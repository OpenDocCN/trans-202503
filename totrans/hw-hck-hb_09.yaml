- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bench Time: Simple Power Analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll introduce a simple laboratory environment that allows
    you to experiment with some code samples. Rather than attack devices we know nothing
    about, we’ll start attacking real devices we have on hand in our lab with specific
    algorithms of our choosing. This practice will allow us to gain experience on
    these kinds of attacks rather than having to do a lot of guessing of what a “closed”
    device is up to. First, we’ll walk through the generics of building the simple
    power analysis (SPA) setup, and then we’ll program an Arduino with an SPA-vulnerable
    password verification and see whether we can extract the password. Finally, we’ll
    perform the same experiment with the ChipWhisperer-Nano. Consider this chapter
    to be like cracking your knuckles to warm up before actually playing the piano.
  prefs: []
  type: TYPE_NORMAL
- en: The Home Lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a simple SPA lab, you need a tool to measure power traces, a target
    device on a power-measurement-enabled circuit board, and a computer that instructs
    the target to perform an operation while recording the device’s power traces and
    input/output.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Basic Hardware Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your lab doesn’t need to be expensive or complicated, as [Figure 9-1](#figure9-1)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09001](image_fi/278748c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: A homemade experimental platform'
  prefs: []
  type: TYPE_NORMAL
- en: This simple home-built lab consists of a USB-connected oscilloscope 1, a target
    device on a breadboard with some electronics enabling measurement 2, and a standard
    computer with a USB-serial adapter 3. The ATmega328P microcontroller, as used
    in an Arduino, is mounted on a special board with a current measurement resistor.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Oscilloscopes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using a regular oscilloscope, the most important requirement is that it’s
    capable of sampling at 100 MS/s (mega-samples per second) or higher on two channels.
    Many oscilloscopes specify a maximum sample rate that you can get only on a single
    channel. If you use two channels, the sample rate on each channel is half of that
    maximum, which means a 100 MS/s scope can sample only at 50 MS/s if you want to
    measure two inputs at once. For these experiments, we’ll use the second channel
    as a trigger only. Your scope may have an external trigger (which still allows
    you to get the maximum sample rate from one channel), but if not, be sure you
    can sample on two channels simultaneously at 100 MS/s or better. Attacking more
    advanced implementations, such as hardware AES, will require much faster sampling
    rates—sometimes 1 GS/s or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Very low-cost generic oscilloscopes may not have a useful computer interface.
    For example, you will find USB-connected oscilloscopes that lack an API to allow
    you to interface with the device. When purchasing an oscilloscope for side-channel
    analysis, make sure you can control the device from your computer and that you
    can quickly download data from the oscilloscope.
  prefs: []
  type: TYPE_NORMAL
- en: Also, pay attention to the sample size buffer. Low-cost devices have a small
    buffer of, say, only 15,000 samples, which will make your work much more difficult.
    This is because you’ll need to trigger the capture at the exact moment of the
    sensitive operation; otherwise, you’ll overflow the oscilloscope’s memory buffer.
    You’ll also be unable to perform certain work, such as simple power analysis on
    longer public-key algorithms that would require a much larger buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Special-purpose sampling devices that allow synchronous sampling can reduce
    your sample rate requirements by keeping a relationship between the device clock
    and your sample clock (like the ChipWhisperer does). See Appendix A for more information
    on oscilloscopes.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Microcontroller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Select a microcontroller that you can program directly and that isn’t running
    any operating system. The Arduino is a perfect choice. Don’t begin your side-channel
    career by attempting to use a target such as a Raspberry Pi or BeagleBone. Those
    products have too many complicating factors, such as the difficulty of getting
    a reliable trigger, high clock speeds, and their operating systems. We’re building
    a skill, so let’s start in easy mode.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Target Board
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first thing we need to build is a microcontroller target board that has
    a shunt resistor inserted into the power line. *Shunt resistor* is a generic term
    we give to a resistor that we insert into a circuit’s path to measure current.
    Current flow through that resistor will cause a voltage to be developed across
    it, and we can measure that voltage using an oscilloscope.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](#figure9-1) shows an example of a test target. [Figure 9-2](#figure9-2)
    details the insertion of a shunt resistor, where the low side of the shunt resistor
    goes to the oscilloscope channel. Ohm’s law tells us that a voltage “developed”
    across a resistor is equal to the resistance multiplied by the current (*V* =
    *I* × *R*). The voltage polarity will be such that a lower voltage is present
    on the low side. If the high side was 3.3 V, and the low side was 2.8 V, this
    means that 0.5 V (3.3 – 2.8) was developed across the resistor.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09002](image_fi/278748c09/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: A shunt resistor makes it easy to measure power consumption.'
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to measure only the voltage across the shunt resistor, we could
    use an instrument called a *differential probe*. With a differential probe, we’ll
    get only the exact voltage across the shunt resistor itself, which should provide
    the most accurate measurement.
  prefs: []
  type: TYPE_NORMAL
- en: An easier method that doesn’t require additional gear (and how we’ll work in
    this lab) is to assume the high side of the shunt resistor is connected to a clean
    and constant voltage power supply, which means any noise on the high side of the
    shunt resistor will add to measurement noise on the low side. We’ll measure power
    consumption across this shunt resistor simply by measuring the voltage on the
    low side, which will be the value of our constant “high side” voltage minus the
    drop on the shunt resistor. As the current increases in the shunt, the voltage
    drop across the shunt increases as well, and thus the “low side” voltage becomes
    smaller.
  prefs: []
  type: TYPE_NORMAL
- en: The resistance value you’ll need for your shunt resistor depends on the current
    power consumption of your target device. Using Ohm’s law, *V* = *I* × *R*, you
    can calculate reasonable resistance values. Most oscilloscopes have good voltage
    resolution of 50 mV to 5 V. The current (*I*) is determined by the device, but
    it will range from dozens of mA for microcontrollers to several A for large System-on-Chips
    (SoCs). For example, if your target is a small microcontroller at 50 mA, you should
    be able to use a resistance of 10 Ω to 50 Ω, but a field-programmable gate array
    (FPGA) with 5 A consumption might require 0.05 Ω to 0.5 Ω. Higher value resistors
    produce a larger voltage drop that provides a strong signal for your oscilloscope,
    but that may reduce the device voltage to such a low point that it stops operating.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](#figure9-3) shows a schematic of the target board 2 from [Figure
    9-1](#figure9-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09003](image_fi/278748c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: A schematic of the target board'
  prefs: []
  type: TYPE_NORMAL
- en: The ATmega328P microcontroller runs the target code, a resistor (R2) allows
    us to take power measurements, and noise filtering of the input voltage source
    is done with C1, C2, C3, and R1\. An external USB-TTL serial adapter is connected
    to the RX and TX line. Note that the digital power supply has *no* decoupling
    capacitors; they would filter out details of the power consumption that contain
    potentially interesting information. You can easily modify this circuit to use
    other microcontrollers if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to be able to program the microcontroller with your target code,
    which might mean moving the physical chip between the target breadboard and the
    Arduino. An Arduino Uno uses the same ATmega328P microcontroller we mentioned
    before, so whenever we say “Arduino,” we just mean a board that can be used to
    program the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Buying a Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’d rather not build your own lab for side-channel analysis, you can purchase
    one. The ChipWhisperer-Nano (shown in [Figure 9-4](#figure9-4)) or the ChipWhisperer-Lite
    (shown in [Figure 9-5](#figure9-5)) replaces all the hardware shown in [Figure
    9-1](#figure9-1) for about US$50 or US$250, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09004](image_fi/278748c09/f09004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: The ChipWhisperer-Nano'
  prefs: []
  type: TYPE_NORMAL
- en: The ChipWhisperer-Nano is a device that allows you to program the included STM32F0
    with various algorithms and perform power analysis. You can break off the included
    target to look at other devices. The glitching functionality is very limited compared
    to the ChipWhisperer-Lite.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09005](image_fi/278748c09/f09005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: The ChipWhisperer-Lite'
  prefs: []
  type: TYPE_NORMAL
- en: The ChipWhisperer-Lite provides capture hardware along with a sample target
    board. The included target is available as either an Atmel XMEGA or STM32F303
    ARM. Beyond side-channel analysis, this device also allows you to perform experiments
    of clock and voltage glitching. Again, you can break off the included target to
    look at more advanced devices. These devices include both the target and the capture
    hardware all on one board. The ChipWhisperer-Lite is an open source design, so
    you can also build it yourself. Alternatively, commercial tools like Riscure’s
    Inspector or CRI’s DPA Workstation are available; they’re developed for higher
    complexity and higher security targets but are outside the average hardware hacker’s
    budget.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Target Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll assume an Arduino as the target for now and afterward demonstrate the
    same attack on a ChipWhisperer-Nano. Regardless of your choice of hardware, you’ll
    need to program the microcontroller to perform the encryption or password check
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](#listing9-1) shows an example of the firmware code you need to
    program into your target.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: Sample microcontroller firmware using Arduino for performing a
    simple operation with a trigger'
  prefs: []
  type: TYPE_NORMAL
- en: The target first reads in a password from the user. Then the target compares
    that password with the stored password 2 (in this case, the hardcoded password
    is `ilovecheese`). A specific I/O line is set high during the password comparison
    operation, allowing you to trigger your oscilloscope into measuring the signal
    during this operation 1.
  prefs: []
  type: TYPE_NORMAL
- en: This firmware has a trick up its sleeve. Even though it uses a leaky string
    comparison 2 (like in our introduction on timing attacks in Listing 8-1), it makes
    timing attacks difficult by doing a random wait of up to 500ms at the end of the
    operation 3, making it ripe for an SPA attack.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the computer side, your work will involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the target device (sending commands and data and receiving
    a response)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the oscilloscope as appropriate (channels, triggers, and scales)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading data from the oscilloscope to the computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the power trace and data sent to the device in a database or file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at the requirements for each of these steps in the next few sections.
    The end objective is to measure the power consumption of a microcontroller while
    executing a simple program, as shown in [Listing 9-1](#listing9-1).
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Target Device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since you’re targeting a device that you program yourself, you can define your
    own communications protocol. In [Listing 9-1](#listing9-1), it’s simply a serial
    interface that reads a password. For simplicity, the “correct” password is hardcoded
    in the program, but in general, it’s good to allow configuration of the “sensitive
    information” (such as the password). This practice allows you to experiment more
    easily (for example, with a longer and shorter password). When you start targeting
    crypto, this practice also holds: configuration of the key material from the computer
    enables experimentation.'
  prefs: []
  type: TYPE_NORMAL
- en: The other part of communication is triggering the oscilloscope. While the target
    device is running the task with the “sensitive operation,” you need to monitor
    the device’s power consumption. [Listing 9-1](#listing9-1) shows triggering, where
    we put a trigger line high right before the comparison occurs and pull it back
    low after the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The Shunt Resistor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shunt resistor’s output signal is fairly strong, and it should be able to
    drive your oscilloscope directly. Connect the signal directly to your oscilloscope
    using the BNC connector input, rather than feed it through the probes, which might
    introduce noise through the ground connection. Also, if your oscilloscope has
    only fixed 10:1 probes, you’ll be reducing the peak-to-peak voltage. After doing
    this, your scope can measure the voltage differentials caused by varying power
    consumption of the target.
  prefs: []
  type: TYPE_NORMAL
- en: Oscilloscope Settings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll need to get a few settings on your scope in the right ballpark: the
    voltage range, coupling, and sampling rate. This is “Oscilloscope 101,” so we’ll
    give only a few brief tips on specifics when doing side-channel captures. More
    details on using scopes can be found in the section “Digital Oscilloscope” in
    Chapter 2. If you need to purchase an oscilloscope, see the section “Viewing Analog
    Waveforms (Oscilloscopes)” in Appendix A.'
  prefs: []
  type: TYPE_NORMAL
- en: The *voltage range* should be selected high enough such that the captured signal
    doesn’t clip. For instance, when you have a 1.3 V signal but your range is set
    to 1.0 V, you’ll lose all information above 1.0 V. On the other hand, it needs
    to be selected low enough so as not to cause quantization errors. This means if
    your range is set to 5 V, but you have a 1.3 V signal, you’ve wasted 3.7 V of
    range. If your scope gives you a choice between 1 V and 2 V, for the 1.3 V signal,
    you’d pick 2 V.
  prefs: []
  type: TYPE_NORMAL
- en: Your scope’s *input coupling* mode isn’t typically too critical. Unless you
    have a good reason not to, just use AC-coupled mode, as it centers the signal
    around the 0 V level. You can use DC-coupled mode and adjust the offset as well
    to achieve the same results. The advantage of AC-coupled mode is that it eliminates
    any gradual shift in voltage or very low-frequency noise that might complicate
    measurements if, for example, the output of your voltage regulator drifts as the
    system warms up. It will also compensate for the DC offset introduced if you are
    using a shunt on the VCC side, as we showed in [Figure 9-2](#figure9-2). DC offsets
    do not typically carry side-channel information.
  prefs: []
  type: TYPE_NORMAL
- en: For the *sampling rate*, the trade-off is increased processing time but better
    capture quality at a higher rate versus faster processing but at a lower quality
    at a lower rate. When getting started, use the rule of thumb that you sample at
    one to five times your target’s clock speed.
  prefs: []
  type: TYPE_NORMAL
- en: Your scope might have other useful features too, such as a 20 MHz *bandwidth
    limit* that can reduce high-frequency noise. You can also introduce analog lowpass
    filters with the same effect. If you were attacking lower-frequency devices, this
    reduction in high-frequency noise would prove useful, but if you were attacking
    a very fast device, you might require data from the higher-frequency components.
    A good practice is to put a bandwidth limiter at about five times your sampling
    rate. For example, a 5 MHz target can be sampled at 10 MS/s and bandwidth limited
    at 50 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to experiment to determine the best measurement setup for any given
    device and algorithm. It’s a good learning experience and will teach you how settings
    affect quality and acquisition speed.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To actually perform the attack, you’ll need some way to download trace data
    to the computer. For simple power analysis attacks, you might be able to do it
    by inspecting the oscilloscope display visually. Any of the more advanced attacks
    will require you to download data from the oscilloscope to the computer.
  prefs: []
  type: TYPE_NORMAL
- en: The method of communicating with your oscilloscope will depend almost entirely
    on the oscilloscope’s vendor. Some vendors have their own library with language
    bindings to use that library in languages such as C and Python. Many other vendors
    rely instead on the *Virtual Instrument Software Architecture (VISA)*, an industry
    standard for communications between test equipment. If your scope supports VISA,
    you should be able to find high-level libraries in almost all languages to help
    you interface with it, such as PyVISA for Python. You’ll need to implement specific
    commands or options for your oscilloscope, but the vendor should provide some
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Data Storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How you store your traces depends almost entirely on your planned analysis platform.
    If you’re planning on doing the analysis entirely in Python, you might look for
    the storage format that works with the popular NumPy library. If using MATLAB,
    you would take advantage of the native MATLAB file format. If you plan on experimenting
    with distributed computing, you’ll need to investigate the preferred filesystem
    for your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: When working with really large trace sets, the storage format will matter, and
    you’ll want to optimize it for fast linear access. In professional labs, sets
    of 1TB are no exception. On the other hand, for your initial work and investigation,
    your data storage requirements should be fairly small. Attacking a software implementation
    on an 8-bit microcontroller may take only 10 or 20 power measurements, so almost
    anything better than copy/pasting the data out of a spreadsheet will work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Pulling It Together: An SPA Attack'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our fresh setup, let’s perform the actual SPA attack, working with the
    code from [Listing 9-1](#listing9-1). As mentioned previously, this code has a
    leaky password comparison. The random wait at the end of the code hides the timing
    leak, so it’s not directly exploitable through timing. We’ll have to look closer,
    using SPA on traces, to see whether we can identify the individual character comparisons.
    If the traces give away which character is incorrect, we can do a very limited
    brute-force attack to recover the password, exactly like we did in the pure timing
    attacks in Chapter 8.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll need to do a bit of additional preparation on our Arduino. Then,
    we’ll measure power traces when we provide correct, partially correct, and incorrect
    passwords. If these traces reveal the index of the first wrong character, we can
    brute-force the rest to recover the correct password.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate a no-soldering approach to capturing traces, we need to extend
    the setup shown in [Figure 9-1](#figure9-1). We basically take an Arduino Uno
    and simply move the ATmega328P microcontroller onto a breadboard (see [Figure
    9-6](#figure9-6)). As mentioned earlier, we need the current shunt in the VCC
    pin, which is why we can’t just use a regular Arduino board (at least without
    doing some soldering).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09006](image_fi/278748c09/f09006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: The humble Arduino used as a side-channel analysis attack target'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-7](#figure9-7) shows details of the required wiring for the Arduino
    Uno.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09007](image_fi/278748c09/f09007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-7: Details of the required wiring for the Arduino Uno (this image
    was created with Fritzing).'
  prefs: []
  type: TYPE_NORMAL
- en: Pins 9 and 10 are wired from the empty integrated circuit (IC) socket, where
    the microcontroller used to be, onto the breadboard. These jumper wires bring
    the crystal frequency from the board as needed by the microcontroller IC. The
    wires should be as short as possible. It’s not a great idea to wire these sensitive
    lines outside the board like we’ve done, but in practice, it tends to work. If
    you have trouble getting the system operating, it might be that these lines are
    too long.
  prefs: []
  type: TYPE_NORMAL
- en: The value of resistors and capacitors is not critical. The resistors here are
    100 Ω, but anything from 22–100 Ω should work. Capacitors in the range of 100μF
    to 330μF will work. (The schematic in [Figure 9-3](#figure9-3) shows some details.
    Note that Y1, C5, and C6 shown in [Figure 9-3](#figure9-3) are not required here
    as those parts are on the Arduino baseboard instead.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Arduino has been modded for power measurements, we program the
    code from [Listing 9-1](#listing9-1). After connecting with a serial terminal,
    you should have a prompt where you can enter your password (see [Figure 9-8](#figure9-8)).
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to test that the code behaves correctly for both a valid and an invalid
    password. You can do so by typing in a password manually or making a test program
    that communicates with the target code directly. At this point, you are ready
    for an attack!
  prefs: []
  type: TYPE_NORMAL
- en: '![f09008](image_fi/278748c09/f09008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-8: Serial output from the programmed Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Oscilloscope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Set your oscilloscope to trigger on the digital I/O line in use. We use “Digital
    IO 2,” which is pin 4 on the ATmega328P chip. The code on the target pulls the
    line high just before the sensitive operation (in this case, the password comparison).
  prefs: []
  type: TYPE_NORMAL
- en: First, experiment by sending the same password repeatedly. You should get very
    similar looking traces. If not, go debug your setup. Your trigger may not be caught
    by the oscilloscope, or maybe your test program isn’t running correctly. The trace
    captures left of the dotted line in the upcoming [Figure 9-9](#figure9-9) provide
    an idea of how similar the traces should look.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re convinced that the measurement setup is working, experiment with
    various oscilloscope settings, heeding our advice from the previous section. An
    Arduino Uno runs at 16 MHz, so set your oscilloscope to anything between 20 MS/s
    and 100 MS/s. Tune your scope range to fit the signal snugly without clipping.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of build, we’ve used oscilloscope probes. As mentioned earlier, this
    will produce some signal loss compared to feeding a BNC-connected wire into the
    scope directly. On this target, there’s plenty of signal, so it’s not a big deal.
  prefs: []
  type: TYPE_NORMAL
- en: If you have oscilloscope probes that are switchable between 10× and 1×, you
    may find they work much better in the 1× position. The 1× position provides less
    noise, but with a greatly reduced bandwidth. For this specific case, the lower
    bandwidth is actually helpful, so we prefer to use the 1× setting. If your oscilloscope
    has a bandwidth limit (many have a 20 MHz bandwidth limit option), enable it to
    see whether the signal becomes clearer. If you are looking at picking up an oscilloscope
    for this, we’ll cover what sort of options you might need in Appendix A.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of the Signal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can start to experiment with different passwords; you should see a
    noticeable difference when sending the correct and incorrect passwords. [Figure
    9-9](#figure9-9) shows an example of the power measurement recorded with different
    passwords when running: the power traces for the correct password (top, `ilovecheese`),
    a fully incorrect password (bottom, `test`), and a partially correct password
    (middle, `iloveaaaaaa`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09009](image_fi/278748c09/f09009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-9: Power traces are shown for correct, partially correct, and incorrect
    passwords; arrows indicate character-comparison operation. The black signal overlaying
    each trace is the trigger signal.'
  prefs: []
  type: TYPE_NORMAL
- en: A clear difference is visible between the top two traces and the bottom trace.
    The string comparison function more quickly detects if the number of characters
    differs—the bottom trace shows a shorter trigger signal. The more interesting
    area is where the same number of characters is compared but with incorrect values,
    as shown in the top and middle traces. For those traces, the power signature is
    the same up until the dashed line, after which the character comparisons start.
    By carefully inspecting the correct password, you can see about 11 repeated segments,
    indicated by the arrows, which perfectly match the 11 characters of `ilovecheese`.
  prefs: []
  type: TYPE_NORMAL
- en: Now by looking at the `iloveaaaaaa` password trace in the middle, you can see
    only five such segments. Each “segment” means a single iteration through some
    comparison loop, so the number of these segments corresponds to the length of
    the correct password prefix. As with the timing attack in Chapter 8, that means
    we only must guess each possible input character, one at a time, and that means
    we can guess the password very quickly (assuming we write a script to do this).
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the Communication and Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll want to have interfaced both the oscilloscope and target to some programming
    environment for this section. This interface will allow you to write a script
    to send arbitrary passwords while noting the power measurement. We will use this
    script to determine how many initial characters were accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The specifics of this script will depend a lot on what system you’re using to
    download data from an oscilloscope. [Listing 9-2](#listing9-2) shows a script
    that works with a PicoScope USB device and the Arduino password-checking code.
    You’ll need to tweak the settings for your specific target; it’s not just a copy-paste-run
    task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: A sample script to connect a computer to a PicoScope 2000 series
    along with its Arduino target'
  prefs: []
  type: TYPE_NORMAL
- en: The Python script in [Listing 9-2](#listing9-2) will display a diagram like
    the one shown in [Figure 9-10](#figure9-10). Note that the markers in this diagram
    were added with additional code not shown in [Listing 9-2](#listing9-2). If you
    want to see the exact marker generation code, look at the companion repository,
    which includes the code used to generate [Figure 9-10](#figure9-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09010](image_fi/278748c09/f09010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-10: Two power traces of two different password guesses (correct marked
    with circles; incorrect marked with squares)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-10](#figure9-10) is zoomed in compared to [Figure 9-9](#figure9-9),
    with the comparison starting at sample 148\. The solid line is for the correct
    password; the partially correct password is shown with dashes. You can observe
    that every 25 samples, starting at sample number 148, a pattern is repeated—seemingly
    one pattern per comparison. The lines overlap for five of the comparisons. Notice
    at sample number 273 the correct password and partially correct password have
    diverged, which coincides with the idea that the first five characters (`ilove`)
    are the same between both password guesses. To emphasize this, we’ve marked the
    value of the correct password power trace with circles every 25 samples, and the
    value of the incorrect password power trace with squares every 25 samples. Notice
    the square and circle are close to each other for the first five marked locations,
    but on the sixth location, it is noticeably different.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to script this attack, we can compare the sample value of the power
    trace every 25 samples, starting at sample 148\. Taking the markers from [Figure
    9-10](#figure9-10), we can see that there is some threshold voltage around 1.2
    V that could be used to separate the good and bad iterations.
  prefs: []
  type: TYPE_NORMAL
- en: How did we know the comparison started at sample point 148? You can determine
    the start of the comparison by using the “fully incorrect” password, which should
    show divergence as soon as the comparison starts. To do this, you’ll have to add
    to the list of guessed passwords a third option that sends a fully incorrect password,
    such as `aaaaaaaaaaa`.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve used the “squint at traces” technique to identify the segments, which
    is the usual starting point for SPA, but in order to script this, we need to be
    a bit more accurate. We need a *distinguisher* that tells a script whether there
    is a segment. With that in mind, we devised the following rule: a character comparison
    segment index *i* is detected as being successful if there is a peak *larger*
    than 1.2 V at sample 148 + 25*i*. You’ll notice in [Figure 9-10](#figure9-10)
    the incorrect password diverged at sample 273, and at that time the incorrect
    password trace had a value of about 1.06 V. Note traces can be noisy and may require
    you to add filtering onto the signal or to check a few times to confirm your results
    match.'
  prefs: []
  type: TYPE_NORMAL
- en: You also need to use a search on an area around the sample by ± 1 samples because
    the oscilloscope may have some jitter. A quick check in [Figure 9-10](#figure9-10)
    shows that this should work. With that knowledge, we can build the Python script
    in [Listing 9-3](#listing9-3), which automatically guesses the correct password.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: A sample script to exploit the leakage discovered and guess a
    password'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script implements the basic SPA attack: it captures a password check,
    uses the height of the peak at 148 + 25*i* to determine if character *i* is correct,
    and simply loops through all characters until the full password is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '`****FOUND PASSWORD = ilovecheese`'
  prefs: []
  type: TYPE_NORMAL
- en: This script is a bit slow to keep things simple. There are two areas for improvement.
    First, the timeout in the `serial.read()` function is set always to wait for 500ms.
    We could instead look for the newline (`\n`) and stop trying to read more data.
    Second, the password-checker firmware in the Arduino has a delay when a wrong
    password is entered. We could use an I/O line to reset the Arduino chip after
    every attempt to skip that delay. We’ll leave those improvements as an exercise
    for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at your traces, you will need to very carefully scrutinize the
    power traces. Depending on where you position your distinguisher, you may need
    to flip the sign of the comparison for this example to work. There will be multiple
    locations showing the leakage, so minor adjustments in the code may change your
    results.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to see this example running on known hardware, the companion
    notebook (see [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))
    shows how to use a ChipWhisperer-Nano or ChipWhisperer-Lite to communicate with
    the Arduino target. In addition, the companion notebook includes “pre-recorded”
    power traces so you can run this example without hardware. However, we can make
    this attack more consistent by targeting one of the built-in targets instead of
    the Arduino you built, which we’ll look at next. In addition, we’ll work to make
    a more automated attack that doesn’t require us to manually determine the location
    and value of the distinguisher.
  prefs: []
  type: TYPE_NORMAL
- en: ChipWhisperer-Nano Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s examine a similar attack on the ChipWhisperer-Nano that includes the
    target, programmer, oscilloscope, and serial port all in one package, which means
    we can concentrate on the sample code and automate the attack. As in other chapters,
    you’ll use a companion notebook ([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/));
    open that up if you have a ChipWhisperer-Nano.
  prefs: []
  type: TYPE_NORMAL
- en: Building and Loading Firmware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you need to build the sample software (similar to [Listing 9-1](#listing9-1))
    for the STM32F0 microcontroller target. You don’t need to write your own code,
    as you’ll use the source code that’s part of the ChipWhisperer project. Building
    the firmware simply requires calling `make` from the notebook with the appropriate
    platform specified, as shown in [Listing 9-4](#listing9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: Building the `basic-passwdcheck` firmware, similar to [Listing
    9-1](#listing9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You can then connect to the target and program the onboard STM32F0 with the
    notebook code in [Listing 9-5](#listing9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: Initial setup and programming the included target with our custom
    firmware'
  prefs: []
  type: TYPE_NORMAL
- en: This code creates some default settings for performing the power analysis and
    then programs the firmware hex file built in [Listing 9-4](#listing9-4).
  prefs: []
  type: TYPE_NORMAL
- en: A First Glance at the Communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, let’s look at what boot messages the device is printing on reset. The
    notebook environment has a function called `reset_target()` that toggles the `nRST`
    line to perform a target reset, after which we can record the serial data coming
    in. To do this, we’ll run the code from [Listing 9-6](#listing9-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: Resetting the device and reading the boot messages'
  prefs: []
  type: TYPE_NORMAL
- en: This reset results in the boot messages shown in [Listing 9-7](#listing9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: The boot messages from the demo password check code'
  prefs: []
  type: TYPE_NORMAL
- en: Looks like some serious boot security . . . but perhaps we can use SPA to attack
    the password comparison. Let’s see what’s actually implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing a Trace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the ChipWhisperer integrates everything into one platform, it’s much
    easier to build a function that performs a power capture on the password comparison.
    The code in [Listing 9-8](#listing9-8) defines a function that captures the power
    trace with a given test password. Most of this code is actually just waiting for
    the boot messages to end, after which the target is waiting for a password to
    be input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: Function to record the power trace of the target processing any
    arbitrary password'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we simply use `scope.arm()` to tell the ChipWhisperer to wait for the
    trigger event. We send the password to the target, at which point the target will
    perform the password check. Our cooperative target is telling ChipWhisperer the
    moment the comparison is starting through the trigger (in this case, a GPIO pin
    going high, which is the little bit of a cheat we added to the target firmware).
    Finally, we record the power trace and pass it back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: With that function defined, we could run [Listing 9-9](#listing9-9) to capture
    the trace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: Capturing the trace for a particular password'
  prefs: []
  type: TYPE_NORMAL
- en: That code should generate the power trace shown in [Figure 9-11](#figure9-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09011](image_fi/278748c09/f09011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-11: The power consumption of the device as it is processing a particular
    password'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the ability to take a power trace for a particular password,
    let’s see if we can turn it into an attack.
  prefs: []
  type: TYPE_NORMAL
- en: From Trace to Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As before, the first step is simply sending several different passwords and
    seeing whether we notice a difference between them. The code in [Listing 9-10](#listing9-10)
    sends five different single-character passwords: `0`, `a`, `b`, `c`, or `h`. It
    then generates a plot of the power traces during processing of those passwords.
    (In this case, we’ve cheated, as we know the correct password starts with `h`,
    but we want to make the resulting figures reasonably visible. In reality, you
    may have to look at multiple figures to find the outlier—for example, by grouping
    initial characters `a`–`h`, `i`–`p`, `q`–`x`, and `y`–`z` into separate plots.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: A simple test of five password first characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting traces are plotted in [Figure 9-12](#figure9-12), which shows
    the first 100 samples of the power consumption as the device processes two of
    the five different password first characters. One of the characters is the correct
    start to the password. Around sample 18, the power consumption of different characters
    starts to deviate. This is due to the timing leak: if the loop exits early (because
    the first character is wrong), the resulting code execution follows a different
    path from when the first character is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09012](image_fi/278748c09/f09012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-12: Power consumption for five different initial characters'
  prefs: []
  type: TYPE_NORMAL
- en: If we were to zoom in on [Figure 9-12](#figure9-12) and plot all five power
    traces, we would see that four characters have pretty much the same power trace,
    and one is the clear outlier. We would guess that the outlier is the correct first
    character, as only one character can be correct. We then build up a guess using
    the correct first character and do the same analysis for the unknown second character.
  prefs: []
  type: TYPE_NORMAL
- en: Using SAD to Find the Password (and Become Happy)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than fine-tune the timing of particular peaks as we did earlier in this
    chapter, we could try to be a bit cleverer and possibly more generic. First, we
    could assume we know a password that will always fail the first character comparison.
    We’ll make an “invalid password template power trace” and compare each following
    trace to the template. In this case, we’ll use a single character set to hex 0x00
    as an invalid password. If we see a major difference between the template and
    the power trace of the device processing a particular character, it suggests that
    that particular character is correct.
  prefs: []
  type: TYPE_NORMAL
- en: A simple method of comparing two arrays is a *sum of absolute difference (SAD)*.
    To calculate the SAD, we find the difference between each point in two traces,
    turn it into an absolute number, then sum up those points. The SAD is a measure
    of how alike two traces are, where 0 means they are exactly the same, and higher
    numbers mean traces are less alike (see [Figure 9-13](#figure9-13)).
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t sum up the points and look only at the absolute difference, we can
    see some interesting patterns. In [Figure 9-13](#figure9-13), we’ve taken the
    invalid password trace and calculated the absolute difference with two traces.
    One trace was taken using a password with the wrong first character (such as `e`),
    shown as the bottom line with peak far above 0.1\. The other trace was taken with
    a password with the correct first character (`h`), shown as the top noisy line
    that hovers just above 0\. The difference at each point is much larger for the
    correct password. We can now sum up all those points, effectively calculating
    the SAD. We should get a large value for the incorrect character and a much smaller
    value for the correct character.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09013](image_fi/278748c09/f09013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-13: Absolute differences in traces for a correct (top) and incorrect
    (bottom) first password character'
  prefs: []
  type: TYPE_NORMAL
- en: A Single-Character Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because we now have a “goodness” metric in the form of SAD, we can automate
    the attack for the first character. The code in [Listing 9-11](#listing9-11) shows
    a script that runs through a guess list (in this case, lowercase letters and numbers)
    and checks whether any of them results in an obviously different code path. If
    so, it flags that as a likely correct password character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: Testing a single character against a known-bad password.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to adjust the threshold for your setup at 2, which is most easily
    done by uncommenting the `print` statement at 1 and checking what differences
    look like for good and bad passwords.
  prefs: []
  type: TYPE_NORMAL
- en: A Full Password Recovery
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Building this into a full attack requires only slightly more effort, as implemented
    in [Listing 9-12](#listing9-12). As mentioned previously, our template is built
    using a single-character bad password. Now that we’ve used that template to guess
    the first character, we need another template that represents “first character
    correct, second character wrong.” We do that by capturing a new template from
    the power consumption of the guessed first password character, plus another 0x00.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-12: A full attack script that automatically discovers the password'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve built in a mechanism to validate that the new template is representative.
    The captures can sometimes be noisy, and a noisy reference trace will generate
    false positives. So, a new template is created by grabbing two power traces with
    the same (invalid) password and making sure that the SAD is below some threshold
    at 1. You’ll have to tune this threshold for your setup as well.
  prefs: []
  type: TYPE_NORMAL
- en: A more robust solution would be to average several traces or to detect a trace
    that is an outlier from the full set automatically. The two magic numbers `50`
    and `80` in [Listing 9-12](#listing9-12), however, are the shortest way to accomplish
    the goal.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code should print the full password of `h0px3`. That’s an SPA timing
    attack in just a handful of Python lines.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter concentrated on how to perform a simple timing attack using power
    analysis. You can use the methods described here for all sorts of attacks on real
    systems. The only way to get a good handle on them is through hands-on experimentation.
    When it comes time to attacking real systems, you’ll also learn that the first
    step is almost always to characterize the system. These characterizations take
    the same form as the experiments you did here, such as simply measuring what sort
    of leakage you can find.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try public-key cryptography for the SPA examples, you could use
    an open source library like avr-crypto-lib. You’ll even find ports of this library
    to Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: The ChipWhisperer platform helps abstract away some of the dirty low-level hardware
    details, so you can concentrate on the more interesting high-level aspects of
    the attack. The ChipWhisperer site includes tutorials and Python-based sample
    code to interface to a variety of devices, including various oscilloscopes, serial
    port drivers, and smartcard readers. Not all targets are part of the ChipWhisperer
    platform, so for that reason, it can be beneficial to implement “bare-metal” attacks
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll expand on this simple attack to read data out of a device under
    test. Doing so means not only seeing what sort of program flow is occurring, but
    also actually determining the secret data being used.
  prefs: []
  type: TYPE_NORMAL
