- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Table Design That Works for You
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为你设计的表格
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Obsession with order and detail can be a good thing. When you’re running out
    the door, it’s reassuring to see your keys hanging on the hook where you *always*
    leave them. The same holds true for database design. When you need to excavate
    a nugget of information from dozens of tables and millions of rows, you’ll appreciate
    a dose of that same detail obsession. With data organized into a finely tuned,
    smartly named set of tables, the analysis experience becomes much more manageable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对秩序和细节的执着有时是件好事。当你匆忙出门时，看到钥匙挂在你*总是*放的地方的钩子上会让你安心。数据库设计同样如此。当你需要从数十个表和数百万行中挖掘出一条信息时，你会感谢这种对细节的执着。有了经过精心组织、命名得当的表格，分析过程变得更加可控。
- en: In this chapter, I’ll build on Chapter 7 by introducing best practices for organizing
    and speeding up SQL databases, whether they’re yours or ones you inherit for analysis.
    We’ll dig deeper into table design by exploring naming rules and conventions,
    ways to maintain the integrity of your data, and how to add indexes to tables
    to speed up queries.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将在第七章的基础上，介绍如何组织和加速 SQL 数据库的最佳实践，无论是你自己的，还是你继承来进行分析的数据库。我们将深入探讨表格设计，探索命名规则和约定、如何维护数据完整性，以及如何为表格添加索引以加速查询。
- en: Following Naming Conventions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循命名约定
- en: Programming languages tend to have their own style patterns, and even various
    factions of SQL coders prefer certain conventions when naming tables, columns,
    and other objects (called *identifiers*). Some like *camel case*, as in `berrySmoothie`,
    where words are strung together and the first letter of each word is capitalized
    except for the first word. *Pascal case*, as in `BerrySmoothie`, follows a similar
    pattern but capitalizes the first letter too. With *snake case*, as in `berry_smoothie`,
    all the words are lowercase and separated by underscores.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言往往有自己的风格模式，甚至不同的 SQL 编码者群体在命名表格、列和其他对象（称为*标识符*）时也偏好某些约定。有些人喜欢使用*驼峰式命名法*，如
    `berrySmoothie`，其中单词连写，且每个单词的首字母大写（除了第一个单词）。*帕斯卡式命名法*，如 `BerrySmoothie`，遵循类似的模式，但首字母也大写。使用*蛇形命名法*，如
    `berry_smoothie`，所有单词都小写，并用下划线分隔。
- en: You’ll find passionate supporters of each naming convention, with some preferences
    tied to individual database applications or programming languages. For example,
    Microsoft uses Pascal case in the documentation for its SQL Server database. In
    this book, for PostgreSQL-related reasons I’ll explain in a moment, we’re using
    snake case, as in the table `us_counties_pop_est_2019`. Whichever convention you
    prefer or find yourself required to use, it’s important to apply it consistently.
    Be sure to check whether your organization has a style guide or offer to collaborate
    on one, and then follow it religiously.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现每种命名约定都有热情的支持者，有些偏好与特定的数据库应用程序或编程语言有关。例如，Microsoft 在其 SQL Server 数据库文档中使用帕斯卡式命名法。在本书中，出于
    PostgreSQL 相关的原因，我稍后会解释，我们使用蛇形命名法，如 `us_counties_pop_est_2019`。无论你喜欢哪种约定，或者你被要求使用哪种约定，重要的是要始终如一地应用它。一定要检查你的组织是否有风格指南，或者主动提议一起制定，并严格遵守。
- en: 'Mixing styles or following none generally leads to a mess. For example, imagine
    connecting to a database and finding the following collection of tables:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 混合风格或不遵循任何约定通常会导致混乱。例如，想象一下连接到数据库并发现以下一组表格：
- en: '`Customers`'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Customers`'
- en: '`customers`'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customers`'
- en: '`custBackup`'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`custBackup`'
- en: '`customer_analysis`'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customer_analysis`'
- en: '`customer_test2`'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customer_test2`'
- en: '`customer_testMarch2012`'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customer_testMarch2012`'
- en: '`customeranalysis`'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customeranalysis`'
- en: You would have questions. For one, which table actually holds the current data
    on customers? A disorganized naming scheme—and a general lack of tidiness—makes
    it hard for others to dive into your data and makes it challenging for you to
    pick up where you left off.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会有疑问。例如，哪张表格实际上包含客户的当前数据？一个混乱的命名方案——以及缺乏条理性——使得别人很难进入你的数据，也让你自己在接着上次的工作时感到困难。
- en: Let’s explore considerations related to naming identifiers and suggestions for
    best practices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索与命名标识符相关的注意事项以及最佳实践建议。
- en: Quoting Identifiers Enables Mixed Case
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引号标识符启用混合大小写
- en: 'Regardless of any capitalization you supply, PostgreSQL treats identifiers
    as lowercase unless you place double quotes around the identifier. Consider these
    two `CREATE TABLE` statements for PostgreSQL:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你提供什么样的大小写，PostgreSQL 都将标识符视为小写，除非你将双引号括住标识符。请看以下 PostgreSQL 的 `CREATE TABLE`
    语句：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you execute these statements in order, the first command creates a table
    called `customers`. The second statement, rather than creating a separate table
    called `Customers`, will throw an error: `relation "customers" already exists`.
    Because you didn’t quote the identifier, PostgreSQL treats `customers` and `Customers`
    as the same identifier, disregarding the case. To preserve the uppercase letter
    and create a separate table named `Customers`, you must surround the identifier
    with quotes, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按顺序执行这些语句时，第一个命令创建了一个名为`customers`的表。第二个语句并不是创建一个名为`Customers`的单独表，而是会抛出一个错误：`relation
    "customers" already exists`。因为你没有给标识符加引号，PostgreSQL将`customers`和`Customers`视为相同的标识符，不区分大小写。为了保留大写字母并创建一个名为`Customers`的独立表，你必须将标识符用引号括起来，像这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, because this requires that to query `Customers` rather than `customers`,
    you have to quote its name in the `SELECT` statement:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为这要求你在`SELECT`语句中查询`Customers`而不是`customers`时，必须对其名称加引号：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That can be a chore to remember and makes a user vulnerable to a mix-up. Make
    sure your tables have names that are clear and distinct from other tables in the
    database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很难记住，也容易让用户混淆。确保你的表名清晰，并且与数据库中的其他表区分开。
- en: Pitfalls with Quoting Identifiers
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用标识符的陷阱
- en: Quoting identifiers also allows you to use characters not otherwise allowed,
    including spaces. That may appeal to some folks, but there are negatives. You
    may want to throw quotes around `"trees planted"` as a column name in a reforestation
    database, but then all users will have to provide quotes on every reference to
    that column. Omit the quotes in a query, and the database will respond with an
    error, identifying `trees` and `planted` as separate columns and responding that
    `trees` does not exist. A more readable and reliable option is to use snake case,
    as in `trees_planted`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 引用标识符还允许你使用其他情况下不被允许的字符，包括空格。对于某些人来说，这可能是一个吸引人的特性，但也有一些负面影响。你可能希望在重新造林数据库中将`"trees
    planted"`作为列名，但是这样所有用户在引用该列时都必须加上引号。如果在查询中省略引号，数据库会报错，认为`trees`和`planted`是不同的列，并提示`trees`列不存在。一个更具可读性和可靠性的选择是使用蛇形命名法，例如`trees_planted`。
- en: Quotes also let you use SQL *reserved keywords*, which are words that have special
    meaning in SQL. You’ve already encountered several, such as `TABLE`, `WHERE`,
    or `SELECT`. Most database developers frown on using reserved keywords as identifiers.
    At a minimum it’s confusing, and at worst neglecting or forgetting to quote that
    keyword later may result in an error because the database will interpret the word
    as a command instead of an identifier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 引号还允许你使用SQL的*保留关键字*，即在SQL中具有特殊意义的单词。你已经遇到过一些，比如`TABLE`、`WHERE`或`SELECT`。大多数数据库开发人员不推荐将保留关键字用作标识符。至少这会造成混淆，最糟糕的是，忽略或忘记稍后引用该关键字时，可能会导致错误，因为数据库会将该单词解释为命令，而不是标识符。
- en: Guidelines for Naming Identifiers
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名标识符的指南
- en: 'Given the extra burden of quoting and its potential problems, it’s best to
    keep your identifier names simple, unquoted, and consistent. Here are my recommendations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到引用标识符的额外负担及其潜在问题，最好保持标识符名称简单、不加引号且一致。以下是我的建议：
- en: 'Use snake case. Snake case is readable and reliable, as shown in the earlier
    `trees_planted` example. It’s used throughout the official PostgreSQL documentation
    and helps make multiword names easy to understand: `video_on_demand` makes more
    sense at a glance than `videoondemand`.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用蛇形命名法（snake case）。蛇形命名法具有良好的可读性和可靠性，如前面提到的`trees_planted`示例所示。它在官方PostgreSQL文档中被广泛使用，并帮助使多单词的名称更容易理解：`video_on_demand`比`videoondemand`一目了然。
- en: Make names easy to understand and avoid cryptic abbreviations. If you’re building
    a database related to travel, `arrival_time` is a clearer column name than `arv_tm`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使名称易于理解，避免使用晦涩的缩写。如果你正在构建一个与旅游相关的数据库，`arrival_time`比`arv_tm`更容易理解。
- en: For table names, use plurals. Tables hold rows, and each row represents one
    instance of an entity. So, use plural names for tables, such as `teachers`, `vehicles`,
    or `departments`. I do make exceptions at times. For example, to preserve the
    names of imported CSV files, I use them as a table name, especially when they
    are one-off imports.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于表名，使用复数形式。表格包含行，每一行代表实体的一个实例。因此，表名应该使用复数形式，如`teachers`、`vehicles`或`departments`。有时我会做例外。例如，为了保留导入的CSV文件名，我会将它们作为表名，特别是在它们是一次性导入的情况下。
- en: 'Mind the length. The maximum number of characters allowed for an identifier
    name varies by database application: the SQL standard is 128 characters, but PostgreSQL
    limits you to 63, and older Oracle systems have a maximum of 30\. If you’re writing
    code that may get reused in another database system, lean toward shorter identifier
    names.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意长度。不同数据库应用程序允许的标识符名称的最大字符数不同：SQL标准为128个字符，但PostgreSQL限制为63个字符，而旧版Oracle系统的最大值为30。如果你编写的代码可能在其他数据库系统中重用，建议使用较短的标识符名称。
- en: When making copies of tables, use names that will help you manage them later.
    One method is to append a `_YYYY_MM_DD` date to the table name when you create
    the copy, such as `vehicle_parts_2021_04_08`. An additional benefit is that the
    table names will sort in date order.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复制表时，请使用有助于以后管理的名称。一种方法是在创建副本时将`_YYYY_MM_DD`日期附加到表名中，例如`vehicle_parts_2021_04_08`。另一个好处是，表名将按日期排序。
- en: Controlling Column Values with Constraints
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用约束控制列值
- en: 'You can maintain further control over the data a column will accept by using
    certain constraints. A column’s data type broadly defines the kind of data it
    will accept: integers versus characters, for example. Additional constraints let
    us further specify acceptable values based on rules and logical tests. With constraints,
    we can avoid the “garbage in, garbage out” phenomenon, which happens when poor-quality
    data results in inaccurate or incomplete analysis. Well-designed constraints help
    maintain the quality of the data and ensure the integrity of the relationships
    among tables.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用某些约束进一步控制列接受的数据。列的数据类型广泛定义了它将接受的数据类型，例如整数与字符。额外的约束让我们根据规则和逻辑测试进一步指定可接受的值。通过约束，我们可以避免“垃圾进，垃圾出”的现象，即当低质量数据导致分析结果不准确或不完整时。设计良好的约束有助于维护数据质量，并确保表之间关系的完整性。
- en: 'In Chapter 7, you learned about *primary* and *foreign keys*, which are two
    of the most commonly used constraints. SQL also has the following constraint types:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，你学习了*主键*和*外键*，它们是最常用的两种约束。SQL还具有以下约束类型：
- en: '`CHECK` Allows only those rows where a supplied Boolean expression evaluates
    to `true`'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CHECK` 仅允许布尔表达式求值为`true`的行'
- en: '`UNIQUE` Ensures that values in a column or group of columns are unique in
    each row in the table'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UNIQUE` 确保某一列或列组合中的值在每一行中都是唯一的'
- en: '`NOT NULL` Prevents `NULL` values in a column'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NOT NULL` 防止列中出现`NULL`值'
- en: 'We can add constraints in two ways: as a *column constraint* or as a *table
    constraint*. A column constraint applies only to that column. We declare it with
    the column name and data type in the `CREATE TABLE` statement, and it gets checked
    whenever a change is made to the column. With a table constraint, we can supply
    criteria that apply to one or more columns. We declare it in the `CREATE TABLE`
    statement immediately after defining all the table columns, and it gets checked
    whenever a change is made to a row in the table.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式添加约束：作为*列约束*或*表约束*。列约束仅适用于该列。在`CREATE TABLE`语句中，我们用列名和数据类型声明它，每次修改该列时都会进行检查。而表约束则适用于一个或多个列。在`CREATE
    TABLE`语句中，我们在定义完所有表列后立即声明它，并且每次修改表中行时都会进行检查。
- en: Let’s explore these constraints, their syntax, and their usefulness in table
    design.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些约束、它们的语法以及它们在表设计中的实用性。
- en: 'Primary Keys: Natural vs. Surrogate'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主键：自然主键与代理主键
- en: 'As explored in Chapter 7, a *primary key* is a column or collection of columns
    whose values uniquely identify each row in a table. A primary key is a constraint,
    and it imposes two rules on the column or columns that make up the key:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如第7章所述，*主键*是一个列或多个列的集合，其值唯一标识表中的每一行。主键是一种约束，它对组成主键的列或列集合施加两条规则：
- en: Values must be unique for each row.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行的值必须是唯一的。
- en: No column can have missing values.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何列都不能有缺失值。
- en: In a table of products stored in a warehouse, the primary key could be a column
    of unique product codes. In the simple primary key examples in “Relating Tables
    with Key Columns” in Chapter 7, our tables had a primary key made from a single
    ID column with an integer inserted by us, the user. Often, the data will suggest
    the best path and help us decide whether to use a *natural key* or a *surrogate
    key* as the primary key.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储在仓库中的产品表中，主键可以是一个包含唯一产品代码的列。在第7章“通过键列关联表格”的简单主键示例中，我们的表格有一个由我们（用户）插入的整数构成的单一ID列的主键。通常，数据会暗示最佳路径，并帮助我们决定是否使用*自然键*或*替代键*作为主键。
- en: Using Existing Columns for Natural Keys
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用现有列作为自然键
- en: 'A natural key uses one or more of the table’s existing columns that meet the
    criteria for a primary key: unique for every row and never empty. Values in the
    columns can change as long as the new value doesn’t cause a violation of the constraint.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自然键使用表格中现有的一列或多列，这些列符合主键的标准：每行唯一且永不为空。列中的值可以更改，只要新值不违反约束。
- en: 'A natural key might be a driver’s license identification number issued by a
    local Department of Motor Vehicles. Within a governmental jurisdiction, such as
    a state in the United States, we’d reasonably expect that all drivers would receive
    a unique ID on their licenses, which we could store as `driver_id`. However, if
    we were compiling a national driver’s license database, we might not be able to
    make that assumption; several states could independently issue the same ID code.
    In that case, the `driver_id` column may not have unique values and cannot be
    used as the natural key. As a solution, we could create a *composite primary key*
    by combining `driver_id` with a column holding the state name, which would give
    us a unique combination for each row. For example, both rows in this table have
    a unique combination of the `driver_id` and `st` columns:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自然键可能是由地方车辆管理部门发放的驾驶证号码。在美国这样的一个政府管辖区内，我们可以合理地预期所有司机会在他们的驾驶证上获得一个唯一的ID，我们可以将其存储为`driver_id`。然而，如果我们正在编制一个全国性的驾驶证数据库，我们可能无法做出这样的假设；多个州可能会独立地发放相同的ID代码。在这种情况下，`driver_id`列可能没有唯一值，不能作为自然键使用。作为解决方案，我们可以通过将`driver_id`与存储州名的列结合来创建一个*复合主键*，这将为每一行提供唯一的组合。例如，表中的这两行有一个唯一的`driver_id`和`st`列组合：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll visit both approaches in this chapter, and as you work with data, keep
    an eye out for values suitable for natural keys. A part number, a serial number,
    or a book’s ISBN are all good examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨这两种方法，随着你处理数据时，留意那些适合自然键的值。部件号、序列号或书籍的ISBN号都是很好的例子。
- en: Introducing Columns for Surrogate Keys
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引入替代键列
- en: 'A *surrogate* key is a single column that you fill with artificial values;
    we might use it when a table doesn’t have data that supports creating a natural
    primary key. The surrogate key might be a sequential number autogenerated by the
    database. We’ve already done this with the serial data type and the `IDENTITY`
    syntax (covered in “Auto-Incrementing Integers” in Chapter 4). A table using an
    autogenerated integer for a surrogate key might look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*替代*键是一个单独的列，你可以用人工生成的值填充它；当一个表没有支持创建自然主键的数据时，我们可能会使用它。替代键可能是数据库自动生成的一个顺序号。我们已经通过序列数据类型和`IDENTITY`语法（在第4章的“自动递增整数”部分中介绍）做了这种操作。使用自动生成整数作为替代键的表可能如下所示：'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Some developers like to use a *universally unique identifier (UUID)*, which
    is a code comprised of 32 hexadecimal digits in groups separated by hyphens. Often,
    UUIDs are used to identify computer hardware or software and look like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员喜欢使用*全局唯一标识符（UUID）*，它由32个十六进制数字组成，按连字符分组。UUID通常用于标识计算机硬件或软件，格式如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'PostgreSQL offers a UUID data type as well as two modules that generate UUIDs:
    `uuid-ossp` and `pgcrypto`. The PostgreSQL documentation at [https://www.postgresql.org/docs/current/datatype-uuid.html](https://www.postgresql.org/docs/current/datatype-uuid.html)
    is a good starting point for diving deeper.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL提供了UUID数据类型以及两个生成UUID的模块：`uuid-ossp`和`pgcrypto`。PostgreSQL文档[https://www.postgresql.org/docs/current/datatype-uuid.html](https://www.postgresql.org/docs/current/datatype-uuid.html)是深入了解的一个良好起点。
- en: Evaluating the Pros and Cons of Key Types
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 评估键类型的优缺点
- en: 'There are well-reasoned arguments for using either type of primary key, but
    both have drawbacks. Points to consider about natural keys include the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任一类型主键都有充分的理由，但两者都有缺点。关于自然键需要考虑的要点包括以下几点：
- en: The data already exists in the table, so you don’t need to add a column to create
    a key.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据已经存在于表中，因此你无需添加列来创建键。
- en: Because the natural key data has meaning, it can reduce the need to join tables
    when querying.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于自然键数据本身具有意义，它可以减少查询时表之间联接的需要。
- en: If your data changes in a way that violates the requirements for a key—the sudden
    appearance of duplicate values, for instance—you’ll be forced to change the setup
    of the table.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据发生变化，违反了键的要求——例如突然出现重复值——你将不得不更改表的设置。
- en: 'Here are points to consider about surrogate keys:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于替代键需要考虑的几点：
- en: Because a surrogate key doesn’t have any meaning in itself and its values are
    independent of the data in the table, you’re not limited by the key structure
    if your data changes later.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为替代键本身没有任何意义，并且其值独立于表中的数据，因此如果数据稍后发生变化，你不受键结构的限制。
- en: Key values are guaranteed to be unique.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值保证是唯一的。
- en: Adding a column for a surrogate key requires more space.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为替代键添加一列需要更多的空间。
- en: In a perfect world, a table should have one or more columns that can serve as
    a natural key, such as a unique product code in a table of products. But real-world
    limitations arise all the time. In a table of employees, it might be difficult
    to find any single column, or even multiple columns, that would be unique on a
    row-by-row basis to serve as a primary key. In such cases where you can’t reconsider
    the table structure, you may need to use a surrogate key.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，表应该有一个或多个列可以作为自然键，例如在产品表中使用唯一的产品代码。但现实中常常会遇到限制。例如，在员工表中，可能很难找到任何单一列，甚至多个列，能在逐行的基础上保持唯一性，作为主键。在无法重新考虑表结构的情况下，可能需要使用替代键。
- en: Creating a Single-Column Primary Key
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建单列主键
- en: 'Let’s work through several primary key examples. In “Understanding JOIN Types”
    in Chapter 7, you created primary keys on the `district_2020` and `district_2035`
    tables to try `JOIN` types. In fact, these were surrogate keys: in both tables,
    you created columns called `id` to use as the key and used the keywords `CONSTRAINT`
    `key_name` `PRIMARY KEY` to declare them as primary keys.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个主键示例来分析。在第7章的《理解 JOIN 类型》中，你在 `district_2020` 和 `district_2035` 表上创建了主键来尝试不同的
    `JOIN` 类型。实际上，这些都是替代键：在这两个表中，你创建了名为 `id` 的列作为键，并使用了关键字 `CONSTRAINT` `key_name`
    `PRIMARY KEY` 来声明它们为主键。
- en: 'There are two ways to declare constraints: as a column constraint or as a table
    constraint. In [Listing 8-1](#listing8-1), we try both methods, declaring a primary
    key on a table similar to the driver’s license example mentioned earlier. Because
    we expect the driver’s license IDs to always be unique, we’ll use that column
    as a natural key.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法来声明约束：作为列约束或作为表约束。在[列表 8-1](#listing8-1)中，我们尝试了这两种方法，在类似于前面提到的驾驶执照示例的表上声明主键。由于我们预期驾驶执照ID始终唯一，我们将使用该列作为自然键。
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-1: Declaring a single-column natural key as a primary key'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：将单列自然键声明为主键
- en: 'We first create a table called `natural_key_example` and use the column constraint
    syntax `CONSTRAINT` to declare `license_id` as the primary key 1 followed by a
    name for the constraint and the keywords `PRIMARY KEY`. This syntax makes it easy
    to understand at a glance which column is designated as the primary key. Note
    that you can omit the `CONSTRAINT` keyword and name for the key and simply use
    `PRIMARY KEY`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `natural_key_example` 的表，并使用列约束语法 `CONSTRAINT` 声明 `license_id` 为主键
    1，后跟约束名称和关键字 `PRIMARY KEY`。这种语法可以让你一目了然地了解哪个列被指定为主键。注意，你也可以省略 `CONSTRAINT` 关键字和主键名称，只使用
    `PRIMARY KEY`：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In that case, PostgreSQL will name the primary key on its own, using the convention
    of the table name followed by `_pkey`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，PostgreSQL 将自行为主键命名，采用表名后跟 `_pkey` 的命名约定。
- en: Next, we delete the table from the database with `DROP TABLE` 2 to prepare for
    the table constraint example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `DROP TABLE` 2 从数据库中删除表，以准备表约束示例。
- en: To add a table constraint, we declare the `CONSTRAINT` after listing all the
    columns 3, with the column we want to use as the key in parentheses. (Again, you
    can omit the `CONSTRAINT` keyword and key name.) In this example, we end up with
    the same `license_id` column for the primary key. You must use the table constraint
    syntax when you want to create a primary key using more than one column; in that
    case, you would list the columns in parentheses, separated by commas. We’ll explore
    that in a moment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加表约束，我们在列出所有列 3 后声明 `CONSTRAINT`，并在括号中列出我们想要用作主键的列。（同样，你可以省略 `CONSTRAINT`
    关键字和主键名称。）在这个例子中，我们最终还是将 `license_id` 列作为主键。当你希望使用多列创建主键时，必须使用表约束语法；在这种情况下，你需要在括号中列出列，并用逗号分隔。我们稍后会详细探讨这个问题。
- en: First, let’s look at how the qualities of a primary key—unique for every row
    and no `NULL` values—protect you from harming your data’s integrity. [Listing
    8-2](#listing8-2) has two `INSERT` statements.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看主键的特性——每一行唯一且没有 `NULL` 值——是如何保护数据完整性的。[列表 8-2](#listing8-2) 中有两个 `INSERT`
    语句。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-2: An example of a primary key violation'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-2：主键冲突示例
- en: 'When you execute the first `INSERT` statement on its own, the server loads
    a row into the `natural_key_example` table without any issue. When you attempt
    to execute the second, the server replies with an error:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你单独执行第一个 `INSERT` 语句时，服务器会顺利地将一行数据加载到 `natural_key_example` 表中。你尝试执行第二个时，服务器会返回错误：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before adding the row, the server checked whether a `license_id` of `T229901`
    was already present in the table. Because it was and because a primary key by
    definition must be unique for each row, the server rejected the operation. The
    rules of the fictional DMV state that no two drivers can have the same license
    ID, so checking for and rejecting duplicate data is one way for the database to
    enforce that rule.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加行之前，服务器检查表中是否已经存在 `T229901` 的 `license_id`。由于它已经存在，并且根据主键的定义，主键必须对每一行唯一，因此服务器拒绝了该操作。虚构的
    DMV 规则规定，两个驾驶员不能拥有相同的驾照 ID，因此检查并拒绝重复数据是数据库执行该规则的一种方式。
- en: Creating a Composite Primary Key
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建复合主键
- en: If a single column doesn’t meet the requirements for a primary key, we can create
    a *composite primary key*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单列不符合主键的要求，我们可以创建一个 *复合主键*。
- en: We’ll make a table that tracks student school attendance. The combination of
    `student_id` and `school_day` columns gives us a unique value for each row, which
    records whether a student was in school on that day in a column called `present`.
    To create a composite primary key, you must declare it using the table constraint
    syntax, as shown in [Listing 8-3](#listing8-3).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个跟踪学生上学出勤情况的表。`student_id` 和 `school_day` 列的组合为每一行提供了一个唯一的值，记录了学生在某一天是否到校，这些信息存储在一个名为
    `present` 的列中。要创建复合主键，你必须使用表约束语法，如[列表 8-3](#listing8-3)所示。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-3: Declaring a composite primary key as a natural key'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-3：将复合主键声明为自然主键
- en: Here we pass two (or more) columns as arguments rather than one. We’ll simulate
    a key violation by attempting to insert a row where the combination of values
    in the two key columns—`student_id` and `school_day`—is not unique to the table.
    Run the `INSERT` statements in [Listing 8-4](#listing8-4) one at a time (by highlighting
    them in pgAdmin before clicking **Execute/Refresh**).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递两个（或更多）列作为参数，而不是一个。我们将通过尝试插入一行数据来模拟主键冲突，其中两个主键列 `student_id` 和 `school_day`
    的值在表中并不唯一。逐个运行[列表 8-4](#listing8-4) 中的 `INSERT` 语句（在 pgAdmin 中高亮显示它们后点击 **Execute/Refresh**）。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-4: Example of a composite primary key violation'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：复合主键冲突示例
- en: 'The first two `INSERT` statements execute fine because there’s no duplication
    of values in the combination of the key columns. But the third statement causes
    an error because the `student_id` and `school_day` values it contains match a
    combination that already exists in the table:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个 `INSERT` 语句执行正常，因为在主键列的组合中没有值重复。但第三个语句会导致错误，因为它包含的 `student_id` 和 `school_day`
    值与表中已存在的组合匹配：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can create composite keys with more than two columns. The limit to the number
    of columns you can use depends on your database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建包含超过两列的复合主键。你可以使用的列数的限制取决于你的数据库。
- en: Creating an Auto-Incrementing Surrogate Key
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建自增替代主键
- en: 'As you learned in “Auto-Incrementing Integers” in Chapter 4, there are two
    ways to have a PostgreSQL database add an automatically increasing unique value
    to a column. The first is to set the column to one of the PostgreSQL-specific
    serial data types: `smallserial`, `serial`, and `bigserial`. The second is to
    use the `IDENTITY` syntax; because it is part of the ANSI SQL standard, we’ll
    employ this for our examples.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 4 章《自增整数》中学到的那样，PostgreSQL 数据库有两种方法可以向列添加自动增长的唯一值。第一种方法是将列设置为 PostgreSQL
    特定的序列数据类型之一：`smallserial`、`serial` 和 `bigserial`。第二种方法是使用 `IDENTITY` 语法；由于它是 ANSI
    SQL 标准的一部分，我们将在示例中使用这种方法。
- en: Use `IDENTITY` with one of the integer types `smallint`, `integer`, and `bigint`.
    For a primary key, it may be tempting to try to save disk space by using `integer`,
    which handles numbers as large as 2,147,483,647\. But many a database developer
    has received a late-night call from a user frantic to know why an application
    is broken, only to discover that the database is trying to generate a number one
    greater than the data type’s maximum. So, if it’s remotely possible that your
    table will grow past 2.147 billion rows, it’s wise to use `bigint`, which accepts
    numbers as high as 9.2 *quintillion*. You can set it and forget it, as shown in
    the first column defined in [Listing 8-5](#listing8-5).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IDENTITY` 和 `smallint`、`integer`、`bigint` 等整数类型中的一种。对于主键来说，可能会诱使你通过使用 `integer`
    来节省磁盘空间，它可以处理最大为 2,147,483,647 的数字。但是，许多数据库开发人员曾在深夜接到用户的紧急电话，询问为何应用程序崩溃，结果发现数据库尝试生成比数据类型的最大值更大的数字。因此，如果你的表有可能增长超过
    21.47 亿行，明智的做法是使用 `bigint`，它可以接受高达 9.2 * quintillion 的数字。你可以设置并忘记它，就像在 [清单 8-5](#listing8-5)
    中定义的第一列那样。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-5: Declaring a `bigint` column as a surrogate key using `IDENTITY`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-5：使用 `IDENTITY` 声明 `bigint` 列作为替代键
- en: '[Listing 8-5](#listing8-5) shows how to declare an auto-incrementing `bigint`
    1 column called `order_number` using the `IDENTITY` syntax and then set the column
    as the primary key 2. When you insert data into the table 3, you omit `order_number`
    from the list of columns and values. The database will create a new value for
    that column as each row is inserted, and that value will be one greater than the
    largest already created for the column.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-5](#listing8-5) 显示了如何使用 `IDENTITY` 语法声明一个自增的 `bigint` 列，名为 `order_number`，并将该列设置为主键
    2。当你向表 3 中插入数据时，可以从列和值列表中省略 `order_number`。数据库将在每插入一行时为该列创建一个新值，该值将比已创建的最大值大 1。'
- en: 'Run `SELECT * FROM surrogate_key_example;` to see how the column fills in automatically:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `SELECT * FROM surrogate_key_example;` 来查看该列是如何自动填充的：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We see these sorts of auto-incrementing order numbers reflected in the receipts
    for the purchases we make every day. Now you know how it’s done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在日常购物的收据中看到这些自增的订单号。现在你知道是如何做到的了。
- en: 'A few details worth noting: if you delete a row, the database won’t fill the
    gap in the `order_number` sequence, nor will it change any of the existing values
    in that column. It will generally add one to the largest existing value in the
    sequence (though there are exceptions related to operations, including restoring
    a database from a backup). Also, we used the syntax `GENERATED ALWAYS AS IDENTITY`.
    As discussed in Chapter 4, this prevents a user from inserting a value in `order_number`
    without manually overriding the setting. Generally, you want to prevent such meddling
    to avoid problems. Let’s say a user were to manually insert a value of `4` into
    the `order_number` column of your existing `surrogate_key_example` table. That
    manual insert will not increment the `IDENTITY` sequence for the `order_number`
    column; that occurs only when the database generates a new value. Thus, on the
    next row insert, the database also would try to also insert a `4`, as that’s the
    next number in the sequence. The result will be an error, because a duplicate
    value violates the primary key constraint.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个值得注意的细节：如果你删除一行，数据库不会填补 `order_number` 序列中的空缺，也不会更改该列中的任何现有值。通常，它会将序列中最大的现有值加
    1（尽管在某些操作中会有例外情况，包括从备份恢复数据库）。另外，我们使用了语法 `GENERATED ALWAYS AS IDENTITY`。正如第 4 章中讨论的那样，这可以防止用户在不手动覆盖设置的情况下向
    `order_number` 插入值。通常，你希望防止这种干预，以避免出现问题。假设用户手动向现有的 `surrogate_key_example` 表的
    `order_number` 列插入值 `4`。这个手动插入不会递增 `order_number` 列的 `IDENTITY` 序列；只有当数据库生成新值时，才会发生递增。因此，在下一行插入时，数据库也会尝试插入
    `4`，因为它是序列中的下一个数字。结果将会是一个错误，因为重复值违反了主键约束。
- en: You can, however, allow manual insertions by restarting the `IDENTITY` sequence.
    You might allow this in case you need to insert a row that was mistakenly deleted.
    [Listing 8-6](#listing8-6) shows how to add a row to the table that has an `order_number`
    of `4`, which is the next value in the sequence.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过重新启动`IDENTITY`序列来允许手动插入。你可能允许这样做，以防需要插入一个误删的行。[示例 8-6](#listing8-6)显示了如何向表中添加一个`order_number`为`4`的行，这个值是序列中的下一个值。
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-6: Restarting an `IDENTITY` sequence'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6：重新启动`IDENTITY`序列
- en: You start with an `INSERT` statement that includes the keywords `OVERRIDING
    SYSTEM VALUE` 1. Next we include the `VALUES` clause and specify the integer `4`
    for the first column, `order_number`, in the `VALUES` list, which overrides the
    `IDENTITY` restriction. We’re using `4`, but we could choose any number that’s
    not already present in the column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个包含关键字`OVERRIDING SYSTEM VALUE` 1的`INSERT`语句开始。接下来，我们包括`VALUES`子句，并为`order_number`列在`VALUES`列表中指定整数`4`，这将覆盖`IDENTITY`限制。我们使用`4`，但我们也可以选择任何一个未在该列中存在的数字。
- en: After the insert, you need to reset the `IDENTITY` sequence so that it begins
    at a number larger than the `4` you just inserted. To do this, use an `ALTER TABLE
    ... ALTER COLUMN` statement 2 that includes the keywords `RESTART WITH 5`. An
    `ALTER TABLE` modifies tables and columns in various ways, which we’ll explore
    more thoroughly in Chapter 10, “Inspecting and Modifying Data.” Here, you use
    it to change the beginning number of the `IDENTITY` sequence; so, when the next
    row gets added to the table, the value for `order_number` will be `5`. Finally,
    insert a new row 3 and omit a value for the `order_number`, as you did in [Listing
    8-5](#listing8-5).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 插入后，你需要重置`IDENTITY`序列，以便它从比你刚插入的`4`更大的数字开始。为此，使用`ALTER TABLE ... ALTER COLUMN`语句，其中包括关键字`RESTART
    WITH 5`。`ALTER TABLE`用于以各种方式修改表和列，更多内容将在第10章《检查和修改数据》中深入探讨。在这里，你用它来改变`IDENTITY`序列的起始数字；这样，下一个插入表中的行，`order_number`的值将是`5`。最后，插入一个新行并省略`order_number`的值，正如在[示例
    8-5](#listing8-5)中所做的那样。
- en: 'If you select all rows again from the `surrogate_key_example` table, you’ll
    see that the `order_number` column populated as intended:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次从`surrogate_key_example`表中选择所有行，你会看到`order_number`列已经按预期填充：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This task isn’t one you necessarily want to tackle often, but it’s good to know
    if the need arises.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务不一定是你需要经常处理的，但如果需要的话，知道怎么做是有帮助的。
- en: Foreign Keys
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外键
- en: We use *foreign keys* to establish relationships between tables. A foreign key
    is one or more columns whose values match those in another table’s primary key
    or other unique key. Foreign key values must already exist in the primary key
    or other unique key of the table it references. If not, the value is rejected.
    With this constraint, SQL enforces *referential integrity*—ensuring that data
    in related tables doesn’t end up unrelated, or orphaned. We won’t end up with
    rows in one table that have no relation to rows in the other tables we can join
    them to.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*外键*来建立表之间的关系。外键是一个或多个列，其值与另一个表的主键或其他唯一键中的值匹配。外键的值必须已经存在于它所引用的表的主键或其他唯一键中。如果不存在，则该值会被拒绝。通过这一约束，SQL
    强制执行*参照完整性*——确保相关表中的数据不会变得无关或成为孤立数据。我们不会在一个表中得到与其他可以连接的表中的行没有关系的行。
- en: '[Listing 8-7](#listing8-7) shows two tables from a hypothetical database tracking
    motor vehicle activity.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-7](#listing8-7)显示了一个假设数据库中的两个表，用于追踪机动车活动。'
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-7: A foreign key example'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7：外键示例
- en: The first table, `licenses`, uses a driver’s unique `license_id` 1 as a natural
    primary key. The second table, `registrations`, is for tracking vehicle registrations.
    A single license ID might be connected to multiple vehicle registrations, because
    each licensed driver can register multiple vehicles—this is called a *one-to-many
    relationship* (Chapter 7).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表`licenses`使用驾驶员唯一的`license_id` 1作为自然主键。第二个表`registrations`用于追踪车辆注册。一个许可证
    ID 可能会与多个车辆注册相关联，因为每个持证驾驶员可以注册多辆车——这被称为*一对多关系*（第7章）。
- en: 'Here’s how that relationship is expressed via SQL: in the `registrations` table,
    we designate the column `license_id` 2 as a foreign key by adding the `REFERENCES`
    keyword, followed by the table name and column for it to reference.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SQL，关系是这样表达的：在`registrations`表中，我们通过添加`REFERENCES`关键字，将`license_id`列指定为外键，后面跟上它引用的表名和列名。
- en: Now, when we insert a row into `registrations`, the database will test whether
    the value inserted into `license_id` already exists in the `license_id` primary
    key column of the `licenses` table. If it doesn’t, the database returns an error,
    which is important. If any rows in `registrations` didn’t correspond to a row
    in `licenses`, we’d have no way to write a query to find the person who registered
    the vehicle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们向`registrations`插入一行时，数据库会检查插入到`license_id`中的值是否已经存在于`licenses`表的`license_id`主键列中。如果不存在，数据库会返回一个错误，这是非常重要的。如果`registrations`中的任何行与`licenses`中的行不对应，我们将无法编写查询来找到注册了该车辆的人。
- en: 'To see this constraint in action, create the two tables and execute the `INSERT`
    statements one at a time. The first adds a row to `licenses` 3 that includes the
    value `T229901` for the `license_id`. The second adds a row to `registrations`
    4 where the foreign key contains the same value. So far, so good, because the
    value exists in both tables. But we encounter an error with the third insert,
    which tries to add a row to `registrations` 5 with a value for `license_id` that’s
    not in `licenses`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看此约束的实际效果，创建这两个表并逐一执行`INSERT`语句。第一个语句向`licenses` 3中添加一行，其中`license_id`的值为`T229901`。第二个语句向`registrations`
    4中添加一行，其中外键包含相同的值。到目前为止，一切正常，因为该值在两个表中都存在。但是在第三次插入时，我们遇到错误，该插入尝试将一行插入到`registrations`
    5中，且其`license_id`值在`licenses`中不存在：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The resulting error is actually helpful: the database is enforcing referential
    integrity by preventing a registration for a nonexistent license holder. But it
    also indicates a few practical implications. First, it affects the order in which
    we insert data. We cannot add data to a table that contains a foreign key before
    the other table referenced by the key has the related records, or we’ll get an
    error. In this example, we’d have to create a driver’s license record before inserting
    a related registration record (if you think about it, that’s what your local department
    of motor vehicles probably does).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的错误实际上是有帮助的：数据库通过阻止对不存在的许可证持有者进行注册来强制执行引用完整性。但它也表明了一些实际影响。首先，它影响我们插入数据的顺序。在另一个表中包含外键的表在没有相关记录之前不能添加数据，否则我们会遇到错误。在这个例子中，我们必须先创建一个驾驶执照记录，然后再插入相关的注册记录（如果你想一想，这就是你当地的机动车管理部门可能会做的事情）。
- en: Second, the reverse applies when we delete data. To maintain referential integrity,
    the foreign key constraint prevents us from deleting a row from `licenses` before
    removing any related rows in `registrations`, because doing so would leave an
    orphaned record. We would have to delete the related row in `registrations` first
    and then delete the row in `licenses`. However, ANSI SQL provides a way to handle
    this order of operations automatically using the `ON DELETE` `CASCADE` keywords.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当我们删除数据时，情况恰恰相反。为了保持引用完整性，外键约束阻止我们在删除`registrations`中的任何相关行之前，删除`licenses`中的一行，因为这样做会留下一个孤立的记录。我们必须先删除`registrations`中的相关行，然后再删除`licenses`中的记录。然而，ANSI
    SQL提供了一种方法，通过使用`ON DELETE` `CASCADE`关键字自动处理这种操作顺序。
- en: How to Automatically Delete Related Records with CASCADE
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用CASCADE自动删除相关记录
- en: To delete a row in `licenses` and have that action automatically delete any
    related rows in `registrations`, we can specify that behavior by adding `ON DELETE
    CASCADE` when defining the foreign key constraint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在删除`licenses`中的一行时自动删除`registrations`中的相关行，我们可以通过在定义外键约束时添加`ON DELETE CASCADE`来指定这种行为。
- en: 'Here’s how we would modify the [Listing 8-7](#listing8-7) `CREATE TABLE` statement
    for `registrations`, adding the keywords at the end of the definition of the `license_id`
    column:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何修改[列表 8-7](#listing8-7)中`CREATE TABLE`语句以创建`registrations`表，在`license_id`列的定义末尾添加关键字的方式：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Deleting a row in `licenses` should also delete all related rows in `registrations`.
    This allows us to delete a driver’s license without first having to manually remove
    any registrations linked to it. It also maintains data integrity by ensuring deleting
    a license doesn’t leave orphaned rows in `registrations`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`licenses`中的一行应该也会删除`registrations`中所有相关的行。这使我们能够删除驾驶执照，而不必先手动删除任何与其关联的注册记录。它还通过确保删除一个执照不会在`registrations`中留下孤立的行来维护数据完整性。
- en: The CHECK Constraint
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`CHECK`约束'
- en: A `CHECK` constraint evaluates whether data added to a column meets the expected
    criteria, which we specify with a logical test. If the criteria aren’t met, the
    database returns an error. The `CHECK` constraint is extremely valuable because
    it can prevent columns from getting loaded with nonsensical data. For example,
    a baseball player’s total number of hits shouldn’t be negative, so you should
    limit that data to values of zero or greater. Or, in most schools, `Z` isn’t a
    valid letter grade for a course (although my barely passing algebra grade felt
    like it), so we might insert constraints that only accept the values A–F.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHECK`约束评估添加到列中的数据是否符合预期标准，我们通过逻辑测试来指定这些标准。如果标准不符合，数据库将返回错误。`CHECK`约束非常有价值，因为它可以防止列中加载无意义的数据。例如，棒球运动员的总击球数不应为负数，因此应该限制该数据为零或更大的值。或者，在大多数学校中，`Z`不是有效的课程成绩（尽管我那时勉强及格的代数成绩感觉像是Z），因此我们可以插入只接受A–F值的约束。'
- en: 'As with primary keys, we can implement a `CHECK` constraint at the column or
    table level. For a column constraint, declare it in the `CREATE TABLE` statement
    after the column name and data type: `CHECK (``logical expression``)`. As a table
    constraint, use the syntax `CONSTRAINT` `constraint_name` `CHECK (``logical expression``)`
    after all columns are defined.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与主键一样，我们可以在列级别或表级别实现`CHECK`约束。对于列约束，在`CREATE TABLE`语句中声明它，放在列名和数据类型之后：`CHECK
    (``logical expression``)`。作为表约束，使用语法`CONSTRAINT` `constraint_name` `CHECK (``logical
    expression``)`，在所有列定义之后。
- en: '[Listing 8-8](#listing8-8) shows a `CHECK` constraint applied to two columns
    in a table we might use to track the user role and salary of employees within
    an organization. It uses the table constraint syntax for the primary key and the
    `CHECK` constraint.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-8](#listing8-8)展示了一个`CHECK`约束，应用于一个表中的两个列，我们可能会用这个表来追踪员工在组织中的角色和薪资。它使用了主键和`CHECK`约束的表约束语法。'
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 8-8: Examples of `CHECK` constraints'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-8: `CHECK`约束示例'
- en: We create the table and set the `user_id` column as an auto-incrementing surrogate
    primary key. The first `CHECK` 1 tests whether values entered into the `user_role`
    column match one of two predefined strings, `Admin` or `Staff`, by using the SQL
    `IN` operator. The second `CHECK` 2 tests whether values entered in the `salary`
    column are greater than or equal to 0, because a negative amount wouldn’t make
    sense. Both tests are an example of a *Boolean expression*, a statement that evaluates
    as either true or false. If a value tested by the constraint evaluates as `true`,
    the check passes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建表并将`user_id`列设置为自动递增的替代主键。第一个`CHECK` 1测试输入到`user_role`列的值是否符合预定义的两个字符串之一，`Admin`或`Staff`，通过使用SQL中的`IN`运算符。第二个`CHECK`
    2测试输入到`salary`列的值是否大于或等于0，因为负数金额是没有意义的。两个测试都是*布尔表达式*的例子，这是一种评估为真或假的语句。如果约束测试的值为`true`，则检查通过。
- en: When values are inserted or updated, the database checks them against the constraint.
    If the values in either column violate the constraint—or, for that matter, if
    the primary key constraint is violated—the database will reject the change.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入或更新值时，数据库会将其与约束进行检查。如果任一列中的值违反了约束，或者即使违反了主键约束，数据库也会拒绝该更改。
- en: 'If we use the table constraint syntax, we also can combine more than one test
    in a single `CHECK` statement. Say we have a table related to student achievement.
    We could add the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用表约束语法，我们还可以在一个`CHECK`语句中组合多个测试。例如，我们有一个与学生成绩相关的表。我们可以添加如下内容：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that we combine two logical tests by enclosing them in parentheses and
    connecting them with `AND`. Here, both Boolean expressions must evaluate as `true`
    for the entire check to pass. You can also test values across columns, as in the
    following example where we want to make sure an item’s sale price is a discount
    on the original, assuming we have columns for both values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过将两个逻辑测试括在括号中并用`AND`连接它们来组合这两个逻辑测试。在这里，两个布尔表达式必须都评估为`true`，整个检查才会通过。你也可以跨列进行值的测试，如下面的例子所示，我们希望确保商品的销售价格是原价的折扣，假设我们有两个列来存储这两个值：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inside the parentheses, the logical expression checks that the sale price is
    less than the retail price.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，逻辑表达式检查销售价格是否小于零售价格。
- en: The UNIQUE Constraint
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UNIQUE约束
- en: We can also ensure that a column has a unique value in each row by using the
    `UNIQUE` constraint. If ensuring unique values sounds similar to the purpose of
    a primary key, it is. But `UNIQUE` has one important difference. In a primary
    key, no values can be `NULL`, but a `UNIQUE` constraint permits multiple `NULL`
    values in a column. This is useful in cases where we won’t always have values
    but want to ensure that the ones we do have are unique.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `UNIQUE` 约束来确保每一行中的列具有唯一的值。如果确保唯一值听起来与主键的目的相似，确实如此。但是，`UNIQUE` 有一个重要的区别：在主键中，值不能为
    `NULL`，但 `UNIQUE` 约束允许列中存在多个 `NULL` 值。这在某些情况下非常有用，例如当我们并不总是拥有值，但希望确保现有值是唯一的。
- en: To show the usefulness of `UNIQUE`, look at the code in [Listing 8-9](#listing8-9),
    which is a table for tracking contact info.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `UNIQUE` 的实用性，看看 [列表 8-9](#listing8-9) 中的代码，这是一张用于跟踪联系人信息的表格。
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 8-9: A `UNIQUE` constraint example'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：`UNIQUE` 约束示例
- en: 'In this table, `contact_id` serves as a surrogate primary key, uniquely identifying
    each row. But we also have an `email` column, the main point of contact with each
    person. We’d expect this column to contain only unique email addresses, but those
    addresses might change over time. So, we use `UNIQUE` 1 to ensure that any time
    we add or update a contact’s email, we’re not providing one that already exists.
    If we try to insert an email that already exists 2, the database will return an
    error:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，`contact_id` 作为替代主键，唯一地标识每一行数据。但我们还有一个 `email` 列，这是与每个人的主要联系方式。我们希望这个列只包含唯一的电子邮件地址，但这些地址可能随着时间变化。所以，我们使用
    `UNIQUE` 1 来确保每次添加或更新联系人的电子邮件时，不会重复已经存在的地址。如果我们尝试插入一个已存在的电子邮件 2，数据库将返回错误：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, the error shows the database is working for us.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，错误信息表明数据库正在为我们工作。
- en: The NOT NULL Constraint
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`NOT NULL` 约束'
- en: In Chapter 7, you learned about `NULL`, a special SQL value that represents
    missing data or unknown values. We know that `NULL` is not allowed for primary
    key values because they need to uniquely identify each row in a table. But there
    may be other times when you’ll want to disallow empty values in a column. For
    example, in a table listing each student in a school, requiring that columns containing
    first and last names be filled for each row makes sense. To require a value in
    a column, SQL provides the `NOT NULL` constraint, which simply prevents a column
    from accepting empty values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七章中，你学习了 `NULL`，它是一个特殊的 SQL 值，表示缺失数据或未知值。我们知道，主键的值不能为 `NULL`，因为主键需要唯一地标识表中的每一行。但在某些情况下，你可能希望在列中禁止空值。例如，在列出学校中每个学生的表格中，要求每一行的名字和姓氏列都必须填写是合理的。为了要求列中必须有值，SQL
    提供了 `NOT NULL` 约束，它简单地禁止列接受空值。
- en: '[Listing 8-10](#listing8-10) demonstrates the `NOT NULL` syntax.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-10](#listing8-10) 展示了 `NOT NULL` 语法。'
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-10: A `NOT NULL` constraint example'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-10：`NOT NULL` 约束示例
- en: Here, we declare `NOT NULL` for the `first_name` and `last_name` columns because
    it’s likely we’d require those pieces of information in a table tracking student
    information. If we attempt an `INSERT` on the table and don’t include values for
    those columns, the database will notify us of the violation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `first_name` 和 `last_name` 列声明了 `NOT NULL`，因为在跟踪学生信息的表格中，这些信息可能是必需的。如果我们尝试在表中执行
    `INSERT` 并且没有为这些列提供值，数据库会通知我们违反了约束。
- en: How to Remove Constraints or Add Them Later
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何删除约束或稍后添加它们
- en: You can remove a constraint or later add one to an existing table using `ALTER
    TABLE`, the command you used earlier in the chapter in “Creating an Auto-incrementing
    Surrogate Key” to reset the `IDENTITY` sequence.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `ALTER TABLE` 删除或稍后向现有表添加约束，就像你在本章“创建自增替代主键”中使用的命令来重置 `IDENTITY` 序列一样。
- en: 'To remove a primary key, foreign key, or `UNIQUE` constraint, you write an
    `ALTER TABLE` statement in this format:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除主键、外键或 `UNIQUE` 约束，你需要编写以下格式的 `ALTER TABLE` 语句：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To drop a `NOT NULL` constraint, the statement operates on the column, so you
    must use the additional `ALTER COLUMN` keywords, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除 `NOT NULL` 约束，语句作用于列，因此你必须使用额外的 `ALTER COLUMN` 关键字，如下所示：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s use these statements to modify the `not_null_example` table you just made,
    as shown in [Listing 8-11](#listing8-11).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些语句修改你刚刚创建的 `not_null_example` 表，如 [列表 8-11](#listing8-11) 所示。
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 8-11: Dropping and adding a primary key and a `NOT NULL` constraint'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-11：删除和添加主键以及 `NOT NULL` 约束
- en: Execute the statements one at a time. Each time, you can view the changes to
    the table definition in pgAdmin by clicking the table name once and then clicking
    the **SQL** tab above the query window. (Note that it will display a more verbose
    syntax for the table definition than what you used when creating the table.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一次执行一个语句。每次执行后，你可以通过在pgAdmin中单击表名，然后点击查询窗口上方的**SQL**标签，查看表定义的更改。（请注意，它将显示比你创建表时所使用的语法更详细的表定义语法。）
- en: With the first `ALTER TABLE` statement, we use `DROP CONSTRAINT` to remove the
    primary key named `student_id_key`. We then add the primary key back using `ADD
    CONSTRAINT`. We’d use that same syntax to add a constraint to any existing table.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`ALTER TABLE`语句中，我们使用`DROP CONSTRAINT`移除名为`student_id_key`的主键。然后，我们使用`ADD
    CONSTRAINT`将主键重新添加。我们可以使用相同的语法向任何现有表添加约束。
- en: In the third statement, `ALTER COLUMN` and `DROP NOT NULL` remove the `NOT NULL`
    constraint from the `first_name` column. Finally, `SET NOT NULL` adds the constraint.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三条语句中，`ALTER COLUMN`和`DROP NOT NULL`移除了`first_name`列的`NOT NULL`约束。最后，`SET
    NOT NULL`添加了该约束。
- en: Speeding Up Queries with Indexes
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引加速查询
- en: In the same way that a book’s index helps you find information more quickly,
    you can speed up queries by adding an *index*—a separate data structure the database
    manages—to one or more columns in a table. The database uses the index as a shortcut
    rather than scanning each row to find data. That’s admittedly a simplistic picture
    of what, in SQL databases, is a nontrivial topic. We could spend several chapters
    delving into the workings of SQL indexes and tuning databases for performance,
    but instead I’ll offer general guidance on using indexes and a PostgreSQL-specific
    example that demonstrates their benefits.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一本书的索引帮助你更快找到信息一样，你也可以通过向表中的一列或多列添加*索引*—一种由数据库管理的独立数据结构—来加速查询。数据库使用索引作为快捷方式，而不是扫描每一行来查找数据。坦率地说，这只是SQL数据库中非平凡话题的一个简化版本。我们可以用好几章来深入探讨SQL索引的工作原理以及如何调优数据库性能，但在这里，我会提供关于使用索引的一般指导，并通过一个PostgreSQL特定的示例来展示它们的好处。
- en: 'B-Tree: PostgreSQL’s Default Index'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B-树：PostgreSQL的默认索引
- en: You’ve already created several indexes, perhaps without knowing. Each time you
    add a primary key or `UNIQUE` constraint, PostgreSQL (as well as most database
    systems) creates an index on the column or columns included in the constraint.
    Indexes are stored separately from the table data and are accessed automatically
    (if needed) when you run a query and updated every time a row is added, removed,
    or updated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了几个索引，也许你并没有意识到。每次你添加主键或`UNIQUE`约束时，PostgreSQL（以及大多数数据库系统）会在包含该约束的列上创建一个索引。索引与表数据分开存储，并在你运行查询时自动访问（如果需要），并在每次添加、删除或更新行时更新。
- en: In PostgreSQL, the default index type is the *B-tree index*. It’s created automatically
    on the columns designated for the primary key or a `UNIQUE` constraint, and it’s
    also the type created by default with the `CREATE INDEX` statement. B-tree, short
    for *balanced tree*, is so named because when you search for a value, the structure
    looks from the top of the tree down through branches until it locates the value.
    (Of course, the process is a lot more complicated than that.) A B-tree index is
    useful for data that can be ordered and searched using equality and range operators,
    such as `<`, `<=`, `=`, `>=`, `>`, and `BETWEEN`. It also works with `LIKE` if
    there’s no wildcard in the pattern at the beginning of the search string. An example
    is `WHERE chips LIKE 'Dorito%'`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中，默认的索引类型是*B树索引*。它会在指定为主键或`UNIQUE`约束的列上自动创建，并且它也是使用`CREATE INDEX`语句时默认创建的索引类型。B树（*balanced
    tree*的缩写）得名于其结构，因为在查找一个值时，它从树的顶部开始，通过分支向下搜索，直到找到该值。（当然，过程远比这更复杂。）B树索引适用于可以排序并使用相等和范围运算符（如`<`、`<=`、`=`、`>=`、`>`和`BETWEEN`）进行搜索的数据。如果搜索字符串的开头没有通配符，它也适用于`LIKE`。例如：`WHERE
    chips LIKE 'Dorito%'`。
- en: PostgreSQL also supports additional index types, such as the *Generalized Inverted
    Index (GIN)* and the *Generalized Search Tree* *(GiST)*. Each has distinct uses,
    and I’ll incorporate them in later chapters on full-text search and queries using
    geometry types.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL还支持其他索引类型，例如*广义倒排索引（GIN）*和*广义搜索树（GiST）*。每种索引有不同的用途，我将在后续章节中介绍它们，尤其是在全文搜索和使用几何类型进行查询时。
- en: For now, let’s see a B-tree index speed up a simple search query. For this exercise,
    we’ll use a large dataset comprising more than 900,000 New York City street addresses,
    compiled by the OpenAddresses project at [https://openaddresses.io/](https://openaddresses.io/).
    The file with the data, *city_of_new_york.csv*, is available for you to download
    along with all the resources for this book from [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 B-tree 索引如何加速一个简单的搜索查询。在这个练习中，我们将使用一个包含超过 900,000 个纽约市街道地址的大型数据集，这些数据由
    OpenAddresses 项目提供，网址为 [https://openaddresses.io/](https://openaddresses.io/)。包含数据的文件
    *city_of_new_york.csv* 可以从 [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)
    下载，和本书的所有资源一起提供。
- en: After you’ve downloaded the file, use the code in [Listing 8-12](#listing8-12)
    to create a `new_york_addresses` table and import the address data. The import
    will take longer than the tiny datasets you’ve loaded so far because the CSV file
    is about 50MB.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，使用 [列表 8-12](#listing8-12) 中的代码创建 `new_york_addresses` 表并导入地址数据。由于 CSV
    文件约为 50MB，导入过程将比您之前加载的小型数据集要慢。
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 8-12: Importing New York City address data'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-12：导入纽约市地址数据
- en: When the data loads, run a quick `SELECT` query to visually check that you have
    940,374 rows and seven columns. A common use for this data might be to search
    for matches in the `street` column, so we’ll use that example for exploring index
    performance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据加载完成后，运行一个快速的 `SELECT` 查询，目视检查是否有 940,374 行和七列。此数据的常见用途可能是搜索 `street` 列中的匹配项，因此我们将以此为例来探索索引性能。
- en: Benchmarking Query Performance with EXPLAIN
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 EXPLAIN 基准测试查询性能
- en: We’ll measure the performance before and after adding an index by using the
    PostgreSQL-specific `EXPLAIN` command, which lists the *query plan* for a specific
    database query. The query plan might include how the database plans to scan the
    table, whether or not it will use indexes, and so on. When we add the `ANALYZE`
    keyword, `EXPLAIN` will carry out the query and show the actual execution time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 PostgreSQL 特定的 `EXPLAIN` 命令来测量添加索引前后的性能，该命令列出特定数据库查询的 *查询计划*。查询计划可能包括数据库计划如何扫描表，是否使用索引等信息。当我们添加
    `ANALYZE` 关键字时，`EXPLAIN` 将执行查询并显示实际执行时间。
- en: Recording Some Control Execution Times
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 记录一些控制执行时间
- en: We’ll use the three queries in [Listing 8-13](#listing8-13) to analyze query
    performance before and after adding an index. We’re using typical `SELECT` queries
    with a `WHERE` clause with `EXPLAIN ANALYZE` included at the beginning. These
    keywords tell the database to execute the query and display statistics about the
    query process and how long it took to execute, rather than show the results.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 [列表 8-13](#listing8-13) 中的三个查询来分析添加索引前后的查询性能。我们使用典型的 `SELECT` 查询，并在开始时包含带有
    `WHERE` 子句的 `EXPLAIN ANALYZE`。这些关键字告诉数据库执行查询并显示查询过程的统计信息以及执行所花费的时间，而不是显示结果。
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 8-13: Benchmark queries for index performance'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-13：索引性能基准查询
- en: 'On my system, the first query returns these stats in the pgAdmin output pane:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，第一个查询返回了以下统计信息，显示在 pgAdmin 输出窗格中：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Not all the output is relevant here, so I won’t decode it all, but two lines
    are pertinent. The first indicates that to find any rows where `street = ''BROADWAY''`,
    the database will conduct a sequential scan 1 of the table. That’s a synonym for
    a full table scan: the database will examine each row and remove any where `street`
    doesn’t match `BROADWAY`. The execution time (on my computer about 389 milliseconds)
    2 is how long the query took to run. Your time will depend on factors including
    your computer hardware.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有输出都与此相关，因此我不会解码全部内容，但有两行是相关的。第一行指出，为了找到 `street = 'BROADWAY'` 的所有行，数据库将对表进行顺序扫描
    1。这是全表扫描的同义词：数据库将检查每一行并删除所有 `street` 不匹配 `BROADWAY` 的行。执行时间（在我的计算机上大约是 389 毫秒）
    2 表示查询运行所需的时间。您的时间将取决于多个因素，包括您的计算机硬件。
- en: For the test, run each query in [Listing 8-13](#listing8-13) several times and
    record the fastest execution time for each. You’ll notice that execution times
    for the same query will vary slightly on each run. That can be the result of several
    factors, from other processes running on the server to the effect of data being
    held in memory after a prior run of the query.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，运行 [列表 8-13](#listing8-13) 中的每个查询多次，并记录每个查询的最快执行时间。您会注意到，相同查询的执行时间在每次运行时会略有不同。这可能是由多个因素造成的，从服务器上其他进程的运行到查询在先前运行后数据被保存在内存中的效果。
- en: Adding the Index
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加索引
- en: Now, let’s see how adding an index changes the query’s search method and execution
    time. [Listing 8-14](#listing8-14) shows the SQL statement for creating the index
    with PostgreSQL.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看添加索引如何改变查询的搜索方法和执行时间。[列表 8-14](#listing8-14)显示了使用 PostgreSQL 创建索引的 SQL
    语句。
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 8-14: Creating a B-tree index on the `new_york_addresses` table'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-14：在 `new_york_addresses` 表上创建 B-tree 索引
- en: Notice that it’s similar to the commands for creating constraints. We give the
    `CREATE INDEX` keywords followed by a name we choose for the index, in this case
    `street_idx`. Then `ON` is added, followed by the target table and column.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与创建约束的命令类似。我们给出 `CREATE INDEX` 关键字，后面跟上我们为索引选择的名称，在这个例子中是 `street_idx`。然后加上
    `ON`，后面是目标表和列。
- en: 'Execute the `CREATE INDEX` statement, and PostgreSQL will scan the values in
    the `street` column and build the index from them. We need to create the index
    only once. When the task finishes, rerun each of the three queries in [Listing
    8-13](#listing8-13) and record the execution times reported by `EXPLAIN ANALYZE`.
    Here’s an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `CREATE INDEX` 语句，PostgreSQL 会扫描 `street` 列中的值，并从中构建索引。我们只需要创建一次索引。当任务完成后，重新运行
    [列表 8-13](#listing8-13) 中的每个查询，并记录 `EXPLAIN ANALYZE` 提供的执行时间。以下是一个示例：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do you notice a change? First, we see that the database is now using an index
    scan on `street_idx` 1 instead of visiting each row in a sequential scan. Also,
    the query speed is now markedly faster 2. [Table 8-1](#table8-1) shows the fastest
    execution times (rounded) from my computer before and after adding the index.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到有什么变化吗？首先，我们看到数据库现在使用的是 `street_idx` 上的索引扫描，而不是逐行扫描。此外，查询速度明显更快了。2 [表 8-1](#table8-1)
    显示了我在添加索引前后计算机上最快的执行时间（已四舍五入）。
- en: 'Table 8-1: Measuring Index Performance'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1：衡量索引性能
- en: '| **Query filter** | **Before index** | **After index** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **查询筛选器** | **索引前** | **索引后** |'
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `WHERE street = ''BROADWAY''` | 92 ms | 5 ms |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `WHERE street = ''BROADWAY''` | 92 毫秒 | 5 毫秒 |'
- en: '| `WHERE street = ''52 STREET''` | 94 ms | 1 ms |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `WHERE street = ''52 STREET''` | 94 毫秒 | 1 毫秒 |'
- en: '| `WHERE street = ''ZWICKY AVENUE''` | 93 ms | <1 ms |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `WHERE street = ''ZWICKY AVENUE''` | 93 毫秒 | <1 毫秒 |'
- en: The execution times are much, much better, nearly a tenth of a second faster
    or more per query. Is a tenth of a second that impressive? Well, whether you’re
    seeking answers in data using repeated querying or creating a database system
    for thousands of users, the time savings adds up.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间大大缩短，每个查询节省了近十分之一秒甚至更多。十分之一秒真的那么令人印象深刻吗？无论你是通过重复查询在数据中寻找答案，还是为成千上万的用户创建一个数据库系统，这些时间节省加起来都是可观的。
- en: If you ever need to remove an index from a table—perhaps if you’re testing the
    performance of several index types—use the `DROP INDEX` command followed by the
    name of the index to remove.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从表中移除索引——也许是为了测试几种索引类型的性能——可以使用 `DROP INDEX` 命令，后面跟上要移除的索引名称。
- en: Considerations When Using Indexes
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用索引时的考虑事项
- en: 'You’ve seen that indexes have significant performance benefits, so does that
    mean you should add an index to every column in a table? Not so fast! Indexes
    are valuable, but they’re not always needed. In addition, they do enlarge the
    database and impose a maintenance cost on writing data. Here are a few tips for
    judging when to uses indexes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到索引具有显著的性能优势，那么这是否意味着你应该为每个表中的列都添加索引呢？别急！索引是有价值的，但并不总是需要的。此外，索引会增大数据库，并对写入数据造成维护成本。以下是一些判断何时使用索引的建议：
- en: Consult the documentation for the database system you’re using to learn about
    the kinds of indexes available and which to use on particular data types. PostgreSQL,
    for example, has five more index types in addition to B-tree. One, called GiST,
    is particularly suited to the geometry data types discussed later in the book.
    Full-text search, which you’ll learn in Chapter 14, also benefits from indexing.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅你所使用的数据库系统的文档，了解可用的索引类型以及在特定数据类型上使用哪些索引。例如，PostgreSQL 除了 B-tree 之外，还拥有五种索引类型。一个叫做
    GiST 的索引类型特别适合本书后面讨论的几何数据类型。全文本搜索（你将在第 14 章学习）也能从索引中受益。
- en: Consider adding indexes to columns you’ll use in table joins. Primary keys are
    indexed by default in PostgreSQL, but foreign key columns in related tables are
    not and are a good target for indexes.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑为你将在表连接中使用的列添加索引。在 PostgreSQL 中，主键默认会被索引，但相关表中的外键列则没有，这些列是添加索引的好目标。
- en: An index on a foreign key will help avoid an expensive sequential scan during
    a cascading delete.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键上的索引有助于避免在级联删除时进行昂贵的顺序扫描。
- en: Add indexes to columns that will frequently end up in a query `WHERE` clause.
    As you’ve seen, search performance is significantly improved via indexes.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为经常出现在查询`WHERE`子句中的列添加索引。如你所见，通过索引，搜索性能得到了显著提升。
- en: Use `EXPLAIN ANALYZE` to test the performance under a variety of configurations.
    Optimization is a process! If an index isn’t being used by the database—and it’s
    not backing up a primary key or other constraint—you can drop it to reduce the
    size of your database and speed up inserts, updates, and deletes.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EXPLAIN ANALYZE`测试在不同配置下的性能。优化是一个过程！如果数据库没有使用某个索引，并且该索引不是主键或其他约束的支持索引，那么你可以删除它，以减少数据库的大小，并加速插入、更新和删除操作。
- en: Wrapping Up
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: With the tools you’ve added to your toolbox in this chapter, you’re ready to
    ensure that the databases you build or inherit are best suited for your collection
    and exploration of data. It’s crucial to define constraints that match the data
    and the expectation of users by not allowing values that don’t make sense, making
    sure values are filled in, and setting up proper relationships between tables.
    You’ve also learned how to make your queries run faster and how to consistently
    organize your database objects. That’s a boon for you and for others who share
    your data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章中添加到你工具箱的工具，你已经准备好确保你构建或继承的数据库最适合你的数据收集和探索工作。至关重要的是要定义与数据和用户预期相匹配的约束，通过不允许不合理的值，确保填充所有值，以及建立表之间的正确关系。你还学会了如何让查询更快运行，并如何一致地组织你的数据库对象。这对你和其他共享你数据的人都是一种帮助。
- en: This chapter concludes the first part of the book, which focused on giving you
    the essentials to dig into SQL databases. We’ll continue building on these foundations
    as we explore more complex queries and strategies for data analysis. In the next
    chapter, we’ll use SQL aggregate functions to assess the quality of a dataset
    and get usable information from it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的第一部分，重点是为你提供深入SQL数据库所需的基本知识。接下来，我们将继续在这些基础上构建，探索更复杂的查询和数据分析策略。在下一章中，我们将使用SQL聚合函数评估数据集的质量，并从中获取可用信息。
