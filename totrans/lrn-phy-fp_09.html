<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch8"><span epub:type="pagebreak" id="page_97"/><span class="big">8</span><br/>TYPE CLASSES</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">We have seen functions that have a concrete type, such as <code>not</code>, which takes a <code>Bool</code> as input and returns a <code>Bool</code> as output. We have also seen functions with types that use a type variable to express that they work with all types, such as <code>head</code>, which takes a list of any type and returns the first element. Use of a type variable expresses commonality over all types.</p>&#13;
<p class="indent">Between the extremes of functions that work with a single type and functions that work with all types is a need to express a more limited commonality among types that does not extend to all types. For example, we would like addition to be available for numeric types like <code>Int</code>, <code>Integer</code>, and <code>Double</code>, without the need to define addition for <em>all</em> types. The term <em>parametric polymorphism</em> is used to express commonality among all types. The <code>head</code> function mentioned earlier is parametric polymorphic on the underlying type of the input list. The term <em>ad-hoc polymorphism</em> is used to express more limited commonality. Type classes are Haskell’s way of providing a mechanism for ad-hoc polymorphism. They express commonality among types that doesn’t extend to all types.</p>&#13;
<p class="indent">In this chapter, we’ll introduce the idea of a type class, along with a number of type classes from the Prelude. We’ll describe which of the basic types <span epub:type="pagebreak" id="page_98"/>are members of these type classes, and why. The explanation for why Haskell has three different exponentiation operators is based on type classes. A <em>section</em> is a function based on an operator and one of its arguments, and many sections have types that involve type classes. While type classes provide a nice way to express commonality, they also allow for the possibility that the compiler cannot figure out concrete types for values when it needs to, and we give an example where the code writer must provide extra type information to the compiler.</p>&#13;
<h3 class="h3" id="ch8lev1">Type Classes and Numbers</h3>&#13;
<p class="noindent">Let us begin by asking GHCi about the type of the number <code>4</code>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t 4</span>&#13;
4 :: Num p =&gt; p</pre>&#13;
<p class="indent">It would be entirely reasonable to expect the type of the number <code>4</code> to be <code>Int</code> or <code>Integer</code>. But the designers of the Haskell language wanted a number like <code>4</code> to be able to be an <code>Int</code>, an <code>Integer</code>, a <code>Double</code>, or even a few other types, depending on the programmer’s needs. For this reason (and other, more compelling reasons), they invented the idea of type classes.</p>&#13;
<p class="indent">A type class is like a club to which a type can belong, and it makes certain functions available to that type. The types <code>Int</code>, <code>Integer</code>, and <code>Double</code> all belong to the type class <code>Num</code> (short for number). Each of these types has addition, subtraction, and multiplication available to it because these functions are owned by the <code>Num</code> type class. When a type belongs to a type class, we say that it is an <em>instance</em> of that type class.</p>&#13;
<p class="indent">The type signature <code>4 :: Num p =&gt; p</code> can be read as “<code>4</code> has type <code>p</code> as long as <code>p</code> is in type class <code>Num</code>.” The letter <code>p</code> is a type variable in this type signature. It can stand for any type. The conditions to the left of the double arrow (<code>=&gt;</code>) are <em>type class constraints</em>. In the type signature above, there is one type class constraint, <code>Num p</code>, which says that <code>p</code> must belong to type class <code>Num</code>.</p>&#13;
<p class="indent">Type classes are a way to express commonality among types. The types <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code> have quite a bit in common; namely, we want to do the same sorts of things with them. We want to be able to add, subtract, and multiply numbers with these types. By having the type class <code>Num</code> own addition, subtraction, and multiplication, we allow the same addition operator that works with <code>Int</code>s to also work with <code>Double</code>s.</p>&#13;
<p class="indent">In the type signature <code>4 :: Num p =&gt; p</code>, GHCi hasn’t committed to a concrete type for the number 4 yet. But this noncommittal attitude about the type of <code>4</code> can’t go on forever. At some point, the Haskell compiler will demand that every value have a concrete type. The inability of the compiler to assign a concrete type to a value can be a source of trouble. However, GHCi has some type-defaulting rules to make our lives easier. For example, if you put the line</p>&#13;
<pre>x = 4</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_99"/>into a program file (say <em>typetest.hs</em>), giving <code>x</code> no type signature, load it into GHCi, and then ask for the type of <code>x</code>,</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l typetest.hs</span>&#13;
[1 of 1] Compiling Main            ( typetest.hs, interpreted )&#13;
Ok, one module loaded.&#13;
*Main&gt; <span class="codestrong1">:t x</span>&#13;
x :: Integer</pre>&#13;
<p class="noindent">GHCi will tell you that <code>x</code> has type <code>Integer</code>. Here, GHCi has committed to a concrete type without our specifying the type.</p>&#13;
<p class="indent">There are other situations, like that in “Example of Type Classes and Plotting” at the end of this chapter, where GHCi feels unable to assign a concrete type, and you will need to help it out by adding type signatures to your code.</p>&#13;
<h3 class="h3" id="ch8lev2">Type Classes from the Prelude</h3>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8tab1">Table 8-1</a> shows several type classes provided by the Prelude. The table also shows which of the basic types are instances of each of the type classes.</p>&#13;
<p class="tabcap" id="ch8tab1"><strong>Table 8-1:</strong> Basic Types That Are Instances of Various Type Classes</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type class</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><code>Bool</code></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><code>Char</code></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><code>Int</code></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><code>Integer</code></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><code>Float</code></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><code>Double</code></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Eq</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Ord</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Show</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Num</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Integral</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Fractional</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>Floating</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"> X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"> X</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The following sections discuss the purpose and use of the type classes listed in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>.</p>&#13;
<h4 class="h4" id="ch8lev3">The Eq Type Class</h4>&#13;
<p class="noindent">We want to be able to ask the computer whether two things are equal. That’s what the <code>==</code> (equality) operator (first introduced in <a href="ch01.xhtml#ch1tab2">Table 1-2</a>) does. But if we are serious about functions having types, what should the type of <code>(==)</code> be?</p>&#13;
<p class="indent">A function that takes two strings as input and gives as output a Boolean value (true or false) that indicates whether the two strings are equal should have the type <code>String -&gt; String -&gt; Bool</code>. A function that takes two integers as input and gives as output a Boolean value indicating whether the two integers are equal should have the type <code>Integer -&gt; Integer -&gt; Bool</code>. It would <span epub:type="pagebreak" id="page_100"/>be an unfortunate state of affairs if we needed a different function for each type (<code>String</code>, <code>Integer</code>, and so on) that we wanted to check for equality. Perhaps a type variable could solve the problem, and the type of <code>(==)</code> could be <code>a -&gt; a -&gt; Bool</code>. That is almost correct, but the type <code>a -&gt; a -&gt; Bool</code> implies that every type <code>a</code> can be checked for equality, while there are some types that can’t be checked for equality (such as function types).</p>&#13;
<p class="indent">The type class <code>Eq</code> is for types that have a notion of equality. In other words, types for which equality checking makes sense will be instances of <code>Eq</code>. These are the types for which the operators <code>==</code> and <code>/=</code> are defined. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that all of the six basic types (<code>Bool</code>, <code>Char</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code>) are instances of <code>Eq</code>.</p>&#13;
<p class="indent">The type of the function <code>(==)</code> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (==)</span>&#13;
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</pre>&#13;
<p class="noindent">which means that we can use the <code>==</code> operator between any two expressions of the same type <code>a</code>, as long as <code>a</code> is an instance of <code>Eq</code>. What sort of type would not be an instance of <code>Eq</code>? Generally function types are not instances of <code>Eq</code>. For example, the type <code>R -&gt; R</code> is not an instance of <code>Eq</code>.</p>&#13;
<p class="indent">The reason is that it is usually difficult or impossible to check whether two functions are equal. (There is a rigorous mathematical result called Richardson’s theorem that gives sufficient conditions, which are quite mild, for when function equality is undecidable.)</p>&#13;
<p class="indent">From the perspective of computational physics, it’s a bad idea that <code>Float</code> and <code>Double</code> are instances of <code>Eq</code>. Because these two types are used for approximate calculation, you should never test <code>Float</code>s and <code>Double</code>s for equality. (The one exception to this rule is that you might check whether a <code>Float</code> or <code>Double</code> is zero before attempting to divide by it.) From the perspective of the computer, these types are each represented by a finite number of bits, and the computer will happily check whether each bit of one <code>Double</code> is the same as the corresponding bit of another <code>Double</code>. But as we saw in <a href="ch01.xhtml">Chapter 1</a>, the bits of <code>sqrt 5 ^ 2</code> are not the same as the bits of <code>5</code>. They are very close, but not the same. If you want to go deeper, a nice introduction to floating-point computation is [<strong><a href="bib.xhtml#bib5"><span class="green">5</span></a></strong>]. The take-home message for computational physics is to avoid using <code>==</code> for approximate types like <code>Double</code>. The issue of equality checking with floating-point numbers is not unique to Haskell or to functional programming. Approximately calculated results should not be tested for equality in any language.</p>&#13;
<h4 class="h4" id="ch8lev4">The Show Type Class</h4>&#13;
<p class="noindent">The type class <code>Show</code> is for types whose values can be shown using text. As indicated in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>, all of the basic types (<code>Bool</code>, <code>Char</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code>) are instances of <code>Show</code>.</p>&#13;
<p class="indent">Function types are not typically instances of <code>Show</code>. If I enter the name of a function at the GHCi prompt, I get a message that complains that there is no <code>Show</code> instance for <code>sqrt</code>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">sqrt</span>&#13;
&#13;
&lt;interactive&gt;:5:1: error:&#13;
    • No instance for (Show (Double -&gt; Double))&#13;
        arising from a use of print&#13;
        (maybe you haven't applied a function to enough arguments?)&#13;
    • In a stmt of an interactive GHCi command: print it</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>GHCi knows how to apply the <code>sqrt</code> function to numbers and show you the result, but it does not know how to show you the <code>sqrt</code> function itself. The reason behind this is the design decision that anything that is a member of the <code>Show</code> type class should also be a member of the <code>Read</code> type class. This means that what can be rendered from its internal form to a <code>String</code> (<code>Show</code> instance) can also be converted from a <code>String</code> back to its internal form (<code>Read</code> instance). If a function’s <code>Show</code> instance returns the function’s name, or even its source definition, it wouldn’t usually be convertible back into its internal representation because the source file context would be missing. Note that <code>sqrt</code> is a perfectly acceptable Haskell expression, with a well-defined type, even though it cannot be shown.</p>&#13;
<h4 class="h4" id="ch8lev5">The Num Type Class</h4>&#13;
<p class="noindent">As we saw earlier, the type class <code>Num</code> is for numeric types. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code> are instances of <code>Num</code>, while <code>Bool</code> and <code>Char</code> are not. The functions <code>(+)</code> (addition), <code>(-)</code> (subtraction), and <code>(*)</code> (multiplication) are owned by <code>Num</code>. The type of the function <code>(+)</code> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (+)</span>&#13;
(+) :: Num a =&gt; a -&gt; a -&gt; a</pre>&#13;
<p class="noindent">meaning that we can use the operator <code>+</code> between any two expressions of the same type <code>a</code>, as long as <code>a</code> is an instance of <code>Num</code>. The result will be an expression of type <code>a</code>. The type class <code>Num</code> allows the addition function <code>(+)</code> to act as though it has the type <code>Int -&gt; Int -&gt; Int</code> or <code>Integer -&gt; Integer -&gt; Integer</code> or <code>Float -&gt; Float -&gt; Float</code> or <code>Double -&gt; Double -&gt; Double</code>.</p>&#13;
<p class="indent">We can ask for information about the <code>Num</code> type class by using GHCi’s <code>:info</code> (or <code>:i</code>) command:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:i Num</span>&#13;
class Num a where&#13;
  (+) :: a -&gt; a -&gt; a&#13;
  (-) :: a -&gt; a -&gt; a&#13;
  (*) :: a -&gt; a -&gt; a&#13;
  negate :: a -&gt; a&#13;
  abs :: a -&gt; a&#13;
  signum :: a -&gt; a&#13;
  fromInteger :: Integer -&gt; a&#13;
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}&#13;
   -- Defined in 'GHC.Num'&#13;
instance Num Word -- Defined in 'GHC.Num'&#13;
instance Num Integer -- Defined in 'GHC.Num'&#13;
instance Num Int -- Defined in 'GHC.Num'&#13;
instance Num Float -- Defined in 'GHC.Float'&#13;
instance Num Double -- Defined in 'GHC.Float'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/>Here we see that <code>Num</code> owns addition, subtraction, multiplication, and a few other functions. We also see some concrete types that are instances of <code>Num</code>.</p>&#13;
<h4 class="h4" id="ch8lev6">The Integral Type Class</h4>&#13;
<p class="noindent">The <code>Integral</code> type class is for types that behave like integers. A type has to be an instance of <code>Num</code> before it can be an instance of <code>Integral</code>. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <code>Int</code> and <code>Integer</code> are instances of <code>Integral</code>, while <code>Float</code> and <code>Double</code> are not. The type of the function <code>rem</code>, which finds the remainder of one integer divided by another, is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t rem</span>&#13;
rem :: Integral a =&gt; a -&gt; a -&gt; a</pre>&#13;
<p class="noindent">meaning that we can use the function <code>rem</code> between any two expressions of the same type <code>a</code>, as long as <code>a</code> is an instance of <code>Integral</code>, and the result will be an expression of type <code>a</code>.</p>&#13;
<h4 class="h4" id="ch8lev7">The Ord Type Class</h4>&#13;
<p class="noindent">We want to be able to compare things, but most people would agree that</p>&#13;
<pre>"kitchen" &gt; 4</pre>&#13;
<p class="noindent">doesn’t make any sense. The designers of the Haskell language decided that such an expression should not evaluate to <code>True</code> or to <code>False</code> but instead should be regarded as a type error. To use one of the comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>), two requirements must be met:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">The two things being compared must have the same type. Let us call this type <code>a</code>.</li>&#13;
<li class="noindent">Type <code>a</code> must belong to the <code>Ord</code> type class.</li>&#13;
</ul>&#13;
<p class="indentt">The <code>Ord</code> type class is for types that have a notion of order. A type must first be an instance of <code>Eq</code> before it may be an instance of <code>Ord</code>. The type of the function <code>(&lt;)</code> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (&lt;)</span>&#13;
(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool</pre>&#13;
<p class="noindent">which means we can use the operator <code>&lt;</code> between any two expressions of the same type <code>a</code>, as long as <code>a</code> is an instance of <code>Ord</code>. The type of <code>(&lt;)</code> expresses both requirements we listed above.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Some types have no obvious notion of comparison. Three-dimensional vectors, for which we’ll define the <code>Vec</code> type in <a href="ch10.xhtml">Chapter 10</a>, have no obvious notion of order. This is not to say that there is no way of defining comparison for vectors. We could compare their magnitudes or their x-components, for example. The point is that there is not a single, obvious candidate for what comparison would mean. Because vectors have no obvious notion of comparison, <code>Vec</code> will not belong to <code>Ord</code>.</p>&#13;
<p class="indent">What about the expression</p>&#13;
<pre>x &gt; y</pre>&#13;
<p class="noindent">if <code>x</code> has the value <code>4.2</code> and <code>y</code> has the value <code>4</code>? Most people would agree that the expression should evaluate to <code>True</code>. But Haskell will regard this expression as an error if <code>x</code> has type <code>Double</code> and <code>y</code> has type <code>Int</code>, because <code>Double</code> and <code>Int</code> are not the same type. To compare two things, we must explicitly convert the type of one thing into the type of the other. To avoid a rounding error, we’d want to convert <code>y</code> (the <code>Int</code>) into a <code>Double</code>. For this, we can use the Prelude function <code>fromIntegral</code>, replacing our original expression <code>x &gt; y</code> with</p>&#13;
<pre>x &gt; fromIntegral y</pre>&#13;
<p class="indent">The type of <code>fromIntegral</code> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t fromIntegral</span>&#13;
fromIntegral :: (Integral a, Num b) =&gt; a -&gt; b</pre>&#13;
<p class="noindent">indicating that <code>fromIntegral</code> will convert any type in <code>Integral</code> into any type in <code>Num</code>. The type checker will figure out that in this case, since <code>x</code> has type <code>Double</code>, <code>y</code> needs to be converted to a <code>Double</code>.</p>&#13;
<p class="indent">Some other programming languages have a process of <em>type coercion</em> that changes the type of a value so that it can be compared with or used with another value. For example, an integer will automatically be changed into a floating-point number when the two are being compared. Haskell does not have automatic type conversion, and the decision to not include this was intentional. The designers of the language believed that many or most type coercions are really mistakes that the programmer did not intend rather than automatic help that the compiler could provide.</p>&#13;
<h4 class="h4" id="ch8lev8">The Fractional Type Class</h4>&#13;
<p class="noindent">The <code>Fractional</code> type class is for numeric types that support division. A type has to be an instance of <code>Num</code> before it can be an instance of <code>Fractional</code>. We see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <code>Float</code> and <code>Double</code> are instances of <code>Fractional</code>, while <code>Int</code> and <code>Integer</code> are not. The type of the function <code>(/)</code> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (/)</span>&#13;
(/) :: Fractional a =&gt; a -&gt; a -&gt; a</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_104"/>meaning that we can use the <code>/</code> operator between any two expressions of the same type <code>a</code>, as long as <code>a</code> is an instance of <code>Fractional</code>. The result will be an expression of type <code>a</code>.</p>&#13;
<h4 class="h4" id="ch8lev9">The Floating Type Class</h4>&#13;
<p class="noindent">The <code>Floating</code> type class is for numeric types that are stored by the computer as floating-point numbers, that is, as inexact approximations. A type has to be an instance of <code>Fractional</code> before it can be an instance of <code>Floating</code>. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <code>Float</code> and <code>Double</code> are instances of <code>Floating</code>, while <code>Int</code> and <code>Integer</code> are not. The type of the function <code>cos</code> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t cos</span>&#13;
cos :: Floating a =&gt; a -&gt; a</pre>&#13;
<p class="noindent">meaning that we can use the <code>cos</code> function on any expression of type <code>a</code>, as long as <code>a</code> is an instance of <code>Floating</code>. The result will be an expression of type <code>a</code>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8fig1">Figure 8-1</a> shows the relationship among the numeric type classes we’ve just discussed.</p>&#13;
<div class="imagel" id="ch8fig1"><img src="Images/104fig01.jpg" alt="Image" width="564" height="298"/></div>&#13;
<p class="figcap"><em>Figure 8-1: Relationship among the numeric type classes <code>Num, Integral, Fractional</code>, and <code>Floating</code></em></p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, types are preceded by a bullet and type classes are not. As you can see, the types <code>Int</code> and <code>Integer</code> are instances of type classes <code>Integral</code> and <code>Num</code>. The types <code>Float</code> and <code>Double</code> are instances of type classes <code>Floating</code>, <code>Fractional</code>, and <code>Num</code>.</p>&#13;
<h3 class="h3" id="ch8lev10">Exponentiation and Type Classes</h3>&#13;
<p class="noindent">Haskell offers three operators for exponentiation, shown in <a href="ch08.xhtml#ch8tab2">Table 8-2</a>. The difference between these operators lies in the type class constraints that each work under and in the methods of implementation. The single caret operator (<code>^</code>) requires that the exponent be a nonnegative integer. Exponentiation by <code>^</code> repeatedly multiplies a <code>Num</code> by itself. The double-caret operator (<code>^^</code>) requires that the exponent be an integer, enforced by the <code>Integral b</code> <span epub:type="pagebreak" id="page_105"/>constraint. The <code>^^</code> operator can be implemented by repeated multiplication and taking reciprocals, and it can accept a negative exponent. The double-star operator (<code>**</code>) requires that the base and the exponent have the same type and that that type be an instance of <code>Floating</code>. This operator requires a more complicated implementation, taking a logarithm and using the exponential function.</p>&#13;
<p class="tabcap" id="ch8tab2"><strong>Table 8-2:</strong> Haskell’s Three Functions for Exponentiation</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(^)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(Integral b, Num a) =&gt; a -&gt; b -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(^^)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>(**)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>Floating a =&gt; a -&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Since <code>Float</code> and <code>Double</code> are members of the <code>Floating</code> type class, and thus represent numbers approximately, the <code>**</code> operator is generally going to do an approximate calculation. This is certainly what you want for a non-integral exponent. Under the right circumstances, the caret and double-caret operators can do exact calculation.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab3">Table 8-3</a> shows which of types (<code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code>) are allowable for the base <code>x</code> and the exponent <code>y</code> in the expression <code>x ^^ y</code>.</p>&#13;
<p class="tabcap" id="ch8tab3"><strong>Table 8-3:</strong> Possible Types for <code>x</code> and <code>y</code> with the Double-Caret Exponentiation Operator</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h1s"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><code>y :: Int</code></strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><code>y :: Integer</code></strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><code>y :: Float</code></strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><code>y :: Double</code></strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba"><code>x :: Int</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba"><code>x :: Integer</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba"><code>x :: Float</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> <code>^^</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> <code>^^</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_normal_right"><p class="taba"><code>x :: Double</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>^^</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>^^</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"/></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Since the base must have a type that is an instance of <code>Fractional</code>, only <code>Float</code> and <code>Double</code> can serve as a type for the base. Since the exponent must have a type that is an instance of <code>Integral</code>, only <code>Int</code> and <code>Integer</code> can serve as a type for the exponent.</p>&#13;
<h3 class="h3" id="ch8lev11">Sections</h3>&#13;
<p class="noindent">An infix operator expects an argument on its left and an argument on its right. If only one of these two arguments is given, the resulting expression can be thought of as a function waiting for the other argument. Haskell allows us to make such functions by enclosing an operator and one of its arguments in parentheses. A function formed by enclosing an operator and one argument in parentheses is called a <em>section</em>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab4">Table 8-4</a> shows examples of sections, with their types. Many useful sections have types with type-class constraints.</p>&#13;
<p class="tabcap" id="ch8tab4"><span epub:type="pagebreak" id="page_106"/><strong>Table 8-4:</strong> Examples of Sections</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>(+1)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Num a =&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(2*)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Num a =&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>(^2)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Num a =&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(2^)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(Integral b, Num a) =&gt; b -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>('A':)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[Char] -&gt; [Char]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(:"end")</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Char -&gt; [Char]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>("I won't " ++)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[Char] -&gt; [Char]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>($ True)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>(Bool -&gt; b) -&gt; b</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, <code>(+1)</code>, which could also be written <code>(1+)</code>, is a function that adds 1 to its argument, and <code>(2*)</code>, which could also be written <code>(*2)</code>, is a function that doubles its argument. However, the sections <code>(^2)</code> and <code>(2^)</code> are not the same function; the former is the squaring function and the latter is the “2 to the power of” function.</p>&#13;
<p class="indent">Sections can be useful in the same way that anonymous functions are useful: they provide a quick way of specifying a function without naming it, often as an input to a higher-order function.</p>&#13;
<p class="indent">Let’s use a section to integrate the squaring function. Using the <code>integral</code> function from <a href="ch06.xhtml">Chapter 6</a>,</p>&#13;
<pre>type R = Double&#13;
&#13;
integral :: R -&gt; (R -&gt; R) -&gt; R -&gt; R -&gt; R&#13;
integral dt f a b&#13;
    = sum [f t * dt | t &lt;- [a+dt/2, a+3*dt/2 .. b - dt/2]]</pre>&#13;
<p class="noindent">we can use a section for the squaring function as follows:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:l TypeClasses</span>&#13;
[1 of 1] Compiling Main            ( TypeClasses.lhs, interpreted )&#13;
Ok, one module loaded.&#13;
*Main&gt; <span class="codestrong1">integral 0.01 (^2) 0 1</span>&#13;
0.33332499999999987</pre>&#13;
<p class="indent">Like anonymous functions, sections give the programmer tools to create functions “on the fly” without having to name them. And like anonymous functions, using sections requires a bit of care since it is easy to forget why you defined a particular section. This is because the terse syntax provides no clue about what you meant when you wrote it. If the meaning of a section is not immediately clear, a short function definition with an evocative name may be a better choice.</p>&#13;
<h3 class="h3" id="ch8lev12">Example of Type Classes and Plotting</h3>&#13;
<p class="noindent">At the beginning of this chapter, we mentioned that the Haskell type checker will sometimes complain if it cannot determine concrete types for each <span epub:type="pagebreak" id="page_107"/>expression it needs to deal with. The solution is to add a type signature or type annotation to your code. As an example of this, create a new program file called <em>typeTrouble.hs</em> with the following code:</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
plot1 = plotFunc [] [0,0.01..10] cos</pre>&#13;
<p class="indent">When I try to load this file into GHCi, I get this horrible-looking error message:</p>&#13;
<pre>typeTrouble.hs:3:9: error:&#13;
    • Ambiguous type variable 'a0' arising from a use of 'plotFunc'&#13;
      prevents the constraint '(Graphics.Gnuplot.Value.Atom.C&#13;
                                  a0)' from being solved.&#13;
      Probable fix: use a type annotation to specify what 'a0' should be.&#13;
      These potential instances exist:&#13;
        instance [safe] Graphics.Gnuplot.Value.Atom.C Integer&#13;
          -- Defined in 'Graphics.Gnuplot.Value.Atom'&#13;
        instance [safe] Graphics.Gnuplot.Value.Atom.C Double&#13;
          -- Defined in 'Graphics.Gnuplot.Value.Atom'&#13;
        instance [safe] Graphics.Gnuplot.Value.Atom.C Float&#13;
          -- Defined in 'Graphics.Gnuplot.Value.Atom'&#13;
        ...plus one other&#13;
        ...plus 11 instances involving out-of-scope types&#13;
        (use -fprint-potential-instances to see them all)&#13;
    • In the expression: plotFunc [] [0, 0.01 .. 10] cos&#13;
      In an equation for 'plot1': plot1 = plotFunc [] [0, 0.01 .. 10] cos&#13;
   |&#13;
3  | plot1 = plotFunc [] [0,0.01..10] cos&#13;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</pre>&#13;
<p class="indent">Don’t panic. This error message contains much more information than we need to solve the problem. The most useful part of the message is the first line, which tells where the problem is in the code (line 3, column 9). At line 3, column 9 of our code is the function <code>plotFunc</code>. Let’s look at the type of <code>plotFunc</code>.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t plotFunc</span>&#13;
&#13;
&lt;interactive&gt;:1:1: error: Variable not in scope: plotFunc</pre>&#13;
<p class="indent">Hmmm. Life just got worse. But this latter error is an easy one. “Variable not in scope” means that GHCi doesn’t know this function. That makes sense, actually, because it’s not included in the Prelude (the collection of built-in functions that are loaded automatically when we start up GHCi), and GHCi refused to load our <em>typeTrouble.hs</em> file because it had a problem with it. At the moment, it has no knowledge of <code>plotFunc</code>. The <code>plotFunc</code> function is <span epub:type="pagebreak" id="page_108"/>defined in the <code>Graphics.Gnuplot.Simple</code> module. We can get access to <code>plotFunc</code> by loading the plotting module manually, like we first did to make a quick plot.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:m Graphics.Gnuplot.Simple</span></pre>&#13;
<p class="indent">Now, let’s ask again for the type of <code>plotFunc</code>.</p>&#13;
<pre>Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotFunc</span>&#13;
plotFunc&#13;
  :: (Graphics.Gnuplot.Value.Atom.C a,&#13;
      Graphics.Gnuplot.Value.Tuple.C a) =&gt;&#13;
     [Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="indent">There are a couple of type class constraints to the left of the <code>=&gt;</code>. I don’t know the specifics of those type classes, but as long as <code>a</code> (a type variable) belongs to those two type classes, the type of <code>plotFunc</code> is the following:</p>&#13;
<pre>[Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="indent">In other words, <code>plotFunc</code> needs a list of <code>Attribute</code>s (we have given an empty list in our examples so far), a list of <code>a</code>s, and a function that takes an <code>a</code> as input and gives back an <code>a</code> as output. If we give <code>plotFunc</code> all this stuff, it will give us back an <code>IO ()</code>, which is a way of saying that it will actually <em>do</em> something for us (make a plot).</p>&#13;
<p class="indent">The key to fixing an “ambiguous type variable” error like this lies in the suggestion of the fifth line in the error message shown earlier. Add a type signature to your code. The Haskell type checker would like more help figuring out the types of things. In particular, it can’t figure out the types of <code>[0,0.01..10]</code> and <code>cos</code>. Let’s ask GHCi about the types of these two.</p>&#13;
<pre>Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t [0,0.01..10]</span>&#13;
[0,0.01..10] :: (Fractional a, Enum a) =&gt; [a]&#13;
Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t cos</span>&#13;
cos :: Floating a =&gt; a -&gt; a</pre>&#13;
<p class="indent">Both of these expressions contain type class constraints.</p>&#13;
<p class="indent">One solution to the problem is to give the list <code>[0,0.01..10]</code> a name and a type signature. Let’s make a program file called <em>typeTrouble2.hs</em> with the following lines:</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
xRange :: [Double]&#13;
xRange = [0,0.01..10]&#13;
&#13;
plot2 = plotFunc [] xRange cos</pre>&#13;
<p class="indent">This program file should load fine and give you a nice plot when you enter <code>plot2</code>. Try it and see.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>A second solution is to specify the type of the list <code>[0,0.01..10]</code> on the line where it’s used. We could make a program file called <em>typeTrouble3.hs</em> with the following lines:</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
plot3 = plotFunc [] ([0,0.01..10] :: [Double]) cos</pre>&#13;
<p class="indent">A third solution, which is my favorite because it involves the fewest keystrokes, is to tell the compiler that the final element of the list, <code>10</code>, has type <code>Double</code>. This implies that all of the elements in the list have type <code>Double</code>.</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
plot4 = plotFunc [] [0,0.01..10 :: Double] cos</pre>&#13;
<p class="indent">The moral of the story is that you should include type signatures for all of the functions you define, and you should be prepared to add more type signatures if the type checker complains.</p>&#13;
<h3 class="h3" id="ch8lev13">Summary</h3>&#13;
<p class="noindent">This chapter introduced the idea of a type class, something that contains types and owns certain functions. We discussed several standard type classes from the Prelude, in addition to functions that have type-class constraints. We saw that a section is a function without a name, formed by combining an operator with one of its arguments. Many sections have types with type-class constraints. Finally, we gave an example where it was necessary to add a type annotation to our code to satisfy the Haskell type checker.</p>&#13;
<p class="indent">With the introduction of type classes, we have described almost all of Haskell’s type system. There are basic types, function types, list types, type variables, and type classes. Once we cover tuple types in the next chapter, we’ll have described Haskell’s type system in full.</p>&#13;
<h3 class="h3" id="ch8lev14">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 8.1.</strong> Is it possible for a type to belong to more than one type class? If so, give an example. If not, why not?</p>&#13;
<p class="noindentts"><strong>Exercise 8.2.</strong> We said in this chapter that function types are typically not instances of <code>Eq</code> because it’s too hard to check whether two functions are equal.</p>&#13;
<p class="alphats">(a) What does it mean mathematically for two functions to be equal?</p>&#13;
<p class="alphats">(b) Why is it usually very hard or impossible for the computer to check if two functions are equal?</p>&#13;
<p class="alphats">(c) Give a specific example of a function type that would be easy to check for equality.</p>&#13;
<p class="noindentts"><strong>Exercise 8.3.</strong> The function <code>(*2)</code> is the same as the function <code>(2*)</code>. Is the function <code>(/2)</code> the same as the function <code>(2/)</code>? Explain what these functions do.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_110"/><strong>Exercise 8.4.</strong> In <a href="ch02.xhtml">Chapter 2</a>, we defined a function <code>square</code>. Now that we know that Haskell has sections, we can see that we didn’t need to define <code>square</code>. Show how to use a section to write the function that squares its argument. How about a section for the function that cubes its argument?</p>&#13;
<p class="noindentts"><strong>Exercise 8.5.</strong> You can get information from GHCi about a type or a type class by using the GHCi command <code>:info</code> (<code>:i</code> for short), followed by the name of the type or type class you want information about. If you ask for information about a type, GHCi will tell you the type classes of which your type is an instance (the line <code>instance Num Double</code>, for example, means that the type <code>Double</code> is an instance of the type class <code>Num</code>). If you ask for information about a type class, GHCi will tell you the types that are instances of your type class.</p>&#13;
<p class="alphats">(a) We showed in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the type <code>Integer</code> was an instance of type classes <code>Eq</code>, <code>Ord</code>, <code>Show</code>, <code>Num</code>, and <code>Integral</code>. There are a few more type classes that we did not discuss of which <code>Integer</code> is also an instance. Find these.</p>&#13;
<p class="alphats">(b) Type class <code>Enum</code> is for types that can be enumerated, or listed. Which Prelude types are instances of <code>Enum</code>?</p>&#13;
<p class="noindentts"><strong>Exercise 8.6.</strong> Find the types of the following Prelude Haskell expressions (some are functions and some are not):</p>&#13;
<p class="alphats">(a) <code>42</code></p>&#13;
<p class="alphats">(b) <code>42.0</code></p>&#13;
<p class="alphats">(c) <code>42.5</code></p>&#13;
<p class="alphats">(d) <code>pi</code></p>&#13;
<p class="alphats">(e) <code>[3,1,4]</code></p>&#13;
<p class="alphats">(f) <code>[3,3.5,4]</code></p>&#13;
<p class="alphats">(g) <code>[3,3.1,pi]</code></p>&#13;
<p class="alphats">(h) <code>(==)</code></p>&#13;
<p class="alphats">(i) <code>(/=)</code></p>&#13;
<p class="alphats">(j) <code>(&lt;)</code></p>&#13;
<p class="alphats">(k) <code>(&lt;=)</code></p>&#13;
<p class="alphats">(l) <code>(+)</code></p>&#13;
<p class="alphats">(m) <code>(-)</code></p>&#13;
<p class="alphats">(n) <code>(*)</code></p>&#13;
<p class="alphats">(o) <code>(/)</code></p>&#13;
<p class="alphats">(p) <code>(^)</code></p>&#13;
<p class="alphats">(q) <code>(**)</code></p>&#13;
<p class="alphats">(r) <code>8/4</code></p>&#13;
<p class="alphats">(s) <code>sqrt</code></p>&#13;
<p class="alphats">(t) <code>cos</code></p>&#13;
<p class="alphats"><span epub:type="pagebreak" id="page_111"/>(u) <code>show</code></p>&#13;
<p class="alphats">(v) <code>(2/)</code></p>&#13;
<p class="noindentts"><strong>Exercise 8.7.</strong> If 8/4 = 2, and <code>2 :: Num a =&gt; a</code> (2 has type <code>a</code> for every type <code>a</code> in type class <code>Num</code>), why does <code>8/4 :: Fractional a =&gt; a</code>?</p>&#13;
<p class="noindentts"><strong>Exercise 8.8.</strong> The functions <code>quot</code>, <code>rem</code>, <code>div</code>, and <code>mod</code> all have to do with integer division and remainders. All of these functions work with types that are instances of type class <code>Integral</code>, as shown in the following table:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>quot</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Integral a =&gt; a -&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>rem</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Integral a =&gt; a -&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>div</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Integral a =&gt; a -&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>mod</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>Integral a =&gt; a -&gt; a -&gt; a</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">By playing around with these functions, try to explain in words what each does. What is the difference between <code>quot</code> and <code>div</code>? What is the difference between <code>rem</code> and <code>mod</code>?</p>&#13;
<p class="noindentts"><strong>Exercise 8.9.</strong> Make a table like <a href="ch08.xhtml#ch8tab3">Table 8-3</a>, showing which of types <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code> can be used for the base <code>x</code> and the exponent <code>y</code> in the expression <code>x ^ y</code>. Do the same for the expression <code>x ** y</code>. Finally, find a pair of types <code>a</code> and <code>b</code> for which there is no exponentiation operator that allows the base to have type <code>a</code> and the exponent to have type <code>b</code>.<span epub:type="pagebreak" id="page_112"/></p>&#13;
</div></body></html>