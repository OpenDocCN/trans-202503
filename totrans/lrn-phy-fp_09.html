<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch8"><span epub:type="pagebreak" id="page_97"/><span class="big">8</span><br/>TYPE CLASSES</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">We have seen functions that have a concrete type, such as <span class="literal">not</span>, which takes a <span class="literal">Bool</span> as input and returns a <span class="literal">Bool</span> as output. We have also seen functions with types that use a type variable to express that they work with all types, such as <span class="literal">head</span>, which takes a list of any type and returns the first element. Use of a type variable expresses commonality over all types.</p>&#13;
<p class="indent">Between the extremes of functions that work with a single type and functions that work with all types is a need to express a more limited commonality among types that does not extend to all types. For example, we would like addition to be available for numeric types like <span class="literal">Int</span>, <span class="literal">Integer</span>, and <span class="literal">Double</span>, without the need to define addition for <em>all</em> types. The term <em>parametric polymorphism</em> is used to express commonality among all types. The <span class="literal">head</span> function mentioned earlier is parametric polymorphic on the underlying type of the input list. The term <em>ad-hoc polymorphism</em> is used to express more limited commonality. Type classes are Haskell’s way of providing a mechanism for ad-hoc polymorphism. They express commonality among types that doesn’t extend to all types.</p>&#13;
<p class="indent">In this chapter, we’ll introduce the idea of a type class, along with a number of type classes from the Prelude. We’ll describe which of the basic types <span epub:type="pagebreak" id="page_98"/>are members of these type classes, and why. The explanation for why Haskell has three different exponentiation operators is based on type classes. A <em>section</em> is a function based on an operator and one of its arguments, and many sections have types that involve type classes. While type classes provide a nice way to express commonality, they also allow for the possibility that the compiler cannot figure out concrete types for values when it needs to, and we give an example where the code writer must provide extra type information to the compiler.</p>&#13;
<h3 class="h3" id="ch8lev1">Type Classes and Numbers</h3>&#13;
<p class="noindent">Let us begin by asking GHCi about the type of the number <span class="literal">4</span>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t 4</span>&#13;
4 :: Num p =&gt; p</pre>&#13;
<p class="indent">It would be entirely reasonable to expect the type of the number <span class="literal">4</span> to be <span class="literal">Int</span> or <span class="literal">Integer</span>. But the designers of the Haskell language wanted a number like <span class="literal">4</span> to be able to be an <span class="literal">Int</span>, an <span class="literal">Integer</span>, a <span class="literal">Double</span>, or even a few other types, depending on the programmer’s needs. For this reason (and other, more compelling reasons), they invented the idea of type classes.</p>&#13;
<p class="indent">A type class is like a club to which a type can belong, and it makes certain functions available to that type. The types <span class="literal">Int</span>, <span class="literal">Integer</span>, and <span class="literal">Double</span> all belong to the type class <span class="literal">Num</span> (short for number). Each of these types has addition, subtraction, and multiplication available to it because these functions are owned by the <span class="literal">Num</span> type class. When a type belongs to a type class, we say that it is an <em>instance</em> of that type class.</p>&#13;
<p class="indent">The type signature <span class="literal">4 :: Num p =&gt; p</span> can be read as “<span class="literal">4</span> has type <span class="literal">p</span> as long as <span class="literal">p</span> is in type class <span class="literal">Num</span>.” The letter <span class="literal">p</span> is a type variable in this type signature. It can stand for any type. The conditions to the left of the double arrow (<span class="literal">=&gt;</span>) are <em>type class constraints</em>. In the type signature above, there is one type class constraint, <span class="literal">Num p</span>, which says that <span class="literal">p</span> must belong to type class <span class="literal">Num</span>.</p>&#13;
<p class="indent">Type classes are a way to express commonality among types. The types <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span> have quite a bit in common; namely, we want to do the same sorts of things with them. We want to be able to add, subtract, and multiply numbers with these types. By having the type class <span class="literal">Num</span> own addition, subtraction, and multiplication, we allow the same addition operator that works with <span class="literal">Int</span>s to also work with <span class="literal">Double</span>s.</p>&#13;
<p class="indent">In the type signature <span class="literal">4 :: Num p =&gt; p</span>, GHCi hasn’t committed to a concrete type for the number 4 yet. But this noncommittal attitude about the type of <span class="literal">4</span> can’t go on forever. At some point, the Haskell compiler will demand that every value have a concrete type. The inability of the compiler to assign a concrete type to a value can be a source of trouble. However, GHCi has some type-defaulting rules to make our lives easier. For example, if you put the line</p>&#13;
<pre>x = 4</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_99"/>into a program file (say <em>typetest.hs</em>), giving <span class="literal">x</span> no type signature, load it into GHCi, and then ask for the type of <span class="literal">x</span>,</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l typetest.hs</span>&#13;
[1 of 1] Compiling Main            ( typetest.hs, interpreted )&#13;
Ok, one module loaded.&#13;
*Main&gt; <span class="codestrong1">:t x</span>&#13;
x :: Integer</pre>&#13;
<p class="noindent">GHCi will tell you that <span class="literal">x</span> has type <span class="literal">Integer</span>. Here, GHCi has committed to a concrete type without our specifying the type.</p>&#13;
<p class="indent">There are other situations, like that in “Example of Type Classes and Plotting” at the end of this chapter, where GHCi feels unable to assign a concrete type, and you will need to help it out by adding type signatures to your code.</p>&#13;
<h3 class="h3" id="ch8lev2">Type Classes from the Prelude</h3>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8tab1">Table 8-1</a> shows several type classes provided by the Prelude. The table also shows which of the basic types are instances of each of the type classes.</p>&#13;
<p class="tabcap" id="ch8tab1"><strong>Table 8-1:</strong> Basic Types That Are Instances of Various Type Classes</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type class</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span class="literal">Bool</span></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span class="literal">Char</span></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span class="literal">Int</span></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span class="literal">Integer</span></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span class="literal">Float</span></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span class="literal">Double</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Eq</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Ord</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Show</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Num</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Integral</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Fractional</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> X</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">Floating</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"> X</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"> X</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The following sections discuss the purpose and use of the type classes listed in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>.</p>&#13;
<h4 class="h4" id="ch8lev3">The Eq Type Class</h4>&#13;
<p class="noindent">We want to be able to ask the computer whether two things are equal. That’s what the <span class="literal">==</span> (equality) operator (first introduced in <a href="ch01.xhtml#ch1tab2">Table 1-2</a>) does. But if we are serious about functions having types, what should the type of <span class="literal">(==)</span> be?</p>&#13;
<p class="indent">A function that takes two strings as input and gives as output a Boolean value (true or false) that indicates whether the two strings are equal should have the type <span class="literal">String -&gt; String -&gt; Bool</span>. A function that takes two integers as input and gives as output a Boolean value indicating whether the two integers are equal should have the type <span class="literal">Integer -&gt; Integer -&gt; Bool</span>. It would <span epub:type="pagebreak" id="page_100"/>be an unfortunate state of affairs if we needed a different function for each type (<span class="literal">String</span>, <span class="literal">Integer</span>, and so on) that we wanted to check for equality. Perhaps a type variable could solve the problem, and the type of <span class="literal">(==)</span> could be <span class="literal">a -&gt; a -&gt; Bool</span>. That is almost correct, but the type <span class="literal">a -&gt; a -&gt; Bool</span> implies that every type <span class="literal">a</span> can be checked for equality, while there are some types that can’t be checked for equality (such as function types).</p>&#13;
<p class="indent">The type class <span class="literal">Eq</span> is for types that have a notion of equality. In other words, types for which equality checking makes sense will be instances of <span class="literal">Eq</span>. These are the types for which the operators <span class="literal">==</span> and <span class="literal">/=</span> are defined. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that all of the six basic types (<span class="literal">Bool</span>, <span class="literal">Char</span>, <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span>) are instances of <span class="literal">Eq</span>.</p>&#13;
<p class="indent">The type of the function <span class="literal">(==)</span> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (==)</span>&#13;
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</pre>&#13;
<p class="noindent">which means that we can use the <span class="literal">==</span> operator between any two expressions of the same type <span class="literal">a</span>, as long as <span class="literal">a</span> is an instance of <span class="literal">Eq</span>. What sort of type would not be an instance of <span class="literal">Eq</span>? Generally function types are not instances of <span class="literal">Eq</span>. For example, the type <span class="literal">R -&gt; R</span> is not an instance of <span class="literal">Eq</span>.</p>&#13;
<p class="indent">The reason is that it is usually difficult or impossible to check whether two functions are equal. (There is a rigorous mathematical result called Richardson’s theorem that gives sufficient conditions, which are quite mild, for when function equality is undecidable.)</p>&#13;
<p class="indent">From the perspective of computational physics, it’s a bad idea that <span class="literal">Float</span> and <span class="literal">Double</span> are instances of <span class="literal">Eq</span>. Because these two types are used for approximate calculation, you should never test <span class="literal">Float</span>s and <span class="literal">Double</span>s for equality. (The one exception to this rule is that you might check whether a <span class="literal">Float</span> or <span class="literal">Double</span> is zero before attempting to divide by it.) From the perspective of the computer, these types are each represented by a finite number of bits, and the computer will happily check whether each bit of one <span class="literal">Double</span> is the same as the corresponding bit of another <span class="literal">Double</span>. But as we saw in <a href="ch01.xhtml">Chapter 1</a>, the bits of <span class="literal">sqrt 5 ^ 2</span> are not the same as the bits of <span class="literal">5</span>. They are very close, but not the same. If you want to go deeper, a nice introduction to floating-point computation is [<strong><a href="bib.xhtml#bib5"><span class="green">5</span></a></strong>]. The take-home message for computational physics is to avoid using <span class="literal">==</span> for approximate types like <span class="literal">Double</span>. The issue of equality checking with floating-point numbers is not unique to Haskell or to functional programming. Approximately calculated results should not be tested for equality in any language.</p>&#13;
<h4 class="h4" id="ch8lev4">The Show Type Class</h4>&#13;
<p class="noindent">The type class <span class="literal">Show</span> is for types whose values can be shown using text. As indicated in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>, all of the basic types (<span class="literal">Bool</span>, <span class="literal">Char</span>, <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span>) are instances of <span class="literal">Show</span>.</p>&#13;
<p class="indent">Function types are not typically instances of <span class="literal">Show</span>. If I enter the name of a function at the GHCi prompt, I get a message that complains that there is no <span class="literal">Show</span> instance for <span class="literal">sqrt</span>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">sqrt</span>&#13;
&#13;
&lt;interactive&gt;:5:1: error:&#13;
    • No instance for (Show (Double -&gt; Double))&#13;
        arising from a use of print&#13;
        (maybe you haven't applied a function to enough arguments?)&#13;
    • In a stmt of an interactive GHCi command: print it</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>GHCi knows how to apply the <span class="literal">sqrt</span> function to numbers and show you the result, but it does not know how to show you the <span class="literal">sqrt</span> function itself. The reason behind this is the design decision that anything that is a member of the <span class="literal">Show</span> type class should also be a member of the <span class="literal">Read</span> type class. This means that what can be rendered from its internal form to a <span class="literal">String</span> (<span class="literal">Show</span> instance) can also be converted from a <span class="literal">String</span> back to its internal form (<span class="literal">Read</span> instance). If a function’s <span class="literal">Show</span> instance returns the function’s name, or even its source definition, it wouldn’t usually be convertible back into its internal representation because the source file context would be missing. Note that <span class="literal">sqrt</span> is a perfectly acceptable Haskell expression, with a well-defined type, even though it cannot be shown.</p>&#13;
<h4 class="h4" id="ch8lev5">The Num Type Class</h4>&#13;
<p class="noindent">As we saw earlier, the type class <span class="literal">Num</span> is for numeric types. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span> are instances of <span class="literal">Num</span>, while <span class="literal">Bool</span> and <span class="literal">Char</span> are not. The functions <span class="literal">(+)</span> (addition), <span class="literal">(-)</span> (subtraction), and <span class="literal">(*)</span> (multiplication) are owned by <span class="literal">Num</span>. The type of the function <span class="literal">(+)</span> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (+)</span>&#13;
(+) :: Num a =&gt; a -&gt; a -&gt; a</pre>&#13;
<p class="noindent">meaning that we can use the operator <span class="literal">+</span> between any two expressions of the same type <span class="literal">a</span>, as long as <span class="literal">a</span> is an instance of <span class="literal">Num</span>. The result will be an expression of type <span class="literal">a</span>. The type class <span class="literal">Num</span> allows the addition function <span class="literal">(+)</span> to act as though it has the type <span class="literal">Int -&gt; Int -&gt; Int</span> or <span class="literal">Integer -&gt; Integer -&gt; Integer</span> or <span class="literal">Float -&gt; Float -&gt; Float</span> or <span class="literal">Double -&gt; Double -&gt; Double</span>.</p>&#13;
<p class="indent">We can ask for information about the <span class="literal">Num</span> type class by using GHCi’s <span class="literal">:info</span> (or <span class="literal">:i</span>) command:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:i Num</span>&#13;
class Num a where&#13;
  (+) :: a -&gt; a -&gt; a&#13;
  (-) :: a -&gt; a -&gt; a&#13;
  (*) :: a -&gt; a -&gt; a&#13;
  negate :: a -&gt; a&#13;
  abs :: a -&gt; a&#13;
  signum :: a -&gt; a&#13;
  fromInteger :: Integer -&gt; a&#13;
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}&#13;
   -- Defined in 'GHC.Num'&#13;
instance Num Word -- Defined in 'GHC.Num'&#13;
instance Num Integer -- Defined in 'GHC.Num'&#13;
instance Num Int -- Defined in 'GHC.Num'&#13;
instance Num Float -- Defined in 'GHC.Float'&#13;
instance Num Double -- Defined in 'GHC.Float'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/>Here we see that <span class="literal">Num</span> owns addition, subtraction, multiplication, and a few other functions. We also see some concrete types that are instances of <span class="literal">Num</span>.</p>&#13;
<h4 class="h4" id="ch8lev6">The Integral Type Class</h4>&#13;
<p class="noindent">The <span class="literal">Integral</span> type class is for types that behave like integers. A type has to be an instance of <span class="literal">Num</span> before it can be an instance of <span class="literal">Integral</span>. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <span class="literal">Int</span> and <span class="literal">Integer</span> are instances of <span class="literal">Integral</span>, while <span class="literal">Float</span> and <span class="literal">Double</span> are not. The type of the function <span class="literal">rem</span>, which finds the remainder of one integer divided by another, is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t rem</span>&#13;
rem :: Integral a =&gt; a -&gt; a -&gt; a</pre>&#13;
<p class="noindent">meaning that we can use the function <span class="literal">rem</span> between any two expressions of the same type <span class="literal">a</span>, as long as <span class="literal">a</span> is an instance of <span class="literal">Integral</span>, and the result will be an expression of type <span class="literal">a</span>.</p>&#13;
<h4 class="h4" id="ch8lev7">The Ord Type Class</h4>&#13;
<p class="noindent">We want to be able to compare things, but most people would agree that</p>&#13;
<pre>"kitchen" &gt; 4</pre>&#13;
<p class="noindent">doesn’t make any sense. The designers of the Haskell language decided that such an expression should not evaluate to <span class="literal">True</span> or to <span class="literal">False</span> but instead should be regarded as a type error. To use one of the comparison operators (<span class="literal">&lt;</span>, <span class="literal">&lt;=</span>, <span class="literal">&gt;</span>, or <span class="literal">&gt;=</span>), two requirements must be met:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">The two things being compared must have the same type. Let us call this type <span class="literal">a</span>.</li>&#13;
<li class="noindent">Type <span class="literal">a</span> must belong to the <span class="literal">Ord</span> type class.</li>&#13;
</ul>&#13;
<p class="indentt">The <span class="literal">Ord</span> type class is for types that have a notion of order. A type must first be an instance of <span class="literal">Eq</span> before it may be an instance of <span class="literal">Ord</span>. The type of the function <span class="literal">(&lt;)</span> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (&lt;)</span>&#13;
(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool</pre>&#13;
<p class="noindent">which means we can use the operator <span class="literal">&lt;</span> between any two expressions of the same type <span class="literal">a</span>, as long as <span class="literal">a</span> is an instance of <span class="literal">Ord</span>. The type of <span class="literal">(&lt;)</span> expresses both requirements we listed above.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Some types have no obvious notion of comparison. Three-dimensional vectors, for which we’ll define the <span class="literal">Vec</span> type in <a href="ch10.xhtml">Chapter 10</a>, have no obvious notion of order. This is not to say that there is no way of defining comparison for vectors. We could compare their magnitudes or their x-components, for example. The point is that there is not a single, obvious candidate for what comparison would mean. Because vectors have no obvious notion of comparison, <span class="literal">Vec</span> will not belong to <span class="literal">Ord</span>.</p>&#13;
<p class="indent">What about the expression</p>&#13;
<pre>x &gt; y</pre>&#13;
<p class="noindent">if <span class="literal">x</span> has the value <span class="literal">4.2</span> and <span class="literal">y</span> has the value <span class="literal">4</span>? Most people would agree that the expression should evaluate to <span class="literal">True</span>. But Haskell will regard this expression as an error if <span class="literal">x</span> has type <span class="literal">Double</span> and <span class="literal">y</span> has type <span class="literal">Int</span>, because <span class="literal">Double</span> and <span class="literal">Int</span> are not the same type. To compare two things, we must explicitly convert the type of one thing into the type of the other. To avoid a rounding error, we’d want to convert <span class="literal">y</span> (the <span class="literal">Int</span>) into a <span class="literal">Double</span>. For this, we can use the Prelude function <span class="literal">fromIntegral</span>, replacing our original expression <span class="literal">x &gt; y</span> with</p>&#13;
<pre>x &gt; fromIntegral y</pre>&#13;
<p class="indent">The type of <span class="literal">fromIntegral</span> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t fromIntegral</span>&#13;
fromIntegral :: (Integral a, Num b) =&gt; a -&gt; b</pre>&#13;
<p class="noindent">indicating that <span class="literal">fromIntegral</span> will convert any type in <span class="literal">Integral</span> into any type in <span class="literal">Num</span>. The type checker will figure out that in this case, since <span class="literal">x</span> has type <span class="literal">Double</span>, <span class="literal">y</span> needs to be converted to a <span class="literal">Double</span>.</p>&#13;
<p class="indent">Some other programming languages have a process of <em>type coercion</em> that changes the type of a value so that it can be compared with or used with another value. For example, an integer will automatically be changed into a floating-point number when the two are being compared. Haskell does not have automatic type conversion, and the decision to not include this was intentional. The designers of the language believed that many or most type coercions are really mistakes that the programmer did not intend rather than automatic help that the compiler could provide.</p>&#13;
<h4 class="h4" id="ch8lev8">The Fractional Type Class</h4>&#13;
<p class="noindent">The <span class="literal">Fractional</span> type class is for numeric types that support division. A type has to be an instance of <span class="literal">Num</span> before it can be an instance of <span class="literal">Fractional</span>. We see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <span class="literal">Float</span> and <span class="literal">Double</span> are instances of <span class="literal">Fractional</span>, while <span class="literal">Int</span> and <span class="literal">Integer</span> are not. The type of the function <span class="literal">(/)</span> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t (/)</span>&#13;
(/) :: Fractional a =&gt; a -&gt; a -&gt; a</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_104"/>meaning that we can use the <span class="literal">/</span> operator between any two expressions of the same type <span class="literal">a</span>, as long as <span class="literal">a</span> is an instance of <span class="literal">Fractional</span>. The result will be an expression of type <span class="literal">a</span>.</p>&#13;
<h4 class="h4" id="ch8lev9">The Floating Type Class</h4>&#13;
<p class="noindent">The <span class="literal">Floating</span> type class is for numeric types that are stored by the computer as floating-point numbers, that is, as inexact approximations. A type has to be an instance of <span class="literal">Fractional</span> before it can be an instance of <span class="literal">Floating</span>. You can see in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the types <span class="literal">Float</span> and <span class="literal">Double</span> are instances of <span class="literal">Floating</span>, while <span class="literal">Int</span> and <span class="literal">Integer</span> are not. The type of the function <span class="literal">cos</span> is</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t cos</span>&#13;
cos :: Floating a =&gt; a -&gt; a</pre>&#13;
<p class="noindent">meaning that we can use the <span class="literal">cos</span> function on any expression of type <span class="literal">a</span>, as long as <span class="literal">a</span> is an instance of <span class="literal">Floating</span>. The result will be an expression of type <span class="literal">a</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8fig1">Figure 8-1</a> shows the relationship among the numeric type classes we’ve just discussed.</p>&#13;
<div class="imagel" id="ch8fig1"><img src="Images/104fig01.jpg" alt="Image" width="564" height="298"/></div>&#13;
<p class="figcap"><em>Figure 8-1: Relationship among the numeric type classes <span class="literal">Num, Integral, Fractional</span>, and <span class="literal">Floating</span></em></p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, types are preceded by a bullet and type classes are not. As you can see, the types <span class="literal">Int</span> and <span class="literal">Integer</span> are instances of type classes <span class="literal">Integral</span> and <span class="literal">Num</span>. The types <span class="literal">Float</span> and <span class="literal">Double</span> are instances of type classes <span class="literal">Floating</span>, <span class="literal">Fractional</span>, and <span class="literal">Num</span>.</p>&#13;
<h3 class="h3" id="ch8lev10">Exponentiation and Type Classes</h3>&#13;
<p class="noindent">Haskell offers three operators for exponentiation, shown in <a href="ch08.xhtml#ch8tab2">Table 8-2</a>. The difference between these operators lies in the type class constraints that each work under and in the methods of implementation. The single caret operator (<span class="literal">^</span>) requires that the exponent be a nonnegative integer. Exponentiation by <span class="literal">^</span> repeatedly multiplies a <span class="literal">Num</span> by itself. The double-caret operator (<span class="literal">^^</span>) requires that the exponent be an integer, enforced by the <span class="literal">Integral b</span> <span epub:type="pagebreak" id="page_105"/>constraint. The <span class="literal">^^</span> operator can be implemented by repeated multiplication and taking reciprocals, and it can accept a negative exponent. The double-star operator (<span class="literal">**</span>) requires that the base and the exponent have the same type and that that type be an instance of <span class="literal">Floating</span>. This operator requires a more complicated implementation, taking a logarithm and using the exponential function.</p>&#13;
<p class="tabcap" id="ch8tab2"><strong>Table 8-2:</strong> Haskell’s Three Functions for Exponentiation</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(^)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(Integral b, Num a) =&gt; a -&gt; b -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(^^)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">(**)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">Floating a =&gt; a -&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Since <span class="literal">Float</span> and <span class="literal">Double</span> are members of the <span class="literal">Floating</span> type class, and thus represent numbers approximately, the <span class="literal">**</span> operator is generally going to do an approximate calculation. This is certainly what you want for a non-integral exponent. Under the right circumstances, the caret and double-caret operators can do exact calculation.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab3">Table 8-3</a> shows which of types (<span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span>) are allowable for the base <span class="literal">x</span> and the exponent <span class="literal">y</span> in the expression <span class="literal">x ^^ y</span>.</p>&#13;
<p class="tabcap" id="ch8tab3"><strong>Table 8-3:</strong> Possible Types for <span class="literal">x</span> and <span class="literal">y</span> with the Double-Caret Exponentiation Operator</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h1s"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><span class="literal">y :: Int</span></strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><span class="literal">y :: Integer</span></strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><span class="literal">y :: Float</span></strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong><span class="literal">y :: Double</span></strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba"><span class="literal">x :: Int</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba"><span class="literal">x :: Integer</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba"><span class="literal">x :: Float</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> <span class="literal">^^</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> <span class="literal">^^</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_normal_right"><p class="taba"><span class="literal">x :: Double</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">^^</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">^^</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"/></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Since the base must have a type that is an instance of <span class="literal">Fractional</span>, only <span class="literal">Float</span> and <span class="literal">Double</span> can serve as a type for the base. Since the exponent must have a type that is an instance of <span class="literal">Integral</span>, only <span class="literal">Int</span> and <span class="literal">Integer</span> can serve as a type for the exponent.</p>&#13;
<h3 class="h3" id="ch8lev11">Sections</h3>&#13;
<p class="noindent">An infix operator expects an argument on its left and an argument on its right. If only one of these two arguments is given, the resulting expression can be thought of as a function waiting for the other argument. Haskell allows us to make such functions by enclosing an operator and one of its arguments in parentheses. A function formed by enclosing an operator and one argument in parentheses is called a <em>section</em>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab4">Table 8-4</a> shows examples of sections, with their types. Many useful sections have types with type-class constraints.</p>&#13;
<p class="tabcap" id="ch8tab4"><span epub:type="pagebreak" id="page_106"/><strong>Table 8-4:</strong> Examples of Sections</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(+1)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Num a =&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(2*)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Num a =&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(^2)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Num a =&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(2^)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(Integral b, Num a) =&gt; b -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">('A':)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[Char] -&gt; [Char]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(:"end")</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Char -&gt; [Char]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">("I won't " ++)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[Char] -&gt; [Char]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">($ True)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">(Bool -&gt; b) -&gt; b</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, <span class="literal">(+1)</span>, which could also be written <span class="literal">(1+)</span>, is a function that adds 1 to its argument, and <span class="literal">(2*)</span>, which could also be written <span class="literal">(*2)</span>, is a function that doubles its argument. However, the sections <span class="literal">(^2)</span> and <span class="literal">(2^)</span> are not the same function; the former is the squaring function and the latter is the “2 to the power of” function.</p>&#13;
<p class="indent">Sections can be useful in the same way that anonymous functions are useful: they provide a quick way of specifying a function without naming it, often as an input to a higher-order function.</p>&#13;
<p class="indent">Let’s use a section to integrate the squaring function. Using the <span class="literal">integral</span> function from <a href="ch06.xhtml">Chapter 6</a>,</p>&#13;
<pre>type R = Double&#13;
&#13;
integral :: R -&gt; (R -&gt; R) -&gt; R -&gt; R -&gt; R&#13;
integral dt f a b&#13;
    = sum [f t * dt | t &lt;- [a+dt/2, a+3*dt/2 .. b - dt/2]]</pre>&#13;
<p class="noindent">we can use a section for the squaring function as follows:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:l TypeClasses</span>&#13;
[1 of 1] Compiling Main            ( TypeClasses.lhs, interpreted )&#13;
Ok, one module loaded.&#13;
*Main&gt; <span class="codestrong1">integral 0.01 (^2) 0 1</span>&#13;
0.33332499999999987</pre>&#13;
<p class="indent">Like anonymous functions, sections give the programmer tools to create functions “on the fly” without having to name them. And like anonymous functions, using sections requires a bit of care since it is easy to forget why you defined a particular section. This is because the terse syntax provides no clue about what you meant when you wrote it. If the meaning of a section is not immediately clear, a short function definition with an evocative name may be a better choice.</p>&#13;
<h3 class="h3" id="ch8lev12">Example of Type Classes and Plotting</h3>&#13;
<p class="noindent">At the beginning of this chapter, we mentioned that the Haskell type checker will sometimes complain if it cannot determine concrete types for each <span epub:type="pagebreak" id="page_107"/>expression it needs to deal with. The solution is to add a type signature or type annotation to your code. As an example of this, create a new program file called <em>typeTrouble.hs</em> with the following code:</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
plot1 = plotFunc [] [0,0.01..10] cos</pre>&#13;
<p class="indent">When I try to load this file into GHCi, I get this horrible-looking error message:</p>&#13;
<pre>typeTrouble.hs:3:9: error:&#13;
    • Ambiguous type variable 'a0' arising from a use of 'plotFunc'&#13;
      prevents the constraint '(Graphics.Gnuplot.Value.Atom.C&#13;
                                  a0)' from being solved.&#13;
      Probable fix: use a type annotation to specify what 'a0' should be.&#13;
      These potential instances exist:&#13;
        instance [safe] Graphics.Gnuplot.Value.Atom.C Integer&#13;
          -- Defined in 'Graphics.Gnuplot.Value.Atom'&#13;
        instance [safe] Graphics.Gnuplot.Value.Atom.C Double&#13;
          -- Defined in 'Graphics.Gnuplot.Value.Atom'&#13;
        instance [safe] Graphics.Gnuplot.Value.Atom.C Float&#13;
          -- Defined in 'Graphics.Gnuplot.Value.Atom'&#13;
        ...plus one other&#13;
        ...plus 11 instances involving out-of-scope types&#13;
        (use -fprint-potential-instances to see them all)&#13;
    • In the expression: plotFunc [] [0, 0.01 .. 10] cos&#13;
      In an equation for 'plot1': plot1 = plotFunc [] [0, 0.01 .. 10] cos&#13;
   |&#13;
3  | plot1 = plotFunc [] [0,0.01..10] cos&#13;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</pre>&#13;
<p class="indent">Don’t panic. This error message contains much more information than we need to solve the problem. The most useful part of the message is the first line, which tells where the problem is in the code (line 3, column 9). At line 3, column 9 of our code is the function <span class="literal">plotFunc</span>. Let’s look at the type of <span class="literal">plotFunc</span>.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t plotFunc</span>&#13;
&#13;
&lt;interactive&gt;:1:1: error: Variable not in scope: plotFunc</pre>&#13;
<p class="indent">Hmmm. Life just got worse. But this latter error is an easy one. “Variable not in scope” means that GHCi doesn’t know this function. That makes sense, actually, because it’s not included in the Prelude (the collection of built-in functions that are loaded automatically when we start up GHCi), and GHCi refused to load our <em>typeTrouble.hs</em> file because it had a problem with it. At the moment, it has no knowledge of <span class="literal">plotFunc</span>. The <span class="literal">plotFunc</span> function is <span epub:type="pagebreak" id="page_108"/>defined in the <span class="literal">Graphics.Gnuplot.Simple</span> module. We can get access to <span class="literal">plotFunc</span> by loading the plotting module manually, like we first did to make a quick plot.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:m Graphics.Gnuplot.Simple</span></pre>&#13;
<p class="indent">Now, let’s ask again for the type of <span class="literal">plotFunc</span>.</p>&#13;
<pre>Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotFunc</span>&#13;
plotFunc&#13;
  :: (Graphics.Gnuplot.Value.Atom.C a,&#13;
      Graphics.Gnuplot.Value.Tuple.C a) =&gt;&#13;
     [Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="indent">There are a couple of type class constraints to the left of the <span class="literal">=&gt;</span>. I don’t know the specifics of those type classes, but as long as <span class="literal">a</span> (a type variable) belongs to those two type classes, the type of <span class="literal">plotFunc</span> is the following:</p>&#13;
<pre>[Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="indent">In other words, <span class="literal">plotFunc</span> needs a list of <span class="literal">Attribute</span>s (we have given an empty list in our examples so far), a list of <span class="literal">a</span>s, and a function that takes an <span class="literal">a</span> as input and gives back an <span class="literal">a</span> as output. If we give <span class="literal">plotFunc</span> all this stuff, it will give us back an <span class="literal">IO ()</span>, which is a way of saying that it will actually <em>do</em> something for us (make a plot).</p>&#13;
<p class="indent">The key to fixing an “ambiguous type variable” error like this lies in the suggestion of the fifth line in the error message shown earlier. Add a type signature to your code. The Haskell type checker would like more help figuring out the types of things. In particular, it can’t figure out the types of <span class="literal">[0,0.01..10]</span> and <span class="literal">cos</span>. Let’s ask GHCi about the types of these two.</p>&#13;
<pre>Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t [0,0.01..10]</span>&#13;
[0,0.01..10] :: (Fractional a, Enum a) =&gt; [a]&#13;
Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t cos</span>&#13;
cos :: Floating a =&gt; a -&gt; a</pre>&#13;
<p class="indent">Both of these expressions contain type class constraints.</p>&#13;
<p class="indent">One solution to the problem is to give the list <span class="literal">[0,0.01..10]</span> a name and a type signature. Let’s make a program file called <em>typeTrouble2.hs</em> with the following lines:</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
xRange :: [Double]&#13;
xRange = [0,0.01..10]&#13;
&#13;
plot2 = plotFunc [] xRange cos</pre>&#13;
<p class="indent">This program file should load fine and give you a nice plot when you enter <span class="literal">plot2</span>. Try it and see.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>A second solution is to specify the type of the list <span class="literal">[0,0.01..10]</span> on the line where it’s used. We could make a program file called <em>typeTrouble3.hs</em> with the following lines:</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
plot3 = plotFunc [] ([0,0.01..10] :: [Double]) cos</pre>&#13;
<p class="indent">A third solution, which is my favorite because it involves the fewest keystrokes, is to tell the compiler that the final element of the list, <span class="literal">10</span>, has type <span class="literal">Double</span>. This implies that all of the elements in the list have type <span class="literal">Double</span>.</p>&#13;
<pre>import Graphics.Gnuplot.Simple&#13;
&#13;
plot4 = plotFunc [] [0,0.01..10 :: Double] cos</pre>&#13;
<p class="indent">The moral of the story is that you should include type signatures for all of the functions you define, and you should be prepared to add more type signatures if the type checker complains.</p>&#13;
<h3 class="h3" id="ch8lev13">Summary</h3>&#13;
<p class="noindent">This chapter introduced the idea of a type class, something that contains types and owns certain functions. We discussed several standard type classes from the Prelude, in addition to functions that have type-class constraints. We saw that a section is a function without a name, formed by combining an operator with one of its arguments. Many sections have types with type-class constraints. Finally, we gave an example where it was necessary to add a type annotation to our code to satisfy the Haskell type checker.</p>&#13;
<p class="indent">With the introduction of type classes, we have described almost all of Haskell’s type system. There are basic types, function types, list types, type variables, and type classes. Once we cover tuple types in the next chapter, we’ll have described Haskell’s type system in full.</p>&#13;
<h3 class="h3" id="ch8lev14">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 8.1.</strong> Is it possible for a type to belong to more than one type class? If so, give an example. If not, why not?</p>&#13;
<p class="noindentts"><strong>Exercise 8.2.</strong> We said in this chapter that function types are typically not instances of <span class="literal">Eq</span> because it’s too hard to check whether two functions are equal.</p>&#13;
<p class="alphats">(a) What does it mean mathematically for two functions to be equal?</p>&#13;
<p class="alphats">(b) Why is it usually very hard or impossible for the computer to check if two functions are equal?</p>&#13;
<p class="alphats">(c) Give a specific example of a function type that would be easy to check for equality.</p>&#13;
<p class="noindentts"><strong>Exercise 8.3.</strong> The function <span class="literal">(*2)</span> is the same as the function <span class="literal">(2*)</span>. Is the function <span class="literal">(/2)</span> the same as the function <span class="literal">(2/)</span>? Explain what these functions do.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_110"/><strong>Exercise 8.4.</strong> In <a href="ch02.xhtml">Chapter 2</a>, we defined a function <span class="literal">square</span>. Now that we know that Haskell has sections, we can see that we didn’t need to define <span class="literal">square</span>. Show how to use a section to write the function that squares its argument. How about a section for the function that cubes its argument?</p>&#13;
<p class="noindentts"><strong>Exercise 8.5.</strong> You can get information from GHCi about a type or a type class by using the GHCi command <span class="literal">:info</span> (<span class="literal">:i</span> for short), followed by the name of the type or type class you want information about. If you ask for information about a type, GHCi will tell you the type classes of which your type is an instance (the line <span class="literal">instance Num Double</span>, for example, means that the type <span class="literal">Double</span> is an instance of the type class <span class="literal">Num</span>). If you ask for information about a type class, GHCi will tell you the types that are instances of your type class.</p>&#13;
<p class="alphats">(a) We showed in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> that the type <span class="literal">Integer</span> was an instance of type classes <span class="literal">Eq</span>, <span class="literal">Ord</span>, <span class="literal">Show</span>, <span class="literal">Num</span>, and <span class="literal">Integral</span>. There are a few more type classes that we did not discuss of which <span class="literal">Integer</span> is also an instance. Find these.</p>&#13;
<p class="alphats">(b) Type class <span class="literal">Enum</span> is for types that can be enumerated, or listed. Which Prelude types are instances of <span class="literal">Enum</span>?</p>&#13;
<p class="noindentts"><strong>Exercise 8.6.</strong> Find the types of the following Prelude Haskell expressions (some are functions and some are not):</p>&#13;
<p class="alphats">(a) <span class="literal">42</span></p>&#13;
<p class="alphats">(b) <span class="literal">42.0</span></p>&#13;
<p class="alphats">(c) <span class="literal">42.5</span></p>&#13;
<p class="alphats">(d) <span class="literal">pi</span></p>&#13;
<p class="alphats">(e) <span class="literal">[3,1,4]</span></p>&#13;
<p class="alphats">(f) <span class="literal">[3,3.5,4]</span></p>&#13;
<p class="alphats">(g) <span class="literal">[3,3.1,pi]</span></p>&#13;
<p class="alphats">(h) <span class="literal">(==)</span></p>&#13;
<p class="alphats">(i) <span class="literal">(/=)</span></p>&#13;
<p class="alphats">(j) <span class="literal">(&lt;)</span></p>&#13;
<p class="alphats">(k) <span class="literal">(&lt;=)</span></p>&#13;
<p class="alphats">(l) <span class="literal">(+)</span></p>&#13;
<p class="alphats">(m) <span class="literal">(-)</span></p>&#13;
<p class="alphats">(n) <span class="literal">(*)</span></p>&#13;
<p class="alphats">(o) <span class="literal">(/)</span></p>&#13;
<p class="alphats">(p) <span class="literal">(^)</span></p>&#13;
<p class="alphats">(q) <span class="literal">(**)</span></p>&#13;
<p class="alphats">(r) <span class="literal">8/4</span></p>&#13;
<p class="alphats">(s) <span class="literal">sqrt</span></p>&#13;
<p class="alphats">(t) <span class="literal">cos</span></p>&#13;
<p class="alphats"><span epub:type="pagebreak" id="page_111"/>(u) <span class="literal">show</span></p>&#13;
<p class="alphats">(v) <span class="literal">(2/)</span></p>&#13;
<p class="noindentts"><strong>Exercise 8.7.</strong> If 8/4 = 2, and <span class="literal">2 :: Num a =&gt; a</span> (2 has type <span class="literal">a</span> for every type <span class="literal">a</span> in type class <span class="literal">Num</span>), why does <span class="literal">8/4 :: Fractional a =&gt; a</span>?</p>&#13;
<p class="noindentts"><strong>Exercise 8.8.</strong> The functions <span class="literal">quot</span>, <span class="literal">rem</span>, <span class="literal">div</span>, and <span class="literal">mod</span> all have to do with integer division and remainders. All of these functions work with types that are instances of type class <span class="literal">Integral</span>, as shown in the following table:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">quot</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Integral a =&gt; a -&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">rem</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Integral a =&gt; a -&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">div</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Integral a =&gt; a -&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">mod</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">Integral a =&gt; a -&gt; a -&gt; a</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">By playing around with these functions, try to explain in words what each does. What is the difference between <span class="literal">quot</span> and <span class="literal">div</span>? What is the difference between <span class="literal">rem</span> and <span class="literal">mod</span>?</p>&#13;
<p class="noindentts"><strong>Exercise 8.9.</strong> Make a table like <a href="ch08.xhtml#ch8tab3">Table 8-3</a>, showing which of types <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span> can be used for the base <span class="literal">x</span> and the exponent <span class="literal">y</span> in the expression <span class="literal">x ^ y</span>. Do the same for the expression <span class="literal">x ** y</span>. Finally, find a pair of types <span class="literal">a</span> and <span class="literal">b</span> for which there is no exponentiation operator that allows the base to have type <span class="literal">a</span> and the exponent to have type <span class="literal">b</span>.<span epub:type="pagebreak" id="page_112"/></p>&#13;
</div></body></html>