- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REMOTE
    CONTROL VIA TELEGRAM</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">通过
    TELEGRAM 远程控制</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Controlling your Arduino from a distance greater than your local area network
    often requires paid IoT services, such as Blynk or Microsoft Azure, or some complex
    coding and time. For a simpler and less expensive way to remotely control your
    Arduino and retrieve data, you can use the Telegram instant-messaging service
    and an ESP32-based Arduino-compatible board.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程控制 Arduino，超出本地网络的范围，通常需要付费的物联网服务，例如 Blynk 或 Microsoft Azure，或者一些复杂的编码和时间。为了更简单且成本更低的远程控制方式，你可以使用
    Telegram 即时消息服务和基于 ESP32 的 Arduino 兼容板。
- en: Telegram is a free, globally accessible cross-platform encrypted messaging service
    that allows users to chat with each other one on one or in groups on a relatively
    secret basis. Thanks to Telegram’s automation feature, you can get an Arduino
    to control a Telegram user account to send and receive data over the service.
    This allows you to build remote-controlled devices and remotely request data from
    an internet-connected Arduino using Telegram.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Telegram 是一款免费的全球可访问的跨平台加密消息服务，允许用户以相对隐秘的方式进行一对一或群组聊天。得益于 Telegram 的自动化功能，你可以让
    Arduino 控制一个 Telegram 用户账户，通过该服务发送和接收数据。这使你能够构建远程控制的设备，并使用 Telegram 从连接到互联网的 Arduino
    远程请求数据。
- en: 'In this chapter, I’ll introduce you to the Telegram app and web interface.
    You’ll interface Arduino sketches with the Telegram library. You’ll learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍 Telegram 应用和网页版界面。你将学习如何将 Arduino 程序与 Telegram 库连接。你将学到：
- en: Create a simple remote to control digital output pins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的遥控器来控制数字输出引脚
- en: Build a project that remotely retrieves data generated by the BMP180 sensor
    board
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个项目，远程检索 BMP180 传感器板生成的数据
- en: Configure an automated data transmitter that you can monitor from the internet
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个你可以从互联网监控的自动化数据传输器
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring Your Telegram Account</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">配置你的 Telegram 账户</samp>
- en: You can communicate over Telegram using either an app on your device or a web
    browser on almost any device connected to the internet. However, you’ll need to
    create a Telegram account using a device such as a smartphone or tablet before
    you can use the service on your computer. If you don’t already have an account,
    visit the website [*https://<wbr>telegram<wbr>.org*](https://telegram.org), download
    and install the app for your device, and set up a user account.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Telegram 应用或者几乎任何连接到互联网的设备上的网页浏览器进行通信。然而，在你可以在电脑上使用该服务之前，你需要先通过智能手机或平板设备创建一个
    Telegram 账户。如果你还没有账户，请访问网站 [*https://<wbr>telegram<wbr>.org*](https://telegram.org)，下载并安装适合你设备的应用，并设置一个用户账户。
- en: To communicate with your Arduino-compatible ESP32 board over Telegram, you’ll
    need to create a Telegram “bot,” your own automated Telegram user that receives
    and sends messages to and from your ESP32\. To do so, open Telegram, log into
    your account on your device, and search for the user *BotFather*, as shown in
    [Figure 20-1](chapter20.xhtml#fig20-1) (Android).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Telegram 与你的 Arduino 兼容的 ESP32 板进行通信，你需要创建一个 Telegram “机器人”，这是你自己的自动化 Telegram
    用户，用于接收和发送消息到 ESP32。为此，打开 Telegram，登录你的设备账户，搜索用户 *BotFather*，如图 [20-1](chapter20.xhtml#fig20-1)
    所示（Android）。
- en: '![A SCREENSHOT OF SEARCHING FOR THE BOTFATHER USER ON TELEGRAM](../images/fig20-1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![在 TELEGRAM 中搜索 BotFather 用户的截图](../images/fig20-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: Searching for
    the Telegram user</samp> <samp class="SANS_Futura_Std_Book_11">BotFather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">on Android</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-1：在 Android 上搜索 Telegram
    用户</samp> <samp class="SANS_Futura_Std_Book_11">BotFather</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的截图</samp>
- en: Select the BotFather account with the blue tick, and you should be presented
    with the start screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选择带有蓝色勾选标记的 BotFather 账户，你应该会看到开始界面。
- en: Tap **START** to proceed. Telegram should then show you a list of options. Click,
    touch, or just send **/newbot** in the messenger to be prompted for a bot account
    name. Once you enter your preferred bot name, you’ll be prompted for a username
    for your bot. Enter your preferred username. You’ll then be presented with your
    *token*, a unique identifier for your bot that’s required for your Arduino sketches,
    as shown in [Figure 20-2](chapter20.xhtml#fig20-2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF BOT ACCOUNT CREATION](../images/fig20-2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: Bot account creation
    in Telegram</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Write the token down for later reference. You might copy and paste it into a
    file if you’re using Telegram on a computer or into a notes app on your mobile
    device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to determine your Telegram chat ID, a unique number you’ll use
    to authenticate your Arduino’s messages to Telegram. Search for the Telegram user
    *IDBot* and select the result with the image of a fingerprint for the avatar,
    as shown in [Figure 20-3](chapter20.xhtml#fig20-3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF SEARCHING FOR IDBOT](../images/fig20-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Searching for
    the</samp> <samp class="SANS_Futura_Std_Book_11">IDBot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Telegram
    account</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Once you have opened its account, send IDBot the message **/start** to initialize
    communication and then **/getid**, as shown in [Figure 20-4](chapter20.xhtml#fig20-4).
    When IDBot replies with your chat ID, write that number down as well, as you’ll
    need it along with the token.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF SEARCHING FOR THE CHAT ID OF THE ACCOUNT](../images/fig20-4.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: Searching for
    the account’s chat ID</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your Telegram account and bot set up, it’s time to configure
    your Arduino IDE.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE</samp>
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven’t already done so, follow the instructions in “Configuring the
    Arduino IDE for the ESP32” and “Testing the ESP32” in [Chapter 19](chapter19.xhtml).
    Once you’ve set up your ESP32, you need to install two libraries. Search for **UniversalTelegramBot**
    in the Library Manager, and then click **Install**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Once UniversalTelegramBot is installed, search for **ArduinoJson** in the Library
    Manager, and then click **Install** at the bottom of the library description (unless
    the library was already installed along with UniversalTelegramBot).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to create your first project remote-controlled by Telegram.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #58: Remote-Controlling Four
    LEDs</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates a fast and simple method of controlling four LEDs
    via four digital output pins on your Arduino-compatible board via Telegram. With
    your existing knowledge of electronics and Arduino, you should be able to easily
    extrapolate from this basic framework how to control other devices that can be
    triggered with a digital output pin.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目演示了一种通过Telegram控制四个LED的快速简便方法，使用的是你的Arduino兼容板上的四个数字输出引脚。凭借你现有的电子学和Arduino知识，你应该能够轻松地从这个基本框架中推导出如何控制其他可以通过数字输出引脚触发的设备。
- en: 'You’ll need the following hardware:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: An ESP32 dev board and matching USB cable
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块ESP32开发板和匹配的USB电缆
- en: A solderless breadboard
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊面包板
- en: Assorted jumper wires
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Four LEDs
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个LED
- en: One 560 Ω, 0.25 W, 1 percent resistor
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个560 Ω，0.25 W，1%精度的电阻器
- en: Assemble the circuit as shown in [Figure 20-5](chapter20.xhtml#fig20-5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图20-5](chapter20.xhtml#fig20-5)所示组装电路。
- en: '![THE SCHEMATIC FOR PROJECT #58](../images/fig20-5.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![项目#58的原理图](../images/fig20-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: The schematic
    for Project #58</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-5：项目#58的原理图</samp>
- en: 'Next, enter and upload the Project #58 sketch, adding your Wi-Fi network credentials
    in the first few lines as appropriate, as originally explained in Project #55
    in [Chapter 19](chapter19.xhtml). Once the sketch has uploaded, the ESP32 should
    attempt to connect to your Wi-Fi network and communicate with the Telegram bot
    you created earlier. After a few moments, open Telegram on your device or web
    browser and search for your bot.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入并上传项目#58的草图，适当添加你的Wi-Fi网络凭证到前几行，正如在项目#55的[第19章](chapter19.xhtml)中所解释的那样。上传草图后，ESP32应该会尝试连接到你的Wi-Fi网络并与之前创建的Telegram机器人进行通信。几秒钟后，打开你设备上的Telegram或网页浏览器，搜索你的机器人。
- en: Select your bot. You should be presented with the bot’s chat history page. You
    can control your ESP32 board from this chat history. When a user sends the **/start**
    command, any Telegram bot should send it back to the ESP32, which is programmed
    to reply to that command with a basic set of instructions. Always include such
    instructions in your own projects so the user isn’t left at a loss on how to control
    the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你的机器人。你应该会看到机器人的聊天历史页面。你可以通过这个聊天历史来控制你的ESP32板。当用户发送**/start**命令时，任何Telegram机器人都应该将其发送回ESP32，ESP32会通过一组基本的指令来回应该命令。始终在你的项目中包含这样的指令，以确保用户不会不知道如何控制系统。
- en: After Telegram displays the start message, you can send the commands included
    in the instruction set and watch the LEDs respond to your commands. [Figure 20-6](chapter20.xhtml#fig20-6)
    shows an example of starting the bot and controlling the LEDs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Telegram显示启动消息后，你可以发送指令集中包含的命令，并观察LED如何响应你的命令。[图20-6](chapter20.xhtml#fig20-6)展示了启动机器人并控制LED的示例。
- en: '![A SCREENSHOT OF THE ESP32 CONTROL VIA TELEGRAM](../images/fig20-6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![通过Telegram控制ESP32的截图](../images/fig20-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: Sending various
    commands to the ESP32 board via Telegram</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-6：通过Telegram向ESP32板发送各种命令</samp>
- en: You should receive a response to all the commands being sent; again, it’s good
    practice to write code that replies to the user to make sure actions have taken
    place. The sketch also acknowledges responses in the Arduino IDE’s Serial Monitor,
    as shown in [Figure 20-7](chapter20.xhtml#fig20-7).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到所有发送命令的响应；同样，良好的编程习惯是写出回应用户的代码，以确保操作已经发生。草图也会在Arduino IDE的串口监视器中确认回应，如[图20-7](chapter20.xhtml#fig20-7)所示。
- en: '![A SCREENSHOT OF THE EXAMPLE SERIAL MONITOR OUTPUT FOR PROJECT #58](../images/fig20-7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![项目#58示例串口监视器输出的截图](../images/fig20-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: Example Serial
    Monitor output for Project #58</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-7：项目#58的示例串口监视器输出</samp>
- en: 'Let’s see how this works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sketch first includes the required libraries, followed by fields to enter
    your Wi-Fi network’s ID and password and then fields to enter your Telegram token
    and chat ID. It defines the pin numbers for the LEDs so you can easily refer to
    them in the rest of the sketch ❶ and then starts instances of the secure Wi-Fi
    connection client and the Telegram bot interface. Next, the sketch sets the length
    of the period it will wait before checking if new Telegram messages are available
    to 1,000 milliseconds ❷.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先包含所需的库文件，接着是输入 Wi-Fi 网络 ID 和密码的字段，然后是输入 Telegram token 和聊天 ID 的字段。它定义了 LED
    的引脚编号，以便在草图的其余部分中方便引用 ❶，然后启动安全 Wi-Fi 连接客户端和 Telegram 机器人接口的实例。接下来，草图设置等待检查是否有新的
    Telegram 消息的周期长度为 1,000 毫秒 ❷。
- en: The sketch uses the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    to retrieve the messages received by the Telegram bot and then takes actions based
    on the contents of the message. The entire process is repeated for the amount
    passed through the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">numNewMessages</samp>.
    The sketch first performs a security check by comparing your Telegram alphanumeric
    chat ID against the chat ID being sent with the message from Telegram ❸. This
    prevents hackers from attempting to control your Telegram bot. If the two don’t
    match, the sketch jumps out of the loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    function and ignores the message(s) received. If they do match, the sketch proceeds
    to send the message received to the Serial Monitor for debugging purposes and
    then retrieves the Telegram username attached to your Telegram account ❹. This
    is used to add a friendly level of personalization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图使用自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    来检索 Telegram 机器人接收到的消息，然后根据消息的内容采取相应的操作。整个过程会根据传入的参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">numNewMessages</samp>
    重复执行。草图首先通过比较你的 Telegram 字母数字聊天 ID 与 Telegram 发送的消息中的聊天 ID 来进行安全检查 ❸。这可以防止黑客试图控制你的
    Telegram 机器人。如果两者不匹配，草图会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    函数跳出循环并忽略接收到的消息。如果匹配，草图将继续将接收到的消息发送到串口监视器进行调试，然后检索附加到你的 Telegram 帐户的 Telegram
    用户名 ❹。这用于增加一些个性化的友好设置。
- en: To decide how to act on the message received, the sketch compares the received
    message against various <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    functions, the first of which is <samp class="SANS_TheSansMonoCd_W5Regular_11">/start</samp>
    ❺. When activated, this part of the sketch combines lines of text, including the
    Telegram username, into one string variable, which is then sent to be displayed
    in the Telegram chat using <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    ❻. The sketch is set up to accept various other chat messages from a user, all
    beginning with a forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>).
    For example, the message to turn on LED number 1 (<samp class="SANS_TheSansMonoCd_W5Regular_11">/1on</samp>)
    is detected at ❼. When a message is received from the user, a <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    function sends an acknowledgment back to the Telegram chat and then turns on the
    LED. The sketch receives and acts upon the rest of the possible messages in a
    similar manner.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定如何处理接收到的消息，草图将接收到的消息与多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    函数进行比较，第一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">/start</samp> ❺。当激活时，草图的这一部分会将多行文本，包括
    Telegram 用户名，合并成一个字符串变量，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    ❻ 发送该字符串以在 Telegram 聊天中显示。草图已设置为接受来自用户的各种其他聊天消息，所有消息都以斜杠（<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>）开头。例如，打开
    LED 1 的消息（<samp class="SANS_TheSansMonoCd_W5Regular_11">/1on</samp>）在 ❼ 处被检测到。当收到用户的消息时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp> 函数会向 Telegram
    聊天发送一条确认消息，然后打开 LED。草图以类似的方式接收并执行其他可能的消息。
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    configures the digital pins for the LEDs and sets them to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOW</samp>
    by default, initializes the Wi-Fi library, and sets up a secure connection to
    Telegram. Finally, it connects the ESP32 board to your Wi-Fi and sends the IP
    address to the Serial Monitor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中，草图配置了
    LED 的数字引脚，并将其默认设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">LOW</samp>，初始化了
    Wi-Fi 库，并建立了与 Telegram 的安全连接。最后，它将 ESP32 板连接到 Wi-Fi 并将 IP 地址发送到串口监视器。
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the sketch
    checks Telegram for any new chat messages every second, using the comparison in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> function. Every time
    a message is received, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp>
    is updated to the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>.
    If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp> plus
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bot_delay</samp> (the amount of
    time to wait between checking for messages), it’s time to check for messages again.
    The number of new messages is then retrieved from Telegram and processed in turn
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    function described earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This sketch provides a simple framework for acting upon messages received from
    Telegram, along with a simple remote control for digital outputs. The next project
    builds on this framework, teaching you to retrieve data from the remote ESP32
    board using Telegram.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #59: Retrieving Remote Data</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This project enables you to retrieve, on demand, the data generated by the BMP180
    sensor board first used in [Chapter 10](chapter10.xhtml), including temperature,
    air pressure, or height above sea level. You can also use this project as a general
    framework for remotely monitoring parameters over Telegram.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 dev board and matching USB cable
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 sensor board
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 20-8](chapter20.xhtml#fig20-8). The
    BMP180 can work on 3.3 V as well as 5 V, so a level converter board isn’t necessary
    in this case.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #59](../images/fig20-8.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The schematic
    for Project #59</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Once you have built the circuit and uploaded the sketch, open Telegram and enter
    the chat history for your Telegram bot, as with the previous project. Enter **/start**
    in Telegram. You should receive a message listing the commands you can use to
    retrieve sensor data, as shown in [Figure 20-9](chapter20.xhtml#fig20-9). For
    variety, I’ve used the Telegram Windows application, rather than the Android app,
    to take screenshots for this project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #59](../images/fig20-9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: Example output
    from Project #59</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This sketch’s framework for using Telegram is the same as in Project #58\.
    The only differences are the changes required for new hardware used—in this case
    the BMP180 sensor—and the communication messages for use with Telegram. The sketch
    includes the required library and initialization for the BMP180 sensor ❶ ❻. It
    modifies the prior Telegram start message to suit this project’s purposes ❷ and
    programs the responses to temperature ❸, air pressure ❹, and altitude message
    requests ❺. You can easily modify the sketch for this project to substitute your
    own required actions to control ESP32 Arduino-compatible boards remotely via Telegram.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Keep the hardware for this project connected. You’ll use it in the next project,
    in which you’ll learn to automate data transmission over Telegram.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #60: Automating Data Transmission</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This project automatically sends data generated by the BMP180 sensor board on
    a recurring basis to your Telegram account. Rather than using messaging to request
    data, you can simply open your Telegram chat to view the latest project updates,
    watching changes in data in (nearly) real time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The required hardware is the same as that for Project #59\. Once you’ve set
    it up, enter and upload the Project #60 sketch, adding your Wi-Fi network credentials
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> fields as
    usual. After a few moments, open the Telegram bot chat window. You should see
    the temperature from the BMP180 displayed around every five seconds, as shown
    in [Figure 20-10](chapter20.xhtml#fig20-10).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #60](../images/fig20-10.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: Example output
    from Project #60</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As this project is a one-way form of messaging, the required code is much shorter
    than that of the previous projects. The setup for the BMP180, Wi-Fi and Telegram
    is still required, but the custom functions to deal with receiving and acting
    upon messages from the Telegram chat aren’t required. The sketch simply sends
    one message on a regular basis, using <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. It declares the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messageOut</samp>
    to hold the text to send out, then composes the message with explanation text
    showing that the data is temperature ❶ and the temperature value from the BMP180
    ❷. It then sends the message to the Telegram chat. After a delay of five seconds,
    the process repeats.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to harness the Telegram messaging application for
    remote project control or data retrieval, without any extra costs for a cloud
    service or special smartphone app. You could harness these projects to control
    your own devices with a digital output pin, or you could retrieve data from any
    sensor that can be connected to your Arduino or compatible boards.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何利用 Telegram 消息应用程序进行远程项目控制或数据检索，无需额外的云服务费用或特殊的智能手机应用程序。你可以利用这些项目通过数字输出引脚控制自己的设备，或者从任何可以连接到
    Arduino 或兼容板的传感器中检索数据。
- en: The next chapter introduces you to retrieving the current time from internet
    time servers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何从互联网时间服务器获取当前时间。
