- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REMOTE
    CONTROL VIA TELEGRAM</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Controlling your Arduino from a distance greater than your local area network
    often requires paid IoT services, such as Blynk or Microsoft Azure, or some complex
    coding and time. For a simpler and less expensive way to remotely control your
    Arduino and retrieve data, you can use the Telegram instant-messaging service
    and an ESP32-based Arduino-compatible board.
  prefs: []
  type: TYPE_NORMAL
- en: Telegram is a free, globally accessible cross-platform encrypted messaging service
    that allows users to chat with each other one on one or in groups on a relatively
    secret basis. Thanks to Telegram’s automation feature, you can get an Arduino
    to control a Telegram user account to send and receive data over the service.
    This allows you to build remote-controlled devices and remotely request data from
    an internet-connected Arduino using Telegram.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll introduce you to the Telegram app and web interface.
    You’ll interface Arduino sketches with the Telegram library. You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple remote to control digital output pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a project that remotely retrieves data generated by the BMP180 sensor
    board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure an automated data transmitter that you can monitor from the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring Your Telegram Account</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can communicate over Telegram using either an app on your device or a web
    browser on almost any device connected to the internet. However, you’ll need to
    create a Telegram account using a device such as a smartphone or tablet before
    you can use the service on your computer. If you don’t already have an account,
    visit the website [*https://<wbr>telegram<wbr>.org*](https://telegram.org), download
    and install the app for your device, and set up a user account.
  prefs: []
  type: TYPE_NORMAL
- en: To communicate with your Arduino-compatible ESP32 board over Telegram, you’ll
    need to create a Telegram “bot,” your own automated Telegram user that receives
    and sends messages to and from your ESP32\. To do so, open Telegram, log into
    your account on your device, and search for the user *BotFather*, as shown in
    [Figure 20-1](chapter20.xhtml#fig20-1) (Android).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF SEARCHING FOR THE BOTFATHER USER ON TELEGRAM](../images/fig20-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: Searching for
    the Telegram user</samp> <samp class="SANS_Futura_Std_Book_11">BotFather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">on Android</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Select the BotFather account with the blue tick, and you should be presented
    with the start screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tap **START** to proceed. Telegram should then show you a list of options. Click,
    touch, or just send **/newbot** in the messenger to be prompted for a bot account
    name. Once you enter your preferred bot name, you’ll be prompted for a username
    for your bot. Enter your preferred username. You’ll then be presented with your
    *token*, a unique identifier for your bot that’s required for your Arduino sketches,
    as shown in [Figure 20-2](chapter20.xhtml#fig20-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF BOT ACCOUNT CREATION](../images/fig20-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: Bot account creation
    in Telegram</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Write the token down for later reference. You might copy and paste it into a
    file if you’re using Telegram on a computer or into a notes app on your mobile
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to determine your Telegram chat ID, a unique number you’ll use
    to authenticate your Arduino’s messages to Telegram. Search for the Telegram user
    *IDBot* and select the result with the image of a fingerprint for the avatar,
    as shown in [Figure 20-3](chapter20.xhtml#fig20-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF SEARCHING FOR IDBOT](../images/fig20-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Searching for
    the</samp> <samp class="SANS_Futura_Std_Book_11">IDBot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Telegram
    account</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have opened its account, send IDBot the message **/start** to initialize
    communication and then **/getid**, as shown in [Figure 20-4](chapter20.xhtml#fig20-4).
    When IDBot replies with your chat ID, write that number down as well, as you’ll
    need it along with the token.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF SEARCHING FOR THE CHAT ID OF THE ACCOUNT](../images/fig20-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: Searching for
    the account’s chat ID</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your Telegram account and bot set up, it’s time to configure
    your Arduino IDE.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven’t already done so, follow the instructions in “Configuring the
    Arduino IDE for the ESP32” and “Testing the ESP32” in [Chapter 19](chapter19.xhtml).
    Once you’ve set up your ESP32, you need to install two libraries. Search for **UniversalTelegramBot**
    in the Library Manager, and then click **Install**.
  prefs: []
  type: TYPE_NORMAL
- en: Once UniversalTelegramBot is installed, search for **ArduinoJson** in the Library
    Manager, and then click **Install** at the bottom of the library description (unless
    the library was already installed along with UniversalTelegramBot).
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to create your first project remote-controlled by Telegram.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #58: Remote-Controlling Four
    LEDs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates a fast and simple method of controlling four LEDs
    via four digital output pins on your Arduino-compatible board via Telegram. With
    your existing knowledge of electronics and Arduino, you should be able to easily
    extrapolate from this basic framework how to control other devices that can be
    triggered with a digital output pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 dev board and matching USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 560 Ω, 0.25 W, 1 percent resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 20-5](chapter20.xhtml#fig20-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #58](../images/fig20-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: The schematic
    for Project #58</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter and upload the Project #58 sketch, adding your Wi-Fi network credentials
    in the first few lines as appropriate, as originally explained in Project #55
    in [Chapter 19](chapter19.xhtml). Once the sketch has uploaded, the ESP32 should
    attempt to connect to your Wi-Fi network and communicate with the Telegram bot
    you created earlier. After a few moments, open Telegram on your device or web
    browser and search for your bot.'
  prefs: []
  type: TYPE_NORMAL
- en: Select your bot. You should be presented with the bot’s chat history page. You
    can control your ESP32 board from this chat history. When a user sends the **/start**
    command, any Telegram bot should send it back to the ESP32, which is programmed
    to reply to that command with a basic set of instructions. Always include such
    instructions in your own projects so the user isn’t left at a loss on how to control
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: After Telegram displays the start message, you can send the commands included
    in the instruction set and watch the LEDs respond to your commands. [Figure 20-6](chapter20.xhtml#fig20-6)
    shows an example of starting the bot and controlling the LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE ESP32 CONTROL VIA TELEGRAM](../images/fig20-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: Sending various
    commands to the ESP32 board via Telegram</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should receive a response to all the commands being sent; again, it’s good
    practice to write code that replies to the user to make sure actions have taken
    place. The sketch also acknowledges responses in the Arduino IDE’s Serial Monitor,
    as shown in [Figure 20-7](chapter20.xhtml#fig20-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE SERIAL MONITOR OUTPUT FOR PROJECT #58](../images/fig20-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: Example Serial
    Monitor output for Project #58</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes the required libraries, followed by fields to enter
    your Wi-Fi network’s ID and password and then fields to enter your Telegram token
    and chat ID. It defines the pin numbers for the LEDs so you can easily refer to
    them in the rest of the sketch ❶ and then starts instances of the secure Wi-Fi
    connection client and the Telegram bot interface. Next, the sketch sets the length
    of the period it will wait before checking if new Telegram messages are available
    to 1,000 milliseconds ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch uses the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    to retrieve the messages received by the Telegram bot and then takes actions based
    on the contents of the message. The entire process is repeated for the amount
    passed through the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">numNewMessages</samp>.
    The sketch first performs a security check by comparing your Telegram alphanumeric
    chat ID against the chat ID being sent with the message from Telegram ❸. This
    prevents hackers from attempting to control your Telegram bot. If the two don’t
    match, the sketch jumps out of the loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    function and ignores the message(s) received. If they do match, the sketch proceeds
    to send the message received to the Serial Monitor for debugging purposes and
    then retrieves the Telegram username attached to your Telegram account ❹. This
    is used to add a friendly level of personalization.
  prefs: []
  type: TYPE_NORMAL
- en: To decide how to act on the message received, the sketch compares the received
    message against various <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    functions, the first of which is <samp class="SANS_TheSansMonoCd_W5Regular_11">/start</samp>
    ❺. When activated, this part of the sketch combines lines of text, including the
    Telegram username, into one string variable, which is then sent to be displayed
    in the Telegram chat using <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    ❻. The sketch is set up to accept various other chat messages from a user, all
    beginning with a forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>).
    For example, the message to turn on LED number 1 (<samp class="SANS_TheSansMonoCd_W5Regular_11">/1on</samp>)
    is detected at ❼. When a message is received from the user, a <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    function sends an acknowledgment back to the Telegram chat and then turns on the
    LED. The sketch receives and acts upon the rest of the possible messages in a
    similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    configures the digital pins for the LEDs and sets them to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOW</samp>
    by default, initializes the Wi-Fi library, and sets up a secure connection to
    Telegram. Finally, it connects the ESP32 board to your Wi-Fi and sends the IP
    address to the Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the sketch
    checks Telegram for any new chat messages every second, using the comparison in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> function. Every time
    a message is received, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp>
    is updated to the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>.
    If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp> plus
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bot_delay</samp> (the amount of
    time to wait between checking for messages), it’s time to check for messages again.
    The number of new messages is then retrieved from Telegram and processed in turn
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    function described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch provides a simple framework for acting upon messages received from
    Telegram, along with a simple remote control for digital outputs. The next project
    builds on this framework, teaching you to retrieve data from the remote ESP32
    board using Telegram.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #59: Retrieving Remote Data</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project enables you to retrieve, on demand, the data generated by the BMP180
    sensor board first used in [Chapter 10](chapter10.xhtml), including temperature,
    air pressure, or height above sea level. You can also use this project as a general
    framework for remotely monitoring parameters over Telegram.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 dev board and matching USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 sensor board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 20-8](chapter20.xhtml#fig20-8). The
    BMP180 can work on 3.3 V as well as 5 V, so a level converter board isn’t necessary
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #59](../images/fig20-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The schematic
    for Project #59</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have built the circuit and uploaded the sketch, open Telegram and enter
    the chat history for your Telegram bot, as with the previous project. Enter **/start**
    in Telegram. You should receive a message listing the commands you can use to
    retrieve sensor data, as shown in [Figure 20-9](chapter20.xhtml#fig20-9). For
    variety, I’ve used the Telegram Windows application, rather than the Android app,
    to take screenshots for this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #59](../images/fig20-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: Example output
    from Project #59</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This sketch’s framework for using Telegram is the same as in Project #58\.
    The only differences are the changes required for new hardware used—in this case
    the BMP180 sensor—and the communication messages for use with Telegram. The sketch
    includes the required library and initialization for the BMP180 sensor ❶ ❻. It
    modifies the prior Telegram start message to suit this project’s purposes ❷ and
    programs the responses to temperature ❸, air pressure ❹, and altitude message
    requests ❺. You can easily modify the sketch for this project to substitute your
    own required actions to control ESP32 Arduino-compatible boards remotely via Telegram.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the hardware for this project connected. You’ll use it in the next project,
    in which you’ll learn to automate data transmission over Telegram.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #60: Automating Data Transmission</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project automatically sends data generated by the BMP180 sensor board on
    a recurring basis to your Telegram account. Rather than using messaging to request
    data, you can simply open your Telegram chat to view the latest project updates,
    watching changes in data in (nearly) real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required hardware is the same as that for Project #59\. Once you’ve set
    it up, enter and upload the Project #60 sketch, adding your Wi-Fi network credentials
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> fields as
    usual. After a few moments, open the Telegram bot chat window. You should see
    the temperature from the BMP180 displayed around every five seconds, as shown
    in [Figure 20-10](chapter20.xhtml#fig20-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #60](../images/fig20-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: Example output
    from Project #60</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As this project is a one-way form of messaging, the required code is much shorter
    than that of the previous projects. The setup for the BMP180, Wi-Fi and Telegram
    is still required, but the custom functions to deal with receiving and acting
    upon messages from the Telegram chat aren’t required. The sketch simply sends
    one message on a regular basis, using <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. It declares the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messageOut</samp>
    to hold the text to send out, then composes the message with explanation text
    showing that the data is temperature ❶ and the temperature value from the BMP180
    ❷. It then sends the message to the Telegram chat. After a delay of five seconds,
    the process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to harness the Telegram messaging application for
    remote project control or data retrieval, without any extra costs for a cloud
    service or special smartphone app. You could harness these projects to control
    your own devices with a digital output pin, or you could retrieve data from any
    sensor that can be connected to your Arduino or compatible boards.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces you to retrieving the current time from internet
    time servers.
  prefs: []
  type: TYPE_NORMAL
