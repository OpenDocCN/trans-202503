<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="introduction" role="doc-introduction" aria-labelledby="int">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxi" aria-label="xxi"/>&#13;
<hgroup>&#13;
&#13;
<h1 class="FMH" id="int"><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp></h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This book is an introduction to graphs and their algorithms for programmers who want to understand and apply them. Graphs are a type of data structure used throughout mathematics, computer science, and numerous other fields to model and solve a wide range of real-world problems. The structure of a graph allows us to represent connections or associations between items. Understanding this structure is critical to harnessing the power of graphs and using them efficiently.</p>&#13;
<p class="TX"><i>Graph Algorithms the Fun Way</i> grew out of the chapter on graphs in my previous book, <i>Data Structures the Fun Way</i> (No Starch Press, 2022), where I wrote, “We could devote an entire book to this single vastly impactful data structure.” Yet this book still only scratches the surface of the exciting and powerful world of graph algorithms, an area of study with a long history <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxii" aria-label="xxii"/>and ongoing research. A comprehensive coverage of all graph techniques and their relative advantages would require numerous volumes and be out of date the moment it was printed. Instead, this book is meant to serve as a foundation for people approaching this exciting field for the first time.</p>&#13;
<p class="TX">The book starts by introducing the components of graphs, then dives into exploring a variety of graph algorithms and how they apply to real-world problems. It is more than a cookbook of common algorithms. Its goal is to help readers understand the ideas behind the algorithms and build the intuitions to adapt the concepts covered here to techniques beyond this book.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h-1"/><samp class="SANS_Futura_Std_Bold_B_11">Who Is This Book For?</samp></h2>&#13;
<p class="TNI1">This book is for programmers who want to learn more about graphs, graph algorithms, and the computational thinking behind such techniques. I assume no prior knowledge of graphs or graph algorithms. However, readers should have the kind of basic familiarity with Python that can be expected after an introductory course, book, or boot camp. They should be familiar with fundamental Python programming concepts, including basic data structures such as lists and dictionaries.</p>&#13;
<p class="TX">I hope this book will be useful to a wide range of audiences, not just programmers learning graph algorithms for the first time. The examples and metaphors used throughout the book are designed to provide an alternative way to view the topics from their standard mathematical definitions. Advanced students and experienced computer scientists may find a new perspective to understand particularly difficult or tricky topics.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h-2"/><samp class="SANS_Futura_Std_Bold_B_11">Analogies and Examples</samp></h2>&#13;
<p class="TNI1">This book supplements formal descriptions and code with a range of real-world and absurd examples and analogies. The structure of graphs makes them perfect for illustrating algorithms with stories of adventurers searching labyrinths or planning vacations through unknown cities. The goal of these examples and analogies is twofold. First, they motivate the algorithms themselves and why we care about the problems they solve. Second, they provide an alternate approach to visualizing these problems that will help readers break free of technicalities and minutiae.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h2 class="H1" id="sec3"><span id="h-3"/><samp class="SANS_Futura_Std_Bold_B_11">Language and Coding Conventions</samp></h2>&#13;
<p class="TNI1">I chose to present example code in Python due to the language’s wide use and readability. However, aficionados of other languages need not fear, as the concepts behind the code are language-agnostic. Graph algorithms have been implemented in a wide range of languages, and all code examples in this book can be adapted beyond Python.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxiii" aria-label="xxiii"/>The code throughout the book uses common Python conventions. To make the code clearer, I use type hints, as in the following code block:</p>&#13;
<pre><code>def is_edge(self, from_node: int, to_node: int) -&gt; bool:&#13;
    return self.get_edge(from_node, to_node) is not None&#13;
</code></pre>&#13;
<p class="TX">The input arguments list the expected types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and the function definition describes the expected return type (<samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>).</p>&#13;
<p class="TX">The code in this book uses multiple core Python libraries. Since functions throughout a file often use the same library, individual code snippets do not explicitly include the <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statements. Users implementing the code will need to make sure to import the relevant libraries. Where ambiguous, I identify the needed libraries in the code’s text description.</p>&#13;
<p class="TX">Standard Python libraries used in this book include:</p>&#13;
<p class="ListPlainf"><samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp></p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp></p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W5Regular_11">itertools</samp></p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp></p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp></p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp></p>&#13;
<p class="ListPlainl"><samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> (for <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>)</p>&#13;
<p class="BodyContinued">The <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library in particular is needed for a number of code snippets, in order to support type hints for functions with multiple return values.</p>&#13;
<p class="TX">In addition, <span class="Xref">Appendix B</span> defines a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> class used in multiple examples, and <span class="Xref">Appendix C</span> defines a minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure.</p>&#13;
<p class="TX">The code in this book is structured to stand alone as much as possible and requires only these core Python libraries. This means I sometimes don’t take advantage of good existing libraries. For example, in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> I represent a matrix as a list of lists instead of leveraging the <samp class="SANS_TheSansMonoCd_W5Regular_11">numpy</samp> library optimized for matrix operations. I call out instances where existing libraries would be a good fit, but I leave their integration into the code as an exercise for the reader.</p>&#13;
<p class="TX">I’ve also made many of the implementations in the book more verbose than strictly necessary in order to focus on the computational ideas behind them. This means that individual implementations may be broken into extra stages to illustrate the computational concepts, structured in a way that matches the explanation, or otherwise may not be fully optimized. In addition, to keep the examples simple, I often leave out the basic validity checks that are vital for production programs. Treat the examples as illustrations of general concepts rather than code to use verbatim in your own projects.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h2 class="H1" id="sec4"><span id="h-4"/><samp class="SANS_Futura_Std_Bold_B_11">Terminology and Definitions</samp></h2>&#13;
<p class="TNI1">Since graph algorithms have been studied in a variety of fields, multiple terms sometimes exist for the same underlying concept. For example, links <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxiv" aria-label="xxiv"/>in a graph are also commonly referred to as <i>edges</i> or <i>arcs</i>. I define each concept when it is introduced and note some of the alternative names that readers might find in other references.</p>&#13;
<p class="TX">In other cases, the same term is used differently within different fields. In particular, the definitions of several key terms have deviated over the years between formal graph theory in mathematics and computer science study. For example, in mathematics, a <i>path</i> through a graph cannot include repeated nodes, while in computer science it often can. Where definitions differ, I default to the common computer science usages and note the difference in the text.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h2 class="H1" id="sec5"><span id="h-5"/><samp class="SANS_Futura_Std_Bold_B_11">How to Use This Book</samp></h2>&#13;
<p class="TNI1">This book is structured progressively, with later chapters building on earlier ones. <a href="part1.xhtml">Part I</a> sets up the conceptual foundations on which later chapters rely:</p>&#13;
<p class="RunInPara"><b><a href="chapter1.xhtml">Chapter 1</a>: Representing Graphs </b>Introduces the structure of graphs, discusses the graph representations of adjacency lists and adjacency matrices, and provides the implementations used throughout the rest of the book.</p>&#13;
<p class="RunInPara"><b><a href="chapter2.xhtml">Chapter 2</a>: Neighbors and Neighborhoods </b>Covers the core concept of neighboring nodes, basic algorithms to build sets of neighbors, and some basic metrics for understanding the local connectivity around a node.</p>&#13;
<p class="RunInPara"><b><a href="chapter3.xhtml">Chapter 3</a>: Paths Through Graphs </b>Discusses paths through graphs and introduces multiple representations including lists of nodes, lists of edges, and lists of back pointers.</p>&#13;
<p class="TX">Later sections are less interdependent but still call upon concepts in earlier chapters. Each is organized around a theme. <a href="part2.xhtml">Part II</a> focuses on searches and shortest paths in a graph:</p>&#13;
<p class="RunInPara"><b><a href="chapter4.xhtml">Chapter 4</a>: Depth-First Search </b>Introduces two implementations of depth-first search, a recursive approach and an iterative stack-based approach, and also discusses how search information can be encoded in a depth-first search tree.</p>&#13;
<p class="RunInPara"><b><a href="chapter5.xhtml">Chapter 5</a>: Breadth-First Search </b>Explores breadth-first search, discusses its properties, and shows how we can use it to find the shortest paths through unweighted graphs.</p>&#13;
<p class="RunInPara"><b><a href="chapter6.xhtml">Chapter 6</a>: Solving Puzzles </b>Shows how we can use graphs to encode puzzles and use the search algorithms from <span class="runinpara_Xref"><a href="chapter4.xhtml">Chapters 4</a></span> and <span class="runinpara_Xref"><a href="chapter5.xhtml">5</a></span> to solve these puzzles.</p>&#13;
<p class="RunInPara"><b><a href="chapter7.xhtml">Chapter 7</a>: Shortest Paths </b>Introduces three algorithms for finding shortest paths through weighted graphs: Dijkstra’s algorithm, the Bellman-Ford algorithm, and the Floyd-Warshall algorithm.</p>&#13;
<p class="RunInPara"><b><a href="chapter8.xhtml">Chapter 8</a>: Heuristic-Guided Searches </b>Describes two heuristic-based searches, heuristic greedy search and A* search, and shows how they <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxv" aria-label="xxv"/>can make use of heuristic information about how promising the nodes are.</p>&#13;
<p class="TX"><a href="part3.xhtml">Part III</a> focuses on connectivity and ordering in graphs:</p>&#13;
<p class="RunInPara"><b><a href="chapter9.xhtml">Chapter 9</a>: Topological Sort </b>Discusses the problem of sorting a graph’s nodes in topological order and introduces two algorithms for this task: Kahn’s algorithm and an extension of depth-first search.</p>&#13;
<p class="RunInPara"><b><a href="chapter10.xhtml">Chapter 10</a>: Minimum Spanning Trees </b>Describes two algorithms for finding minimum spanning trees on graphs, Prim’s algorithm and Kruskal’s algorithm, and also shows how the ideas behind Kruskal’s algorithm can be extended to problems such as generating solvable mazes or clustering spatial data.</p>&#13;
<p class="RunInPara"><b><a href="chapter11.xhtml">Chapter 11</a>: Bridges and Articulation Points </b>Examines algorithms based on depth-first search for finding bridges and articulation points in graphs.</p>&#13;
<p class="RunInPara"><b><a href="chapter12.xhtml">Chapter 12</a>: Strongly Connected Components </b>Explores Kosaraju-Sharir’s algorithm to identify strongly connected components in directed graphs.</p>&#13;
<p class="RunInPara"><b><a href="chapter13.xhtml">Chapter 13</a>: Random Walks </b>Introduces into random walks on graphs and discusses the concept of Markov chains, then shows how to implement random walk behavior on graphs and estimate the underlying graphs from observed data.</p>&#13;
<p class="TX"><a href="part4.xhtml">Part IV</a> introduces the concept of flow within graphs and uses it to solve a particular matching problem:</p>&#13;
<p class="RunInPara"><b><a href="chapter14.xhtml">Chapter 14</a>: Max-Flow Algorithms </b>Defines the concepts of flow through a graph and the max-flow problem, introduces an extended version of the graph data structure to support this problem, and describes the Ford-Fulkerson and Edmond-Karp algorithms for solving the maximum-flow problem.</p>&#13;
<p class="RunInPara"><b><a href="chapter15.xhtml">Chapter 15</a>: Bipartite Graph Matching </b>Introduces the task of matching in graphs and the concept of bipartite graphs before focusing on the specialization of matching within bipartite graphs. We show how to use maximum-flow algorithms to solve one variety of the matching problem on bipartite graphs.</p>&#13;
<p class="TX"><a href="part5.xhtml">Part V</a> covers various node assignment and path planning problems through graphs:</p>&#13;
<p class="RunInPara"><b><a href="chapter16.xhtml">Chapter 16</a>: Graph Coloring </b>Introduces the problem of assigning colors to graph nodes such that no two neighbors share a color and considers a range of algorithms to solve this problem.</p>&#13;
<p class="RunInPara"><b><a href="chapter17.xhtml">Chapter 17</a>: Cliques, Independent Sets, and Vertex Covers </b>Introduces algorithms for three computationally challenging assignment problems: finding a maximum clique, finding a maximum independent set, and finding a minimum vertex cover.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvi" aria-label="xxvi"/><b><a href="chapter18.xhtml">Chapter 18</a>: Tours Through Graphs </b>Considers three path-planning problems: finding paths that visit each node exactly once, finding paths that visit each node exactly once while minimizing the edge weights traversed, and finding paths that cross each edge exactly once. We describe why the first two problems are difficult, but there exists an efficient solution for the third.</p>&#13;
<p class="TX">The appendices provide additional functions and data structures that are helpful for implementing the algorithms in this book:</p>&#13;
<p class="RunInPara"><b><a href="appendix_A.xhtml">Appendix A</a> </b>Describes functions for programmatically creating graphs, including loading them from files.</p>&#13;
<p class="RunInPara"><b><a href="appendix_B.xhtml">Appendix B</a> </b>Defines the modifiable priority queue data structure used in algorithms throughout the book.</p>&#13;
<p class="RunInPara"><b><a href="appendix_C.xhtml">Appendix C</a> </b>Introduces a minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure necessary to implement some of the algorithms in <a href="chapter10.xhtml">Chapter 10</a></p>&#13;
<p class="TX">Throughout the book, the reader should focus on the questions <i>How?</i> and <i>Why? How</i> does this real-world problem map onto a graph formulation? <i>Why</i> does a certain approach help us compute the solution? <i>How</i> does an algorithm use the graph’s structure to solve the problem? <i>Why</i> do we care about this problem? <i>How</i> do these algorithms apply to different problems? <i>Why</i> is the author using that ridiculous analogy? Understanding the answers to these questions will provide the foundation you need to effectively use existing algorithms and develop your own techniques in the future.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>