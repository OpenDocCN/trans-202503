<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch21"><span epub:type="pagebreak" id="page_467"/><strong><span class="big">21</span><br/>EXCEPTIONS AND INTERRUPTS</strong></h2>&#13;
<div class="image1"><img src="../images/pg495_Image_321.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="noindentz">Thus far, we’ve viewed each application as having exclusive use of the computer. But like most operating systems, Raspberry Pi OS allows multiple applications to run concurrently. It manages the hardware in an interleaved fashion, providing each application, and the operating system itself, with the use of the hardware components it needs at any given time.</p>&#13;
<p class="indent">There are two issues here. First, for the operating system to carry out its management tasks, it needs to maintain control over the interaction between applications and hardware. It does this by using a system of privilege levels in the CPU that allows the operating system to control a gateway between itself and the applications.</p>&#13;
<p class="indent">Second, we saw in <a href="ch20.xhtml">Chapter 20</a> that most I/O devices can interrupt the ongoing activity of the CPU when they are ready to provide input or to accept output. The CPU has a mechanism to direct I/O interruptions through this gateway and invoke functions that are under the control of the operating system, thus allowing the operating system to maintain its control over the I/O devices.</p>&#13;
<p class="indent">In this chapter, I’ll start by discussing how the CPU uses privilege levels to enforce its control over the hardware. Then I’ll cover what sorts of <span epub:type="pagebreak" id="page_468"/>events can cause a change in the privilege level and how the CPU reacts to such events. I’ll end the chapter with a discussion of an instruction that allows applications to traverse the gateway between application and system software to directly call utility functions in the operating system.</p>&#13;
<p class="indent">A full treatment of this material would require a detailed understanding of the internal structure of the operating system and how to program the specific hardware you’re using, which is beyond the scope of this book. The goal here is to provide you with a very general overview.</p>&#13;
<h3 class="h3" id="ch21lev1sec1"><strong>Application vs. System Software</strong></h3>&#13;
<p class="noindent">Software can generally be classified as application software or system software. We use <em>application software</em> for most of what we do on a computer, while <em>system software</em> manages usage of hardware resources, providing controlled access to the hardware by application software.</p>&#13;
<p class="indent">The split between system and application software is maintained by a system of <em>privilege levels</em>. The operating system executes at a <em>privileged</em> level, allowing it to manage most of the hardware resources. Application programs execute at an <em>unprivileged</em> level to prevent them from directly accessing much of the hardware. The operating system, being privileged, acts as a supervisor over the use of the computer resources by applications.</p>&#13;
<p class="indent">This separation of privileges allows the operating system to manage the resources needed to execute several application programs concurrently. For example, we could be running a media application to play music while using an editor application to edit a source file. While waiting for us to press another key, the operating system lets the media application use the CPU. When we press the key, the operating system pauses the media application long enough to read the keystroke and then passes control back to the media application while waiting for the very slow (in CPU time) human to press the next key.</p>&#13;
<p class="indent">An <em>exception</em> is an event that causes the currently executing code stream to be suspended and CPU control to be passed to software running at a privileged level. An <em>interrupt</em> is a type of exception event that comes from a device connected to the CPU. Before discussing what can cause an exception and what takes place when one occurs, let’s look at the privilege levels.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although the general concepts are the same, the terminology varies, so you need to be mindful when reading the respective manuals. For example, ARM uses</em> exception <em>as the more general term, with an</em> interrupt <em>being a type of exception. Intel, on the other hand, uses</em> interrupt <em>as the more general term, with an</em> exception <em>being a type of interrupt.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch21lev1sec2"><strong>Privilege and Exception Levels</strong></h3>&#13;
<p class="noindent">The operating system uses <em>exception levels</em> in the CPU to enforce privilege levels for the currently executing software. At any given time, the CPU is <span epub:type="pagebreak" id="page_469"/>running at one of four possible exception levels. <a href="ch21.xhtml#ch21tab1">Table 21-1</a> shows the levels, from least privileged to most.</p>&#13;
<p class="tabcap" id="ch21tab1"><strong>Table 21-1:</strong> The AArch64 Exception Levels</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Level</strong></th>&#13;
<th class="tab_th"><strong>Usage</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">EL0</td>&#13;
<td class="bg1">Application programs</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">EL1</td>&#13;
<td class="bg">Operating system</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">EL2</td>&#13;
<td class="bg1">Hypervisor</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">EL3</td>&#13;
<td class="bg">Firmware/secure monitor</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Application programs execute with the CPU set at the lowest exception level, EL0. The operating system executes at exception level EL1.</p>&#13;
<p class="indent">A <em>hypervisor</em> allows us to run multiple operating systems concurrently on the same computer by coordinating their interactions with the hardware resources. A hypervisor executes at exception level EL2, giving it supervisorial control over the operating systems.</p>&#13;
<p class="indent"><em>Firmware</em> provides low-level control of device hardware. It’s stored in read-only memory and is executed at the highest exception level, EL3. When the Raspberry Pi is first booted up, the CPU starts at EL3 so that it has access to all the hardware.</p>&#13;
<p class="indent">The AArch64 architecture defines a <em>secure state</em> and a <em>non-secure state</em>. All the hardware can be accessed in the secure state, while access is limited in the non-secure state. Switching between the two states is controlled by a <em>secure monitor</em>, which is software that can be executed only when the exception level is at EL3.</p>&#13;
<p class="indent">In <a href="ch20.xhtml">Chapter 20</a>, you learned that the memory management unit (MMU) uses a page table to map virtual memory addresses to physical memory addresses. The entry in the page table for each virtual memory range includes a 2-bit <em>access permissions (AP)</em> field for that memory range. <a href="ch21.xhtml#ch21tab2">Table 21-2</a> shows what these permissions are at each CPU exception level.</p>&#13;
<p class="tabcap" id="ch21tab2"><strong>Table 21-2:</strong> The AArch64 Memory Access Permission Levels</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>AP</strong></th>&#13;
<th class="tab_th"><strong>EL0 (unprivileged)</strong></th>&#13;
<th class="tab_th"><strong>EL1/2/3 (privileged)</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">00</span></td>&#13;
<td class="bg1">No access</td>&#13;
<td class="bg1">Read/write</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">01</span></td>&#13;
<td class="bg">Read/write</td>&#13;
<td class="bg">Read/write</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">10</span></td>&#13;
<td class="bg1">No access</td>&#13;
<td class="bg1">Read only</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">11</span></td>&#13;
<td class="bg">Read only</td>&#13;
<td class="bg">Read only</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Application programs execute with their instructions and read-only data loaded into virtual memory that has its access permission set to <span class="literal">11</span>. If they have any global variables, those are loaded into virtual memory with access permission set to <span class="literal">01</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_470"/>The operating system’s instructions and read-only data are loaded into virtual memory that has its access permission set to <span class="literal">10</span>, and its global variables exist in virtual memory with access permission set to <span class="literal">00</span>.</p>&#13;
<p class="indent">You saw an example of dealing with these memory access permissions when programming the GPIO device in <a href="ch20.xhtml#ch20list2">Listing 20-2</a> in <a href="ch20.xhtml">Chapter 20</a>. The operating system maps a range of its privileged virtual memory address space to the hardware addresses of the GPIO device registers. We used the <span class="literal">mmap</span> system call function to map unprivileged memory in our application program to the operating system’s GPIO addressing space so that our application program could access it.</p>&#13;
<p class="indent">In addition to exception level, the Armv8-A processor has two execution states, AArch32 and AArch64, as discussed in the introduction to <a href="ch09.xhtml">Chapter 9</a>. The operating system sets the execution state when it first starts up.</p>&#13;
<p class="indent">Exceptions provide a way to change the execution state. When an exception takes the CPU to a higher exception level, we can tell the processor to stay at the same execution state or transition to AArch64. When returning from an exception to a lower exception level, we can tell the processor to stay at the same execution state or transition to AArch32. This allows us to run 32-bit applications under our 64-bit Raspberry Pi OS but prevents us from running 64-bit applications under a 32-bit version of Raspberry Pi OS.</p>&#13;
<p class="indent">In the next sections, you’ll see how exceptions allow the use of privileged software.</p>&#13;
<h3 class="h3" id="ch21lev1sec3"><strong>Exception Events</strong></h3>&#13;
<p class="noindent">There are several kinds of events that can cause an exception. One of the most common causes is when an application program (unprivileged) needs a service provided by the operating system (privileged).</p>&#13;
<p class="indent">An example is when we call the <span class="literal">write</span> system call function to display text on the screen. As illustrated in <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> in <a href="ch02.xhtml">Chapter 2</a>, the <span class="literal">write</span> function communicates directly with the operating system, which in turn sends the characters to the screen. It does this with an <span class="literal">svc</span> instruction, which causes an exception to occur. You’ll see how to use <span class="literal">svc</span> later in this chapter.</p>&#13;
<p class="indent">An exception caused by the <span class="literal">svc</span> instruction is a <em>synchronous exception</em>, which is when the timing is synchronized with that of the CPU. Other causes of synchronous exceptions include an attempt to execute an instruction that is not valid at the current exception level, an attempt to access a memory address that is out of the range of the current exception level, and a debugger inserting a breakpoint in a program.</p>&#13;
<p class="indent">An <em>asynchronous exception</em> is not related to the timing of the CPU. Asynchronous exceptions, also called <em>interrupts</em>, typically come from an I/O device.</p>&#13;
<p class="indent">An example of an asynchronous exception is when we use the <span class="literal">read</span> system call function to get characters from the keyboard. As you saw in <a href="ch02.xhtml#ch2fig1">Figure 2-1</a>, the <span class="literal">read</span> function also communicates directly with the operating system. However, when the <span class="literal">read</span> function requests characters from the keyboard, the operating system has no idea when the next key will be pressed.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_471"/>The operating system notifies the keyboard device controller that it’s waiting for a character and places the currently running program in a waiting state. If there’s another program ready to run, the operating system gives CPU control to that program. When a user finally presses a key on the keyboard, the keyboard device controller sends an interrupt signal to the CPU, which causes an exception. When the CPU finishes executing the current instruction, it processes the interrupting exception, which typically places the waiting program in a ready state.</p>&#13;
<p class="indent">Exception processing is done by a piece of code called an <em>exception handler</em>. The CPU responds to an exception by executing the handler code. Let’s look at how the CPU does this.</p>&#13;
<h3 class="h3" id="ch21lev1sec4"><strong>CPU Response to an Exception</strong></h3>&#13;
<p class="noindent">The processor includes a set of <em>system registers</em> that hold the configuration settings for the processor. These include registers that hold data needed for responding to and handling exceptions. Some of the system registers used for exceptions are shown in <a href="ch21.xhtml#ch21tab3">Table 21-3</a>.</p>&#13;
<p class="tabcap" id="ch21tab3"><strong>Table 21-3:</strong> Some of the System Registers for Handling Exceptions</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:55%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Name</strong></th>&#13;
<th class="tab_th"><strong>Register</strong></th>&#13;
<th class="tab_th"><strong>Usage</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">currentel</span></td>&#13;
<td class="bg1">Current exception level</td>&#13;
<td class="bg1">Bits 3 and 2 hold the exception level (<span class="literal">00</span> for EL0, <span class="literal">01</span> for EL1, <span class="literal">10</span> for EL2, <span class="literal">11</span> for EL3)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">elr</span></td>&#13;
<td class="bg">Exception link</td>&#13;
<td class="bg">Address of instruction that caused the exception</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">esr</span></td>&#13;
<td class="bg1">Exception syndrome</td>&#13;
<td class="bg1">Information about the reasons for the exception</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">far</span></td>&#13;
<td class="bg">Fault address</td>&#13;
<td class="bg">Address of access that caused the fault</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">hcr</span></td>&#13;
<td class="bg1">Hypervisor configuration</td>&#13;
<td class="bg1">Virtualization settings related to EL2</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">scr</span></td>&#13;
<td class="bg">Secure configuration</td>&#13;
<td class="bg">Secure state settings related to EL3</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">sctlr</span></td>&#13;
<td class="bg1">System control</td>&#13;
<td class="bg1">Information about the system</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">spsr</span></td>&#13;
<td class="bg">Saved program status</td>&#13;
<td class="bg">PSTATE when exception was taken to this exception level</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">vbar</span></td>&#13;
<td class="bg1">Vector base address</td>&#13;
<td class="bg1">Exception base address for exception taken to this exception level</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These registers are accessible only from software running at a privileged level. There is only one <span class="literal">currentel</span> register. The <span class="literal">hcr</span> register exists at EL2 and the <span class="literal">scr</span> register at EL3. The other system registers in this table have instances at levels EL1, EL2, and EL3.</p>&#13;
<p class="indent">The current exception level of the CPU is determined by bits 3 and 2 in <span class="literal">currentel</span>. The other 62 bits are reserved for possible future use. The content can be loaded into a general-purpose register with the <span class="literal">mrs x</span><span class="codeitalic">d</span>, <span class="literal">currentel</span> instruction executed at a privileged level:</p>&#13;
<p class="noindenttL"><span class="codestrong">mrs</span><strong>—Move system register</strong></p>&#13;
<p class="hang"><span class="literal">mrs x</span><span class="codeitalic">d</span><span class="literal">,</span> <span class="codeitalic">systemreg</span> copies the content of a system register, <span class="codeitalic">systemreg</span>, into <span class="literal">x</span><span class="codeitalic">d</span>. Valid only at exception levels EL1 and higher.</p>&#13;
<p class="indenttL"><span epub:type="pagebreak" id="page_472"/>There is also an <span class="literal">msr</span> instruction for storing content in some system registers, but not the <span class="literal">currentel</span> register. The content of the 2-bit exception level field in the <span class="literal">currentel</span> register can be changed only by an exception.</p>&#13;
<p class="indent">The exception level can be increased only by an exception event, which can either increase the level or keep it the same, except for an exception event at EL0, which can only increase the level. The only way to decrease the exception level is with the <span class="literal">eret</span> instruction, which will either decrease the level or keep it the same:</p>&#13;
<p class="noindenttL"><span class="codestrong">eret</span><strong>—Exception return</strong></p>&#13;
<p class="hang"><span class="literal">eret</span> restores PSTATE from the <span class="literal">spsr</span> register for the current exception level and loads the address in the <span class="literal">elr</span> register for the current exception level into <span class="literal">pc</span>.</p>&#13;
<p class="indenttL">PSTATE is an abstraction for the bit settings of the system registers that define the current processor state. For example, bits 3 and 2 of the <span class="literal">currentel</span> register are included in PSTATE. The condition flags in the <span class="literal">nzcv</span> register listed in <a href="ch09.xhtml#ch9tab2">Table 9-2</a> in <a href="ch09.xhtml">Chapter 9</a> are also included in PSTATE.</p>&#13;
<p class="indent">In response to an exception, the CPU performs an operation that is similar to the <span class="literal">bl</span> instruction, but there are some significant differences. The most obvious difference is that we specify the address in our program code that the <span class="literal">bl</span> instruction branches to, but an exception causes a branch to a block of code in an <em>exception vector table</em>.</p>&#13;
<p class="indent">An exception vector table has 16 entries, arranged in groups of 4, as shown in <a href="ch21.xhtml#ch21tab4">Table 21-4</a>.</p>&#13;
<p class="tabcap" id="ch21tab4"><strong>Table 21-4:</strong> The Entries in an Exception Vector Table</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Offset</strong></th>&#13;
<th class="tab_th"><strong>Type</strong></th>&#13;
<th class="tab_th"><strong>Conditions</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x000</span></td>&#13;
<td class="bg1">Synchronous</td>&#13;
<td class="bg1">From current EL while using EL0’s SP</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0x080</span></td>&#13;
<td class="bg">IRQ</td>&#13;
<td class="bg"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x100</span></td>&#13;
<td class="bg1">FIQ</td>&#13;
<td class="bg1"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bgL"><span class="literal">0x180</span></td>&#13;
<td class="bgL">SError</td>&#13;
<td class="bgL"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x200</span></td>&#13;
<td class="bg1">Synchronous</td>&#13;
<td class="bg1">From current EL while using current level’s SP</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0x280</span></td>&#13;
<td class="bg">IRQ</td>&#13;
<td class="bg"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x300</span></td>&#13;
<td class="bg1">FIQ</td>&#13;
<td class="bg1"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bgL"><span class="literal">0x380</span></td>&#13;
<td class="bgL">SError</td>&#13;
<td class="bgL"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x400</span></td>&#13;
<td class="bg1">Synchronous</td>&#13;
<td class="bg1">From lower EL, next lower EL using AArch64</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0x480</span></td>&#13;
<td class="bg">IRQ</td>&#13;
<td class="bg"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x500</span></td>&#13;
<td class="bg1">FIQ</td>&#13;
<td class="bg1"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bgL"><span class="literal">0x580</span></td>&#13;
<td class="bgL">SError</td>&#13;
<td class="bgL"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x600</span></td>&#13;
<td class="bg1">Synchronous</td>&#13;
<td class="bg1">From lower EL, next lower EL using AArch32</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0x680</span></td>&#13;
<td class="bg">IRQ</td>&#13;
<td class="bg"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0x700</span></td>&#13;
<td class="bg1">FIQ</td>&#13;
<td class="bg1"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0x780</span></td>&#13;
<td class="bg">SError</td>&#13;
<td class="bg"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_473"/>Exception levels EL1, EL2, and EL3 each have their own copies of the 2KiB exception vector table shown here. Each of the 16 entries contains the code that handles the type and conditions of the exception corresponding to that entry. The length of each entry, 128 bytes, allows for up to 32 instructions for the exception handler. If more than 32 instructions are needed to handle an exception, a function outside the table can be called from the table entry program code.</p>&#13;
<p class="indent">Each exception vector table is created when the operating system first starts up. The address of each table is stored in the vector base address register, <span class="literal">vbar</span>, for its respective exception level. An exception causes a branch to the first instruction at the beginning of one of these entries, depending on the type of exception and the conditions when the exception occurred.</p>&#13;
<p class="indent">A synchronous exception comes from the CPU, as covered in the previous section. Of the three types of asynchronous exceptions, an <em>IRQ</em> is an interrupt request that usually comes from an I/O device controller. In previous versions of the ARM architecture, an <em>FIQ</em> was a fast interrupt request that also came from an I/O device controller but that had a higher priority than an IRQ. Starting with the Armv8-A architecture, an FIQ has the same priority as an IRQ; it simply provides another path for interrupts. How the two paths are used is dependent on the implementation of the architecture.</p>&#13;
<p class="indent">An <em>SError</em> is a system error meant to signal an unexpected event in the memory system. The events that cause an SError exception also vary based on the implementation.</p>&#13;
<p class="indent">The entry selected for each type of exception is dependent on whether the exception comes from the same exception level or from a lower level. If it’s from the current exception level, the selection depends on whether the stack pointer at EL0 or at the current exception level is being used.</p>&#13;
<p class="indent">If the exception comes from a lower exception level, the entry selected depends on whether the exception level immediately below the level you’re going to is executing in AArch32 or AArch64. For example, you might have a 32-bit virtual machine running alongside a 64-bit operating system. Applications in the 32-bit virtual machine run at EL0, and their 32-bit operating system runs at EL1. An exception occurring while in the AArch32 mode that goes to the hypervisor at EL2 would go to one of the entries in the fourth group in <a href="ch21.xhtml#ch21tab4">Table 21-4</a>. All the handlers in this group would be from the 32-bit virtual machine’s operating system. The exception handler in the appropriate entry would execute within the 32-bit operating system.</p>&#13;
<p class="indent">The CPU’s response to an exception is based on the assumption that we want to return to the place where the execution stream was interrupted by the exception and to continue with the CPU in the same state it was in before the exception occurred.</p>&#13;
<p class="indent">When responding to an exception, the CPU does the following:</p>&#13;
<ol>&#13;
<li class="noindent">Saves the contents of PSTATE in the <span class="literal">spsr</span> register of the exception level it’s going to</li>&#13;
<li class="noindent">Stores the address of the last completed instruction in the <span class="literal">elr</span> register</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_474"/>For synchronous and system error exceptions, writes the cause to the <span class="literal">esr</span> register of the exception level it’s going to</li>&#13;
<li class="noindent">For address-related synchronous exceptions, writes the cause to the <span class="literal">far</span> register of the exception level it’s going to</li>&#13;
<li class="noindent">Updates PSTATE to the new exception level</li>&#13;
<li class="noindent">Loads into <span class="literal">pc</span> the address of the appropriate entry in the exception vector table</li>&#13;
</ol>&#13;
<p class="indent">It’s the responsibility of the exception handler to save and restore any general-purpose registers it uses. There is a separate stack pointer register at each exception level, so separate stacks can be set up at each level. When executing at EL1, EL2, or EL3, either the stack pointer at the current level or the stack pointer at EL0 can be used.</p>&#13;
<p class="indent">After the exception handler has restored any saved general-purpose registers, it uses the <span class="literal">eret</span> instruction to restore PSTATE to where it was and to return to the place where the exception occurred. PSTATE includes the 2-bit exception level in the <span class="literal">currentel</span> register, so this operation also returns the CPU to the exception level it came from.</p>&#13;
<p class="indent">Writing an exception handler is an advanced topic beyond the scope of this book, but in the next section you’ll see how you can use an exception to call on the services of the operating system.</p>&#13;
<h3 class="h3" id="ch21lev1sec5"><strong>Supervisor Calls</strong></h3>&#13;
<p class="noindent">The operating system, being privileged, acts as a supervisor over the resources of the computer. When an unprivileged application program needs to use privileged resources, it calls upon the operating system using a <em>supervisor call</em>.</p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13list3">Listing 13-3</a> in <a href="ch13.xhtml">Chapter 13</a>, we used the <span class="literal">write</span> system call function to write <span class="literal">Hello, World!</span> on the screen one character at a time. The <span class="literal">write</span> function is a C wrapper for a supervisor call. The program in <a href="ch21.xhtml#ch21list1">Listing 21-1</a> is called <em>freestanding</em> because it doesn’t use any C library functions. Instead, we’re using a supervisor call directly when we need the services of the operating system.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hello_world.s</em></p>&#13;
</div>&#13;
<pre class="pre">   // Write Hello, World! using a system call.&#13;
           .arch armv8-a&#13;
   // Useful names&#13;
           .equ    NUL, 0&#13;
           .equ    STDOUT, 1&#13;
        <span class="ent">➊</span> .equ    WRITE, 0x40&#13;
           .equ    EXIT, 0x5d&#13;
   // Stack frame&#13;
           .equ    save19, 16&#13;
           .equ    FRAME, 32&#13;
   // Constant data&#13;
           .section  .rodata<span epub:type="pagebreak" id="page_475"/>&#13;
   message:&#13;
           .string "Hello, World!\n"&#13;
   // Code&#13;
           .text&#13;
           .align  2&#13;
           .global my_hello&#13;
           .type   my_hello, %function&#13;
<span class="ent">➋</span> my_hello:&#13;
           adr     x1, message       // Address of message&#13;
   loop:&#13;
           ldrb    w3, [x1]          // Load character&#13;
           cmp     w3, NUL           // End of string?&#13;
           b.eq    done              // Yes&#13;
           mov     x2, 1             // No, one char&#13;
           mov     x0, STDOUT        // Write on screen&#13;
           mov     x8, WRITE&#13;
        <span class="ent">➌</span> svc     0                 // Tell OS to do it&#13;
           add     x1, x1, 1         // Increment pointer&#13;
           b       loop              //   and continue&#13;
   done:&#13;
           mov     w0, wzr           // Return value&#13;
        <span class="ent">➍</span> mov     x8, EXIT          // Terminate this process&#13;
           svc     0</pre>&#13;
<p class="list" id="ch21list1"><em>Listing 21-1: The</em> <span class="codeitalic">Hello, World!</span> <em>freestanding program</em></p>&#13;
<p class="indent">The <span class="literal">gcc</span> compiler assumes we are using the C hosted environment and requires that the first function be named <span class="literal">main</span>. Since we’re not using the C libraries, we don’t need to use the C hosted environment and can give our function any name we wish <span class="ent">❷</span>. After assembling this function, we go directly to the loader and tell it where to start execution of the function with the <span class="literal">-e</span> option:</p>&#13;
<pre class="pre">$ <span class="codestrong1">ld -e my_hello -o hello_world hello_world.o</span></pre>&#13;
<p class="indent">When we need the operating system to output a character, we use the <span class="literal">svc</span> instruction <span class="ent">❸</span>:</p>&#13;
<p class="noindenttL"><span class="codestrong">svc</span><strong>—Supervisor call</strong></p>&#13;
<p class="hang"><span class="literal">svc</span> <span class="codeitalic">imm</span> causes an exception to be taken from exception level EL0 to EL1. It stores <span class="literal">0x15</span> in bits 31 through 26 and <span class="codeitalic">imm</span>, a 16-bit unsigned integer, in bits 15 through 0 of the <span class="literal">esr</span> register.</p>&#13;
<p class="indenttL">Exception level EL1 is handled in the operating system. The <span class="literal">svc</span> handler uses the integer in the <span class="literal">x8</span> register to determine what action it should take. The number for the write operation is <span class="literal">0x40</span> <span class="ent">❶</span>. The other arguments to the write operation in the operating system are the same as those to the C library <span class="literal">write</span> function. The argument to the <span class="literal">svc</span> instruction, <span class="codeitalic">imm</span>, is not used in Linux.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_476"/>Our <span class="literal">my_hello</span> function was launched directly by the operating system as a new process, not called from the C hosted environment. We terminate this process with another supervisor call <span class="ent">❹</span>.</p>&#13;
<p class="indent">Notice that we do not need to create a stack frame or save any registers in this freestanding program. The exception handler for <span class="literal">svc</span> will restore the state of the general-purpose registers when it returns. Because this program doesn’t return to the C hosted environment, we don’t need to save the <span class="literal">sp</span> and <span class="literal">fp</span> registers.</p>&#13;
<p class="indent">The numbers for the operating system operations, the arguments to the operations, and the registers that these are all passed in are listed at <em><a href="https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/">https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/</a></em>. There are four tables on this site: x86_64 (64-bit), arm (32-bit), arm64 (64-bit), and x86 (32-bit). Make sure you use the arm64 table with this book.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21tab5">Table 21-5</a> lists some common <span class="literal">svc</span> codes.</p>&#13;
<p class="tabcap" id="ch21tab5"><strong>Table 21-5:</strong> Some Register Contents for the <span class="literal">svc</span> Call</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Operation</strong></th>&#13;
<th class="tab_th"><span class="codestrong">x8</span></th>&#13;
<th class="tab_th"><span class="codestrong">x0</span></th>&#13;
<th class="tab_th"><span class="codestrong">x1</span></th>&#13;
<th class="tab_th"><span class="codestrong">x2</span></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">read</span></td>&#13;
<td class="bg1"><span class="literal">0x3f</span></td>&#13;
<td class="bg1">File descriptor</td>&#13;
<td class="bg1">Address of character(s)</td>&#13;
<td class="bg1">Number of characters</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">write</span></td>&#13;
<td class="bg"><span class="literal">0x40</span></td>&#13;
<td class="bg">File descriptor</td>&#13;
<td class="bg">Address of character(s)</td>&#13;
<td class="bg">Number of characters</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">exit</span></td>&#13;
<td class="bg1"><span class="literal">0x5d</span></td>&#13;
<td class="bg1">Error code</td>&#13;
<td class="bg1">—</td>&#13;
<td class="bg1">—</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For completeness, here are the instructions that cause an exception to be taken to the hypervisor, <span class="literal">hvc</span>, and to the secure monitor, <span class="literal">smc</span>:</p>&#13;
<p class="noindenttL"><span class="codestrong">hvc</span><strong>—Hypervisor call</strong></p>&#13;
<p class="hang"><span class="literal">hvc</span> <span class="codeitalic">imm</span> causes an exception to be taken from exception level EL1 to EL2. It stores <span class="literal">0x16</span> in bits 31 through 26 and <span class="codeitalic">imm</span>, a 16-bit unsigned integer, in bits 15 through 0 of the <span class="literal">esr</span> register.</p>&#13;
<p class="noindenttL"><span class="codestrong">smc</span><strong>—Secure monitor call</strong></p>&#13;
<p class="hang"><span class="literal">smc</span> <span class="codeitalic">imm</span> causes an exception to be taken from exception level EL1 or EL2 to EL3. It stores <span class="literal">0x17</span> in bits 31 through 26 and <span class="codeitalic">imm</span>, a 16-bit unsigned integer, in bits 15 through 0 of the <span class="literal">esr</span> register.</p>&#13;
<p class="indenttL">Further details of the exception processing mechanism in the AArch64 architecture are complex and beyond the scope of this book. A good next step is reading <em>Learn the Architecture—AArch64 Exception Model</em>, available at <em><a href="https://developer.arm.com/documentation/102412/0103">https://developer.arm.com/documentation/102412/0103</a></em>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch21exe1">21.1     Pick a program you’ve written in assembly language. Add the instruction <span class="literal">mrs x0, currentel</span> in a place where you know it will be executed. Your program should still assemble and link fine, but what happens when you run the program?</p>&#13;
<p class="box-list1"><span epub:type="pagebreak" id="page_477"/>21.2     Modify the three functions <span class="literal">write_char</span>, <span class="literal">write_str</span>, and <span class="literal">read_str</span> in “Your Turn” <a href="ch14.xhtml#ch14exe4">exercise 14.4</a> on <a href="ch14.xhtml#ch14you1">page 293</a> so that they use the <span class="literal">svc</span> instruction instead of calling the C <span class="literal">write</span> and <span class="literal">read</span> functions.</p>&#13;
<p class="box-list1" id="ch21exe3">21.3     What is the supervisor call number for the <span class="literal">mmap</span> operation we used in <a href="ch20.xhtml#ch20list2">Listing 20-2</a> in <a href="ch20.xhtml">Chapter 20</a>?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch21lev1sec6"><strong>What You’ve Learned</strong></h3>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Privilege levels</strong> The operating system maintains its privilege over the hardware resources by tagging memory addresses and running applications with the CPU set at a lower exception level.</p>&#13;
<p class="noindentin"><strong>Exception levels</strong> The CPU runs software at one of four exception levels: from least to most privileged, EL0, EL1, EL2, or EL3.</p>&#13;
<p class="noindentin"><strong>Exception</strong> An interruption in the currently executing code stream that causes CPU control to be passed to software running at a privileged level (EL1–EL3).</p>&#13;
<p class="noindentin"><strong>Interrupt</strong> Other hardware devices can interrupt the regular execution cycle of the CPU and trigger an exception.</p>&#13;
<p class="noindentin"><span class="codestrong">svc</span> The instruction that causes an exception in AArch64.</p>&#13;
<p class="noindentin"><strong>Exception handler</strong> A function in the operating system that gets called by the CPU when an exception or interrupt occurs.</p>&#13;
<p class="noindentin"><strong>Exception vector table</strong> An array of exception handlers.</p>&#13;
<p class="noindentin"><strong>Freestanding program</strong> A program that does not use the C library functions.</p>&#13;
</div>&#13;
<p class="indent">This has been a brief overview of exceptions and interrupts. The details are complex and require a thorough knowledge of the specific model of CPU you’re working with.</p>&#13;
<p class="indent">This concludes my introduction to computer organization. I hope it has provided you with the tools you need to further pursue any of the topics that interest you.<span epub:type="pagebreak" id="page_478"/></p>&#13;
</div>
</div>
</body></html>