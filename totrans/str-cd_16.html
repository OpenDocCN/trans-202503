<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_319"/><span class="big">12</span><br/>FILSKA</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">It’s time to design our first esolang, Filska. Filska, pronounced “full-ska,” is a word in the dialect of the Shetland Islands. It means “high-spirited fun.” Whether a programming language can embody such a thing is up for reasonable debate, but, as with most esolangs, fun is an ingredient, so the name seems appropriate. (As an aside, if you happen to enjoy Scottish fiddle music, as I do, you might look for music by a band from Shetland with the same name. The convergence of names is pure chance, I assure you.)</p>&#13;
<p class="indent">In this chapter, we’ll outline Filska’s philosophy and design. Then, we’ll create an interpreter for it in Python. We’ll experiment with Filska itself in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>&#13;
<h3 class="h3" id="lev1sec82"><strong>Philosophy and Design</strong></h3>&#13;
<p class="noindent">Filska is an answer to this question: what is it like to program in a language where each subprogram can manipulate only a single memory location?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_320"/>Filska works with floating-point numbers and the language itself is simple to make implementing the interpreter easy. As we’ve seen, this is often the case with esolangs. So superficially, Filska looks a bit like assembly language. We’re interested in the experience of trying to code in a restricted language, one where each subprogram is allowed to manipulate only a single memory location; therefore, we might be excused for making the syntax simple.</p>&#13;
<p class="indent">Of course, if each subprogram manipulates only its own memory location, there is no way to share information between subprograms. A typical solution to such a problem is to use a stack, á la Forth, but we’ll be even more restrictive and emulate simple microprocessors. Therefore, Filska supports three floating-point registers, X, Y, and Z, which any subprogram can manipulate along with its memory location. And, as with many simple microprocessors, the registers are somewhat limited in their abilities. We might think of each Filska subprogram as having its own accumulator along with access to the three index registers.</p>&#13;
<p class="indent">Conceptually, a Filska program looks like <a href="ch12.xhtml#ch012fig1">Figure 12-1</a>.</p>&#13;
<div class="image"><img id="ch012fig1" src="Images/12fig01.jpg" alt="Image" width="532" height="378"/></div>&#13;
<p class="figcap"><em>Figure 12-1: The conceptual structure of a Filska program</em></p>&#13;
<p class="indent">The code in <a href="ch12.xhtml#ch012fig1">Figure 12-1</a> is part of the example program outputting the points of the Sierpiński triangle. There are three subprograms: <code>main</code>, <code>loop</code>, and <code>print</code>. All Filska programs have at least a <code>main</code> subprogram where execution begins. The similarity to assembly language is clear.</p>&#13;
<p class="indent">Each subprogram is responsible for a single memory location. In <a href="ch12.xhtml#ch012fig1">Figure 12-1</a>, the values in the memory location represent a possible state of the program. The <code>set,1</code> instruction in <code>main</code> sets <code>main</code>’s memory location to 1.</p>&#13;
<p class="indent">Also indicated are the three general purpose registers, X, Y, and Z. In the figure, X is set to 1 because of the <code>tmx</code> instruction in <code>main</code>, which transfers the current subprogram’s memory value (1) to X.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_321"/>There’s more to say about what’s happening in <a href="ch12.xhtml#ch012fig1">Figure 12-1</a>, but we need a better understanding of Filska first. Therefore, let’s detail Filska so we can implement it in Python.</p>&#13;
<h4 class="h4" id="lev2sec105"><strong><em>Program Structure and Syntax</em></strong></h4>&#13;
<p class="noindent">A Filska program is a set of one or more subprograms. Execution begins with the <code>main</code> subprogram, which must exist. Filska’s syntax is especially simple: tokens are separated by whitespace. Each token is either part of a subprogram declaration or an instruction associated with a subprogram. Comments are allowed; they begin with a double quote (<code>"</code>) and run to the end of the line.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list1">Listing 12-1</a> shows the complete source code to a simple program counting from 10 down to 1.</p>&#13;
<pre>"  Loop and decrement (ex1)&#13;
{ main&#13;
    set,10    " set mem to 10&#13;
    prt       " print it&#13;
    tmx       " mem -&gt; X&#13;
    set,13    " 13 -&gt; mem&#13;
    chr       " newline&#13;
    txm       " X -&gt; mem, restore count&#13;
    dec       " decrement mem&#13;
    tst,n,-6  " if mem != 0, go back six instructions&#13;
    hlt       " end&#13;
}</pre>&#13;
<p class="caption" id="ch012list1"><em>Listing 12-1: Counting down from 10 to 1</em></p>&#13;
<p class="indent">The first items to notice are the comment lines beginning with double quotes. As you expect, comments are ignored by the interpreter. Next, a single subprogram, the required <code>main</code>, is defined. Syntactically, a subprogram is an opening brace (<code>{</code>), a name, one or more instructions, and a closing brace (<code>}</code>). All tokens are separated by whitespace, implying that a complete instruction, even if it consists of several parts, must not have spaces within it. Again, we do this to make our implementation easier so we can focus on the language itself. Lastly, Filska is not case sensitive, so <code>hlt</code> and <code>HLT</code> are the same instruction. We’ll use <code>hlt</code> in the text, but in code, any combination of case is fine.</p>&#13;
<p class="indent">If you run the program in <a href="ch12.xhtml#ch012list1">Listing 12-1</a> with</p>&#13;
<pre>&gt; <span class="codestrong1">python3 filska.py examples/ex1.filska</span></pre>&#13;
<p class="noindent">you’ll get output counting down from 10 to 1 with one number per line. We’ll walk through this example later in the chapter.</p>&#13;
<p class="indent">If this were all there is to the idea of Filska, I wouldn’t waste time with it. However, there are some interesting constraints that make working with the <span epub:type="pagebreak" id="page_322"/>language a bit of a challenge. It’s also fun: Filska requires alternative thinking to do things that might be second nature to you if you are used to standard programming languages.</p>&#13;
<p class="indent">We already mentioned how each Filska subprogram manipulates its own memory. That’s one constraint. The other constraint has to do with program flow between subprograms. Filska does not have a call stack. There is no idea of a subroutine or function. Instead, a subprogram runs and, if instructed, transfers flow to another subprogram. Filska only runs one subprogram at a time, so we aren’t talking about concurrency here.</p>&#13;
<p class="indent">All subprograms run forever unless instructed otherwise. If the last instruction in a subprogram is executed, flow starts again at the top of the subprogram. Thus, a single Filska subprogram acts as a loop on its own. However, the example above ended with a call to <code>hlt</code> (halt). If you remove the <code>hlt</code> instruction, the countdown will repeat forever. Try it. Use CTRL-C to quit the interpreter when you get tired of watching the numbers flash by.</p>&#13;
<p class="indent">So infinite loops are implicit in Filska. What else is there to know? Each Filska subprogram maintains its own program counter, which is its own pointer to the instruction that should be executed next. In some fashion, all the programming languages we used do this. If we have a function like the following in Python</p>&#13;
<pre>def f(x):&#13;
    y = 2*x**2 + 3*x - 4&#13;
    return y</pre>&#13;
<p class="noindent">we would expect to call <code>f(3)</code> and get a return value of 23. If we call <code>f</code> a second time with a different value, say <code>f(4)</code>, we would expect it to begin again from the first instruction and run through the <code>return</code> to give us 40 as the output. The program counter for <code>f</code> resets to 0 after the first call.</p>&#13;
<p class="indent">In Filska, unless we are explicit about resetting them, program counters persist when transferring to another subprogram. We’ll see how this works in the next section, but for now, it means if subprogram <em>A</em> moves to subprogram <em>B</em> and, after some sequence of instructions, subprogram <em>B</em> moves back to subprogram <em>A</em>, execution of <em>A</em> will begin <em>with the next instruction</em> and not with the first instruction. Therefore, it is incorrect to think of Filska subprograms as subroutines, as they don’t reset themselves, but rather persist in their current state between transfers to and from them.</p>&#13;
<p class="indent">We can express the environment in which Filska operates with the following statements:</p>&#13;
<ul>&#13;
<li class="noindent">Filska programs are collections of independent subprograms.</li>&#13;
<li class="noindent">Filska subprograms manipulate a single floating-point memory location, M.</li>&#13;
<li class="noindent">Filska subprograms have access to three floating-point registers shared between them: X, Y, and Z.</li>&#13;
<li class="noindent">Filska subprograms loop when the last instruction is executed.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_323"/>Transfers between subprograms do not automatically reset the  caller’s program counter.</li>&#13;
</ul>&#13;
<p class="indent">This environment is nonstandard, that is, it’s different from what we are used to in traditional programming languages. We might think of Filska as some sort of weird machine from the early days of computers, but that, of course, would be grossly unfair to those early machines. Perhaps we can agree that Filska is just a bit weird, but in a good way, because working with it forces us to expand our thinking—the usual approach to even basic programs doesn’t always work, as we’ll see in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>&#13;
<h4 class="h4" id="lev2sec106"><strong><em>Flow Control</em></strong></h4>&#13;
<p class="noindent">Filska supports five instructions affecting program flow. We’ll talk about four of them here and defer the fifth until we discuss comparisons. The four instructions are: <code>jpr</code>, <code>jmp</code>, <code>gto</code>, and <code>hlt</code>. We’ll discuss them in reverse order beginning with <code>hlt</code>, which, as we’ve already seen, stops the Filska program and exits.</p>&#13;
<p class="indent">To control flow within a subprogram, use <code>gto</code>, which is a three-letter mnemonic for “goto,” the bane of early computer programming. In Filska, <code>gto</code> accepts an offset in terms of instructions. An offset of 1 would move to the next instruction, an offset of 2 would move to the instruction after that, and so forth. To go backward, make the offset values negative. Primitive, yes, but doing this helps simplify the implementation and adds another small twist to the language. If you find yourself writing large Filska programs, feel free to add labels to the implementation.</p>&#13;
<p class="indent">Use <code>gto</code> to execute an unconditional jump <em>within</em> a subprogram. For example, this little block of code will set the subprogram’s memory location to 0 then loop forever, adding 1.</p>&#13;
<pre>set,0&#13;
inc&#13;
gto,-1</pre>&#13;
<p class="noindent">We use <code>gto,-1</code> to go back to the instruction immediately before the <code>gto</code>. Note the syntax <code>gto,&lt;offset&gt;</code>, where no spaces are allowed, the comma is required, and <code>&lt;offset&gt;</code> is an integer, that is, the number of instructions to skip. Note that Filska does not insist on a single instruction per line, so</p>&#13;
<pre>set,0 inc gto,-1</pre>&#13;
<p class="noindent">works just as well.</p>&#13;
<p class="indent">To move program flow from one subprogram to another, use <code>jmp</code> or <code>jpr</code> followed by the new subprogram’s name. For example, in <a href="ch12.xhtml#ch012fig1">Figure 12-1</a>, the <code>main</code> subprogram transfers to <code>loop</code> with <code>jmp,loop</code>. Note that the name of the target subprogram is fixed. Filska does not support any form of indirection.</p>&#13;
<p class="indent">We said before that Filska does not reset the program counter for a subprogram when transferring to a new subprogram. This is true if <code>jmp</code> is used.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_324"/>However, if you use <code>jpr</code> instead, then the current subprogram’s counter <em>is</em> reset to 0, so the next time the subprogram is started, it will start from the beginning.</p>&#13;
<p class="indent">Let’s set up an example. First, let’s write a small program to output some numbers to the console, one number per line. The code is shown in <a href="ch12.xhtml#ch012list2">Listing 12-2</a>.</p>&#13;
<pre>{ main    &#13;
    set,1 prt    &#13;
    jmp,newline    &#13;
    set,2 prt    &#13;
    jmp,newline    &#13;
    set,3 prt    &#13;
    jmp,newline    &#13;
    hlt    &#13;
}       &#13;
    &#13;
{ newline set,10 chr jmp,main }</pre>&#13;
<p class="caption" id="ch012list2"><em>Listing 12-2: <span class="codeitalic1">jmp</span> example</em></p>&#13;
<p class="indent">There are a few things to note in <a href="ch12.xhtml#ch012list2">Listing 12-2</a>. First, there are two subprograms, <code>main</code> and <code>newline</code>. Second, we stated already that <code>set,1</code> sets <code>main</code>’s memory to one. Also, <code>prt</code> will display the current subprogram’s memory as a floating-point number. So the first line of <code>main</code> will display <code>1</code> at the console.</p>&#13;
<p class="indent">The next line transfers control from <code>main</code> to <code>newline</code>. This subprogram sets its memory to 10 and calls <code>chr</code>. Recall that ASCII 10 is the character code for a newline character on Linux. For Windows, it’s ASCII 13. The Filska interpreter is happy with either character. It’s the same as using <code>"\n"</code> in Python. The <code>chr</code> instruction displays the subprogram’s memory as a character. So the point of <code>newline</code> is to move output to the next line.</p>&#13;
<p class="indent">The last instruction in <code>newline</code> is <code>jmp,main</code> to transfer control back to <code>main</code>. But <em>where</em> in <code>main</code> will execution start? Because <code>main</code> called <code>newline</code> with <code>jmp</code>, <code>main</code>’s program counter was not reset, so the next instruction executed is <code>set,2</code> followed by another transfer of control to <code>newline</code>.</p>&#13;
<p class="indent">Where will <code>newline</code> pick up? Previously, it transferred control back to <code>main</code> with a <code>jmp</code> instruction as well, so it will pick up at the next instruction. However, that was the last instruction in <code>newline</code>, so, according to our design, program flow will loop back to the beginning, making <code>set,13</code> the next instruction executed.</p>&#13;
<p class="indent">Therefore, each <code>jmp</code> to <code>newline</code> will effectively run the entire subprogram again. Good. This is what we want. Similarly, each transfer to <code>newline</code> from <code>main</code> uses <code>jmp</code>, so when <code>newline</code> transfers back to <code>main</code>, the next instruction is executed.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list2">Listing 12-2</a> will output <code>1</code>, then <code>2</code>, followed by <code>3</code>, and then stop because of the <code>hlt</code> instruction. The jumps to <code>newline</code> ensure each number is on its own line in the output.</p>&#13;
<p class="indent">Note that because <code>newline</code> transfers to <code>main</code> via its final instruction, it has the effect and feel of a subroutine or function. But don’t be fooled. If <span epub:type="pagebreak" id="page_325"/>another subprogram were to transfer control to <code>newline</code>, the result wouldn’t be to transfer back to that subprogram when done. Instead, <code>newline</code> would transfer control to <code>main</code>.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list2">Listing 12-2</a> shows us how to use <code>jmp</code> to transfer control between sub-programs and how to pick up where we left off if we return to the transferring subprogram. Now, let’s mess things up a bit. We’ll keep the code of <a href="ch12.xhtml#ch012list2">Listing 12-2</a>, but replace the first instance of <code>jmp,newline</code> with <code>jpr,newline</code>, using <code>jpr</code> in the place of <code>jmp</code>.</p>&#13;
<p class="indent">If you make this change and run the code, you won’t see <code>1</code>, <code>2</code>, <code>3</code> at the console. Instead, you’ll see <code>1</code> repeating forever until you hit CTRL-C. Why? Because <code>jpr</code> transfers control to a new subprogram, just like <code>jmp</code>, but it also resets the caller’s program counter to 0. So when <code>main</code> transfers control to <code>newline</code>, <code>main</code>’s program counter is set to 0, causing it to pick up at <code>set,1</code> again when <code>newline</code> transfers back to <code>main</code>. This sets up an endless loop that outputs <code>1</code> repeatedly.</p>&#13;
<p class="indent">As an exercise, restore the <code>jmp,newline</code> instruction in <code>main</code>, replace <code>jmp,main</code> in <code>newline</code> with <code>jpr,main</code>, and run the code. Is there any difference in the output compared to our earlier output? If not, why?</p>&#13;
<p class="indent">The answer is no, there is no difference; both versions output <code>1</code>, <code>2</code>, and <code>3</code> at the console. This is because the transfer back to <code>main</code> from <code>newline</code> is the <em>last</em> instruction, so resetting <code>newline</code>’s program counter is irrelevant in this case. If the program counter is reset, <code>newline</code> starts from its first instruction. If the program counter isn’t reset, it will loop back around to the beginning and start with the first instruction anyway.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012tab1">Table 12-1</a> summarizes Filska’s flow control instructions.</p>&#13;
<p class="tabcap" id="ch012tab1"><strong>Table 12-1:</strong> Flow Control Instructions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Instruction</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>jmp</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Transfer to a new subprogram and preserve the caller’s program counter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code><em>jpr</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Transfer to a new subprogram and reset the caller’s program counter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>gto</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Jump forward or backward within the current subprogram.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code><em>hlt</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Halt. Stop the program immediately and exit.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s move on now to see how Filska handles its little bit of memory.</p>&#13;
<h4 class="h4" id="lev2sec107"><strong><em>Memory</em></strong></h4>&#13;
<p class="noindent">We already know that each Filska subprogram manages a single floating-point number. We also know subprograms share access to three floating-point index registers. Let’s look at the instructions that manipulate these data values.</p>&#13;
<p class="indent">To set a subprogram’s memory, use <code>set</code>.</p>&#13;
<pre>set,42&#13;
set,-6502&#13;
set,0.007&#13;
set,6.62607015e-34</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_326"/>The only way to directly set a memory value to a constant is via <code>set</code>.</p>&#13;
<p class="indent">Several instructions transfer subprogram memory to or from an index register. The form of the instruction is straightforward: the source of the data comes before the destination. So to transfer a memory value to the X register, use <code>tmx</code>. Similarly, to transfer memory to the Z register, use <code>tmz</code>. To move data from an index register to memory, reverse the letters. Therefore, <code>tym</code> moves the current value of the Y register to memory.</p>&#13;
<p class="indent">The transfer instructions are destructive, meaning that the destination value is overwritten. The <code>swp</code> instruction swaps two data values instead. The instruction takes a two-letter argument representing the two data sources to swap. The current subprogram’s memory is denoted as <code>M</code>. For example,</p>&#13;
<pre>swp,mx&#13;
swp,yz</pre>&#13;
<p class="noindent">will first swap memory and the X register and then swap the Y and Z register values.</p>&#13;
<p class="indent">Filska does not support arrays or any form of heap memory, so that immediately precludes many possible programs. However, there is no practical upper bound on the number of subprograms allowed, so creative programming might mimic some larger memory operations. <a href="ch12.xhtml#ch012list3">Listing 12-3</a> shows how to use a subprogram as a set-once, read-many memory location.</p>&#13;
<pre>{ main&#13;
  <span class="ent">➊</span> set,123&#13;
    tmx jmp,mem&#13;
  <span class="ent">➋</span> set,1 prt&#13;
    set,13 chr&#13;
  <span class="ent">➌</span> jmp,mem txm&#13;
    prt set,13 chr&#13;
    jmp,mem txm&#13;
    prt set,13 chr&#13;
    jmp,mem txm&#13;
    prt set,13 chr&#13;
    hlt&#13;
}&#13;
&#13;
{ mem&#13;
    txm&#13;
    inc&#13;
    jmp,main&#13;
    tmx&#13;
    gto,-2&#13;
}</pre>&#13;
<p class="caption" id="ch012list3"><em>Listing 12-3: Using a subprogram as ROM</em></p>&#13;
<p class="indent">The main program of <a href="ch12.xhtml#ch012list3">Listing 12-3</a> loads the X register with 123 by first setting <code>main</code>’s memory to 123 followed by a transfer to the X register <span class="ent">➊</span>. Then, <span epub:type="pagebreak" id="page_327"/>a <code>jmp</code> to <code>mem</code> moves the 123 from X to <code>mem</code>’s memory. Just to show we can, we increment the memory before returning to <code>main</code> via <code>jmp</code>.</p>&#13;
<p class="indent">This first call to <code>mem</code> sets the local data value to 124 (as we incremented it). Subsequent calls to <code>mem</code> from <code>main</code> will start <code>mem</code> at the <code>tmx</code> instruction to transfer the 124 to the X register. In <code>main</code>, we set its memory to 1 and print it at the console along with a newline character to show that <code>main</code>’s memory is now changed <span class="ent">➋</span>.</p>&#13;
<p class="indent">Next, we make three calls to <code>mem</code>. After each call, the X register will contain <code>mem</code>’s local data value (124). Back in <code>main</code>, we transfer the X value to <code>main</code>’s memory and print it at the console <span class="ent">➌</span>. It is not hard to imagine using a second index register, say Y, as an argument of sorts to tell <code>mem</code> to set its local memory to whatever is in X instead of setting X to the local memory.</p>&#13;
<h4 class="h4" id="lev2sec108"><strong><em>Arithmetic</em></strong></h4>&#13;
<p class="noindent">By <em>arithmetic</em> we mean binary math operations like addition and multiplication. The full list of supported binary operations is in <a href="ch12.xhtml#ch012tab2">Table 12-2</a>. The general format of the instruction is</p>&#13;
<pre><span class="codeitalic1">&lt;op&gt;</span>,<span class="codeitalic1">&lt;dst&gt;</span> = <span class="codeitalic1">&lt;op1&gt;&lt;op2&gt;</span></pre>&#13;
<p class="indent">with <code>&lt;op&gt;</code> being the command, <code>&lt;dst&gt;</code> the destination, and <code>&lt;op1&gt;</code> and <code>&lt;op2&gt;</code> the operands. The infix version is <code>&lt;dst&gt; = &lt;op1&gt;&lt;op&gt;&lt;op2&gt;</code> as in <em>c</em> = <em>a – b</em>.</p>&#13;
<p class="tabcap" id="ch012tab2"><strong>Table 12-2:</strong> Binary Arithmetic Instructions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Instruction</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Example</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>add</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>add</em>, <em>m</em>=<em>xy</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Addition, <em>M</em> ← <em>X</em> + <em>Y</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code><em>sub</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code><em>sub</em>, <em>x</em>=<em>yz</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Subtraction, <em>X</em> ← <em>Y – Z</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>mul</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>mul</em>, <em>z</em>=<em>xy</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Multiplication, <em>Z</em> ← <em>X</em> × <em>Y</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code><em>div</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code><em>div</em>, <em>m</em>=<em>zx</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Division, <em>M</em> ← <em>Z</em> ÷ <em>X</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>mod</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code><em>mod</em>, <em>y</em>=<em>mz</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Modulo, <em>Y</em> ← <em>M</em> mod <em>Z</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code><em>pow</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code><em>pow</em>, <em>z</em>=<em>xy</em></code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Power, <em>Z</em> ← <em>X</em><sup><em>Y</em></sup></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You’ll notice from the examples in <a href="ch12.xhtml#ch012tab2">Table 12-2</a> that the operands and the destination must be subprogram memory or one of the index registers. No constants are allowed. However, any combination of memory and registers is permitted. And as usual, to simplify the implementation, no spaces are allowed in the command.</p>&#13;
<h4 class="h4" id="lev2sec109"><strong><em>Comparisons</em></strong></h4>&#13;
<p class="noindent">Filska handles logical comparisons via a flags register and two instructions. The flags register is a list of Boolean values indicating the result of the most recent comparison instruction (<code>cmp</code>). The flags are zero (<code>Z</code>), equal (<code>E</code>), less than (<code>L</code>), and greater than (<code>G</code>). The <code>cmp</code> instruction accepts a single argument and compares it to the subprogram’s memory, setting the appropriate flags as needed. The argument is a constant or one of the index registers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_328"/>For example, these instructions first set memory and then call <code>cmp</code>.</p>&#13;
<pre>set,3&#13;
cmp,x</pre>&#13;
<p class="noindent">The comparison asks about the relationship between memory and the current value of the X index register. Let’s say X is 4. The comparison code is</p>&#13;
<pre>flags = [False, False, False, False]&#13;
if (mem &lt; n):&#13;
    flags[2] = True  # L&#13;
if (mem &gt; n):&#13;
    flags[3] = True  # G&#13;
if (n == mem):&#13;
    flags[1] = True  # E&#13;
if (mem == 0):&#13;
    flags[0] = True  # Z</pre>&#13;
<p class="noindent">with <code>mem</code> being the current subprogram’s memory and <code>n</code> being the value of the X register.</p>&#13;
<p class="indent">Which flags are set depends on the values, but for this example, 3 &lt; 4, so the <code>L</code> flag will be set and the others will remain unset. If X were 3, the <code>E</code> flag would be set instead. Now, consider these instructions:</p>&#13;
<pre>set,0&#13;
cmp,5</pre>&#13;
<p class="noindent">In this case, <code>cmp</code> will set two flags. First, it will set the <code>L</code> flag because 0 &lt; 5. Second, <code>cmp</code> will also set the zero flag (<code>Z</code>) because memory is 0.</p>&#13;
<p class="indent">The code above actually sets the zero flag twice. Checking whether a value is 0 is so common that all of Filska’s instructions that modify subprogram memory check if the result is 0 and if so, set the zero flag. So the <code>set,0</code> instruction set the zero flag even before the <code>cmp</code> instruction, which sets it a second time. We’ll often use this fact in our example programs to branch on memory becoming 0 without an explicit call to <code>cmp</code>. Note that even the transfer instructions affect the zero flag when moving values from the index registers to subprogram memory.</p>&#13;
<p class="indent">If <code>cmp</code> performs tests and sets flags, how do we act on the results? That’s where the test instruction, <code>tst</code>, comes into play. The <code>tst</code> instruction branches within the current subprogram based on the value of a flag. The syntax of the instruction is <code>tst,&lt;flag&gt;,&lt;offset&gt;</code>. For example, consider this sequence of instructions:</p>&#13;
<pre>set,1&#13;
tst,z,10&#13;
dec&#13;
tst,z,8</pre>&#13;
<p class="noindent">We first set memory to 1 and then execute <code>tst</code> to branch forward 10 instructions if the zero flag is set. Assigning a 1 to memory does not set the zero <span epub:type="pagebreak" id="page_329"/>flag, so the <code>tst</code> instruction does not branch and execution continues with the next instruction. The <code>dec</code> instruction decrements memory, making it 0. This operation <em>does</em> set the zero flag, so the next <code>tst</code> instruction will branch eight instructions forward. Note that branching eight instructions forward from the second <code>tst</code> instruction sets the program counter to the same instruction that the first <code>tst</code> instruction was targeting.</p>&#13;
<p class="indent">To test for conditions other than memory is 0, use <code>cmp</code> followed by the <code>tst</code> instruction. For example:</p>&#13;
<pre>cmp,x&#13;
tst,l,-15&#13;
tst,e,-16</pre>&#13;
<p class="noindent">These instructions compare memory to X and branch backward if memory is less than or equal to X. Note that for the equal test to branch to the same location as the less-than test, we must account for the presence of the less-than <code>tst</code> instruction, which explains using <em>–</em>15 and <em>–</em>16, respectively.</p>&#13;
<p class="indent">The <code>tst</code> instruction’s first argument is the flag to test: <code>Z</code>, <code>L</code>, <code>G</code>, or <code>E</code>. However, <code>tst</code> accepts one more flag, <code>N</code>, which means “not zero.” We saw this version of <code>tst</code> in <a href="ch12.xhtml#ch012list1">Listing 12-1</a> earlier.</p>&#13;
<h4 class="h4" id="lev2sec110"><strong><em>Mathematical Functions</em></strong></h4>&#13;
<p class="noindent">Filska’s intended use is to crunch numbers. That’s why it manipulates floating-point values. To that end, Filska supports a set of mathematical functions, all of which operate on the current subprogram’s memory. <a href="ch12.xhtml#ch012tab3">Table 12-3</a> has the complete set of supported functions.</p>&#13;
<p class="tabcap" id="ch012tab3"><strong>Table 12-3:</strong> Filska’s Mathematical Functions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Instruction</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>inc</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ← <em>M</em> + 1</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Increment memory by one</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>dec</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ← <em>M –</em> 1</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Decrement memory by one</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>sin</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ←<em> sin</em>(<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Sine of <em>M</em> (radians)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>cos</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ←<em> cos</em>(<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Cosine of <em>M</em> (radians)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>tan</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ←<em> tan</em>(<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Tangent of <em>M</em> (radians)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>asn</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ← <em>sin</em> <sup><em>–</em>1</sup> (<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Inverse sine of <em>M</em> (radians)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>acs</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ← <em>cos</em> <sup><em>–</em>1</sup> (<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Inverse cosine of <em>M</em> (radians)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>atn</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ← <em>tan</em> <sup><em>–</em>1</sup> (<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Inverse tangent of <em>M</em> (radians)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>log</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ←<em> log</em>(<em>M</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Natural log</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>exp</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ← <em>e</em><sup><em>M</em></sup></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Exponential</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>flr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ← ⌊<em>M</em> ⌋</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Floor of <em>M</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>cel</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ← ⌈<em>M</em> ⌉</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Ceiling of <em>M</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>rnd</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>M</em> ← <em>U</em>[0, 1)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Uniform random number, [0, 1)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>neg</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>M</em> ← <em>–M</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Negation of <em>M</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>sqr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><img src="Images/f0329-01.jpg" alt="Image" width="86" height="20"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Square root of <em>M</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_330"/>The set of functions in <a href="ch12.xhtml#ch012tab3">Table 12-3</a> are the minimal set supported by most programming languages. With these, it’s possible to implement many mathematical expressions, at least in pieces.</p>&#13;
<p class="indent">Internally, our implementation of Filska will use Python floats, meaning IEEE 754 <em>binary64</em> values (C <code>double</code>). We have a good range available numerically, but if our algorithm naturally uses integers, we might be limited a bit, as we will not take advantage of Python’s abilities with arbitrary-sized integers. We’ll see this effect in <a href="ch13.xhtml#ch13">Chapter 13</a> when we develop a Filska program to output the Fibonacci sequence.</p>&#13;
<h4 class="h4" id="lev2sec111"><strong><em>Input and Output</em></strong></h4>&#13;
<p class="noindent">Filska supports three input/output instructions: <code>prt</code>, <code>chr</code>, and <code>ipt</code>. The first two we’ve seen several times already in the examples above. Use <code>prt</code> to output subprogram memory as a floating-point number. Filska’s implementation does check to see if memory is actually an integer and outputs it with an integer format if so. Otherwise, the format is explicitly for floating-point with 10 digits after the decimal.</p>&#13;
<p class="indent">The <code>chr</code> instruction interprets memory as an ASCII code. This casts memory to an integer and then keeps only the lowest eight bits to ensure it is in the range [0, 255]. Then, it outputs the character associated with the resulting ASCII value.</p>&#13;
<p class="indent">The final instruction, <code>ipt</code>, accepts input from the user as a floating-point number. If the input received cannot be properly interpreted as a floating-point number, <code>ipt</code> unceremoniously returns 0. The <code>ipt</code> instruction sets the zero flag as well.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list4">Listing 12-4</a> is a simple program that asks the user for a number and multiplies it by 2.</p>&#13;
<pre>{ main&#13;
    set,63&#13;
    chr&#13;
    ipt&#13;
    tmx &#13;
    set,2&#13;
    mul,m=mx&#13;
    prt &#13;
    set,13&#13;
    chr &#13;
    hlt &#13;
}</pre>&#13;
<p class="caption" id="ch012list4"><em>Listing 12-4: Getting input from the user</em></p>&#13;
<p class="indent">The program first prints a <code>?</code> and then uses <code>ipt</code> to set memory to whatever number the user enters. Filska does not allow constants in arithmetic operations, so to multiply memory by 2, the user’s value is moved to the X register and memory is set to 2. The <code>mul</code> instruction multiplies memory and <span epub:type="pagebreak" id="page_331"/>X stores the result in memory. Next, the program prints the product (<code>prt</code>) with a newline character and then halts.</p>&#13;
<p class="indent">Input and output to the console are as straightforward as can be; however, when combined with input/output redirection, Filska can operate on a file and produce a new file as output. A simple modification to <a href="ch12.xhtml#ch012list4">Listing 12-4</a> makes it possible to multiply a file of numbers by 2 (see <a href="ch12.xhtml#ch012list5">Listing 12-5</a>).</p>&#13;
<pre>{ main&#13;
    ipt&#13;
    tmx&#13;
    set,2&#13;
    mul,m=mx&#13;
    prt&#13;
    set,13&#13;
    chr&#13;
}</pre>&#13;
<p class="caption" id="ch012list5"><em>Listing 12-5: Multiplying a file by 2</em></p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list5">Listing 12-5</a> removes the question mark prompt and <code>hlt</code> instruction to make <code>main</code> loop forever. By design, Filska exits if the call to <code>ipt</code> fails for some reason, including if reading from a redirected file fails.</p>&#13;
<p class="indent">To try <a href="ch12.xhtml#ch012list5">Listing 12-5</a>, first create a file of numbers, one per line. I used 1 through 10. Ensure the final number does not have an empty line after it, as empty lines are read as 0. With the file of numbers in place, run the program.</p>&#13;
<pre>python3 filska.py example_input_file.filska &lt;input.txt</pre>&#13;
<p class="noindent">Assuming you stored the code in <em>example_input_file.filska</em> and your table of numbers in <em>input.txt</em>, you should see your table output at the console with each number multiplied by 2. Naturally, you can redirect Filska output to a different file.</p>&#13;
<p class="indent">Now that we know what Filska is as a language and the instructions it supports, let’s implement it in Python.</p>&#13;
<h3 class="h3" id="lev1sec83"><strong>Implementating Filska</strong></h3>&#13;
<p class="noindent">In this section, we’ll implement portions of Filska. I won’t be so pedantic as to dump every line of Python code on you here. The code for Filska is in the file <em>Filska.py</em>. Please read through it. All told, <em>Filska.py</em> is less than 700 lines, including comments and blanks.</p>&#13;
<p class="indent">Here, we’ll detail the essential parts of the implementation. For example, a single instance of a particular class of instruction is all you need to understand the implementation of the entire class.</p>&#13;
<p class="indent">Therefore, we’ll present the implementation in a top-down fashion, starting with the code’s overall structure and operation. Then we’ll discuss parsing, which is especially easy given Filska’s design, and the execution loop.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_332"/>Next comes an example of an instruction without arguments, followed by instructions that accept arguments. Lastly, we’ll end with flow control within and between subprograms. Again, I assume that you’ll look at <em>Filska.py</em> yourself. After all, at this point in the book we’ve gained enough experience with source code to learn directly from it most of the time.</p>&#13;
<h4 class="h4" id="lev2sec112"><strong><em>Overall Structure and Operation</em></strong></h4>&#13;
<p class="noindent">Conceptually, a Filska interpreter parses the input source code into tokens, ignoring comments, and sorts those tokens into a dictionary of subprograms indexed by the subprogram name. Each subprogram has an associated local memory value, local flags, and a local program counter, an index into the subprogram’s token list. Tokens, memory, flags, and program counters are stored in Python dictionaries, each indexed by the subprogram name. Execution happens one token at a time for the current subprogram, looping at the end of the subprogram, and persisting the program counter between transfers to and from other subprograms, unless the <code>jpr</code> instruction is used, in which case the subprogram’s counter is set to 0.</p>&#13;
<p class="indent">The Filska interpreter itself is a single Python class, <code>Filska</code>. The constructor expects a string, the text of the code to be run, and, optionally, a Boolean flag to turn on runtime execution tracing. We’ll get to tracing later on when we start working with our example programs. We won’t look at how tracing is implemented here. Review the Filska source code to see how it’s done.</p>&#13;
<p class="indent">Using a class to implement a Filska interpreter enables the easy embedding of Filska into another program. Why you’d want to embed a Filska interpreter is a reasonable question, but you can if you want a quirky scripting language for your larger application. Modifications to Filska’s input/output instructions might make embedding more attractive. Imagine a version of the <code>Run</code> method (see below) that accepts a list of inputs and returns the program output as a list of tokens, and so on.</p>&#13;
<p class="indent">When run from the command line, Filska expects the program’s name and an optional <code>-t</code> flag to turn on execution tracing. On startup, Filska runs <code>main</code>, the traditional name for a Python program’s startup function (see <a href="ch12.xhtml#ch012list6">Listing 12-6</a>).</p>&#13;
<pre>def main():&#13;
    trace = False if (len(sys.argv) &lt; 3) else True&#13;
    app = Filska(open(sys.argv[1]).read(), trace=trace)&#13;
    app.Run()&#13;
&#13;
if (__name__ == "__main__"):&#13;
    main()</pre>&#13;
<p class="caption" id="ch012list6"><em>Listing 12-6: Creating a Filska interpreter from the command line</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_333"/>If no arguments are given, Filska displays a short usage message (not shown in the listing). Otherwise, <code>main</code> looks to see if a second command line argument is present and sets <code>trace</code> appropriately. The following line creates an instance of a Filska interpreter passing in the actual text of the program to run. Next, execution begins with a call to <code>Run</code>.</p>&#13;
<p class="indent">The constructor defines state member variables, including the index registers, a dictionary holding per subprogram memory (<code>mem</code>), a dictionary of subprogram instructions (<code>prog</code>), the per subprogram program counter (<code>PC</code>), and the name of the currently running subprogram (<code>CP</code>) initialized to <code>main</code>. The status flags come next (<code>flags</code>), also defined as a dictionary. Dictionaries are used for memory, program text, program counters, and status flags to isolate subprogram state. The only link between subprograms is the ability for each subprogram to interact with the shared index registers.</p>&#13;
<p class="indent">Filska programs are tokenized; therefore, running a subprogram means interpreting token by token. When instructions are encountered as tokens, the instruction is parsed if there are arguments. Then the instruction is looked up in a table, <code>exe</code>, which holds references to Python methods implementing the function.</p>&#13;
<h4 class="h4" id="lev2sec113"><strong><em>Parsing</em></strong></h4>&#13;
<p class="noindent">Parsing a Filska program means splitting the source code string into tokens, ignoring comments, and separating the subprogram tokens and storing them in the <code>prog</code> dictionary. The <code>Parse</code> method tokenizes a program string to return a list of tokens. Next, <code>InitializeProg</code> sorts the subprograms and places them in the <code>prog</code> dictionary.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list7">Listing 12-7</a> shows how to split a source code string into tokens separated by whitespace.</p>&#13;
<pre>def Parse(self, src):&#13;
    eoln = False&#13;
    t = ""&#13;
    for c in src:&#13;
        if (eoln) and (c == '\n'):&#13;
            eoln = False&#13;
        elif (c == '"') and (not eoln):&#13;
            eoln = True&#13;
        elif (not eoln):&#13;
            t += c&#13;
    return " ".join(t.split()).upper().split()</pre>&#13;
<p class="caption" id="ch012list7"><em>Listing 12-7: Tokenizing the source code</em></p>&#13;
<p class="indent">Filska comments begin with a double quote (<code>"</code>) and run to the end of the line. The <code>Parse</code> method scans the input source code character by character, <span epub:type="pagebreak" id="page_334"/>keeping all characters that are not part of a comment line. This means a double quote is not allowed as part of a token.</p>&#13;
<p class="indent">With comments removed, the <code>return</code> statement uses standard Python functionality to first split on whitespace and then join again with a single space between tokens. The new string is made uppercase, thereby requiring Filska to be case insensitive, so <code>main</code> and <code>MAIN</code> refer to the same subprogram. Lastly, the last call to <code>split</code> tokenizes the program text returning a Python list of tokens.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list8">Listing 12-8</a> scans the list of tokens looking for opening braces (<code>{</code>).</p>&#13;
<pre>def InitializeProg(self, tokens):&#13;
    idx = 0&#13;
    k = 0&#13;
    while (k &lt; len(tokens)):&#13;
        if (tokens[k] == "{"):&#13;
            k = self.ExtractProg(tokens,k)&#13;
        else:&#13;
            k += 1&#13;
&#13;
def ExtractProg(self, tokens, ks):&#13;
    k = ks + 1&#13;
    p = []&#13;
    while (k &lt; len(tokens)) and (tokens[k] != "}"):&#13;
        p.append(tokens[k])&#13;
        k += 1&#13;
    self.prog[p[0]] = p[1:]&#13;
    self.PC[p[0]] = 0&#13;
    self.mem[p[0]] = 0.0&#13;
    self.flags[p[0]] = [False, False, False, False]&#13;
    return k</pre>&#13;
<p class="caption" id="ch012list8"><em>Listing 12-8: Separating subprogram text</em></p>&#13;
<p class="indent">When the parser encounters an opening brace, a new subprogram starts. The <code>ExtractProg</code> method captures the subprogram’s tokens using the first token as the new subprogram name. Subprogram state, meaning memory, program counter, and flags, is also defined at the same time.</p>&#13;
<p class="indent">When <code>InitializeProg</code> exits, all subprograms have been defined and all their states initialized. The Filska program is then ready to execute with a call to <code>Run</code>.</p>&#13;
<h4 class="h4" id="lev2sec114"><strong><em>The Execution Loop</em></strong></h4>&#13;
<p class="noindent">The <code>Run</code> method starts the execution loop (see <a href="ch12.xhtml#ch012list9">Listing 12-9</a>).</p>&#13;
<pre>def Run(self):&#13;
    if (self.trace):&#13;
        self.Trace()<span epub:type="pagebreak" id="page_335"/>&#13;
&#13;
    while (True):&#13;
        self.Execute()&#13;
        if (self.trace):&#13;
            self.Trace()&#13;
        time.sleep(self.naptime)</pre>&#13;
<p class="caption" id="ch012list9"><em>Listing 12-9: The execution loop</em></p>&#13;
<p class="indent">The execution loop is quite short. If not in trace mode, <code>Run</code> is nothing more than an endless loop that executes instruction after instruction until <code>hlt</code> quits inside <code>Execute</code> or the user hits CTRL-C. The value of <code>naptime</code> controls the overall speed of a Filska program. The default sleep time is 0.00001 seconds, which basically means “run as fast as possible.”</p>&#13;
<p class="indent">The <code>Execute</code> method in <a href="ch12.xhtml#ch012list10">Listing 12-10</a> executes a single instruction of the current subprogram.</p>&#13;
<pre>def Execute(self):&#13;
    prog = self.prog[self.CP]&#13;
    pc = self.PC[self.CP]&#13;
    flags = self.flags[self.CP]&#13;
    mem = self.mem[self.CP]&#13;
    inst = prog[pc]&#13;
&#13;
    cp, pc, mem, flags = self.Exec(inst, len(prog), mem, pc, flags)&#13;
&#13;
    self.mem[self.CP] = mem&#13;
    self.PC[self.CP] = pc&#13;
    self.flags[self.CP] = flags&#13;
&#13;
	if (self.CP != cp):                                                       &#13;
		self.CP = cp&#13;
		self.flags[cp] = [False, False, False, False]</pre>&#13;
<p class="caption" id="ch012list10"><em>Listing 12-10: Executing a single instruction</em></p>&#13;
<p class="indent">First, the current program (<code>prog</code>), program counter (<code>pc</code>), flags, and local memory (<code>mem</code>) are loaded for the current subprogram (<code>CP</code>). Next, the instruction executes by calling <code>Exec</code>, which we’ll detail shortly. When <code>Exec</code> returns, it passes back updated values for the current subprogram, program counter, local memory, and local flags. The state of the current subprogram is updated along with the name of the current subprogram if a <code>jmp</code> or <code>jpr</code> instruction was executed. Notice that <code>mem</code>, <code>pc</code>, and <code>flags</code> are updated first before the current subprogram name, as they refer to the subprogram whose instruction was just executed. If transferring to a new subprogram, the new subprogram’s flags are reset.</p>&#13;
<p class="indent">The <code>Exec</code> method in <a href="ch12.xhtml#ch012list11">Listing 12-11</a> is responsible for processing a single instruction.</p>&#13;
<pre><span epub:type="pagebreak" id="page_336"/>def Exec(self, inst, proglen, mem, pc, flags):&#13;
    cp = self.CP&#13;
    if (inst[:3] == "JMP"):&#13;
        pc, cp = self.JMP(inst, pc, proglen)&#13;
    elif (inst[:3] == "JPR"):&#13;
        pc, cp = self.JPR(inst, pc)&#13;
    elif (inst[:3] == "GTO"):&#13;
        pc = self.GTO(inst, pc, proglen)&#13;
    elif (inst[:3] == "TST"):&#13;
        pc = self.TST(inst, pc, proglen, flags)&#13;
    else:&#13;
        if (inst[:3] not in self.exe):&#13;
            raise ValueError("Illegal instruction: %s" % inst)&#13;
    <span class="ent">➊</span> rest = inst[4:]&#13;
    <span class="ent">➋</span> mem, flags = self.exe[inst[:3]](rest, mem, flags)&#13;
    <span class="ent">➌</span> pc = (pc+1) % proglen&#13;
&#13;
    return cp, pc, mem, flags</pre>&#13;
<p class="caption" id="ch012list11"><em>Listing 12-11: Evaluating a single instruction</em></p>&#13;
<p class="indent"><code>Exec</code> receives the token representing the instruction (<code>inst</code>), the number of instructions in the current subprogram (<code>proglen</code>), the current value of subprogram memory (<code>mem</code>), the program counter (<code>pc</code>), and the flags (<code>flags</code>). <code>Exec</code> returns the name of the subprogram to execute next (<code>cp</code>), which is usually unchanged, and the updated state for the subprogram whose instruction was just executed.</p>&#13;
<p class="indent">Each Filska instruction is processed by a method with the same name as the instruction. If the instruction affects flow control, like <code>jmp</code>, <code>jpr</code>, <code>gto</code>, or <code>tst</code>, it is processed with a varying set of arguments and return values. We’ll return to these instructions shortly. All other instructions follow the same format: they accept any remaining instruction text (<code>rest</code> <span class="ent">➊</span>), memory, and flags as input, and return updated memory and flags <span class="ent">➋</span>. Because most Filska instructions do not affect program flow, the program counter is updated by adding 1 and rolling over to 0 if the subprogram’s length is exceeded <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="lev2sec115"><strong><em>Instructions Without Arguments</em></strong></h4>&#13;
<p class="noindent">Non-flow control instructions come in two varieties: with arguments and without arguments. Let’s see how Filska instructions without arguments are implemented.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list12">Listing 12-12</a> implements the <code>cos</code> instruction.</p>&#13;
<pre>def COS(self, rest, mem, flags):&#13;
    mem = cos(mem)&#13;
    flags[0] = False<span epub:type="pagebreak" id="page_337"/>&#13;
    if (mem == 0.0):&#13;
        flags[0] = True&#13;
    return mem, flags</pre>&#13;
<p class="caption" id="ch012list12"><em>Listing 12-12: A representative no-argument instruction</em></p>&#13;
<p class="indent">The arguments are any remaining portion of the instruction token after the three-character instruction has been removed, the current subprogram’s memory value, and the associated flags. For no-argument instructions, <code>rest</code> is an empty string. No-argument instructions operate on the subprogram’s memory or one of the index registers. Here, the cosine of memory is used to update it. As with almost all Filska instructions, a 0 result sets the zero flag. All instruction implementations return any new value of the memory and any updated flags.</p>&#13;
<h4 class="h4" id="lev2sec116"><strong><em>Instructions with Arguments</em></strong></h4>&#13;
<p class="noindent">Filska instructions with arguments include <code>set</code>, <code>swp</code>, and all binary math operators. Of the latter, we’ll only detail <code>add</code>, as the others operate similarly.</p>&#13;
<p class="indent">Let’s begin with <code>SET</code> (see <a href="ch12.xhtml#ch012list13">Listing 12-13</a>). The <code>swp</code> instruction is similar.</p>&#13;
<pre>def SET(self, rest, mem, flags):&#13;
    try:&#13;
        n = float(rest)&#13;
    except:&#13;
        n = 0.0&#13;
    mem = n&#13;
    flags[0] = False&#13;
    if (mem == 0):&#13;
        flags[0] = True&#13;
    return mem, flags</pre>&#13;
<p class="caption" id="ch012list13"><em>Listing 12-13: Implementation of <span class="codeitalic1">SET</span></em></p>&#13;
<p class="indent">The single argument passed to <code>SET</code>, meaning the text of the token beyond the string <code>SET</code>, is in <code>rest</code>. Filska attempts to interpret <code>rest</code> as a floating-point number and uses 0 if the conversion fails. Naturally, a more sophisticated approach would issue an error message, but we can live with the simplification. If <code>n</code> is 0, the zero flag is set, and the updated memory value and flags returned (see <a href="ch12.xhtml#ch012list14">Listing 12-14</a>).</p>&#13;
<pre>def ADD(self, rest, mem, flags):&#13;
    op0,op1,dst = self.ops(rest,mem)&#13;
    ans = op0 + op1&#13;
    return self.assign(ans, dst, mem, flags)</pre>&#13;
<p class="caption" id="ch012list14"><em>Listing 12-14: Implementation of <span class="codeitalic1">ADD</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_338"/>Binary math operations like <code>ADD</code> use a four-character argument of the form <span class="codeitalic">&lt;dst&gt;= &lt;op1&gt;&lt;op2&gt;</span>. where <span class="codeitalic">&lt;dst&gt;</span> is a destination, either memory or an index register, and <span class="codeitalic">&lt;op1&gt;</span> and <span class="codeitalic">&lt;op2&gt;</span> are sources. Memory is denoted as <code>M</code> and index registers by their names.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch012list14">Listing 12-14</a> implements addition. The text of the argument is in <code>rest</code>, as with <code>SET</code>. Interpretation of the argument happens in the <code>ops</code> method, which returns the operand values and the destination register’s name (or memory). The operation <code>ADD</code> adds the two operands (<code>ans</code>) and updates memory or index registers based on the destination by calling the <code>assign</code> method. The other binary operations are similarly implemented, differing only in the line defining <code>ans</code>.</p>&#13;
<p class="indent">The <code>ops</code> method parses the four-character argument returning numeric values pulled from memory, or the index registers for the operands and the single character indicating the destination. The <code>assign</code> method takes the result, destination, current memory value, and flags, and updates the proper destination with the result. If the destination is memory and 0, the zero flag is also updated. Lastly, memory and flags are returned.</p>&#13;
<h4 class="h4" id="lev2sec117"><strong><em>Flow Control Instructions</em></strong></h4>&#13;
<p class="noindent">Instructions controlling program flow are implemented separately, as their inputs and outputs vary depending on the instruction. We’ll begin with the jump instructions (<code>JMP</code> and <code>JPR</code>, which transfer program flow between subprograms (see <a href="ch12.xhtml#ch012list15">Listing 12-15</a>).</p>&#13;
<pre>def JMP(self, inst, pc, proglen):&#13;
    pc = (pc+1) % proglen&#13;
    cp = inst[4:]&#13;
    return pc, cp&#13;
&#13;
def JPR(self, inst, pc):&#13;
    pc = 0&#13;
    cp = inst[4:]&#13;
    return pc, cp</pre>&#13;
<p class="caption" id="ch012list15"><em>Listing 12-15: The <span class="codeitalic1">JMP</span> and <span class="codeitalic1">JPR</span> instructions</em></p>&#13;
<p class="indent">The only implementation difference between <code>JMP</code> and <code>JPR</code> is how the program counter of the current subprogram is modified. For <code>JMP</code>, the program counter is incremented, rolling over if necessary, so the next transfer to the current subprogram begins with the instruction following <code>JMP</code>. For <code>JPR</code>, the program counter is set to 0 instead. Both instructions return the name of the subprogram to which execution is transferred.</p>&#13;
<p class="indent">The remaining flow control instructions, <code>GTO</code> and <code>TST</code>, operate within the current subprogram. <a href="ch12.xhtml#ch012list16">Listing 12-16</a> presents the <code>GTO</code> instruction.</p>&#13;
<pre><span epub:type="pagebreak" id="page_339"/>def GTO(self, inst, pc, proglen):&#13;
    try:&#13;
        offset = int(inst[4:])&#13;
        if (offset == 0):&#13;
            offset = 1&#13;
    except:&#13;
        offset = 1&#13;
    pc += offset&#13;
    if (pc &lt; 0):&#13;
        pc = 0&#13;
    if (pc &gt;= proglen):&#13;
        pc = proglen-1&#13;
    return pc</pre>&#13;
<p class="caption" id="ch012list16"><em>Listing 12-16: Unconditional jump within a subprogram</em></p>&#13;
<p class="indent">The <code>GTO</code> instruction’s argument is an integer offset to the current program counter value, that is, a relative number of instructions to branch from the current instruction. First, <code>GTO</code> extracts the <code>offset</code> from the instruction text and converts it to an integer. If the conversion fails, the offset is silently set to 1 to move to the next instruction. Updating the program counter comes next. The instruction adds the offset, which may be positive or negative, to the program counter, with suitable checks for jumping too far back or forward. The updated program counter value is then returned.</p>&#13;
<p class="indent">The most complex Filska instruction is <code>TST</code> (see <a href="ch12.xhtml#ch012list17">Listing 12-17</a>).</p>&#13;
<pre>def TST(self, inst, pc, proglen, flags):&#13;
 <span class="ent">➊</span> if (inst[4] == "Z"):&#13;
        v = flags[0]&#13;
    elif (inst[4] == "E"):&#13;
        v = flags[1]&#13;
    elif (inst[4] == "L"):&#13;
        v = flags[2]&#13;
    elif (inst[4] == "G"):&#13;
        v = flags[3]&#13;
    elif (inst[4] == "N"):&#13;
        v = (flags[0] == False)&#13;
    if (v):&#13;
     <span class="ent">➋</span> try:&#13;
            offset = int(inst[6:])&#13;
            if (offset == 0):&#13;
                offset = 1&#13;
        except:&#13;
            offset = 1&#13;
        pc += offset<span epub:type="pagebreak" id="page_340"/>&#13;
        if (pc &lt; 0):&#13;
            pc = 0&#13;
        if (pc &gt;= proglen):&#13;
            pc = proglen-1&#13;
    else:&#13;
     <span class="ent">➌</span> pc = (pc+1) % proglen&#13;
    return pc</pre>&#13;
<p class="caption" id="ch012list17"><em>Listing 12-17: Conditional branching within a subprogram</em></p>&#13;
<p class="indent">The first part of the <code>TST</code> instruction examines the first argument, the flag to test <span class="ent">➊</span>. The current value of the flag is put into <code>v</code>. Notice how checking for “not zero” asks if the zero flag is currently false. The second part of the instruction interprets the offset argument if the desired flag is set <span class="ent">➋</span>. This code matches <code>GTO</code> in that the offset is extracted and added to the program counter. If the flag is not set, the program counter is incremented as usual <span class="ent">➌</span>.</p>&#13;
<p class="indent">The core of Filska is in the code above, but not all of it. Again, please spend some time reading through <em>filska.py</em> to familiarize yourself with the entire implementation.</p>&#13;
<h3 class="h3" id="lev1sec84"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter introduced Filska by discussing its design and the thinking behind it. We then detailed key portions of the Python implementation to see an embodiment of the design.</p>&#13;
<p class="indent">Now that Filska exists, let’s try to write some programs with it.</p>&#13;
</div></body></html>