- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: 'Bull in a Porcelain Shop: Introducing Fault Injection'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 陶瓷店里的公牛：引入故障注入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Fault injection is the art and science of circumventing security mechanisms
    by causing small hardware corruptions during the execution of normal device functions.
    Fault injection is potentially more of a risk to system security than side-channel
    analysis. Whereas side-channel analysis targets cryptographic keys, with fault
    injection, you can attack various other security mechanisms, such as Secure Boot,
    which besides enabling full system control may enable dumping keys directly from
    memory without the complexities of side-channel analysis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入是一门通过在正常设备功能执行过程中引发小的硬件损坏，绕过安全机制的艺术和科学。故障注入对系统安全性可能构成的风险甚至大于旁道分析。旁道分析针对加密密钥，而故障注入则可以攻击其他各种安全机制，例如安全启动，除了能够完全控制系统外，还可能允许直接从内存中提取密钥，而无需复杂的旁道分析。
- en: Fault injection is all about running hardware outside normal operating parameters
    and manipulating physics to arrive at a desired outcome. It’s the major difference
    between “faults that occur in nature” and “attacker-induced faults.” Attackers
    attempt to engineer faults to trip up complex systems precisely and cause specific
    effects that allow them to bypass security mechanisms. This can range from privilege
    escalation to secret key extraction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入的核心是让硬件在超出正常操作参数的情况下运行，并通过操控物理规律来实现预期的结果。这是“自然发生的故障”和“攻击者引发的故障”之间的主要区别。攻击者试图精确地设计故障，使复杂系统发生故障并产生特定效果，从而绕过安全机制。这可能从权限提升到秘密密钥提取不等。
- en: Reaching this level of precision depends strongly on the precision of the engineered
    fault injection device. Less precise injection devices cause more unexpected effects,
    and those effects are likely to be different for every injection attempt, which
    means only some of those faults will be exploitable. Attackers try to minimize
    the number of fault injection attempts such that exploitation is possible within
    a reasonable amount of time. In Chapter 5, we cover several ways of injecting
    faults and what physically happens on the chip when a fault occurs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 达到这种精确度高度依赖于故障注入设备的精度。精度较低的注入设备会产生更多意想不到的效果，这些效果在每次注入尝试中可能会有所不同，这意味着只有部分故障能够被利用。攻击者尝试最小化故障注入尝试的次数，以便在合理的时间内实现漏洞利用。在第5章中，我们讨论了几种故障注入方式以及故障发生时芯片上发生的物理变化。
- en: Fault injection is not always a relevant attack in practice, as you’ll typically
    need physical access to the target. If a target is sitting securely in a guarded
    server room, fault injection is not applicable. When you have exhausted logical
    hardware and software attacks, but have physical access to the target, fault injection
    can be an effective means of attack. (Software-triggered fault injection is an
    exception, as the hardware fault is caused by a software process, so it doesn’t
    require physical presence. See the section “Software Attacks on Hardware” in Chapter
    1 for more details.)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入在实践中并不总是一个相关的攻击方式，因为通常需要对目标进行物理访问。如果目标安全地位于一个有安保的服务器机房内，故障注入就不适用了。当你已经用尽了逻辑硬件和软件攻击方式，但仍能物理访问目标时，故障注入可以是一个有效的攻击手段。（软件触发的故障注入是一个例外，因为硬件故障是由软件过程引起的，因此不需要物理存在。更多细节请参见第1章的“软件对硬件的攻击”部分。）
- en: In this chapter, we discuss the basics of fault injection and the various rationales
    for performing fault injection in the first place. We also do a paper study on
    an example in a real library (OpenSSH) by identifying authentication bypasses
    through a fault. Faults are unpredictable in practice, and they require much tuning
    of your fault injection test bench parameters, so we also explore the various
    parts of your fault injection test bench setup and strategies for tuning the parameters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了故障注入的基础知识，以及为什么要进行故障注入的各种理由。我们还通过识别通过故障绕过身份验证的例子，对真实库（OpenSSH）中的一个实例进行了研究。故障在实践中是不可预测的，它们需要大量调整故障注入测试平台的参数，因此我们还探讨了故障注入测试平台设置的各个部分以及调优参数的策略。
- en: Faulting Security Mechanisms
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障的安全机制
- en: Devices have multiple security mechanisms that are eligible for faulting fun.
    For example, a JTAG port’s debugging functionality may be enabled only after a
    password is supplied, the device firmware may be digitally signed, or the device
    hardware may store a key where it’s inaccessible to software. Any sane hardware
    engineer will use a single bit to represent an *access granted* state, as opposed
    to an *access denied, go home* state, and will assume that this important bit
    holds its value until its software controller instructs it to change.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设备具有多种安全机制，适合用来进行故障注入攻击。例如，JTAG端口的调试功能可能只有在输入密码后才能启用，设备固件可能经过数字签名，或者设备硬件可能存储一个密钥，软件无法访问。任何理智的硬件工程师都会使用一个单独的位来表示*访问授权*状态，而不是*访问拒绝，回家去*状态，并且会假设这个重要的位会保持其值，直到它的控制软件指示改变。
- en: 'Now, since fault injection is in practice stochastic, it is nontrivial to hit
    exactly the one bit that will break a security mechanism. Assume we have access
    to a fault injector flipping one bit at a single specific point in time. (This
    is the fault injection equivalent of a unicorn: it’s beautiful and everybody wants
    one, but in practice it doesn’t exist, unless we consider microprobing, but that’s
    another league of physical attacks.)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于故障注入在实践中是随机的，要精确击中能破坏安全机制的那个比特位并非易事。假设我们可以访问一个故障注入器，在某个特定时刻翻转一个比特位。（这是故障注入中的独角兽：它很美丽，每个人都想要，但在实践中并不存在，除非我们考虑微探针，但那是另一类物理攻击。）
- en: Now, we can use fault injection to circumvent various security mechanisms. For
    example, when a device boots and performs firmware signature verification, we
    could flip the Boolean that holds the *(in)valid signature* state. We also could
    flip the lock bit on locked functionality, such as a crypto engine, with a secret
    key we’re not supposed to use. We could even flip bits during the execution of
    a cryptographic algorithm to recover cryptographic key material. Let’s take a
    look at some of these security mechanisms in more detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以利用故障注入来绕过各种安全机制。例如，当设备启动并执行固件签名验证时，我们可以翻转保存*(无效/有效签名)*状态的布尔值。我们还可以翻转锁定功能上的锁定位，例如加密引擎，这样就可以使用我们不应该使用的秘密密钥。我们甚至可以在执行加密算法时翻转比特，以恢复加密密钥材料。让我们更详细地看看这些安全机制。
- en: Circumventing Firmware Signature Verification
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过固件签名验证
- en: 'Modern devices often boot from firmware images stored in flash memory. To prevent
    booting from hacked firmware images, device manufacturers sign them digitally,
    and the signature is stored next to the firmware image. When the device boots,
    the firmware image is inspected, and the associated signature is verified using
    a public key linked to the device manufacturer. Only when the signature checks
    out is the device allowed to boot. The verification is cryptographically secured,
    but eventually the device must make a binary decision: to boot or not to boot.
    In the device’s boot software, this decision typically boils down to a conditional
    jump instruction. Aiming the perfect fault injector at this conditional jump can
    induce a “valid” result, even though the image may have been modified. Though
    software can be complex, a controlled fault in a single location can compromise
    all the security.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代设备通常从存储在闪存中的固件镜像启动。为了防止从被篡改的固件镜像启动，设备制造商会对其进行数字签名，并将签名存储在固件镜像旁边。当设备启动时，固件镜像会被检查，并使用与设备制造商相关联的公钥验证签名。只有当签名验证通过时，设备才会允许启动。该验证是通过加密方式确保安全的，但最终设备必须做出二元决策：启动还是不启动。在设备的启动软件中，这个决策通常归结为一个条件跳转指令。针对这个条件跳转的完美故障注入可以诱发一个“有效”的结果，即使固件镜像可能已经被修改。尽管软件可能很复杂，但在单一位置控制的故障就能妥协所有安全性。
- en: Gaining runtime access during a device’s boot allows an attacker to compromise
    any software loaded thereafter, which usually is the operating system and any
    applications, where you can find many of the useful parts of a device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备启动过程中获得运行时访问权限，允许攻击者妥协其后加载的任何软件，这通常是操作系统和任何应用程序，其中包含了设备的许多有用部分。
- en: Gaining Access to Locked Functionality
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获得对锁定功能的访问
- en: A secure system needs to control access to functionality and resources. For
    example, one application shouldn’t be able to access another application’s memory;
    only a kernel should be able to access a DMA engine, and only an authorized user
    should be able to access a file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全系统需要控制对功能和资源的访问。例如，一个应用程序不应该能够访问另一个应用程序的内存；只有内核可以访问DMA引擎，且只有授权用户能够访问文件。
- en: When an unauthorized attempt to access a resource occurs, a specific access
    control bit (or bits) is checked, and “access denied” is the result. This decision
    is often based on the status of a single bit and is enforced by a single conditional
    branch instruction. The perfect fault injector takes advantage of this single
    point of failure and can flip the bit. Poof! Achievement unlocked.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生未经授权的资源访问尝试时，检查一个特定的访问控制位（或多个位），结果是“拒绝访问”。这个决策通常基于单个位的状态，并通过单一的条件分支指令强制执行。完美的故障注入器利用这个单点故障并可以翻转这个位。嘭！成就解锁。
- en: Recovering Cryptographic Keys
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复加密密钥
- en: 'Faults induced into the execution of cryptographic processes may actually leak
    cryptographic key material. A whole body of work is available on this topic, generally
    filed under the subject *differential fault analysis (DFA)*. The name stems from
    the use of differential analysis on faulted cipher execution: we analyze the differences
    between correct and faulty cipher outputs. Known DFA attacks exist on AES, 3DES,
    RSA-CRT, and ECC cryptographic algorithms.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行加密过程时引入的故障实际上可能会泄露加密密钥材料。关于这个话题，有大量的研究工作，通常归类为*差分故障分析（DFA）*。这个名字来源于对故障密码执行进行差分分析：我们分析正确和故障密码输出之间的差异。已知的DFA攻击存在于AES、3DES、RSA-CRT和ECC加密算法中。
- en: The common recipe for attack on these cryptographic algorithms is to perform
    decryption on known input data, sometimes without fault injection and other times
    while injecting faults during the decryption process. Analysis of the output data
    can allow one to determine the key itself. Known DFA attacks on 3DES require less
    than about 100 faults to achieve full key retrieval. For AES, only one or two
    are needed; read the article “Information-Theoretic Approach to Optimal Differential
    Fault Analysis” by Kazuo Sakiyama et al. for more information. The classic Bellcore
    attack on RSA-CRT requires only one fault to retrieve an entire RSA private key,
    no matter the key length, which remains an act of black magic, even after you
    grok the math! You can read more about this in *Fault Analysis in Cryptography*
    (Springer, 2012), edited by Marc Joye and Michael Tunstall.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些加密算法进行攻击的常见方法是对已知输入数据进行解密，有时不进行故障注入，而有时则在解密过程中注入故障。通过分析输出数据，可以确定密钥本身。已知的3DES
    DFA攻击只需要约100个故障即可完全恢复密钥。对于AES，仅需要一个或两个；有关更多信息，请阅读Kazuo Sakiyama等人的文章《信息理论方法优化差分故障分析》。经典的Bellcore攻击针对RSA-CRT，只需一个故障即可恢复整个RSA私钥，无论密钥长度如何，即使你理解了数学原理，它依然显得神秘莫测！你可以在*加密中的故障分析*（Springer，2012年）一书中阅读更多关于此的内容，该书由Marc
    Joye和Michael Tunstall编辑。
- en: You can achieve non-DFA attacks on crypto by faulting a cipher implementation
    to run for only one round, skipping key additions, partially zeroing-out keys,
    or other corruptions. All those methods require some analysis of the algorithm’s
    cryptographic properties and the fault to understand how to retrieve a key from
    a faulty execution. In the most trivial case, you can obtain memory dumps that
    contain key material. We’ll revisit DFA in the shape of a lab in Chapter 6.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使密码实现只运行一个轮次、跳过密钥添加、部分清零密钥或进行其他破坏，可以实现非DFA攻击。所有这些方法都需要分析算法的加密特性和故障，以理解如何从故障执行中恢复密钥。在最简单的情况下，你可以获得包含密钥材料的内存转储。我们将在第6章中通过实验室再次讨论DFA。
- en: An Exercise in OpenSSH Fault Injection
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSSH故障注入练习
- en: Let’s consider how to go about injecting faults when access is via an OpenSSH
    connection and identify possible injection points in a real segment of security
    code. Assume the device has firmware authentication checking and debugging ports
    disabled, and the only interface to it is via an Ethernet port that’s connected
    to a listening OpenSSH server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何在通过OpenSSH连接访问时注入故障，并在真实的安全代码段中识别可能的注入点。假设设备已经禁用了固件认证检查和调试端口，唯一的接口是通过连接到监听OpenSSH服务器的以太网端口。
- en: Injecting Faults into C Code
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向C代码中注入故障
- en: To attempt a fault injection during the password prompt phase, we must inspect
    the OpenSSH 7.2p2 code in [Listing 4-1](#listing4-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在密码提示阶段尝试故障注入，我们必须检查[列表4-1](#listing4-1)中的OpenSSH 7.2p2代码。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: OpenSSH password authentication code in *auth2-passwd.c*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-1：*auth2-passwd.c*中的OpenSSH密码验证代码
- en: The `userauth_passwd` function we’ve copied into [Listing 4-1](#listing4-1)
    is clearly responsible for the “yay/nay” of password correctness. The `authenticated`
    variable on line 54 indicates valid access. Read through this code and consider
    how to manipulate the execution by means of faults to return a `1` value for the
    `authenticated` variable when provided with an invalid password. Assume you can
    do things like flip bits or change branches. Don’t stop until you’ve found at
    least three ways; then read the following answers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[列表4-1](#listing4-1)中复制的`userauth_passwd`函数显然负责密码正确性的“是/否”判断。第54行的`authenticated`变量表示有效访问。仔细阅读这段代码，考虑如何通过故障注入来操控执行，使`authenticated`变量在提供无效密码时返回`1`值。假设你可以做诸如翻转位或更改分支之类的操作。不要停下来，直到你找到了至少三种方法；然后阅读以下答案。
- en: 'Here are a handful of ways you could theoretically fault this code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些理论上可以故障这个代码的方法：
- en: Flip the `authenticated` flag to be nonzero after or at line 54.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第54行之后或第54行时将`authenticated`标志翻转为非零。
- en: Change the return value of `auth_password()` on line 70 to `1`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第70行`auth_password()`的返回值更改为`1`。
- en: Change the outcome of the comparison on line 70 to “true.”
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第70行比较的结果更改为“true”。
- en: Change the value to check against on line 70 to the password provided.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第70行的检查值更改为提供的密码。
- en: Request a password change to the code, setting `change` equal to `1`, then fault
    `newpass` on line 62 to be pointing to the same spot as `password`, and then exploit
    the double `free` call that’s now freeing the same memory at line 64 and line
    73 through software exploitation.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求更改密码，将`change`设置为`1`，然后使第62行的`newpass`指向与`password`相同的位置，并通过软件利用现在在第64行和第73行释放相同内存的双重`free`调用进行利用。
- en: This last fault scenario is very far-fetched, because we’ve never seen that
    kind of control over a target in practice. However, the others are basic faults.
    Dozens more fault opportunities emerge once you track the code leading to the
    `auth_password()` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的故障场景是非常牵强的，因为我们在实践中从未见过那种控制目标的情况。然而，其他的都是基本故障。一旦你追踪到导致`auth_password()`函数的代码，更多的故障机会就会显现出来。
- en: The important point is that some faults are easier to achieve in practice than
    other faults. Generally, the more precise the timing or the more specific the
    required effect, the lower the probability of achieving a successful fault.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，一些故障在实践中比其他故障更容易实现。通常，定时越精确或所需效果越具体，成功故障的概率就越低。
- en: Injecting Faults into Machine Code
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向机器码注入故障
- en: Looking at C code is a nice exercise; however, CPUs don’t execute C. CPUs execute
    instructions that are created out of C code, namely machine code. Machine code
    is hard to read for humans, so we’ll look at assembly code, which is a fairly
    direct representation of machine code. The assembly code instructions are at a
    lower abstraction level than C, and they are a more straightforward representation
    of the activities happening in the hardware (on high-end CPUs there is another
    lower abstraction microcode layer, which we’ll disregard because it’s mostly invisible).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看C代码是一个很好的练习；然而，CPU并不会执行C语言。CPU执行的是从C代码生成的指令，即机器码。机器码对人类来说很难阅读，因此我们将查看汇编代码，汇编代码是机器码的直接表示。汇编代码指令的抽象级别低于C，并且更直接地表示了硬件中的活动（在高端CPU上，还有一个更低抽象级别的微代码层，我们将忽略它，因为它大多是不可见的）。
- en: 'Faults happen inside hardware, at the physical level, and propagate up layers
    of abstraction. A bit flip can happen inside a CPU while that CPU is executing
    a binary, and that binary is produced from some source code. So, although a relation
    exists between the fault and the preceding C code, looking at the assembly code
    brings us a layer closer to the fault. For some background reading on this, see
    “Fault Attacks on Secure Embedded Software: Threats, Design and Evaluation” by
    Bilgiday Yuce et al.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '故障发生在硬件内部，处于物理层，并向上传播到各个抽象层。位翻转可以在CPU内部发生，而该CPU正在执行一个二进制文件，而这个二进制文件是从某些源代码生成的。因此，尽管故障与之前的C代码之间存在某种关系，但查看汇编代码使我们更接近故障。有关此方面的背景阅读，请参见Bilgiday
    Yuce等人所著的《Fault Attacks on Secure Embedded Software: Threats, Design and Evaluation》。'
- en: For this book, we took an OpenSSL binary and loaded it into the IDA Pro disassembler
    program. Take a look at the disassembly of the tail end of the `userauth_passwd`
    function in [Figure 4-1](#figure4-1).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们获取了一个OpenSSL二进制文件，并将其加载到IDA Pro反汇编程序中。请查看[图4-1](#figure4-1)中`userauth_passwd`函数末尾的反汇编。
- en: '![f04001](image_fi/278748c04/f04001.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](image_fi/278748c04/f04001.png)'
- en: 'Figure 4-1: Identifying instructions to fault in assembly code'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：在汇编代码中识别注入故障的指令
- en: By convention, the function returns the state of the user’s authentication status
    in the `rax` register. This `rax` register needs to be nonzero for the program
    to interpret it as `authenticated==true`. Note that `eax` is just the lower 32
    bits of `rax`, so think about the conditions that lead to `rax` being 0 by looking
    at the final basic block labeled `loc_24723` (marked with 1). We’ll wait (spoilers
    follow).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，函数返回用户身份验证状态的`rax`寄存器中的值。此`rax`寄存器需要为非零值，程序才能将其解释为`authenticated==true`。请注意，`eax`只是`rax`的低32位，因此请通过查看标记为`loc_24723`的最终基本块（标记为1）来思考导致`rax`为0的条件。我们将等待（以下是剧透）。
- en: What needs to happen is for the input state to the final `loc_24723` basic block
    at 1 to be `ebp != 0`. In Intel assembly, `ebp` is the lower 32 bits of `rbp`,
    and `bpl` is the lower 8 bits of `rbp/ebp`. Now trace back up the code and think
    about ways to achieve `ebp != 0` by injecting a fault that flips a bit or skips
    an instruction. We’ll wait again.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要发生的情况是，输入状态必须使得最终的`loc_24723`基本块（位置1）满足`ebp != 0`。在Intel汇编中，`ebp`是`rbp`的低32位，`bpl`是`rbp/ebp`的低8位。现在回溯代码并思考通过注入故障翻转某个位或跳过某个指令来实现`ebp
    != 0`的方法。我们再等一下。
- en: 'Here are a few ways that we found:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们找到的几种方法：
- en: At `loc_24748` (marked with 2), skip the call to `mm_auth_password` and hope
    that `eax` was `1`. If `eax` was `1`, the `setz bpl` instruction causes `ebp !=
    0` and, therefore, `authenticated==true`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`loc_24748`（标记为2）处，跳过对`mm_auth_password`的调用，并希望`eax`为`1`。如果`eax`为`1`，则`setz
    bpl`指令会使`ebp != 0`，因此`authenticated==true`。
- en: At `loc_24748` (marked with 2), introduce a fault to skip the `cmp eax,1` and
    hope that `auth_password` set the `z` flag to `1`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`loc_24748`（标记为2）处，引入一个故障来跳过`cmp eax,1`指令，并希望`auth_password`将`z`标志设置为`1`。
- en: Okay, you probably didn’t find this one unless you analyzed the calling function
    in the binary yourself. (Always look at the big picture; that’s where the bugs
    are!) After the `auth_password` call, the `authenticated` variable appears in
    `eax`, then the `bpl` flag, then `ebp`, and finally in `rax` (see, for example,
    3 copying out of `ebp` to `rax/eax`), which means you can induce a fault anywhere
    along that chain in the relevant register to set `authenticated` to a value of
    `1`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好吧，你可能没找到这个，除非你自己分析了二进制文件中的调用函数。（总是从大局着眼；问题通常就藏在这里！）在`auth_password`调用之后，`authenticated`变量出现在`eax`中，然后是`bpl`标志，接着是`ebp`，最后是`rax`（例如，3将`ebp`复制到`rax/eax`），这意味着你可以在相关寄存器的任何地方诱发故障，从而将`authenticated`的值设置为1。
- en: Set the password `change` flag to `true` (through the protocol or a fault; note
    that any nonzero value evaluates to `true`), leading to the `password change not
    supported` response shown in 4 to the `logit` function call. Inject a fault to
    skip the `xor ebp,ebp` steps after that call and then hope `ebp` was nonzero.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密码`change`标志设置为`true`（通过协议或故障；注意，任何非零值都会被视为`true`），从而导致如图4所示的`password change
    not supported`响应，传递给`logit`函数调用。注入一个故障跳过该调用后的`xor ebp,ebp`步骤，然后希望`ebp`是非零值。
- en: Again, you could inject faults into the assembly code at many points. You don’t
    need a very precise plan of what fault to inject to reach a particular outcome.
    In this example, various faults can set `authenticated==true` to bypass the password
    mechanism.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，你可以在多个点注入故障到汇编代码中。你不需要非常精确地计划注入哪个故障来达到某个特定的结果。在这个例子中，多个故障可以设置`authenticated==true`，以绕过密码机制。
- en: 'Now, OpenSSH was never written with fault injection in mind; it’s not part
    of the threat model. In Chapter 14, you’ll learn that you can employ all kinds
    of countermeasures in the software to reduce the effectiveness of injected faults.
    You’ll also find information on *fault simulation* in that chapter, which you
    can use to detect how well code can resist faults. Making code more robust against
    naturally occurring faults also restricts malicious fault injections, but not
    completely. For more on the topic of non-malicious fault injection, see *Software
    Fault Injection* (Wiley, 1998) by Jeffrey M. Voas et al. For how safety measures
    in chips don’t always translate into security mechanisms, see “Safety ≠ Security:
    A Security Assessment of the Resilience Against Fault Injection Attacks in ASIL-D
    Certified Microcontrollers,” by Niels Wiersma et al. The previous source and assembly
    code examples show how a single fault can have a major impact on security, such
    as a password bypass.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，OpenSSH 在编写时并没有考虑故障注入；这并不是其威胁模型的一部分。在第14章中，你将了解到如何在软件中采用各种对策，减少注入故障的效果。你还会在那一章找到有关*故障仿真*的信息，利用这些信息可以检测代码抵抗故障的能力。增强代码对自然发生的故障的鲁棒性，也限制了恶意故障注入，但并非完全阻止。关于非恶意故障注入的更多内容，请参阅
    Jeffrey M. Voas 等人所著的《软件故障注入》（Wiley，1998）。至于芯片中的安全措施为何并不总能转化为安全机制，请参见 Niels Wiersma
    等人所著的《安全 ≠ 安全：对ASIL-D认证微控制器抗故障注入攻击的安全评估》。前述来源和汇编代码示例展示了一个单一故障如何对安全性产生重大影响，例如绕过密码。
- en: Fault Injection Bull
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障注入公牛
- en: So far, we’ve assumed we have access to a mythical, perfect, one-bit fault injector
    that we called our fault injection unicorn. Unfortunately, this device doesn’t
    exist, so let’s see how close we can get to our mythical unicorn, but with tools
    that exist on earth. In practice, the best we can hope for are ways of causing
    useful faults some of the time. Simpler ways of injecting faults include overclocking
    or under-volting a circuit and overheating it. Science-fiction-esque methods exist
    as well, such as using strong electromagnetic (EM) pulses, focused laser pulses,
    or radiation by alpha particles or gamma rays.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设我们可以使用一个虚构的完美的一位故障注入器，我们称之为故障注入独角兽。不幸的是，这个设备并不存在，因此让我们看看如何尽可能接近我们的虚构独角兽，但使用现实世界中现有的工具。实际上，我们能期望的最好情况是有时能够造成一些有用的故障。注入故障的简单方法包括超频或欠压电路并使其过热。也有类似科幻的手段，例如使用强大的电磁（EM）脉冲、聚焦激光脉冲，或者通过α粒子或伽马射线辐射。
- en: An attacker selects a fault injection means and then tunes the timing, duration,
    and other parameters to maximize the effectiveness of the attack, which is the
    goal. The defender’s goal is to minimize the effectiveness of those attacks, which
    is where fault injection goes from theory to practice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者选择一种故障注入手段，然后调整时机、持续时间和其他参数，以最大化攻击的效果，这就是目标。防御者的目标是最小化这些攻击的效果，这就是故障注入从理论走向实践的地方。
- en: In reality, you won’t be able to inject a perfect fault on your first try, because
    you won’t know the fault parameters. If you did know the correct parameters, our
    unicorn fault injector would result in a deterministic effect on a target. However,
    since your injector always includes some imprecision and jitter, you’ll observe
    multiple kinds of effects, even when you use the same settings. In practice, your
    injector’s imprecision will lead to stochastic fault-injection attempts, and you’ll
    need several attempts to reach a successful attack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不可能在第一次尝试时注入一个完美的故障，因为你不知道故障的参数。如果你知道正确的参数，那么我们的独角兽故障注入器将对目标产生确定性的效果。然而，由于你的注入器总是包含一些不精确和抖动，即使使用相同的设置，你也会观察到多种不同的效果。在实践中，你的注入器的不精确将导致随机的故障注入尝试，你需要进行几次尝试才能成功攻击。
- en: To tackle this dilemma, you need to build a system to perform fault experiments
    and control the target as precisely as possible. The idea is to start a target
    operation, wait for a trigger signal indicating that the targeted operation is
    executing, inject the fault, capture the results, and, if needed, reset the target
    for a new attempt.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个难题，你需要构建一个系统来执行故障实验，并尽可能精确地控制目标。其思路是启动目标操作，等待触发信号以指示目标操作正在执行，然后注入故障，捕获结果，如果需要，再重置目标进行新的尝试。
- en: Target Device and Fault Goal
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标设备与故障目标
- en: As we’ve mentioned, fault injection requires physical control over a device,
    so first you need a device (or several in case you fry something). Selecting a
    simple device like an Arduino or another slow microcontroller is helpful—preferably
    one for which you have already written some code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，故障注入需要对设备进行物理控制，因此首先需要一台设备（如果损坏了某个设备，最好准备几台）。选择像Arduino这样的简单设备或其他较慢的微控制器是有帮助的——最好选择已经编写过代码的设备。
- en: Next, you need an idea of the goal you’re aiming toward by applying the fault,
    such as bypassing a password verification hurdle. You’ve already seen an analysis
    of OpenSSH code in the previous section in both C and assembly that provided numerous
    ways to achieve such a goal. Keep in mind C, assembly, and Verilog or VHDL are
    just representations of what is going on with physical hardware. Here, you’re
    trying to manipulate hardware by interfering with its physical environment. By
    doing this, you mess with the assumptions that engineers make—for example, that
    a transistor switches only when instructed to do so, that a logic gate will actually
    switch before the next clock tick, that a CPU instruction will be executed correctly,
    that variables in a C program will hold their value until written over, or that
    an arithmetic operation will always correctly compute its result. You induce the
    fault at the physical level to achieve goals at the higher level.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要明确通过故障注入所要达到的目标，例如绕过密码验证的障碍。在前一节中，你已经看到了对OpenSSH代码的分析，包括C语言和汇编语言的分析，提供了实现此目标的多种方式。请记住，C语言、汇编语言以及Verilog或VHDL只是对物理硬件发生的事情的表示。在这里，你试图通过干扰硬件的物理环境来操控硬件。通过这样做，你打破了工程师的假设——例如，晶体管仅在被指令驱动时才会切换，逻辑门将在下一个时钟周期前实际切换，CPU指令将正确执行，C程序中的变量会在被覆盖之前保持其值，或算术操作总是能正确计算其结果。你在物理层面引发故障，以在更高层次上实现目标。
- en: Fault Injector Tools
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障注入工具
- en: The better you understand the physics, the better you can plan your fault injector,
    but by no means do you need a PhD in physics. Chapter 5 will go into more depth
    about the physics behind the different methods and the construction of a fault
    injector device.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你对物理学的理解越深入，你就能越好地规划你的故障注入器，但并不意味着你需要拥有物理学博士学位。第5章将更深入地探讨不同方法背后的物理学原理以及故障注入设备的构造。
- en: A fault injector that generates a clock signal for a target device can replicate
    the device’s usual clock signal, but then inject one very fast cycle at a specific
    point in time to overclock a process. The goal is to cause a fault in a CPU when
    the fast cycle is introduced. [Figure 4-2](#figure4-2) shows what such a clock
    signal looks like.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生成时钟信号的故障注入器可以复制目标设备的常规时钟信号，但然后在特定时刻注入一个非常快速的周期，以超频某个过程。目标是在引入快速周期时，导致CPU发生故障。[图4-2](#figure4-2)显示了这样的时钟信号的样子。
- en: '![f04002](image_fi/278748c04/f04002.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](image_fi/278748c04/f04002.png)'
- en: 'Figure 4-2: Causing a fault in a CPU with a fast cycle'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：使用快速周期导致CPU故障
- en: Here we have a normal clock with a period of 70ns until cycle A. Cycle A is
    cut short such that cycle B starts only 30ns after the start of cycle A. The duration
    of B and C is again 70ns. This may cause a fault in the chip operation during
    cycle A and/or B.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个正常的时钟，其周期为70ns，直到周期A。周期A被缩短，使得周期B在周期A开始后仅30ns开始。周期B和C的持续时间再次为70ns。这可能会在周期A和/或B期间导致芯片操作故障。
- en: Having a nanosecond jitter in timing makes a big difference when dealing with
    GHz clock speeds; one nanosecond is the length of a full clock cycle at 1 GHz.
    Achieving such timing precision in practice means building specialized hardware
    circuits to do the fault injection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理GHz时钟速度时，纳秒级的时序抖动差异非常大；1纳秒是1 GHz时钟周期的长度。要在实践中实现如此精确的时序，意味着需要构建专门的硬件电路来进行故障注入。
- en: You want to be able to control as many of the aspects of your fault injection
    as possible, so make sure your injector is programmable. Finding the right fault
    parameters requires many experiments, each with its own settings. In the clock
    injector example, you want to be able to program your injector with the normal
    clock speed, with the overclocked clock speed, and with an injection point. This
    way, repeated experiments will allow you to control the frequency of injection
    and figure out what settings cause an anomaly or repeatable effect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要尽可能多地控制故障注入的各个方面，因此确保你的注入器是可编程的。找到合适的故障参数需要进行许多实验，每个实验都有不同的设置。在时钟注入器的例子中，你需要能够将注入器编程为正常时钟速度、超频时钟速度和注入点。通过这种方式，重复实验将允许你控制注入的频率，并找出哪些设置导致异常或可重复的效果。
- en: Target Preparation and Control
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标准备与控制
- en: 'The details of how to prepare a fault injection depend on your target and the
    type of fault you intend to inject. Luckily, you’ll want to do some common actions:
    send a command to the target, receive results from the target, control the target
    reset, control a trigger, monitor the target, and perform any fault-specific modifications.
    [Figure 4-3](#figure4-3) shows an overview of the connections.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 准备故障注入的细节取决于你的目标和你打算注入的故障类型。幸运的是，你会想做一些常见的操作：向目标发送命令、接收来自目标的结果、控制目标重置、控制触发器、监视目标并执行任何特定故障的修改。[图4-3](#figure4-3)展示了连接的概览。
- en: '![f04003](image_fi/278748c04/f04003.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f04003](image_fi/278748c04/f04003.png)'
- en: 'Figure 4-3: The connections between PC, fault injector, and target'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：PC、故障注入器和目标之间的连接
- en: The fault injector in [Figure 4-3](#figure4-3) is the physical tool that performs
    the fault injection. For now, we just assume it can somehow insert a fault in
    the target using one of the methods we briefly described (clock, voltage, and
    so on). The target will trigger the fault injector to synchronize the fault injector
    to the target. This trigger typically goes directly to the fault injector tool,
    as the fault injector tool will have very accurate timing compared to routing
    the trigger through the PC. The PC will control the overall target communications,
    as we need to record a variety of output data from the device. Because timing
    is the important aspect here, we can learn more about how the overall setup works
    by now looking at the interactions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-3](#figure4-3)中的故障注入器是执行故障注入的物理工具。目前，我们只是假设它可以通过我们简要描述的一种方法（如时钟、电压等）在目标中插入故障。目标将触发故障注入器，以便同步故障注入器与目标。这一触发通常直接传送到故障注入器工具，因为故障注入器工具与通过PC路由触发器相比，具有非常精确的时序。PC将控制整体目标通信，因为我们需要记录设备的各种输出数据。由于时序是这里的关键因素，我们可以通过现在查看交互来更好地了解整体设置如何工作。'
- en: '[Figure 4-4](#figure4-4) shows a common sequence diagram outlining the interaction
    between the PC (controlling everything), the fault injector, and the target. You
    can consider the fault injector being connected to the PC by a standard interface
    such as USB.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](#figure4-4)展示了一个常见的时序图，概述了PC（控制一切）、故障注入器和目标之间的交互。你可以认为故障注入器通过USB等标准接口连接到PC。'
- en: '![f04004](image_fi/278748c04/f04004.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![f04004](image_fi/278748c04/f04004.png)'
- en: 'Figure 4-4: The sequence of operations for a single fault injection attempt
    initiated by a PC, which controls the fault injector and target'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4：由PC启动的单次故障注入尝试的操作顺序，PC控制故障注入器和目标
- en: This timing shows that we first configure the fault injector with the parameters
    we want to test. In this example, we also have a *glitch delay* and *glitch length*
    as the configuration parameters. After the trigger event from the target, the
    fault injector waits the glitch delay amount before inserting a fault (glitch)
    of glitch length. After inserting the fault, we observe the target operation’s
    output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时序图显示了我们首先用我们要测试的参数配置故障注入器。在这个例子中，我们还将*故障延迟*和*故障时长*作为配置参数。目标触发事件后，故障注入器会等待故障延迟时间，然后插入一个时长为故障时长的故障（波动）。插入故障后，我们观察目标操作的输出。
- en: Sending a Command to the Target
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向目标发送命令
- en: The target device needs to run a process or operation that you intend to fault
    under control of a script. This depends on the operation, but it can be a command
    sent over RS232, JTAG, USB, the network, or some other communication channel.
    Sometimes starting the target operation can be as simple as switching on the device.
    In the previous OpenSSH example, you need to connect to the SSH daemon over the
    network to send a password, which starts the password verification target operation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目标设备需要运行一个你打算通过脚本控制的故障过程或操作。这取决于操作的类型，但它可以是通过RS232、JTAG、USB、网络或其他通信通道发送的命令。有时候，启动目标操作可能像开机一样简单。在之前的OpenSSH示例中，你需要通过网络连接到SSH守护进程并发送密码，这样就能启动密码验证目标操作。
- en: Receiving Results from the Target
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从目标设备接收结果
- en: You next need to know whether your injected fault produced some interesting
    result. A typical way is to monitor target communication for any result codes,
    statuses, or other signals that could be interesting gateways to injection. Try
    to monitor and record all information from the communication channel at the lowest
    level possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要知道你注入的故障是否产生了某些有趣的结果。一种典型的方法是监控目标设备的通信，查看是否有任何结果代码、状态或其他可能是注入的有趣信号。尽量以最低级别监控并记录所有来自通信通道的信息。
- en: For instance, in a serial connection, monitor all the bytes going back and forth
    over the line, even if a more complex protocol is being run on top of that. The
    intent is that the device must fault. The data being churned out may be unusual
    and not adhere to the normal communications protocol. You don’t want any protocol
    parsers on your end getting in the way of capturing the device fault. Capture
    everything; try to parse it later. In the case of the OpenSSH example, sniff all
    network traffic from the target instead of relying only on your SSH client logging.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在串行连接中，监控所有来回传输的字节，即使在其上运行了更复杂的协议。目的是让设备发生故障。传输的数据可能会异常，并且不遵循正常的通信协议。你不希望任何协议解析器阻碍你捕获设备故障。捕获所有数据，稍后再进行解析。在OpenSSH示例中，嗅探所有来自目标设备的网络流量，而不仅仅依赖于SSH客户端的日志。
- en: Controlling the Target Reset
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制目标重置
- en: You will likely crash your target many times before your experiments reap some
    success, because each experiment can cause an undetermined behavior or state.
    You’ll need some way to reset the device into a known state. One way is pulsing
    a reset or line button to initiate a warm reset, which is typically sufficient,
    although sometimes the device won’t reset properly. In that case, you can do a
    cold reset by dropping the supply voltage of the core or device you are targeting.
    When doing a supply voltage interruption, drop the supply for just long enough
    to cause a clean reset (do it too fast and you may cause a fault—you don’t want
    that here). If that isn’t possible, a cheap USB-controlled power strip may provide
    what you need, although that may crash as well. Both ends of a communications
    channel can crash if your device emits weird data. The host will need to recognize
    USB targets again before you can continue. The control code on the host should
    anticipate and attempt to handle any of these issues. In the OpenSSH example,
    the device that runs the OpenSSH server should restart the server automatically
    upon reset.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的实验取得成功之前，你可能会多次使目标设备崩溃，因为每次实验可能会导致未确定的行为或状态。你需要某种方法将设备重置为已知状态。一种方法是通过按下重置或线路按钮来启动热重置，这通常是足够的，尽管有时设备无法正确重置。在这种情况下，你可以通过切断目标设备的核心或设备的电源来进行冷重置。在进行电源中断时，切断电源的时间要足够长，以便进行干净的重置（如果过快进行，可能会导致故障——你可不想发生这种情况）。如果这不可行，便宜的USB控制电源插座可能能提供你所需的功能，尽管它也可能会崩溃。如果设备发出异常数据，通信通道的两端都有可能崩溃。主机需要重新识别USB目标设备，然后你才能继续。在主机上的控制代码应该预见并尝试处理这些问题。在OpenSSH示例中，运行OpenSSH服务器的设备在重置后应该自动重新启动服务器。
- en: Controlling a Trigger
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制触发器
- en: Triggers are electrical signals originating from within a target. The fault
    injector uses them to synchronize with operations in the target. Using a stable
    trigger with minimal jitter makes it easier to inject a fault at the right time.
    The best way to do that is to program the target device to generate a trigger
    on any of the external pins of the chip, such as a GPIO, serial port, LED, and
    so on. Right before the target operation, the trigger pin is pulled to the high
    voltage, and after the target operation, the pin is pulled to the low voltage.
    When the fault injector sees the trigger, make it wait an adjustable delay and
    then inject the fault. This way, you have a steady reference point in time with
    respect to the target operation and can try to inject faults at different delays
    into its execution. [Figure 4-5](#figure4-5) shows an overview of target operation,
    trigger, and fault timing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器是来自目标内部的电信号。故障注入器利用这些信号与目标操作同步。使用一个稳定且抖动最小的触发器可以更容易地在正确的时间注入故障。最好的方法是编程目标设备，在芯片的任何外部引脚上生成触发信号，例如
    GPIO、串口、LED 等。在目标操作之前，触发引脚被拉高电压，目标操作完成后，触发引脚被拉低电压。当故障注入器看到触发信号时，它会等待一个可调的延迟，然后注入故障。这样，你就有了一个相对于目标操作的稳定时间参考点，并可以尝试在不同的延迟下向其执行过程注入故障。[图
    4-5](#figure4-5) 显示了目标操作、触发器和故障时序的概述。
- en: '![f04005](image_fi/278748c04/f04005.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f04005](image_fi/278748c04/f04005.png)'
- en: 'Figure 4-5: Overview of target operation, trigger, and fault timing'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：目标操作、触发器和故障时序概述
- en: The power consumption, which is measured with an oscilloscope, represents the
    target operation. A pulse, also measured with an oscilloscope, represents the
    trigger, and the fault is the input pulse created for the fault injector representing
    the fault’s timing and amplitude.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 功耗通过示波器测量，代表目标操作。脉冲也是通过示波器测量的，代表触发信号，故障则是为故障注入器创建的输入脉冲，代表故障的时序和幅度。
- en: Even though the delay after the trigger *should* be constant, clock jitter on
    the target may mean that the target operation isn’t happening at a predictable
    time, which decreases the fault’s success rate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使触发后的延迟*应该*是恒定的，目标上的时钟抖动可能导致目标操作没有在可预测的时间发生，从而降低故障的成功率。
- en: Jitter may come from other unexpected sources, so as part of characterizing
    your device, be sure to explore whether the device has nonconstant timing in execution.
    Obvious sources for that jitter include interrupts and leaving a lot of extra
    code between your trigger instructions and the actual targeted fault code. But
    even “simple” devices (such as ARM Cortex-M processors) may optimize machine instructions
    on the fly, meaning the delay of executing a given instruction depends on prior
    instructions executed (the *context*). This means if you move the trigger code
    around to target different areas, there is an unexpected small number of cycles
    difference. Many devices (including the ARM Cortex-M) support an *instruction
    synchronization barrier (ISB)* instruction, which you can insert to “clear” the
    context before executing your trigger code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 抖动可能来自其他意外的来源，因此，作为表征设备的一部分，务必检查设备在执行过程中是否具有不稳定的时序。明显的抖动来源包括中断以及在触发指令和实际目标故障代码之间留下大量多余代码。但即使是“简单”的设备（如
    ARM Cortex-M 处理器）也可能会即时优化机器指令，这意味着执行某个指令的延迟取决于先前执行的指令（*上下文*）。这意味着，如果你将触发代码移动到不同的区域，就会出现一个意外的小周期差异。许多设备（包括
    ARM Cortex-M）支持*指令同步屏障（ISB）*指令，可以在执行触发代码之前插入该指令以“清除”上下文。
- en: If you encounter devices that don’t offer programmatic access for creating a
    hardware trigger, the fallback is software triggering, which requires sending
    a command to start the operation from the controlling host, performing a precise
    delay on the controlling host, and then initiating the fault injector by sending
    a software command to it. A pure software solution suffers from all the jitter
    of software control. Inducing a meaningful fault won’t be impossible, but it will
    decrease your ability to reproduce the fault reliably.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到无法通过编程方式创建硬件触发器的设备，则可以退而求其次使用软件触发，这需要从控制主机发送命令来启动操作，在控制主机上执行精确的延迟，然后通过发送软件命令启动故障注入器。纯软件解决方案会受到软件控制中所有抖动的影响。诱发一个有意义的故障并非不可能，但会降低你可靠再现故障的能力。
- en: In the OpenSSH example, you can recompile OpenSSH to include a command that
    generates a trigger, or you can fall back on software-based triggering by having
    your controlling host send a password to the OpenSSH server followed by a “go”
    command to the fault injector.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenSSH 示例中，您可以重新编译 OpenSSH，加入生成触发信号的命令，或者通过让控制主机向 OpenSSH 服务器发送密码并随后发送一个“go”命令给故障注入器，来使用基于软件的触发方式。
- en: Monitoring the Target
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监控目标设备
- en: To debug your setup, you need to monitor the target, the communication, the
    trigger, and the reset lines. A logic analyzer or oscilloscope is your friend
    for this task. Run a few target operations without injecting faults and capture
    the communication, trigger, and reset lines. Are they all working properly? Using
    your side-channel capabilities (see Chapters 8 and 9) can also be enlightening
    when monitoring target behavior. You should be able to see, for instance, how
    much jitter exists between the trigger signal and the operations being executed.
    If the operations seem to jump back and forth on your scope’s time axis, jitter
    is the cause. Run a few trial faults to see if everything continues to run.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试您的设置，您需要监控目标、通信、触发信号和复位线路。逻辑分析仪或示波器是执行此任务的好帮手。在没有注入故障的情况下运行几次目标操作，并捕获通信、触发和复位线路的信号。它们都工作正常吗？利用您的侧信道能力（见第
    8 和第 9 章）在监控目标行为时也可能获得启发。例如，您应该能够看到触发信号与执行操作之间的抖动有多少。如果操作在示波器的时间轴上来回跳动，说明是抖动引起的。运行几个试验故障，看看一切是否继续正常运行。
- en: Monitoring comes with one huge caveat. In the analog domain, the measuring process
    itself always affects your target. You don’t want the scope hanging off the VCC
    line to absorb that pretty voltage glitch. The extra load on the wires will change
    the injected glitch’s shape. If you must keep your scope connected, configure
    it for a high impedance and use a 10:1 probe.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 监控有一个巨大的警告。在模拟域中，测量过程本身总是会影响目标设备。您不希望将示波器连接在 VCC 线路上，以免吸收那漂亮的电压波动。线缆上的额外负载会改变注入故障的形状。如果必须保持示波器连接，请将其配置为高阻抗，并使用
    10:1 探头。
- en: Before commencing actual fault injection experiments, triple-convince yourself
    that everything is working, and then remove all temporary monitoring so it doesn’t
    interfere with the results. More than once have simple setup mishaps, unanticipated
    instabilities, operating system (OS) updates, and so on interfered in what otherwise
    was a nicely thought-out experiment. Weekend experiments were lost, and people
    were sad.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际的故障注入实验之前，要三重确认一切都正常工作，然后移除所有临时监控设备，以免干扰实验结果。曾有很多次，由于设置上的简单失误、预料之外的不稳定性、操作系统（OS）更新等原因，干扰了本来精心设计的实验。周末的实验因此作废，大家都感到很失望。
- en: Performing Fault-Specific Modifications
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行故障特定的修改
- en: You often need to modify the target physically to execute faults successfully.
    The clock fault in the OpenSSH example requires that you modify the printed circuit
    board (PCB) to inject a clock (we discuss specific modification possibilities
    and tactics in later sections).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功执行故障注入，通常需要物理地修改目标设备。在 OpenSSH 示例中，时钟故障要求修改印刷电路板（PCB），以注入时钟（我们将在后续章节讨论具体的修改可能性和策略）。
- en: The more robustly you plan, program, and build all the attack’s components,
    the more effectively you can run your fault injection experiments. Your setup
    needs to be solid enough to run for weeks and survive any unusual situation that
    may occur. After a million or so fault injections, Murphy’s law dictates that
    the fault will occur, not necessarily in the target but in your setup instead!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您规划、编程和构建攻击组件的越稳健，您就能越有效地进行故障注入实验。您的设置需要足够坚固，能够持续运行数周并应对可能发生的任何异常情况。在进行一百万次左右的故障注入后，墨菲定律告诉我们，故障一定会发生，不一定是在目标设备上，而是在您的设置上！
- en: Fault Searching Methods
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障搜索方法
- en: Now that the target is connected and instrumented, we can inject faults. What
    we don’t yet know is precisely when, where, how much, and how often to inject.
    The general approach is simply to try and use some basic target analysis, feedback,
    and luck to find a winning combination of parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目标设备已连接并装置好，我们可以开始注入故障。我们尚不清楚的是，究竟在何时、何地、注入多少以及注入的频率如何。一般的方法是通过一些基本的目标分析、反馈和运气，找到一组有效的参数组合。
- en: First, we need to identify to which kind of faults a target is sensitive. In
    the OpenSSH example, we went right to the end goal of an authentication bypass
    and assumed we knew how to insert faults—that is, what sort of faults and parameters
    would be successful. It could be that we can fault a target out of loops or corrupt
    memory. For this, we’ll devise various experiments and test programs that help
    narrow down the target’s sensitivities.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定目标对哪种类型的故障敏感。在 OpenSSH 示例中，我们直接目标是认证绕过，并假设我们知道如何插入故障——即哪些类型的故障和参数是成功的。可能我们可以通过故障让目标跳出循环或破坏内存。为此，我们将设计各种实验和测试程序，帮助缩小目标的敏感性范围。
- en: Next, we’ll present a clock glitching example for the purpose of finding these
    parameters and walk through the steps, so you can understand what an experiment
    looks like when you put everything together. Then, we’ll explore search strategies
    a bit more, as various techniques exist for traversing the big fault parameter
    search space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示一个时钟故障示例，目的是找到这些参数，并逐步演示实验步骤，帮助你理解将所有内容整合后实验的样子。然后，我们将进一步探讨搜索策略，因为存在多种技术可以遍历庞大的故障参数搜索空间。
- en: Discovering Fault Primitives
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现故障原语
- en: Having a programmable target allows you to experiment and learn exactly what
    its weaknesses are. The main goal is to discover fault primitives and associated
    parameter values. A *fault primitive* is the type of effect an attacker has on
    the target when injecting a specific fault. It is not the fault itself but the
    category of result, such as inducing a skipped instruction or changing specific
    data values. Predicting exactly what results can be induced is difficult, but
    tests can help you investigate and tune your setup. Josep Balasch, Benedikt Gierlichs,
    and Ingrid Verbauwhede’s paper titled “An In-Depth and Black-Box Characterization
    of the Effects of Clock Glitches on 8-Bit MCUs” provides an example of digging
    even deeper into the CPU to reverse engineer what faults do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可编程的目标系统让你能够进行实验，并准确地了解它的弱点。主要目标是发现故障原语和相关的参数值。*故障原语*是指攻击者在注入特定故障时对目标造成的影响类型。它不是故障本身，而是结果的类别，例如引起跳过指令或更改特定数据值。准确预测可以诱发什么样的结果是困难的，但通过测试，你可以帮助调查并调试你的设置。Josep
    Balasch、Benedikt Gierlichs 和 Ingrid Verbauwhede 的论文《时钟故障对 8 位 MCU 影响的深入黑箱表征》提供了一个例子，展示了如何更深入地反向工程分析
    CPU 中故障的作用。
- en: Loop Test
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环测试
- en: A *loop test* is where a loop of *n* iterations is targeted. Each iteration
    increments a `count` variable by some factor; for this example, let’s say it’s
    seven. The code in [Listing 4-2](#listing4-2) shows how this type of iterative
    count checking is typically done.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环测试*是针对执行 *n* 次迭代的循环进行的。每次迭代都会根据某种因子增加一个 `count` 变量；在本示例中，假设因子为七。清单 [4-2](#listing4-2)
    中的代码展示了如何通常执行这种迭代计数检查。'
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-2: A simple loop example'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：一个简单的循环示例
- en: At the end of the program, the `count` should be `factor`times *n*. If the end
    count is not as expected, a fault has occurred. Based on the output, you can reason
    about what the fault is that happened. If the `count` addition operation was skipped,
    you’ll see a count that’s seven too low. If the increment of the loop counter
    was skipped once, you’ll see a count that is seven too high. If you break out
    of the `for` loop prematurely by corrupting the end check, you’ll see a count
    that is a factor of seven but much lower than `MAX``*``7`. These are the easier
    fault models to reverse engineer. You may also see values that look like complete
    garbage, in which case it may help to dump all CPU registers. It’s not uncommon
    for registers to get swapped on a fault, and you could end up with the stack or
    instruction pointer in your count.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序结束时，`count` 的值应该是 `factor` 乘以 *n*。如果最终的计数值与预期不符，则说明发生了故障。根据输出，你可以推测发生了什么故障。如果跳过了
    `count` 增加操作，你会看到计数值比预期少了七。如果跳过了循环计数器的增量操作一次，你会看到计数值比预期多了七。如果通过破坏结束检查过早跳出了 `for`
    循环，你会看到一个是七的倍数，但比 `MAX` * 7 要小很多的计数值。这些是较易逆向工程的故障模型。你还可能看到看起来完全是垃圾的值，在这种情况下，可能有助于转储所有
    CPU 寄存器。故障时寄存器交换并不罕见，这时你可能会在计数中看到栈或指令指针。
- en: Register or Memory Dump Test
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寄存器或内存转储测试
- en: With this type of test, we try to figure out whether we can affect memory or
    register values in a CPU. We first create a program to dump the register state
    or (parts of, or a hash of) memory to create a baseline. Next, we create a program
    that raises a trigger, executes a *nop slide* (a large number of sequential “no
    operation” instructions in the CPU), and then lowers the trigger and again dumps
    the register state or memory. Then, we start this program and attempt to inject
    a fault during the nop slide’s execution. Since the nop slide naturally doesn’t
    affect registers (except the instruction pointer) or memory, it does not contaminate
    the test results. After this experiment, we can check whether any memory or register
    content has changed by dumping it or comparing the hash.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种类型的测试，我们尝试找出是否能影响CPU中的内存或寄存器值。我们首先创建一个程序来转储寄存器状态或（部分或哈希）内存，以创建基准。接着，我们创建一个程序，触发一个触发器，执行*nop滑动*（CPU中的一大堆连续的“无操作”指令），然后关闭触发器，再次转储寄存器状态或内存。然后，我们启动该程序并尝试在nop滑动执行过程中注入一个故障。由于nop滑动自然不会影响寄存器（除了指令指针）或内存，因此不会污染测试结果。经过这个实验，我们可以通过转储或比较哈希检查内存或寄存器内容是否发生变化。
- en: This test is useful for determining the location of faults when using EM pulses,
    as you may be able to find a relation between a physical location of a RAM cell
    or register and a logical location (register or memory).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试有助于确定使用电磁脉冲时故障的位置，因为你可能能够找到RAM单元或寄存器的物理位置与逻辑位置（寄存器或内存）之间的关系。
- en: Memory Copy Test
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存复制测试
- en: During a memory copy, it may be possible to corrupt some internal registers
    with attacker-controlled data, which allows gaining arbitrary code execution.
    The theory (published in the paper “Controlling PC on ARM using Fault Injection”
    by Niek Timmers, Albert Spruyt, and Marc Witteman) is as follows. On ARMv7, for
    example, an efficient memory copy is implemented, such as that in [Listing 4-3](#listing4-3),
    by filling a number of registers with a single load and then writing all those
    registers with a single store.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存复制过程中，可能会有机会使用攻击者控制的数据破坏一些内部寄存器，从而实现任意代码执行。该理论（发表于Niek Timmers、Albert Spruyt和Marc
    Witteman的论文《使用故障注入控制ARM上的PC》）如下所述。以ARMv7为例，实现了高效的内存复制，如[清单4-3](#listing4-3)所示，通过将多个寄存器填充一个加载指令，然后通过一个存储指令写入所有这些寄存器。
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-3: A memory copy test'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-3：内存复制测试
- en: Running the preceding code in a loop copies a block of data. It becomes interesting
    when we look at how instructions are encoded (see [Table 4-1](#table4-1)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中运行前面的代码会复制一块数据。当我们查看指令如何编码时，它变得有趣（见[表4-1](#table4-1)）。
- en: 'Table 4-1: Encoding of Instructions'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1：指令编码
- en: '| **ARM assembly** | **Hex** | **Binary** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **ARM汇编** | **十六进制** | **二进制** |'
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LDMIA R1!,{R4–R7} | E8B1**0**0F0 | 11101000 10110001 00000000 11110000 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| LDMIA R1!,{R4–R7} | E8B1**0**0F0 | 11101000 10110001 00000000 11110000 |'
- en: '| LDMIA R1!,{R4–R7,**PC**} | E8B1**8**0F0 | 11101000 10110001 **1**0000000
    11110000 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| LDMIA R1!,{R4–R7,**PC**} | E8B1**8**0F0 | 11101000 10110001 **1**0000000
    11110000 |'
- en: In [Table 4-1](#table4-1), the last 16 bits of the instruction encoding signify
    the register list. R4–R7 is given by the consecutive 4 bits set to 1 in index
    4–7\. Index 15 (16th bit from the right) indicates the program counter (PC) register.
    This means that a single bit difference in the opcode allows loading data from
    memory into the PC during a normal copy loop. If a fault can achieve a bit flip,
    and if the source of the memory copy is attacker controlled, that means the PC
    would become attacker controlled.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表4-1](#table4-1)中，指令编码的最后16位表示寄存器列表。R4–R7由索引4–7中连续4个位被设置为1来表示。索引15（从右数的第16位）表示程序计数器（PC）寄存器。这意味着，操作码中的一个比特差异允许在正常的复制循环中从内存加载数据到PC。如果故障能够引起比特翻转，并且如果内存复制的源是攻击者控制的，那意味着PC将变为攻击者控制。
- en: 'Think for a while about what data you would input to the copy routine if you
    could set the PC with a fault. The following shows one answer:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想，如果你能够通过故障设置PC，你会输入什么数据到复制例程中。以下是其中一个答案：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you cause a fault that flips the PC bit in the LDMIA opcode while it is loading
    any of the data in the first 0x1000 bytes, it will cause 0x1000 to be loaded into
    the PC. At address 0x1000, you place the attack code, and when the PC points there,
    you’ve gained code execution! This example is a little simplified. It assumes
    the source of the memory buffer is at address 0\. You’ll need to figure out at
    which offset the source buffer actually lives and then offset everything.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你引发了一个故障，导致LDMIA操作码在加载前0x1000字节内的任何数据时翻转了PC位，那么会将0x1000加载到PC中。在地址0x1000处，你放置攻击代码，当PC指向那里时，你就获得了代码执行权限！这个例子有些简化了，假设内存缓冲区的来源地址是0\。你需要弄清楚源缓冲区实际所在的偏移量，然后再偏移所有内容。
- en: If this scenario seems a little far-fetched, encountering it in copy loops during
    boot (think copying from flash to SRAM) or even at the kernel/user space boundary
    (think copying a buffer into kernel memory) is actually quite common. It’s a security
    mechanism to avoid having a lower-privileged process change buffer contents while
    a higher-privileged process is using the content.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个场景看起来有些牵强，实际上在启动过程中的拷贝循环（比如从闪存到SRAM的拷贝）或甚至在内核/用户空间边界（比如将缓冲区拷贝到内核内存）中遇到这样的情况是非常常见的。这是一种安全机制，旨在防止低权限进程在高权限进程使用缓冲区内容时更改该内容。
- en: This example is specific to AArch32, but other architectures have similar constructs
    (see the Timmers, Spruyt, and Witteman paper for more details).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是针对AArch32的，但其他架构也有类似的构造（更多细节请参考Timmers、Spruyt和Witteman的论文）。
- en: Crypto Test
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加密测试
- en: A *crypto test* runs a cryptographic algorithm repeatedly with the same input
    data. Most algorithms will provide the same output when encountering the same
    input. The *Elliptic Curve Digital Signature Algorithm (ECDSA)*, which generates
    a different signature on every run, is a notable exception. If you see an output
    corruption, you may be able to execute a differential fault analysis attack (see
    “Recovering Cryptographic Keys” earlier in this chapter), which allows you to
    recover key material from faulted cryptographic algorithms.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密测试*通过相同的输入数据反复运行加密算法。大多数算法在遇到相同的输入时会提供相同的输出。*椭圆曲线数字签名算法（ECDSA）*是一个显著的例外，它在每次运行时都会生成不同的签名。如果你看到输出损坏，你可能能够执行差异故障分析攻击（参见本章前面的“恢复加密密钥”），通过这种方式，你可以从故障的加密算法中恢复密钥材料。'
- en: Targeting a Nonprogrammable Device
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对非可编程设备
- en: You won’t always have the luck to be targeting a programmable device, which
    can complicate determining the fault primitive. In that case, you have two basic
    options. The first option is to get a similar device that is programmable—for
    instance, a device with the same CPU and programmable firmware—and hope that the
    fault primitives are similar. This is usually the case, though some of the exact
    fault parameters may differ. The second option is to use monitoring capabilities
    and the powers of deduction to shoot at your target device and hope for the best.
    For example, if you want to corrupt the last round of a cryptographic algorithm,
    use a side-channel measurement to discover the timing and a broad parameter search
    to help discover further fault parameters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是有好运针对一个可编程设备，这会使确定故障原语变得复杂。在这种情况下，你有两种基本的选择。第一种选择是获取一个类似的可编程设备——例如，一个具有相同CPU和可编程固件的设备——并希望故障原语相似。通常情况是这样的，尽管一些具体的故障参数可能会有所不同。第二种选择是利用监控能力和推理能力来攻击目标设备，并希望能有所发现。例如，如果你想破坏加密算法的最后一轮，可以使用旁路测量来发现时序，并进行广泛的参数搜索，以帮助发现更多的故障参数。
- en: Searching for Effective Faults
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找有效故障
- en: The loop, memory dump, and crypto tests in the previous section allow you to
    determine what kind of fault has occurred, but they don’t tell you how to induce
    an effective fault. Determine your target’s basic performance parameters—the min
    and max clock frequencies, supply voltage, and so on—to provide some ballpark
    figures to start finding effective faults. This is where fault injection turns
    from science into a bit of art. It now boils down to tuning the fault injector’s
    parameters until they become effective.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面章节中的循环、内存转储和加密测试让你能够确定发生了何种故障，但它们并未告诉你如何引发有效的故障。首先，确定目标的基本性能参数——最小和最大时钟频率、电压等——为开始查找有效的故障提供一些大致的参考值。这时，故障注入就从科学转变为一种艺术。现在的关键是调整故障注入器的参数，直到它们变得有效。
- en: Overclock Fault Example
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超频故障示例
- en: Assume you have a target with a loop test program and a clock fault injector
    hooked up to the clock line, as shown in [Figure 4-6](#figure4-6).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个目标设备，运行着一个循环测试程序，并且将时钟故障注入器连接到时钟线，如[图 4-6](#figure4-6)所示。
- en: '![f04006](image_fi/278748c04/f04006.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f04006](image_fi/278748c04/f04006.png)'
- en: 'Figure 4-6: Clock switching arrangement'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：时钟切换安排
- en: This simple workbench uses an electronic switch to send one of two clock frequencies
    to the device. The idea is that the fast clock is too fast for the target to keep
    up and, therefore, will cause a fault. A microcontroller (clock fault injector)
    controls the switching, which is also monitoring the target device.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的工作台使用电子开关将两种时钟频率中的一种发送到设备。其理念是，快速时钟对目标设备来说过于迅速，因此会导致故障。微控制器（时钟故障注入器）控制切换，同时也在监控目标设备。
- en: You can tweak a number of parameters to tune the fault. Depending on the target,
    a set of parameter values will either have no effect, cause full crashes, or,
    if chosen well, cause some faults. Types of parameters include the overclock frequency,
    the number of clock cycles after the trigger to start overclocking, and the number
    of consecutive cycles to overclock. You could additionally play with the high
    and low voltage, rise/fall times, and various other more complicated aspects of
    the clock.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整多个参数来调节故障。根据目标设备的不同，一组参数值要么没有效果，要么导致完全崩溃，或者如果选择得当，会导致一些故障。参数类型包括超频频率、触发后开始超频的时钟周期数，以及连续超频的周期数。你还可以调整高低电压、上升/下降时间以及时钟的其他更复杂的方面。
- en: The pseudocode in [Listing 4-4](#listing4-4) shows how to run repeated experiments
    using different settings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-4](#listing4-4)中的伪代码展示了如何使用不同设置运行重复实验。'
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-4: A Python example designed to vary parameters and view the results'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-4：一个旨在调整参数并查看结果的 Python 示例
- en: You can see the randomized settings of the wait parameter 1, glitch cycles 2,
    and overclock frequency 3. For each fault injection attempt, we capture the actual
    program output 4 before we reset the target 5. This allows us to determine whether
    we have caused any effect. Let’s say we have a target that is running the loop
    test with a factor of one; that is, the counter increases by one every loop iteration.
    We loop the target 65,535 times (hex 0xFFFF), so if anything other than `'FF FF'`
    is returned, a fault has been injected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到等待参数 1、故障周期 2 和超频频率 3 的随机设置。对于每次故障注入尝试，我们会捕获实际的程序输出 4，然后重置目标设备 5。这使得我们可以确定是否引发了任何效应。假设我们的目标设备正在运行带有因子的循环测试；也就是说，每次循环迭代时计数器增加
    1。我们让目标设备循环 65,535 次（十六进制 0xFFFF），所以如果返回的不是 `'FF FF'`，则说明发生了故障注入。
- en: '[Figure 4-7](#figure4-7) shows the sequence of interactions between the PC,
    fault injector, and target for this specific example. You can compare this to
    [Figure 4-4](#figure4-4) to see how some of the configuration for this specific
    example differs from our previous work.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#figure4-7)展示了在此特定示例中，PC、故障注入器和目标设备之间的交互顺序。你可以将其与[图 4-4](#figure4-4)进行比较，看看这个特定示例的配置与我们之前工作的不同之处。'
- en: '![f04007](image_fi/278748c04/f04007.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![f04007](image_fi/278748c04/f04007.png)'
- en: 'Figure 4-7: Sequence of operations between PC, fault injector, and target when
    doing a single fault injection'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7：PC、故障注入器和目标设备在进行单次故障注入时的操作顺序
- en: In [Figure 4-7](#figure4-7), you can see that we now have specified that we
    are going from the *basefreq* to *freq*. These are part of the configuration parameters
    passed to the fault injector tool.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-7](#figure4-7)中，你可以看到我们现在已经指定了从*basefreq*到*freq*的切换。这些是传递给故障注入工具的配置参数的一部分。
- en: '[Figure 4-8](#figure4-8) shows a snapshot of what the signals would look like
    on a logic analyzer, where you can see the target block switching from *basefreq*
    to *freq* and back.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-8](#figure4-8)展示了信号在逻辑分析仪上的快照，在这里你可以看到目标设备的时钟从*basefreq*切换到*freq*，然后再切回。'
- en: In [Figure 4-8](#figure4-8), note that the target clock is running at double
    speed when the fault injector is active. In this example, wait cycles is set to
    2, and glitch cycles is set to 3\. We can see that by counting the number of cycles
    from the rising edge of the trigger signal and the time when the target clock
    increases to *freq*. As we tried more parameters, we would see this sweep through
    various settings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-8](#figure4-8)中，注意到当故障注入器激活时，目标设备的时钟以两倍速运行。在这个示例中，等待周期被设置为 2，故障周期被设置为
    3。通过计算从触发信号的上升沿到目标时钟增加到*freq*的时间，我们可以看到这一变化。随着我们尝试更多参数，我们将看到这在各种设置之间的变化。
- en: '![f04008](image_fi/278748c04/f04008.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![f04008](image_fi/278748c04/f04008.png)'
- en: 'Figure 4-8: Timing of operations between PC, fault injector, and target when
    doing a single fault injection'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8：进行单次故障注入时，PC、故障注入器和目标之间的操作时序
- en: A tricky aspect of being successful is choosing the parameter ranges to start
    with. In the preceding example, if we randomize wait cycles, glitch cycles, and
    frequency, an attacker needs to be lucky to “guess” them all right to result in
    a fault. With a limited number of parameters, this is a viable approach, but with
    more parameters, the search space becomes exponentially larger.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的一个关键方面是选择起始的参数范围。在前面的例子中，如果我们随机化等待周期、故障周期和频率，攻击者需要非常幸运才能“猜测”所有参数正确，从而导致故障。对于参数数量有限的情况，这是一种可行的方法，但随着参数增多，搜索空间会呈指数级增长。
- en: In general, it makes sense to isolate individual parameters and try to determine
    reasonable ranges for those parameters. For instance, injection faults must be
    targeted at the `for` loop in [Listing 4-2](#listing4-2). We can measure this
    loop’s timing by the start and end points of the trigger on the GPIO line, so
    we need to restrict the wait cycles to within the trigger window. For the glitch
    cycles and frequency, we don’t have any clear indication at this point of what
    would work. Starting small and then going larger usually makes sense in order
    to start with a working target, and then we slowly push up the parameters until
    the target device crashes. After that, we search the boundary between “working”
    and “crashing,” hopefully to find exploitable faults. We’ll discuss various strategies
    in the “Search Strategies” section later in the chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，隔离各个参数并尝试确定这些参数的合理范围是有意义的。例如，注入故障必须针对[清单 4-2](#listing4-2)中的`for`循环进行。我们可以通过在GPIO线上的触发的起始和结束点来测量该循环的时序，因此我们需要将等待周期限制在触发窗口内。对于故障周期和频率，目前我们并没有明确的指示表明什么是有效的。从小范围开始然后逐步增大通常是有道理的，这样可以先从一个可行的目标开始，然后逐步提高参数，直到目标设备崩溃。之后，我们在“工作”与“崩溃”之间寻找边界，希望能够发现可利用的故障。我们将在本章稍后的“搜索策略”部分讨论各种策略。
- en: Fault Injection Experiment
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障注入实验
- en: Now, let’s select some parameter ranges to perform an experiment with the clock
    fault injector. We will use a range of one to four glitch cycles for our experiment.
    We chose one cycle as a minimum because it is the smallest setting that may still
    cause a fault, and we chose four cycles as the maximum because, in practice, this
    is still “gentle.” Dozens or even hundreds of consecutive glitch cycles will simply
    crash the target. Similarly, we selected an overclock frequency of 25 MHz to 100
    MHz.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们选择一些参数范围来使用时钟故障注入器进行实验。我们将使用从一个到四个故障周期的范围进行实验。我们选择一个周期作为最小值，因为它是可能仍然引起故障的最小设置，而四个周期作为最大值，因为在实际中，这仍然算是“温和”的。几十个甚至数百个连续的故障周期将直接导致目标崩溃。类似地，我们选择了从
    25 MHz 到 100 MHz 的超频频率。
- en: Next, we run the fault injection program for a while and check the output. If
    no faults occur, we need to make our parameters more aggressive. If only crashes
    occur, we need to make them less aggressive.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行故障注入程序一段时间并检查输出。如果没有故障发生，我们需要使参数更加激进。如果只发生崩溃，我们则需要减小参数的激进度。
- en: Fault Experiment Results
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障实验结果
- en: The results of the first run of faults are shown alongside the test parameters
    in [Table 4-2](#table4-2), including the fault configuration and output sent by
    the target to the PC.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行故障的结果显示在[表 4-2](#table4-2)中，包含故障配置和目标发送到PC的输出。
- en: 'Table 4-2: Results of the First Run of Faults'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2：第一次故障运行结果
- en: '| **ID** | **Wait cycles** | **Glitch cycles** | **Frequency (MHz)** | **Output**
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **等待周期** | **故障周期** | **频率 (MHz)** | **输出** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 561 | 4 | 50 | **FF FE** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 561 | 4 | 50 | **FF FE** |'
- en: '| 1 | 486 | 4 | 75 | **FF FE** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 486 | 4 | 75 | **FF FE** |'
- en: '| 2 | 204 | 3 | 100 | <timeout> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 204 | 3 | 100 | <timeout> |'
- en: '| 3 | 765 | 4 | 75 | **FF FE** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 765 | 4 | 75 | **FF FE** |'
- en: '| 4 | 276 | 4 | 50 | **FF FE** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 276 | 4 | 50 | **FF FE** |'
- en: '| 5 | 219 | 2 | 100 | **FF FE** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 219 | 2 | 100 | **FF FE** |'
- en: '| 6 | 844 | 1 | 25 | FF FF |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 844 | 1 | 25 | FF FF |'
- en: '| 7 | 909 | 3 | 50 | **FF FE** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 909 | 3 | 50 | **FF FE** |'
- en: '| 8 | 795 | 4 | 75 | **FF FE** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 795 | 4 | 75 | **FF FE** |'
- en: '| 9 | 235 | 4 | 100 | <timeout> |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 235 | 4 | 100 | <timeout> |'
- en: '| 10 | 225 | 1 | 25 | FF FF |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 225 | 1 | 25 | FF FF |'
- en: '| 11 | 686 | 1 | 50 | 61 72 62 69 74 72 61 72 79 20 6D 65 6D 6F 72 79 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 686 | 1 | 50 | 61 72 62 69 74 72 61 72 79 20 6D 65 6D 6F 72 79 |'
- en: '| 12 | 66 | 2 | 100 | **FF FE** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 66 | 2 | 100 | **FF FE** |'
- en: '| 13 | 156 | 1 | 75 | **FF FE** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 156 | 1 | 75 | **FF FE** |'
- en: '| 14 | 39 | 2 | 100 | **FF FE** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 39 | 2 | 100 | **FF FE** |'
- en: '| 15 | 755 | 3 | 50 | 61 72 62 69 74 72 61 72 79 20 6D 65 6D 6F 72 79 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 755 | 3 | 50 | 61 72 62 69 74 72 61 72 79 20 6D 65 6D 6F 72 79 |'
- en: '| 16 | 658 | 2 | 50 | 00 EB CD AF 08 8E 00 00 00 01 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 658 | 2 | 50 | 00 EB CD AF 08 8E 00 00 00 01 |'
- en: '| 17 | 727 | 1 | 100 | <timeout> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 727 | 1 | 100 | <timeout> |'
- en: '| 18 | 518 | 3 | 50 | 00 EB CD AF 08 8E 00 00 00 01 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 518 | 3 | 50 | 00 EB CD AF 08 8E 00 00 00 01 |'
- en: The log shows some significant results. First, some attempts return `FF FF`,
    indicating no fault was caused. Other output shows `FF FE`, which is interesting
    because that value is one less than `FF FF` numerically. This means we may have
    induced fault primitive types like “skip a loop” or “turn an addition into a nop.”
    Other values are probably arbitrary data. In practice, we’ve seen that this can
    be arbitrary memory, so it still can be an interesting attack primitive. Getting
    enough snippets of arbitrary memory means that the passwords or firmware contents
    stored in that memory may be leaked. Another result we see is a timeout, which
    indicates that the target has crashed and stopped responding.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示了一些显著的结果。首先，某些尝试返回`FF FF`，表示没有引起故障。其他输出显示`FF FE`，这很有趣，因为该值在数值上比`FF FF`少了
    1。这意味着我们可能引入了像“跳过循环”或“将加法转化为无操作”这样的故障原始类型。其他值可能是任意数据。在实际操作中，我们发现这些可能是任意内存，因此它仍然可能是一个有趣的攻击原始类型。获取足够的任意内存片段意味着存储在该内存中的密码或固件内容可能会泄漏。我们还看到另一个结果是超时，这表示目标崩溃并停止响应。
- en: Analyze the Results
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析结果
- en: Next, we’ll analyze the data and try to narrow the parameter ranges such that
    they are closest to inducing the desired results. The data in [Table 4-2](#table4-2)
    shows that whenever the clock frequency is run at 25 MHz, there are no faults,
    as we consistently get `FF FF` output. At 50 MHz, we start seeing some interesting
    effects where the return is `FF FE`. This same result happens at 50–100 MHz and
    during glitch cycles 1–4\. Closer analysis reveals that 50 MHz also shows various
    corruptions, whereas 100 MHz also indicates timeouts. For 75 MHz and any number
    of glitch cycles, we always get the “skip a loop” primitive fault type that results
    in `FF FE`. The wait cycles at that frequency seemingly have no effect, probably
    because it doesn’t matter where we inject during the loop execution to have the
    desired effect.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分析数据，并尝试缩小参数范围，使其尽可能接近诱导所需结果的条件。[表 4-2](#table4-2)中的数据表明，当时钟频率设为 25 MHz
    时，没有发生故障，因为我们始终得到`FF FF`输出。在 50 MHz 时，我们开始看到一些有趣的效果，返回值为`FF FE`。这个结果在 50–100 MHz
    和故障周期 1–4 时都出现。更仔细的分析显示，50 MHz 也会显示各种数据损坏，而 100 MHz 则表示超时。在 75 MHz 和任何数量的故障周期下，我们总是得到“跳过循环”原始故障类型，结果为`FF
    FE`。在该频率下的等待周期似乎没有任何效果，可能是因为在循环执行过程中注入的地方不影响最终效果。
- en: Retry the Experiment
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重试实验
- en: Now, let’s say we want to investigate the “skip a loop” primitive. Analyzing
    the results suggests doing a secondary experiment to determine the effectiveness
    of a more targeted range of parameters. The successful faults at 75 MHz seem like
    a good place to start. For the wait and glitch cycles, an average of the successful
    results at this frequency seems a reasonable choice of parameter values that causes
    faults. Their averages, respectively, are 550.5 and 3.25\. Needing an integer
    value, we rerun the experiments using {550,551} and {3,4}. However, running tests
    with those parameter ranges results in no faults at all! Something went wrong.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要研究“跳过循环”原始故障。分析结果表明，进行二次实验来确定更有针对性的参数范围的有效性。75 MHz 下成功的故障似乎是一个不错的起点。对于等待和故障周期，选择该频率下成功结果的平均值似乎是一个合理的参数选择，这些参数能够导致故障。它们的平均值分别是
    550.5 和 3.25。由于需要整数值，我们重新运行实验，使用{550,551}和{3,4}。然而，使用这些参数范围运行测试结果没有任何故障！出了点问题。
- en: To try something else, we fix the frequency at 75 MHz but use the original range
    of wait and glitch cycles, as shown in [Table 4-3](#table4-3).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试其他方法，我们将频率固定为 75 MHz，但使用原始的等待和故障周期范围，如[表 4-3](#table4-3)所示。
- en: 'Table 4-3: Examples of Glitch Results, Take Two'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3：故障结果示例，再次尝试
- en: '| **ID** | **Wait cycles** | **Glitch cycles** | **Frequency (MHz)** | **Output**
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **等待周期** | **故障周期** | **频率（MHz）** | **输出** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 155 | 3 | 75 | FF FF |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 155 | 3 | 75 | FF FF |'
- en: '| 1 | 612 | 4 | 75 | **FF FE** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 612 | 4 | 75 | **FF FE** |'
- en: '| 2 | 348 | 1 | 75 | **FF FE** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 348 | 1 | 75 | **FF FE** |'
- en: '| 3 | 992 | 4 | 75 | FF FF |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 992 | 4 | 75 | FF FF |'
- en: '| 4 | 551 | 2 | 75 | FF FF |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 551 | 2 | 75 | FF FF |'
- en: '| 5 | 436 | 3 | 75 | FF FF |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 436 | 3 | 75 | FF FF |'
- en: '| 6 | 763 | 1 | 75 | FF FF |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 763 | 1 | 75 | FF FF |'
- en: '| 7 | 695 | 4 | 75 | FF FF |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 695 | 4 | 75 | FF FF |'
- en: '| 8 | 10 | 4 | 75 | FF FF |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 10 | 4 | 75 | FF FF |'
- en: '| 9 | 48 | 4 | 75 | FF FF |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 48 | 4 | 75 | FF FF |'
- en: '| 10 | 485 | 3 | 75 | FF FF |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 485 | 3 | 75 | FF FF |'
- en: '| 11 | 18 | 2 | 75 | **FF FE** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 18 | 2 | 75 | **FF FE** |'
- en: '| 12 | 512 | 2 | 75 | FF FF |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 512 | 2 | 75 | FF FF |'
- en: '| 13 | 745 | 4 | 75 | FF FF |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 745 | 4 | 75 | FF FF |'
- en: '| 14 | 260 | 3 | 75 | FF FF |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 260 | 3 | 75 | FF FF |'
- en: '| 15 | 802 | 4 | 75 | FF FF |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 802 | 4 | 75 | FF FF |'
- en: '| 16 | 608 | 1 | 75 | FF FF |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 608 | 1 | 75 | FF FF |'
- en: '| 17 | 48 | 3 | 75 | **FF FE** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 48 | 3 | 75 | **FF FE** |'
- en: '| 18 | 900 | 1 | 75 | **FF FE** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 900 | 1 | 75 | **FF FE** |'
- en: The results show a mix of normal operation (`FF FF`) and the faults we’re interested
    in (`FF FE`), so that’s another step in the right direction. Take a moment to
    analyze the results.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了正常操作（`FF FF`）和我们关注的故障（`FF FE`）的混合，因此这是朝正确方向迈出的另一大步。花点时间分析一下结果。
- en: It seems that any number of glitch cycles leads to faults, so that isn’t a reason
    for the faults in the first experimental run. The issue must be the wait cycles.
    Remember, the wait cycles correspond to the number of clock cycles between the
    trigger (the `for` loop start) and the fault attempt. The `for` loop will have
    some sequence of instructions that is repeated. Now, what if only one of the instructions
    in the `for` loop is vulnerable to a fault? What do you expect to see for the
    wait cycles on effective faults?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，任何数量的故障周期都会导致故障，因此这并不是第一次实验中故障发生的原因。问题一定出在等待周期上。记住，等待周期对应的是触发器（`for`循环的开始）和故障尝试之间的时钟周期数。`for`循环会有一些重复执行的指令序列。那么，假设`for`循环中的某一指令易受故障影响，你期待在有效故障发生时看到什么样的等待周期？
- en: 'Here comes the spoiler: most of the wait cycles that result in the `FF FE`
    fault are multiples of three. Perhaps the reason for this similar multiple is
    that the loop takes three cycles to execute, and one particular cycle is vulnerable.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个剧透：导致`FF FE`故障的大多数等待周期是三的倍数。也许这种相似的倍数的原因在于，循环执行需要三周期，而其中某一特定周期容易出故障。
- en: Yet, the number of glitch cycles does not seem to affect the fault. Theoretically,
    this seems odd. We’d expect that by starting one cycle before the vulnerable instruction
    and having a glitch cycle of two, we would hit the vulnerable instruction and
    cause the same fault. We wish we could now go into a beautiful explanation about
    clocks, bits, atoms, impedances, and their relation to tidal cycles, but unfortunately
    the ways of hardware are often mysterious. We regularly see results we can reproduce
    but cannot explain, and you will encounter the same phenomenon. In such cases,
    it is best to simply accept the black magic aspect of fault injection and move
    on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，故障周期的数量似乎并不影响故障。从理论上讲，这看起来很奇怪。我们本以为通过在易受攻击指令前开始一个周期，并且将故障周期设置为两个，我们会击中易受攻击指令并导致相同的故障。我们真希望能为你提供一段关于时钟、位、原子、阻抗以及它们与潮汐周期关系的美妙解释，但不幸的是，硬件的规律往往神秘莫测。我们经常看到可以重现的结果，但却无法解释，而你也会遇到同样的现象。在这种情况下，最好干脆接受故障注入中的“黑魔法”成分，然后继续前进。
- en: The Outcome
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: We’ve been able to establish that we can skip a loop, or turn an increment instruction
    into a nop, if we can hit the right clock cycle. Based on the preceding limited
    experiment, we set the wait cycles to a multiple of three to attack this system.
    This gives us five successes and one failure (ID 9 is divisible by 3, but it didn’t
    lead to a fault), so we can estimate an 83 percent success rate. Not bad!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，如果能够命中正确的时钟周期，我们就能跳过一个循环，或者将增量指令变为无操作（nop）。基于之前的有限实验，我们将等待周期设置为三的倍数来攻击这个系统。这样，我们得到了五次成功和一次失败（ID
    9能被3整除，但没有导致故障），因此我们可以估算出83%的成功率。还不错！
- en: This exercise assumes you have access to the source code in the fault target.
    Even if the source code is available, predicting from that source when a specific
    operation is executing on your target device isn’t trivial. The exercise shows
    that not having exact information about when to execute a fault does not preclude
    you from timing the attack. In a zero-knowledge scenario, you’ll need to search
    more for effective parameters via (online) research and reverse engineering of
    the target program.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习假设你可以访问故障目标中的源代码。即使源代码可用，从中预测特定操作何时在目标设备上执行并非易事。该练习表明，即使没有精确的信息来判断何时执行故障，也并不妨碍你进行攻击时序。在零知识场景下，你需要通过（在线）研究和目标程序的逆向工程来寻找有效的参数。
- en: Keep in mind that often more than one combination of parameters will work, and
    more than one method can create a desired fault. Sometimes you’ll need to tune
    parameters precisely; other times, parameters will exhibit significant tolerance
    to variation. Some parameter values may depend on your hardware (such as sensitivity
    to an electromagnetic pulse), and others may depend on the software running the
    target device (such as a critical instruction’s precise timing).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常有多个参数组合可以起作用，并且多种方法可以产生期望的故障。有时你需要精确调节参数；其他时候，参数对变化表现出显著的容忍度。有些参数值可能取决于你的硬件（例如对电磁脉冲的敏感性），而其他参数可能取决于运行目标设备的软件（例如某个关键指令的精确时序）。
- en: Search Strategies
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索策略
- en: 'No single recipe exists for finding a good set of parameters to use in experiments.
    The previous example provides some hints on to how to approach parameter selection.
    That example is already a high-dimensional parameter optimization problem. Adding
    more parameters only increases the search space exponentially. The strategy of
    randomizing parameters will be quite ineffective, unless your goal is to grow
    old real fast. This is especially true if a single fault isn’t sufficient to induce
    the desired result. Some fault injection countermeasures include repeating sensitive
    computations twice and then comparing the results. For instance, a program could
    check a password twice, which means you need to fault the target a second time,
    in the same way, to bypass detection (or you need to inject a fault in the target
    operation and then try to fault the detection mechanism). Note that this introduces
    new parameters: the delay between the multiple faults, as well as parameters for
    those individual faults.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个固定的方案可以用来为实验选择一组合适的参数。前面的示例为如何选择参数提供了一些提示。那个示例已经是一个高维参数优化问题，增加更多的参数只会使搜索空间呈指数级增长。随机化参数的策略是相当无效的，除非你的目标是快速衰老。特别是当一个故障不足以引发期望的结果时，这一点尤其适用。一些故障注入对策包括重复敏感的计算两次，并比较结果。例如，程序可以检查密码两次，这意味着你需要第二次以相同的方式对目标进行故障注入，才能绕过检测（或者你需要在目标操作中注入故障，然后尝试故障检测机制）。注意，这引入了新的参数：多个故障之间的延迟，以及每个故障的参数。
- en: A few general strategies exist that you can use to optimize the parameters with
    which you choose to experiment, such as random or interval stepping, nesting,
    progressing from small to big (or vice versa), trying a divide-and-conquer approach,
    attempting a more intelligent search, or, if all else fails, exercising patience.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些通用策略，你可以用来优化你选择实验的参数，比如随机或区间步进、嵌套、从小到大（或反过来）、尝试分而治之的方式、进行更智能的搜索，或者，如果一切都失败了，耐心等待。
- en: Random or Interval Stepping
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机或区间步进
- en: One decision when choosing parameters values is whether to randomize values
    for each attempt or step through intervals in a particular range. Often, when
    you start testing, you’ll use random values for multiple parameters to sample
    a large variety of parameter combinations. Trying each cycle by stepping through
    each value for wait cycles within a range is useful if you’ve already established
    other parameter values and you want to pinpoint the exact clock cycles that are
    fault sensitive.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选择参数值时的一个决定是：是为每次尝试随机化值，还是在特定范围内逐步通过区间。有时，在你开始测试时，会为多个参数使用随机值来采样各种参数组合。如果你已经确定了其他参数值，并且想要精准定位出故障敏感的时钟周期，那么逐步测试每个等待周期范围内的每个值是非常有用的。
- en: Nesting
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套
- en: If you want to try all values for some parameters exhaustively, you can nest
    them. For instance, you can interval-step over all wait cycle values and then
    try four different clock frequencies for each wait cycle value. This approach
    works for fine-tuning over small ranges, but once the ranges are bigger, nesting
    quickly leads to an explosion of the number of combinations you need to test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要穷举地尝试某些参数的所有值，你可以将它们嵌套。例如，你可以在所有等待周期值上进行区间步进，然后为每个等待周期值尝试四种不同的时钟频率。这种方法适用于在小范围内的微调，但一旦范围增大，嵌套会迅速导致需要测试的组合数量爆炸。
- en: Without any prior knowledge, you may arbitrarily choose which parameter to sweep
    first and which to sweep next. This is called the *nesting order*. In the preceding
    example, we also could have tried all wait cycles for a fixed clock frequency
    first and only afterward tried all wait cycles for the next clock frequency. You
    can extend this idea to an arbitrary number of parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何先验知识的情况下，你可能会随意选择先扫哪个参数，后扫哪个参数。这叫做*嵌套顺序*。在前面的例子中，我们也可以先尝试所有固定时钟频率下的等待周期，然后再尝试下一个时钟频率下的所有等待周期。你可以将这个思路扩展到任意数量的参数。
- en: You may accidently make your life more complicated—for instance, if the target
    you are working with is very sensitive to a particular wait cycle value but will
    fault at just about any frequency. In this case, you would be better sweeping
    wait cycles first and then changing the frequency. You can often derive this type
    of information from an initial sweep using randomized parameter value selection.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会不小心让自己的工作变得更复杂——例如，如果你正在处理的目标对某个特定的等待周期值非常敏感，但几乎在任何频率下都会发生故障。在这种情况下，你最好先扫一遍等待周期，然后再改变频率。通常，你可以通过使用随机化参数值选择进行初步扫描，从而获得这种类型的信息。
- en: Small to Big
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 小到大
- en: With this strategy, you start setting all parameters to small values, usually
    when you don’t want to destroy the target. These parameters can be a short time,
    low pulse intensity, or small voltage differential. You then slowly increase the
    range of parameter values. This is a safe method in the sense that some faults
    can have dramatic consequences on your target, such as when laser power is ramped
    up from just a sparkle to a full-on puff of blue smoke.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种策略下，你首先将所有参数设置为小值，通常是在你不想破坏目标时。这些参数可以是短时间、低脉冲强度或小电压差异。然后，你逐步增加参数值的范围。从某种意义上讲，这是一种安全的方法，因为某些故障可能会对目标产生剧烈后果，例如当激光功率从仅仅是一点火花提升到完全爆发成蓝色烟雾。
- en: Big to Small
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大到小
- en: The small-to-big method can be frustrating because it may require patience to
    produce any faults. Sometimes initially turning up the volume to 11 on some parameter
    values and then reducing them slowly is more effective. The risk with using this
    method is potentially destroying the target.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 小到大方法可能令人沮丧，因为它可能需要耐心才能产生故障。有时，先将某些参数值的音量调到11，然后再慢慢减少它们，可能更有效。使用这种方法的风险是可能会破坏目标。
- en: For fault injection methods that aren’t destructive, this technique is valuable
    during initial setup. If you are performing voltage glitching by simply cutting
    power out, for example, you may find it useful to prove you can cause device resets
    to confirm your fault injection circuitry is working correctly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非破坏性故障注入方法，这种技术在初始设置阶段非常有价值。例如，如果你通过简单切断电源来执行电压故障注入，你可能会发现证明可以引发设备重启，以确认你的故障注入电路工作正常。
- en: Divide and Conquer
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分而治之
- en: Some parameters are independent of other parameters, while some have impacts
    and dependencies on other parameters. If some parameters are independent, try
    to identify them and optimize them individually for effectiveness.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数是独立于其他参数的，而有些则对其他参数有影响和依赖关系。如果某些参数是独立的，尝试识别它们并单独优化，以提高效果。
- en: For example, it’s plausible that the pulse power for an EM fault is independent
    of the timing of a critical program instruction. The pulse power depends on hardware
    aspects, and the timing depends on the program running on the chip. One strategy
    is to randomize the fault timing and slowly increase EM power until you start
    seeing crashes or corruptions. At that point, you have a ballpark for the EM power
    parameter that produces a result. Next, you leave the EM power at that level and
    then step through the program’s instruction timing in the hope of discovering
    an instant that gives rise to a useful fault.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，脉冲功率对于电磁（EM）故障来说，很可能与关键程序指令的时序无关。脉冲功率取决于硬件因素，而时序则取决于芯片上运行的程序。一种策略是随机化故障时序，并逐步增加电磁功率，直到开始出现崩溃或数据损坏。在那个时刻，你大致可以确定产生结果的电磁功率参数。接下来，保持电磁功率在该水平，并逐步调整程序指令时序，期望发现某一时刻能够引发有用的故障。
- en: Other parameters may only seem independent. For instance, a voltage glitch may
    need to be stronger in some parts of the program than in others. Some stages in
    a program may draw different power levels than other stages and require a different
    voltage glitch. If you get stuck finding good parameters, try optimizing some
    other parameter pairs in tandem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数可能看起来是独立的。例如，某些程序部分可能需要更强的电压故障，而其他部分则不需要。程序中的某些阶段可能比其他阶段消耗不同的功率水平，因此需要不同的电压故障。如果你在寻找良好的参数时遇到困难，尝试同步优化其他参数对。
- en: The x- and y-coordinates of the spatial location on which you’re injecting an
    EM pulse are most certainly in tandem. The clock speed and voltage glitch depth
    are likely in tandem as well. If you try to optimize those probably paired parameters
    separately, you may end up missing good fault opportunities.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你注入电磁脉冲的空间位置的x和y坐标很可能是成对的。时钟速度和电压故障深度也很可能是成对的。如果你试图分别优化这些可能成对的参数，可能会错过一些好的故障机会。
- en: Intelligent Search
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 智能搜索
- en: For some parameters, you can apply more logic than just randomizing or stepping
    when optimizing them. *Hill-climbing algorithms* start with a certain set of parameters
    and then create small changes in those parameters to see whether the performance
    (the faulting success rate) improves.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些参数，在优化时你可以应用比随机化或步进更复杂的逻辑。*爬山算法*从一组特定的参数开始，然后对这些参数进行小幅度变化，以查看性能（故障成功率）是否改善。
- en: 'For instance, if you’re on a sensitive spot on a die, you can use a hill-climbing
    algorithm to optimize the location in this way: inject a few faults around that
    spot and move in the direction where the fault success rate increases. Continue
    doing this until no more neighboring spots have increased success rates. At that
    point, you’ve found a local maximum. In principle, you can apply this technique
    to all parameters when you observe smooth changes in the success rate with small
    changes in those parameters. This technique completely fails when such smooth
    changes are not present, so buyer beware.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你处在一个骰子的敏感位置，你可以使用爬山算法通过以下方式优化位置：在该位置周围注入一些故障，并朝着故障成功率增加的方向移动。继续这样做，直到没有更多相邻位置的成功率增加。此时，你已经找到了局部最大值。原则上，当你观察到成功率随着参数的小变化而平滑变化时，可以将此技术应用于所有参数。当没有这样的平滑变化时，这种技术完全失败，因此购买者需要小心。
- en: Exercising Patience
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保持耐心
- en: Having more patience for an experiment to complete is not very efficient, but
    sometimes it’s the most effective thing you can do. Finding that one combination
    of parameters that induces a fault can be difficult. Don’t give up too easily.
    Once you’ve exhausted being smart about parameter searching in the lab, you can
    easily let the experiment run for weeks to search for lucky parameter combinations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对实验保持更长时间的耐心虽然效率不高，但有时却是你能做的最有效的事情。找到能够引发故障的那一组参数组合可能很困难。不要轻易放弃。一旦你在实验室里关于参数搜索的聪明方法用尽，你可以让实验运行几周，等待幸运的参数组合出现。
- en: Analyzing Results
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析结果
- en: How do you interpret all your results? One useful method is simply to present
    the results visually. Sort the results table by a parameter you’re investigating
    and color-code each row according to the result measured. Noticing clustering
    will help you determine sensitive parameters. Making the sort interactive lets
    you easily drill down to effective sets of parameters. See the results in [Figure
    4-9](#figure4-9), which will be colored green, yellow, and red in the actual software.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解读所有结果？一种有用的方法是简单地将结果以可视化方式呈现。按你正在调查的参数对结果表格进行排序，并根据测量的结果为每一行上色。注意聚类现象将帮助你确定敏感参数。让排序变得互动性强，可以让你轻松地深入分析有效的参数集。请参见[图
    4-9](#figure4-9)，在实际软件中，结果将被着色为绿色、黄色和红色。
- en: In [Figure 4-9](#figure4-9), green lines (gray in the figure) show normal results,
    yellow lines (light gray in the figure) indicate resets, and red lines (dark gray
    in the figure) highlight invalid or unexpected responses resulting from faults.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-9](#figure4-9)中，绿色线条（图中为灰色）表示正常结果，黄色线条（图中为浅灰色）表示重置，红色线条（图中为深灰色）突出显示由故障引起的无效或意外响应。
- en: '![f04009](image_fi/278748c04/f04009.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![f04009](image_fi/278748c04/f04009.png)'
- en: 'Figure 4-9: Color-coded results in Riscure’s Inspector software'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-9：Riscure Inspector 软件中的颜色编码结果
- en: For effective faults, determining the min/max/mode values for each parameter
    can be useful. Note that the statistical “mode” calculation yields more reliable
    results than the “average” statistical calculation, because the average could
    point to a parameter value that doesn’t cause faults. A good way to identify parameter
    values is to visualize the results on an x-y scatterplot, where two different
    parameter variables are plotted along the two axes (see [Figure 4-10](#figure4-10)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有效的故障，确定每个参数的最小值/最大值/众数值可能是有用的。请注意，统计学中的“众数”计算比“平均值”统计计算提供更可靠的结果，因为平均值可能会指向一个不会导致故障的参数值。识别参数值的一个好方法是通过
    x-y 散点图可视化结果，其中两个不同的参数变量分别沿两个坐标轴绘制（见[图 4-10](#figure4-10)）。
- en: '![f04010](image_fi/278748c04/f04010.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![f04010](image_fi/278748c04/f04010.png)'
- en: 'Figure 4-10: An x-y plot of the glitch results, with significant faults plotted
    with an X'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-10：故障结果的 x-y 绘图，重大故障用 X 标出
- en: Data points generated by parameters that actually caused significant faults
    are plotted as an X. You can see their clustering between the reset/crash data
    points plotted in a top-left lighter shade (yellow in the original software) and
    the bottom-right darker points (green in the original software) that represent
    correct program behavior.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由实际导致重大故障的参数生成的数据点以 X 标出。你可以看到它们在重置/崩溃数据点之间聚集，这些数据点绘制在左上角的浅色阴影区域（原软件中的黄色），而右下角的深色点（原软件中的绿色）则代表正确的程序行为。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we described the basics of faults—why you would fault in the
    first place and how to analyze a program for fault injection opportunities. We
    then discussed how performing this analysis perfectly is impossible, because the
    fault primitives depend on the device to test, and also because fault injections
    are imprecise. Fault injection is a stochastic process in practice. We also explored
    the components involved in building a fault injector, provided a sample clock
    fault experiment, and discussed several search strategies for fault parameters.
    The next chapter will fill in the missing pieces: building actual fault injectors
    for voltage, clock, and EM fault injection.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了故障的基础知识——为什么会发生故障，以及如何分析程序以寻找故障注入的机会。接着我们讨论了为什么完美地执行这种分析是不可能的，因为故障原语依赖于待测设备，而且故障注入是不精确的。故障注入在实践中是一个随机过程。我们还探讨了构建故障注入器所涉及的组件，提供了一个时钟故障实验示例，并讨论了几种故障参数的搜索策略。下一章将填补缺失的部分：为电压、时钟和电磁故障注入构建实际的故障注入器。
