- en: '**8 Fractals**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8 分形**'
- en: '*“Pathological monsters!” cried the terrified mathematician Every one of them
    a splinter in my eye I hate the Peano Space and the Koch Curve I fear the Cantor
    Ternary Set The Sierpiński Gasket makes me wanna cry And a million miles away
    a butterfly flapped its wings On a cold November day a man named Benoit Mandelbrot
    was born*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*“病态的怪物！”害怕的数学家喊道 每一个都是我眼中的刺 我讨厌皮亚诺空间和科赫曲线 我害怕康托尔三元集 谢尔宾斯基垫片让我想哭 而在百万英里外，一只蝴蝶扇动了翅膀
    在一个寒冷的十一月的日子里，一个叫Benoit Mandelbrot的男人出生了*'
- en: —Jonathan Coulton, lyrics from “Mandelbrot Set”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —Jonathan Coulton，歌曲《Mandelbrot Set》的歌词
- en: '![Image](../images/pg437_Image_674.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg437_Image_674.jpg)'
- en: '**Chakri Maha Prasat Hall, Bangkok, Thailand (photo by Saad Akhtar)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**查克里·玛哈·普拉萨德大厅，泰国曼谷（摄影：Saad Akhtar）**'
- en: The Chakri Maha Prasat Hall, located within the Grand Palace in the heart of
    Bangkok, Thailand, is an architectural feat known for its intricate details and
    grandeur. Each level of the multilayered roof echoes a smaller or larger version
    of itself and represents the different levels of Mount Meru, the center of the
    Buddhist universe.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 查克里·玛哈·普拉萨德大厅位于泰国曼谷市中心的大皇宫内，是一座因其复杂细节和宏伟而闻名的建筑杰作。每一层多层屋顶都反映出自己更小或更大的版本，代表着佛教宇宙中心的梅鲁山的不同层次。
- en: Once upon a time, I took a course in high school called Geometry. Perhaps you
    took such a course too, where you learned about classic shapes in one, two, and
    maybe even three dimensions. What’s the circumference of a circle? The area of
    a rectangle? The distance between a point and a line? This sort of geometry is
    generally referred to as **Euclidean geometry**, after the Greek mathematician
    Euclid, and come to think of it, it’s a subject I’ve been covering all along in
    this book. Whenever I used vectors to describe the motion of bodies in Cartesian
    space, that was Euclidean geometry.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，我在高中上过一门叫做几何学的课，也许你也上过这样的课，学习了一维、二维甚至三维的经典形状。圆的周长是多少？矩形的面积呢？点与直线之间的距离是多少？这种几何学通常被称为**欧几里得几何**，以希腊数学家欧几里得命名，想一想，这也是我在本书中一直在讲的内容。每当我用向量描述笛卡尔空间中物体的运动时，那就是欧几里得几何。
- en: For us nature coders, however, I would ask, Can our world *really* be described
    with Euclidean geometry? The laptop screen I’m staring at right now sure looks
    like a rectangle. And the plum I ate this morning was spherical. But what if I
    were to look further and consider the trees that line the street, the leaves that
    hang off those trees, the lightning from last night’s thunderstorm, the cauliflower
    I ate for dinner, the blood vessels in my body, and the mountains and coastlines
    that define a landscape? As [Figure 8.1](ch08.xhtml#ch8fig1) shows, most of the
    stuff you find in nature looks quite different from the idealized geometrical
    forms of Euclidean geometry.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们这些自然编码者，我想问一下，我们的世界*真的*能用欧几里得几何来描述吗？我现在盯着的笔记本屏幕看起来确实是一个矩形。而我今天早上吃的李子是球形的。但如果我进一步观察，考虑街道旁的树木、树上挂着的叶子、昨晚雷暴中的闪电、我晚餐吃的花椰菜、我身体中的血管，以及定义地貌的山脉和海岸线呢？正如[图
    8.1](ch08.xhtml#ch8fig1)所示，许多自然界中的事物与欧几里得几何的理想化几何形态相差甚远。
- en: '![Image](../images/pg438_Image_675.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_675.jpg)'
- en: 'Figure 8.1: Comparing idealized Euclidean geometry to shapes found in nature'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：将理想化的欧几里得几何与自然界中的形态进行比较
- en: 'If you want to start building computational designs with patterns that move
    beyond basic shapes like `circle()`, `square()`, and `line()`, it’s time to learn
    about a different kind of geometry, the *geometry of nature*: fractals. This chapter
    explores the concepts behind fractals as well as programming techniques for simulating
    fractal geometry.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想开始构建具有超越基本形状（如`circle()`、`square()`和`line()`）的计算设计，是时候了解一种不同的几何学了，即*自然的几何学*：分形。本章探讨了分形背后的概念以及模拟分形几何的编程技巧。
- en: '**What Is a Fractal?**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是分形？**'
- en: The term **fractal** (from the Latin *fractus*, meaning “broken”) was coined
    by the mathematician Benoit Mandelbrot in 1975\. In his seminal work *The Fractal
    Geometry of Nature*, he defines a fractal as “a rough or fragmented geometric
    shape that can be split into parts, each of which is (at least approximately)
    a reduced-size copy of the whole.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**分形**（来自拉丁语*fractus*，意为“破碎”）这一术语是由数学家Benoit Mandelbrot于1975年创造的。在他的开创性著作《自然的分形几何》中，他将分形定义为“一个粗糙或碎片化的几何形状，可以被分割成多个部分，每个部分（至少大致上）是整体的一个缩小版。”'
- en: I’ll illustrate this definition with two simple examples. First, think about
    the branching structure of a tree, as shown in [Figure 8.2](ch08.xhtml#ch8fig2).
    (In [Example 8.6](ch08.xhtml#ch8ex6), I’ll show you how to write the code to draw
    this tree.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用两个简单的例子来说明这个定义。首先，想想树的分支结构，如[图 8.2](ch08.xhtml#ch8fig2)所示。（在[示例 8.6](ch08.xhtml#ch8ex6)中，我将展示如何编写代码来绘制这棵树。）
- en: '![Image](../images/pg439_Image_676.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg439_Image_676.jpg)'
- en: 'Figure 8.2: A branching fractal tree'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：一棵分支的分形树
- en: Notice that the tree has a single trunk with branches connected at its end.
    Each one of those branches has branches at its end, and those branches have branches,
    and so on. And what if you were to pluck one branch from the tree and examine
    it more closely on its own, as in [Figure 8.3](ch08.xhtml#ch8fig3)?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这棵树有一个主干，末端连接着分支。每一根分支的末端都有新的分支，而这些分支又有分支，依此类推。如果你从树上摘下一根分支，并单独仔细观察它，就像在[图
    8.3](ch08.xhtml#ch8fig3)中展示的那样，会怎样呢？
- en: '![Image](../images/pg439_Image_677.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg439_Image_677.jpg)'
- en: 'Figure 8.3: Zooming in on one branch of the fractal tree'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：放大分形树的一根分支
- en: The zoomed-in branch is an exact replica of the whole, just as Mandelbrot describes.
    Not all fractals have to be perfectly self-similar like this tree, however. For
    example, take a look at [Figure 8.4](ch08.xhtml#ch8fig4), which shows two illustrations
    of the coastline of Greenland (or Kalaallit Nunaat in the indigenous Kalaallisut
    language).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 放大的分支是整体的精确复制品，就像曼德尔布罗特所描述的那样。然而，并不是所有的分形都必须像这棵树一样完全自相似。例如，看看[图 8.4](ch08.xhtml#ch8fig4)，其中展示了格林兰岛（或在本土Kalaallisut语言中称为Kalaallit
    Nunaat）海岸线的两幅插图。
- en: '![Image](../images/pg440_Image_678.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg440_Image_678.jpg)'
- en: 'Figure 8.4: Two coastlines'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：两条海岸线
- en: The absence of a scale in these illustrations is no accident. Am I showing the
    entire coastline or just a small portion of it? There’s no way for you to know
    without a scale reference because coastlines, as fractals, look essentially the
    same at any scale. (Incidentally, coastline B shows an approximately 3× magnified
    view of a specific section of coastline A. I’ve added the scales in [Figure 8.5](ch08.xhtml#ch8fig5).)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插图中缺少比例尺并非偶然。我展示的是整个海岸线还是它的一小部分？没有比例尺参照，你无法知道，因为作为分形，海岸线在任何尺度下看起来本质上都是一样的。（顺便提一下，海岸线
    B 展示了海岸线 A 的一个特定部分的约 3 倍放大视图。我已在[图 8.5](ch08.xhtml#ch8fig5)中添加了比例尺。）
- en: '![Image](../images/pg440_Image_679.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg440_Image_679.jpg)'
- en: 'Figure 8.5: Two coastlines, with scale'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：两条海岸线，带有比例尺
- en: A coastline is an example of a **stochastic** fractal, meaning it’s built out
    of probabilities and randomness. Unlike the **deterministic** (or predictable)
    tree-branching structure, a stochastic fractal is *statistically* self-similar.
    This means that even if a pattern isn’t precisely the same at every size, the
    general quality of the shape and its overall feel stay the same no matter how
    much you zoom in or out. The examples in this chapter explore both deterministic
    and stochastic techniques for generating fractal patterns.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 海岸线是一个**随机**分形的例子，这意味着它是由概率和随机性构建的。与**确定性**（或可预测）树状分支结构不同，随机分形是*统计上*自相似的。这意味着，即使一个模式在每个尺度上不是完全相同，形状的总体特征和感觉在你放大或缩小时依然保持不变。本章中的示例探讨了生成分形图案的确定性和随机技术。
- en: 'While self-similarity is a key trait of fractals, it’s important to realize
    that self-similarity alone doesn’t make a fractal. After all, a straight line
    is self-similar: it looks the same at any scale and can be thought of as comprising
    lots of little lines. But a straight line isn’t a fractal. Fractals are characterized
    by having a fine structure at small scales (keep zooming in on the coastline and
    you’ll continue to find fluctuations) and can’t be described with Euclidean geometry.
    As a rule, if you can say “It’s a line!” then it’s not a fractal.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自相似性是分形的一个关键特征，但重要的是要意识到，仅凭自相似性并不能定义一个分形。毕竟，直线也是自相似的：它在任何尺度下看起来都一样，并且可以被认为由很多小直线组成。但直线并不是分形。分形的特点是，在小尺度下有精细的结构（继续放大海岸线，你会发现不断变化的波动），并且无法用欧几里得几何来描述。通常，如果你能说“那是条线！”那么它就不是分形。
- en: '![Image](../images/zoom.jpg) **The Mandelbrot Set**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **曼德尔布罗特集**'
- en: One of the most well-known and recognizable fractal patterns is named for Mandelbrot
    himself. Generating the **Mandelbrot set** involves testing the properties of
    complex numbers after they’re passed through an iterative function. Do they tend
    to infinity? Do they stay bounded?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名且最具辨识度的分形图案之一，以**曼德尔布罗特**命名。生成**曼德尔布罗特集合**涉及在将复杂数通过迭代函数后，测试其特性。它们是否趋向于无穷大？它们是否保持在某个范围内？
- en: While a fascinating mathematical discussion, this escape-time algorithm is a
    less practical method for generating fractals than the recursive techniques we’ll
    examine in this chapter. However, code for generating the Mandelbrot set is included
    in the online examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个引人入胜的数学讨论，但这种逃逸时间算法生成分形的方式，比我们在本章中将要探讨的递归技术更不实用。然而，生成曼德尔布罗特集合的代码已包含在在线示例中。
- en: '![Image](../images/pg441_Image_680.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg441_Image_680.jpg)'
- en: Fractals have a long history predating Mandelbrot’s 1975 book, appearing in
    various forms across cultures. They’re virtually as old as nature itself. Indigenous
    and ancient societies often incorporated fractal patterns into their art, architecture,
    and textiles, long before the formal study of fractals in Western mathematics.
    For example, the traditional Ba-ila village layouts of Zambia and the intricate
    geometric patterns in Islamic architecture both exhibit fractal properties. These
    patterns highlight the significance of fractals in diverse cultural contexts and
    their timeless appeal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 分形有着比曼德尔布罗特1975年出版的书籍更悠久的历史，早在各种文化中就以不同形式出现。它们几乎和自然本身一样古老。许多土著和古代社会早在西方数学正式研究分形之前，就已经将分形图案融入到他们的艺术、建筑和纺织品中。例如，赞比亚传统的巴伊拉村布局和伊斯兰建筑中的复杂几何图案，都展现了分形的特性。这些图案突显了分形在不同文化背景下的重要性以及它们的永恒魅力。
- en: '**Recursion**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**递归**'
- en: 'Beyond self-similarity, another fundamental component of fractal geometry is
    **recursion**: the process of repeatedly applying a rule, known as a **production
    rule**, indicating that the outcome of one iteration becomes the starting point
    for the next. Recursion has been in the picture since the first appearance of
    fractals in modern mathematics, when German mathematician Georg Cantor developed
    simple rules for generating an infinite set of numbers in 1883\. Cantor’s production
    rules are illustrated in [Figure 8.6](ch08.xhtml#ch8fig6).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自相似性，分形几何学的另一个基本组成部分是**递归**：反复应用一个规则的过程，称为**生成规则**，即每一次迭代的结果成为下一次迭代的起点。自从分形在现代数学中首次出现以来，递归就一直是其中的核心概念。当时，德国数学家乔治·康托尔在1883年提出了生成无限集合的简单规则。康托尔的生成规则在[图8.6](ch08.xhtml#ch8fig6)中进行了说明。
- en: '![Image](../images/pg442_Image_681.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg442_Image_681.jpg)'
- en: 'Figure 8.6: Recursive instructions for generating the Cantor set fractal'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：生成康托尔集合分形的递归指令
- en: 'A feedback loop is at work in Cantor’s rules. Take a single line and break
    it into two. Then return to those two lines and apply the same rule, breaking
    each line into two. Now you have four. Return to those four lines and apply the
    rule. Now you have eight. And so on. That’s how recursion works: the output of
    a process is fed back into the process itself, over and over again. In this case,
    the result is known as the **Cantor set**. Like the fractal tree in [Figure 8.3](ch08.xhtml#ch8fig3),
    it’s an example of a deterministic, entirely predictable fractal, in which each
    part is a precise replica of the whole.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在康托尔的规则中，存在一个反馈循环。取一条线，将其分成两段。然后回到这两条线，应用相同的规则，每条线再分成两段。现在你有了四条线。再回到这四条线，应用规则。现在你有了八条。以此类推。这就是递归的工作方式：一个过程的输出再次输入到该过程本身，反复进行。在这种情况下，结果被称为**康托尔集合**。就像[图8.3](ch08.xhtml#ch8fig3)中的分形树一样，它是一个确定性的、完全可预测的分形，其中每一部分都是整体的精确复制品。
- en: Cantor was interested in what happens when you apply a recursive set of rules
    an infinite number of times. You and I don’t have infinite time on our hands,
    however. Also, a p5.js sketch is limited to a finite pixel space, so at some point
    it becomes impossible to draw increasingly smaller lines. As such, for the purposes
    of this book, I’ll mostly ignore the questions and paradoxes that arise from infinite
    recursion. Instead, the code will be constructed in such a way that the rules
    aren’t applied “forever” (resulting in an infinite loop and a frozen computer)
    but instead stop when a certain condition is met.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Cantor对应用递归规则集进行无限次迭代后的结果非常感兴趣。然而，你我并没有无限的时间。另外，p5.js草图的像素空间是有限的，因此最终绘制越来越小的线条变得不可能。因此，在本书中，我将主要忽略由无限递归引发的问题和悖论。相反，代码将以某种方式构建，使得规则不是“永远”应用（导致无限循环和电脑死机），而是在满足某个条件时停止。
- en: '**Implementing Recursive Functions**'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**实现递归函数**'
- en: 'In a moment, I’ll write a sketch that recursively implements the Cantor set.
    But first, what does it mean to have recursion in code? It all boils down to calling
    a function from inside a function. This, in and of itself, isn’t anything new.
    After all, you probably call functions from inside other functions all the time.
    For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一会儿我会写一个草图，递归实现Cantor集。但首先，代码中的递归是什么意思？归根结底，就是在一个函数内部调用另一个函数。这本身并不新鲜。毕竟，你可能经常在函数内部调用其他函数。例如：
- en: '![Image](../images/pg442_Image_682.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg442_Image_682.jpg)'
- en: 'Here’s the key difference with recursion: What would happen if you called the
    function you’re defining within that function itself? Can `someFunction()` call
    `someFunction()`?'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是递归的关键区别：如果你在定义的函数内部调用这个函数会发生什么？`someFunction()`能否调用`someFunction()`？
- en: '![Image](../images/pg443_Image_683.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg443_Image_683.jpg)'
- en: Not only is this allowed, but it’s quite encouraged! In fact, it’s essential
    to the way I’ll implement the Cantor set. Functions that call themselves are known
    as **recursive functions**, and they’re well suited for solving certain problems.
    For example, some mathematical calculations are implemented recursively; the most
    well-known example is the **factorial**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅被允许，实际上还被鼓励！事实上，这对于我实现Cantor集的方式至关重要。调用自身的函数被称为**递归函数**，它们非常适合解决某些问题。例如，一些数学计算是递归实现的；最著名的例子就是**阶乘**。
- en: 'The factorial of any number *n*, usually written as *n*!, is defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字 *n* 的阶乘，通常写作 *n*!，定义如下：
- en: '*n*! = *n* × (*n* − 1) × . . . × 3 × 2 × 1'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*! = *n* × (*n* − 1) × . . . × 3 × 2 × 1'
- en: 0! = 1
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 0! = 1
- en: 'Here’s a nonrecursive function in JavaScript that uses a `for` loop to calculate
    the factorial of a number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`for`循环来计算阶乘的JavaScript非递归函数：
- en: '![Image](../images/pg443_Image_684.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg443_Image_684.jpg)'
- en: 'Upon close examination, you’ll notice something interesting about the way factorials
    work. Think about how 4! and 3! are defined:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会发现阶乘的运作方式很有趣。想一想4!和3!是如何定义的：
- en: 4! = 4 × 3 × 2 × 1
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 4! = 4 × 3 × 2 × 1
- en: 3! = 3 × 2 × 1
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 3! = 3 × 2 × 1
- en: 'The entire definition of 3! is contained within the definition of 4!:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 3! 的整个定义包含在 4! 的定义中：
- en: 4! = 4 × 3!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 4! = 4 × 3!
- en: 'In more general terms, for any positive integer *n*, the following is true:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，对于任何正整数 *n*，以下公式成立：
- en: '*n*! = *n* × (*n* − 1)!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*! = *n* × (*n* − 1)!'
- en: 0! = 1
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 0! = 1
- en: Writing this out, I can say that the *factorial* of *n* is defined as *n* times
    the *factorial* of *n* – 1.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 写下来，我可以说 *n* 的阶乘定义为 *n* 乘以 *n* - 1 的阶乘。
- en: 'The definition of *factorial* includes *factorial*? That’s kind of like defining
    *pizza* as “a delicious meal that includes slices of pizza.” While this definition
    of pizza is admittedly nonsensical, it highlights the concept of self-reference
    in a definition, the essence of recursion. When applied to a function definition
    in code, it can lead to remarkably elegant solutions, such as this recursive definition
    of a `factorial()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*阶乘*的定义中包括了*阶乘*？这有点像将*比萨*定义为“包含比萨片的美味餐点”。虽然这种比萨的定义显然是荒谬的，但它突出了定义中的自引用概念，这正是递归的本质。当这种自引用应用到代码中的函数定义时，它能产生非常优雅的解决方案，比如这个递归定义的`factorial()`函数：'
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `factorial()` function calls itself within its own definition. It may look
    a bit odd at first, but it works, as long as a stopping condition exists (in this
    case, `n <= 1`) so the function doesn’t get stuck calling itself forever. (I’m
    using `<=` instead of `===` as a safeguard against infinite recursion, but I should
    probably include additional error checking to manage noninteger or negative inputs
    to be more mathematically accurate.) [Figure 8.7](ch08.xhtml#ch8fig7) illustrates
    the steps that unfold when `factorial(4)` is called.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial()`函数在其自身的定义中调用自己。起初看起来有些奇怪，但只要存在停止条件（在此例中为`n <= 1`），它就能工作，避免了无限递归（我使用`<=`而非`===`作为防止无限递归的保护措施，不过我应该增加额外的错误检查来处理非整数或负数输入，这样可以更符合数学上的准确性。）[图8.7](ch08.xhtml#ch8fig7)展示了当调用`factorial(4)`时所展开的步骤。'
- en: '![Image](../images/pg444_Image_685.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg444_Image_685.jpg)'
- en: 'Figure 8.7: Visualizing the process of calling the recursive `factorial()`
    function'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：可视化调用递归`factorial()`函数的过程
- en: The function keeps calling itself, descending deeper and deeper down a rabbit
    hole of nested function calls until it reaches the stopping condition. Then it
    works its way up out of the hole, returning values until it arrives back home
    at the original call of `factorial(4)`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不断递归调用自身，深入嵌套的函数调用的“兔子洞”，直到达到停止条件。然后它开始从洞中向上回溯，返回值，直到回到最初的`factorial(4)`调用处。
- en: You can apply the same recursive principle illustrated by the `factorial()`
    function to graphics in a canvas, only instead of returning values, you draw shapes.
    This is precisely what you’ll see in the examples throughout this chapter. To
    begin, here’s a simple recursive function that draws increasingly smaller circles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`factorial()`函数中所示的递归原理应用到画布中的图形上，只不过这次不是返回值，而是绘制图形。这正是本章例子所展示的。首先，这里有一个简单的递归函数，用来绘制逐渐变小的圆形。
- en: '![Image](../images/pg445_Image_686.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg445_Image_686.jpg)'
- en: The `drawCircles()` function draws a circle based on a set of parameters that
    it receives as arguments. It then calls itself with those same parameters, adjusting
    them slightly. The result is a series of circles, each of which is drawn inside
    the previous circle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawCircles()`函数根据它接收的参数集合绘制一个圆形。然后，它用相同的参数调用自己，并对参数做些微调。结果是一系列圆形，每个圆形都绘制在前一个圆形内部。'
- en: Just as the `factorial()` function stops recursing when `n` equals `0`, notice
    that `drawCircles()` recursively calls itself only if the radius is greater than
    `4`. This is a crucial point. As with iteration, *all recursive functions must
    have an exit condition!* You’re likely already aware that all `for` and `while`
    loops must include a Boolean expression that eventually evaluates to `false`,
    thus exiting the loop. Without one, the sketch would get caught inside an infinite
    loop. The same can be said about recursion. If a recursive function calls itself
    forever and ever with no exit, you’d be treated to a chilly, frozen screen in
    most cases. The browser, however, has protections built in, and rather than freeze,
    it will quit the sketch with the error message `Maximum call stack size exceeded`.
    This is just a fancy way of saying, “Too many recursive calls to the same function;
    time to stop!”
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`factorial()`函数在`n`等于`0`时停止递归一样，注意`drawCircles()`只有在半径大于`4`时才会递归调用自身。这是一个关键点。和迭代一样，*所有递归函数必须有退出条件！*你可能已经知道，所有的`for`和`while`循环必须包含一个最终会变为`false`的布尔表达式，从而退出循环。如果没有退出条件，草图将陷入无限循环。同样地，递归也如此。如果一个递归函数无限次地调用自身而没有退出条件，通常你会看到一个冻结的屏幕。然而，浏览器内置了保护机制，它不会冻结，而是会以错误信息`Maximum
    call stack size exceeded`退出草图。这只是另一种方式在说：“递归调用次数过多，是时候停止了！”
- en: '[Example 8.1](ch08.xhtml#ch8ex1) was rather trivial; it could easily be achieved
    through simple iteration with a `for` or `while` loop. The results become more
    interesting, however, when a function is defined to call itself more than once.
    In such scenarios, recursion becomes wonderfully elegant. To illustrate, I’ll
    make `drawCircles()` a bit more complex: for every circle displayed, draw two
    more circles inside it, half its size—one left of center and one right of center.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例8.1](ch08.xhtml#ch8ex1)相对简单；通过使用`for`或`while`循环的简单迭代就能轻松实现。然而，当一个函数被定义为调用自己多次时，结果变得更加有趣。在这种情况下，递归变得非常优雅。为了演示这一点，我将使`drawCircles()`稍微复杂一点：每绘制一个圆形，就在其中绘制两个半径为原来一半的新圆形，一个位于中心左侧，另一个位于中心右侧。'
- en: '![Image](../images/pg446_Image_687.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg446_Image_687.jpg)'
- en: Add two more lines of code, and now each circle contains four circles—left,
    right, above, and below its center.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再添加两行代码，现在每个圆圈里包含了四个圆圈——分别是左、右、上和下。
- en: '![Image](../images/pg447_Image_688.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg447_Image_688.jpg)'
- en: Try reproducing this sketch with iteration instead of recursion—I dare you!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用迭代代替递归来重现这个草图——我敢打赌你做不到！
- en: '**Drawing the Cantor Set with Recursion**'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用递归绘制Cantor集**'
- en: 'Now that I’ve demonstrated how to use recursive functions, I’m ready to visualize
    the Cantor set in p5.js. Where do I begin? Well, I know that the Cantor set begins
    with a line, so I’ll start there and write a function that draws a line:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经展示了如何使用递归函数，我准备好在p5.js中可视化Cantor集了。我该从哪里开始呢？嗯，我知道Cantor集是从一条线开始的，所以我从这开始，编写一个画线的函数：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function draws a line of length `length` that starts at pixel coordinate
    (*x*, *y*). The line is drawn horizontally, but this is an arbitrary decision.
    Let’s say the function is called like so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数绘制了一条长度为`length`的线，起点是像素坐标(*x*, *y*)。这条线是水平绘制的，但这是一个任意的决定。假设这个函数是这样调用的：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’d see something like [Figure 8.8](ch08.xhtml#ch8fig8).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似于[图 8.8](ch08.xhtml#ch8fig8)的结果。
- en: '![Image](../images/pg448_Image_689.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_689.jpg)'
- en: 'Figure 8.8: The result of a single call to `cantor()` is a single line.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：调用一次`cantor()`的结果是一条线。
- en: The Cantor rule operates by duplicating the original line and erasing its middle
    third section, leaving two remaining lines—one from the beginning to the one-third
    mark, and one from the two-thirds mark to the end of the line (see [Figure 8.9](ch08.xhtml#ch8fig9)).
    I can implement that rule manually by calling `line()` two more times, moving
    the y-position down 20 pixels so that the next generation of lines appears below
    the first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Cantor规则通过复制原始线条并删除其中的三分之一部分来操作，剩下两条线——一条从起点到三分之一的位置，另一条从三分之二的位置到线的末端（见[图 8.9](ch08.xhtml#ch8fig9)）。我可以通过手动调用`line()`两次来实现这个规则，并将y位置下移20像素，这样下一代线条就会出现在第一代线条的下方。
- en: '![Image](../images/pg448_Image_690.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_690.jpg)'
- en: 'Figure 8.9: The next iteration of lines in the Cantor set are one-third the
    length of the previous line.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：Cantor集中下一代的线条是前一条线的三分之一长度。
- en: '![Image](../images/pg448_Image_691.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_691.jpg)'
- en: '[Figure 8.10](ch08.xhtml#ch8fig10) shows the result.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.10](ch08.xhtml#ch8fig10)展示了结果。'
- en: '![Image](../images/pg448_Image_692.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_692.jpg)'
- en: 'Figure 8.10: Two generations of lines drawn with the Cantor set rules'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10：使用Cantor集规则绘制的两代线条
- en: 'This works over two generations, but continuing to manually call `line()` will
    quickly become unwieldy. For the succeeding generations, I’d need 4, then 8, then
    16 calls to `line()`. A `for` loop is the usual way around such a problem, but
    give that a try and you’ll see that working out the math for each iteration quickly
    proves inordinately complicated. Don’t despair, however: here’s where recursion
    comes to the rescue!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于两代，但继续手动调用`line()`会很快变得笨重。对于后续的几代，我需要调用4次、8次、16次`line()`。`for`循环通常是解决这种问题的方式，但尝试一下，你会发现为每次迭代计算数学公式变得异常复杂。不过别灰心：这时候递归就能派上用场！
- en: 'Look at where I draw the first line of the second generation, from the start
    to the one-third mark:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我如何绘制第二代的第一条线，从起点到三分之一的位置：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of calling the `line()` function directly, why not call the `cantor()`
    function? After all, what does the `cantor()` function do? It draws a line at
    an (*x*, *y*) position with a given `length`. The `x` value stays the same, `y`
    increments by 20, and the length is `length / 3`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与其直接调用`line()`函数，为什么不调用`cantor()`函数呢？毕竟，`cantor()`函数到底做什么呢？它在(*x*, *y*)位置画一条给定`length`的线。`x`值保持不变，`y`值增加20，而长度是`length
    / 3`：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This call to `cantor()` is precisely equivalent to the earlier call to `line()`.
    And for the next line in the second generation, I can call `cantor()` again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次调用`cantor()`与之前调用`line()`完全等价。而对于第二代中的下一条线，我可以再次调用`cantor()`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the `cantor()` function looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`cantor()`函数看起来是这样的：
- en: '![Image](../images/pg449_Image_693.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg449_Image_693.jpg)'
- en: 'Since the `cantor()` function is now recursive, the same rule will be applied
    to the next line and to the next and to the next as `cantor()` calls itself again
    and again! But don’t go running this code quite yet. The sketch is missing that
    crucial element: an exit condition. It has to stop recursing at some point. Here,
    I’ll choose to stop if the line length is less than or equal to 1 pixel. In other
    words, keep going if `length` is greater than `1`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cantor()`函数现在是递归的，因此相同的规则将应用于下一条线，接着是下下一条，依此类推，直到`cantor()`一次又一次地调用自己！但是，别急着运行这段代码。草图缺少一个至关重要的元素：退出条件。递归必须在某个时刻停止。在这里，我选择当线段长度小于或等于
    1 像素时停止。换句话说，当`length`大于`1`时继续。
- en: '![Image](../images/pg450_Image_694.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg450_Image_694.jpg)'
- en: Writing a function that recursively calls itself is a simple, elegant technique
    for generating a fractal pattern, but it doesn’t allow me to do much beyond drawing
    the pattern. For example, what if I want the lines in the Cantor set to exist
    as individual objects that could be moved independently? For that, I need to use
    a different programming approach, one that applies recursion in combination with
    an array that keeps track of all its individual parts. That’s exactly what I’ll
    do next!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个递归调用自身的函数是生成分形模式的一种简单优雅的技术，但它只允许我做绘制模式这一件事。例如，如果我想让康托集中的线条作为独立的对象存在并且可以独立移动呢？为此，我需要使用一种不同的编程方法，将递归与一个数组结合使用，该数组跟踪所有的独立部分。这正是我接下来要做的！
- en: '![Image](../images/pencil.jpg) **Exercise 8.1**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 8.1**'
- en: Using [Examples 8.2](ch08.xhtml#ch8ex2) and [8.3](ch08.xhtml#ch8ex3) as a model,
    design your own recursive pattern. Here is an example of one using lines.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例 8.2](ch08.xhtml#ch8ex2)和[8.3](ch08.xhtml#ch8ex3)作为模型，设计你自己的递归模式。以下是一个使用线条的示例。
- en: '![Image](../images/pg450_Image_695.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg450_Image_695.jpg)'
- en: '**The Koch Curve**'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**科赫曲线**'
- en: I’ll now turn to another famous fractal pattern, the **Koch curve**, discovered
    in 1904 by Swedish mathematician Helge von Koch. [Figure 8.11](ch08.xhtml#ch8fig11)
    outlines the production rules for drawing this fractal. Notice that the rules
    start the same way as the Cantor set, with a single line that’s then divided into
    three equal parts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将转向另一个著名的分形模式——**科赫曲线**，它是由瑞典数学家赫尔格·冯·科赫于1904年发现的。[图 8.11](ch08.xhtml#ch8fig11)概述了绘制这个分形的生成规则。注意，这些规则的开始方式与康托集相同，首先是一条线，然后将其分成三等分。
- en: '![Image](../images/pg451_Image_696.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg451_Image_696.jpg)'
- en: 'Figure 8.11: The rules for drawing the Koch curve'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11：绘制科赫曲线的规则
- en: '[Figure 8.12](ch08.xhtml#ch8fig12) shows how the fractal develops over several
    repetitions of these steps.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.12](ch08.xhtml#ch8fig12)展示了通过多次重复这些步骤后，分形的演化过程。'
- en: '![Image](../images/pg451_Image_697.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg451_Image_697.jpg)'
- en: 'Figure 8.12: The evolution of the Koch curve'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12：科赫曲线的演变
- en: I could proceed in the same manner as I did with the Cantor set and write a
    recursive function that iteratively applies the Koch rules over and over. Instead,
    I’m going to tackle this problem differently by treating each segment of the Koch
    curve as an individual object. This will open up some exciting design possibilities.
    For example, if each segment is an object, it could move independently from its
    original position and participate in a physics simulation. In addition, the visual
    appearance of each segment could vary if the object includes customizable properties
    for color, line thickness, and so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像处理康托集那样进行操作，编写一个递归函数，反复迭代应用科赫规则。但我打算换一种方式解决这个问题，把科赫曲线的每一段当作一个独立的对象。这将打开一些令人兴奋的设计可能性。例如，如果每一段都是一个对象，它可以独立于原始位置移动，并参与物理模拟。此外，每一段的外观也可以有所不同，如果对象包含可自定义的属性，如颜色、线条粗细等。
- en: '![Image](../images/zoom.jpg) **The Monster Curve**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **怪物曲线**'
- en: The Koch curve and other fractal patterns are often called *mathematical monsters*
    because of an odd paradox that emerges when you apply the recursive definition
    an infinite number of times. If the length of the original starting line is 1,
    the first iteration of the Koch curve will yield a line of length four-thirds
    (each segment is one-third the length of the starting line). Do it again and you
    get a length of sixteen-ninths. As you iterate toward infinity, the length of
    the Koch curve approaches infinity, and yet it fits in the tiny finite space provided
    right here on this paper (or screen)!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 科赫曲线和其他分形图案常被称为*数学怪物*，因为当你将递归定义应用无限次时，会出现一个奇怪的悖论。如果原始起始线段的长度为1，那么科赫曲线的第一次迭代将得到一条长度为四分之三的线（每段长度为起始线的三分之一）。再迭代一次，你将得到十六分之九的长度。随着迭代趋向于无穷大，科赫曲线的长度也接近无穷大，但它仍然可以适应这个纸面（或屏幕）上的有限空间！
- en: Since you’re working in the p5.js land of finite pixels, this theoretical paradox
    won’t be a factor. You’ll just have to limit the number of times you recursively
    apply the Koch rules so that your program won’t run out of memory or crash.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在p5.js的有限像素空间中工作，这个理论悖论不会成为问题。你只需要限制递归应用科赫规则的次数，以免程序耗尽内存或崩溃。
- en: 'To accomplish the goal of treating each segment as an individual object, I
    must first decide what this object should be in the first place. What data should
    it store? What functions should it have? The Koch curve is a series of connected
    lines, and so I’ll think of each segment as a *KochLine*. Each `KochLine` object
    has a start point (a) and an end point (b). These points are represented as `p5.Vector`
    objects, and the line is drawn using the `line()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现将每个段落视为一个独立对象的目标，我首先必须决定这个对象应该是什么。它应该存储什么数据？它应该具备什么功能？科赫曲线是一系列相连的线段，因此我会将每个段落视为一个*KochLine*。每个`KochLine`对象都有一个起点（a）和一个终点（b）。这些点被表示为`p5.Vector`对象，线段则通过`line()`函数绘制：
- en: '![Image](../images/pg452_Image_698.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg452_Image_698.jpg)'
- en: 'Now that I have the `KochLine` class, I can get started on `setup()` and `draw()`.
    I’ll need a data structure to keep track of what will eventually become many `KochLine`
    objects, and a JavaScript array will do just fine (see [Chapter 4](ch04.xhtml#ch04)
    for a review of arrays):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了`KochLine`类，我可以开始编写`setup()`和`draw()`了。我需要一个数据结构来追踪最终会成为许多`KochLine`对象的内容，而一个JavaScript数组就能很好地完成这项任务（请参见[第4章](ch04.xhtml#ch04)以复习数组）：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `setup()`, I’ll want to add the first line segment to the array, a line
    that stretches from 0 to the width of the canvas:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`中，我将希望将第一条线段添加到数组中，这条线段从0延伸到画布的宽度：
- en: '![Image](../images/pg453_Image_699.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg453_Image_699.jpg)'
- en: 'Then in `draw()`, all `KochLine` objects (just one for now) can be rendered
    with a `for...of` loop:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`draw()`中，所有`KochLine`对象（目前只有一个）可以通过`for...of`循环渲染：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is my foundation for the sketch. I have a `KochLine` class that keeps track
    of a line from point `start` to point `end`, and I have an array that keeps track
    of all the `KochLine` objects. Given these elements, how and where should I apply
    the Koch rules and the principles of recursion?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我草图的基础。我有一个`KochLine`类，它追踪从起点`start`到终点`end`的线段，我还有一个数组追踪所有`KochLine`对象。有了这些元素，我该如何以及在哪里应用科赫规则和递归原理呢？
- en: 'Remember the Game of Life cellular automaton from [Chapter 7](ch07.xhtml#ch07)?
    In that simulation, I always kept track of two generations: current and next.
    When I was finished calculating the next generation, *next* became *current*,
    and I moved on to computing the new next generation. I’m going to apply a similar
    technique here. I have a `segments` array listing the current set of line segments
    (at the start of the program, there’s only one). Now I need a second array (I’ll
    call it `next`), where I can place all the new `KochLine` objects generated from
    applying the Koch rules. For every single `KochLine` in the current array, four
    new line segments will be added to `next`. When I’m done, the `next` array becomes
    the new `segments` array (see [Figure 8.13](ch08.xhtml#ch8fig13)).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[第7章](ch07.xhtml#ch07)中的生命游戏元胞自动机吗？在那个模拟中，我始终追踪着两代细胞：当前代和下一代。当我计算完下一代后，*下一代*变成*当前代*，然后我继续计算新的下一代。我将在这里应用类似的技巧。我有一个`segments`数组列出当前的线段集合（在程序开始时，只有一条）。现在我需要一个第二个数组（我叫它`next`），在这里我可以放置所有通过应用科赫规则生成的新`KochLine`对象。对于当前数组中的每一个`KochLine`，将会有四个新的线段被添加到`next`中。当我完成时，`next`数组将成为新的`segments`数组（请参见[图8.13](ch08.xhtml#ch8fig13)）。
- en: '![Image](../images/pg454_Image_700.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg454_Image_700.jpg)'
- en: 'Figure 8.13: The next generation of the fractal is calculated from the current
    generation. Then *next* becomes the new *current* in the transition from one generation
    to another.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：分形的下一代是通过当前一代计算得出的。然后，*next*变为新的*current*，在一代到另一代的过渡中。
- en: 'Here’s how the code looks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '![Image](../images/pg454_Image_701.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg454_Image_701.jpg)'
- en: 'By calling `generate()` over and over, the Koch curve rules will be recursively
    applied to the existing set of `KochLine` segments. But, of course, I’ve skipped
    over the real work of the function: How do I actually break one line segment into
    four as described by the rules? I need a way to calculate the start and end points
    of each line.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反复调用`generate()`，Koch曲线的规则将递归应用到现有的`KochLine`线段集合中。但是，当然，我跳过了函数的真正工作：我如何将一条线段按照规则分割成四个部分？我需要一种方法来计算每条线段的起点和终点。
- en: 'Because the `KochLine` class uses `p5.Vector` objects to store the start and
    end points, this is a wonderful opportunity to practice all that vector math from
    [Chapter 1](ch01.xhtml#ch01), along with some trigonometry from [Chapter 3](ch03.xhtml#ch03).
    First, I should establish the scope of the problem: How many points do I need
    to compute for each `KochLine` object? [Figure 8.14](ch08.xhtml#ch8fig14) shows
    the answer.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`KochLine`类使用`p5.Vector`对象来存储起点和终点，这是一个很好的机会，来练习[第1章](ch01.xhtml#ch01)中的所有向量数学知识，以及[第3章](ch03.xhtml#ch03)中的一些三角学知识。首先，我需要确定问题的范围：每个`KochLine`对象需要计算多少个点？[图8.14](ch08.xhtml#ch8fig14)给出了答案。
- en: '![Image](../images/pg455_Image_702.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg455_Image_702.jpg)'
- en: 'Figure 8.14: Two points become five points.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：两个点变成五个点。
- en: 'As the figure illustrates, I need to turn the two points (*start*, *end*) into
    five (*a*, *b*, *c*, *d*, *e*) to generate the four new line segments (*a* → *b*,
    *b* → *c*, *c* → *d*, *d* → *e*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图中所示，我需要将两个点（*start*，*end*）转化为五个点（*a*，*b*，*c*，*d*，*e*），从而生成四个新的线段（*a* → *b*，*b*
    → *c*，*c* → *d*，*d* → *e*）：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Where do I get these points? Why not ask the `KochLine` object to calculate
    them for me?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我从哪里获得这些点呢？为什么不直接让`KochLine`对象为我计算它们呢？
- en: '![Image](../images/pg455_Image_703.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg455_Image_703.jpg)'
- en: 'Wait, let’s take a look at this one line of code a little bit more closely:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，让我们仔细看看这一行代码：
- en: '![Image](../images/pg455_Image_704.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg455_Image_704.jpg)'
- en: 'As you may recall, in [Chapter 6](ch06.xhtml#ch06) I explained **object destructuring**
    as a means of extracting properties from an object and assigning them to individual
    variables. Guess what? You can do the same with arrays! Here, as long as the `kochPoints()`
    method returns an array of five elements, I can conveniently unpack and assign
    them, each to its respective variables: `a`, `b`, `c`, `d`, and `e`. It’s a lovely
    way to handle multiple return values. Just as with objects, **array destructuring**
    keeps the code neat and tidy.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，在[第6章](ch06.xhtml#ch06)中，我解释了**对象解构**，这是一种从对象中提取属性并将它们分配给各个变量的方法。猜猜看？你也可以对数组做同样的事情！在这里，只要`kochPoints()`方法返回一个包含五个元素的数组，我就可以方便地将它们解构并分别赋值给：`a`、`b`、`c`、`d`和`e`。这是一种处理多个返回值的漂亮方法。就像对象解构一样，**数组解构**使得代码保持整洁。
- en: 'Now I just need to write a new `kochPoints()` method in the `KochLine` class
    that returns an array of `p5.Vector` objects representing the points *a* through
    *e* in [Figure 8.15](ch08.xhtml#ch8fig15). I’ll knock off *a* and *e* first, which
    are the easiest—they’re just copies of the `start` and `end` points of the original
    line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只需要在`KochLine`类中写一个新的`kochPoints()`方法，返回一个`p5.Vector`对象数组，表示[图8.15](ch08.xhtml#ch8fig15)中的点*a*到*e*。我将首先处理最简单的*a*和*e*——它们只是原始线段的`start`和`end`点的副本：
- en: '![Image](../images/pg456_Image_705.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg456_Image_705.jpg)'
- en: How about points *b* and *d*? Point *b* is one-third of the way along the line
    segment, and *d* is two-thirds of the way along. As [Figure 8.15](ch08.xhtml#ch8fig15)
    shows, if I create a vector ![Image](../images/common-01.jpg) that points from
    the original *start* to *end*, I can find the new points by scaling its magnitude
    to one-third for the new *b* and two-thirds for the new *d*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，点*b*和*d*呢？点*b*在线段上是三分之一的位置，点*d*则在两分之二的位置。如[图8.15](ch08.xhtml#ch8fig15)所示，如果我创建一个指向原始*start*到*end*的向量![Image](../images/common-01.jpg)，我可以通过将其大小缩放为三分之一来获得新的*b*，将其大小缩放为三分之二来获得新的*d*。
- en: '![Image](../images/pg456_Image_706.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg456_Image_706.jpg)'
- en: 'Figure 8.15: The original line expressed as a vector ![Image](../images/common-02.jpg)
    can be divided by 3 to find the positions of the points for the next generation.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15：原始线段作为向量 ![图片](../images/common-02.jpg)，可以通过三等分来找到下一代点的位置。
- en: 'Here’s how that looks in code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码实现：
- en: '![Image](../images/pg456_Image_707.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg456_Image_707.jpg)'
- en: The last point, *c*, is the most difficult one to compute. However, if you consider
    that the angles of an equilateral triangle are all 60 degrees, this makes your
    work suddenly easier. If you know how to find the new *b* with a vector one-third
    the length of the line, what if you rotate that same vector 60 degrees (or π/3
    radians) and add it to *b*, as in [Figure 8.16](ch08.xhtml#ch8fig16)? You’d arrive
    at *c*!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的点，*c*，是最难计算的。然而，如果你考虑到等边三角形的角度都是60度，这就使得你的工作突然变得容易了。如果你知道如何通过一个三分之一长度的向量找到新的*b*，那么如果你将这个相同的向量旋转60度（或π/3弧度）并加到*b*上，就像在[图
    8.16](ch08.xhtml#ch8fig16)中那样，你就能得到*c*！
- en: '![Image](../images/pg456_Image_708.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg456_Image_708.jpg)'
- en: 'Figure 8.16: The vector ![Image](../images/common-02.jpg) is rotated by 60
    degrees to find the third point.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：向量 ![图片](../images/common-02.jpg) 旋转60度来找到第三个点。
- en: '![Image](../images/pg457_Image_709.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg457_Image_709.jpg)'
- en: 'Finally, after calculating the five points, I can return them all together
    in an array. This will match the code for destructuring the array into five separate
    variables, as previously outlined:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在计算出五个点后，我可以将它们一起返回一个数组。这将匹配之前概述的将数组解构成五个独立变量的代码：
- en: '![Image](../images/pg457_Image_710.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg457_Image_710.jpg)'
- en: Now all that remains is to call `generate()` a certain number of times (say,
    five) in `setup()` to calculate the Koch line segments up to that generation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是在`setup()`中调用`generate()`一定次数（比如五次），以计算出该代的科赫线段。
- en: '![Image](../images/pg457_Image_711.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg457_Image_711.jpg)'
- en: In this example, I chose to call `generate()` five times. Each time the Koch
    rules are applied, the number of line segments grows exponentially. It’s an arbitrary
    decision, but after five iterations I have 1,024 segments, which provide a considerable
    amount of detail for seeing the pattern. You could, however, choose to use the
    approach taken in previous examples, setting a threshold for the minimum segment
    length and calling `generate()` until the segments become too small. Alternatively,
    you might consider an interactive option, with a button that advances the shape
    to the next generation with each press.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我选择调用`generate()`五次。每次应用科赫规则时，线段的数量会呈指数增长。这是一个任意的决定，但经过五次迭代后，我得到了1,024个线段，这为观察模式提供了相当多的细节。不过，你也可以选择使用前面示例中的方法，设定最小线段长度的阈值，并在线段变得过小之前一直调用`generate()`。另外，你也可以考虑一个交互选项，设置一个按钮，每按一次按钮就将形状推进到下一代。
- en: '![Image](../images/pencil.jpg) **Exercise 8.2**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 8.2**'
- en: Draw the Koch snowflake, which consists of three Koch curves arranged in a triangle.
    Or draw some another variation of the Koch curve.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制科赫雪花，它由三个科赫曲线组成，排列成一个三角形。或者绘制科赫曲线的其他变体。
- en: '![Image](../images/pg458_Image_712.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg458_Image_712.jpg)'
- en: '![Image](../images/pencil.jpg) **Exercise 8.3**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 8.3**'
- en: Try animating the Koch curve. For example, can you draw it from left to right?
    Can you vary the visual design of the line segments? Can you move the line segments
    by using techniques from earlier chapters? What if you make each line segment
    into a spring (Toxiclibs.js) or constraint (Matter.js)?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试动画化科赫曲线。例如，你能从左到右绘制它吗？你能改变线段的视觉设计吗？你能使用前面章节中的技术移动线段吗？如果你将每个线段做成弹簧（Toxiclibs.js）或约束（Matter.js）会怎么样？
- en: '![Image](../images/pencil.jpg) **Exercise 8.4**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 8.4**'
- en: Rewrite the Cantor set example by using objects and an array.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象和数组重写康托集示例。
- en: '![Image](../images/pencil.jpg) **Exercise 8.5**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 8.5**'
- en: Use recursion to draw the Sierpiński triangle (as seen in [Chapter 7](ch07.xhtml#ch07)’s
    Wolfram elementary CA).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归绘制谢尔宾斯基三角形（如[第7章](ch07.xhtml#ch07)中的沃尔夫勒姆初等CA所示）。
- en: '![Image](../images/pg459_Image_713.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg459_Image_713.jpg)'
- en: '**Trees**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**树**'
- en: 'The fractals presented so far in this chapter have been deterministic: they
    have no randomness baked in and will always produce the same outcome each time
    they’re run. While this has made for an excellent introduction to classic fractal
    patterns and the programming techniques behind drawing them, the results have
    appeared too precise to seem truly organic.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止呈现的分形是确定性的：它们没有内建的随机性，每次运行时都会产生相同的结果。虽然这为经典分形模式和绘制它们的编程技巧提供了很好的介绍，但结果看起来过于精确，似乎不够有机。
- en: In this section, I’ll take a step closer to the natural world, with a case study
    of a branching fractal tree. I’ll start with a deterministic version. Then I’ll
    introduce an element of randomness to illustrate techniques for generating stochastic
    (or nondeterministic) fractals, whose outcome can vary each time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将进一步接近自然世界，通过一个分支分形树的案例研究。我将从一个确定性版本开始。然后，我会引入随机性元素，说明生成随机（或非确定性）分形的技巧，这些分形的结果每次运行时都可能不同。
- en: '**The Deterministic Version**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**确定性版本**'
- en: '[Figure 8.17](ch08.xhtml#ch8fig17) outlines a deterministic set of production
    rules for drawing a fractal tree.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.17](ch08.xhtml#ch8fig17)概述了绘制分形树的确定性生成规则。'
- en: '![Image](../images/pg460_Image_714.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg460_Image_714.jpg)'
- en: 'Figure 8.17: Each generation of a fractal tree, following the given production
    rules. The final tree is several generations later.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：每一代分形树，遵循给定的生成规则。最终的树是几代之后的结果。
- en: 'Once again, I have a nice fractal with a recursive definition: a branch is
    a line with two branches connected to it. What makes this fractal a bit more difficult
    than the previous ones is the use of the word *rotate* in the fractal’s rules.
    Each new branch must rotate relative to the previous branch, which is rotated
    relative to all its previous branches. Luckily, p5.js has a mechanism to keep
    track of rotations: **transformations**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次得到一个很好的分形，其递归定义是：一根树枝是一条线，且有两根树枝与之相连。与之前的分形相比，这个分形稍微复杂一些，因为在分形规则中使用了*rotate*一词。每一根新树枝必须相对于上一根树枝进行旋转，而上一根树枝又是相对于它所有的前一根树枝进行旋转。幸运的是，p5.js提供了一个机制来跟踪旋转：**变换**。
- en: I touched on transformations in [Chapter 3](ch03.xhtml#ch03). They’re a set
    of functions, such as `translate()`, `rotate()`, `scale()`, `push()`, and `pop()`,
    that allow you to change the position, orientation, and scale of shapes in your
    sketch. The `translate()` function moves the coordinate system, `rotate()` rotates
    it, and `push()` and `pop()` help save and restore the current transformation
    state. If you aren’t familiar with these functions, I have a set of videos on
    transformations in p5.js available at the Coding Train website (*[https://thecodingtrain.com/transformations](https://thecodingtrain.com/transformations)*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第3章](ch03.xhtml#ch03)中简要介绍了变换。它们是一组函数，如`translate()`、`rotate()`、`scale()`、`push()`和`pop()`，这些函数允许你改变草图中形状的位置、方向和大小。`translate()`函数用于平移坐标系，`rotate()`用于旋转坐标系，`push()`和`pop()`帮助保存和恢复当前的变换状态。如果你不熟悉这些函数，我在Coding
    Train网站上提供了一组关于p5.js变换的视频 (*[https://thecodingtrain.com/transformations](https://thecodingtrain.com/transformations)*)。
- en: 'I’ll begin by drawing a single branch, the trunk of the tree. Since I’m going
    to be using the `rotate()` function, I need to make sure I’m continuously translating
    along the branches while drawing. Remember, when you rotate in p5.js, you’re always
    rotating around the origin, or point (0, 0), so here the origin must always be
    translated to the start of the next branch being drawn (equivalent to the end
    of the previous branch). Since the trunk starts at the bottom of the window, I
    first have to translate to that spot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从画一根树枝开始，即树干。由于我将使用`rotate()`函数，我需要确保在绘制过程中不断地沿着树枝进行平移。记住，在p5.js中，当你进行旋转时，你总是围绕原点（即点
    (0, 0)）进行旋转，所以在这里，原点必须始终平移到下一根正在绘制的树枝的起点（相当于上一根树枝的末端）。由于树干从窗口的底部开始，我首先需要平移到那个位置：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then I can draw the trunk as a line upward:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以将树干画成一条向上的线：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once I’ve drawn the line, I must translate to the end of that line and rotate
    in order to draw the next branch, as demonstrated in [Figure 8.18](ch08.xhtml#ch8fig18).
    (Eventually, I’m going to need to package up what I’m doing right now into a recursive
    function, but I’ll sort out the individual steps first.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我画完了这条线，我必须平移到这条线的末端并进行旋转，以便绘制下一根树枝，正如[图8.18](ch08.xhtml#ch8fig18)中所示。（最终，我需要将目前的操作封装成一个递归函数，但我会先理清单个步骤。）
- en: '![Image](../images/pg461_Image_715.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg461_Image_715.jpg)'
- en: 'Figure 8.18: The process of drawing a line, translating to the end of the line,
    and rotating by an angle'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for the process illustrated in [Figure 8.18](ch08.xhtml#ch8fig18).
    I’m using an angle of 30 degrees, or π/6 radians:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg461_Image_716.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Now that I have a branch going to the right, I need one going to the left (see
    [Figure 8.19](ch08.xhtml#ch8fig19)). For that, I should have used `push()` to
    save the transformation state before rotating and drawing the right branch. Then
    I’ll be able to call `pop()` after drawing the right branch to restore that state,
    putting me back in the correct position to rotate and draw the left branch.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg461_Image_717.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: After “popping” back, a new branch is rotated to the left.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s all the code together:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg462_Image_718.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Think of each call to the `line()` function as a branch, and you can begin
    to see how this code has implemented a definition of branching as a line that
    has two lines connected to its end. I could keep adding more and more calls to
    `line()` for more and more branches, but just as with the Cantor set and Koch
    curve, my code would soon become incredibly complicated and unwieldy. Instead,
    I’ll use the code I’ve already written as a foundation for a `branch()` function,
    replacing the second and third calls to `line()` with recursive calls to `branch()`
    itself:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg462_Image_719.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Notice that I use `push()` and `pop()` around each pair of calls to `rotate()`
    and `branch()`. This is one of those elegant code solutions that feels like magic.
    Before each subsequent call to `branch()`, the code takes a moment to remember
    that branch’s starting position, so it can come back to it later. If you turn
    yourself into p5.js for a moment and try to follow the recursive function with
    pencil and paper, you’ll notice that you end up drawing all the branches to the
    right first. At the very end of the right side, `pop()` will send you back along
    all the branches that were drawn so that you can populate the branches to the
    left.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.6**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Follow the recursive algorithm of drawing branches, and number them in the diagram
    in the order that p5.js would actually draw each one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg463_Image_720.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'You may have noticed that the recursive function as written has a major problem:
    it has no exit condition, so it would get stuck in infinite recursive calls to
    itself. Also, the branches of the tree should get shorter at each level, but so
    far I’ve hardcoded every branch to have a length of 100 pixels. The solutions
    to these two issues are intertwined—if the branches shrink from one generation
    to the next, I can make the function stop recursing when the branches have become
    too short:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg463_Image_721.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: I’ve also included a variable for `angle`. In the finished example, the angle
    is controlled by the `mouseX` position.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg464_Image_722.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: The recursive `branch()` function provides a clean and elegant way of drawing
    the tree with very few lines of code. However, this approach constrains the potential
    for animation. By adopting the methodology used in the Koch curve, storing each
    segment as an object in an array, you can explore creative ways to animate the
    tree’s growth or even apply physics to the branches!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.7**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Vary the `strokeWeight()` for each branch. Make the trunk thick and each subsequent
    branch thinner.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg465_Image_723.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/pencil.jpg) **Exercise 8.8**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Re-create the tree by using a `Branch` class and an array to keep track of
    the branches. (Hint: You’ll want to keep track of the branch directions and lengths
    by using vector math instead of p5.js transformations.) Can you animate the tree’s
    growth? What about drawing leaves at the ends of the branches?'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg465_Image_724.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: '**The Stochastic Version**'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At first glance (and with the right angle), it may look like I’ve drawn a convincing
    tree in the previous example, but on closer inspection, the result is a little
    too perfect. Take a look outside at a real tree and you’ll notice that the branch
    lengths and angles vary from branch to branch, not to mention the fact that not
    all branches split off into exactly two smaller branches. Fractal trees are a
    great example of how adding a touch of randomness can make the end result look
    more natural. That bit of randomness also transforms the fractal from deterministic
    to stochastic—the exact outcome will be different from drawing to drawing, while
    still retaining the overall characteristics of a branching, tree-like structure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'First, how about randomizing the angle for each branch? This is a pretty easy
    one to do just by adding `random()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg466_Image_725.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: In the original example, `branch()` always calls itself twice. Now, for extra
    variety, I’ll instead pick a random number of branches (each with a random angle)
    for each branch.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg466_Image_726.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: '[Example 8.7](ch08.xhtml#ch8ex7) demonstrates the use of randomness in angles
    and numbers of branches, but perhaps it goes too far: the resulting trees still
    don’t appear particularly organic. For a more natural-looking tree, you might
    try limiting the range of random angles more narrowly, or incorporating Perlin
    noise for more gradual angle changes.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.9**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Set the angles of the tree branches according to Perlin noise values. Adjust
    the noise values over time to animate the tree. See if you can get it to appear
    as if it’s blowing in the wind.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.10**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Use Toxiclibs.js to simulate tree physics. Each branch of the tree could be
    two particles connected with a spring. How can you get the tree to stand up and
    not fall down?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**L-systems**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1968, Hungarian botanist Aristid Lindenmayer developed a grammar-based system
    to model the growth patterns of plants. This system uses textual symbols and a
    specific set of rules to generate patterns, just as a language’s grammar defines
    rules for constructing sentences out of words. Known as an **L-system** (short
    for **Lindenmayer system**), this technique can be used to generate the recursive
    fractal patterns demonstrated so far in this chapter. L-systems are additionally
    valuable because they provide a mechanism for using simple symbols to keep track
    of fractal structures that require complex and multifaceted production rules.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年，匈牙利植物学家阿里斯提德·林登迈尔（Aristid Lindenmayer）开发了一种基于语法的系统，用于模拟植物的生长模式。这个系统使用文本符号和一组特定的规则来生成模式，类似于语言的语法定义了用单词构建句子的规则。这个被称为**L系统**（**林登迈尔系统**）的技术，可以用来生成本章至今展示的递归分形模式。L系统还具有额外的价值，因为它们提供了一种机制，使用简单的符号跟踪需要复杂且多面的生成规则的分形结构。
- en: 'Implementing an L-system in p5.js requires working with recursion, transformations,
    and strings of text. This chapter already covers recursion and transformations,
    but strings are new. Here’s a quick snippet of code demonstrating the three aspects
    of working with text important to L-systems: creating, concatenating, and iterating
    over strings. You can refer to the book’s website for additional string resources
    and tutorials.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在p5.js中实现L系统需要使用递归、变换和文本字符串。本章已经介绍了递归和变换，但字符串是新的概念。这里有一段简短的代码示例，展示了与文本相关的L系统的三个重要方面：创建、连接和迭代字符串。你可以参考本书网站获取更多字符串的资源和教程。
- en: '![Image](../images/pg467_Image_728.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg467_Image_728.jpg)'
- en: 'An L-system has three main components:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个L系统有三个主要组成部分：
- en: '**Alphabet:** An L-system’s alphabet comprises the valid characters that can
    be included. For example, I could say the alphabet is ABC, meaning that any valid
    “sentence” (a string of characters) in an L-system can include only these three
    characters.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字母表：** 一个L系统的字母表包括可以包含的有效字符。例如，我可以说字母表是ABC，这意味着L系统中任何有效的“句子”（一串字符）只能包含这三个字符。'
- en: '**Axiom:** The axiom is a sentence (created with characters from the alphabet)
    that describes the initial state of the system. For example, with the alphabet
    ABC, a possible axiom could be AAA, or B, or ACBAB.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公理：** 公理是一个句子（由字母表中的字符创建），描述系统的初始状态。例如，使用字母表ABC，一个可能的公理可以是AAA、B或ACBAB。'
- en: '**Rules:** The production rules of an L-system describe ways of transforming
    the sentence. The rules are applied recursively, starting with the axiom, generating
    new sentences over and over again. An L-system rule includes two sentences, a
    *predecessor* and a *successor*. For example, the rule A → AB means that wherever
    an A (the predecessor) occurs in a sentence, it should be replaced with AB (the
    successor) in the next generation.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则：** L系统的生成规则描述了变换句子的方法。这些规则是递归应用的，从公理开始，一次又一次地生成新的句子。L系统的规则包括两个句子，一个是*前驱*，另一个是*后继*。例如，规则A
    → AB表示在句子中每个出现A（前驱）的地方，在下一代中应该用AB（后继）替换。'
- en: 'I’ll begin with a simple L-system. In fact, it’s Lindenmayer’s original L-system,
    which models the growth of algae. Here are its components:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从一个简单的L系统开始。事实上，这是林登迈尔的原始L系统，它模拟了藻类的生长。以下是它的组成部分：
- en: '| Alphabet | A, B |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 字母表 | A, B |'
- en: '| Axiom | A |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 公理 | A |'
- en: '| Rules | A → AB B → A |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 规则 | A → AB B → A |'
- en: '![Image](../images/pg468_Image_730.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg468_Image_730.jpg)'
- en: 'Figure 8.20: And so on and so forth . . .'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：依此类推……
- en: 'The L-system has an alphabet of two characters and features two simple rules:
    replace A with AB, and replace B with A. As with recursive fractal shapes, I can
    consider each successive application of the L-system rules to be a generation.
    Generation 0 is, by definition, the axiom (A), and each subsequent generation
    shows the result of applying the production rules to the current generation. [Figure
    8.20](ch08.xhtml#ch8fig20) shows several generations of this L-system’s development.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个L系统的字母表包含两个字符，并且有两个简单的规则：将A替换为AB，将B替换为A。与递归分形图形一样，我可以将L系统规则的每次应用视为一次世代。世代0按定义是公理（A），每个后续的世代显示将生成规则应用于当前世代的结果。[图8.20](ch08.xhtml#ch8fig20)展示了这个L系统发展的几个世代。
- en: 'How can I implement this L-system with code? I’ll start by storing a string
    containing the axiom in a variable. I’ll name the variable `current`, as it will
    always store the current generation (starting with the axiom):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once again, just as with the Game of Life and the Koch curve, I now need an
    entirely separate string for the next generation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now it’s time to apply the production rules to `current` and write the results
    to `next`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg469_Image_731.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'When the `for` loop is done, `current` is set to `next`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To be sure this code is working, I’ll package it into a function called `generate()`
    and use a loop to call `generate()` multiple times, drawing the current string
    to the canvas.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg469_Image_732.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Right about now, you may be thinking, “This is all very interesting, but what
    exactly is the point? After all, isn’t this chapter supposed to be about *drawing*
    fractal patterns? I can see how the recursive nature of the L-system sentence
    structure relates to the recursive nature of fractals, but how exactly does this
    visually model plant growth? As far as I know, there aren’t any plants that sprout
    As and Bs.”
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'What I’ve left unsaid until now is that embedded into these L-system sentences
    are instructions for drawing, which is how Lindenmayer was able to translate strings
    of characters into the organic structures of plants. To see how this works, here’s
    another example system:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| Alphabet | A, B |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| Axiom | A |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| Rules | A → ABA B → BBB |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: 'Here’s how this L-system plays out over a few generations:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '| Generation 0 | A |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| Generation 1 | ABA |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| Generation 2 | ABABBBABA |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| Generation 3 | ABABBBABABBBBBBBBBABABBBABA |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: 'To turn this into a drawing, I’ll translate the system’s alphabet in the following
    way:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '| A | Draw a line forward. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| B | Move forward (without drawing a line). |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: Armed with this translation, I can treat each generation’s sentence as instructions
    for drawing. [Figure 8.21](ch08.xhtml#ch8fig21) shows the result.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg471_Image_734.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: The Cantor set as expressed with the alphabet of an L-system'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Look familiar? This L-system generated the Cantor set!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, I’ve been using AB as an alphabet, but many L-systems use the
    characters F, G, +, –, [, and ] instead. Here’s what they mean:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| F | Draw a line and move forward. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| G | Move forward (without drawing a line). |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| + | Turn right. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| – | Turn left. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| [ | Save current state. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| ] | Restore current state. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: 'This type of drawing framework is often referred to as **turtle graphics**
    (from the old days of Logo programming). Imagine a turtle sitting on your p5.js
    canvas, able to accept a small set of commands: turn left, turn right, move forward,
    draw a line, and so on. While p5.js isn’t set up to operate this way by default,
    I can emulate a turtle graphics engine fairly easily with `translate()`, `rotate()`,
    and `line()`. Here’s how I would convert this L-system’s alphabet into p5.js code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| F |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '| G |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '| + |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '| – |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| [ |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '| ] |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming I’ve generated a sentence from the L-system, I can iterate through
    the sentence character by character and execute the appropriate code for each
    character:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg472_Image_735.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'With this code and the right L-system conditions, I can draw incredibly elaborate,
    plantlike structures. For the next example, here’s the L-system I’ll use:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '|  Alphabet  | F, G, +, –, [, ] |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| Axiom | F |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| Rules | F → FF + [+ F – F – F] – [– F + F + F] |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: 'The sketch available for download on the book’s website takes all the L-system
    code provided in this section and organizes it into three elements:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '`rules`: A JavaScript object that stores pairs of predecessor and successor
    strings for an L-system rule'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LSystem`: A class to iterate a new L-system generation'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Turtle`: A class to manage reading the L-system sentence and following its
    instructions to draw on the screen'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won’t write out these classes here, since they simply duplicate the code I’ve
    already worked out in this chapter. Instead, I’ll show how all the elements come
    together in the main *sketch.js* file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg473_Image_736.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, I’ve extensively covered OOP in the context of classes
    such as `Particle` and `p5.Vector`. However, in [Example 8.9](ch08.xhtml#ch8ex9),
    you may have noticed a shortcut I took when initializing the `rules` variable.
    Instead of defining a `Rule` class and invoking a constructor with the `new` keyword,
    I initialized the variable with a JavaScript object literal. With its key-value
    pairs, this is a convenient data structure for defining transformation rules for
    an L-system. Each key represents a character in the current generation that needs
    to be replaced (in this case, there’s just one, `"F"`), and that key’s value defines
    the replacement ( `"FF+[+F-F-F]-[-F+F+F]"` ). Although this example has only one
    rule, you could create additional rules as other key-value pairs in the object
    literal.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.11**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Use an L-system as a set of instructions for creating objects stored in an array.
    Use trigonometry and vector math to perform the rotations instead of transformations
    (just as I did with the Koch curve in [Example 8.5](ch08.xhtml#ch8ex5)).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.12**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The seminal work in L-systems and plant structures, *The Algorithmic Beauty
    of Plants* (*[http://algorithmicbotany.org](http://algorithmicbotany.org)*) by
    Przemysław Prusinkiewicz and Aristid Lindenmayer (Springer), was published in
    1990\. [Chapter 1](ch01.xhtml#ch01) describes many sophisticated L-systems with
    additional drawing rules and available alphabet characters. It also describes
    several methods for generating stochastic L-systems. Expand the L-system code
    in [Example 8.9](ch08.xhtml#ch8ex9) to include one or more of the extra features
    described by Prusinkiewicz and Lindenmayer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 8.13**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I emphasized using fractal algorithms for generating visual
    patterns. However, fractals can be found in other creative mediums. For example,
    they’re evident in Johann Sebastian Bach’s Cello Suite No. 3, and the structure
    of David Foster Wallace’s novel *Infinite Jest* (Little, Brown, 1996) was inspired
    by fractals. Consider using the examples in this chapter to generate audio or
    text.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我强调了使用分形算法生成视觉图案。然而，分形也可以在其他创意媒介中找到。例如，它们在约翰·塞巴斯蒂安·巴赫的《大提琴组曲第三号》中显而易见，大卫·福斯特·华莱士的小说*无限的玩笑*（Little,
    Brown，1996）的结构也受到分形的启发。可以考虑使用本章中的示例来生成音频或文本。
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: 'Incorporate fractals into your ecosystem. Here are some possibilities:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将分形融入到你的生态系统中。以下是一些可能性：
- en: Add plantlike creatures to the ecosystem environment.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向生态系统环境中添加类似植物的生物。
- en: Say one of your plants is similar to a fractal tree. Can you add leaves or flowers
    to the ends of the branches? What if the leaves can fall off the tree (depending
    on a wind force)? What if you add fruit that can be picked and eaten by the creatures?
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你的某个植物像一棵分形树。你能在树枝的末端添加叶子或花朵吗？如果这些叶子可以根据风力从树上飘落呢？如果你添加可以被生物采摘并食用的果实呢？
- en: Design a creature with a fractal pattern.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个具有分形图案的生物。
- en: Use an L-system to generate instructions for the way a creature should move
    or behave.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用L系统生成关于生物如何移动或行为的指令。
- en: '![Image](../images/pg475_Image_738.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg475_Image_738.jpg)'
