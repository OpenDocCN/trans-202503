<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch2"><span epub:type="pagebreak" id="page_15"/><span class="big">2</span><br/>WRITING BASIC FUNCTIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">The function is the central idea of functional programming. In this chapter, we’ll learn how to define functions and constants and how to use those functions and constants in GHCi. We’ll discuss the language we use to talk about functions, and we’ll see how communicating with computers often requires more precision than communicating with people. We’ll then introduce Haskell’s system of <em>anonymous functions</em>, which are functions without a name. After a brief glimpse of Haskell’s type system (which we’ll describe more in <a href="ch03.xhtml">Chapter 3</a>), we’ll show how the function composition operator can be used to compose functions. Finally, we’ll show the kind of error you get if you use a name that has not been defined.</p>&#13;
<h3 class="h3" id="ch2lev1"><span epub:type="pagebreak" id="page_16"/>Constants, Functions, and Types</h3>&#13;
<p class="noindent">Programming in Haskell is a process of defining functions. Functions express to the computer how to calculate something we want. Haskell functions are much like mathematical functions: they take inputs and produce an output that depends on the inputs. Like mathematical functions, Haskell functions have a domain, describing the kind of entities that can be used as input, and a codomain (sometimes called range), describing the kind of entities that will be produced as output.</p>&#13;
<p class="indent">Unlike mathematical functions, Haskell functions must be <em>constructive</em>. They must give a clear, well-defined recipe for constructing the output from the inputs. Abelson and Sussman, in their wonderful book <em>Structure and Interpretation of Computer Programs</em> [<strong><a href="bib.xhtml#bib3"><span class="green">3</span></a></strong>], note that the square root function, defined as a number that is nonnegative and squares to equal the input, is a perfectly legitimate mathematical function. But this definition does not give a recipe for how to construct the square root from the input, so it cannot be made into a Haskell function. Fortunately, there are other definitions of square root that are constructive and can be made into Haskell functions.</p>&#13;
<p class="indent">There is a way to define functions inside GHCi, but since we’ll want to use most functions we define more than once, it’s better to define our functions in a <em>source code file</em>, also called a <em>program file</em>, and then load that file into GHCi.</p>&#13;
<p class="indent">We’ll need a text editor to create such a file. Examples of popular text editors are GNU Emacs, Vim, and gedit.</p>&#13;
<p class="indent">Word processing programs you might use to type a letter or a document are not appropriate for this purpose because they store the text you type with additional information (such as font type and size) that will make no sense to the Haskell compiler.</p>&#13;
<p class="indent">Using a text editor, let’s create a file named <em>first.hs</em> for our first program. (The <em>.hs</em> extension indicates a Haskell program.) Put the following lines in the file:</p>&#13;
<pre>-- First Haskell program&#13;
&#13;
-- Here we define a constant&#13;
e :: Double&#13;
e = exp 1&#13;
&#13;
-- Here we define a function&#13;
square :: Double -&gt; Double&#13;
square x = x**2</pre>&#13;
<p class="indent">This program file defines a constant and a function. The lines that begin with a double hyphen are <em>comments</em>. The Haskell compiler ignores any line that begins with a double hyphen; in fact, it ignores whatever is written after a double hyphen until the end of the line, unless the double hyphen is part of a string or certain other special environments. Comments are meant to help humans read the code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_17"/>The first two non-comment lines of the file define the constant <em>e</em>, the base of natural logarithms. Unlike <em>π</em>, <em>e</em> is not included in the Haskell Prelude. The line</p>&#13;
<pre>e :: Double</pre>&#13;
<p class="noindent">declares the <em>type</em> of <code>e</code> to be <code>Double</code>. A <em>type</em> is a description of commonality in how entities can be used. Every expression in Haskell has a type, which tells the compiler about the situations in which the expression can be used and the situations in which it cannot. For example, the <code>Double</code> type tells the compiler that <code>e</code> is an approximation of a real number, sometimes called a floating-point number. The name <code>Double</code> is used for historical reasons to mean a <em>double-precision</em> floating-point number. This type of number is capable of about 15 decimal digits of precision, compared with a single-precision number that is capable of about seven decimal digits of precision. Haskell has a type <code>Float</code> for single-precision numbers. Unless there is a compelling reason to do otherwise, we’ll always use type <code>Double</code> for our (approximations of) real numbers.</p>&#13;
<p class="indent">In addition to <code>Double</code>, there are several other types we might want to use. Haskell has a type <code>Int</code> for small integers (up to at least a few billion) and a type <code>Integer</code> for arbitrary-size integers. <a href="ch03.xhtml">Chapter 3</a> is all about types.</p>&#13;
<p class="indent">Let’s get back to our <em>first.hs</em> program file. As we said earlier, the first non-comment line of the file declares the type of the name <code>e</code> to be <code>Double</code>. This kind of line, with a name followed by a double colon followed by a type, is called a <em>type signature</em>. We may also call such a line a <em>declaration</em>, because it declares the name <code>e</code> to have type <code>Double</code>.</p>&#13;
<p class="indent">The second non-comment line of the file actually <em>defines</em> <code>e</code>. Here, we use the built-in function <code>exp</code> applied to the number <code>1</code> to produce the constant <code>e</code>. Remember that we don’t need parentheses to apply a function to an argument.</p>&#13;
<p class="indent">Next, we have a type signature for the function <code>square</code>. The type of <code>square</code> is declared to be <code>Double -&gt; Double</code>. A type containing an arrow is called a <em>function type</em>. (Function types will be explored in more detail in the next chapter.) It says that <code>square</code> is a function that takes a <code>Double</code> as input and produces a <code>Double</code> as output. The last line defines the function <code>square</code>. Note the <code>**</code> operator used for exponentiation.</p>&#13;
<p class="indent">To load this program file into GHCi, use GHCi’s <code>:load</code> command (<code>:l</code> for short).</p>&#13;
<pre>Prelude&gt; :<span class="codestrong1">l first.hs</span>&#13;
[1 of 1] Compiling Main            ( first.hs, interpreted )&#13;
Ok, one module loaded.&#13;
*Main&gt; <span class="codestrong1">square 7</span>&#13;
49.0&#13;
*Main&gt; <span class="codestrong1">square e</span>&#13;
7.3890560989306495</pre>&#13;
<p class="indent">After we load <em>first.hs</em>, the GHCi prompt changes from <code>Prelude&gt;</code> to <code>*Main&gt;</code>. This indicates that our program file has been successfully loaded and given <span epub:type="pagebreak" id="page_18"/>the default name <code>Main</code>. We now have access to the constant and function defined in the file.</p>&#13;
<p class="indent">The names <code>e</code> and <code>square</code> defined in the file <em>first.hs</em> are examples of <em>variable identifiers</em> in Haskell. Variable identifiers must begin with a lowercase letter, followed by zero or more uppercase letters, lowercase letters, digits, underscores, and single quotes. Names that begin with an uppercase letter are reserved for types, type classes (which we’ll discuss in <a href="ch08.xhtml">Chapter 8</a>), and module names.</p>&#13;
<p class="indent">If you forget or don’t know the type of something, you can ask GHCi for the type with the <code>:type</code> command (<code>:t</code> for short).</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t square</span>&#13;
square :: Double -&gt; Double</pre>&#13;
<p class="indent">The notation used for defining a function in Haskell is similar to mathematical notation in some ways and different in a few others. Let’s comment on the differences. <a href="ch02.xhtml#ch2tab1">Table 2-1</a> shows a few examples.</p>&#13;
<p class="tabcap" id="ch2tab1"><strong>Table 2-1:</strong> Comparison of Function Definitions in Traditional Mathematical Notation with Function Definitions in Haskell</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Mathematical definition</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell definition</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>f</em>(<em>x</em>) = <em>x</em><sup>3</sup></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>f x = x**3</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>f</em>(<em>x</em>) = 3<em>x</em><sup>2</sup> – 4<em>x</em> + 5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>f x = 3 * x**2 - 4 * x + 5</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>g</em>(<em>x</em>) = cos 2<em>x</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>g x = cos (2 * x)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>v</em>(<em>t</em>) = 10<em>t</em> + 20</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>v t = 10 * t + 20</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><em>h</em>(<em>x</em>) = <em>e</em><sup><em>–x</em></sup></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>h x = exp (-x)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">First, notice that traditional mathematical notation (and some computer algebra systems) use juxtaposition to represent multiplication. For example, 2<em>x</em> means 2 multiplied by <em>x</em>, just because the symbols are next to each other. Haskell requires use of the multiplication operator <code>*</code>. In Haskell, juxtaposition means function application.</p>&#13;
<p class="indent">Next, notice that traditional mathematical notation requires that function arguments be put in parentheses after the function name. This is true for function definitions (compare <em>f</em> (<em>x</em>) = <em>x</em><sup>3</sup> with Haskell’s <code>f x = x**3</code>) as well as function applications (compare <em>f</em> (2) with Haskell’s <code>f 2</code>). Haskell does not require parentheses in function definition or application. Haskell uses parentheses to indicate the order of operations.</p>&#13;
<p class="indent">Lastly, traditional mathematical notation tries to get away with single-letter function names, such as <em>f</em> . Haskell allows single-letter function names, but it is much more common to use a multi-letter word for a function name (such as <code>square</code> above), especially when the word can serve as a good description of what the function does.</p>&#13;
<h3 class="h3" id="ch2lev2"><span epub:type="pagebreak" id="page_19"/>How We Talk About Functions</h3>&#13;
<p class="noindent">Suppose we define a function <em>f</em> as <em>f</em> (<em>x</em>) = <em>x</em><sup>2</sup> – 3<em>x</em> + 2. It’s common in mathematics and physics to speak of “the function <em>f</em> (<em>x</em>).” Haskell invites us to think a bit more carefully and precisely about this bad habit. (Well, it really <em>requires</em> us to think more carefully about it, but it’s always nicer to be invited than required, no?) Instead of saying “the function <em>f</em> (<em>x</em>),” we should say one of the following, depending on what we mean:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">The function <em>f</em></li>&#13;
<li class="noindent">The value <em>f</em> (<em>x</em>)</li>&#13;
<li class="noindent">Given a number <em>x</em>, the value of the function <em>f</em> at <em>x</em></li>&#13;
</ul>&#13;
<p class="indent">The second and third bullet points are two ways of saying the same thing. The first bullet point is saying something different from the second and third.</p>&#13;
<p class="indent">What’s wrong with saying “the function <em>f</em> (<em>x</em>)?” It’s common in mathematics and physics to use “the function <em>f</em>” and “the function <em>f</em> (<em>x</em>)” interchangeably, with the second expression merely indicating explicitly that <em>f</em> depends on <em>x</em>. We think of mathematical notation as being a precise representation of an idea, but this is a case where the commonly used notation is not precise.</p>&#13;
<p class="indent">One reason for shunning the language “the function <em>f</em> (<em>x</em>)” is that if <em>f</em> (<em>x</em>) = <em>x</em><sup>2</sup> – 3<em>x</em> + 2, then <em>f</em> (<em>y</em>) = <sup><em>y</em>2</sup> – 3<em>y</em> + 2. The letter <em>x</em> really has nothing to do with the function <em>f</em> . Granted, we need <em>some</em> letter to use to make the definition, but it doesn’t matter which one. We call <em>x</em> a <em>dummy variable</em> when it’s used to define something else.</p>&#13;
<p class="indent">In Haskell, we say <em>f</em> (<em>x</em>) when we want to evaluate the function <em>f</em> using the input <em>x</em>. We say <em>f</em> when we want to speak about the function itself, not evaluate it (that is, not give it any input). What else is there to do with a function except give it an input? Well, you could <em>integrate</em> the function between given limits. You could <em>differentiate</em> the function to obtain another function. You could, in some cases, apply the function twice. In short, there are many things we might want to do with a function other than simply evaluating it.</p>&#13;
<p class="indent">Haskell’s type system helps us understand the key distinction between <em>f</em> and <em>f</em> (<em>x</em>). The variable <em>x</em> is a number, so it has a type like <code>Double</code>. Now <em>f</em> is a function, so it has a type like <code>Double -&gt; Double</code>. Finally, <em>f</em> (<em>x</em>) means the function <em>f</em> evaluated at the number <em>x</em>, so <em>f</em> (<em>x</em>) has type <code>Double</code>. Things that have type <code>Double -&gt; Double</code> are functions. Things that have type <code>Double</code> are numbers. The table below summarizes these distinctions.</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Math notation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell notation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>f</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>f</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Double -&gt; Double</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>f</em> (3)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>f 3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Double</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><em>f</em> (<em>x</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>f x</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>Double</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Computers are notorious for being inflexible in understanding what a person means. Computers look at exactly what you say, and they give warnings and errors if your input doesn’t meet their requirements for format and <span epub:type="pagebreak" id="page_20"/>interpretation. Most of the time, this is a pain in the neck. We would like to have an assistant that understands what we mean and does what we want.</p>&#13;
<p class="indent">However, in the case of types and functions, Haskell’s inflexibility is a great teaching aid. Haskell is helping us to organize our thinking so we will be prepared to do more complex things in a structured and organized way. In <a href="ch06.xhtml">Chapter 6</a>, which covers higher-order functions, we’ll see examples of how careful thinking about types and functions allows us to encode more complex ideas simply and easily.</p>&#13;
<p class="indent">When we use Haskell, we make a trade-off. We agree to use language in a precise and careful way (the compiler is going to check us on this), and in exchange, we’ll be able to say things in the language that are rather complex and difficult to say in a language that accommodates imprecision. Thus, we’ll be able expose the essential structure of a physical theory like Newtonian mechanics.</p>&#13;
<h3 class="h3" id="ch2lev3">Anonymous Functions</h3>&#13;
<p class="noindent">Haskell provides a way to specify a function without naming it. For example, the function that squares its argument can be written as <code>\x -&gt; x**2</code>.</p>&#13;
<p class="indent">A function specified in this way is called an <em>anonymous function</em> or a <em>lambda function</em> after the lambda calculus developed by Alonzo Church in the 1930s. (Church was Alan Turing’s PhD advisor.) The backslash character (<code>\</code>) was thought by Haskell’s creators to look a bit like the lowercase Greek letter lambda (<em>λ</em>).</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2tab2">Table 2-2</a> shows examples of mathematical functions written as lambda functions. This is an alternative way to define the functions in <a href="ch02.xhtml#ch2tab1">Table 2-1</a>.</p>&#13;
<p class="tabcap" id="ch2tab2"><strong>Table 2-2:</strong> Comparison of Function Definitions in Traditional Mathematical Notation with Lambda Functions Defined in Haskell</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Mathematical function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell lambda function</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>f</em> (<em>x</em>) = <em>x</em><sup>3</sup></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>f = \x -&gt; x**3</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>f</em> (<em>x</em>) = 3<em>x</em><sup>2</sup> – 4<em>x</em> + 5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>f = \x -&gt; 3 * x**2 - 4 * x + 5</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>g</em>(<em>x</em>) = cos 2<em>x</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>g = \x -&gt; cos (2 * x)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>v</em>(<em>t</em>) = 10<em>t</em> + 20</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>v = \t -&gt; 10 * t + 20</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><em>h</em>(<em>x</em>) = <em>e</em><sup><em>–x</em></sup></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>h = \x -&gt; exp (-x)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The real power of lambda functions comes from using them in places where we need a function but don’t want to spend the effort (that is, a declaration and a definition) to name a new function. We’ll see examples of how this is useful in <a href="ch06.xhtml">Chapter 6</a>, where we discuss higher-order functions that take other functions as input. These other functions are sometimes conveniently expressed as anonymous functions.</p>&#13;
<p class="indent">We can apply the anonymous squaring function <code>\x -&gt; x**2</code> to the argument 3 by writing <code>(\x -&gt; x**2) 3</code> at the GHCi prompt.</p>&#13;
<span epub:type="pagebreak" id="page_21"/>&#13;
<pre>*Main&gt; <span class="codestrong1">(\x -&gt; x**2) 3</span>&#13;
9.0</pre>&#13;
<p class="indent">Notice that when we write <code>\x -&gt; x**2</code>, we are <em>not</em> defining what <code>x</code> is. Instead we are saying that if we temporarily allow <code>x</code> to stand for the argument of the function (such as <code>3</code> above), we have a rule for determining the value of the function applied to the argument. The same remark is true of (named) mathematical functions; when we define <em>f</em> (<em>x</em>) = <em>x</em><sup>2</sup>, this is a definition for <em>f</em>, not a definition for <em>x</em>. The function <code>\x -&gt; x**2</code> is the same as the function <code>\y -&gt; y**2</code>; the variable we use to name the argument is not important. Both are the function that squares its argument.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2tab3">Table 2-3</a> shows examples of the application of anonymous functions to an argument.</p>&#13;
<p class="tabcap" id="ch2tab3"><strong>Table 2-3:</strong> Examples of Applying Anonymous Functions to an Argument</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>(\x -&gt; x**2) 3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">9.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(\y -&gt; y**2) 3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">9.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>(\x -&gt; x**3) 3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">27.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(\x -&gt; 3 * x**2 - 4 * x + 5) 3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">20.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>(\x -&gt; cos (2 * x)) pi</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(\t -&gt; 10 * t + 20) 3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">50</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>(\x -&gt; exp (-x)) (log 2)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">0.5</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These examples can be evaluated at the GHCi prompt.</p>&#13;
<h3 class="h3" id="ch2lev4">Composing Functions</h3>&#13;
<p class="noindent">Writing cos<sup>2</sup> <em>x</em> is shorthand for (cos <em>x</em>)<sup>2</sup>, which means “take the cosine of <em>x</em> and then square the result.” When we use the output of one function <em>f</em> as the input to another function <em>g</em>, we are <em>composing</em> the two functions to produce a new function. We write <em>g</em> ∘<em>f</em>, called <em>g after f</em>, for the function that applies <em>f</em> to its input and then applies <em>g</em> to the result.</p>&#13;
<div class="imagec"><img src="Images/021equ01.jpg" alt="Image" width="418" height="21"/></div>&#13;
<p class="indent">The <em>function composition operator</em> (<code>.</code>) from <a href="ch01.xhtml#ch1tab2">Table 1-2</a> serves the role that ∘ serves in mathematical notation. The following four functions are equivalent ways of defining the cosine squared function:</p>&#13;
<pre>cosSq :: Double -&gt; Double&#13;
cosSq x = square (cos x)&#13;
&#13;
cosSq' :: Double -&gt; Double&#13;
cosSq' x = square $ cos x&#13;
&#13;
cosSq'' :: Double -&gt; Double&#13;
cosSq'' x = (square . cos) x&#13;
&#13;
cosSq''' :: Double -&gt; Double&#13;
cosSq''' = square . cos</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>The first function, <code>cosSq</code>, defines the square of the cosine of a number in the most straightforward way. It’s clear from the parentheses that the cosine acts on <code>x</code> first, and then the function <code>square</code> gets applied. The second function, <code>cosSq'</code>, does the same thing, but it uses the function application operator <code>$</code> instead of parentheses (see “The Application Operator” in <a href="ch01.xhtml">Chapter 1</a> ). The third function, <code>cosSq''</code>, shows how the composition operator can be used to compose the functions <code>square</code> and <code>cos</code>. The expression <code>square . cos</code> is like the <em>g</em> ∘<em>f</em> on the left side of Equation 2.1, where <code>square</code> plays the role of <em>g</em> and <code>cos</code> plays the role of <em>f</em> . The fourth function, <code>cosSq'''</code>, shows how Haskell lets us define a function without mentioning the argument to which it will be applied. Such a definition is called <em>point-free style</em>. If <em>h</em> is the function defined by <em>h</em>(<em>x</em>) = <em>g</em>(<em>f</em> (<em>x</em>)), mathematical notation allows us to alternatively define <em>h</em> by <em>h</em> = <em>g</em> ∘<em>f</em>. The function <code>cosSq''</code> expresses the former definition, and the function <code>cosSq'''</code> expresses the latter. If you feel the need to define a cosine squared function, any of the four functions would be perfectly acceptable. The choice is a matter of style. The last definition is my favorite because of its concision.</p>&#13;
<p class="indent">The definitions just shown are examples of Haskell’s delightful feature of allowing tick marks (single quotes) in identifiers. This is nice because it supports our mathematical usage of the concise “<em>x</em> prime” for something that is related to <em>x</em>.</p>&#13;
<p class="indent">The function composition operator can be used between any two functions in which the output type of the first function applied matches the input type of the second. In practice, the function composition operator often serves as a way to avoid naming a new function. If the functions <code>square</code> and <code>cos</code> are available, there is really no need to make any of the four definitions because <code>square . cos</code> is a perfectly good function that can be used anywhere <code>cosSq</code> can be.</p>&#13;
<h3 class="h3" id="ch2lev5">Variable Not in Scope Error</h3>&#13;
<p class="noindent">One of the simplest types of error comes from using a name that has not been defined. If we ask GHCi for the value of <code>x</code> without having defined <code>x</code>, we’ll get a “Variable not in scope” error.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">x</span>&#13;
&#13;
&lt;interactive&gt;:6:1: error: Variable not in scope: x</pre>&#13;
<p class="indent">The <em>scope</em> of a name is the set of situations in which the name can be used and properly understood by the compiler. The “Variable not in scope” <span epub:type="pagebreak" id="page_23"/>error might be better called “name not recognized.” Any name the compiler expects to recognize but doesn’t will produce this error. The error comes from the use of a name we haven’t defined or haven’t told the compiler where to find. This applies to functions, constants, and local variables (which we will introduce later)—essentially any entity that can have a name. Common identifiers, such as <code>x</code>, can be reused, and there are ways to unambiguously control which <code>x</code> we are referring to at a particular point in our program.</p>&#13;
<h3 class="h3" id="ch2lev6">Summary</h3>&#13;
<p class="noindent">In this chapter, we saw how to define functions in a source code file and load them into GHCi to use them. We showed how anonymous functions can be used in places where we need a function but don’t want to name it. The need for and usefulness of anonymous functions will become clearer in <a href="ch06.xhtml">Chapter 6</a>. The function composition operator can be used to compose any two functions in which the output type of the first matches the input type of the second. We saw how a “Variable not in scope” error can arise when the computer thinks it should know the meaning of a name but doesn’t. In the next chapter, we’ll look more deeply into Haskell’s system of types, which provides a powerful tool to organize our thinking and reflect that organization in our writing.</p>&#13;
<h3 class="h3" id="ch2lev7">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 2.1.</strong> In a Haskell program file (a new file with a new name that ends in <em>.hs</em>), define the function <img class="inline" src="Images/023equ01.jpg" alt="Image" width="124" height="25"/>. As we did for the function <code>square</code>, give both a type signature and a function definition. Then load this file into GHCi and check that <em>f</em> (0) gives 1, <em>f</em> (1) gives about 1.414, and <em>f</em> (3) gives 2.</p>&#13;
<p class="noindentts"><strong>Exercise 2.2.</strong> Consider throwing a rock straight upward from the ground at 30 m/s. Ignoring air resistance, find an expression <em>y</em>(<em>t</em>) for the height of the rock as a function of time.</p>&#13;
<p class="indent">Add on to your program file <em>first.hs</em> by writing a function</p>&#13;
<pre>yRock30 :: Double -&gt; Double</pre>&#13;
<p class="noindent">that accepts as input the time (after the rock was thrown) in seconds and gives as output the height of the rock in meters.</p>&#13;
<p class="noindentts"><strong>Exercise 2.3.</strong> Continuing with the rock example, write a function</p>&#13;
<pre>vRock30 :: Double -&gt; Double</pre>&#13;
<p class="noindentts">that accepts as input the time (after the rock was thrown) in seconds and gives as output the upward velocity of the rock in meters per second. (A downward velocity should be returned as a negative number.)</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_24"/><strong>Exercise 2.4.</strong> Define a function <code>sinDeg</code> that computes the sine of an angle given in degrees. Test your function by evaluating <code>sinDeg 30</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 2.5.</strong> Write Haskell function definitions for the following mathematical functions. In each case, write a type signature (the type should be <code>Double -&gt; Double</code> for each function) and a function definition. You will need to pick alternative names for some of these functions because Haskell functions must begin with a lowercase letter. Do not use more than two levels of nested parentheses.</p>&#13;
<p class="alphats">(a) <img class="inline" src="Images/024equ01.jpg" alt="Image" width="82" height="23"/></p>&#13;
<p class="alphats">(b) <em>g</em>(<em>y</em>) = <em>e<sup>y</sup></em> + 8<sup><em>y</em></sup></p>&#13;
<p class="alphats">(c) <img class="inline" src="Images/024equ02.jpg" alt="Image" width="185" height="53"/></p>&#13;
<p class="alphats">(d) <img class="inline" src="Images/024equ03.jpg" alt="Image" width="138" height="52"/></p>&#13;
<p class="alphats">(e) <img class="inline" src="Images/024equ04.jpg" alt="Image" width="187" height="44"/></p>&#13;
<p class="alphats">(f) <img class="inline" src="Images/024equ05.jpg" alt="Image" width="133" height="25"/></p>&#13;
<p class="alphats">(g) <img class="inline" src="Images/024equ06.jpg" alt="Image" width="95" height="46"/></p>&#13;
<p class="alphats">(h) <img class="inline" src="Images/024equ07.jpg" alt="Image" width="152" height="49"/></p>&#13;
<p class="noindentt"><strong>Exercise 2.6.</strong></p>&#13;
<p class="alpha">(a) Express <img class="inline" src="Images/024equ08.jpg" alt="Image" width="138" height="53"/> as an anonymous function.</p>&#13;
<p class="alphats">(b) Write an expression that applies the anonymous function from part (a) to the argument 0.8. What result do you get from GHCi?</p>&#13;
</div></body></html>