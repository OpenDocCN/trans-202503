<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="177" id="Page_177"/>10</span><br/>
<span class="ChapterTitle">Working with Video</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c10-0001" class="HeadProject"><span><span epub:type="pagebreak" title="178" id="Page_178"/>Sketch 80: Playing a Video</span></h2>
<p class="BodyFirst">We can use Processing to play videos but, as was the situation with audio, Processing does not have its own facility for doing so. Instead, we use the <code>Movie</code> class from the <code>processing.video</code> library, which in turn uses the underlying Java-based video functions. As a first example, this sketch will load and display a short video.</p>
<p>First, we import the <code>processing.video</code> library <span class="CodeAnnotation" aria-label="annotation1">1</span> as the first line in the program:</p>
<pre><code>import processing.video.*;</code></pre>
<p>Now we can declare an instance of the <code>Movie</code> class <span class="CodeAnnotation" aria-label="annotation2">2</span>, one for each movie we want to play:</p>
<pre><code>Movie movie;</code></pre>
<p>We load the video file when we initialize the class instance by calling its constructor (see Sketch 43), specifying the name of the file as a parameter <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>movie = new Movie(this, "car.avi");</code></pre>
<p>In the <code>setup()</code> function, we begin reading the video from the file by calling the <code>movie.play()</code> function (which doesn’t just play the video, as you’d expect). A video is a sequence of compressed images or frames, just like an animation, and each one can take some significant time to read and decode. After we call <code>play()</code>, the system tries to read frames from the file, and when one is ready, the <code>available()</code> function returns <code>true</code>. We can then acquire the frame using <code>read()</code>. Like a <code>PGraphics</code> object, a <code>Movie</code> object can be treated as an image and displayed using the <code>image()</code> function. Thus, this is the process for displaying a movie <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>if (movie.available()) 
{
  movie.read();
  image (movie, 0, 0);
}</code></pre>
<p>If no new frame were available, <code>read()</code> would not be called, and the previously read frame would be displayed in its place. This is usually not noticeable.</p>
<p>The <code>Movie</code> class plays the sound with the movie.</p>
<p>The sketch also prints relevant information at the top of the window. It counts the number of frames read in and displays that number. It also displays the <span class="KeyTerm">time count</span>, which is the number of seconds that have been played so far, retrieved using the <code>movie.time()</code> function call <span class="CodeAnnotation" aria-label="annotation5">5</span>. When the movie is complete, as indicated by <code>movie.time() &gt;= movie.duration()</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>, the counters reset and the movie resumes playing from the first frame by calling <code>movie.jump(0)</code>. The <code>jump(t)</code> function call moves the current frame to the one at time <code>t</code>. Playing in a loop could also be accomplished by calling <code>movie.loop()</code> instead of <code>movie.play()</code>. In that case, the replaying of the movie from location 0 would be automatic.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> import processing.video.*;

boolean playing = true;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> Movie movie; 
int frame = 1;

void setup () 
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> movie = new Movie(this, "car.avi"); // Create the instance of Movie
  size(320, 300);
  movie.play();    // Start playing
}

void draw () 
{
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (movie.available())   // New frame?
  {
    movie.read();          // Read it
    frame = frame + 1;     // Count it
  }
  image(movie,0,0);        // Display the current frame
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> text ("Frame "+frame+"  Time: "+ (float)((int)(movie.time()*100))/100, 10, 20);
  <span class="CodeAnnotationHang" aria-label="annotation6">6</span> if (movie.time() &gt;= movie.duration())  // End
  {
    frame = 1; movie.jump(0);  // Restart the counters. Rewind.
  }
}

void mouseReleased ()
{
  if (playing) 
  {
    movie.pause();
    playing = false;
  } else 
  {
    movie.play();
    playing = true;
  }
}</code></pre>
<span epub:type="pagebreak" title="179" id="Page_179"/><figure class="graphic"><img src="Images/g080001.png" alt="g080001" width="320" height="299"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c10-0002" class="HeadProject"><span><span epub:type="pagebreak" title="180" id="Page_180"/>Sketch 81: Playing a Video with a Jog Wheel</span></h2>
<p class="BodyFirst">A<span class="KeyTerm"> jog wheel</span> (or <span class="KeyTerm">shuttle dial</span>) is a device, often circular, that allows the user to advance or back through a video. Turning it clockwise moves the video forward by individual frames, and turning it counterclockwise moves the video backward. Editors often use this for editing where the video needs to be positioned frame by frame. This sketch will implement an approximation of this <span class="KeyTerm">jogging</span> process. The video will begin to play, and the user can adjust the speed and direction of play using the mouse. At any point, the user can stop the video and back up slowly to arrive at any specific frame.</p>
<p>To do this we have to address the problem of how to play a video backward. The <code>jump()</code> function permits the positioning of the video at any moment in time <span class="CodeAnnotation" aria-label="annotation2">2</span>. The time of any particular frame depends on the frame rate, which is the number of frames played per second. Given a frame rate of <code>rate</code>, we know that each frame lasts 1/<code>rate</code> seconds. The final frame occurs at <code>duration()</code> seconds from the start, so positioning at the frame before that could be done with the following call:</p>
<pre><code>movie.jump (movie.duration-(1/rate))</code></pre>
<p class="BodyContinued">The frame before that one is at <code>movie.jump (movie.duration-(1/rate)*2)</code> and so on. Simply step backward through the frames in this way, read the frame, and display it. </p>
<p>In the sketch, we store the time of the current frame in a <code>time</code> variable, and the time between frames is in the variable <code>ftime</code>. We will use the mouse to control the speed with which the video will be displayed. A mouse click in the middle of the screen sets the speed to 0 by setting <code>ftime</code> to 0. A click on the right sets <code>ftime</code> to a value in proportion to the distance from the middle, and it moves the video forward; a click on the left sets <code>ftime</code> to a value that moves the video backward. Initially <code>ftime = 1/rate</code>, but this becomes −3 times that for a far left click and +3 times that for a far right click. This is the whole calculation <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>ftime = 3*((float)(width/2 - mouseX)/(width/2))/rate;</code></pre>
<p>A minor problem occurs at the end of the video, which is really the beginning if it is playing in reverse. Time is set to 0 if the end is found while moving forward, and it is set to <code>duration()-ftime</code> if the beginning is found while moving backward. </p>
<p>The basic display process <span class="CodeAnnotation" aria-label="annotation1">1</span> occurs within <code>draw()</code> and is as follows:</p>
<pre><code>if (movie.available())  movie.read();  // Read a frame if one is there
image(movie,0,0);                      // Display it
time = time - ftime;                   // Advance/retard the time value
movie.jump(time);                      // Set frame to the one at that time</code></pre>
<p>The sketch displays a simple calibration to allow the user to select a speed, and it also displays the value of <code>ftime</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import processing.video.*;

boolean playing = true;
Movie movie; 
float time = 1, ftime = 1, rate = 20;

void setup () 
{  
  movie = new Movie(this, "car.avi"); 
  size(320, 300); 
  ftime = 1.0/rate;
  time = movie.duration() - ftime;
  movie.play();    // Start playing
  fill (0);
}

void draw () 
{
  background(200);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (movie.available())  movie.read();          // Read it
  image(movie,0,0);        // Display the current frame
  text ("  Time: "+ (float)((int)(movie.time()*100))/100, 10, 20);
  time = time - ftime;     // Control which is the next frame
  movie.jump(time);
  if ( (time &lt; 0) || (time&gt;movie.duration()) )
  {
    if (time&lt;0) time = movie.duration() - ftime; 
    else time = 0;
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> movie.jump(time);      // Restart the counters. Rewind.
  }
  text ("Mouse click controls speed and direction", 50, 260);
  text (" Reverse                                                 Forward", 30, 275);
  ellipse (160, 245, 3, 3);
  for (int i=160; i&lt;320; i=i+30) ellipse (i, 245, 1, 1);
  for (int i=160; i&gt;0; i=i-30) ellipse (i, 245, 1, 1);
  text (""+  -((int)(ftime*100))/100.0, 150, 275);
}

void mouseReleased ()
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (mouseX &lt; width/2) ftime = 3*((float)(width/2 - mouseX)/(width/2))/rate;
  else  ftime = -3*(float)(mouseX-(width/2))/(width/2)/rate;

}</code></pre>
<span epub:type="pagebreak" title="181" id="Page_181"/><figure class="graphic"><img src="Images/g081001.png" alt="g081001" width="342" height="320"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c10-0003" class="HeadProject"><span><span epub:type="pagebreak" title="182" id="Page_182"/>Sketch 82: Saving Still Frames from a Video</span></h2>
<p class="BodyFirst">This sketch will allow the user to save a set of still image frames from a video. The video is played in a loop so that the user can select all of the frames they need. Clicking the mouse will start saving images, and clicking again will stop it. </p>
<p>Saving frames is accomplished using the <code>save()</code> function of the <code>Movie</code> class object. If <code>movie</code> is a <code>Movie</code> object, the following call saves the current frame in the named file as the type indicated by the file extension:</p>
<pre><code>movie.save("name.jpg");</code></pre>
<p class="BodyContinued">This is the same way we save <code>PImage</code> pictures. In this case, we save a JPEG, but GIF, PNG, and other file formats work too. </p>
<p>To save multiple frames without overwriting the same file each time, we might use the number of stills that we have already saved, stored in the variable <code>v</code>, in the filename, as follows: </p>
<pre><code>movie.save("frame"+v+".jpg");</code></pre>
<p class="BodyContinued">This means that the filenames would be <em>frame1.jpg</em>, <em>frame2.jpg</em>, and so on. </p>
<p>With this labeling scheme, however, there’s no way to tell where one saved sequence ends and the next one begins. This sketch solves that problem by using the variable <code>nclicks</code> in conjunction with <code>v</code>. When the user clicks the mouse while the frames are being saved, then saving ceases, <code>nclicks</code> is incremented, and <code>v</code> is reset. We build a filename using the frame count and a letter that is relative to the <code>nclicks</code> variable: <code>nclicks</code> = 0 adds the letter “<code>a</code>” to the name, <code>nclicks </code>= 1 adds “<code>b</code>” to the name, and so on. The file for each frame is actually saved as follows <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>movie.save("frame"+char(nclicks+int('a'))+v+".jpg");</code></pre>
<p>The first sequence would be <em>framea1.jpg</em>, <em>framea2.jpg</em>, . . . and the second would be <em>frameb1.jpg</em> and so on.</p>
<p>The sketch draws the time on the screen, but this is for the user—it will not appear on the saved image.  </p>
<p>Another way to save video frames is to display them in the sketch window and then save the sketch window as an image. If we did that in this case, the time drawn on the window would in fact be saved to the file with the image. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import processing.video.*;

boolean saving = false;
Movie movie; 
float time = 1, rate = 20;
int frame = 1, v = 0;
int nclicks = 0;

void setup () 
{  
  movie = new Movie(this, "car.avi"); // Create the instance of Movie
  size(320, 300);
  movie.frameRate(rate);
  movie.play();    // Start playing
  fill (0);
}

void draw () 
{
  if (saving) background (0, 200, 20);
  else background(200);
  if (movie.available())  
  {
    movie.read();            // Read it
    image(movie,0,0);        // Display the current frame
    if (saving)
    {
      v++;
      <span class="CodeAnnotationHang" aria-label="annotation1">1</span> movie.save("frame"+ char(nclicks+int('a'))+v+".jpg");
      frame = frame + 1;
    }
  } else image(movie,0,0);

  text ("  Time: "+ (float)((int)(movie.time()*100))/100, 10, 20);
  if (saving) text ("Saving file "+frame, 20, 275);
  if ( movie.time() &gt;= movie.duration() )
    movie.jump(0);  // Restart the video
}

void mouseReleased ()
{
  saving = !saving;
  if (!saving) {
    nclicks = nclicks + 1;
    v = 0;
  }
  if (nclicks &gt; 25) nclicks = 0;
}</code></pre>
<span epub:type="pagebreak" title="183" id="Page_183"/><figure class="graphic"><img src="Images/g082001.png" alt="g082001" width="326" height="305"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c10-0004" class="HeadProject"><span><span epub:type="pagebreak" title="184" id="Page_184"/>Sketch 83: Processing Video in Real Time</span></h2>
<p class="BodyFirst">Some applications process or analyze a video frame by frame, and it is not necessary to see the result in real time. For example, it is possible to analyze a batter’s swing by capturing a video, enhancing relevant portions in each frame, and then putting the enhanced frames back in video form. It is even possible, when the analysis of each frame does not require too much computational effort, to do the processing as the video is playing and see the result as the action is going on. </p>
<p>In this sketch, the video that we used in the previous two sketches will be converted to grayscale and then <span class="KeyTerm">thresholded</span> in real time, just as we did in Sketch 23 for a still image.</p>
<p>Recall that we can treat a <code>Movie</code> object just like a <code>PImage</code> (they have the same local functions). We extract each pixel <code>p</code> in the movie image using <code>movie.loadPixels()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and calculate a brightness or grey level by averaging the color components: <code>(red(p)+green(p)+blue(p))/3</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. If this value is less than a threshold, the corresponding pixel in the display image is set to black; otherwise it is set to white. In this sketch, the threshold value is 100. The result is a video that displays only black and white pixels. </p>
<p>The setup is the same as before, but we also create a second image the size of a video frame (named <code>display</code>) that will hold a processed copy of each frame as it is displayed. The <code>draw()</code> function reads a frame when it is ready and then calls a local <code>thresh()</code> function to calculate a thresholded image. After <code>thresh()</code> has created a thresholded version of the movie image, both are displayed, one above the other, and both versions play simultaneously. </p>
<p>The result in this case is unimpressive, but it does give an idea of what we could do. For example, if we choose the threshold carefully, it might be possible to show only the motion of the car in the scene, removing the background clutter.</p>
<p>In other videos, we could locate faces, enhance and read license plates on moving cars, or inspect and count apples moving past the camera on a conveyor belt. These are problems in <span class="KeyTerm">computer vision</span>, and Processing is a good tool for building computer vision systems because of the ease with which it deals with images.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A tool called SimpleOpenNI is available for download from <a href="https://code.google.com/p/simple-openni/" class="LinkURL">https://code.google.com/p/simple-openni/</a>. It allows Processing to communicate with Kinect devices, which in turn allows us to acquire 3D images in real time. Microsoft uses this to build computer games, but there are many other potential uses, like the computer vision problems just described.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import processing.video.*;

PImage display;
Movie movie; 


void setup () 
{  // Create the instance of Movie
  movie = new Movie(this, "car.avi");  
  size(320, 480);
  movie.play();    // Start playing
  movie.frameRate(15);
  fill (0);
  display = createImage (320, 300, RGB);
}

void draw () 
{
  background (255);
  if (movie.available())  
  {
    movie.read();// Read it
    thresh();
  }
  image(display,0,0);
  image (movie, 0, 240);

  text ("  Time: "+ (float)((int)(movie.time()*100))/100, 10, 20);
}
void thresh ()
{
  color p,q;
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> movie.loadPixels();
  for (int i=0; i&lt;movie.pixels.length; i++)
  {
    p = movie.pixels[i];
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if ((red(p)+green(p)+blue(p))/3 &lt; 100) q = color(0,0,0);
    else q = color(255,255,2525);
    display.pixels[i] = q; 
   }
   display.updatePixels();
}</code></pre>
<span epub:type="pagebreak" title="185" id="Page_185"/><figure class="graphic"><img src="Images/g083001.png" alt="g083001" width="373" height="560"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c10-0005" class="HeadProject"><span><span epub:type="pagebreak" title="186" id="Page_186"/>Sketch 84: Capturing Video from a Webcam</span></h2>
<p class="BodyFirst">Webcams are present on most computers and almost all laptops. The previous sketches dealt with video that had already been <span class="KeyTerm">captured</span>, in the sense that a video file was available to be displayed or processed. This sketch will capture live video data from a webcam and display it in grayscale.</p>
<p>The <code>Capture</code> class deals with cameras and image/video capture. To use it, first declare an instance <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>Capture camera;</code></pre>
<p class="BodyContinued">Then initialize it using the class constructor. The class constructor may take only the parameter <code>this</code>, or <code>this</code> and a device specifier <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>Camera = new Capture (this);  
camera = new Capture (this, myCamera);</code></pre>
<p>The <code>myCamera</code> variable is a device specifier string of the following form:</p>
<pre><code>"name=USB2.0 HD UVC WebCam,size=160x120,fps=15"</code></pre>
<p>Much of the information in this string has an obvious meaning, and most is not absolutely necessary. If you know that the camera has a resolution of 640×480, the following call will open the camera:</p>
<pre><code>camera = new Capture (this, "size=640x480");</code></pre>
<p>Image capture begins with a call to <code>start()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>camera.start();</code></pre>
<p>As when playing a video, a frame is available when <code>camera.available()</code> returns <code>true</code>. The camera instance can now be treated like a <code>PImage</code> and be displayed with a call to <code>image()</code>.</p>
<p>This sketch copies the camera image into a <code>PImage</code> variable, <code>display</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. The function <code>grey()</code> converts the color image into a grey one, which is displayed in place of the original. The result is a moving grayscale image of what is being captured by the camera. Be patient—it can take some time to open the camera device.</p>
<p>The <code>Capture</code> class function <code>list()</code> looks at the camera devices available on the computer and returns a list of descriptors that can be used in the constructor. So, if this line</p>
<pre><code>String[] cameras = Capture.list();</code></pre>
<p class="BodyContinued">were to be followed by this</p>
<pre><code>for (int i=0; i&lt;cameras.length; i++)
  println (cameras[i]);</code></pre>
<p class="BodyContinued">then a list of available cameras would be printed to the window. We could select one and use the index for it in the code to select it from the <code>cameras[]</code> array. For instance, you could search for a camera that is 640×480 at 130 frames per second and find it as camera <code>i</code> in the list. Then you could use the selector you want by indexing the array:</p>
<pre><code>camera = new Capture (this, cameras[i]);</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import processing.video.*;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> Capture camera;
PImage display;
void setup () 
{
  String[] cameras = Capture.list();
    if (cameras.length == 0) 
    {
      println("There are no cameras.");
      exit();
    }
  
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> camera = new Capture(this, cameras[0]);
  display = createImage (640, 480, RGB);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> camera.start(); 
  size (640, 480);
}

void draw () 
{
  if (camera.available() == true) camera.read();
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> display.copy (camera, 0,0,640, 480, 0,0,640, 480);
  grey();
  image(display, 0, 0);  //  set(0, 0, camera);
}

void grey ()
{
  color p;
  int k;
  
  for (int i=0; i&lt;display.pixels.length; i=i+1)
  {
    p = display.pixels[i];
    k = (int)((red(p)+green(p)+blue(p))/3);
    display.pixels[i] = color(k,k,k);
  }
}</code></pre>
<span epub:type="pagebreak" title="187" id="Page_187"/><figure class="graphic"><img src="Images/g084001.png" alt="g084001" width="449" height="337"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c10-0006" class="HeadProject"><span><span epub:type="pagebreak" title="188" id="Page_188"/>Sketch 85: Mapping Live Video as a Texture</span></h2>
<p class="BodyFirst">In the previous sketches, you saw that a <code>Movie</code> object can be treated as a <code>PImage</code> for display purposes and even for extracting pixels from a video frame. This sketch shows the use of a video as a texture for a 3D surface, again like a <code>PImage</code>. The idea is to paint a four-cornered plane (a quad) with a movie so that the video plays on a 3D plane and is foreshortened as the user’s point of view changes.</p>
<p>The first part of the sketch sets up the webcam (as before), establishes the <code>camera</code> variable as a source of images, and establishes P3D as the current renderer. When executing, the system requires a few seconds to figure out what cameras are attached and which one to use. We do all of this, including starting the camera, by calling <code>start()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> in <code>setup()</code>.</p>
<p>In <code>draw()</code>, the first thing is to check if there is a new image available. If so, we read it; if not, then the previous image remains as the current one <span class="CodeAnnotation" aria-label="annotation2">2</span>. Then we establish a 3D environment, with a call to <code>camera</code> setting up the viewpoint <span class="CodeAnnotation" aria-label="annotation3">3</span>. We draw a quad in the 3D space and use the webcam as a texture <span class="CodeAnnotation" aria-label="annotation4">4</span>. The viewpoint oscillates a little bit (x between −30 and 100) <span class="CodeAnnotation" aria-label="annotation5">5</span> to show that the view is changing. </p>
<p>The effect is that the quad seems to continuously change location and orientation while the live video plays within the quad. An interesting variation on this would be to draw a rotating cube with the video mapped on all faces. This would show nothing new, but it would take more code.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="189" id="Page_189"/>import processing.video.*;
Capture camera;
float sx=30., sy=40., sz=12.;
int eyex=30, eyey=50, eyez=60;
int cx=20, cy=30, cz=12, dx=-1;

void setup ()
{
  String[] cameras = Capture.list();
  size (640, 480, P3D);

  if (cameras.length == 0)
  {
    println("There are no cameras.");
    exit();
  }

  camera = new Capture(this, cameras[0]);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> camera.start();
}

void draw ()
{
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (camera.available() == true) camera.read();
  background(255);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> camera(eyex, eyey, eyez, cx, cy, cz, 0, 1, 0);
  textureMode(NORMAL);
  beginShape (QUAD);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> texture (camera);
  vertex (0., 0., 0.,  0., 0.);
  vertex (sx, 0., 0.,  1., 0.);
  vertex (sx, sy, 0.,  1., 1.);
  vertex (0., sy, 0.,  0., 1.);
  endShape (CLOSE);
  eyex = eyex + dx;
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> if (eyex &lt; -30) dx = -dx;
  if (eyex &gt; 100) dx = -dx;
}</code></pre>
<figure class="graphic"><img src="Images/g085001.png" alt="g085001" width="506" height="380"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>