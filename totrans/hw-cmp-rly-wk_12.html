<html><head></head><body>
<span epub:type="pagebreak" id="page_261"/>&#13;
<h2 class="h2"><strong><span class="big">12</span><br/>THE WORLD WIDE WEB</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">The previous chapter described the internet, the globally connected set of computer networks that share a suite of protocols. The World Wide Web is a system built on top of the internet, one so popular that it is often confused with the internet itself. In this chapter, we dive into the details of the web. We first look at its key attributes and related programming languages, and then we look at web browsers and web servers.</p>&#13;
<h3 class="h3" id="lev1_90"><strong>Overview of the World Wide Web</strong></h3>&#13;
<p class="noindent">The <em>World Wide Web</em>, often just called the <em>web</em>, is a set of resources, delivered using <em>HyperText Transfer Protocol (HTTP)</em> over the internet. A web <em>resource</em> is anything that can be accessed using the web, such as a document or an image. A computer or software program that hosts web resources is called a <span epub:type="pagebreak" id="page_262"/><em>web server</em>, and a <em>web browser</em> is a type of application commonly used to access content on the web. Browsers are used to view documents known as <em>web pages</em>, and a collection of related web pages is known as a <em>website</em>. The web is distributed, addressable, and linked. Let’s begin by examining each of those core attributes.</p>&#13;
<h4 class="h4" id="lev2_38"><strong><em>The Distributed Web</em></strong></h4>&#13;
<p class="noindent">The World Wide Web is <em>distributed</em>. No centralized organization or system governs what content can be published to the web. Any computer connected to the internet can run a web server, and the owner of such a computer can make available any content they wish. That said, organizations or countries may choose to block users from accessing certain content on the web, and governments can shut down websites that host illegal content. Aside from those cases, the web is an open platform for publishing whatever people wish to publish, and no single organization controls what content is made available.</p>&#13;
<h4 class="h4" id="lev2_39"><strong><em>The Addressable Web</em></strong></h4>&#13;
<p class="noindent">The web uses <em>Uniform Resource Locators (URLs)</em> to give every resource on the web a unique address that includes both its location and how to access it. URLs are commonly referred to as <em>web addresses</em> or just <em>addresses</em>. To illustrate how these addresses are structured, let’s use a URL for a fictitious travel website, as shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>. This URL identifies a page with information about traveling to the Carolinas.</p>&#13;
<div class="image" id="ch12fig1"><img src="../images/fig12-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-1: An example URL</em></p>&#13;
<p class="indent">A URL is composed of multiple parts. The URL <em>scheme</em> identifies the application layer protocol for accessing the resource. In this case, the protocol is HTTP, which we’ll cover in more detail later. The colon (:) character indicates the end of the scheme portion. Following two forward slashes (//) is the <em>authority</em> portion of the URL. In this example, the authority portion contains a DNS hostname of the server(s) where the resource resides, <em>travel.example.com</em>. An IP address can be used here as well. Other information besides the host can also go in this section, such as a username (preceding the host and followed by an @ sign) or port number (following the host and prefixed with a colon). The <em>path</em> portion of the URL is next; it specifies the location of a resource on the web server. A URL path is analogous to a filesystem path, organizing resources into a logical hierarchy. In our example, the path <em>/destinations/carolinas</em> implies that the site has a collection of pages that describe travel destinations, and the particular page specified in the URL is a page about the Carolinas. We could reasonably assume that if the site had a page describing Florida as a destination, it would be found at <em>/destinations/florida</em>. Finally, the <em>query</em> portion of the <span epub:type="pagebreak" id="page_263"/>URL acts as a modifier to the resource returned to the client. In our example, the query indicates that the <em>carolinas</em> page should display locations at the beach. The format and meaning of the query portion of the URL varies from site to site.</p>&#13;
<p class="indent">A lot of information is packed into that URL, so let me restate how to read it in plain language. A website is running on a computer named <em>travel.example.com</em>. The site speaks HTTP, so use that protocol when connecting to the site. On that site there’s a page called <em>carolinas</em>, part of a collection of <em>destinations</em>. The query string directs the page to only show locations that are at the beach.</p>&#13;
<p class="indent">A URL does not have to include every element in the example in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>. It may also contain some elements not included in this example. A URL that includes only the scheme and the authority is perfectly valid, such as <em><a href="http://travel.example.com">http://travel.example.com</a></em>. In that scenario, the website serves its default page, since no path is provided.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch12ex1"><strong>EXERCISE 12-1: IDENTIFY THE PARTS OF A URL</strong></p>&#13;
<p class="exercise-para">For the following URLs, identify the scheme, username, host, port, path, and query. Not all URLs include all these parts.</p>&#13;
<ul>&#13;
<li class="noindent"><em><a href="https://example.com/photos?subject=cat&amp;color=black">https://example.com/photos?subject=cat&amp;color=black</a></em></li>&#13;
<li class="noindent"><em><a href="http://192.168.1.20:8080/docs/set5/two-trees.pdf">http://192.168.1.20:8080/docs/set5/two-trees.pdf</a></em></li>&#13;
<li class="noindent"><em><a href="mailto:someone@example.com">mailto:someone@example.com</a></em></li>&#13;
</ul>&#13;
<p class="exercise-parai">You can check your answers in <a href="appa.xhtml">Appendix A</a>.</p>&#13;
</div>&#13;
<p class="indent">A web browser typically displays the current URL in its address bar, as illustrated in <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>.</p>&#13;
<div class="image" id="ch12fig2"><img src="../images/fig12-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-2: The address bar</em></p>&#13;
<p class="indent">Today, it’s common for browsers to exclude the scheme, colon, and forward slashes in the address bar representation of the URL. This doesn’t mean these elements of the URL are no longer used by the browser. The browser is just trying to simplify things for users. The specifics of how the URL is displayed continue to change over time, with various browsers behaving differently.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig3">Figure 12-3</a> shows examples of how Google Chrome (version 77) displays URLs in its address bar.</p>&#13;
<span epub:type="pagebreak" id="page_264"/>&#13;
<div class="image" id="ch12fig3"><img src="../images/fig12-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-3: Chrome’s address bar</em></p>&#13;
<p class="indent">The top image in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a> shows the address bar when an HTTP site is loaded. Chrome doesn’t display the <em>http://</em> prefix in its address bar. Note the <code>Not secure</code> text. The lower image shows the address bar when an HTTPS site is loaded. HTTPS is the secure version of HTTP. Chrome omits the <em>https://</em> prefix but displays a padlock icon indicating this is an HTTPS site.</p>&#13;
<p class="indent">We’ve been discussing URLs in the context of web pages, but URLs extend to other resources on the web too. An image shown on a web page, for example, has its own URL, as does a script file or an XML data file. A web browser only shows the URL of the web page in its address bar, but a typical web page references various other resources by URL; the browser automatically loads those resources.</p>&#13;
<p class="indent">Sometimes it isn’t necessary to include the scheme, hostname, or even the full path in a URL. When a URL omits one or more of these elements, it’s known as a <em>relative URL</em>. A relative URL is interpreted as relative to the context in which it’s found. For example, if a URL like <em>/images/cat.jpg</em> is used on a web page, the browser that loads the page assumes that the scheme and hostname of the cat photo match the scheme and hostname of the page itself.</p>&#13;
<h4 class="h4" id="lev2_40"><strong><em>The Linked Web</em></strong></h4>&#13;
<p class="noindent">The nature of URLs, where every resource on the web has a unique address, makes it easy for one web resource to reference another. A reference from one web document to another is known as a <em>hyperlink</em>, or just a <em>link</em>. Such links are one-way; any web page can link to another page without permission or a reciprocal link. This system of pages linking to one another is what puts the “web” in World Wide Web. Documents like web pages that can be connected with hyperlinks are known as <em>hypertext</em> documents.</p>&#13;
<h4 class="h4" id="lev2_41"><strong><em>The Protocols of the Web</em></strong></h4>&#13;
<p class="noindent">The web is delivered using <em>HyperText Transfer Protocol (HTTP)</em>, and its secure variant, <em>HTTPS</em>.</p>&#13;
<h5 class="h5"><strong>HTTP</strong></h5>&#13;
<p class="noindent">Despite its name, HTTP isn’t just for transferring hypertext; it’s used for reading, creating, updating, and deleting all resources on the web. HTTP typically relies on TCP/IP. TCP ensures that data is reliably transferred, and IP handles host addressing. HTTP itself is based on a model of <em>request</em> and <em>response</em>. An HTTP request is sent to a web server, and the server replies with a response.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>Each HTTP request includes an <em>HTTP method</em>, also informally called an <em>HTTP verb</em>, that describes what kind of action the client is requesting of the server.</p>&#13;
<p class="indent">Some commonly used HTTP methods:</p>&#13;
<p class="block"><span class="codestrong">GET</span>   Retrieve a resource without modifying it.</p>&#13;
<p class="block"><span class="codestrong">PUT</span>   Create or modify a resource at a specific URL on the server.</p>&#13;
<p class="block"><span class="codestrong">POST</span>   Create a resource on the server, as a child of an existing URL.</p>&#13;
<p class="block"><span class="codestrong">DELETE</span>   Remove a resource from the server.</p>&#13;
<p class="indent">Any HTTP method can be attempted on any resource, but the server hosting a specific resource often won’t allow some methods on that resource. For example, most websites do not allow clients to delete resources. Those that do allow deletion almost always require the user to log on with an account that has permission to delete content.</p>&#13;
<p class="indent">The most commonly used method on a typical website is <code>GET</code>. When a web browser navigates to a website, the browser performs a <code>GET</code> on the requested page. That page may include references to scripts, images, and so forth, and the browser then also uses the <code>GET</code> method to obtain those resources before the page can be fully displayed.</p>&#13;
<p class="indent">Each HTTP response includes an <em>HTTP status code</em> that describes the server’s response. Each status code is a 3-digit number, where the most significant digit indicates the general class of response. Responses in the 100 range are informational. Responses in the 200 range indicate success. Responses in the 300 range indicate redirection. Responses in the 400s indicate an error on the client side—the request wasn’t properly formed by the client. A 500 range response means the server encountered an error.</p>&#13;
<p class="indent">Some commonly used HTTP status codes:</p>&#13;
<p class="block"><strong>200</strong>   Success. The server was able to fulfill the request.</p>&#13;
<p class="block"><strong>301</strong>   Moved Permanently. The browser should redirect the request to a different URL, specified in the response.</p>&#13;
<p class="block"><strong>401</strong>   Unauthorized. Authentication is required.</p>&#13;
<p class="block"><strong>403</strong>   Forbidden. The user doesn’t have access to the requested resource.</p>&#13;
<p class="block"><strong>404</strong>   Not Found. The server didn’t find the requested resource.</p>&#13;
<p class="block"><strong>500</strong>   Internal Server Error. Something unexpected happened on the server.</p>&#13;
<p class="indent">HTTP is fairly easy to understand. It uses human-readable text to describe requests and responses. The first line of a request includes an HTTP method, the URL of the resource, and the requested version of HTTP. Here’s an example:</p>&#13;
<pre>GET /documents/hello.txt HTTP/1.1</pre>&#13;
<p class="indent">This simply means that the client is asking the server to send it the content of <em>/documents/hello.txt</em> using HTTP version <code>1.1</code>. Following the request line, an HTTP request usually includes header fields that provide more information about the request and an optional message body.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_266"/>Similarly, an HTTP response uses a simple text format. The first line includes a version of HTTP, a status code, and a response phrase. Here’s an example of the first line of an HTTP response:</p>&#13;
<pre>HTTP/1.1 200 OK</pre>&#13;
<p class="indent">In this example response, the server is indicating a status code of <code>200</code> and a response phrase of <code>OK</code>. Just like HTTP requests, responses may also include header values and a message body. <a href="ch12.xhtml#ch12fig4">Figure 12-4</a> provides a more detailed, but still simplified, example of an HTTP request and response.</p>&#13;
<div class="image" id="ch12fig4"><img src="../images/fig12-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-4: A simplified HTTP request and response</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch12.xhtml#proj36">Project #36</a> on <a href="ch12.xhtml#page_283">page 283</a>, where you can look at HTTP network traffic</em>.</p>&#13;
</div>&#13;
<h5 class="h5"><strong>HTTPS</strong></h5>&#13;
<p class="noindent">A secure variation of HTTP known as <em>HTTPS (HyperText Transfer Protocol Secure)</em> is commonly used on the web to encrypt data sent over the internet. <em>Encryption</em> is the process of encoding data into a format that’s unreadable. <em>Decryption</em> is the reversal of encryption, making encrypted data readable again. Cryptographic algorithms encrypt and decrypt data using a secret sequence of bytes known as a <em>cryptographic key</em>. Because keys can be kept secret, the algorithm itself can be well-known.</p>&#13;
<p class="indent">HTTPS uses two kinds of encryption. <em>Symmetric encryption</em> uses a single <em>shared key</em> both for encrypting and decrypting a message. <em>Asymmetric encryption</em> uses two keys (a <em>key pair</em>): a <em>public key</em> is used to encrypt data, and a <em>private</em> <span epub:type="pagebreak" id="page_267"/><em>key</em> is used to decrypt data. Asymmetric encryption allows a public key to be shared freely so that anyone can encrypt and send data, whereas a private key is shared only with trusted parties who need to be able to receive and decrypt the data.</p>&#13;
<p class="indent">Without HTTPS, web traffic is transmitted “in the clear,” meaning it is unencrypted and can be intercepted or modified in transit by malicious parties. HTTPS helps to reduce these risks. With HTTPS, the entire HTTP request is encrypted, including the URL, headers, and body. The same is true of an HTTPS response; it’s fully encrypted. HTTPS takes an HTTP request and encrypts it using a protocol called <em>Transport Layer Security (TLS)</em>. In the past, a similar protocol called <em>Secure Sockets Layer (SSL)</em> was used, but due to security issues, it has since been deprecated in favor of TLS. When we speak of HTTPS, what we mean is HTTP encrypted with TLS.</p>&#13;
<p class="indent">When an HTTPS session begins, the client connects to the server with a <em>client hello</em> message with details of how it wishes to securely communicate. The server responds with a <em>server hello</em> message that confirms how the communication will occur. The server also sends a set of bytes known as a <em>digital certificate</em>, which includes the server’s public cryptographic key, used for asymmetric encryption. The client then checks if the server’s certificate is valid. If so, the client encrypts a string of bytes using the server’s public key and then sends the encrypted message to the server. The server decrypts the bytes using its private key. The server and client both use the information previously exchanged to compute a shared secret key, used for symmetric encryption. Once both client and server have the shared key, that key is used to encrypt and decrypt all communication between the client and server for the duration of the session.</p>&#13;
<p class="indent">HTTPS was previously only used in limited cases, for websites that dealt with particularly sensitive information. However, the web is moving to a state in which HTTPS is the norm rather than the exception. There is a growing belief that the security and privacy benefits of HTTPS make sense for most, if not all, traffic on the web. Google has encouraged this change, by marking HTTP sites as “Not secure” in Chrome and by using the presence of HTTPS as a positive signal to its search engine, helping to boost the Google search rank of HTTPS sites.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch12.xhtml#proj37">Project #37</a> on <a href="ch12.xhtml#page_285">page 285</a>, where you can set up a simple web server on your local network.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_42"><strong><em>The Searchable Web</em></strong></h4>&#13;
<p class="noindent">For many people, the typical entry point to the web is a search. Rather than navigate to a particular URL, a user types some search terms into their browser and sees what comes up. Browser design encourages this, since browsers commonly leverage the address bar as a search box too. Even when a user wants to visit a particular site, they often perform a search for that site, then click the <span epub:type="pagebreak" id="page_268"/>resulting link, rather than entering the full URL in the address bar. This is a design that enhances usability of the browser, even as it blurs the distinction between URLs and search terms, browser and search engine.</p>&#13;
<p class="indent">Despite the prevalence and usefulness of searching the web, the capability of searching isn’t a native feature of the web. There isn’t a standard specification for how searching should work. This means that searching, one of the key features of the web, relies on nonstandard, proprietary search engines. At the time of this writing, Google dominates the web searching space, and although there are good alternative search engines, their worldwide usage is a fraction of Google’s.</p>&#13;
<h3 class="h3" id="lev1_91"><strong>The Languages of the Web</strong></h3>&#13;
<p class="noindent">Any content that can be saved as a file can be hosted on the web. For example, a web server can host a collection of Excel files, and they can be downloaded from the website and opened in Excel. However, a web browser is much more than just a tool for downloading files to be opened in other applications. A web browser not only downloads content, but also renders web pages. These pages can be simple documents, or interactive web applications. To make this possible, browsers understand three computer languages, which are used to construct websites.</p>&#13;
<p class="block"><strong>HyperText Markup Language (HTML)</strong>   Defines the structure of a web page. In other words, it defines <em>what is on the page</em>. For example, HTML can specify that a button exists on a web page.</p>&#13;
<p class="block"><strong>Cascading Style Sheets (CSS)</strong>   Defines the appearance of a web page. In other words, it defines <em>how the page looks</em>. For example, CSS can specify that the aforementioned button is 30 pixels wide and blue.</p>&#13;
<p class="block"><strong>JavaScript</strong>   Defines the behavior of a web page. In other words, it defines <em>how the page functions</em>. For example, JavaScript can be used to add two numbers together when a button is clicked.</p>&#13;
<p class="indent">These three languages are used together to create the content of the web. It’s worth noting that web browsers are also capable of rendering some other data types too, notably certain image, video, and audio formats, but we won’t go into those in detail. Let’s now dive into each of the three foundational languages of the web: HTML, CSS, and JavaScript.</p>&#13;
<h4 class="h4" id="lev2_43"><strong><em>Structuring the Web with HTML</em></strong></h4>&#13;
<p class="noindent">HTML is a markup language that describes the structure of a web page. Note that HTML isn’t a programming language. A programming language describes operations that a computer should perform, whereas a markup language describes the structure of data. In the case of HTML, the data in question represents a web page. A web page can contain various elements such as paragraphs, headings, and images. Here’s an example of a simple web page described in HTML.</p>&#13;
<span epub:type="pagebreak" id="page_269"/>&#13;
<pre>&lt;!DOCTYPE html&gt;<br/>&#13;
&lt;html lang="en"&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;meta charset="utf-8"&gt;<br/>&#13;
    &lt;title&gt;A Cat&lt;/title&gt;<br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;h1&gt;Thoughts on a Cat&lt;/h1&gt;<br/>&#13;
    &lt;p&gt;This is a cat.&lt;/p&gt;<br/>&#13;
    &lt;img src="cat.jpg" alt="cat photo"&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">You see a number of items enclosed in less than (<code>&lt;</code>) and greater than (<code>&gt;</code>) signs. These are known as <em>HTML tags</em>, sets of text characters used to define the parts of an HTML document. As an example, the tag used to indicate the start of a paragraph is <code>&lt;p&gt;</code>. A corresponding tag is used to indicate the end of a paragraph, <code>&lt;/p&gt;</code>. Note the slash in the end tag, differentiating it from the start tag. An <em>HTML element</em> is a portion of the page beginning with a start tag, ending with an end tag, and including the content between the tags. For example, this is an HTML element: <code>&lt;p&gt;This is a cat.&lt;/p&gt;</code>. In truth, not all elements require an end tag. For example, the <code>img</code> element, used for representing an image, needs no end tag. You can see this in the previous HTML code example.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig5">Figure 12-5</a> shows how the example HTML might be rendered in a web browser.</p>&#13;
<div class="image" id="ch12fig5"><img src="../images/fig12-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-5: Our example web page rendered in a web browser</em></p>&#13;
<p class="indent">The document intentionally included no information about how it should be presented, so a browser uses a default font and size for the heading and <span epub:type="pagebreak" id="page_270"/>paragraph. In this example, the browser also defaulted to black text on a white background—again, that wasn’t specified in the document. Since this HTML example contains no style information, different browsers can choose to render this page slightly differently.</p>&#13;
<p class="indent">Let’s examine the HTML code example more closely. The first line of an HTML document declares that the file is an HTML document, like so: <code>&lt;!DOCTYPE html&gt;</code>. After that, an HTML document is structured as a tree, with parent elements and child elements. The <code>&lt;html&gt;</code> tag is the top-level parent tag; everything is enclosed between <code>&lt;html&gt;</code> and <code>&lt;/html&gt;</code>. You can interpret those two tags as “HTML starts here” and “HTML ends here.” This makes sense—everything in an HTML document should be HTML! The <code>&lt;html&gt;</code> tag also contains an attribute called <code>lang</code> that identifies the language of this document as <code>en</code>, the code for English.</p>&#13;
<p class="indent">The <code>html</code> element has two child elements: <code>head</code> and <code>body</code>. Elements contained in the head (between <code>&lt;head&gt;</code> and <code>&lt;/head&gt;</code>) describe the document, whereas elements in the body (between <code>&lt;body&gt;</code> and <code>&lt;/body&gt;</code>) make up the contents of the document.</p>&#13;
<p class="indent">In our example, the head contains two elements: a <code>meta</code> element describing the character set used to encode our document, and a <code>title</code>. Browsers typically show the title text on a page’s tab and use it as a default name when a user adds a bookmark or favorite. Search engines use the title text when showing results. For those reasons it’s important for web developers to give meaningful titles to their pages.</p>&#13;
<p class="indent">The body in our example includes an <code>&lt;h1&gt;</code> tag, which is used for a heading element. Heading tags of <code>&lt;h1&gt;</code> through <code>&lt;h6&gt;</code> are available, with <code>h1</code> intended to be used as the highest level of section headings, and <code>h6</code> as the lowest level. A paragraph follows the heading, indicated with a <code>&lt;p&gt;</code> tag, and after that an image is included using <code>&lt;img&gt;</code>. Note that the bytes of the image itself aren’t present in the HTML. Instead, the <code>&lt;img&gt;</code> tag simply references an image file by a relative URL (<em>cat.jpg</em>). To fully load this page, a browser needs to make a separate HTTP request to download the image. In this example, the image URL is simply a filename, meaning it’s hosted on the same server and in the same path as the document itself. If the image were hosted elsewhere, a URL with a path or a server name could be used. The <code>&lt;img&gt;</code> tag also has an <code>alt</code> attribute, which provides alternate text that describes the image. This is used in cases in which the image cannot be rendered, such as when a text-only browser or a screen reader that reads the contents of the page aloud is being used.</p>&#13;
<p class="indent">You may have noticed that the earlier HTML code used indentation to show the nesting of various elements on the page. For example, the <code>&lt;h1&gt;</code> and <code>&lt;p&gt;</code> tags are indented to the same level, showing that they are child elements of the <code>&lt;body&gt;</code> tag. This is a common practice in web development to improve readability of HTML, but it’s not required. In fact, whitespace beyond a single space or tab doesn’t matter in an HTML document! We could remove all the extra spaces, tabs, and line breaks, leaving us with the HTML all on a single line, and the document would render the same way in a browser. Web browsers ignore extra whitespace, so spacing out elements on a page is only helpful to developers.</p>&#13;
<span epub:type="pagebreak" id="page_271"/>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch12.xhtml#proj38">Project #38</a> on <a href="ch12.xhtml#page_287">page 287</a>, where you can have your local website return a document structured with HTML rather than simple text</em>.</p>&#13;
</div>&#13;
<p class="indent">The HTML elements we’ve covered so far are only a small percentage of the total elements recognized by web browsers. We won’t exhaustively cover all of HTML here; it is well documented online. The specifications for HTML were previously maintained by two organizations: the World Wide Web Consortium (W3C) and the Web Hypertext Application Technology Working Group (WHATWG). The last major version of HTML to receive “Recommendation” status from the W3C was <em>HTML5</em>. In 2019, the two organizations agreed that ongoing development of the HTML standard will be handled principally by the WHATWG, in what is known as the <em>HTML Living Standard</em>, which is continually maintained.</p>&#13;
<p class="indent">Modern browsers attempt to support both current and older versions of HTML, since plenty of web content was authored with earlier HTML standards in mind. In the past, browsers introduced nonstandard HTML elements, some of which eventually became standardized, while others fell out of use and lost support. Web browser developers must balance innovation with adherence to standards, while still supporting less-than-perfect HTML that’s sometimes found on the web. Web browsers are ever evolving, and different browsers sometimes render the same content differently. This means that web developers regularly test their creations on multiple browsers to ensure consistent behavior.</p>&#13;
<h4 class="h4" id="lev2_44"><strong><em>Styling the Web with CSS</em></strong></h4>&#13;
<p class="noindent">In our earlier example HTML, we used tags that described the structure of a document, but those tags did not convey any information about how the document should be presented. This was intentional; we want to keep structure and style separate. A division between the two allows for the same content to be rendered with different styles in different contexts. For example, most web content should be rendered differently on a large PC screen versus a small mobile screen.</p>&#13;
<p class="indent"><em>Cascading Style Sheets (CSS)</em> is the language used to describe the style of a web page. A style sheet is a list of rules. Each rule describes a style that should be applied to a certain part of the page. Each rule includes a selector, which indicates what elements on the page should have the style applied. The <em>cascading</em> term refers to the ability for multiple rules to apply to the same element. Let’s look at a simple example:</p>&#13;
<pre>p {<br/>&#13;
   font-family: Arial, Helvetica, sans-serif;<br/>&#13;
   font-size: 11pt;<br/>&#13;
   margin-left: 10px;<br/>&#13;
   color: DimGray;<br/>&#13;
}<br/>&#13;
 <br/>&#13;
h1 {<br/>&#13;
   font-family: 'Courier New', Courier, monospace;<br/>&#13;
   font-size: 18pt;<br/>&#13;
   font-weight: bold;<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_272"/>In this example, style rules are defined for paragraph (<code>p</code>) elements and heading 1 (<code>h1</code>) elements. When this CSS is applied to a page, all paragraphs on that page use the specified font, with a size of 11 point, a left margin of 10 pixels, and gray text. Similarly, h1 headings use the specified bolded font with a size of 18 point. Note that <code>font-family</code> is a list of fonts, not just a single font. This means that a web browser should try to find a matching font, starting with the leftmost font and proceeding to the right until a font match is found. Not every client device has the first choice of font installed; specifying multiple fonts increases the chance that a matching font will be available.</p>&#13;
<p class="indent">You can apply a style sheet to a web page in a couple of ways. One option is to include the CSS rules within a <code>style</code> element on the page. For example:</p>&#13;
<pre>&lt;style&gt;p {color: red};&lt;/style&gt;</pre>&#13;
<p class="indent">This isn’t ideal, because the style and structure are now closely related. A better option is to specify the CSS rules in a separate file, also hosted on the web. This approach keeps our HTML and CSS completely separate, and it allows multiple HTML files to use the same style sheet. This way we can change a CSS rule, and it will apply to multiple pages at once. A single element in the HTML’s head section can be used to apply the style sheet rules from a CSS file, like so (where <code>style.css</code> is the URL of the CSS file to apply):</p>&#13;
<pre>&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;</pre>&#13;
<p class="indent">If we apply this style sheet to our example cat page, we see these changes to the heading and paragraph text, as shown in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a>.</p>&#13;
<div class="image" id="ch12fig6"><img src="../images/fig12-6.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-6: Our example web page with CSS applied</em></p>&#13;
<span epub:type="pagebreak" id="page_273"/>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch12.xhtml#proj39">Project #39</a> on <a href="ch12.xhtml#page_288">page 288</a>, where you can update your cat web page with some CSS</em>.</p>&#13;
</div>&#13;
<p class="indent">This CSS example is simple, but CSS allows for much more advanced styling as well. If you’re familiar with the amazing variety of visual styles to be found on the web, then you have already seen the power of CSS in action.</p>&#13;
<h4 class="h4" id="lev2_45"><strong><em>Scripting the Web with JavaScript</em></strong></h4>&#13;
<p class="noindent">The web was originally envisioned as a means of sharing information through hypertext documents. HTML gives us that capability, and CSS gives us a method of controlling the presentation of such documents. However, the web evolved into a platform for interactive content, and JavaScript became the standard means for enabling interactivity. <em>JavaScript</em> is a programming language that enables web pages to respond to users’ actions and programmatically perform various tasks. With JavaScript, a web browser becomes not just a document reader, but a full application development platform.</p>&#13;
<p class="indent">JavaScript is an interpreted language; it isn’t compiled to machine code before it’s delivered to the browser. Web servers host JavaScript code in text format, and that code is downloaded by a browser and interpreted at runtime. That said, some browsers use a <em>just-in-time (JIT) compiler</em> that compiles JavaScript at runtime, leading to increased performance. Some developers <em>minify</em> their JavaScript before deploying it, removing whitespace, comments, and generally reducing the size of the script. Minifying JavaScript can improve the load time of a website. Minification isn’t the same as compilation; the minified file is still high-level code, not compiled machine code.</p>&#13;
<p class="indent">JavaScript has a syntax that’s similar to C and other languages that borrowed from C (such as C++, Java, and C#). However, the similarity is superficial, as JavaScript is quite different from those languages. Don’t let the name confuse you: JavaScript has little to do with Java. The language is object-oriented but fundamentally relies on <em>prototypes</em> rather than classes. That is, an existing object, rather than a class, acts a template for other objects.</p>&#13;
<p class="indent">JavaScript interacts with an HTML page using a browser-supplied representation of the page called the <em>Document Object Model (DOM)</em>. The DOM is a hierarchical tree structure of page elements, and it can be programmatically modified. An update to an element in the DOM causes the browser to update the element on the displayed web page. JavaScript includes methods for working with the DOM, and by using these methods, JavaScript code can both respond to events that occur on the page (such as the click of a button) and change the contents of the rendered page.</p>&#13;
<p class="indent">Let’s look at part of a simple script that interacts with our example page. The script adds the text <code>Meow!</code> to our page’s paragraph every time the cat photo is clicked (or tapped on a touchscreen).</p>&#13;
<pre>document.getElementById('cat-photo').onclick = function() {<br/>&#13;
  document.getElementById('cat-para').innerHTML += ' Meow!';<br/>&#13;
};</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>The first line here adds an event handler that runs when the cat photo is clicked. The event handler code is defined on the next line, and it tells the browser to add the text <code>Meow!</code> to the paragraph. Since this is defined as an event handler, the code only runs when the image click event occurs. Note that the script references the photo and paragraph by IDs, <code>cat-photo</code> and <code>cat-para</code>, respectively. HTML elements can be given IDs; this allows us to easily reference them programmatically. Our script only works if we add these IDs to our HTML. Here is the updated HTML that references the script (named <code>cat.js</code>) and adds the needed IDs.</p>&#13;
<pre>&lt;!DOCTYPE html&gt;<br/>&#13;
&lt;html lang="en"&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;meta charset="utf-8"&gt;<br/>&#13;
    &lt;title&gt;A Cat&lt;/title&gt;<br/>&#13;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;<br/>&#13;
    <span class="codestrong1">&lt;script src="cat.js"&gt;&lt;/script&gt;</span><br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;h1&gt;Thoughts on a Cat&lt;/h1&gt;<br/>&#13;
    &lt;p <span class="codestrong1">id="cat-para"</span>&gt;This is a cat.&lt;/p&gt;<br/>&#13;
    &lt;img <span class="codestrong1">id="cat-photo"</span> src="cat.jpg" alt="cat photo"&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">Once the script code is saved as <em>cat.js</em>, and the HTML is updated as shown, then reloading the page and clicking the cat image appends <code>Meow!</code> to our paragraph. If we click the image multiple times, we end up with something like what is shown in <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>.</p>&#13;
<div class="image" id="ch12fig7"><img src="../images/fig12-7.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-7: Our example web page after running JavaScript code to append text</em></p>&#13;
<span epub:type="pagebreak" id="page_275"/>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch12.xhtml#proj40">Project #40</a> on <a href="ch12.xhtml#page_289">page 289</a>, where you can update your web page with JavaScript</em>.</p>&#13;
</div>&#13;
<p class="indent">JavaScript can be used to build full applications that run in a web browser. The previous example is a just a taste of what it can do. JavaScript is standardized in a specification known as <em>ECMAScript</em>. Various browsers implement script engines that attempt to comply with all or part of the ECMAScript standard, which is updated regularly.</p>&#13;
<h4 class="h4" id="lev2_46"><strong><em>Structuring the Web’s Data with JSON and XML</em></strong></h4>&#13;
<p class="noindent">Websites aren’t the only type of content available on the web. A <em>web service</em> provides data over HTTP and is intended to be interacted with programmatically. This is in contrast to a website that returns HTML (and related assets) and is intended for user consumption via a web browser. Most end users never directly interact with web services, although the websites and apps we use are often underpinned by web services.</p>&#13;
<p class="indent">Imagine that you run a website with information about local bands that perform in your city. The site contains a profile of each band, including band members, background, where the band will be playing, and so forth. An end user can visit your website and easily read up on their favorite musicians. Now, let’s say you’re approached by an app developer who wants to include the latest information from your website in their app. However, the app has its own presentation that’s totally different from your web pages—the developer doesn’t want to just display your web pages in the app. They need a way to get at the underlying data on your site. They could try to programmatically read your web pages and extract the relevant information, but this process is complicated and error-prone, particularly if your site’s layout changes.</p>&#13;
<p class="indent">You could make things much easier for this developer by providing a web service that presents the data from your site in a format other than HTML. Although HTML does provide a certain structure, it’s a structure that describes a document (headers, paragraphs, and so on) and provides little insight into the data types referenced in that document. HTML makes sense for a human reader, but it’s difficult for software to parse. So what format should your web service use to structure data about bands? The most common general-purpose data formats in use today by web services are XML and JSON.</p>&#13;
<p class="indent"><em>Extensible Markup Language (XML)</em> has been around since the 1990s and is a popular means of exchanging data over the web. Like HTML, it’s a text-based markup language, but rather than having a set of predefined tags, XML allows for custom tags that describe your data. In the case of our fictitious band information service, we might define a <code>&lt;band&gt;</code> tag and a <code>&lt;concert&gt;</code> tag. Let’s look at an imaginary band described using XML:</p>&#13;
<pre>&lt;band name="The Highbury Musical Club"&gt;<br/>&#13;
  &lt;bandMembers&gt;<br/>&#13;
    &lt;member name="Jane Fairfax" instrument="Piano" /&gt;<br/>&#13;
    &lt;member name="Emma Woodhouse" instrument="Guitar" /&gt;<br/>&#13;
    &lt;member name="Harriet Smith" instrument="Percussion" /&gt;<br/>&#13;
    &lt;member name="Frank Churchill" instrument="Vocals" /&gt;<br/>&#13;
<span epub:type="pagebreak" id="page_276"/>  &lt;/bandMembers&gt;<br/>&#13;
  &lt;upcomingConcerts&gt;<br/>&#13;
    &lt;concert location="Donwell Abbey" date="August 14, 2020" /&gt;<br/>&#13;
    &lt;concert location="Hartfield" date="November 20, 2020" /&gt;<br/>&#13;
  &lt;/upcomingConcerts&gt;<br/>&#13;
&lt;/band&gt;</pre>&#13;
<p class="indent">As you can see, the specific XML tags and their attributes are tailored to our needs, while the general structure of start tags, end tags, and tree hierarchy follows a pattern similar to HTML. The flexibility of XML, where tags can be arbitrarily defined, means that both the producer and the consumer of the XML need to agree on the expected tags and their meanings. This is true of HTML as well, but with HTML, all parties agree to a standard. In the case of XML, only the general format is standardized while the specific tags vary.</p>&#13;
<p class="indent">XML is a popular method for sharing data over the web, with many web services using XML as their primary means of representing data. However, XML is verbose and parsing it properly can be tricky.</p>&#13;
<p class="indent"><em>JavaScript Object Notation (JSON)</em>, like XML, is a method of describing data in a text format. JSON avoids using markup tags and instead embraces a style that’s similar to JavaScript’s syntax for describing objects, hence the name. In JSON, objects are wrapped in curly braces (<code>{</code> and <code>}</code>) and arrays (collections of objects) are enclosed in brackets (<code>[</code> and <code>]</code>). Its syntax is terser than XML, which is helpful in reducing the size of data transmitted over a network. The popularity of JSON rose in the 2010s, when it began to displace XML as the preferred data format for new web services. Here is the same imaginary band described in JSON:</p>&#13;
<pre>{<br/>&#13;
  "name": "The Highbury Musical Club",<br/>&#13;
  "bandMembers": [<br/>&#13;
    {<br/>&#13;
      "name": "Jane Fairfax",<br/>&#13;
      "instrument": "Piano"<br/>&#13;
    },<br/>&#13;
    {<br/>&#13;
      "name": "Emma Woodhouse",<br/>&#13;
      "instrument": "Guitar"<br/>&#13;
    },<br/>&#13;
    {<br/>&#13;
      "name": "Harriet Smith",<br/>&#13;
      "instrument": "Percussion"<br/>&#13;
    },<br/>&#13;
    {<br/>&#13;
      "name": "Frank Churchill",<br/>&#13;
      "instrument": "Vocals"<br/>&#13;
    }<br/>&#13;
  ],<br/>&#13;
  "upcomingConcerts": [<br/>&#13;
    {<br/>&#13;
      "location": "Donwell Abbey",<br/>&#13;
      "date": "August 14, 2020"<br/>&#13;
<span epub:type="pagebreak" id="page_277"/>    },<br/>&#13;
    {<br/>&#13;
      "location": "Hartfield",<br/>&#13;
      "date": "November 20, 2020"<br/>&#13;
    }<br/>&#13;
  ]<br/>&#13;
}</pre>&#13;
<p class="indent">Both XML and JSON ignore extra whitespace, so just like with HTML, we can remove all extra spaces, tabs, and line breaks without affecting how the data is interpreted. Doing so produces a fairly compact rendering of data, particularly in the case of JSON.</p>&#13;
<p class="indent">XML and JSON are not formats meant for direct rendering in a web browser. Opening JSON or XML content in certain browsers may cause the browser to display something (perhaps a lightly formatted version of the data), but really JSON and XML aren’t intended to be directly consumed by web browsers. They are meant to be read by code that in turn does something useful with the data. Perhaps that code is a smartphone app that shows information about what bands are playing nearby, as in our example. Or maybe the code is client-side JavaScript that transforms JSON into HTML for a browser to display.</p>&#13;
<h3 class="h3" id="lev1_92"><strong>Web Browsers</strong></h3>&#13;
<p class="noindent">Now that we’ve covered the languages used to describe the web, let’s take a look at software on the client side of the web, the web browser. The first web browser was called <em>WorldWideWeb</em> (not to be confused with the subject of this chapter). It was developed by Tim Berners-Lee in 1990. This first browser was the client for the first web server, <em>CERN httpd</em>. In a few years WorldWideWeb was supplanted by <em>Mosaic</em>, a browser that helped popularize the web. The next major browser release was <em>Netscape Navigator</em>, which also had a large following. In 1995, Microsoft released their first browser, <em>Internet Explorer</em>, as a direct competitor to Netscape Navigator, and Internet Explorer became the dominant browser of its time. Today, the browser landscape has shifted dramatically, and at the time of this writing, the dominant browsers are <em>Google Chrome</em>, <em>Apple Safari</em>, and <em>Mozilla Firefox</em>.</p>&#13;
<h4 class="h4" id="lev2_47"><strong><em>Rendering a Page</em></strong></h4>&#13;
<p class="indent">Let’s now look at the process a web browser goes through to render a page. A typical visit to a website starts with a request of the default page of a site (such as <em><a href="http://www.example.com">http://www.example.com</a>/</em>) or a request of a specific page on the site (such as <em><a href="http://www.example.com/animals/cat.html">http://www.example.com/animals/cat.html</a></em>). A user may enter this URL directly in the address bar, or the user could arrive at this URL by following a link. In either case, the browser requests the contents at the specified URL. Assuming the URL is valid and represents a web page, the server responds with HTML.</p>&#13;
<p class="indent">The web browser must then take the returned HTML and generate a DOM representation of the page. The HTML may contain references <span epub:type="pagebreak" id="page_278"/>to other resources, like images, scripts, and style sheets. Each of these resources has its own URL, and the browser makes separate requests for each resource, as illustrated in <a href="ch12.xhtml#ch12fig8">Figure 12-8</a>.</p>&#13;
<div class="image" id="ch12fig8"><img src="../images/fig12-8.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-8: A web browser requests a page and its referenced content</em></p>&#13;
<p class="indent">Once the browser has retrieved the various resources of the page, it displays the HTML, using any specified CSS to determine the appropriate presentation. Any scripts are handed off to a JavaScript engine to run. JavaScript code may immediately make changes to the page, or it may register event handlers that run later when certain events occur. JavaScript code may also request data from a web service and use that data to update the page.</p>&#13;
<p class="indent">Web browsers consist of a rendering engine (for HTML and CSS), a JavaScript engine, and a user interface that ties things together. Although the user interface provides the look and feel of the browser itself (such as the appearance of the back button and address bar), it’s the rendering engine and JavaScript engine that determine how websites are presented and behave (this includes things like how the page is laid out and how it responds to input). Since each rendering engine and JavaScript engine handle things slightly differently, a web page may look or act differently when viewed on different browsers. Ideally, all browsers would render content the same way, exactly as the site developer intended, but that’s not always the case. At the time of this writing, only three major rendering engines are in active development: WebKit, Blink, and Gecko.</p>&#13;
<p class="indent"><em>WebKit</em> is the rendering engine and JavaScript engine for Apple’s Safari browser. It’s also used in applications found in the iOS App Store, since Apple requires all iOS apps that display web content to use this engine. <em>Blink</em>, which <span epub:type="pagebreak" id="page_279"/>is a fork of WebKit, is the rendering engine for the <em>Chromium</em> open source project, which also includes the <em>V8</em> JavaScript engine. Chromium is the basis for Google Chrome and Opera. In December 2018, Microsoft announced that the <em>Microsoft Edge</em> browser would also be Chromium-based; Microsoft chose to halt development of its own rendering and JavaScript engines. That leaves only one major browser that doesn’t trace its roots to WebKit—Mozilla Firefox, which has its own <em>Gecko</em> rendering engine and <em>SpiderMonkey</em> JavaScript engine.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A software fork occurs when developers make a copy of a project’s source code and then make changes to that copy. This allows the original and forked projects to coexist as separate software</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_48"><strong><em>The User Agent String</em></strong></h4>&#13;
<p class="noindent">The formal, technical term for a web browser is a <em>user agent</em>. This term can be applied to other software as well (anything that acts on behalf of a user), but here we’re talking specifically about web browsers. This term pops up in technical documentation about the web, although it’s rarely used outside of formal communication. That said, one place where the term is used in practice is the <em>user agent string</em>. When a browser makes a request to a web server, it commonly includes a header value called <code>User-Agent</code> that describes the browser. As an example, here is the user agent string sent by Chrome (version 71) on Windows 10:</p>&#13;
<pre>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)<br/>&#13;
Chrome/71.0.3578.98 Safari/537.36</pre>&#13;
<p class="indent">This may seem contradictory. What does all this mean?</p>&#13;
<p class="indent">The first entry, <code>Mozilla/5.0</code>, is a holdover from the early days of the web. Mozilla was the user agent name for Netscape Navigator, and many sites specifically looked for “Mozilla” in the user agent string as an indicator to send the cutting-edge version of their website to the browser. At the time, other browsers wanted to get the best versions of websites too, so they identified themselves as Mozilla, even though they weren’t Mozilla at all. Fast forward to today, when essentially <em>every</em> browser identifies itself as Mozilla, and we find that portion of the user agent string fairly meaningless.</p>&#13;
<p class="indent">The next section in parentheses, <code>(Windows NT 10.0; Win64; x64)</code>, specifies the platform on which the browser is running.</p>&#13;
<p class="indent">Following that is the rendering engine, <code>AppleWebKit/537.36</code> in this case. As mentioned earlier, Chrome’s Blink engine is a fork of WebKit and still identifies itself as such. The following text, <code>(KHTML, like Gecko)</code>, is just a further elaboration on this; KHTML is a legacy engine that WebKit was based on.</p>&#13;
<p class="indent">Now we get to the actual browser name and version, <code>Chrome/71.0.3578.98</code>.</p>&#13;
<p class="indent">Finally, we have an awkward mention of Apple’s browser <code>Safari/537.36</code>, included for sites that give Safari special treatment. By including this text, Chrome attempts to ensure that those sites send it the same content that Safari would receive.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_280"/>That’s a rather complicated way to identify Chrome, but other browsers do the same kind of thing to ensure compatibility with all manner of websites. This complexity is an unfortunate side effect of historically fragmented capabilities in different browsers and websites that tried to send tailored versions of their content based on the particular browser. Browsers evolved so that today there is less variation in browser capabilities. However, many websites didn’t evolve and still send content tailored for specific browsers, forcing modern browsers to continue to trick old sites into believing they are communicating with a different browser.</p>&#13;
<h3 class="h3" id="lev1_93"><strong>Web Servers</strong></h3>&#13;
<p class="noindent">So far, we’ve focused primarily on the technologies used on the client side of the web. Web browsers speak a common trio of languages: HTML, CSS, and JavaScript. What about on the web’s server side? What languages and technologies are used to power web servers? In short, any programming language or technology can be used on a web server, as long as that technology can communicate over HTTP and return data in a format that the client understands.</p>&#13;
<p class="indent">Broadly speaking, websites are designed as either static or dynamic. A <em>static website</em> returns HTML, CSS, or JavaScript that was built ahead of time. Typically, the content of the site is stored in files on the server, and the server simply returns the contents of those files without modification. This means that any required runtime processing must be implemented in JavaScript that runs in the browser. On the other hand, a <em>dynamic website</em> performs processing on the server, generating HTML when a request comes in.</p>&#13;
<p class="indent">In the early days of the web, nearly everything was static. Pages were simple HTML, and there was little interactivity. As time went on, developers began adding code that ran on the web server, allowing the server to return dynamic content or accept a file upload or form submission from a user. This trend continued, and it became commonplace for requests to go through server-side processing before the server would respond.</p>&#13;
<p class="indent">Let’s look at how server-side processing on a dynamic website typically works, as illustrated in <a href="ch12.xhtml#ch12fig9">Figure 12-9</a>. Assume that the dynamic website represented in <a href="ch12.xhtml#ch12fig9">Figure 12-9</a> is a blog. A browser makes a request for a blog post. When the web server receives the request for the blog post, it reads the requested URL and determines that it needs to generate HTML. Code on the server then queries a database (which may be on the web server or on another server), retrieves the relevant blog text data, formats that text as HTML, and then responds to the client with that HTML. This approach is useful because it allows the content of a site to be managed separately from the website’s code, but dynamic sites also have some drawbacks. The increased complexity on the server means more work to set things up, a slower response at runtime, a potentially heavy load on the server, and an increased risk of security problems.</p>&#13;
<span epub:type="pagebreak" id="page_281"/>&#13;
<div class="image" id="ch12fig9"><img src="../images/fig12-9.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-9: A typical dynamic website handles a request</em></p>&#13;
<p class="indent">Recently, there has been a trend to move back to static sites where possible. The flow of a page request on a static site is shown in <a href="ch12.xhtml#ch12fig10">Figure 12-10</a>.</p>&#13;
<div class="image" id="ch12fig10"><img src="../images/fig12-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-10: A static website handles a request</em></p>&#13;
<p class="indent">As shown in <a href="ch12.xhtml#ch12fig10">Figure 12-10</a>, the static website’s server-side processing is simplified, as compared to the dynamic site. The server-side processing on a static site is simply a matter of returning the static file that matches the requested URL. The content has already been built; the server does not need to retrieve raw data and format it. Reducing the complexity on the server side generally means simpler, faster, and more secure sites.</p>&#13;
<p class="indent">It is important to understand that in this context, the terms <em>static</em> and <em>dynamic</em> are from the server’s perspective, not the user’s. A static site’s content comes unchanged from files on the server, whereas a dynamic site’s content is generated on the server. The terms aren’t a description of how a user experiences the site, such as whether the site is interactive or if content is automatically updated. These experiences can be achieved using JavaScript in the browser, sometimes in conjunction with a separate web service, regardless of whether the website itself is static or dynamic.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>If you’re hosting a static site, all you need is web server software that can respond to requests for your static files and serve the contents of those files. No custom code required. Many software packages and online services are available for hosting static sites. Typically, the software for serving a static site is configured to point to a directory of files on the server, and when a request comes in for a certain file, the server simply returns the contents of that file. For example, if the files for the website at <em>example.com</em> reside in a directory on the server called <em>/websites/example</em>, then a request for <em><a href="http://example.com/images/cat.jpg">http://example.com/images/cat.jpg</a></em> maps to <em>/websites/example/images/cat.jpg</em>. The web server simply reads the matching file from its local directory and returns the bytes contained in that file to the client. The website developed in Projects #37 through #40 is an example of a static site.</p>&#13;
<p class="indent">If you’re building a dynamic website or web service, either you can use existing software that manages your content and serves up dynamic pages, or you can write your own custom code that generates web content. Assuming you’re writing custom code, you’ll find things are quite different on the server side as compared to the client side of web development. Any programming language, any operating system, any platform can be used for a web server. Anything goes, as long as the web server responds over HTTP and returns data in a format that the client understands! The client doesn’t care what technologies were used to generate HTML or JavaScript; it just needs a response in a format it can handle.</p>&#13;
<p class="indent">Since it doesn’t really matter to clients what technology is used on the web server side, many options are available to developers who wish to write code that runs on the server. Client-side web development is limited to the trio of HTML, CSS, and JavaScript, whereas server-side web development can take place in Python, C#, JavaScript, Java, Ruby, PHP, and more. Server-side web development often includes interfacing with a database of some kind. In the same way that any programming language can be used on the server, any kind of database can be used for server-side web development.</p>&#13;
<h3 class="h3" id="lev1_94"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter we covered the web—a set of distributed, addressable, linked resources, delivered by HTTP over the internet. You learned how web pages are structured with HTML, styled with CSS, and scripted with JavaScript. We looked at web browsers, which are used to access content on the web, and we examined web servers—the software that hosts web resources. In the next chapter, we’ll look at some trends in modern computing, and you’ll have a chance to complete a final project that ties together various concepts found throughout this book.</p>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_283"/>&#13;
<p class="exercise" id="proj36"><strong><span class="black1">PROJECT #36: EXAMINE HTTP TRAFFIC</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll use Google Chrome or Chromium to examine HTTP traffic between a web browser and a web server. You can either use Chrome on a Windows PC or a Mac, or use the Chromium web browser on your Raspberry Pi. The following steps assume you’re using a Raspberry Pi, but the process is similar on a Windows PC or a Mac; just use Chrome instead of Chromium.</p>&#13;
<ol>&#13;
<li class="noindent_sidebar">If you aren’t using the graphical desktop on your Raspberry Pi, switch to it now. Unlike previous projects, this project cannot be completed from a terminal window.</li>&#13;
<li class="noindent_sidebar">Click <strong>Raspberry</strong> (icon in the upper left corner)<span class="ent">▶</span> <strong>Internet</strong><span class="ent">▶</span> <strong>Chromium Web Browser</strong>.</li>&#13;
<li class="noindent_sidebar">Go to a website, such as <em><a href="http://www.example.com">http://www.example.com</a></em>.</li>&#13;
<li class="noindent_sidebar">Press the F12 key (or <small>CTRL-SHIFT</small>-I) to open the developer tools (DevTools), shown in <a href="ch12.xhtml#ch12fig11">Figure 12-11</a>.&#13;
<div class="image" id="ch12fig11"><img src="../images/fig12-11.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-11: Developer tools in Chromium</em></p></li>&#13;
<li class="noindent_sidebar">On the DevTools menu, choose the <strong>Network</strong> menu item.</li>&#13;
<li class="noindent_sidebar">Press F5 (or hit the reload icon) to reload the page. You’ll see the HTTP requests that are made to load the page you’re currently visiting.</li>&#13;
<li class="noindent_sidebar"><span epub:type="pagebreak" id="page_284"/>If you actually use <em>www.example.com</em> you’ll likely see a fairly boring request. If you want to see something more interesting, visit a more complicated site and watch the network requests, as shown in <a href="ch12.xhtml#ch12fig12">Figure 12-12</a>.&#13;
<div class="image" id="ch12fig12"><img src="../images/fig12-12.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-12: Example of HTTP traffic for a website shown in Chromium’s DevTools</em></p></li>&#13;
<li class="noindent_sidebar">Each line represents a request to the web server. You can see the resource name that was requested, the status of the request (<code>200</code> means success), and more.</li>&#13;
<li class="noindent_sidebar">You can click each line and see the specifics of the request, such as the headers and the content returned.</li>&#13;
</ol>&#13;
<p class="exercise-parai">I recommend you try this on several websites to get a feel for the number of requests made for a site. You may be surprised at how much content is transferred!</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_285"/>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj37"><strong><span class="black1">PROJECT #37: RUN YOUR OWN WEB SERVER</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll set up a Raspberry Pi to act as a web server. You’ll use Python 3 to do this, so you can actually follow these steps on any device with Python 3 installed, although the steps here were written with the Raspberry Pi in mind. Our simple website will return the contents of a file when it receives a request.</p>&#13;
<p class="exercise-parai">Open a terminal window and create a directory that will hold the files your website will serve, and then set that new directory as your current directory.</p>&#13;
<pre>$ <span class="codestrong1">mkdir web</span><br/>&#13;
$ <span class="codestrong1">cd web</span></pre>&#13;
<p class="exercise-parai">When a request is made to the root of your website, the web server software looks for a file named <em>index.html</em> and returns the contents of that file to the client. Let’s create a very simple <em>index.html</em> file:</p>&#13;
<pre>$ <span class="codestrong1">echo "Hello, Web!" &gt; index.html</span></pre>&#13;
<p class="exercise-parai">That command creates a text file named <em>index.html</em> with the text <code>Hello, Web!</code> in the file. You can view the contents of the text file to ensure it was created successfully by opening the file in a text editor, or you can display the contents in the terminal like so:</p>&#13;
<pre>$ <span class="codestrong1">cat index.html</span></pre>&#13;
<p class="exercise-parai">Once your file is in place, let’s use Python’s built-in web server to serve up your <code>Hello, Web!</code> message to anyone who connects.</p>&#13;
<pre>$ <span class="codestrong1">python3 -m http.server 8888</span></pre>&#13;
<p class="exercise-parai">This command tells Python to run an HTTP server on port <code>8888</code>. Let’s test this out to see if it’s working as expected. Open another terminal window on your Raspberry Pi. From this second terminal window, enter the following command to make a <code>GET</code> request to the root of your new website:</p>&#13;
<pre>$ <span class="codestrong1">curl http://localhost:8888</span></pre>&#13;
<p class="exercise-parai">The <code>curl</code> utility can be used to make HTTP <code>GET</code> requests, and <code>localhost</code> is a hostname that refers to the computer you’re currently using. This command tells the <code>curl</code> utility to perform an HTTP <code>GET</code> to port <code>8888</code> on the local computer. You should see the text <code>Hello, Web!</code> returned. Also, back in the original terminal, you should see that a <code>GET</code> request came in.</p>&#13;
<p class="exercise-parai">Now, let’s try connecting to your website from a web browser. From the Raspberry Pi desktop, open the Chromium web browser. In the address bar, enter <span class="codestrong">http://localhost:8888</span>. You should see the text from your website appear in the browser, as shown in <a href="ch12.xhtml#ch12fig13">Figure 12-13</a>.</p>&#13;
<span epub:type="pagebreak" id="page_286"/>&#13;
<div class="image" id="ch12fig13"><img src="../images/fig12-13.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 12-13: Connecting to a local web server using the Chromium browser</em></p>&#13;
<p class="exercise-parai">Now try connecting to your website from another device. For this to work, the second device has to be on the same network as your Raspberry Pi. For example, they should both be on the same Wi-Fi network. Or, if your Raspberry Pi has a public IP address (see <a href="ch11.xhtml#proj34">Project #34</a> on <a href="ch11.xhtml#page_259">page 259</a>), then your website is available to any device on the internet! First, get your Raspberry Pi’s IP address by running the following command in the second terminal window:</p>&#13;
<pre>$ <span class="codestrong1">ifconfig | grep inet</span></pre>&#13;
<p class="exercise-parai">This likely returns several IP addresses. You can’t use <code>127.0.0.1</code> when connecting from a remote device, so choose another IP address assigned to your Raspberry Pi. Once you have the IP address, open a browser on another device. This can be a smartphone, laptop, or really any device on your network that has a web browser. In the browser window, enter the following in the address bar: <em><code>http://w.x.y.z:8888</code></em> (replacing <em><code>w.x.y.z</code></em> with the IP address of your device). Press <small>ENTER</small> or the appropriate button in the browser to navigate to that address. You should see <code>Hello, Web!</code> appear in the browser.</p>&#13;
<p class="exercise-parai">If this didn’t work for you, and your Raspberry Pi does not have a public IP address, make sure the two devices are on the same physical local network. Also, sometimes the Python web server becomes unresponsive to new requests. If the web server stops responding, you can restart <span epub:type="pagebreak" id="page_287"/>it. To stop the web server, go to the terminal where the server command was executed, and press <small>CTRL</small>-C on the keyboard. Then restart the server by running the <span class="codestrong">python3 -m http.server 8888</span> command again (press the keyboard up arrow to get the last command).</p>&#13;
<p class="exercise-parai">Once you have your site working, try editing the <em>index.html</em> file and change the message to say whatever you want. You can use the text editor of your choice to do this. Once your <em>index.html</em> file is updated, reload the web page in a web browser to see your changes!</p>&#13;
<p class="exercise-parai">If you don’t want other devices to be able to access your website, you can restrict things so that only requests from the Raspberry Pi itself get a response. Running the Python web server with the <code>--bind</code> option can accomplish this, like so:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m http.server 8888 --bind 127.0.0.1</span></pre>&#13;
<p class="exercise-parai">To run the web server with the <code>--bind</code> option, you first need to stop any running instance of the web server (press <small>CTRL</small>-C on the keyboard).</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj38"><strong><span class="black1">PROJECT #38: RETURN HTML FROM YOUR WEB SERVER</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: <a href="ch12.xhtml#proj37">Project #37</a>.</p>&#13;
<p class="exercise-parai">In this project, you’ll update your local web server to return HTML instead of simple text. Use the text editor of your choice to open <em>index.html</em> (that was created in <a href="ch12.xhtml#proj37">Project #37</a>) and replace all the text in the file with the following HTML. This is the same HTML code that was discussed in the chapter. You don’t need to worry about the indentation of each line, since extra whitespace in HTML doesn’t matter.</p>&#13;
<pre>&lt;!DOCTYPE html&gt;<br/>&#13;
&lt;html lang="en"&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;meta charset="utf-8"&gt;<br/>&#13;
    &lt;title&gt;A Cat&lt;/title&gt;<br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;h1&gt;Thoughts on a Cat&lt;/h1&gt;<br/>&#13;
    &lt;p&gt;This is a cat.&lt;/p&gt;<br/>&#13;
    &lt;img src="cat.jpg" alt="cat photo"&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="exercise-parai">Once your file has been updated, you’ll use Python’s built-in web server again. If it isn’t already running, start it with this command. Just be sure that your terminal window is currently in the <em>web</em> directory before running the command.</p>&#13;
<pre>$ <span class="codestrong1">python3 -m http.server 8888</span></pre>&#13;
<span epub:type="pagebreak" id="page_288"/>&#13;
<p class="exercise-parai">Now, use a web browser to connect to your web server as you did in <a href="ch12.xhtml#proj37">Project #37</a>. You should see the page rendered, but without the cat photo. If you look at the terminal window where you ran the Python web server command, you should see an attempt to get the cat photo that failed, like so:</p>&#13;
<pre>192.168.1.123 - - [31/Jan/2020 17:38:56] "GET /cat.jpg HTTP/1.1" 404 -</pre>&#13;
<p class="exercise-parai">The <code>404</code> error code indicates that the resource can’t be found, which makes sense given that you don’t have a file named <em>cat.jpg</em> in this directory! Why did the web browser even ask for a cat photo? If you look back at the HTML for the page, you see an HTML <code>&lt;img&gt;</code> tag that directs the browser to render the <code>cat.jpg</code> image. The browser requests the image, but it fails to retrieve it since the file is missing.</p>&#13;
<p class="exercise-parai">Let’s fix the missing cat image issue. You need to download an image of a cat (or an image of anything really) in JPEG format and save it as <em>~/web/cat.jpg</em>. To make this easy, you can download the image used in the chapter with the following command. Be sure that your terminal window is currently in the <em>web</em> directory before running the command.</p>&#13;
<pre>$ <span class="codestrong1">wget https://www.howcomputersreallywork.com/images/cat.jpg</span></pre>&#13;
<p class="exercise-parai">You should now have <em>cat.jpg</em> stored in your <em>web</em> directory. Reload the page in a web browser to see the cat image in the page. Reminder: if the web server seems stuck, restart it as described in <a href="ch12.xhtml#proj37">Project #37</a>.</p>&#13;
<p class="exercise-parai">It’s worth noting that not only can you view the cat image in your page, but you can also request the image directly from the server, since it has its own URL. Try pointing your browser to the following URL (replacing <em><code>SERVER</code></em> with the hostname or IP address you’ve been using for your website): <code>http://<em>SERVER</em>:8888/cat.jpg</code>. You should see the cat image rendered in the browser, outside of the web page. Every resource referenced on a web page has its own URL and can be accessed directly!</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj39"><strong><span class="black1">PROJECT #39: ADD CSS TO YOUR WEBSITE</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: <a href="ch12.xhtml#proj38">Project #38</a>.</p>&#13;
<p class="exercise-parai">In this project, you’ll use CSS to style your website. First, use the text editor of your choice to create a file named <em>style.css</em> in the <em>web</em> directory. This file will contain your CSS rules. Be sure the file is named <em>style.css</em> and is saved to the <em>web</em> directory alongside your <em>index.html</em> and <em>cat.jpg</em> files. The contents of <em>style.css</em> should be the following:</p>&#13;
<pre>p {<br/>&#13;
   font-family: Arial, Helvetica, sans-serif;<br/>&#13;
   font-size: 11pt;<br/>&#13;
   margin-left: 10px;<br/>&#13;
   color: DimGray;<br/>&#13;
}<br/>&#13;
<span epub:type="pagebreak" id="page_289"/>&#13;
h1 {<br/>&#13;
   font-family: 'Courier New', Courier, monospace;<br/>&#13;
   font-size: 18pt;<br/>&#13;
   font-weight: bold;<br/>&#13;
}</pre>&#13;
<p class="exercise-parai">Once <em>style.css</em> has been created, open <em>index.html</em> for editing, as you did in the previous project. Leave the existing HTML in place. We just want to add a single line to the head section, as shown here:</p>&#13;
<pre>  &lt;head&gt;<br/>&#13;
    &lt;meta charset="utf-8"&gt;<br/>&#13;
    &lt;title&gt;A Cat&lt;/title&gt;<br/>&#13;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;<span class="ent">❶</span><br/>&#13;
  &lt;/head&gt;</pre>&#13;
<p class="exercise-parai">Once you’ve made this update <span class="ent">❶</span> to <em>index.html</em>, start your web server (if it isn’t already running), and reload the page in your web browser. You should see the style of the page update. Reminder: if the web server seems stuck, restart it as described in <a href="ch12.xhtml#proj37">Project #37</a>.</p>&#13;
<p class="exercise-parai">Feel free to edit <em>style.css</em> to try different styles. Maybe you want to make the paragraph font huge or a different color! Edit the style to your liking, save <em>style.css</em>, and reload the page in your browser.</p>&#13;
<p class="exercise-parai">If you aren’t seeing your updates reflected in the browser, it may be because your web browser is loading a cached copy of your website rather than downloading the latest version. Try opening the page in a new tab or restarting the browser altogether. You can also tell your browser to bypass its local cache when reloading. To do this, navigate to the page, and then press <small>CTRL</small>-F5 to force the page to reload. This works on most browsers on Windows and Linux. On a Mac, you can force a refresh in Chrome and Firefox with <small>CMD-SHIFT</small>-R. Sometimes multiple refreshes are needed before the browser renders the latest content.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj40"><strong><span class="black1">PROJECT #40: ADD JAVASCRIPT TO YOUR WEBSITE</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: <a href="ch12.xhtml#proj39">Project #39</a>.</p>&#13;
<p class="exercise-parai">In this project, you’ll use JavaScript to make your website interactive. First, use the text editor of your choice to create a file named <em>cat.js</em> in the <em>web</em> directory. This file will contain JavaScript code. Be sure the file is named <em>cat.js</em> and is saved to the <em>web</em> directory alongside your <em>index.html</em> and <em>cat.jpg</em> files. The contents of <em>cat.js</em> should be the following:</p>&#13;
<pre>document.addEventListener('DOMContentLoaded', function() {<br/>&#13;
    document.getElementById('cat-photo').onclick = function() {<br/>&#13;
        document.getElementById('cat-para').innerHTML += ' Meow!';<br/>&#13;
    };<br/>&#13;
});</pre>&#13;
<span epub:type="pagebreak" id="page_290"/>&#13;
<p class="exercise-parai">Once <em>cat.js</em> has been saved, open <em>index.html</em> for editing, as you did in the previous project. Leave the existing HTML in place and make the changes shown here:</p>&#13;
<pre>&lt;!DOCTYPE html&gt;<br/>&#13;
&lt;html lang="en"&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;meta charset="utf-8"&gt;<br/>&#13;
    &lt;title&gt;A Cat&lt;/title&gt;<br/>&#13;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;<br/>&#13;
    &lt;script src="cat.js"&gt;&lt;/script&gt;<span class="ent">❶</span><br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;h1&gt;Thoughts on a Cat&lt;/h1&gt;<br/>&#13;
    &lt;p id="cat-para"<span class="ent">❷</span>&gt;This is a cat.&lt;/p&gt;<br/>&#13;
    &lt;img id="cat-photo"<span class="ent">❸</span> src="cat.jpg" alt="cat photo"&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="exercise-parai">These changes reference the script <span class="ent">❶</span> and give IDs to the paragraph <span class="ent">❷</span> and image <span class="ent">❸</span>.</p>&#13;
<p class="exercise-parai">Once you’ve made this update to <em>index.html</em>, start your web server (if it isn’t already running), and reload the page in a web browser. You should now be able to click (or touch) the cat photo and see the word <code>Meow!</code> appended to the paragraph. Reminder: if the web server seems stuck, restart it as described in <a href="ch12.xhtml#proj37">Project #37</a>.</p>&#13;
</div>&#13;
</body></html>