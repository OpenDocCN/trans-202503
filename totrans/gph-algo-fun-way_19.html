<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BIPARTITE GRAPH MATCHING</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Many problems in business and logistics consist of matching items from two different sets. We might want to match people with jobs, conferences with locations, vehicles with routes, or adopted pets with homes. In each case, we must ask which item from one set is compatible with which item from the second set. This chapter explores this problem, called <i>bipartite graph matching</i>, in detail.</p>&#13;
<p class="TX">A <i>bipartite graph</i> is a graph consisting of two disjoint sets of nodes where each edge always has one end in each set. This graph naturally lends itself to the matching problem: each set of nodes represents one of the sets of items that we want to match, while edges indicate compatibility between the items.</p>&#13;
<p class="TX">This chapter begins by discussing the broader concept of matching on a graph before formally introducing undirected bipartite graphs and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>bipartite matching algorithms, showing along the way how graph matching encompasses a rich set of problems, from assigning partners for group work to scheduling jobs in a data center, and technical challenges.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-206"/><samp class="SANS_Futura_Std_Bold_B_11">Matching</samp></h3>&#13;
<p class="TNI1">A <i>matching</i> on an undirected graph is a set of edges that do not share any nodes. In other words, each edge in the matching connects two different nodes, and each node is adjacent to at most one edge. We can visualize matchings via pairing up students for project work using their friendship connections. Each edge in the matching represents two friends (the edge’s two nodes) who will collaborate on the project. As a natural consequence of this pairwise assignment, we pair up only students with existing social connections and do not guarantee that all students will find a partner.</p>&#13;
<p class="TX">The general concept of matching opens up a range of problems we can solve. As concrete examples for this chapter, let’s examine two particularly useful matching problems. First, finding a <i>maximum-cardinality matching</i> (sometimes shortened to <i>maximum matching</i>) consists of finding a matching with the most edges. This corresponds to finding an assignment of students to pairs that creates the most groups. Second, a <i>maximal matching</i> is any matching where no additional edges can be added without breaking the matching property. While a maximum-cardinality matching is always a maximal matching, the converse is not true.</p>&#13;
<p class="TX"><a href="#fig15-1">Figure 15-1</a> shows examples of these two matching types. We cannot add any more edges to the maximal matching in <a href="#fig15-1">Figure 15-1(a)</a>, represented by the bold edges, without reusing a node. Meanwhile, <a href="#fig15-1">Figure 15-1(b)</a> is both a maximal matching and a maximum-cardinality matching: we cannot create a matching for this graph with more than three edges.</p>&#13;
<figure class="IMG"><img id="fig15-1" class="img100" src="../images/f15001.jpg" alt="A graph with undirected edges (0,1), (0,3), (1, 2), (1, 4), (1, 5), (2, 5) and (4, 5). (A) has edges (0, 3) and (1, 5) bolded. (B) has edges (0, 3), (1, 2), and (4, 5) bolded." width="1211" height="367"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: Maximal (a) and maximum-cardinality (b) matching</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The problem of finding a <i>maximum-weight matching</i> consists of finding the matching in a weighted graph that maximizes the sum of the edge weights. This corresponds to prioritizing the strength of the students’ friendships when allocating the groups. While this approach is useful in the context of maximizing a reward function such as student happiness, it does not necessarily lead to a maximum-cardinality matching. For example, <a href="#fig15-2">Figure 15-2</a> shows a maximum-weight matching that is not <span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>a maximum-cardinality matching. Two pairs of nodes {0, 1} and {2, 5} are matched, while nodes 3 and 4 are left out.</p>&#13;
<figure class="IMG"><img id="fig15-2" class="img40" src="../images/f15002.jpg" alt="A graph with undirected, weighted edges. Edge (0,1) has weight 10. Edge (0,3) has weight 1. Edge (1, 2) has weight 3. Edge (1, 4) has weight 5. Edge (1, 5) has weight 1. Edge (2, 5) has weight 19. Edge (4, 5) has weight 4. The edges (0, 1) and (2, 5) are bolded." width="503" height="314"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The maximum- weight matching on a graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The list of possible matching problems continues beyond these initial examples. We could ask whether a graph has a <i>perfect matching</i>, where every node is included exactly once; find a maximum-cardinality matching that minimizes the sum of the edge weights; or find a matching that maximizes the weight while keeping below a given number of edges. Throughout the rest of the chapter, we will focus primarily on maximum-cardinality matching, one of the simplest and most broadly applicable formulations, in the context of a specific graph type.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-207"/><samp class="SANS_Futura_Std_Bold_B_11">Bipartite Graphs</samp></h3>&#13;
<p class="TNI1">As noted earlier, a <i>bipartite graph</i> can be partitioned into two disjoint sets of nodes such that no edge connects two nodes in the same set. Bipartite graphs are often visualized as two parallel lines of nodes, as shown in <a href="#fig15-3">Figure 15-3</a>. The left and right columns define the two sets of nodes. Every edge in the graph spans the columns.</p>&#13;
<figure class="IMG"><img id="fig15-3" class="img30" src="../images/f15003.jpg" alt="A graph with seven nodes and undirected edges (0, 3), (0, 5), (2, 1), (2, 5), (4, 3), (4, 5) and (6, 1). The even nodes are in a column on the left and the odd nodes are in a column on the right. All edges go between two columns." width="335" height="585"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: A bipartite graph with seven nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>Bipartite graphs provide a natural model for pairwise matching problems. In a canonical example, the items on the left represent people and the ones on the right represent the jobs for which they are qualified, summarizing a complex set of constraints in a simple graph.</p>&#13;
<p class="TX">Although matching is the focus of this chapter, the usefulness of bipartite graphs does not end there. Bipartite graphs can model a range of phenomena, from physical bridges crossing a river to spies watching each other at a party.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h-208"/><samp class="SANS_Futura_Std_Bold_B_11">Bipartite Labeling</samp></h3>&#13;
<p class="TNI1">Given an undirected graph, we can ask whether it is a bipartite graph and, if so, which node is part of which set. We can use the properties of a bipartite graph to perform both this check and the labeling of which nodes are in which set. We know that any path through an undirected bipartite graph must zigzag between the two sets, and a node can never have a neighbor within its own set. We use a simple search, either breadth-first or depth-first, to traverse the undirected graph and assign labels to nodes. The key is that we arbitrarily assign the first node one label and then alternate labels each time we cross an edge. If we ever find two neighbors with the same label, we know the graph is not bipartite.</p>&#13;
<p class="TX">We can picture the algorithm in the context of competing spy agencies at a cocktail party. The agencies consist of disjoint sets of spies, represented as nodes. Each edge signifies the connection between two people who are watching each other. The spies are well trained and can each keep an eye on multiple people at once—Spy A might be watching Spy B, Spy C, and Spy D!</p>&#13;
<p class="TX">A bored waiter, unaware of the true identities of anyone in the ballroom, uses the opportunity to determine which spies work together. They start by picking one spy at random and assigning them to the green team. They determine all the people that spy is watching and assign each of them to the yellow team. Then, for each of the newly discovered yellow members, the waiter determines who they are watching and assigns those people being watched to the green team. The process bounces back and forth, uncovering the affiliations of each person as the waiter serves various appetizers.</p>&#13;
<p class="TX">Of course, if the waiter ever finds a spy watching a member of their own team, they know they do not have a bipartite graph. Maybe the agencies sent internal affairs or there is a double agent. Regardless, the situation is no longer as clear as yellow versus green and probably is not something with which the waiter wants to be involved.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-209"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The code for bipartite graph labeling in <a href="#list15-1">Listing 15-1</a> uses a breadth-first search to iteratively explore the graph and label nodes as belonging to either the right or left side.</p>&#13;
<span id="list15-1"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>def bipartite_labeling(g: Graph) -&gt; Union[list, None]: &#13;
    label: list = [None] * g.num_nodes&#13;
    pending: queue.Queue = queue.Queue()&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for start in range(g.num_nodes):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if label[start] is not None:&#13;
            continue&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> pending.put(start)&#13;
        label[start] = True&#13;
        while not pending.empty():&#13;
            current: int = pending.get()&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> next_label = not label[current]&#13;
&#13;
            for edge in g.nodes[current].get_edge_list():&#13;
                neighbor: int = edge.to_node&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> if label[neighbor] is None:&#13;
                    pending.put(neighbor)&#13;
                    label[neighbor] = next_label&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> elif label[neighbor] != next_label:&#13;
                    return None&#13;
    return label&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: Labeling nodes according to which side of the bipartite graph they occupy</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp> function maintains a list mapping each node index to one of three states (unlabeled = <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, right = <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, or left = <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) using a combination of Boolean and <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> values. The code starts by setting up the list of labels (<samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>) and a queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>), which requires us to import Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> library. Each label is initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, indicating that the algorithm has not yet seen a node and given it a label. This list will serve the roles of both tracking the seen nodes in breadth-first search and storing the labels.</p>&#13;
<p class="TX">The main body of the code is a repeated breadth-first search where an outer loop starts a new search on any unvisited node <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop checks whether each potential starting node has already been seen by a previous search. If so (the node’s label is not <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>), the code skips it <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If the node has not been seen, the code adds it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> queue for the breadth-first search, marks it as belonging to the left-hand side (label of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>), and starts a new breadth-first search from that node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">During each step of the breadth-first search, the code gets the current node being explored and uses its label to determine that of its neighbors <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. That is, the current node’s neighbors must all have the opposite label; otherwise, the graph is not bipartite. The code iterates over the node’s edges and checks each neighbor. If the neighbor has not been seen (label is <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>) <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>, the code sets the label (marking it seen) and adds it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> queue. If the node has been seen, the code takes the opportunity to check the validity of its label <span class="CodeAnnotationCode" aria-label="annotation6">❻</span>. If the label does not match what is expected, the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>graph has two connected nodes on the same side and therefore is not bipartite. It immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate the problem.</p>&#13;
<p class="TX">If the code successfully finishes the series of breadth-first searches needed to explore every node, it returns a list of node labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> values. Otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate the graph is not bipartite. As with other examples throughout the book, we need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to support type hints for these multiple return values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2"><span id="sec5"/><span id="h-210"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig15-4">Figure 15-4</a> shows the steps of the bipartite labeling algorithm working on an example seven-node graph. In <a href="#fig15-4">Figure 15-4(a)</a>, an arbitrary node (0) is chosen, given the first label (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>), and added to the queue to explore. This corresponds to the waiter selecting the first spy to watch and assigning them to the green team.</p>&#13;
<p class="TX">After exploring node 0, the algorithm finds two neighbors, as shown in <a href="#fig15-4">Figure 15-4(b)</a>. It gives nodes 3 and 5 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> labels to indicate they are in the opposite set from node 0. Both nodes are also added to the queue.</p>&#13;
<p class="TX"><a href="#fig15-4">Figure 15-4(c)</a> shows the search’s state after exploring node 3 and discovering just one new neighbor, node 4. Since node 3 had a label of <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, the search gives node 4 a label of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The algorithm also checks all previously seen nodes, in this case node 0, to confirm their labels match the expected value. For the bored waiter, this step corresponds to watching the first person identified as a member of the yellow team. The waiter shifts behind a potted plant and notes that person 3 is watching person 0 back, as must be expected of any good spy. After a moment, the waiter notes that person 3 is also watching person 4. The waiter has found another member of the green team and notes this on a cocktail napkin.</p>&#13;
<p class="TX">The search continues through the graph one node at a time. At each step, the algorithm examines the full set of neighbors, labeling new ones and adding them to the queue as well as checking known neighbors’ labels for consistency. The search ends in <a href="#fig15-4">Figure 15-4(h)</a> after every node has been checked.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>&#13;
<figure class="IMG"><img id="fig15-4" class="img80" src="../images/f15004.jpg" alt="Each subfigure shows the graph from Fig. 15-3 with seven nodes and undirected edges (0, 3), (0, 5), (2, 1), (2, 5), (4, 3), (4, 5) and (6, 1). In subfigure B, node 0 is circled and the label list reads [T, /, /, F, /, F, /]" width="1622" height="2252"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: The steps of a successful bipartite graph check</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>We can also use this same algorithm to identify non-bipartite graphs. <a href="#fig15-5">Figure 15-5</a> shows the same algorithm on a non-bipartite graph, formed by adding a single additional edge to the graph in <a href="#fig15-4">Figure 15-4</a>. For the first few steps, the search progresses similarly to that in <a href="#fig15-4">Figure 15-4</a>. An arbitrary initial node is chosen in <a href="#fig15-5">Figure 15-5(a)</a> and explored in <a href="#fig15-5">Figure 15-5(b)</a>. The first hint of trouble occurs in <a href="#fig15-5">Figure 15-5(c)</a>, where node 1 is labeled as occurring on the left-hand side because it is a neighbor of node 3. We can easily tell this is a mistake from the visual representation, but the algorithm does not have that information yet. From its perspective, node 1 could very well be on the left-hand side. The algorithm will not see the problem until it proceeds further.</p>&#13;
<figure class="IMG"><img id="fig15-5" class="img100" src="../images/f15005.jpg" alt="A similar set of graphs to Figure 15-4 with an additional edge (1, 3). In subfigure E, node 1 is circled and the label array has an X through the entry for node 2." width="1626" height="1523"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: The steps of an unsuccessful bipartite graph check</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The algorithm finally notices the problem in <a href="#fig15-5">Figure 15-5(e)</a>, when it explores node 1. Since node 1’s own label is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, it expects its neighbors <span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/>to be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. This fails as soon as it checks node 2. Node 2 was previously labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> while exploring node 5, but node 2 cannot be both <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The graph is not bipartite.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-211"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">The <i>bipartite matching problem</i> consists of solving the matching problem on a bipartite graph and can be used to solve a number of real-world optimization and assignment problems. Due to the structure of the bipartite graph, each selected edge will join a single node from the left side with a single node from the right side. Depending on the task, the problem might be trying to maximize different criteria, such as the number of matches or the sum of the used edge weights. This formulation encompasses a wide range of real-world problems that we might not normally consider in the graph context, from job scheduling to planning office building organization to matching heroes with monsters in a magical dungeon.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-212"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scheduling Jobs</samp></h4>&#13;
<p class="TNI1">Suppose a physics laboratory wants to maximize the number of concurrent simulations run on its machines. The machines vary in capability, but each can run only a single program at a time. The scientists each submit a program to the human scheduler and urge the scheduler to prioritize their own work first. Yet each program comes with its own requirements, such as high memory or a GPU. The scheduler must respect these constraints, limiting the number of valid assignments.</p>&#13;
<p class="TX">The scheduler, sensing the perfect opportunity to employ a bipartite matching algorithm, models the allocations as an undirected graph. They list the scientists’ jobs in the left column and the computers in the right, then draw an edge from a program to a machine if the job can run on that machine. The jobs requiring high memory have edges to the high-memory machines, the jobs requiring GPUs have edges to the machines with GPUs, and so forth. Satisfied at their representation, they set about finding the maximum number of jobs that they can schedule at one time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-213"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Office Space</samp></h4>&#13;
<p class="TNI1">The Happy Data Structures corporation is looking to move into a new office. While most teams are counting down to move-in day with anticipation of the new space, the planners are worrying about how to assign each team to a work area in the new building. Each workspace has constraints based on the properties of the area, including natural light, access to resources, and size.</p>&#13;
<p class="TX">After days of collecting long lists of requirements, the planners decide to model the problem as a bipartite-graph-matching problem. One set of nodes represents the teams and the other represents the workspaces. Spaces that are compatible with a team’s needs are joined by an edge. Each team can be assigned only to a single space, and each space can have only a single team. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/>The planners use bipartite graph matching between the teams and spaces to find an assignment of all teams to spaces that satisfy their constraints.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-214"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning Quest Battles</samp></h4>&#13;
<p class="TNI1">An adventuring party is exploring a magical dungeon when they stumble upon a room full of monsters. Each adventurer agrees to take on a single monster, but the group needs to (quickly) make the assignments. Some assignments are invalid: the wizard cannot fight the magic-resistant lizard, and the sword master cannot challenge the cloud of vapor.</p>&#13;
<p class="TX">In a twist on the canonical job allocation problem, the party models the problem as a bipartite graph assignment. They use one set of nodes to represent the adventurers and the other to represent the monsters. Compatible enemies are linked with an edge. Now they just need to efficiently match each adventurer with an enemy.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h-215"/><samp class="SANS_Futura_Std_Bold_B_11">Exhaustive Algorithms</samp></h3>&#13;
<p class="TNI1">One straightforward approach to finding a variety of matchings, including maximum cardinality and maximum weight, is to simply try every combination of edges. We could enumerate all 2<sup>|</sup><i><sup>E</sup></i><sup>|</sup> possible sets of used edges, throw away ones that use any node more than once, and score the rest based on our metric of interest. In this section, we briefly consider an algorithm based on depth-first search that performs this <i>exhaustive search</i>. This algorithm provides a baseline to which to compare more computationally efficient approaches.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-216"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matching Data</samp></h4>&#13;
<p class="TNI1">To simplify and generalize the code in this section, we employ a wrapper data structure around the matching assignments that track both the assignments and the current score. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> object holds three pieces of information about the current matching:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the total number of nodes in the graph</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">assignments</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Stores a mapping of each node to its partner or <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> if the node is unmatched</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">score</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp><b>) </b>Stores the matching’s score</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> list is bidirectional and stores the partners for both sides of the bipartite graph. For example, the inclusion of edge (0, 4) would result in <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[0]=4</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments[4]=0</samp>.</p>&#13;
<p class="TX">To implement this wrapper data structure, we define a constructor to create an empty matching and provide functions adding and removing edges from the matching:</p>&#13;
<pre><code>class Matching:&#13;
    def __init__(self, num_nodes: int): &#13;
        self.num_nodes: int = num_nodes<span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/>&#13;
        self.assignments: list = [-1] * num_nodes&#13;
        self.score: float = 0.0&#13;
&#13;
    def add_edge(self, ind1: int, ind2: int, score: float): &#13;
        self.assignments[ind1] = ind2&#13;
        self.assignments[ind2] = ind1&#13;
        self.score += score&#13;
&#13;
    def remove_edge(self, ind1: int, ind2: int, score: float): &#13;
        self.assignments[ind1] = -1&#13;
        self.assignments[ind2] = -1&#13;
        self.score -= score&#13;
</code></pre>&#13;
<p class="TX">To simplify the example, neither the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> functions check node validity or whether a node is currently assigned. In real-world production software, you’ll often want to add checks that no node is used twice and that the added edge exists within the graph using similar checks to those in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-217"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exhaustive Scoring</samp></h4>&#13;
<p class="TNI1">We use an approach based on recursive depth-first search to enumerate which edges are used. Instead of exploring depth-first over the nodes, we explore over node assignments.</p>&#13;
<p class="TX">For example, consider the bipartite graph in <a href="#fig15-6">Figure 15-6</a>. Node 0 has three options for matching: nothing, node 1, or node 3. The same applies to node 2.</p>&#13;
<figure class="IMG"><img id="fig15-6" class="img40" src="../images/f15006.jpg" alt="A graph with four nodes and edges (0, 1), (0, 3), (2, 1) and (2, 3). The even nodes are in a single column on the left while the odd nodes are in a single column on the right." width="586" height="335"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: A bipartite graph with four nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can visualize the space of potential matchings for the graph in <a href="#fig15-6">Figure 15-6</a> as a tree where each level indicates the assignment of one of the left-hand nodes. This tree is shown in <a href="#fig15-7">Figure 15-7</a>. The first level of the tree splits into three scenarios based on the three different options for node 0. The left branch represents the options if we leave node 0 unpaired. The central branch represents the options with node 0 paired to node 1. The right branch represents the options with node 0 paired to node 3. We limit the search space by considering only potential matches that correspond to edges in the graph.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>&#13;
<figure class="IMG"><img id="fig15-7" class="img100" src="../images/f15007.jpg" alt="A tree showing potential matches. Each node is a vector of matches for each node. The root node is [–1, –1, –1, 1] while the rightmost bottom node is [3, 2, 1, 0]." width="1637" height="365"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-7: A search tree over the potential node-matching assignments</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The second level of the tree in <a href="#fig15-7">Figure 15-7</a> shows similar splits for the assignment of node 2. Since node 0 is already assigned in two of the three branches, those branches can split only into two sub-options.</p>&#13;
<p class="TX">Since this approach is performing an exhaustive search, it will work for a variety of bipartite matching problems, including maximum cardinality and maximum weight. As we will see, the only factor that changes is how we compute the matching’s score.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2"><span id="sec13"/><span id="h-218"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">We implement a search for the maximum-weight matching over this tree using a recursive algorithm:</p>&#13;
<pre><code>def bipartite_matching_exh(g: Graph) -&gt; Union[list, None]: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> labels: Union[list, None] = bipartite_labeling(g)&#13;
    if labels is None:&#13;
        return None&#13;
&#13;
    current: Matching = Matching(g.num_nodes)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> best_matching: Matching = matching_recursive(g, labels, current, 0)&#13;
    return best_matching.assignments&#13;
&#13;
def matching_recursive(g: Graph, labels: list, current: Matching,&#13;
                       index: int) -&gt; Matching: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if index &gt;= g.num_nodes:&#13;
        return copy.deepcopy(current)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if not labels[index]:&#13;
        return matching_recursive(g, labels, current, index + 1)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> best: Matching = matching_recursive(g, labels, current, index + 1)&#13;
    for edge in g.nodes[index].get_edge_list():&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> if current.assignments[edge.to_node] == -1:&#13;
            current.add_edge(index, edge.to_node, edge.weight)&#13;
            new_m: Matching = matching_recursive(g, labels, current, index + 1)&#13;
            if new_m.score &gt; best.score:&#13;
                best = new_m&#13;
            current.remove_edge(index, edge.to_node, edge.weight)&#13;
    return best&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>The outer wrapper function <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_exh()</samp> labels the sides of the graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and sets up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> data structure. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> if the graph is not bipartite (again necessitating the inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">import Union</samp> to support the type hints for multiple return values). It then calls the recursive function to do the matching <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">The recursive function <samp class="SANS_TheSansMonoCd_W5Regular_11">matching_recursive()</samp> starts by checking whether it has hit the bottom of the search <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>, where everything on the left-hand side has been assigned (even if to <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>). If there are no more nodes to assign, it returns a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> as the best assignments found down this branch using the <samp class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp> function from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> library. The code performs the copy to effectively snapshot this match and separate it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> object that it will continue to modify during the rest of the search. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">deepcopy()</samp> requires the inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">import copy</samp> at the top of the file.</p>&#13;
<p class="TX">The code then checks whether this node is on the left-hand side of the graph <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. Since the code makes assignments only from the left nodes, we skip the right ones by calling the recursive function with the current matching at the next index. While the code could be modified to test both sides, assigning the right-side nodes is unnecessary. Each edge can be used only once and is guaranteed to be adjacent to a left-side node.</p>&#13;
<p class="TX">The code then checks each available option for a match to the current node and saves the best one, starting with the choice of leaving the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) unassigned by calling the recursive function with the current matching at the next index <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>. The code saves the best matching down this branch for later comparison as <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp>. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each of the current node’s neighbors, checking the current matching assignments so it can skip nodes that are already assigned to others <span class="CodeAnnotationCode" aria-label="annotation6">❻</span>. The code adds each viable neighbor to the matching, uses the recursive function to get the best matching down that path, updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">best</samp> matching if necessary, and removes the edge from the matching. Finally, it returns the best matching down this entire branch.</p>&#13;
<p class="TX">We can change the implementation from the maximum-weight matching in the code to a maximum-cardinality matching by changing the score passed to the matching. That is, we swap <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">edge.weight</samp> when adding or removing edges. With this change, the search selects matchings with the higher number of assigned edges instead of the greater total weight.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h-219"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1">We can visualize this function by looking at the state of the current matching each time the algorithm hits the bottom of the recursion. <a href="#fig15-8">Figure 15-8</a> shows the first nine times the algorithm hits the end of the recursion on an example graph.</p>&#13;
<p class="TX">Since the algorithm tests the no-assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>) branch first, the recursion encounters the full assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1,-1,-1,-1]</samp> in <a href="#fig15-8">Figure 15-8(a)</a>. After evaluating this empty matching, the search backtracks and tests alternate assignments for node 4 while keeping the assignments for nodes 0 and 2 from previous decisions fixed. This produces the matchings in <a href="#fig15-8">Figures 15-8(b)</a>, <a href="#fig15-8">15-8(c)</a>, and <a href="#fig15-8">15-8(d)</a>. It is not until <a href="#fig15-8">Figure 15-8(f)</a> that the algorithm evaluates a matching with two edges used.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>&#13;
<figure class="IMG"><img id="fig15-8" class="img100" src="../images/f15008.jpg" alt="Each subgraph shows a six-node bipartite graph with zero or more edges bolded. The score is the sum of the weights of the bolded edges." width="1667" height="2074"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-8: The first nine steps of the exhaustive search algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/>While the exhaustive algorithm is both complete and generalizable, it is far from efficient, especially on large graphs. Even the search of the six-node graph in <a href="#fig15-8">Figure 15-8</a> explores 34 different assignments. The next section introduces one of the specialized algorithms that exist to efficiently solve individual matching problems.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-220"/><samp class="SANS_Futura_Std_Bold_B_11">Solving the Maximum-Cardinality Bipartite Problem</samp></h3>&#13;
<p class="TNI1">This section shows how to use the max-flow algorithms from the previous chapter to solve the maximum-cardinality bipartite problem efficiently. We can transform the maximum-cardinality bipartite problem directly into a maximum-flow problem by transforming the bipartite graph into a flow network with directed edges and unit weights. <a href="#fig15-9">Figure 15-9(a)</a> shows a bipartite graph and <a href="#fig15-9">Figure 15-9(b)</a> shows the result of this transformation. We add a single source node <i>s</i> that feeds all the nodes in the left column. We add a single sink node <i>t</i> to accept flow from the nodes in the right column. Each edge in the graph is directed from left to right and has a capacity of 1. (To reduce clutter, the illustration does not include the capacity of the edges.)</p>&#13;
<figure class="IMG"><img id="fig15-9" class="img100" src="../images/f15009.jpg" alt="(A) shows a bipartite graph with five nodes on the left and four on the right. The graph has edges (0, 1), (0, 5), (0, 7), (2, 1), (4, 3), (4, 7), (6, 1), and (8, 3). (B) shows an expanded graph with an additional source node feeding the left-hand nodes and a sink node fed by the right-hand nodes." width="1369" height="742"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-9: A bipartite graph (a) and its flow network version (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Using this setup, the source node can supply each of the left-hand nodes with up to a single unit of flow. Similarly, each node in the right-hand column can provide at most 1 unit of flow to the sink. Given the constraint that the flow into a node must equal the flow out of it, each node on the left can send flow to at most 1 unit of flow to a node on the right. Each node on the right can accept at most 1 unit of flow from a node on the left. The maximum flow is equal to the maximum number of pairs we can assign.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>&#13;
<h4 class="H2"><span id="sec16"/><span id="h-221"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The code for performing maximum-cardinality bipartite matching with the max-flow algorithm reuses the Edmonds-Karp implementation from <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> to do all the heavy lifting. Much of the wrapper function itself transforms the graph by adding a source and sink node, then later pruning the unneeded edges:</p>&#13;
<pre><code>def bipartite_matching_max_flow(g: Graph) -&gt; Union[list, None]: &#13;
    num_nodes: int = g.num_nodes&#13;
&#13;
    labeling: Union[list, None] = bipartite_labeling(g)&#13;
    if labeling is None:&#13;
        return None&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> extended: Graph = Graph(g.num_nodes + 2, undirected=False)&#13;
    for node in g.nodes:&#13;
        for edge in node.edges.values():&#13;
            if labeling[edge.from_node]:&#13;
                extended.insert_edge(edge.from_node, edge.to_node, 1.0)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> source_ind: int = num_nodes&#13;
    sink_ind: int = num_nodes + 1&#13;
    for i in range(num_nodes):&#13;
        if labeling[i]:&#13;
            extended.insert_edge(source_ind, i, 1.0)&#13;
        else:&#13;
            extended.insert_edge(i, sink_ind, 1.0)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> residual: ResidualGraph = edmonds_karp(extended, source_ind, sink_ind)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> result: list = [-1] * g.num_nodes&#13;
    for from_node in range(residual.num_nodes):&#13;
        if from_node != source_ind:&#13;
            edge_list: dict = residual.edges[from_node]&#13;
            for to_node in edge_list.keys():&#13;
                if to_node != sink_ind and edge_list[to_node].used &gt; 0.0:&#13;
                    result[from_node] = to_node&#13;
                    result[to_node] = from_node&#13;
    return result&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_matching_max_flow()</samp> function returns either a list of assignments (in the same bidirectional format as <samp class="SANS_TheSansMonoCd_W5Regular_11">Matching</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">assignments</samp> list) or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> if the graph is not bipartite.</p>&#13;
<p class="TX">To build the augmented graph, the code first must know which nodes are on which side of the bipartite graph. It reuses the <samp class="SANS_TheSansMonoCd_W5Regular_11">bipartite_labeling()</samp> function from <a href="#list15-1">Listing 15-1</a>, taking the opportunity to also check for non-bipartite graphs.</p>&#13;
<p class="TX">The code then builds an augmented graph. First, it creates a new (directed) graph with two extra nodes for the source and sink <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Second, it adds directed edges, each with a capacity of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, going from the left <span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>column to the right column, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">labeling</samp> list to determine in which column a node belongs. Finally, the code connects the source and sink <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. It adds edges from the source to each of the original graph’s left-hand nodes and edges from each of the original graph’s right-hand nodes to the sink.</p>&#13;
<p class="TX">The code runs the Edmonds-Karp algorithm on the graph to find the maximum flow through it <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> in the resulting graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">residual</samp>) that has used flow are connected. However, the overall graph also still contains the source node, the sink node, and all their corresponding edges. The code iterates through the edges and fills in the assignments for each <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> where <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> is greater than zero, the origin is not the source node, and the destination is not the sink node <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2"><span id="sec17"/><span id="h-222"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig15-10">Figure 15-10</a> shows the steps the maximum-flow algorithm takes as it identifies a matching on the example bipartite graph in <a href="#fig15-9">Figure 15-9</a>. Edges at capacity (<samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> equals 1) after each step of the algorithm are bolded.</p>&#13;
<p class="TX">We can picture this algorithm in the context of the job-scheduling algorithm introduced in <span class="Xref">“Use Cases”</span> on <span class="Xref"><a href="chapter15.xhtml#pg_263">page 263</a></span>. Job 0 (node 0) is the most flexible job, with the ability to run on three of the four machines. In contrast, jobs 2, 6, and 8 are limited to running on specific machines.</p>&#13;
<p class="TX"><a href="#fig15-10">Figure 15-10(a)</a> shows the initial state where the algorithm has added the source node, the sink node, and all the corresponding edges. No edges carry any flow yet. This corresponds to starting in an empty state with no jobs scheduled to run on any machine.</p>&#13;
<p class="TX"><a href="#fig15-10">Figures 15-10(b)</a> and <a href="#fig15-10">15-10(c)</a> show the state of assignments after the code finds the first two augmenting paths. During the first round, it discovers that the unassigned job 0 can run on the unused machine 1 and makes that assignment. In the second round, it does the same with job 4 and machine 3.</p>&#13;
<p class="TX">Things get interesting at this point, as shown in <a href="#fig15-10">Figure 15-10(d)</a>. By assigning job 0 to machine 1, the algorithm has blocked both jobs 2 and 6, as both can only run on machine 1. Luckily, the algorithm can handle this by finding a new augmenting path: (<i>s</i>, 2), (2, 1), (1, 0), (0, 5), (5, <i>t</i>). In doing so, it pushes flow backward along the edge (0, 1), unassigning job 0 from machine 1. The result is an assignment with one more job scheduled.</p>&#13;
<p class="TX"><a href="#fig15-10">Figure 15-10(e)</a> shows a similar multi-step augmenting path. This new path consists of edges (<i>s</i>, 8), (8, 3), (3, 4), (4, 7), and (7, <i>t</i>). The code unassigns job 4 from machine 3 and then assigns job 4 to machine 7 and job 8 to machine 3.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/>&#13;
<figure class="IMG"><img id="fig15-10" class="img80" src="../images/f15010.jpg" alt="Each subfigure shows the same graph with different edges bolded to indicate the used paths. (B) has a single path (s, 0), (0, 1), (1, t) bolded." width="1664" height="2165"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-10: The max-flow algorithm operating on an augmented bipartite graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>After the maximum-flow algorithm completes, it has produced the graph in <a href="#fig15-10">Figure 15-10(e)</a>. To produce the matching list, it then walks the edges of the residual graph. It skips all edges connected to either the source node <i>s</i> or the sink node <i>t</i>, since those were not part of the original bipartite graph. It saves all connections with nonzero flow. The result with matched edges (0, 5), (2, 1), (4, 7), and (8, 3) is shown in <a href="#fig15-11">Figure 15-11</a>. The unused connections in the original bipartite graph are shown in thin gray lines for reference.</p>&#13;
<figure class="IMG"><img id="fig15-11" class="img30" src="../images/f15011.jpg" alt="A bipartite graph with five nodes on the left and four on the right. The graph has edges (0, 1), (0, 5), (0, 7), (2, 1), (4, 3), (4, 7), (6, 1), and (8, 3). The edges (0, 5), (2, 1), (4, 7), and (8, 3) are bolded." width="439" height="752"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-11: A bipartite graph with edges in the maximum-cardinality matching bolded</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The maximum-flow algorithm will only find a single maximum-cardinality matching that is not necessarily unique. In <a href="#fig15-11">Figure 15-11</a>, for example, alternative matchings are possible. Instead of including the edge (2, 1), we could have included the edge (6, 1).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h-223"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Bipartite graphs enable us to translate a range of assignment problems to equivalent graph algorithms, allowing access to a wealth of powerful graph algorithms. In doing so, we can solve problems that we might not initially think of as graph-based. A clear example of this flexibility is the maximum-cardinality matching problem, which transforms the problem of matching items from two disjoint sets into a graph problem that we can solve with maximum-flow algorithms.</p>&#13;
<p class="TX">In the next section of the book, we switch topics and consider a variety of computationally challenging problems on graphs. <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> introduces the problem of assigning colors to graph nodes such that no two neighbors share a color. <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span> considers a variety of other useful node assignment problems. Finally, <span class="Xref"><a href="chapter18.xhtml">Chapter 18</a></span> extends the examination of challenging problems to that of finding specific types of paths through graphs.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>