<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_217"/><strong><span class="big">8</span><br/>BOOLEAN LOGIC AND DIGITAL DESIGN</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">Boolean logic is the basis of computation in modern computer systems. You can represent any algorithm, or any electronic computer circuit, using a system of Boolean equations. To fully understand how software operates, then, you need to understand basic Boolean logic and digital design.</p>&#13;
<p class="indent">This material is especially important to those who want to design electronic circuits or write software that controls them. Even if you don’t plan to do this, you can use your knowledge of Boolean logic to optimize your software. Many high-level languages process Boolean expressions, such as those that control an <code>if</code> statement or <code>while</code> loop. Understanding Boolean logic provides the tools you need to optimize your Boolean expressions and improve the performance of HLL code.</p>&#13;
<p class="indent">This chapter covers the following subjects, which will aid you when you attempt to optimize Boolean expressions:</p>&#13;
<ul>&#13;
<li class="noindent">Boolean algebra, Boolean operators, and Boolean functions</li>&#13;
<li class="noindent">An introduction to Boolean postulates and theorems</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_218"/>Truth tables and Boolean function optimization</li>&#13;
<li class="noindent">Canonical forms</li>&#13;
<li class="noindent">Electronic circuits and their Boolean function counterparts</li>&#13;
</ul>&#13;
<p class="indent">Although a detailed knowledge of Boolean algebra and digital circuit design isn’t necessary if you simply want to write typical programs, familiarity with these topics will help answer why CPU manufacturers implement instructions in certain ways—questions that will undoubtedly arise as we begin looking at the CPU’s low-level implementation.</p>&#13;
<h3 class="h3" id="sec8_1"><strong>8.1 Boolean Algebra</strong></h3>&#13;
<p class="noindent">Boolean algebra is a deductive mathematical system. A <em>binary operator</em> (°) accepts a pair of Boolean inputs and produces a single Boolean value. For example, the Boolean AND operator accepts two Boolean inputs and produces a single Boolean output (the logical AND of the two inputs).</p>&#13;
<h4 class="h4" id="sec8_1_1"><strong><em>8.1.1 The Boolean Operators</em></strong></h4>&#13;
<p class="noindent">For our purposes, we will base Boolean algebra on the following set of values and operators:</p>&#13;
<ul>&#13;
<li class="noindent">The two possible values in the Boolean system are 0 and 1. Often, we call these values <code>false</code> and <code>true</code>, respectively.</li>&#13;
<li class="noindent">The • symbol represents the logical AND operation. <em>A</em> • <em>B</em> is the operation of logically ANDing the Boolean values <em>A</em> and <em>B</em>, also known as the <em>product</em> of <em>A</em> and <em>B</em>. For single-letter variable names, this text drops the • symbol; therefore, <em>AB</em> also represents the logical AND of the variables <em>A</em> and <em>B</em>.</li>&#13;
<li class="noindent">The + (plus sign) represents the logical OR operation. <em>A</em> + <em>B</em> is the result of logically ORing the Boolean values <em>A</em> and <em>B</em>. We also call this the <em>sum</em> of <em>A</em> and <em>B</em>.</li>&#13;
<li class="noindent">Logical complement, logical negation, and NOT are all names for the same unary operator. This chapter will use the ' (prime symbol) to denote logical negation. <em>A'</em> denotes the logical NOT of <em>A</em>.</li>&#13;
</ul>&#13;
<h4 class="h4" id="sec8_1_2"><strong><em>8.1.2 Boolean Postulates</em></strong></h4>&#13;
<p class="noindent">Every algebraic system follows a certain set of initial assumptions, or <em><a href="gloss01.xhtml#gloss01_198">postulates</a></em>. You can deduce additional rules, theorems, and other properties of the system from this basic set of postulates. Boolean algebra employs the following postulates:</p>&#13;
<p class="uln-indent"><strong>Closure</strong> A Boolean system is <em>closed</em> with respect to a particular binary operator if, for every pair of Boolean values, it produces only a Boolean result.</p>&#13;
<p class="uln-indent"><strong>Commutativity</strong> A binary operator ° is <em>commutative</em> if <em>A</em> ° <em>B</em> = <em>B</em> ° <em>A</em> for all possible Boolean values <em>A</em> and <em>B</em>.</p>&#13;
<p class="uln-indent"><span epub:type="pagebreak" id="page_219"/><strong>Associativity</strong> A binary operator ° is <em>associative</em> if (<em>A</em> ° <em>B</em>) ° <em>C</em> = <em>A</em> ° (<em>B</em> ° <em>C</em>) for all Boolean values <em>A</em>, <em>B</em>, and <em>C</em>.</p>&#13;
<p class="uln-indent"><strong>Distribution</strong> Two binary operators ° and % are <em><a href="gloss01.xhtml#gloss01_77">distributive</a></em> if <em>A</em> ° (<em>B</em> % <em>C</em>) = (<em>A</em> ° <em>B</em>) % (<em>A</em> ° <em>C</em>) for all Boolean values <em>A</em>, <em>B</em>, and <em>C</em>.</p>&#13;
<p class="uln-indent"><strong>Identity</strong> A Boolean value <em>I</em> is said to be the <em>identity element</em> with respect to some binary operator ° if <em>A</em> ° <em>I</em> = <em>A</em> for all Boolean values <em>A</em>.</p>&#13;
<p class="uln-indent"><strong>Inverse</strong> A Boolean value <em>I</em> is said to be the <em>inverse element</em> with respect to some binary operator ° if <em>A</em> ° <em>I</em> = <em>B</em> and <em>B</em> ° <em>A</em> (that is, <em>B</em> is the opposite value of <em>A</em> in a Boolean system) for all Boolean values <em>A</em> and <em>B</em>.</p>&#13;
<p class="indent">When applied to the Boolean operators, the preceding postulates produce the following set of <em>Boolean postulates</em>:</p>&#13;
<p class="uln-indent"><strong>P1</strong>   Boolean algebra is closed under the AND, OR, and NOT operations.</p>&#13;
<p class="uln-indent"><strong>P2</strong>   The identity element of AND (•) is 1, and the identity element of OR (+) is 0. There’s no identity element for logical NOT (').</p>&#13;
<p class="uln-indent"><strong>P3</strong>   The • and + operators are commutative.</p>&#13;
<p class="uln-indent"><strong>P4</strong>   • and + are distributive with respect to each other. That is, <em>A</em> • (<em>B</em> + <em>C</em>) = (<em>A</em> • <em>B</em>) + (<em>A</em> • <em>C</em>) and <em>A</em> + (<em>B</em> • <em>C</em>) = (<em>A</em> + <em>B</em>) • (<em>A</em> + <em>C</em>).</p>&#13;
<p class="uln-indent"><strong>P5</strong>   • and + are both associative. That is, (<em>A</em> • <em>B</em>) • <em>C</em> = <em>A</em> • (<em>B</em> • <em>C</em>) and (<em>A</em> + <em>B</em>) + <em>C</em> = <em>A</em> + (<em>B</em> + <em>C</em>).</p>&#13;
<p class="uln-indent"><strong>P6</strong>   For every value <em>A</em> there exists a value <em>A'</em> such that <em>A</em> • <em>A'</em> = 0 and <em>A</em> + <em>A'</em> = 1. This value is the logical complement (or NOT) of <em>A</em>.</p>&#13;
<p class="indent">You can prove all other theorems in Boolean algebra using this set of Boolean postulates. This chapter won’t go into the formal proofs of the following theorems, but familiarity with them will be useful:</p>&#13;
<p class="uln-indent"><strong>Th1</strong>   <em>A</em> + <em>A</em> = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th2</strong>   <em>A</em> • <em>A</em> = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th3</strong>   <em>A</em> + 0 = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th4</strong>   <em>A</em> • 1 = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th5</strong>   <em>A</em> • 0 = 0</p>&#13;
<p class="uln-indent"><strong>Th6</strong>   <em>A</em> + 1 = 1</p>&#13;
<p class="uln-indent"><strong>Th7</strong>   (<em>A</em> + <em>B</em>)<em>' = A'</em> • <em>B'</em></p>&#13;
<p class="uln-indent"><strong>Th8</strong>   (<em>A</em> • <em>B</em>)<em>'</em> = <em>A'</em> + <em>B'</em></p>&#13;
<p class="uln-indent"><strong>Th9</strong>   <em>A</em> + <em>A</em> • <em>B</em> = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th10</strong>   <em>A</em> • (<em>A</em> + <em>B</em> ) = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th11</strong>   <em>A</em> + <em>A'B</em> = <em>A</em> + <em>B</em></p>&#13;
<p class="uln-indent"><strong>Th12</strong>   <em>A'</em> • (<em>A</em> + <em>B'</em>) = <em>A'B'</em></p>&#13;
<p class="uln-indent"><strong>Th13</strong>   <em>AB</em> + <em>AB'</em> = <em>A</em></p>&#13;
<p class="uln-indent"><strong>Th14</strong>   (<em>A'</em> + <em>B'</em> ) • (<em>A'</em> + <em>B</em>) = <em>A'</em></p>&#13;
<p class="uln-indent"><strong>Th15</strong>   <em>A</em> + <em>A'</em> = 1</p>&#13;
<p class="uln-indent"><strong>Th16</strong>   <em>A</em> • <em>A'</em> = 0</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_220"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Theorems 7 and 8 are called</em> DeMorgan’s Theorems <em>after the mathematician who discovered them.</em></p>&#13;
</div>&#13;
<p class="indent">An important principle in the Boolean algebra system is <em>duality</em>. Each pair, theorems 1 and 2, theorems 3 and 4, and so on, forms a <em>dual</em>. Any valid expression you can create using the postulates and theorems of Boolean algebra remains valid if you interchange the operators and constants appearing in the expression. Specifically, if you exchange the • and + operators and swap the 0 and 1 values in an expression, the resulting expression will obey all the rules of Boolean algebra. <em>This does not mean the dual expression computes the same values</em>, only that both expressions are legal in the Boolean algebra system.</p>&#13;
<h4 class="h4" id="sec8_1_3"><strong><em>8.1.3 Boolean Operator Precedence</em></strong></h4>&#13;
<p class="noindent">If several different Boolean operators appear within a single Boolean expression, the result of the expression depends on the <em><a href="gloss01.xhtml#gloss01_201">precedence</a></em> of the operators. The following Boolean operators are ordered from highest precedence to lowest:</p>&#13;
<ul>&#13;
<li class="noindent">Parentheses</li>&#13;
<li class="noindent">Logical NOT</li>&#13;
<li class="noindent">Logical AND</li>&#13;
<li class="noindent">Logical OR</li>&#13;
</ul>&#13;
<p class="indent">The logical AND and OR operators are <em>left associative</em>. This means that if two operators with the same precedence appear between three operands, you must evaluate the expressions from left to right. The logical NOT operation is <em>right associative</em>, although it would produce the same result using either left or right associativity because it is a unary operator having only a single operand.</p>&#13;
<h3 class="h3" id="sec8_2"><strong>8.2 Boolean Functions and Truth Tables</strong></h3>&#13;
<p class="noindent">A Boolean <em>expression</em> is a sequence of 0s, 1s, and literals separated by Boolean operators. A Boolean <em>literal</em> is a primed (negated) or unprimed variable name, and all variable names are a single alphabetic character. A Boolean function is a specific Boolean expression; we generally give Boolean functions the name <em>F</em> with a possible subscript. For example, consider the following Boolean function:</p>&#13;
<p class="equation"><em>F</em><sub>0</sub> = <em>AB</em> + <em>C</em></p>&#13;
<p class="indent">This function computes the logical AND of <em>A</em> and <em>B</em> and then logically ORs this result with <em>C</em>. If <em>A</em> = 1, <em>B</em> = 0, and <em>C</em> = 1, then <em>F</em><sub>0</sub> returns 1 (1 • 0 + 1 = 1).</p>&#13;
<p class="indent">You can also represent a Boolean function with a <em>truth table</em>. The truth tables for the logical AND and OR functions are shown in <a href="ch08.xhtml#ch08tab01">Tables 8-1</a> and <a href="ch08.xhtml#ch08tab02">8-2</a>, respectively.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_221"/><a id="ch08tab01"/><strong>Table 8-1:</strong> AND Truth Table</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>AND</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>0</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>1</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><a id="ch08tab02"/><strong>Table 8-2:</strong> OR Truth Table</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>OR</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>0</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>1</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For binary operators and two input variables, this truth table format is very intuitive and convenient. However, for functions involving more than two variables, it doesn’t work well.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08tab03">Table 8-3</a> shows another way to represent truth tables. This format has several advantages—it is easier to fill in the table, it supports three or more variables, and it provides a compact representation for two or more functions.</p>&#13;
<p class="tabcap"><a id="ch08tab03"/><strong>Table 8-3:</strong> Truth Table Format for a Function of Three Variables</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>C</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>B</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>A</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>F = ABC</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>F = AB + C</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>F = A + BC</em></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Although you can create an infinite variety of Boolean functions, they are not all unique. For example, <em>F</em> = <em>A</em> and <em>F</em> = <em>AA</em> are two different functions. By theorem 2, however, it’s easy to show that these two functions produce exactly the same result no matter what input value you supply for <em>A</em>. As it turns out, if you fix the number of input variables, there’s a finite number of unique Boolean functions possible. For example, there are 16 unique Boolean functions with two input variables, and there are 256 possible Boolean functions with three input variables. Given <em>n</em> input variables, there are 2<sup>2<sup><em>n</em></sup></sup> unique Boolean functions (2 raised to 2 raised to the <em>n</em>th power). With two input variables, there are 2<sup>2</sup><sup>2</sup> or 16 different functions. With three input variables, there are 2<sup>2</sup><sup>3</sup> or 256 possible functions. Four input variables have 2<sup>2</sup><sup>4</sup> or 2<sup>16</sup> or 65,536 unique Boolean functions.</p>&#13;
<p class="indent">When working with only 16 Boolean functions (two input variables), we can name each unique function (see <a href="ch08.xhtml#ch08tab04">Table 8-4</a>).</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_222"/><a id="ch08tab04"/><strong>Table 8-4:</strong> Common Names for Boolean Functions of Two Variables</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th">Function number<sup><a href="footnotes.xhtml#fn8_1a" id="fn8_1">1</a></sup></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Function name</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Zero (clear)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Always returns 0 regardless of <em>A</em> and <em>B</em> input values.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Logical NOR</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">(NOT (<em>A</em> OR <em>B</em>)) = (<em>A</em> + <em>B</em>)<em>'</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Inhibition (<em>AB</em><span class="EmpItalic">'</span>)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Inhibition = <em>AB</em><em>'</em> (<em>A</em> AND not <em>B</em>). Also equivalent to <em>A</em> &gt; <em>B</em> or <em>B</em> &lt; <em>A</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">NOT <em>B</em></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Ignores <em>A</em> and returns <em>B</em><em>'</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Inhibition (<em>BA</em><em>'</em>)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Inhibition = <em>BA</em><em>'</em> (<em>B</em> AND not <em>A</em>). Also equivalent to <em>B</em> &gt; <em>A</em> or <em>A</em> &lt; <em>B</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">5</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">NOT <em>A</em></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Returns <em>A</em><em>'</em> and ignores <em>B</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">6</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Exclusive-OR (XOR)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A</em> ⊕ <em>B</em>. Equivalent to <em>A</em> ≠ <em>B</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">7</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Logical NAND</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">(NOT (<em>A</em> AND <em>B</em>)) = (<em>A</em> • <em>B</em>)<em>'</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">8</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Logical AND</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A</em> • <em>B</em> = (<em>A</em> AND <em>B</em>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">9</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Equivalence (exclusive-NOR)</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">(<em>A</em> = <em>B</em>). Also known as exclusive-NOR (not exclusive-OR).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">10</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A</em></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Copy <em>A</em>. Returns the value of <em>A</em> and ignores <em>B</em>’s value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">11</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Implication, <em>B</em> implies <em>A</em></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><em>A</em> + <em>B</em><em>'</em>. (If <em>B</em> then <em>A</em>.) Equivalent to <em>B</em> ≥ <em>A</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">12</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>B</em></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Copy <em>B</em>. Returns the value of <em>B</em> and ignores <em>A</em>’s value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">13</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Implication, <em>A</em> implies <em>B</em></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><em>B</em> + <em>A</em><em>'</em>. (If <em>A</em> then <em>B</em>.) Equivalent to <em>A</em> ≥ <em>B</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">14</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Logical OR</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A</em> + <em>B</em>. Returns <em>A</em> OR <em>B</em>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">15</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">One (set)</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Always returns 1 regardless of <em>A</em> and <em>B</em> input values.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="sec8_3"><strong>8.3 Function Numbers</strong></h3>&#13;
<p class="noindent">Beyond two input variables, there are too many functions to provide a specific name for each. Even when referring to functions with two input variables, we’ll refer to the function’s number rather than its name. For example, <em>F</em><sub>8</sub> denotes the logical AND of <em>A</em> and <em>B</em> for a two-input function, and <em>F</em><sub>14</sub> denotes the logical OR operation. Of course, for functions with more than two input variables, the question is, “How do we determine a function’s number?” For example, what is the corresponding number for the function <em>F</em> = <em>AB</em> + <em>C</em> ? We compute the answer by looking at the function’s truth table. If we treat the values for <em>A</em>, <em>B</em>, and <em>C</em> as bits in a binary number with <em>C</em> being the HO bit and <em>A</em> being the LO bit, they produce the binary strings that correspond to numbers in the range 0 through 7. Associated with each of these binary strings is the function result, either 0 or 1. If we construct a binary number by placing the function result of each <span epub:type="pagebreak" id="page_223"/>combination of the <em>A</em>, <em>B</em>, and <em>C</em> input values into the bit position specified by the binary string of the <em>A</em>, <em>B</em>, and <em>C</em> bits, the resulting binary number will be the corresponding function number. If this doesn’t make sense, an example will help clear it up. Consider the truth table for <em>F</em> = <em>AB</em> + <em>C</em> (see <a href="ch08.xhtml#ch08tab05">Table 8-5</a>).</p>&#13;
<p class="tabcap"><a id="ch08tab05"/><strong>Table 8-5:</strong> Truth Table for <em>F</em> = <em>AB</em> + <em>C</em></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>C</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>B</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>A</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>F = AB + C</em></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The input variables <em>C</em>, <em>B</em>, and <em>A</em> combine to form binary number sequences in the range <code>%000</code> through <code>%111</code> (0 through 7). If we use these values to denote bit numbers in an 8-bit value (<em>CBA</em> = <code>%111</code> specifies bit 7, <em>CBA</em> = <code>%110</code> specifies bit 6, and so on), we can determine the function number by placing at each of these bit positions the result of <em>F</em> = <em>AB</em> + <em>C</em>, for the corresponding combination of <em>C</em>, <em>B</em>, and <em>A</em> values:</p>&#13;
<pre>CBA:           7    6    5    4    3    2    1    0<br/>&#13;
F = AB + C:    1    1    1    1    1    0    0    0</pre>&#13;
<p class="indent">Now, if we treat this bit string as a binary number, it produces the function number <code>$F8</code>, or 248. We usually denote function numbers in decimal. This also provides insight into why there are 2<sup>2<sup><em>n</em></sup></sup> different functions given <em>n</em> input variables: if you have <em>n</em> input variables, there are 2<sup><em>n</em></sup> different variable value combinations, and thus 2<sup><em>n</em></sup> bits in the function’s binary number. If you have <em>m</em> bits, there are 2<sup><em>m</em></sup> different possible arrangements of those bits. Therefore, for <em>n</em> input variables there are <em>m</em> = 2<sup><em>n</em></sup> possible bits and 2<sup><em>m</em></sup> or 2<sup>2<sup><em>n</em></sup></sup> possible functions.</p>&#13;
<h3 class="h3" id="sec8_4"><strong>8.4 Algebraic Manipulation of Boolean Expressions</strong></h3>&#13;
<p class="noindent">You can transform one Boolean expression into an equivalent expression by applying the postulates and theorems of Boolean algebra. This is important if you want to convert a given expression to a canonical form (see the next section) or if you want to minimize the number of literals or terms in an expression. (A <em>literal</em> is a primed or unprimed variable, and a <em>term</em> is a variable or a product—logical AND—of several different literals.) Electrical circuits often consist of individual components that implement each literal <span epub:type="pagebreak" id="page_224"/>or term, so minimizing the number of literals and terms in an expression allows a circuit designer to use fewer electrical components and, therefore, to reduce the monetary cost of the system.</p>&#13;
<p class="indent">Unfortunately, there are no fixed rules you can apply to optimize a given expression. Much like constructing mathematical proofs, an individual’s ability to easily do these transformations is usually a matter of experience. Nevertheless, a few examples show the possibilities:</p>&#13;
<pre>ab + ab' + a'b            =  a(b + b') + a'b             By P4<br/>&#13;
                          =  a • 1 + a'b                 By P5<br/>&#13;
                          =  a + a'b                     By Th4<br/>&#13;
                          =  a + b                       By Th11<br/><br/>&#13;
(a'b + a'b' + b')'        =  ( a'(b + b') + b')'         By P4<br/>&#13;
                          =  (a'• 1 + b')'               By P5<br/>&#13;
                          =  (a' + b')                   By Th4<br/>&#13;
                          =  ( (ab)' )'                  By Th8<br/>&#13;
                          =  ab                          By definition of not<br/><br/>&#13;
b(a + c) + ab' + bc' + c  =  ba + bc + ab' + bc' + c     By P4<br/>&#13;
                          =  a(b + b') + b(c + c') + c   By P4<br/>&#13;
                          =  a • 1 + b • 1 + c           By P5<br/>&#13;
                          =  a + b + c                   By Th4</pre>&#13;
<h3 class="h3" id="sec8_5"><strong>8.5 Canonical Forms</strong></h3>&#13;
<p class="noindent">Each Boolean function has an infinite number of equivalent logic expressions. To help eliminate confusion, logic designers generally specify a Boolean function using a <em>canonical</em>, or standardized, form. For each different Boolean function, we can choose a single canonical representation from a defined set.</p>&#13;
<p class="indent">There are several ways to define a set of canonical representations for all the possible Boolean functions of <em>n</em> variables. Within each canonical set, a single expression describes each Boolean function in the system so all of the functions in the set are unique. We’ll discuss two canonical systems in this chapter—the <em>sum of minterms</em> and the <em>product of maxterms</em>—but we’ll employ only the first. Using the duality principle, we can convert between these two systems.</p>&#13;
<p class="indent">As mentioned earlier, a term is either a single literal or a product (logical AND) of several different literals. For example, if you have two variables, <em>A</em> and <em>B</em>, there are eight possible terms: <em>A</em>, <em>B</em>, <em>A'</em>, <em>B'</em>, <em>A'B'</em>, <em>A'B</em>, <em>AB'</em>, and <em>AB</em>. For three variables, we have 26 different terms: <em>A</em>, <em>B</em>, <em>C</em>, <em>A'</em>, <em>B'</em>, <em>C'</em>, <em>A'B'</em>, <em>A'B</em>, <em>AB'</em>, <em>AB</em>, <em>A'C'</em>, <em>A'C</em>, <em>AC'</em>, <em>AC</em>, <em>B'C'</em>, <em>B'C</em>, <em>BC'</em>, <em>BC</em>, <em>A'B'C'</em>, <em>AB'C'</em>, <em>A'BC'</em>, <em>ABC'</em>, <em>A'B'C</em>, <em>AB'C</em>, <em>A'BC</em>, and <em>ABC</em>. As the number of variables increases, the number of terms increases dramatically. A <em>minterm</em> is a product containing <span epub:type="pagebreak" id="page_225"/>exactly <em>n</em> literals, where <em>n</em> is the number of input variables. For example, the minterms for the two variables <em>A</em> and <em>B</em> are <em>A'B'</em>, <em>AB'</em>, <em>A'B</em>, and <em>AB</em>. Likewise, the minterms for three variables <em>A</em>, <em>B</em>, and <em>C</em> are <em>A'B'C'</em>, <em>AB'C'</em>, <em>A'BC'</em>, <em>ABC'</em>, <em>A'B'C</em>, <em>AB'C</em>, <em>A'BC</em>, and <em>ABC</em>. In general, there are 2<sup><em>n</em></sup> minterms for <em>n</em> variables. The set of possible minterms is easy to generate because they correspond to the sequence of binary numbers (see <a href="ch08.xhtml#ch08tab06">Table 8-6</a>).</p>&#13;
<p class="tabcap"><a id="ch08tab06"/><strong>Table 8-6:</strong> Generating Minterms from Binary Numbers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Binary equivalent (</strong><span class="EmpStrong">CBA</span><strong>)</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Minterm</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">000</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A'B'C'</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">001</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><em>AB'C'</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">010</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A'BC'</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">011</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><em>ABC'</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">100</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A'B'C</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">101</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><em>AB'C</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">110</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><em>A'BC</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">111</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><em>ABC</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We can derive the canonical form for <em>any</em> Boolean function using a sum (logical OR) of minterms. Given <em>F</em><sub>248</sub> = <em>AB</em> + <em>C</em>, the equivalent canonical form is <em>ABC</em> + <em>A'BC</em> + <em>AB'C</em> + <em>A'B'C</em> + <em>ABC'</em>. Algebraically, we can show that the canonical form is equivalent to <em>AB</em> + <em>C</em> as follows:</p>&#13;
<pre>ABC + A'BC + AB'C + A'B'C + ABC'  =  BC(A + A') + B'C(A + A') + ABC'   By P4<br/>&#13;
                                  =  BC • 1 + B'C • 1 + ABC'           By Th15<br/>&#13;
                                  =  C(B + B') + ABC'                  By P4<br/>&#13;
                                  =  C + ABC'                          By Th15 &amp; Th4<br/>&#13;
                                  =  C + AB                            By Th11</pre>&#13;
<p class="indent">Obviously, the canonical form is not optimal. However, it’s very easy to generate the truth table for a function from the canonical form. It’s also very easy to generate the sum-of-minterms canonical form equation from the truth table.</p>&#13;
<h4 class="h4" id="sec8_5_1"><strong><em>8.5.1 Sum-of-Minterms Canonical Form and Truth Tables</em></strong></h4>&#13;
<p class="noindent">To build the truth table from the sum-of-minterms canonical form, follow these steps:</p>&#13;
<ol>&#13;
<li class="noindent">Convert minterms to binary equivalents by substituting a 1 for unprimed variables and a 0 for primed variables, like so:&#13;
<pre>F248 = CBA + CBA' + CB'A + CB'A' + C' BA<br/>&#13;
     = 111 + 110  + 101  + 100   + 011</pre></li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_226"/>Place a 1 in the function column for the appropriate minterm entries:&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>C</em></strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>B</em></strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>A</em></strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>F = AB +</em> <em>C</em></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</li>&#13;
<li class="noindent">Finally, place the number 0 in the function column for the remaining entries:&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>C</em></strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>B</em></strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>A</em></strong></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="tab_th"><strong><em>F =</em> <em>AB + C</em></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</li></ol>&#13;
<p class="indent">Going in the other direction, to generate a logic function from a truth table, follow these steps:</p>&#13;
<ol>&#13;
<li class="noindent">Locate all the entries in the truth table with a function result of 1. In this table, these are the last five entries. The number of table entries containing 1s determines the number of minterms in the canonical equation.</li>&#13;
<li class="noindent">Generate the individual minterms by substituting <em>A</em>, <em>B</em>, or <em>C</em> for 1s and <em>A'</em>, <em>B'</em>, or <em>C'</em> for 0s. In this example, the result of <em>F</em><sub>248</sub> is 1 when <em>CBA</em> equals 111, 110, 101, 100, or 011. Therefore, <em>F</em><sub>248</sub> <em>= CBA</em> + <em>CBA'</em> + <em>CB'A</em> + <em>CB'A'</em> + <em>C'AB</em>.</li>&#13;
<li class="noindent">Optionally rearrange the terms within the minterms, and rearrange the minterms within the overall function. This works because the logical OR and logical AND operations are both commutative.</li></ol>&#13;
<p class="indent">This process works equally well for any number of variables, as with the truth table in <a href="ch08.xhtml#ch08tab07">Table 8-7</a> for the function <em>F</em><sub>53,504</sub> = <em>ABCD</em> + <em>A'BCD</em> + <em>A'B'CD</em> + <em>A'B'C'D</em>.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_227"/><a id="ch08tab07"/><strong>Table 8-7:</strong> Truth Table for F<sub>53,504</sub></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>D</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>C</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>B</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>A</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>F = ABCD + A'BCD + A'B'CD + A'B'C'D</em></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Perhaps the easiest way to generate the canonical form of a Boolean function is to first generate the truth table for it and then build the canonical form from the truth table. In fact, we’ll use this technique when converting between the two canonical forms.</p>&#13;
<h4 class="h4" id="sec8_5_2"><strong><em>8.5.2 Algebraically Derived Sum-of-Minterms Canonical Form</em></strong></h4>&#13;
<p class="noindent">To generate the sum-of-minterms canonical form algebraically, we use the distributive law and theorem 15 (<em>A</em> + <em>A'</em> = 1). Consider <em>F</em><sub>248</sub> = <em>AB</em> + <em>C</em>. This function contains two terms, <em>AB</em> and <em>C</em>, but they are not minterms. We can convert the first term to a sum of minterms as follows:</p>&#13;
<pre>AB    =  AB • 1            By Th4<br/>&#13;
      =  AB • (C + C')     By Th15<br/>&#13;
      =  ABC + ABC'        By distributive law<br/>&#13;
      =  CBA + C'BA        By associative law</pre>&#13;
<p class="indent">Similarly, we can convert the second term in <em>F</em><sub>248</sub> to a sum of minterms as follows:</p>&#13;
<pre>C     =  C • 1                              By Th4<br/>&#13;
      =  C • (A + A')                       By Th15<br/>&#13;
      =  CA + CA'                           By distributive law<br/>&#13;
      =  CA • 1 + CA' • 1                   By Th4<br/>&#13;
<span epub:type="pagebreak" id="page_228"/>      =  CA • (B + B') + CA' • (B + B')     By Th15<br/>&#13;
      =  CAB + CAB' + CA'B + CA'B'          By distributive law<br/>&#13;
      =  CBA + CBA' + CB'A + CB'A'          By associative law</pre>&#13;
<p class="indent">The last step (rearranging the terms) in these two conversions is optional. To obtain the final canonical form for <em>F</em><sub>248</sub>, we sum the results from these two conversions:</p>&#13;
<pre>F<sub>248</sub>    =  (CBA + C'BA) + (CBA + CBA' + CB'A + CB'A')<br/>&#13;
       =  CBA + CBA' + CB'A + CB'A' + C'BA</pre>&#13;
<h4 class="h4" id="sec8_5_3"><strong><em>8.5.3 Product-of-Maxterms Canonical Form</em></strong></h4>&#13;
<p class="noindent">Another canonical form is the <em>products of maxterms</em>. A maxterm is the sum (logical OR) of all input variables, primed or unprimed. For example, consider the following logic function, <em>G</em>, of three variables in product-of-maxterms form:</p>&#13;
<pre>G = (A + B + C) • (A' + B + C) • (A + B' + C)</pre>&#13;
<p class="indent">As with the sum-of-minterms form, there’s exactly one product of maxterms for each possible logic function. For every product-of-maxterms form, there’s an equivalent sum-of-minterms form. In fact, the function <em>G</em> in this example is equivalent to the earlier sum-of-minterms form of <em>F</em><sub>248</sub>:</p>&#13;
<pre>F<sub>248</sub> = CBA + CBA' + CB'A + CB'A' + C'BA = AB + C</pre>&#13;
<p class="indent">To generate a truth table from the product of maxterms, you use the duality principle; that is, swap AND for OR and 0s for 1s (and vice versa). Therefore, to build the truth table, you’d first swap primed and nonprimed literals. In <em>G</em>, this would yield:</p>&#13;
<pre>G = (A' + B' + C') • (A + B' + C') • (A' + B + C')</pre>&#13;
<p class="indent">The next step is to swap the logical OR and logical AND operators, which produces the following:</p>&#13;
<pre>G = A'B'C' + AB'C' + A'BC'</pre>&#13;
<p class="indent">Finally, you need to swap all 0s and 1s. This means that for each of the minterms listed previously, you need to store 0s into the function column of the truth table, and then fill in the rest of the truth table’s function column with 1s. This will place a 0 in rows 0, 1, and 2 in the truth table. Filling the remaining entries with 1s produces <em>F</em><sub>248</sub>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_229"/>You can easily convert between these two canonical forms by generating the truth table for one form and working backward to produce the other form. Consider the function of two variables, <em>F</em><sub>7</sub> = <em>A</em> + <em>B</em>. The sum-of-minterms form is <em>F</em><sub>7</sub> = <em>A'B</em> + <em>AB'</em> + <em>AB</em>. The truth table is shown in <a href="ch08.xhtml#ch08tab08">Table 8-8</a>.</p>&#13;
<p class="tabcap"><a id="ch08tab08"/><strong>Table 8-8:</strong> OR Truth Table for Two Variables</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>A</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>B</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>F</em></strong>7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Working backward to get the product of maxterms, we first locate all entries in the truth table that have a 0 result. The entry with <em>A</em> and <em>B</em> both equal to 0 is the only entry with a 0 result. This gives us the first step of <em>G</em> = <em>A' B'</em>. However, we still need to invert all the variables to obtain <em>G</em> = <em>AB</em>. By the duality principle, we also need to swap the logical OR and logical AND operators, obtaining <em>G</em> = <em>A</em> + <em>B</em>. This is the canonical <em>product of maxterms</em> form.</p>&#13;
<h3 class="h3" id="sec8_6"><strong>8.6 Simplification of Boolean Functions</strong></h3>&#13;
<p class="noindent">Because there’s an infinite variety of Boolean functions of <em>n</em> variables, but a finite number of unique ones, you might wonder if there is some method that will simplify a given Boolean function to produce the optimal form—that is, the expression containing the fewest number of operators. An optimal form must exist for all logic functions, but we don’t use it for the canonical form for two reasons. First, although it’s easy to convert between the truth table forms and the canonical form, it’s not as easy to generate the optimal form from a truth table. Second, there may be several optimal forms for a single function.</p>&#13;
<p class="indent">You can attempt to produce the optimal form using algebraic transformations, but there’s no guarantee you’ll arrive at the best result. There are two methods that will <em>always</em> reduce a given Boolean function to its optimal form: the <em>mapping</em> method and the <em>prime implicants</em> method. This book covers the mapping method.</p>&#13;
<p class="indent">Using the mapping method to manually optimize Boolean functions is practical only for functions of two, three, or four variables. It’s doable but cumbersome for functions of five or six variables. For more than six variables, you should write a program.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_230"/>The first step in the mapping method is to build a special two-dimensional truth table for the function (see <a href="ch08.xhtml#ch08fig01">Figure 8-1</a>). <em>Take a careful look at these truth tables</em>. They do not use the same forms shown earlier in this chapter. In particular, the progression of the 2-bit values is 00, 01, 11, 10, not 00, 01, 10, 11. This is very important! If you organize the truth tables in a binary sequence, the mapping optimization method will not work properly. We’ll call this a <em>truth map</em> to distinguish it from the standard truth table.<sup><a href="footnotes.xhtml#fn8_2a" id="fn8_2">2</a></sup></p>&#13;
<div class="image"><img alt="image" src="../images/08fig01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig01"/><em>Figure 8-1: Two-, three-, and four-variable truth maps</em></p>&#13;
<p class="indent">Assuming your Boolean function is already in sum-of-minterms canonical form, insert 1s for each of the truth map cells corresponding to one of the minterms in the function. Place 0s everywhere else. For example, consider the function of three variables <em>F</em> = <em>C'B'A</em> + <em>C'BA'</em> + <em>C'BA</em> + <em>CB'A'</em> + <em>CB'A</em> + <em>CBA'</em> + <em>CBA</em>. <a href="ch08.xhtml#ch08fig02">Figure 8-2</a> shows the truth map for this function.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig02.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_231"/><a id="ch08fig02"/><em>Figure 8-2: A truth map for</em> F = C'B'A + C'BA' + C'BA + CB'A' + CB'A + CBA' + CBA</p>&#13;
<p class="indent">The next step is to draw outlines around rectangular groups of 1s. The rectangles you enclose must have sides whose lengths are powers of 2. For functions with three variables, the rectangles can have sides whose lengths are 1, 2, and 4. The set of rectangles you draw must surround all cells containing 1s in the truth map. The trick is to draw all possible rectangles unless a rectangle would be completely enclosed within another, but also draw the fewest number of rectangles. Note that the rectangles may overlap as long as one rectangle does not completely enclose the other. In the truth map in <a href="ch08.xhtml#ch08fig03">Figure 8-3</a>, there are three such rectangles.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig03.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig03"/><em>Figure 8-3: Surrounding rectangular groups of 1s in a truth map</em></p>&#13;
<p class="indent">Each rectangle represents a term in the simplified Boolean function. Therefore, the simplified Boolean function will contain only three terms. You build each term by eliminating any variables whose primed and unprimed forms both appear within the rectangle (because the positive and negative variants cancel each other out). The long skinny rectangle in <a href="ch08.xhtml#ch08fig03">Figure 8-3</a> is sitting in the row where <em>C</em> = 1 contains both <em>A</em> and <em>B</em> in primed and unprimed forms. Therefore, we can eliminate both <em>A</em> and <em>B</em> from the term. Because the rectangle sits in the <em>C</em> = 1 region, this rectangle represents the single literal <em>C</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_232"/>The light gray square in <a href="ch08.xhtml#ch08fig03">Figure 8-3</a> includes <em>C</em>, <em>C'</em>, <em>B</em>, <em>B'</em>, and <em>A</em>. Therefore, it represents the single term <em>A</em>. Likewise, the dark gray square in <a href="ch08.xhtml#ch08fig03">Figure 8-3</a> contains <em>C</em>, <em>C'</em>, <em>A</em>, <em>A'</em>, and <em>B</em>, so it represents the single term <em>B</em>.</p>&#13;
<p class="indent">The final, optimal, function is the sum (logical OR) of the terms represented by the three squares, or <em>F</em> = <em>A</em> + <em>B</em> + <em>C</em>. You do not have to consider the remaining squares containing 0s.</p>&#13;
<p class="indent">A truth map forms a <em>torus</em> (a doughnut shape). The right edge of the map wraps around to the left edge, and vice versa. Likewise, the top edge wraps around to the bottom edge. This introduces additional possibilities for drawing rectangles around groups of 1s in a map. Consider the Boolean function <em>F</em> = <em>C'B'A'</em> + <em>C'BA'</em> + <em>CB'A'</em> + <em>CBA'</em>. <a href="ch08.xhtml#ch08fig04">Figure 8-4</a> shows the truth map for this function.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig04.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig04"/><em>Figure 8-4: Truth map for F = C'B'A' + C'BA' + CB'A + CBA'</em></p>&#13;
<p class="indent">At first glance, you might think that the minimum number of rectangles is two, as shown in <a href="ch08.xhtml#ch08fig05">Figure 8-5</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig05.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig05"/><em>Figure 8-5: First attempt at surrounding rectangles formed by 1s</em></p>&#13;
<p class="indent">However, because the truth map is a continuous object with the right side and left sides connected, we can actually form a single, square rectangle, as <a href="ch08.xhtml#ch08fig06">Figure 8-6</a> shows.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig06.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_233"/><a id="ch08fig06"/><em>Figure 8-6: Correct rectangle for the function</em></p>&#13;
<p class="indent">Why does it matter if we have one rectangle or two in the truth map? The larger the rectangles are, the more terms they will eliminate. The fewer rectangles that we have, then, the fewer terms will appear in the final Boolean function.</p>&#13;
<p class="indent">The example in <a href="ch08.xhtml#ch08fig05">Figure 8-5</a> with two rectangles generates a function with two terms. The rectangle on the left eliminates the <em>C</em> variable, leaving <em>A'B'</em> as its term. The rectangle on the right also eliminates the <em>C</em> variable, leaving the term <em>BA'</em>. Therefore, this truth map would produce the equation <em>F</em> = <em>A'B'</em> + <em>A'B</em>. We know this is not optimal (see theorem 13).</p>&#13;
<p class="indent">Now consider the truth map in <a href="ch08.xhtml#ch08fig06">Figure 8-6</a>. Here we have a single rectangle, so our Boolean function will have only a single term. Because this rectangle includes both <em>C</em> and <em>C'</em>, and also <em>B</em> and <em>B'</em>, the only term left is <em>A'</em>. This Boolean function, therefore, reduces to <em>F = A'</em>.</p>&#13;
<p class="indent">There are only two types of truth maps that the mapping method cannot handle properly: a truth map that contains all 0s or a truth map that contains all 1s. These two cases correspond to the Boolean functions <em>F</em> = 0 and <em>F</em> = 1 (that is, the function number is 0 or 2<sup><em>n</em></sup> – 1). When you see either of these truth maps, you’ll know how to optimally represent the function.</p>&#13;
<p class="indent">When optimizing Boolean functions using the mapping method, remember that you always want to pick the largest rectangles whose sides’ lengths are powers of 2. You must do this even for overlapping rectangles (unless one rectangle encloses another). Consider the Boolean function <em>F</em> = <em>C'B'A'</em> + <em>C'BA'</em> + <em>CB'A'</em> + <em>C'AB</em> + <em>CBA'</em> + <em>CBA</em>. This produces the truth map in <a href="ch08.xhtml#ch08fig07">Figure 8-7</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig07.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig07"/><em>Figure 8-7: Truth map for F = C'B'A' + C'BA' + CB'A' + C'AB + CBA' + CBA</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_234"/>The initial temptation is to create one of the sets of rectangles found in <a href="ch08.xhtml#ch08fig08">Figure 8-8</a>. However, the correct mapping appears in <a href="ch08.xhtml#ch08fig09">Figure 8-9</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig08.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig08"/><em>Figure 8-8: Obvious choices for rectangles</em></p>&#13;
<div class="image"><img alt="image" src="../images/08fig09.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig09"/><em>Figure 8-9: Correct set of rectangles for F = C'B'A' + C'BA' + CB'A' + C'AB + CBA' + CBA</em></p>&#13;
<p class="indent">All three mappings will produce a Boolean function with two terms. However, the first two will produce the expressions <em>F</em> = <em>B</em> + <em>A'B'</em> and <em>F</em> = <em>AB</em> + <em>A'</em>. The third form produces <em>F</em> = <em>B</em> + <em>A'</em>. This last form is the optimized one (see theorems 11 and 12).</p>&#13;
<p class="indent">Truth maps you create for functions of four variables are even trickier; there are many places rectangles can hide from you along the edges, as you can see in <a href="ch08.xhtml#ch08fig10">Figure 8-10</a>. This list of patterns doesn’t even begin to cover all of them! For example, the diagrams in <a href="ch08.xhtml#ch08fig10">Figure 8-10</a> show none of the 1×2 rectangles.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig10.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_235"/><a id="ch08fig10"/><em>Figure 8-10: Partial pattern list for a 4×4 truth map</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_236"/>This final example demonstrates optimizing a function of four variables. The function is <em>F</em> = <em>D'C'B'A'</em> + <em>D'C'B'A</em> + <em>D'C'BA</em> + <em>D'C'BA'</em> + <em>D'CB'A</em> + <em>D'CBA</em> + <em>DCB'A</em> + <em>DCBA</em> + <em>DC'B'A'</em> + <em>DC'BA'</em>, and its truth map appears in <a href="ch08.xhtml#ch08fig11">Figure 8-11</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig11.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig11"/><em>Figure 8-11: Truth map for F = D'C'B'A' + D'C'B'A + D'C'BA + D'C'BA' + D'CB'A + D'CBA + DCB'A + DCBA + DC'B'A' + DC'BA'</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08fig12">Figure 8-12</a> shows the two possible sets of maximal rectangles for this function, each producing three terms.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig12.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig12"/><em>Figure 8-12: Two combinations yielding three terms</em></p>&#13;
<p class="indent">The rectangle formed by the four corners, common to both maps in <a href="ch08.xhtml#ch08fig12">Figure 8-12</a>, contains <em>B</em>, <em>B'</em>, <em>D</em>, and <em>D'</em>, so we can eliminate those terms. The remaining terms contained within the rectangle are <em>C'</em> and <em>A'</em>, so this rectangle represents the term <em>C'A'</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_237"/>The rectangle formed by the middle four squares, also in both combinations, includes the terms <em>A</em>, <em>B</em>, <em>B'</em>, <em>C</em>, <em>D</em>, and <em>D'</em>. Eliminating <em>B</em>, <em>B'</em>, <em>D</em>, and <em>D'</em>, we obtain <em>CA</em>.</p>&#13;
<p class="indent">Combination 1 has a third term represented by the top row. This term includes the variables <em>A</em>, <em>A'</em>, <em>B</em>, <em>B'</em>, <em>C',</em> and <em>D'</em>. We can eliminate <em>A</em>, <em>A'</em>, <em>B</em>, and <em>B'</em>. This leaves the term <em>C'D'</em>. Therefore, the function represented by the upper truth map is <em>F</em> = <em>C'A'</em> + <em>CA</em> + <em>C'D'</em>.</p>&#13;
<p class="indent">Combination 2 has a third term represented by the top/middle four squares. This rectangle subsumes the variables <em>A</em>, <em>B</em>, <em>B'</em>, <em>C</em>, <em>C'</em>, and <em>D'</em>. We can eliminate <em>B</em>, <em>B'</em>, <em>C</em>, and <em>C'</em>, leaving the term <em>AD</em>. Therefore, the function represented by the lower truth map is <em>F</em> = <em>C'A'</em> + <em>CA</em> + <em>AD'</em>.</p>&#13;
<p class="indent">Both functions are equivalent; both are optimal (remember, there’s no guarantee of a unique optimal solution). Either will suffice for our purposes: implementing Boolean functions using the fewest circuit components.</p>&#13;
<h3 class="h3" id="sec8_7"><strong>8.7 What Does This Have to Do with Computers, Anyway?</strong></h3>&#13;
<p class="noindent">Any program you can write, you can also specify as a sequence of Boolean equations. This means that any algorithm you can implement in software, you can also implement directly in hardware—there is a one-to-one relationship between the set of all Boolean functions and the set of all electronic circuits. Electrical engineers, who design CPUs and other computer-related circuits, have to be intimately familiar with this material.</p>&#13;
<p class="indent">Because it’s easier to specify a solution to a programming problem using languages like Pascal, C, or even assembly language than it is to specify the solution using Boolean equations, it’s unlikely that you would ever implement an entire program using a set of state machines and other logic circuitry. However, a hardware solution can be orders of magnitude faster than an equivalent software solution, and some time-critical operations require a hardware solution.</p>&#13;
<p class="indent">It is also possible to implement all hardware functions in software. This is important, because many operations you’d normally implement in hardware are much cheaper to implement using software on a microprocessor. Indeed, one of the primary uses of assembly language on modern systems is to inexpensively replace a complex electronic circuit. Often, you can replace many tens or hundreds of dollars of electronic components with a single $2 microcomputer chip programmed to perform the equivalent function.</p>&#13;
<p class="indent">The whole field of <em>embedded systems</em> (computer systems embedded in other products) deals with this problem. For example, most microwave ovens, TV sets, video games, CD players, and other consumer devices contain one or more complete computer systems whose sole purpose is to replace a complex hardware design. Engineers use computers for this purpose because they are less expensive and easier to design with than traditional electronic circuitry.</p>&#13;
<p class="indent">To write software that reads switches (input variables) and turns on motors, LEDs, or lights, or that locks or unlocks a door, you need to understand Boolean functions and how to implement them in software.</p>&#13;
<h4 class="h4" id="sec8_7_1"><span epub:type="pagebreak" id="page_238"/><strong><em>8.7.1 Correspondence Between Electronic Circuits and Boolean Functions</em></strong></h4>&#13;
<p class="noindent">For any Boolean function, you can design an equivalent electronic circuit and vice versa. We can construct any electronic circuit using the AND, OR, and NOT Boolean operators, which correspond to the AND, OR, and inverter (NOT) circuits (see <a href="ch08.xhtml#ch08fig13">Figure 8-13</a>). These symbols are standard electronic symbols appearing in <em>schematic diagrams</em>. (To learn more about electronic schematic diagrams, check out any book on electronic design.)</p>&#13;
<div class="image"><img alt="image" src="../images/08fig13.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig13"/><em>Figure 8-13: AND, OR, and inverter (NOT) gates</em></p>&#13;
<p class="indent">The lines to the left of each gate, with the <em>A</em> and <em>B</em> labels, correspond to a logic function input; the line to the right of each diagram corresponds to the function’s output.</p>&#13;
<p class="indent">An <em>electronic circuit</em> is a combination of gates that implement some set of Boolean functions. Consider the Boolean function <em>F</em> = <em>AB</em> + <em>B</em>. You can implement this function using an AND gate and an OR gate. Simply connect the two input variables (<em>A</em> and <em>B</em>) to the inputs of the AND gate, connect the output of the AND gate to one of the inputs of the OR gate, and connect the <em>B</em> input variable to the other OR input. Now you have an electronic (hardware) circuit that implements this function.</p>&#13;
<p class="indent">However, you actually need only a single gate type—the NAND (NOT AND) gate—to implement <em>any</em> electronic circuit (see <a href="ch08.xhtml#ch08fig14">Figure 8-14</a>). The NAND gate tests its two inputs (<em>A</em> and <em>B</em>) and outputs <code>false</code> if both inputs are <code>true</code>; it outputs <code>true</code> if both inputs are <code>false</code>. You could construct the NAND circuit from an AND gate and an inverter. However, from a transistor/hardware perspective, the NAND gate is actually simpler to construct than an AND gate; therefore, NAND gates (such as the 7400 IC) are very common.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig14.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig14"/><em>Figure 8-14: The NAND gate</em></p>&#13;
<p class="indent">We can construct any Boolean function using only NAND gates because we can build an inverter (NOT), an AND gate, and an OR gate from NAND gates.<sup><a href="footnotes.xhtml#fn8_3a" id="fn8_3">3</a></sup> Building an inverter is easy; just connect the two inputs together (see <a href="ch08.xhtml#ch08fig15">Figure 8-15</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/08fig15.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_239"/><a id="ch08fig15"/><em>Figure 8-15: Inverter built from a NAND gate</em></p>&#13;
<p class="indent">After building an inverter, we can build an AND gate by inverting the output of a NAND gate, because NOT (NOT (<em>A</em> AND <em>B</em>)) is equivalent to <em>A</em> AND <em>B</em> (see <a href="ch08.xhtml#ch08fig16">Figure 8-16</a>). It takes two NAND gates to construct a single AND gate (no one said that circuits constructed only with NAND gates are optimal, only that they’re possible).</p>&#13;
<div class="image"><img alt="image" src="../images/08fig16.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig16"/><em>Figure 8-16: Constructing an AND gate from two NAND gates</em></p>&#13;
<p class="indent">The remaining gate is the logical-OR gate. We can construct an OR gate from NAND gates by applying DeMorgan’s Theorems.</p>&#13;
<pre>(A or B)'    =    A' and B'            DeMorgan's Theorem.<br/>&#13;
A or B       =    (A' and B')'         Invert both sides of the equation.<br/>&#13;
A or B       =    A' nand B'           Definition of NAND operation.</pre>&#13;
<p class="indent">Applying these transformations produces the circuit shown in <a href="ch08.xhtml#ch08fig17">Figure 8-17</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig17.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig17"/><em>Figure 8-17: Constructing an OR gate from NAND gates</em></p>&#13;
<p class="indent">NAND gates are generally less expensive to build than other gates, and it’s much easier to build up complex circuits from the same basic building blocks than it is to construct an integrated circuit using different basic gates.</p>&#13;
<h4 class="h4" id="sec8_7_2"><strong><em>8.7.2 Combinatorial Circuits</em></strong></h4>&#13;
<p class="noindent">A computer’s CPU is built from <em>combinatorial circuits</em>, which are systems containing basic Boolean operations (AND, OR, NOT), some inputs, and a set of outputs. A combinatorial circuit often implements several different Boolean functions, with each output corresponding to an individual logic function.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It is very important that you remember that</em> each output represents a different Boolean function.</p>&#13;
</div>&#13;
<h5 class="h5" id="sec8_7_2_1"><span epub:type="pagebreak" id="page_240"/><strong>8.7.2.1 Combining Addition Circuits</strong></h5>&#13;
<p class="noindent">You can implement addition using Boolean functions. Suppose you have two 1-bit numbers, <em>A</em> and <em>B</em>. You can produce the 1-bit sum and the 1-bit carry of this addition using these two Boolean functions:</p>&#13;
<pre>S  =  AB' + A'B        Sum of A and B.<br/>&#13;
C  =  AB               Carry from addition of A and B.</pre>&#13;
<p class="indent">These two Boolean functions implement a <em>half adder</em>, so called because it adds 2 bits together but cannot add in a carry from a previous operation. Note that <em>S</em> = 1 if <em>A</em> or <em>B</em> is 1, <em>S</em> = 0 if <em>A</em> and <em>B</em> are both 0 or 1 (both 1 produces a carry, which is what the <em>C</em> = <em>AB</em> expression produces).</p>&#13;
<p class="indent">A <em>full adder</em> adds three 1-bit inputs (2 bits plus a carry from a previous addition) and produces two outputs: the sum and the carry. These are the two logic equations for a full adder:</p>&#13;
<pre>S     =  A'B'C<sub>in</sub> + A'BC<sub>in</sub>' + AB'C<sub>in</sub>' + ABC<sub>in</sub><br/>&#13;
C<sub>out</sub>  =  AB + AC<sub>in</sub> + BC<sub>in</sub></pre>&#13;
<p class="indent">Although these equations produce only a single-bit result (plus a carry), it’s easy to construct an <em>n</em>-bit sum by combining adder circuits (see <a href="ch08.xhtml#ch08fig18">Figure 8-18</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/08fig18.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig18"/><em>Figure 8-18: Building an n-bit adder using half and full adders</em></p>&#13;
<p class="indent">The two <em>n</em>-bit inputs, <em>A</em> and <em>B</em>, are passed into the adder bit-by-bit, with the LO bits input as <em>A</em><sub>0</sub> and <em>B</em><sub>0</sub>, and so on up to HO bits <em>A</em><sub><em>n</em></sub><sub>–1</sub> and <em>B</em><sub><em>n</em></sub><sub>–1</sub>. <em>S</em><sub>0</sub> is the LO bit of the sum, up to <em>S</em><sub><em>n</em></sub><sub>–1</sub>, and the final carry indicates whether the addition overflowed <em>n</em> bits.</p>&#13;
<h5 class="h5" id="sec8_7_2_2"><span epub:type="pagebreak" id="page_241"/><strong>8.7.2.2 Using Seven-Segment LED Decoders</strong></h5>&#13;
<p class="noindent">Another common combinatorial circuit is the <em>seven-segment decoder</em>. Among the more important circuits in computer system design, decoder circuits enable the computer to recognize (or <em>decode</em>) a string of bits.</p>&#13;
<p class="indent">The seven-segment decoder circuit accepts an input of 4 bits and determines which segments to illuminate on a seven-segment LED display. Because a seven-segment display contains seven output values (one for each segment), there are seven logic functions associated with it (segments 0 through 6). See <a href="ch08.xhtml#ch08fig19">Figure 8-19</a> for the segment assignments. <a href="ch08.xhtml#ch08fig20">Figure 8-20</a> shows the active segments for each of the 10 decimal values.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig19.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig19"/><em>Figure 8-19: Seven-segment display</em></p>&#13;
<div class="image"><img alt="image" src="../images/08fig20.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig20"/><em>Figure 8-20: Seven-segment values for 0 through 9</em></p>&#13;
<p class="indent">The four inputs to each of these seven Boolean functions are the 4 bits from a binary number in the range 0 through 9. Let <em>D</em> be the HO bit of this number and <em>A</em> be the LO bit. Each segment’s logic function should produce a <code>1</code> (segment on) for all binary number inputs that have that segment illuminated in <a href="ch08.xhtml#ch08fig20">Figure 8-20</a>. For example, <em>S</em><sub>4</sub> (segment 4) should be illuminated for numbers 0, 2, 6, and 8, which correspond to the binary values 0000, 0010, 0110, and 1000. For each of the binary values that illuminates a segment, you will have one minterm in the logic equation:</p>&#13;
<pre>S<sub>4</sub> = D'C'B'A' + D'C'BA' + D'CBA' + DC'B'A'</pre>&#13;
<p class="indent"><em>S</em><sub>0</sub> (segment 0), as a second example, is on for the numbers 0, 2, 3, 5, 6, 7, 8, and 9, which correspond to the binary values 0000, 0010, 0011, 0101, 0110, 0111, 1000, and 1001. Therefore, the logic function for <em>S</em><sub>0</sub> is as follows:</p>&#13;
<pre>S<sub>0</sub> = D'C'B'A' + D'C'BA' + D'C'BA + D'CB'A + D'CBA' + D'CBA + DC'B'A' + DC'B'A</pre>&#13;
<h5 class="h5" id="sec8_7_2_3"><span epub:type="pagebreak" id="page_242"/><strong>8.7.2.3 Decoding Memory Addresses</strong></h5>&#13;
<p class="noindent">A decoder is also commonly used in memory expansion. For example, suppose a system designer wishes to install four (identical) 256MB memory modules in a system to bring the total to 1GB of RAM. Each of these 256MB memory modules has 28 address lines (<em>A</em><sub>0</sub>..<em>A</em><sub>27</sub>), assuming each memory module is 8 bits wide (2<sup>28</sup> × 8 bits is 256MB).<sup><a href="footnotes.xhtml#fn8_4a" id="fn8_4">4</a></sup></p>&#13;
<p class="indent">Unfortunately, if the system designer hooked up those four memory modules to the CPU’s address bus, each module would respond to the same addresses on the bus. Pandemonium would result. To correct this problem, each memory module needs to respond to a different set of addresses appearing on the full address bus (with a module address appearing on the LO 28 bits of the address bus). By adding a chip-select line to each of the memory modules, and using a two-input, four-output decoder circuit, we can use the chip select lines <em>A</em><sub>28</sub> and <em>A</em><sub>29</sub> to specify the HO 2 bits of the (now effectively 30-bit) memory address. See <a href="ch08.xhtml#ch08fig21">Figure 8-21</a> for the details.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig21.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig21"/><em>Figure 8-21: Adding four 256MB memory modules to a system</em></p>&#13;
<p class="indent">The two- to four-line decoder circuit in <a href="ch08.xhtml#ch08fig21">Figure 8-21</a> incorporates four different logic functions: one function for each of the outputs. Each combination of the input bits will activate a single chip-select line, and deactivate the other three. Assuming the inputs are <em>A</em> and <em>B</em> (<em>A</em> = <em>A</em><sub>28</sub> and <em>B</em> = <em>A</em><sub>29</sub>), the four output functions are as follows:</p>&#13;
<pre>Q<sub>0</sub> = A'B'<br/>&#13;
Q<sub>1</sub> = AB'<br/>&#13;
Q<sub>2</sub> = A'B<br/>&#13;
Q<sub>3</sub> = AB</pre>&#13;
<p class="indent">Following standard electronic circuit notation, these equations use <em>Q</em> to denote an output.</p>&#13;
<p class="indent">Note that most circuit designers use <em>active low logic</em> for decoders and chip enables. This means that they enable a circuit when a low-input <span epub:type="pagebreak" id="page_243"/>value (<code>0</code>) is supplied and disable the circuit when a high-input value (<code>1</code>) is supplied. Real-world decoding circuits would likely use the following sums of maxterms functions:</p>&#13;
<pre>Q<sub>0</sub> = A + B<br/>&#13;
Q<sub>1</sub> = A' + B<br/>&#13;
Q<sub>2</sub> = A + B'<br/>&#13;
Q<sub>3</sub> = A' + B'</pre>&#13;
<h5 class="h5" id="sec8_7_2_4"><strong>8.7.2.4 Decoding Machine Instructions</strong></h5>&#13;
<p class="noindent">Decoding circuits are also used to decode machine instructions. We’ll cover this subject in much greater depth in <a href="ch09.xhtml#ch09">Chapters 9</a> and <a href="ch10.xhtml#ch10">10</a>, but a simple example is in order here.</p>&#13;
<p class="indent">Most modern computer systems represent machine instructions using binary values in memory. To execute an instruction, the CPU fetches the instruction’s binary value from memory, decodes it using decoder circuitry, and then does the appropriate work. To see how this is done, let’s create a fictional CPU with a very simple instruction set. <a href="ch08.xhtml#ch08fig22">Figure 8-22</a> provides the instruction format (all the numeric codes that correspond to the various instructions) for our CPU. Within the 1-byte operation code (opcode), 3 bits (<code>iii</code>) represent the instruction, 2 bits (<code>ss</code>) the source operand, and 2 bits the destination operand (<code>dd</code>).</p>&#13;
<div class="image"><img alt="image" src="../images/08fig22.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig22"/><em>Figure 8-22: Instruction (opcode) format for a very simple CPU</em></p>&#13;
<p class="indent">To determine the 8-bit opcode for a given instruction, look up each component of the instruction in the tables in <a href="ch08.xhtml#ch08fig22">Figure 8-22</a> and substitute the corresponding bit values.</p>&#13;
<p class="indent">Let’s pick <code>mov(eax, ebx);</code> as our simple example. To convert this instruction to its numeric equivalent, <code>mov</code> is encoded as <code>000</code>, <code>eax</code> is encoded as <code>00</code>, and <code>ebx</code> is encoded as <code>01</code>. Assemble these three fields into the opcode byte (a packed data type), to obtain the bit value: <code>%00000001</code>. Therefore, the numeric value <code>$1</code> is the value for the <code>mov(eax, ebx);</code> instruction (see <a href="ch08.xhtml#ch08fig23">Figure 8-23</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/08fig23.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_244"/><a id="ch08fig23"/><em>Figure 8-23: Encoding the <code>mov(eax, ebx);</code> instruction</em></p>&#13;
<p class="indent">A typical decoder circuit for this example appears in <a href="ch08.xhtml#ch08fig24">Figure 8-24</a>. The circuit uses three separate decoders to decode the individual fields of the opcode. This is much less complex than creating a single 7- to 128-line decoder to decode the entire opcode.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig24.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig24"/><em>Figure 8-24: Decoding simple machine instructions</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_245"/>The circuit in <a href="ch08.xhtml#ch08fig24">Figure 8-24</a> tells you which instruction and what operands a given opcode specifies. To actually execute this instruction, you must supply additional circuitry to select the source and destination operands from an array of registers and act accordingly upon those operands. Such circuitry is beyond the scope of this chapter, so we’ll save the juicy details for later.</p>&#13;
<h4 class="h4" id="sec8_7_3"><strong><em>8.7.3 Sequential and Clocked Logic</em></strong></h4>&#13;
<p class="noindent">One major problem with combinatorial logic is that it is <em>memoryless</em>. In theory, all logic function outputs depend only on the current inputs. Any change in the input values immediately appears on the outputs.<sup><a href="footnotes.xhtml#fn8_5a" id="fn8_5">5</a></sup> Unfortunately, computers need the ability to <em>remember</em> the results of past computations. This is the domain of sequential, or clocked, logic.</p>&#13;
<h5 class="h5" id="sec8_7_3_1"><strong>8.7.3.1 The Set/Reset Flip-Flop</strong></h5>&#13;
<p class="noindent">A <em>memory cell</em> is an electronic circuit that remembers an input value after the removal of that input value. The most basic memory unit is the <em>set/reset (S/R) flip-flop</em>. You can construct an S/R flip-flop memory cell using two NAND gates, as shown in <a href="ch08.xhtml#ch08fig25">Figure 8-25</a>. In this diagram, the outputs of the two NAND gates are recirculated to one of the inputs of the other NAND gate.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig25.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig25"/><em>Figure 8-25: Set/reset flip-flop constructed from NAND gates</em></p>&#13;
<p class="indent">The <em>S</em> and <em>R</em> inputs are normally high, or <code>1</code>. If you toggle the <em>S</em> input by <em>temporarily</em> setting its value to <code>0</code> and then bringing it back to <code>1</code>, the <em>Q</em> output is set to <code>1</code>. Likewise, if you toggle the <em>R</em> input from <code>1</code> to <code>0</code> and back to <code>1</code>, this resets the <em>Q</em> output to <code>0</code>. <em>Q'</em> outputs the opposite of <em>Q</em>.</p>&#13;
<p class="indent">If both <em>S</em> and <em>R</em> are <code>1</code>, then the <em>Q</em> output depends upon the original value of <em>Q</em> itself. That is, whatever <em>Q</em> happens to be, the top NAND gate continues to output that same value. If <em>Q</em> was originally <code>1</code>, then the bottom NAND gate receives two inputs of <code>1</code> (both <em>Q</em> and <em>R</em>), and the bottom NAND gate produces an output of <code>0</code> (<em>Q'</em>). As a result, the two inputs to the top NAND gate are <code>0</code> and <code>1</code>, and the top NAND gate produces an output of <code>1</code>, matching the original value for <em>Q</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>On the other hand, if the original value of <em>Q</em> was <code>0</code>, then the inputs to the bottom NAND gate are <em>Q</em> = <code>0</code> and <em>R</em> = <code>1</code>, and the output of this bottom NAND gate is <code>1</code>. As a result, the inputs to the top NAND gate are <em>S =</em> <code>1</code> and <em>Q' =</em> <code>1</code>. This produces a <code>0</code> output, the original value of <em>Q</em>.</p>&#13;
<p class="indent">Now suppose <em>Q</em> is <code>0</code>, <em>S</em> is <code>0</code>, and <em>R</em> is <code>1</code>. This sets the two inputs to the top NAND gate to <code>1</code> and <code>0</code>, forcing the output (<em>Q</em>) to <code>1</code>. Returning <em>S</em> to the high state does not change the output at all, because the value of <em>Q'</em> is <code>1</code>. You will obtain this same result if <em>Q</em> is <code>1</code>, <em>S</em> is <code>0</code>, and <em>R</em> is <code>1</code>. Again, this produces a <em>Q</em> output value of <code>1</code>, and again this value remains <code>1</code> even when <em>S</em> switches from <code>0</code> to <code>1</code>. To overcome this and produce a <em>Q</em> output of <code>1</code>, you must toggle the <em>S</em> input. The same idea applies to the <em>R</em> input, except that toggling it forces the <em>Q</em> output to <code>0</code> rather than to <code>1</code>.</p>&#13;
<p class="indent">There is one catch to this circuit. It does not operate properly if you set both the <em>S</em> and <em>R</em> inputs to <code>0</code> simultaneously. This forces both the <em>Q</em> and <em>Q'</em> outputs to <code>1</code> (which is logically inconsistent). Whichever input remains <code>0</code> the longest determines the final state of the flip-flop. A flip-flop operating in this mode is said to be <em>unstable</em>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08tab09">Table 8-9</a> lists all the output configurations for an S/R flip-flop based on the current inputs and the previous output values.</p>&#13;
<p class="tabcap"><a id="ch08tab09"/><strong>Table 8-9:</strong> S/R Flip-Flop Output States Based on Current Inputs and Previous Outputs</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Previous Q</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Previous Q’</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>S input</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>R input</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Q output</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Q’ output</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">x<sup><a href="footnotes.xhtml#fn8_6a" id="fn8_6">6</a></sup></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">x</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code> (<code>1</code> &gt; <code>0</code> &gt; <code>1</code>)</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">x</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">x</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>0</code> (<code>1</code> &gt; <code>0</code> &gt; <code>1</code>)</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">x</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">x</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code><sup><a href="footnotes.xhtml#fn8_7a" id="fn8_7">7</a></sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="sec8_7_3_2"><strong>8.7.3.2 The D Flip-Flop</strong></h5>&#13;
<p class="noindent">The only problem with the S/R flip-flop is that to be able to remember either a <code>0</code> or a <code>1</code> value, you must have two different inputs. A memory cell would be more valuable to us if we could specify the data value to remember with one input value and supply a second <em>clock input</em> value to <em>latch</em> the data input value.<sup><a href="footnotes.xhtml#fn8_8a" id="fn8_8">8</a></sup> This type of flip-flop, the D flip-flop (<em>D</em> stands for <em>data</em>), uses the circuit in <a href="ch08.xhtml#ch08fig26">Figure 8-26</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig26.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_247"/><a id="ch08fig26"/><em>Figure 8-26: Implementing a D flip-flop with NAND gates</em></p>&#13;
<p class="indent">Assuming you fix the <em>Q</em> and <em>Q'</em> outputs to either <code>0</code>/<code>1</code> or <code>1</code>/<code>0</code>, sending a <em>clock pulse</em> that goes from <code>0</code> to <code>1</code> and back to <code>0</code> will copy the <em>D</em> input to the <em>Q</em> output (and set <em>Q'</em> to the inverse of <em>Q</em>). To see how this works, note that the right half of the circuit diagram in <a href="ch08.xhtml#ch08fig26">Figure 8-26</a> is an S/R flip-flop. If the data input is <code>1</code> while the clock line is high, this places a <code>0</code> on the <em>S</em> input of the S/R flip-flop (and a <code>1</code> on the <em>R</em> input). Conversely, if the data input is <code>0</code> while the clock line is high, this places a <code>0</code> on the <em>R</em> input (and a <code>1</code> on the <em>S</em> input) of the S/R flip-flop, thus clearing the S/R flip-flop’s output. Whenever the clock input is low, both the <em>S</em> and <em>R</em> input are high, and the outputs of the S/R flip-flop do not change.</p>&#13;
<p class="indent">Although remembering a single bit is often important, in most computer systems you want to remember a <em>group</em> of bits. You can do this by combining several D flip-flops in parallel. Concatenating flip-flops to store an <em>n</em>-bit value forms a <em>register.</em> The electronic schematic in <a href="ch08.xhtml#ch08fig27">Figure 8-27</a> shows how to build an 8-bit register from a set of D flip-flops.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig27.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig27"/><em>Figure 8-27: An 8-bit register implemented with eight D flip-flops</em></p>&#13;
<p class="indent">Note that the eight D flip-flops in <a href="ch08.xhtml#ch08fig27">Figure 8-27</a> use a common clock line. This diagram does not show the <em>Q'</em> outputs on the flip-flops because they are rarely required in a register.</p>&#13;
<p class="indent">D flip-flops are useful for building many sequential circuits beyond simple registers. For example, you can build a <em>shift register</em> that shifts the bits one position to the left on each clock pulse. A 4-bit shift register appears in <a href="ch08.xhtml#ch08fig28">Figure 8-28</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig28.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_248"/><a id="ch08fig28"/><em>Figure 8-28: A 4-bit shift register built from D flip-flops</em></p>&#13;
<p class="indent">You can even build a <em>counter</em> that counts the number of times the clock toggles from <code>1</code> to <code>0</code> and back to <code>1</code> using flip-flops. The circuit in <a href="ch08.xhtml#ch08fig29">Figure 8-29</a> implements a 4-bit counter using D flip-flops.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig29.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig29"/><em>Figure 8-29: A 4-bit counter built from D flip-flops</em></p>&#13;
<p class="indent">Surprisingly, you can build an entire CPU with combinatorial circuits and only a few additional sequential circuits. For example, you can build a simple state machine known as a <em>sequencer</em> by combining a counter and a decoder, as shown in <a href="ch08.xhtml#ch08fig30">Figure 8-30</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/08fig30.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig30"/><em>Figure 8-30: A simple 16-state sequencer</em></p>&#13;
<p class="indent">For each cycle of the clock in <a href="ch08.xhtml#ch08fig30">Figure 8-30</a>, this sequencer activates one of its output lines. Those lines, in turn, may control other circuits. By “firing” those other circuits on each of the 16 output lines of the decoder, we can control the order in which the circuits accomplish their tasks. This is essential in a CPU, as we often need to control the sequence of various <span epub:type="pagebreak" id="page_249"/>operations. For example, it wouldn’t be a good thing if the <code>add(eax, ebx);</code> instruction stored the result into EBX before fetching the source operand from EAX (or EBX). A simple sequencer can tell the CPU when to fetch the first operand, when to fetch the second operand, when to add them together, and when to store the result. However, we’re getting a little ahead of ourselves—we’ll discuss this in detail in the next two chapters.</p>&#13;
<h3 class="h3" id="sec8_8"><strong>8.8 For More Information</strong></h3>&#13;
<p class="ref">Horowitz, Paul, and Winfield Hill. <em>The Art of Electronics</em>. 3rd ed. Cambridge, UK: Cambridge University Press, 2015.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This chapter is not, by any means, a complete treatment of Boolean algebra and digital design. If you’re interested in learning more, consult one of the dozens of books on this subject.</em><span epub:type="pagebreak" id="page_250"/></p>&#13;
</div>&#13;
</body></html>