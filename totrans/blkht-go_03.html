<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch3"><span epub:type="pagebreak" id="page_45"/><span class="big">3</span><br/>HTTP CLIENTS AND REMOTE INTERACTION WITH TOOLS</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned how to harness the power of TCP with various techniques for creating usable clients and servers. This is the first in a series of chapters that explores a variety of protocols on higher layers of the OSI model. Because of its prevalence on networks, its affiliation with relaxed egress controls, and its general flexibility, let’s begin with HTTP.</p>&#13;
<p class="indent">This chapter focuses on the client side. It will first introduce you to the basics of building and customizing HTTP requests and receiving their responses. Then you’ll learn how to parse structured response data so the client can interrogate the information to determine actionable or relevant data. Finally, you’ll learn how to apply these fundamentals by building HTTP clients that interact with a variety of security tools and resources. The clients you develop will query and consume the APIs of Shodan, Bing, and Metasploit and will search and parse document metadata in a manner similar to the metadata search tool FOCA.</p>&#13;
<h3 class="h3" id="ch3lev1sec1"><span epub:type="pagebreak" id="page_46"/>HTTP Fundamentals with Go</h3>&#13;
<p class="noindent">Although you don’t need a comprehensive understanding of HTTP, you should know some fundamentals before you get started.</p>&#13;
<p class="indent">First, HTTP is a <em>stateless protocol</em>: the server doesn’t inherently maintain state and status for each request. Instead, state is tracked through a variety of means, which may include session identifiers, cookies, HTTP headers, and more. The client and servers have a responsibility to properly negotiate and validate this state.</p>&#13;
<p class="indent">Second, communications between clients and servers can occur either synchronously or asynchronously, but they operate on a request/response cycle. You can include several options and headers in the request in order to influence the behavior of the server and to create usable web applications. Most commonly, servers host files that a web browser renders to produce a graphical, organized, and stylish representation of the data. But the endpoint can serve arbitrary data types. APIs commonly communicate via more structured data encoding, such as XML, JSON, or MSGRPC. In some cases, the data retrieved may be in binary format, representing an arbitrary file type for download.</p>&#13;
<p class="indent">Finally, Go contains convenience functions so you can quickly and easily build and send HTTP requests to a server and subsequently retrieve and process the response. Through some of the mechanisms you’ve learned in previous chapters, you’ll find that the conventions for handling structured data prove extremely convenient when interacting with HTTP APIs.</p>&#13;
<h4 class="h4" id="ch3lev2sec1">Calling HTTP APIs</h4>&#13;
<p class="noindent">Let’s begin the HTTP discussion by examining basic requests. Go’s <code>net/http</code> standard package contains several convenience functions to quickly and easily send POST, GET, and HEAD requests, which are arguably the most common HTTP verbs you’ll use. These functions take the following forms:</p>&#13;
<pre>Get(<span class="codeitalic1">url string</span>) (resp *Response, err error)&#13;
Head(<span class="codeitalic1">url string</span>) (resp *Response, err error)&#13;
Post(<span class="codeitalic1">url string</span>, <span class="codeitalic1">bodyType string</span>, <span class="codeitalic1">body io.Reader</span>) (resp *Response, err error)</pre>&#13;
<p class="indent">Each function takes—as a parameter—the URL as a string value and uses it for the request’s destination. The <code>Post()</code> function is slightly more complex than the <code>Get()</code> and <code>Head()</code> functions. <code>Post()</code> takes two additional parameters: <code>bodyType</code>, which is a string value that you use for the Content-Type HTTP header (commonly <code>application/x-www-form-urlencoded</code>) of the request body, and an <code>io.Reader</code>, which you learned about in <a href="ch02.xhtml#ch2">Chapter 2</a>.</p>&#13;
<p class="indent">You can see a sample implementation of each of these functions in <a href="ch03.xhtml#ch3list1">Listing 3-1</a>. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.) Note that the POST request creates the request body from form values and sets the <span epub:type="pagebreak" id="page_47"/>Content-Type header. In each case, you must close the response body after you’re done reading data from it.</p>&#13;
<pre>r1, err := http.Get("http://www.google.com/robots.txt")&#13;
// Read response body. Not shown.&#13;
defer r1.Body.Close()&#13;
r2, err := http.Head("http://www.google.com/robots.txt")&#13;
// Read response body. Not shown.&#13;
defer r2.Body.Close()&#13;
form := url.Values{}&#13;
form.Add("foo", "bar")&#13;
r3, err = http.Post<span class="ent">❶</span>(&#13;
    "https://www.google.com/robots.txt",&#13;
 <span class="ent">❷</span> "application/x-www-form-urlencoded",&#13;
    strings.NewReader(form.Encode()<span class="ent">❸</span>),&#13;
)&#13;
// Read response body. Not shown.&#13;
defer r3.Body.Close()</pre>&#13;
<p class="caption" id="ch3list1"><em>Listing 3-1: Sample implementations of the <code>Get()</code>, <code>Head()</code>, and <code>Post()</code> functions (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go">/ch-3/basic/main.go</a><em>)</em></p>&#13;
<p class="indent">The POST function call <span class="ent">❶</span> follows the fairly common pattern of setting the Content-Type to <code>application/x-www-form-urlencoded</code> <span class="ent">❷</span>, while URL-encoding form data <span class="ent">❸</span>.</p>&#13;
<p class="indent">Go has an additional POST request convenience function, called <code>PostForm()</code>, which removes the tediousness of setting those values and manually encoding every request; you can see its syntax here:</p>&#13;
<pre>func PostForm(<span class="codeitalic1">url string</span>, <span class="codeitalic1">data url.Values</span>) (resp *Response, err error)</pre>&#13;
<p class="indent">If you want to substitute the <code>PostForm()</code> function for the <code>Post()</code> implementation in <a href="ch03.xhtml#ch3list1">Listing 3-1</a>, you use something like the bold code in <a href="ch03.xhtml#ch3list2">Listing 3-2</a>.</p>&#13;
<pre>form := url.Values{}&#13;
form.Add("foo", "bar")&#13;
r3, err := <span class="codestrong1">http.PostForm("https://www.google.com/robots.txt", form)</span>&#13;
// Read response body and close.</pre>&#13;
<p class="caption" id="ch3list2"><em>Listing 3-2: Using the <code>PostForm()</code> function instead of <code>Post()</code> (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go">/ch-3/basic/main.go</a><em>)</em></p>&#13;
<p class="indent">Unfortunately, no convenience functions exist for other HTTP verbs, such as PATCH, PUT, or DELETE. You’ll use these verbs mostly to interact with RESTful APIs, which employ general guidelines on how and why a server should use them; but nothing is set in stone, and HTTP is like the Old West when it comes to verbs. In fact, we’ve often toyed with the idea of creating a new web framework that exclusively uses DELETE for everything. we’d call it <em>DELETE.js</em>, and it would be a top hit on Hacker News for sure. By reading this, you’re agreeing not to steal this idea!</p>&#13;
<h4 class="h4" id="ch3lev2sec2"><span epub:type="pagebreak" id="page_48"/>Generating a Request</h4>&#13;
<p class="noindent">To generate a request with one of these verbs, you can use the <code>NewRequest()</code> function to create the <code>Request</code> struct, which you’ll subsequently send using the <code>Client</code> function’s <code>Do()</code> method. We promise that it’s simpler than it sounds. The function prototype for <code>http.NewRequest()</code> is as follows:</p>&#13;
<pre>func NewRequest(<span class="ent">❶</span><span class="codeitalic1">method</span>, <span class="ent">❷</span><span class="codeitalic1">url string</span>, <span class="ent">❸</span><span class="codeitalic1">body io.Reader</span>) (req *Request, err error)</pre>&#13;
<p class="indent">You need to supply the HTTP verb <span class="ent">❶</span> and destination URL <span class="ent">❷</span> to <code>NewRequest()</code> as the first two string parameters. Much like the first POST example in <a href="ch03.xhtml#ch3list1">Listing 3-1</a>, you can optionally supply the request body by passing in an <code>io.Reader</code> as the third and final parameter <span class="ent">❸</span>.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3list3">Listing 3-3</a> shows a call without an HTTP body—a DELETE request.</p>&#13;
<pre>req, err := http.NewRequest("DELETE", "https://www.google.com/robots.txt", nil)&#13;
var client http.Client&#13;
resp, err := client.Do(req)&#13;
// Read response body and close.</pre>&#13;
<p class="caption" id="ch3list3"><em>Listing 3-3: Sending a DELETE request (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go">/ch-3/basic/main.go</a><em>)</em></p>&#13;
<p class="indent">Now, <a href="ch03.xhtml#ch3list4">Listing 3-4</a> shows a PUT request with an <code>io.Reader</code> body (a PATCH request looks similar).</p>&#13;
<pre>form := url.Values{}&#13;
form.Add("foo", "bar")&#13;
var client http.Client&#13;
req, err := http.NewRequest(&#13;
    "PUT",&#13;
    "https://www.google.com/robots.txt",&#13;
    strings.NewReader(form.Encode()),&#13;
)&#13;
resp, err := client.Do(req)&#13;
// Read response body and close.</pre>&#13;
<p class="caption" id="ch3list4"><em>Listing 3-4: Sending a PUT request (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go">/ch-3/basic/main.go</a><em>)</em></p>&#13;
<p class="indent">The standard Go <code>net/http</code> library contains several functions that you can use to manipulate the request before it’s sent to the server. You’ll learn some of the more relevant and applicable variants as you work through practical examples throughout this chapter. But first, we’ll show you how to do something meaningful with the HTTP response that the server receives.</p>&#13;
<h4 class="h4" id="ch3lev2sec3">Using Structured Response Parsing</h4>&#13;
<p class="noindent">In the previous section, you learned the mechanisms for building and sending HTTP requests in Go. Each of those examples glossed over response handling, essentially ignoring it for the time being. But inspecting various <span epub:type="pagebreak" id="page_49"/>components of the HTTP response is a crucial aspect of any HTTP-related task, like reading the response body, accessing cookies and headers, or simply inspecting the HTTP status code.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3list5">Listing 3-5</a> refines the GET request in <a href="ch03.xhtml#ch3list1">Listing 3-1</a> to display the status code and response body—in this case, Google’s <em>robots.txt</em> file. It uses the <code>ioutil.ReadAll()</code> function to read data from the response body, does some error checking, and prints the HTTP status code and response body to stdout.</p>&#13;
<pre><span class="ent">❶</span> resp, err := http.Get("https://www.google.com/robots.txt")&#13;
   if err != nil {&#13;
       log.Panicln(err)&#13;
   }&#13;
   // Print HTTP Status&#13;
   fmt.Println(resp.Status<span class="ent">❷</span>)&#13;
&#13;
   // Read and display response body&#13;
   body, err := ioutil.ReadAll(resp.Body<span class="ent">❸</span>)&#13;
   if err != nil {&#13;
       log.Panicln(err)&#13;
   }&#13;
   fmt.Println(string(body))&#13;
<span class="ent">❹</span> resp.Body.Close()</pre>&#13;
<p class="caption" id="ch3list5"><em>Listing 3-5: Processing the HTTP response body (<a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go">/ch-3/basic/main.go</a>)</em></p>&#13;
<p class="indent">Once you receive your response, named <code>resp</code> <span class="ent">❶</span> in the above code, you can retrieve the status string (for example, <code>200 OK</code>) by accessing the exported <code>Status</code> parameter <span class="ent">❷</span>; not shown in our example, there is a similar <code>StatusCode</code> parameter that accesses only the integer portion of the status string.</p>&#13;
<p class="indent">The <code>Response</code> type contains an exported <code>Body</code> parameter <span class="ent">❸</span>, which is of type <code>io.ReadCloser</code>. An <code>io.ReadCloser</code> is an interface that acts as an <code>io.Reader</code> as well as an <code>io.Closer</code>, or an interface that requires the implementation of a <code>Close()</code> function to close the reader and perform any cleanup. The details are somewhat inconsequential; just know that after reading the data from an <code>io.ReadCloser</code>, you’ll need to call the <code>Close()</code> function <span class="ent">❹</span> on the response body. Using <code>defer</code> to close the response body is a common practice; this will ensure that the body is closed before you return it.</p>&#13;
<p class="indent">Now, run the script to see the error status and response body:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
200 OK&#13;
User-agent: *&#13;
Disallow: /search&#13;
Allow: /search/about&#13;
Disallow: /sdch&#13;
Disallow: /groups&#13;
Disallow: /index.html?&#13;
Disallow: /?&#13;
Allow: /?hl=&#13;
<span epub:type="pagebreak" id="page_50"/>Disallow: /?hl=*&amp;&#13;
Allow: /?hl=*&amp;gws_rd=ssl$&#13;
Disallow: /?hl=*&amp;*&amp;gws_rd=ssl&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">If you encounter a need to parse more structured data—and it’s likely that you will—you can read the response body and decode it by using the conventions presented in <a href="ch02.xhtml#ch2">Chapter 2</a>. For example, imagine you’re interacting with an API that communicates using JSON, and one endpoint—say, <code>/ping</code>—returns the following response indicating the server state:</p>&#13;
<pre>{"Message":"All is good with the world","Status":"Success"}</pre>&#13;
<p class="indent">You can interact with this endpoint and decode the JSON message by using the program in <a href="ch03.xhtml#ch3list6">Listing 3-6</a>.</p>&#13;
<pre>   package main&#13;
&#13;
   import {&#13;
       encoding/json"&#13;
       log&#13;
       net/http&#13;
   }&#13;
<span class="ent">❶</span> type Status struct {&#13;
       Message string&#13;
       Status  string&#13;
   }&#13;
&#13;
   func main() {&#13;
    <span class="ent">❷</span> res, err := http.Post(&#13;
           "http://<span class="codeitalic1">IP:PORT</span>/ping",&#13;
           "application/json",&#13;
           nil,&#13;
       )&#13;
       if err != nil {&#13;
           log.Fatalln(err)&#13;
       }&#13;
&#13;
       var status Status&#13;
    <span class="ent">❸</span> if err := json.NewDecoder(res.Body).Decode(&amp;status); err != nil {&#13;
           log.Fatalln(err)&#13;
       }&#13;
       defer res.Body.Close()&#13;
       log.Printf("%s -&gt; %s\n", status.Status<span class="ent">❹</span>, status.Message<span class="ent">❺</span>)&#13;
   }</pre>&#13;
<p class="caption" id="ch3list6"><em>Listing 3-6: Decoding a JSON response body (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/basic-parsing/main.go">/ch-3/basic-parsing/main.go</a><em>)</em></p>&#13;
<p class="indent">The code begins by defining a struct called <code>Status</code> <span class="ent">❶</span>, which contains the expected elements from the server response. The <code>main()</code> function first sends the POST request <span class="ent">❷</span> and then decodes the response body <span class="ent">❸</span>. After <span epub:type="pagebreak" id="page_51"/>doing so, you can query the <code>Status</code> struct as you normally would—by accessing exported data types <code>Status</code> <span class="ent">❹</span> and <code>Message</code> <span class="ent">❺</span>.</p>&#13;
<p class="indent">This process of parsing structured data types is consistent across other encoding formats, like XML or even binary representations. You begin the process by defining a struct to represent the expected response data and then decoding the data into that struct. The details and actual implementation of parsing other formats will be left up to you to determine.</p>&#13;
<p class="indent">The next sections will apply these fundamental concepts to assist you in building tools to interact with third-party APIs for the purpose of enhancing adversarial techniques and reconnaissance.</p>&#13;
<h3 class="h3" id="ch3lev1sec2">Building an HTTP Client That Interacts with Shodan</h3>&#13;
<p class="noindent">Prior to performing any authorized adversarial activities against an organization, any good attacker begins with reconnaissance. Typically, this starts with passive techniques that don’t send packets to the target; that way, detection of the activity is next to impossible. Attackers use a variety of sources and services—including social networks, public records, and search engines—to gain potentially useful information about the target.</p>&#13;
<p class="indent">It’s absolutely incredible how seemingly benign information becomes critical when environmental context is applied during a chained attack scenario. For example, a web application that discloses verbose error messages may, alone, be considered low severity. However, if the error messages disclose the enterprise username format, and if the organization uses single-factor authentication for its VPN, those error messages could increase the likelihood of an internal network compromise through password-guessing attacks.</p>&#13;
<p class="indent">Maintaining a low profile while gathering the information ensures that the target’s awareness and security posture remains neutral, increasing the likelihood that your attack will be successful.</p>&#13;
<p class="indent"><em>Shodan</em> (<em><a href="https://www.shodan.io/">https://www.shodan.io/</a></em>), self-described as “the world’s first search engine for internet-connected devices,” facilitates passive reconnaissance by maintaining a searchable database of networked devices and services, including metadata such as product names, versions, locale, and more. Think of Shodan as a repository of scan data, even if it does much, much more.</p>&#13;
<h4 class="h4" id="ch3lev2sec4">Reviewing the Steps for Building an API Client</h4>&#13;
<p class="noindent">In the next few sections, you’ll build an HTTP client that interacts with the Shodan API, parsing the results and displaying relevant information. First, you’ll need a Shodan API key, which you get after you register on Shodan’s website. At the time of this writing, the fee is fairly nominal for the lowest tier, which offers adequate credits for individual use, so go sign up for that. Shodan occasionally offers discounted pricing, so monitor it closely if you want to save a few bucks.</p>&#13;
<p class="indent">Now, get your API key from the site and set it as an environment variable. The following examples will work as-is only if you save your API key as the variable <code>SHODAN_API_KEY</code>. Refer to your operating system’s user manual, or better yet, look at <a href="ch01.xhtml#ch1">Chapter 1</a> if you need help setting the variable.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>Before working through the code, understand that this section demonstrates how to create a bare-bones implementation of a client—not a fully featured, comprehensive implementation. However, the basic scaffolding you’ll build now will allow you to easily extend the demonstrated code to implement other API calls as you may need.</p>&#13;
<p class="indent">The client you build will implement two API calls: one to query subscription credit information and the other to search for hosts that contain a certain string. You use the latter call for identifying hosts; for example, ports or operating systems matching a certain product.</p>&#13;
<p class="indent">Luckily, the Shodan API is straightforward, producing nicely structured JSON responses. This makes it a good starting point for learning API interaction. Here is a high-level overview of the typical steps for preparing and building an API client:</p>&#13;
<ol>&#13;
<li><p class="noindent">Review the service’s API documentation.</p></li>&#13;
<li><p class="noindent">Design a logical structure for the code in order to reduce complexity and repetition.</p></li>&#13;
<li><p class="noindent">Define request or response types, as necessary, in Go.</p></li>&#13;
<li><p class="noindent">Create helper functions and types to facilitate simple initialization, authentication, and communication to reduce verbose or repetitive logic.</p></li>&#13;
<li><p class="noindent">Build the client that interacts with the API consumer functions and types.</p></li>&#13;
</ol>&#13;
<p class="indent">We won’t explicitly call out each step in this section, but you should use this list as a map to guide your development. Start by quickly reviewing the API documentation on Shodan’s website. The documentation is minimal but produces everything needed to create a client program.</p>&#13;
<h4 class="h4" id="ch3lev2sec5">Designing the Project Structure</h4>&#13;
<p class="noindent">When building an API client, you should structure it so that the function calls and logic stand alone. This allows you to reuse the implementation as a library in other projects. That way, you won’t have to reinvent the wheel in the future. Building for reusability slightly changes a project’s structure. For the Shodan example, here’s the project structure:</p>&#13;
<pre>$ <span class="codestrong1">tree github.com/blackhat-go/bhg/ch-3/shodan</span>&#13;
github.com/blackhat-go/bhg/ch-3/shodan&#13;
|---cmd&#13;
|   |---shodan&#13;
|       |---main.go&#13;
|---shodan&#13;
    |---api.go&#13;
    |---host.go&#13;
    |---shodan.go</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>The <em>main.go</em> file defines <code>package main</code> and is used primarily as a consumer of the API you’ll build; in this case, you use it primarily to interact with your client implementation.</p>&#13;
<p class="indent">The files in the <em>shodan</em> directory—<em>api.go</em>, <em>host.go</em>, and <em>shodan.go</em>—define <code>package shodan</code>, which contains the types and functions necessary for communication to and from Shodan. This package will become your stand-alone library that you can import into various projects.</p>&#13;
<h4 class="h4" id="ch3lev2sec6">Cleaning Up API Calls</h4>&#13;
<p class="noindent">When you perused the Shodan API documentation, you may have noticed that every exposed function requires you to send your API key. Although you certainly can pass that value around to each consumer function you create, that repetitive task becomes tedious. The same can be said for either hardcoding or handling the base URL (<em>https://api.shodan.io/</em>). For example, defining your API functions, as in the following snippet, requires you to pass in the token and URL to each function, which isn’t very elegant:</p>&#13;
<pre>func APIInfo(<span class="codeitalic1">token</span>, <span class="codeitalic1">url string</span>) { --<span class="codeitalic1">snip</span>-- }&#13;
func HostSearch(<span class="codeitalic1">token</span>, <span class="codeitalic1">url string</span>) { --<span class="codeitalic1">snip</span>-- }</pre>&#13;
<p class="indent">Instead, opt for a more idiomatic solution that allows you to save keystrokes while arguably making your code more readable. To do this, create a <em>shodan.go</em> file and enter the code in <a href="ch03.xhtml#ch3list7">Listing 3-7</a>.</p>&#13;
<pre>   package shodan&#13;
&#13;
<span class="ent">❶</span> const BaseURL = "https://api.shodan.io"&#13;
&#13;
<span class="ent">❷</span> type Client struct {&#13;
       apiKey string&#13;
   }&#13;
&#13;
<span class="ent">❸</span> func New(apiKey string) *Client {&#13;
       return &amp;Client{apiKey: apiKey}&#13;
   }</pre>&#13;
<p class="caption" id="ch3list7"><em>Listing 3-7: Shodan <code>Client</code> definition (</em>/<a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/shodan.go">ch-3/shodan/shodan/shodan.go</a><em>)</em></p>&#13;
<p class="indent">The Shodan URL is defined as a constant value <span class="ent">❶</span>; that way, you can easily access and reuse it within your implementing functions. If Shodan ever changes the URL of its API, you’ll have to make the change at only this one location in order to correct your entire codebase. Next, you define a <code>Client</code> struct, used for maintaining your API token across requests <span class="ent">❷</span>. Finally, the code defines a <code>New()</code> helper function, taking the API token as input and creating and returning an initialized <code>Client</code> instance <span class="ent">❸</span>. Now, rather than creating your API code as arbitrary functions, you create them as <em>methods</em> on the <code>Client</code> struct, which allows you to interrogate the instance <span epub:type="pagebreak" id="page_54"/>directly rather than relying on overly verbose function parameters. You can change your API function calls, which we’ll discuss momentarily, to the following:</p>&#13;
<pre>func (s *Client) APIInfo() { --<span class="codeitalic1">snip</span>-- }&#13;
func (s *Client) HostSearch() { --<span class="codeitalic1">snip</span>-- }</pre>&#13;
<p class="indent">Since these are methods on the <code>Client</code> struct, you can retrieve the API key through <code>s.apiKey</code> and retrieve the URL through <code>BaseURL</code>. The only prerequisite to calling the methods is that you create an instance of the <code>Client</code> struct first. You can do this with the <code>New()</code> helper function in <em>shodan.go</em>.</p>&#13;
<h4 class="h4" id="ch3lev2sec7">Querying Your Shodan Subscription</h4>&#13;
<p class="noindent">Now you’ll start the interaction with Shodan. Per the Shodan API documentation, the call to query your subscription plan information is as follows:</p>&#13;
<pre>https://api.shodan.io/api-info?key=<span class="codeitalic1">{YOUR_API_KEY}</span></pre>&#13;
<p class="indent">The response returned resembles the following structure. Obviously, the values will differ based on your plan details and remaining subscription credits.</p>&#13;
<pre>{&#13;
 "query_credits": 56,&#13;
 "scan_credits": 0,&#13;
 "telnet": true,&#13;
 "plan": "edu",&#13;
 "https": true,&#13;
 "unlocked": true,&#13;
}</pre>&#13;
<p class="indent">First, in <em>api.go</em>, you’ll need to define a type that can be used to unmarshal the JSON response to a Go struct. Without it, you won’t be able to process or interrogate the response body. In this example, name the type <code>APIInfo</code>:</p>&#13;
<pre>type APIInfo struct {&#13;
    QueryCredits int    `json:"query_credits"`&#13;
    ScanCredits  int    `json:"scan_credits"`&#13;
    Telnet       bool   `json:"telnet"`&#13;
    Plan         string `json:"plan"`&#13;
    HTTPS        bool   `json:"https"`&#13;
    Unlocked     bool   `json:"unlocked"`&#13;
}</pre>&#13;
<p class="indent">The awesomeness that is Go makes that structure and JSON alignment a joy. As shown in <a href="ch01.xhtml#ch1">Chapter 1</a>, you can use some great tooling to “automagically” parse JSON—populating the fields for you. For each exported type on the struct, you explicitly define the JSON element name with struct tags so you can ensure that data is mapped and parsed properly.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Next you need to implement the function in <a href="ch03.xhtml#ch3list8">Listing 3-8</a>, which makes an HTTP GET request to Shodan and decodes the response into your <code>APIInfo</code> struct:</p>&#13;
<pre>func (s *Client) APIInfo() (*APIInfo, error) {&#13;
    res, err := http.Get(fmt.Sprintf("%s/api-info?key=%s", BaseURL, s.apiKey))<span class="ent">❶</span>&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
    defer res.Body.Close()&#13;
&#13;
    var ret APIInfo&#13;
    if err := json.NewDecoder(res.Body).Decode(&amp;ret)<span class="ent">❷</span>; err != nil {&#13;
        return nil, err&#13;
    }&#13;
    return &amp;ret, nil&#13;
}</pre>&#13;
<p class="caption" id="ch3list8"><em>Listing 3-8: Making an HTTP GET request and decoding the response (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/api.go">/ch-3/shodan/shodan/api.go</a><em>)</em></p>&#13;
<p class="indent">The implementation is short and sweet. You first issue an HTTP GET request to the <code>/api-info</code> resource <span class="ent">❶</span>. The full URL is built using the <code>BaseURL</code> global constant and <code>s.apiKey</code>. You then decode the response into your <code>APIInfo</code> struct <span class="ent">❷</span> and return it to the caller.</p>&#13;
<p class="indent">Before writing code that utilizes this shiny new logic, build out a second, more useful API call—the host search—which you’ll add to <em>host.go</em>. The request and response, according to the API documentation, is as follows:</p>&#13;
<pre>https://api.shodan.io/shodan/host/search?key=<span class="codeitalicst">{</span><span class="codeitalic1">YOUR_API_KEY}</span>&amp;query=<span class="codeitalic1">{query}</span>&amp;facets=<span class="codeitalic1">{facets}</span>&#13;
&#13;
{&#13;
    "matches": [&#13;
    {&#13;
        "os": null,&#13;
        "timestamp": "2014-01-15T05:49:56.283713",&#13;
        "isp": "Vivacom",&#13;
        "asn": "AS8866",&#13;
        "hostnames": [ ],&#13;
        "location": {&#13;
            "city": null,&#13;
            "region_code": null,&#13;
            "area_code": null,&#13;
            "longitude": 25,&#13;
            "country_code3": "BGR",&#13;
            "country_name": "Bulgaria",&#13;
            "postal_code": null,&#13;
            "dma_code": null,&#13;
            "country_code": "BG",&#13;
            "latitude": 43&#13;
        },&#13;
        "ip": 3579573318,&#13;
        "domains": [ ],&#13;
<span epub:type="pagebreak" id="page_56"/>        "org": "Vivacom",&#13;
        "data": "@PJL INFO STATUS CODE=35078 DISPLAY="Power Saver" ONLINE=TRUE",&#13;
        "port": 9100,&#13;
        "ip_str": "213.91.244.70"&#13;
    },&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    ],&#13;
    "facets": {&#13;
        "org": [&#13;
        {&#13;
            "count": 286,&#13;
            "value": "Korea Telecom"&#13;
        },&#13;
        --<span class="codeitalic1">snip</span>--&#13;
        ]&#13;
    },&#13;
    "total": 12039&#13;
}</pre>&#13;
<p class="indent">Compared to the initial API call you implemented, this one is significantly more complex. Not only does the request take multiple parameters, but the JSON response contains nested data and arrays. For the following implementation, you’ll ignore the <code>facets</code> option and data, and instead focus on performing a string-based host search to process only the <code>matches</code> element of the response.</p>&#13;
<p class="indent">As you did before, start by building the Go structs to handle the response data; enter the types in <a href="ch03.xhtml#ch3list9">Listing 3-9</a> into your <em>host.go</em> file.</p>&#13;
<pre>type HostLocation struct {&#13;
    City         string  `json:"city"`&#13;
    RegionCode   string  `json:"region_code"`&#13;
    AreaCode     int     `json:"area_code"`&#13;
    Longitude    float32 `json:"longitude"`&#13;
    CountryCode3 string  `json:"country_code3"`&#13;
    CountryName  string  `json:"country_name"`&#13;
    PostalCode   string  `json:"postal_code"`&#13;
    DMACode      int     `json:"dma_code"`&#13;
    CountryCode  string  `json:"country_code"`&#13;
    Latitude     float32 `json:"latitude"`&#13;
}&#13;
&#13;
type Host struct {&#13;
    OS        string       `json:"os"`&#13;
    Timestamp string       `json:"timestamp"`&#13;
    ISP       string       `json:"isp"`&#13;
    ASN       string       `json:"asn"`&#13;
    Hostnames []string     `json:"hostnames"`&#13;
    Location  HostLocation `json:"location"`&#13;
    IP        int64        `json:"ip"`&#13;
    Domains   []string     `json:"domains"`&#13;
    Org       string       `json:"org"`&#13;
    Data      string       `json:"data"`&#13;
<span epub:type="pagebreak" id="page_57"/>    Port      int          `json:"port"`&#13;
    IPString  string       `json:"ip_str"`&#13;
}&#13;
&#13;
type HostSearch struct {&#13;
    Matches []Host `json:"matches"`&#13;
}</pre>&#13;
<p class="caption" id="ch3list9"><em>Listing 3-9: Host search response data types (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/host.go">/ch-3/shodan/shodan/host.go</a><em>)</em></p>&#13;
<p class="indent">The code defines three types:</p>&#13;
<p class="noindentf"><strong><span class="codestrong">HostSearch</span></strong> Used for parsing the <code>matches</code> array</p>&#13;
<p class="noindentf"><strong><span class="codestrong">Host</span></strong> Represents a single <code>matches</code> element</p>&#13;
<p class="noindentf"><strong><span class="codestrong">HostLocation</span></strong> Represents the <code>location</code> element within the host</p>&#13;
<p class="indent">Notice that the types may not define all response fields. Go handles this elegantly, allowing you to define structures with only the JSON fields you care about. Therefore, our code will parse the JSON just fine, while reducing the length of your code by including only the fields that are most relevant to the example. To initialize and populate the struct, you’ll define the function in <a href="ch03.xhtml#ch3list10">Listing 3-10</a>, which is similar to the <code>APIInfo()</code> method you created in <a href="ch03.xhtml#ch3list8">Listing 3-8</a>.</p>&#13;
<pre>func (s *Client) HostSearch(q string<span class="ent">❶</span>) (*HostSearch, error) {&#13;
    res, err := http.Get( <span class="ent">❷</span>&#13;
        fmt.Sprintf("%s/shodan/host/search?key=%s&amp;query=%s", BaseURL, s.apiKey, q),&#13;
    )&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
    defer res.Body.Close()&#13;
&#13;
    var ret HostSearch&#13;
    if err := json.NewDecoder(res.Body).Decode(&amp;ret)<span class="ent">❸</span>; err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return &amp;ret, nil&#13;
}</pre>&#13;
<p class="caption" id="ch3list10"><em>Listing 3-10: Decoding the host search response body (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/host.go">/ch-3/shodan/shodan/host.go</a><em>)</em></p>&#13;
<p class="indent">The flow and logic is exactly like the <code>APIInfo()</code> method, except that you take the search query string as a parameter <span class="ent">❶</span>, issue the call to the <code>/shodan/host/search</code> endpoint while passing the search term <span class="ent">❷</span>, and decode the response into the <code>HostSearch</code> struct <span class="ent">❸</span>.</p>&#13;
<p class="indent">You repeat this process of structure definition and function implementation for each API service you want to interact with. Rather than wasting precious pages here, we’ll jump ahead and show you the last step of the process: creating the client that uses your API code.</p>&#13;
<h4 class="h4" id="ch3lev2sec8"><span epub:type="pagebreak" id="page_58"/>Creating a Client</h4>&#13;
<p class="noindent">You’ll use a minimalistic approach to create your client: take a search term as a command line argument and then call the <code>APIInfo()</code> and <code>HostSearch()</code> methods, as in <a href="ch03.xhtml#ch3list11">Listing 3-11</a>.</p>&#13;
<pre>func main() {&#13;
    if len(os.Args) != 2 {&#13;
        log.Fatalln("Usage: shodan <span class="codeitalic1">searchterm</span>")&#13;
    }&#13;
    apiKey := os.Getenv("SHODAN_API_KEY")<span class="ent">❶</span>&#13;
    s := shodan.New(apiKey)<span class="ent">❷</span>&#13;
    info, err := s.APIInfo()<span class="ent">❸</span>&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
    fmt.Printf(&#13;
        "Query Credits: %d\nScan Credits:  %d\n\n",&#13;
        info.QueryCredits,&#13;
        info.ScanCredits)&#13;
&#13;
    hostSearch, err := s.HostSearch(os.Args[1])<span class="ent">❹</span>&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
 <span class="ent">❺</span> for _, host := range hostSearch.Matches {&#13;
        fmt.Printf("%18s%8d\n", host.IPString, host.Port)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch3list11"><em>Listing 3-11: Consuming and using the <code>shodan</code> package (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/cmd/shodan/main.go">/ch-3/shodan/cmd/shodan/main.go</a><em>)</em></p>&#13;
<p class="indent">Start by reading your API key from the <code>SHODAN_API_KEY</code> environment variable <span class="ent">❶</span>. Then use that value to initialize a new <code>Client</code> struct <span class="ent">❷</span>, <code>s</code>, subsequently using it to call your <code>APIInfo()</code> method <span class="ent">❸</span>. Call the <code>HostSearch()</code> method, passing in a search string captured as a command line argument <span class="ent">❹</span>. Finally, loop through the results to display the IP and port values for those services matching the query string <span class="ent">❺</span>. The following output shows a sample run, searching for the string <code>tomcat</code>:</p>&#13;
<pre>$ <span class="codestrong1">SHODAN_API_KEY=</span><span class="codeitalicst">YOUR-KEY</span> <span class="codestrong1">go run main.go tomcat</span>&#13;
Query Credits: 100&#13;
Scan Credits:  100&#13;
&#13;
    185.23.138.141    8081&#13;
   218.103.124.239    8080&#13;
     123.59.14.169    8081&#13;
      177.6.80.213    8181&#13;
    142.165.84.160   10000&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>You’ll want to add error handling and data validation to this project, but it serves as a good example for fetching and displaying Shodan data with your new API. You now have a working codebase that can be easily extended to support and test the other Shodan functions.</p>&#13;
<h3 class="h3" id="ch3lev1sec3">Interacting with Metasploit</h3>&#13;
<p class="noindent"><em>Metasploit</em> is a framework used to perform a variety of adversarial techniques, including reconnaissance, exploitation, command and control, persistence, lateral network movement, payload creation and delivery, privilege escalation, and more. Even better, the community version of the product is free, runs on Linux and macOS, and is actively maintained. Essential for any adversarial engagement, Metasploit is a fundamental tool used by penetration testers, and it exposes a <em>remote procedure call</em> <em>(RPC)</em> API to allow remote interaction with its functionality.</p>&#13;
<p class="indent">In this section, you’ll build a client that interacts with a remote Metasploit instance. Much like the Shodan code you built, the Metasploit client you develop won’t cover a comprehensive implementation of all available functionality. Rather, it will be the foundation upon which you can extend additional functionality as needed. We think you’ll find the implementation more complex than the Shodan example, making the Metasploit interaction a more challenging progression.</p>&#13;
<h4 class="h4" id="ch3lev2sec9">Setting Up Your Environment</h4>&#13;
<p class="noindent">Before you proceed with this section, download and install the Metasploit community edition if you don’t already have it. Start the Metasploit console as well as the RPC listener through the <code>msgrpc</code> module in Metasploit. Then set the server host—the IP on which the RPC server will listen—and a password, as shown in <a href="ch03.xhtml#ch3list12">Listing 3-12</a>.</p>&#13;
<pre>$ <span class="codestrong1">msfconsole</span>&#13;
msf &gt; <span class="codestrong1">load msgrpc Pass</span><span class="codeitalicst">=s3cr3t</span> <span class="codestrong1">ServerHost=</span><span class="codeitalicst">10.0.1.6</span>&#13;
[*] MSGRPC Service:  <span class="codeitalic1">10.0.1.6:55552</span>&#13;
[*] MSGRPC Username: <span class="codeitalic1">msf</span>&#13;
[*] MSGRPC Password: <span class="codeitalic1">s3cr3t</span>&#13;
[*] Successfully loaded plugin: msgrpc</pre>&#13;
<p class="caption" id="ch3list12"><em>Listing 3-12: Starting Metasploit and the msgrpc server</em></p>&#13;
<p class="indent">To make the code more portable and avoid hardcoding values, set the following environment variables to the values you defined for your RPC instance. This is similar to what you did for the Shodan API key used to interact with Shodan in “Creating a Client” on <a href="ch03.xhtml#page_58">page 58</a>.</p>&#13;
<pre>$ <span class="codestrong1">export MSFHOST=</span><span class="codeitalicst">10.0.1.6:55552</span>&#13;
$ <span class="codestrong1">export MSFPASS=</span><span class="codeitalicst">s3cr3t</span></pre>&#13;
<p class="indent">You should now have Metasploit and the RPC server running.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Because the details on exploitation and Metasploit use are beyond the scope of this book,<sup><a id="rch3fn1" href="footnote.xhtml#ch3fn1">1</a></sup> let’s assume that through pure cunning and trickery you’ve already compromised a remote Windows system and you’ve leveraged Metasploit’s Meterpreter payload for advanced post-exploitation activities. Here, your efforts will instead focus on how you can remotely communicate with Metasploit to list and interact with established Meterpreter sessions. As we mentioned before, this code is a bit more cumbersome, so we’ll purposely pare it back to the bare minimum—just enough for you to take the code and extend it for your specific needs.</p>&#13;
<p class="indent">Follow the same project roadmap as the Shodan example: review the Metasploit API, lay out the project in library format, define data types, implement client API functions, and, finally, build a test rig that uses the library.</p>&#13;
<p class="indent">First, review the Metasploit API developer documentation at Rapid7’s official website (<em><a href="https://metasploit.help.rapid7.com/docs/rpc-api/">https://metasploit.help.rapid7.com/docs/rpc-api/</a></em>). The functionality exposed is extensive, allowing you to do just about anything remotely that you could through local interaction. Unlike Shodan, which uses JSON, Metasploit communicates using MessagePack, a compact and efficient binary format. Because Go doesn’t contain a standard MessagePack package, you’ll use a full-featured community implementation. Install it by executing the following from the command line:</p>&#13;
<pre>$ <span class="codestrong1">go get gopkg.in/vmihailenco/msgpack.v2</span></pre>&#13;
<p class="indent">In the code, you’ll refer to the implementation as <code>msgpack</code>. Don’t worry too much about the details of the MessagePack spec. You’ll see shortly that you’ll need to know very little about MessagePack itself to build a working client. Go is great because it hides a lot of these details, allowing you to instead focus on business logic. What you need to know are the basics of annotating your type definitions in order to make them “MessagePack-friendly.” Beyond that, the code to initiate encoding and decoding is identical to other formats, such as JSON and XML.</p>&#13;
<p class="indent">Next, create your directory structure. For this example, you use only two Go files:</p>&#13;
<pre>$ <span class="codestrong1">tree github.com/blackhat-go/bhg/ch-3/metasploit-minimal</span>&#13;
github.com/blackhat-go/bhg/ch-3/metasploit-minimal&#13;
|---client&#13;
|   |---main.go&#13;
|---rpc&#13;
    |---msf.go</pre>&#13;
<p class="indent">The <em>msf.go</em> file resides within the <code>rpc</code> package, and you’ll use <em>client/main.go</em> to implement and test the library you build.</p>&#13;
<h4 class="h4" id="ch3lev2sec10"><span epub:type="pagebreak" id="page_61"/>Defining Your Objective</h4>&#13;
<p class="noindent">Now, you need to define your objective. For the sake of brevity, implement the code to interact and issue an RPC call that retrieves a listing of current Meterpreter sessions—that is, the <code>session.list</code> method from the Metasploit developer documentation. The request format is defined as follows:</p>&#13;
<pre>[ "session.list", "<span class="codeitalic1">token</span>" ]</pre>&#13;
<p class="indent">This is minimal; it expects to receive the name of the method to implement and a token. The <span class="codeitalic">token</span> value is a placeholder. If you read through the documentation, you’ll find that this is an authentication token, issued upon successful login to the RPC server. The response returned from Metasploit for the <code>session.list</code> method follows this format:</p>&#13;
<pre>{&#13;
"1" =&gt; {&#13;
    'type' =&gt; "shell",&#13;
    "tunnel_local" =&gt; "192.168.35.149:44444",&#13;
    "tunnel_peer" =&gt; "192.168.35.149:43886",&#13;
    "via_exploit" =&gt; "exploit/multi/handler",&#13;
    "via_payload" =&gt; "payload/windows/shell_reverse_tcp",&#13;
    "desc" =&gt; "Command shell",&#13;
    "info" =&gt; "",&#13;
    "workspace" =&gt; "Project1",&#13;
    "target_host" =&gt; "",&#13;
    "username" =&gt; "root",&#13;
    "uuid" =&gt; "hjahs9kw",&#13;
    "exploit_uuid" =&gt; "gcprpj2a",&#13;
    "routes" =&gt; [ ]&#13;
    }&#13;
}</pre>&#13;
<p class="indent">This response is returned as a map: the Meterpreter session identifiers are the keys, and the session detail is the value.</p>&#13;
<p class="indent">Let’s build the Go types to handle both the request and response data. <a href="ch03.xhtml#ch3list13">Listing 3-13</a> defines the <code>sessionListReq</code> and <code>SessionListRes</code>.</p>&#13;
<pre><span class="ent">❶</span> type sessionListReq struct {&#13;
    <span class="ent">❷</span> _msgpack struct{} `msgpack:",asArray"`&#13;
       Method   string&#13;
       Token    string&#13;
   }&#13;
&#13;
<span class="ent">❸</span> type SessionListRes struct {&#13;
       ID          uint32 `msgpack:",omitempty"`<span class="ent">❹</span>&#13;
       Type        string `msgpack:"type"`&#13;
       TunnelLocal string `msgpack:"tunnel_local"`&#13;
       TunnelPeer  string `msgpack:"tunnel_peer"`&#13;
       ViaExploit  string `msgpack:"via_exploit"`&#13;
       ViaPayload  string `msgpack:"via_payload"`&#13;
       Description string `msgpack:"desc"`&#13;
   <span epub:type="pagebreak" id="page_62"/>    Info        string `msgpack:"info"`&#13;
       Workspace   string `msgpack:"workspace"`&#13;
       SessionHost string `msgpack"session_host"`&#13;
       SessionPort int    `msgpack"session_port"`&#13;
       Username    string `msgpack:"username"`&#13;
       UUID        string `msgpack:"uuid"`&#13;
       ExploitUUID string `msgpack:"exploit_uuid"`&#13;
}</pre>&#13;
<p class="caption" id="ch3list13"><em>Listing 3-13: Metasploit session list type definitions (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go">/ch-3/metasploit-minimal/rpc/msf.go</a><em>)</em></p>&#13;
<p class="indent">You use the request type, <code>sessionListReq</code> <span class="ent">❶</span>, to serialize structured data to the MessagePack format in a manner consistent with what the Metasploit RPC server expects—specifically, with a method name and token value. Notice that there aren’t any descriptors for those fields. The data is passed as an array, not a map, so rather than expecting data in key/value format, the RPC interface expects the data as a positional array of values. This is why you omit annotations for those properties—no need to define the key names. However, by default, a structure will be encoded as a map with the key names deduced from the property names. To disable this and force the encoding as a positional array, you add a special field named _<code>msgpack</code> that utilizes the <code>asArray</code> descriptor <span class="ent">❷</span>, to explicitly instruct an encoder/decoder to treat the data as an array.</p>&#13;
<p class="indent">The <code>SessionListRes</code> type <span class="ent">❸</span> contains a one-to-one mapping between response field and struct properties. The data, as shown in the preceding example response, is essentially a nested map. The outer map is the session identifier to session details, while the inner map is the session details, represented as key/value pairs. Unlike the request, the response isn’t structured as a positional array, but each of the struct properties uses descriptors to explicitly name and map the data to and from Metasploit’s representation. The code includes the session identifier as a property on the struct. However, because the actual value of the identifier is the key value, this will be populated in a slightly different manner, so you include the <code>omitempty</code> descriptor <span class="ent">❹</span> to make the data optional so that it doesn’t impact encoding or decoding. This flattens the data so you don’t have to work with nested maps.</p>&#13;
<h4 class="h4" id="ch3lev2sec11">Retrieving a Valid Token</h4>&#13;
<p class="noindent">Now, you have only one thing outstanding. You have to retrieve a valid <span class="codeitalic">token</span> value to use for that request. To do so, you’ll issue a login request for the <code>auth.login()</code> API method, which expects the following:</p>&#13;
<pre>["auth.login", "<span class="codeitalic1">username</span>", "<span class="codeitalic1">password</span>"]</pre>&#13;
<p class="indent">You need to replace the <span class="codeitalic">username</span> and <span class="codeitalic">password</span> values with what you used when loading the <code>msfrpc</code> module in Metasploit during initial setup (recall that you set them as environment variables). Assuming authentication is successful, the server responds with the following message, which contains an authentication token you can use for subsequent requests.</p>&#13;
<pre><span epub:type="pagebreak" id="page_63"/>{ "result" =&gt; "success", "<span class="codeitalic1">token</span>" =&gt; "a1a1a1a1a1a1a1a1" }</pre>&#13;
<p class="indent">An authentication failure produces the following response:</p>&#13;
<pre>{&#13;
    "error" =&gt; true,&#13;
    "error_class" =&gt; "Msf::RPC::Exception",&#13;
    "error_message" =&gt; "Invalid User ID or Password"&#13;
}</pre>&#13;
<p class="indent">For good measure, let’s also create functionality to expire the token by logging out. The request takes the method name, the authentication token, and a third optional parameter that you’ll ignore because it’s unnecessary for this scenario:</p>&#13;
<pre>[ "auth.logout", "<span class="codeitalic1">token</span>", "<span class="codeitalic1">logoutToken</span>"]</pre>&#13;
<p class="indent">A successful response looks like this:</p>&#13;
<pre>{ "result" =&gt; "success" }</pre>&#13;
<h4 class="h4" id="ch3lev2sec12">Defining Request and Response Methods</h4>&#13;
<p class="noindent">Much as you structured the Go types for the <code>session.list()</code> method’s request and response, you need to do the same for both <code>auth.login()</code> and <code>auth.logout()</code> (see <a href="ch03.xhtml#ch3list14">Listing 3-14</a>). The same reasoning applies as before, using descriptors to force requests to be serialized as arrays and for the responses to be treated as maps:</p>&#13;
<pre>type loginReq struct {&#13;
    _msgpack struct{} `msgpack:",asArray"`&#13;
    Method   string&#13;
    Username string&#13;
    Password string&#13;
}&#13;
&#13;
type loginRes struct {&#13;
    Result       string `msgpack:"result"`&#13;
    Token        string `msgpack:"token"`&#13;
    Error        bool   `msgpack:"error"`&#13;
    ErrorClass   string `msgpack:"error_class"`&#13;
    ErrorMessage string `msgpack:"error_message"`&#13;
}&#13;
&#13;
type logoutReq struct {&#13;
    _msgpack    struct{} `msgpack:",asArray"`&#13;
    Method      string&#13;
    Token       string&#13;
    LogoutToken string&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_64"/>type logoutRes struct {&#13;
    Result string `msgpack:"result"`&#13;
}</pre>&#13;
<p class="caption" id="ch3list14"><em>Listing 3-14: Login and logout Metasploit type definition (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go">/ch-3/metasploit-minimal/rpc/msf.go</a><em>)</em></p>&#13;
<p class="indent">It’s worth noting that Go dynamically serializes the login response, populating only the fields present, which means you can represent both successful and failed logins by using a single struct format.</p>&#13;
<h4 class="h4" id="ch3lev2sec13">Creating a Configuration Struct and an RPC Method</h4>&#13;
<p class="noindent">In <a href="ch03.xhtml#ch3list15">Listing 3-15</a>, you take the defined types and actually use them, creating the necessary methods to issue RPC commands to Metasploit. Much as in the Shodan example, you also define an arbitrary type for maintaining pertinent configuration and authentication information. That way, you won’t have to explicitly and repeatedly pass in common elements such as host, port, and authentication token. Instead, you’ll use the type and build methods on it so that data is implicitly available.</p>&#13;
<pre>type Metasploit struct {&#13;
    host  string&#13;
    user  string&#13;
    pass  string&#13;
    token string&#13;
}&#13;
&#13;
func New(host, user, pass string) *Metasploit {&#13;
    msf := &amp;Metasploit{&#13;
        host: host,&#13;
        user: user,&#13;
        pass: pass,&#13;
    }&#13;
&#13;
    return msf&#13;
}</pre>&#13;
<p class="caption" id="ch3list15"><em>Listing 3-15: Metasploit client definition (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go">/ch-3/metasploit-minimal/rpc/msf.go</a><em>)</em></p>&#13;
<p class="indent">Now you have a struct and, for convenience, a function named <code>New()</code> that initializes and returns a new struct.</p>&#13;
<h4 class="h4" id="ch3lev2sec14">Performing Remote Calls</h4>&#13;
<p class="noindent">You can now build methods on your <code>Metasploit</code> type in order to perform the remote calls. To prevent extensive code duplication, in <a href="ch03.xhtml#ch3list16">Listing 3-16</a>, you start by building a method that performs the serialization, deserialization, and HTTP communication logic. Then you won’t have to include this logic in every RPC function you build.</p>&#13;
<pre>func (msf *Metasploit) send(req interface{}, res interface{})<span class="ent">❶</span> error {&#13;
    buf := new(bytes.Buffer)&#13;
<span epub:type="pagebreak" id="page_65"/> <span class="ent">❷</span> msgpack.NewEncoder(buf).Encode(req)&#13;
 <span class="ent">❸</span> dest := fmt.Sprintf("http://%s/api", msf.host)&#13;
    r, err := http.Post(dest, "binary/message-pack", buf)<span class="ent">❹</span>&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    defer r.Body.Close()&#13;
&#13;
    if err := msgpack.NewDecoder(r.Body).Decode(&amp;res)<span class="ent">❺</span>; err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch3list16"><em>Listing 3-16: Generic <code>send()</code> method with reusable serialization and deserialization (</em>/<a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go">ch-3/metasploit-minimal/rpc/msf.go</a><em>)</em></p>&#13;
<p class="indent">The <code>send()</code> method receives request and response parameters of type <code>interface{}</code> <span class="ent">❶</span>. Using this interface type allows you to pass any request struct into the method, and subsequently serialize and send the request to the server. Rather than explicitly returning the response, you’ll use the <code>res interface{}</code> parameter to populate its data by writing a decoded HTTP response to its location in memory.</p>&#13;
<p class="indent">Next, use the <code>msgpack</code> library to encode the request <span class="ent">❷</span>. The logic to do this matches that of other standard, structured data types: first create an encoder via <code>NewEncoder()</code> and then call the <code>Encode()</code> method. This populates the <code>buf</code> variable with MessagePack-encoded representation of the request struct. Following the encoding, you build the destination URL by using the data within the <code>Metasploit</code> receiver, <code>msf</code> <span class="ent">❸</span>. You use that URL and issue a POST request, explicitly setting the content type to <code>binary/message-pack</code> and setting the body to the serialized data <span class="ent">❹</span>. Finally, you decode the response body <span class="ent">❺</span>. As alluded to earlier, the decoded data is written to the memory location of the response interface that was passed into the method. The encoding and decoding of data is done without ever needing to explicitly know the request or response struct types, making this a flexible, reusable method.</p>&#13;
<p class="indent">In <a href="ch03.xhtml#ch3list17">Listing 3-17</a>, you can see the meat of the logic in all its glory.</p>&#13;
<pre>func (msf *Metasploit) Login()<span class="ent">❶</span> error {&#13;
    ctx := &amp;loginReq{&#13;
        Method:   "auth.login",&#13;
        Username: msf.user,&#13;
        Password: msf.pass,&#13;
    }&#13;
    var res loginRes&#13;
    if err := msf.send(ctx, &amp;res)<span class="ent">❷</span>; err != nil {&#13;
        return err&#13;
    }&#13;
    msf.token = res.Token&#13;
    return nil&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_66"/>func (msf *Metasploit) Logout()<span class="ent">❸</span> error {&#13;
    ctx := &amp;logoutReq{&#13;
        Method:      "auth.logout",&#13;
        Token:       msf.token,&#13;
        LogoutToken: msf.token,&#13;
    }&#13;
    var res logoutRes&#13;
    if err := msf.send(ctx, &amp;res)<span class="ent">❹</span>; err != nil {&#13;
        return err&#13;
    }&#13;
    msf.token = ""&#13;
    return nil&#13;
}&#13;
&#13;
func (msf *Metasploit) SessionList()<span class="ent">❺</span> (map[uint32]SessionListRes, error) {&#13;
    req := &amp;SessionListReq{Method: "session.list", Token: msf.token}&#13;
 <span class="ent">❻</span> res := make(map[uint32]SessionListRes)&#13;
    if err := msf.send(req, &amp;res)<span class="ent">❼</span>; err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
 <span class="ent">❽</span> for id, session := range res {&#13;
        session.ID = id&#13;
        res[id] = session&#13;
    }&#13;
    return res, nil&#13;
}</pre>&#13;
<p class="caption" id="ch3list17"><em>Listing 3-17: Metasploit API calls implementation (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go">/ch-3/metasploit-minimal/rpc/msf.go</a><em>)</em></p>&#13;
<p class="indent">You define three methods: <code>Login()</code> <span class="ent">❶</span>, <code>Logout()</code> <span class="ent">❸</span>, and <code>SessionList()</code> <span class="ent">❺</span>. Each method uses the same general flow: create and initialize a request struct, create the response struct, and call the helper function <span class="ent">❷</span><span class="ent">❹</span><span class="ent">❼</span> to send the request and receive the decoded response. The <code>Login()</code> and <code>Logout()</code> methods manipulate the <code>token</code> property. The only significant difference between method logic appears in the <code>SessionList()</code> method, where you define the response as a <code>map[uint32]SessionListRes</code> <span class="ent">❻</span> and loop over that response to flatten the map <span class="ent">❽</span>, setting the <code>ID</code> property on the struct rather than maintaining a map of maps.</p>&#13;
<p class="indent">Remember that the <code>session.list()</code> RPC function requires a valid authentication token, meaning you have to log in before the <code>SessionList()</code> method call will succeed. <a href="ch03.xhtml#ch3list18">Listing 3-18</a> uses the <code>Metasploit</code> receiver struct to access a token, which isn’t a valid value yet—it’s an empty string. Since the code you’re developing here isn’t fully featured, you could just explicitly include a call to your <code>Login()</code> method from within the <code>SessionList()</code> method, but for each additional authenticated method you implement, you’d have to check for the existence of a valid authentication token and make an explicit call to <code>Login()</code>. This isn’t great coding practice because you’d spend a lot of time repeating logic that you could write, say, as part of a bootstrapping process.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>You’ve already implemented a function, <code>New()</code>, designed to be used for bootstrapping, so patch up that function to see what a new implementation looks like when including authentication as part of the process (see <a href="ch03.xhtml#ch3list18">Listing 3-18</a>).</p>&#13;
<pre><span class="gray">func New(host, user, pass string)</span> (*Metasploit, error)<span class="ent">❶</span> <span class="gray">{</span>&#13;
    <span class="gray">msf := &amp;Metasploit{</span>&#13;
        <span class="gray">host: host,</span>&#13;
        <span class="gray">user: user,</span>&#13;
        <span class="gray">pass: pass,</span>&#13;
    <span class="gray">}</span>&#13;
&#13;
    if err := msf.Login()<span class="ent">❷</span>; err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return msf, nil&#13;
<span class="gray">}</span></pre>&#13;
<p class="caption" id="ch3list18"><em>Listing 3-18: Initializing the client with embedding Metasploit login (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go">/ch-3/metasploit-minimal/rpc/msf.go</a><em>)</em></p>&#13;
<p class="indent">The patched-up code now includes an <code>error</code> as part of the return value set <span class="ent">❶</span>. This is to alert on possible authentication failures. Also, added to the logic is an explicit call to the <code>Login()</code> method <span class="ent">❷</span>. As long as the <code>Metasploit</code> struct is instantiated using this <code>New()</code> function, your authenticated method calls will now have access to a valid authentication token.</p>&#13;
<h4 class="h4" id="ch3lev2sec15">Creating a Utility Program</h4>&#13;
<p class="noindent">Nearing the end of this example, your last effort is to create the utility program that implements your shiny new library. Enter the code in <a href="ch03.xhtml#ch3list19">Listing 3-19</a> into <em>client/main.go</em>, run it, and watch the magic happen.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "log"&#13;
&#13;
    "github.com/blackhat-go/bhg/ch-3/metasploit-minimal/rpc"&#13;
)&#13;
&#13;
func main() {&#13;
    host := os.Getenv("MSFHOST")&#13;
    pass := os.Getenv("MSFPASS")&#13;
    user := "msf"&#13;
&#13;
    if host == "" || pass == "" {&#13;
        log.Fatalln("Missing required environment variable MSFHOST or MSFPASS")&#13;
    }&#13;
<span epub:type="pagebreak" id="page_68"/>    msf, err := rpc.New(host, user, pass)<span class="ent">❶</span>&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
 <span class="ent">❷</span> defer msf.Logout()&#13;
&#13;
    sessions, err := msf.SessionList()<span class="ent">❸</span>&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
    fmt.Println("Sessions:")&#13;
 <span class="ent">❹</span> for _, session := range sessions {&#13;
        fmt.Printf("%5d  %s\n", session.ID, session.Info)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch3list19"><em>Listing 3-19: Consuming our <code>msfrpc</code> package (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/client/main.go">/ch-3/metasploit-minimal/client/main.go</a><em>)</em></p>&#13;
<p class="indent">First, bootstrap the RPC client and initialize a new <code>Metasploit</code> struct <span class="ent">❶</span>. Remember, you just updated this function to perform authentication during initialization. Next, ensure you do proper cleanup by issuing a deferred call to the <code>Logout()</code> method <span class="ent">❷</span>. This will run when the <code>main</code> function returns or exits. You then issue a call to the <code>SessionList()</code> method <span class="ent">❸</span> and iterate over that response to list out the available Meterpreter sessions <span class="ent">❹</span>.</p>&#13;
<p class="indent">That was a lot of code, but fortunately, implementing other API calls should be substantially less work since you’ll just be defining request and response types and building the library method to issue the remote call. Here’s sample output produced directly from our client utility, showing one established Meterpreter session:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
Sessions:&#13;
    1 WIN-HOME\jsmith @ WIN-HOME</pre>&#13;
<p class="indent">There you have it. You’ve successfully created a library and client utility to interact with a remote Metasploit instance to retrieve the available Meterpreter sessions. Next, you’ll venture into search engine response scraping and document metadata parsing.</p>&#13;
<h3 class="h3" id="ch3lev1sec4">Parsing Document Metadata with Bing Scraping</h3>&#13;
<p class="noindent">As we stressed in the Shodan section, relatively benign information—when viewed in the correct context—can prove to be critical, increasing the likelihood that your attack against an organization succeeds. Information such as employee names, phone numbers, email addresses, and client software versions are often the most highly regarded because they provide concrete <span epub:type="pagebreak" id="page_69"/>or actionable information that attackers can directly exploit or use to craft attacks that are more effective and highly targeted. One such source of information, popularized by a tool named FOCA, is document metadata.</p>&#13;
<p class="indent">Applications store arbitrary information within the structure of a file saved to disk. In some cases, this can include geographical coordinates, application versions, operating system information, and usernames. Better yet, search engines contain advanced query filters that allow you to retrieve specific files for an organization. The remainder of this chapter focuses on building a tool that <em>scrapes</em>—or as my lawyer calls it, <em>indexes</em>—Bing search results to retrieve a target organization’s Microsoft Office documents, subsequently extracting relevant metadata.</p>&#13;
<h4 class="h4" id="ch3lev2sec16">Setting Up the Environment and Planning</h4>&#13;
<p class="noindent">Before diving into the specifics, we’ll start by stating the objectives. First, you’ll focus solely on Office Open XML documents—those ending in <em>xlsx</em>, <em>docx</em>, <em>pptx</em>, and so on. Although you could certainly include legacy Office data types, the binary formats make them exponentially more complicated, increasing code complexity and reducing readability. The same can be said for working with PDF files. Also, the code you develop won’t handle Bing pagination, instead only parsing initial page search results. We encourage you to build this into your working example and explore file types beyond Open XML.</p>&#13;
<p class="indent">Why not just use the Bing Search APIs for building this, rather than doing HTML scraping? Because you already know how to build clients that interact with structured APIs. There are practical use cases for scraping HTML pages, particularly when no API exists. Rather than rehashing what you already know, we’ll take this as an opportunity to introduce a new method of extracting data. You’ll use an excellent package, <code>goquery</code>, which mimics the functionality of <code>jQuery</code>, a JavaScript library that includes an intuitive syntax to traverse HTML documents and select data within. Start by installing <code>goquery</code>:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/PuerkitoBio/goquery</span></pre>&#13;
<p class="indent">Fortunately, that’s the only prerequisite software needed to complete the development. You’ll use standard Go packages to interact with Open XML files. These files, despite their file type suffix, are ZIP archives that, when extracted, contain XML files. The metadata is stored in two files within the <code>docProps</code> directory of the archive:</p>&#13;
<pre>$ <span class="codestrong1">unzip test.xlsx</span>&#13;
$ <span class="codestrong1">tree</span>&#13;
--<span class="codeitalic1">snip</span>--&#13;
|---docProps&#13;
|   |---app.xml&#13;
|   |---core.xml&#13;
--<span class="codeitalic1">snip</span>—</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>The <em>core.xml</em> file contains the author information as well as modification details. It’s structured as follows:</p>&#13;
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&#13;
&lt;cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata&#13;
/core-properties"&#13;
                   &#13;
                   &#13;
                   &#13;
                   &gt;&#13;
    &lt;dc:creator&gt;Dan Kottmann&lt;/dc:creator&gt;<span class="ent">❶</span>&#13;
    &lt;cp:lastModifiedBy&gt;Dan Kottmann&lt;/cp:lastModifiedBy&gt;<span class="ent">❷</span>&#13;
    &lt;dcterms:created xsi:type="dcterms:W3CDTF"&gt;2016-12-06T18:24:42Z&lt;/dcterms:created&gt;&#13;
    &lt;dcterms:modified xsi:type="dcterms:W3CDTF"&gt;2016-12-06T18:25:32Z&lt;/dcterms:modified&gt;&#13;
&lt;/cp:coreProperties&gt;</pre>&#13;
<p class="indent">The <code>creator</code> <span class="ent">❶</span> and <code>lastModifiedBy</code> <span class="ent">❷</span> elements are of primary interest. These fields contain employee or usernames that you can use in a social-engineering or password-guessing campaign.</p>&#13;
<p class="indent">The <em>app.xml</em> file contains details about the application type and version used to create the Open XML document. Here’s its structure:</p>&#13;
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&#13;
&lt;Properties &#13;
            &gt;&#13;
    &lt;Application&gt;Microsoft Excel&lt;/Application&gt;<span class="ent">❶</span>&#13;
    &lt;DocSecurity&gt;0&lt;/DocSecurity&gt;&#13;
    &lt;ScaleCrop&gt;false&lt;/ScaleCrop&gt;&#13;
    &lt;HeadingPairs&gt;&#13;
        &lt;vt:vector size="2" baseType="variant"&gt;&#13;
            &lt;vt:variant&gt;&#13;
                &lt;vt:lpstr&gt;Worksheets&lt;/vt:lpstr&gt;&#13;
            &lt;/vt:variant&gt;&#13;
            &lt;vt:variant&gt;&#13;
                &lt;vt:i4&gt;1&lt;/vt:i4&gt;&#13;
            &lt;/vt:variant&gt;&#13;
        &lt;/vt:vector&gt;&#13;
    &lt;/HeadingPairs&gt;&#13;
    &lt;TitlesOfParts&gt;&#13;
        &lt;vt:vector size="1" baseType="lpstr"&gt;&#13;
            &lt;vt:lpstr&gt;Sheet1&lt;/vt:lpstr&gt;&#13;
        &lt;/vt:vector&gt;&#13;
    &lt;/TitlesOfParts&gt;&#13;
    &lt;Company&gt;ACME&lt;/Company&gt;<span class="ent">❷</span>&#13;
    &lt;LinksUpToDate&gt;false&lt;/LinksUpToDate&gt;&#13;
    &lt;SharedDoc&gt;false&lt;/SharedDoc&gt;&#13;
    &lt;HyperlinksChanged&gt;false&lt;/HyperlinksChanged&gt;&#13;
    &lt;AppVersion&gt;15.0300&lt;/AppVersion&gt;<span class="ent">❸</span>&#13;
&lt;/Properties&gt;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_71"/>You’re primarily interested in just a few of those elements: <code>Application</code> <span class="ent">❶</span>, <code>Company</code> <span class="ent">❷</span>, and <code>AppVersion</code> <span class="ent">❸</span>. The version itself doesn’t obviously correlate to the Office version name, such as Office 2013, Office 2016, and so on, but a logical mapping does exist between that field and the more readable, commonly known alternative. The code you develop will maintain this mapping.</p>&#13;
<h4 class="h4" id="ch3lev2sec17">Defining the metadata Package</h4>&#13;
<p class="noindent">In <a href="ch03.xhtml#ch3list20">Listing 3-20</a>, define the Go types that correspond to these XML datasets in a new package named <em>metadata</em> and put the code in a file named <em>openxml.go</em>—one type for each XML file you wish to parse. Then add a data mapping and convenience function for determining the recognizable Office version that corresponds to the <code>AppVersion</code>.</p>&#13;
<pre>type OfficeCoreProperty struct {&#13;
    XMLName        xml.Name `xml:"coreProperties"`&#13;
    Creator        string   `xml:"creator"`&#13;
    LastModifiedBy string   `xml:"lastModifiedBy"`&#13;
}&#13;
&#13;
type OfficeAppProperty struct {&#13;
    XMLName     xml.Name `xml:"Properties"`&#13;
    Application string   `xml:"Application"`&#13;
    Company     string   `xml:"Company"`&#13;
    Version     string   `xml:"AppVersion"`&#13;
}&#13;
&#13;
var OfficeVersions<span class="ent">❶</span> = map[string]string{&#13;
    "16": "2016",&#13;
    "15": "2013",&#13;
    "14": "2010",&#13;
    "12": "2007",&#13;
    "11": "2003",&#13;
}&#13;
&#13;
func (a *OfficeAppProperty) GetMajorVersion()<span class="ent">❷</span> string {&#13;
    tokens := strings.Split(a.Version, ".")<span class="ent">❸</span>&#13;
&#13;
    if len(tokens) &lt; 2 {&#13;
        return "Unknown"&#13;
    }&#13;
    v, ok := OfficeVersions<span class="ent">❹</span> [tokens[0]]&#13;
    if !ok {&#13;
        return "Unknown"&#13;
    }&#13;
    return v&#13;
}</pre>&#13;
<p class="caption" id="ch3list20"><em>Listing 3-20: Open XML type definition and version mapping (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/metadata/openxml.go">/ch-3/bing-metadata/metadata/openxml.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_72"/>After you define the <code>OfficeCoreProperty</code> and <code>OfficeAppProperty</code> types, define a map, <code>OfficeVersions</code>, that maintains a relationship of major version numbers to recognizable release years <span class="ent">❶</span>. To use this map, define a method, <code>GetMajorVersion()</code>, on the <code>OfficeAppProperty</code> type <span class="ent">❷</span>. The method splits the XML data’s <code>AppVersion</code> value to retrieve the major version number <span class="ent">❸</span>, subsequently using that value and the <code>OfficeVersions</code> map to retrieve the release year <span class="ent">❹</span>.</p>&#13;
<h4 class="h4" id="ch3lev2sec18">Mapping the Data to Structs</h4>&#13;
<p class="noindent">Now that you’ve built the logic and types to work with and inspect the XML data of interest, you can create the code that reads the appropriate files and assigns the contents to your structs. To do this, define <code>NewProperties()</code> and <code>process()</code> functions, as shown in <a href="ch03.xhtml#ch3list21">Listing 3-21</a>.</p>&#13;
<pre>func NewProperties(r *zip.Reader) (*OfficeCoreProperty, *OfficeAppProperty, error) {<span class="ent">❶</span>&#13;
    var coreProps OfficeCoreProperty&#13;
    var appProps OfficeAppProperty&#13;
&#13;
    for _, f := range r.File {<span class="ent">❷</span>&#13;
        switch f.Name {<span class="ent">❸</span>&#13;
        case "docProps/core.xml":&#13;
            if err := process(f, &amp;coreProps)<span class="ent">❹</span>; err != nil {&#13;
                return nil, nil, err&#13;
            }&#13;
        case "docProps/app.xml":&#13;
            if err := process(f, &amp;appProps)<span class="ent">❺</span>; err != nil {&#13;
                return nil, nil, err&#13;
            }&#13;
        default:&#13;
            continue&#13;
        }&#13;
    }&#13;
    return &amp;coreProps, &amp;appProps, nil&#13;
}&#13;
&#13;
func process(f *zip.File, prop interface{}) error {<span class="ent">❻</span>&#13;
    rc, err := f.Open()&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    defer rc.Close()&#13;
&#13;
    if err := <span class="ent">❼</span>xml.NewDecoder(rc).Decode(&amp;prop); err != nil {&#13;
        return err&#13;
    }&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch3list21"><em>Listing 3-21: Processing Open XML archives and embedded XML documents (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/metadata/openxml.go">/ch-3/bing-metadata/metadata/openxml.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>The <code>NewProperties()</code> function accepts a <code>*zip.Reader</code>, which represents an <code>io.Reader</code> for ZIP archives <span class="ent">❶</span>. Using the <code>zip.Reader</code> instance, iterate through all the files in the archive <span class="ent">❷</span>, checking the filenames <span class="ent">❸</span>. If a filename matches one of the two property filenames, call the <code>process()</code> function <span class="ent">❹</span><span class="ent">❺</span>, passing in the file and the arbitrary structure type you wish to populate—either <code>OfficeCoreProperty</code> or <code>OfficeAppProperty</code>.</p>&#13;
<p class="indent">The <code>process()</code> function accepts two parameters: a <code>*zip.File</code> and an <code>interface{}</code> <span class="ent">❻</span>. Similar to the Metasploit tool you developed, this code accepts a generic <code>interface{}</code> type to allow for the file contents to be assigned into any data type. This increases code reuse because there’s nothing type-specific within the <code>process()</code> function. Within the function, the code reads the contents of the file and unmarshals the XML data into the struct <span class="ent">❼</span>.</p>&#13;
<h4 class="h4" id="ch3lev2sec19">Searching and Receiving Files with Bing</h4>&#13;
<p class="noindent">You now have all the code necessary to open, read, parse, and extract Office Open XML documents, and you know what you need to do with the file. Now, you need to figure out how to search for and retrieve files by using Bing. Here’s the plan of action you should follow:</p>&#13;
<ol>&#13;
<li><p class="noindent">Submit a search request to Bing with proper filters to retrieve targeted results.</p></li>&#13;
<li><p class="noindent">Scrape the HTML response, extracting the HREF (link) data to obtain direct URLs for documents.</p></li>&#13;
<li><p class="noindent">Submit an HTTP request for each direct document URL</p></li>&#13;
<li><p class="noindent">Parse the response body to create a <code>zip.Reader</code></p></li>&#13;
<li><p class="noindent">Pass the <code>zip.Reader</code> into the code you already developed to extract metadata.</p></li>&#13;
</ol>&#13;
<p class="indent">The following sections discuss each of these steps in order.</p>&#13;
<p class="indent">The first order of business is to build a search query template. Much like Google, Bing contains advanced query parameters that you can use to filter search results on numerous variables. Most of these filters are submitted in a <span class="codeitalic">filter_type: value</span> format. Without explaining all the available filter types, let’s instead focus on what helps you achieve your goal. The following list contains the three filters you’ll need. Note that you could use additional filters, but at the time of this writing, they behave somewhat unpredictably.</p>&#13;
<p class="noindentf"><span class="codestrong">site</span> Used to filter the results to a specific domain</p>&#13;
<p class="noindentf"><span class="codestrong">filetype</span> Used to filter the results based off resource file type</p>&#13;
<p class="noindentf"><span class="codestrong">instreamset</span> Used to filter the results to include only certain file extensions</p>&#13;
<p class="indent">An example query to retrieve <em>docx</em> files from <em><a href="http://nytimes.com">nytimes.com</a></em> would look like this:</p>&#13;
<pre>site:nytimes.com &amp;&amp; filetype:docx &amp;&amp; instreamset:(url title):docx</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_74"/>After submitting that query, take a peek at the resulting URL in your browser. It should resemble <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>. Additional parameters may appear after this, but they’re inconsequential for this example, so you can ignore them.</p>&#13;
<p class="indent">Now that you know the URL and parameter format, you can see the HTML response, but first you need to determine where in the Document Object Model (DOM) the document links reside. You can do this by viewing the source code directly, or limit the guesswork and just use your browser’s developer tools. The following image shows the full HTML element path to the desired HREF. You can use the element inspector, as in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>, to quickly select the link to reveal its full path.</p>&#13;
<div class="image"><img src="Images/03fig01.jpg" alt="Image" width="802" height="609"/></div>&#13;
<p class="figcap" id="ch3fig1"><em>Figure 3-1: A browser developer tool showing the full element path</em></p>&#13;
<p class="indent">With that path information, you can use <code>goquery</code> to systematically pull all data elements that match an HTML path. Enough talk! <a href="ch03.xhtml#ch3list22">Listing 3-22</a> puts it all together: retrieving, scraping, parsing, and extracting. Save this code to <em>main.go</em>.</p>&#13;
<pre><span class="ent">❶</span> func handler(i int, s *goquery.Selection) {&#13;
       url, ok := s.Find("a").Attr("href")<span class="ent">❷</span>&#13;
       if !ok {&#13;
           return&#13;
       }&#13;
&#13;
       fmt.Printf("%d: %s\n", i, url)&#13;
       res, err := http.Get(url)<span class="ent">❸</span>&#13;
       if err != nil {&#13;
           return&#13;
       }&#13;
   <span epub:type="pagebreak" id="page_75"/>    buf, err := ioutil.ReadAll(res.Body)<span class="ent">❹</span>&#13;
       if err != nil {&#13;
           return&#13;
       }&#13;
       defer res.Body.Close()&#13;
&#13;
       r, err := zip.NewReader(bytes.NewReader(buf)<span class="ent">❺</span>, int64(len(buf)))&#13;
       if err != nil {&#13;
           return&#13;
       }&#13;
&#13;
       cp, ap, err := metadata.NewProperties(r)<span class="ent">❻</span>&#13;
       if err != nil {&#13;
           return&#13;
       }&#13;
&#13;
       log.Printf(&#13;
           "%25s %25s - %s %s\n",&#13;
           cp.Creator,&#13;
           cp.LastModifiedBy,&#13;
           ap.Application,&#13;
           ap.GetMajorVersion())&#13;
   }&#13;
&#13;
   func main() {&#13;
       if len(os.Args) != 3 {&#13;
           log.Fatalln("Missing required argument. Usage: main.go <span class="codeitalic1">domain ext</span>")&#13;
       }&#13;
       domain := os.Args[1]&#13;
       filetype := os.Args[2]&#13;
&#13;
    <span class="ent">❼</span> q := fmt.Sprintf(&#13;
           "site:%s &amp;&amp; filetype:%s &amp;&amp; instreamset:(url title):%s",&#13;
           domain,&#13;
           filetype,&#13;
           filetype)&#13;
    <span class="ent">❽</span> search := fmt.Sprintf("http://www.bing.com/search?q=%s", url.QueryEscape(q))&#13;
       doc, err := goquery.NewDocument(search)<span class="ent">❾</span>&#13;
       if err != nil {&#13;
           log.Panicln(err)&#13;
       }&#13;
&#13;
       s := "html body div#b_content ol#b_results li.b_algo div.b_title h2"&#13;
    <span class="ent">❿</span> doc.Find(s).Each(handler)&#13;
  }</pre>&#13;
<p class="caption" id="ch3list22"><em>Listing 3-22: Scraping Bing results and parsing document metadata (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/client/main.go">/ch-3/bing-metadata/client/main.go</a><em>)</em></p>&#13;
<p class="indent">You create two functions. The first, <code>handler()</code>, accepts a <code>goquery.Selection</code> instance <span class="ent">❶</span> (in this case, it will be populated with an anchor HTML element) and finds and extracts the <code>href</code> attribute <span class="ent">❷</span>. This attribute contains a direct link to the document returned from the Bing search. Using that URL, the code then issues a GET request to retrieve the document <span class="ent">❸</span>. Assuming no <span epub:type="pagebreak" id="page_76"/>errors occur, you then read the response body <span class="ent">❹</span>, leveraging it to create a <code>zip.Reader</code> <span class="ent">❺</span>. Recall that the function you created earlier in your <code>metadata</code> package, <code>NewProperties()</code>, expects a <code>zip.Reader</code>. Now that you have the appropriate data type, pass it to that function <span class="ent">❻</span>, and properties are populated from the file and printed to your screen.</p>&#13;
<p class="indent">The <code>main()</code> function bootstraps and controls the whole process; you pass it the domain and file type as command line arguments. The function then uses this input data to build the Bing query with the appropriate filters <span class="ent">❼</span>. The filter string is encoded and used to build the full Bing search URL <span class="ent">❽</span>. The search request is sent using the <code>goquery.NewDocument()</code> function, which implicitly makes an HTTP GET request and returns a <code>goquery</code>-friendly representation of the HTML response document <span class="ent">❾</span>. This document can be inspected with <code>goquery</code>. Finally, use the HTML element selector string you identified with your browser developer tools to find and iterate over matching HTML elements <span class="ent">❿</span>. For each matching element, a call is made to your <code>handler()</code> function.</p>&#13;
<p class="indent">A sample run of the code produces output similar to the following:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go nytimes.com docx</span>&#13;
0: http://graphics8.nytimes.com/packages/pdf/2012NAIHSAnnualHIVReport041713.docx&#13;
2020/12/21 11:53:50     Jonathan V. Iralu     Dan Frosch - Microsoft Macintosh Word 2010&#13;
1: http://www.nytimes.com/packages/pdf/business/Announcement.docx&#13;
2020/12/21 11:53:51     agouser               agouser - Microsoft Office Outlook 2007&#13;
2: http://www.nytimes.com/packages/pdf/business/DOCXIndictment.docx&#13;
2020/12/21 11:53:51     AGO                   Gonder, Nanci - Microsoft Office Word 2007&#13;
3: http://www.nytimes.com/packages/pdf/business/BrownIndictment.docx&#13;
2020/12/21 11:53:51     AGO                   Gonder, Nanci - Microsoft Office Word 2007&#13;
4: http://graphics8.nytimes.com/packages/pdf/health/Introduction.docx&#13;
2020/12/21 11:53:51     Oberg, Amanda M       Karen Barrow - Microsoft Macintosh Word 2010</pre>&#13;
<p class="indent">You can now search for and extract document metadata for all Open XML files while targeting a specific domain. I encourage you to expand on this example to include logic to navigate multipage Bing search results, to include other file types beyond Open XML, and to enhance the code to concurrently download the identified files.</p>&#13;
<h3 class="h3" id="ch3lev1sec5">Summary</h3>&#13;
<p class="noindent">This chapter introduced to you fundamental HTTP concepts in Go, which you used to create usable tools that interacted with remote APIs, as well as to scrape arbitrary HTML data. In the next chapter, you’ll continue with the HTTP theme by learning to create servers rather than clients.</p>&#13;
</div>



  </body></html>