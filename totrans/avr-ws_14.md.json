["```\n\n      void initPWM()\n\n      {  // Activate PWM on PB1\n\n      ❶ TCCR1A |= (1 << WGM11);\n\n      TCCR1B |= (1 << WGM12)|(1 << WGM13)|(1 << CS11);\n\n      // Connect PWM to PB1\n\n      ❷ TCCR1A |= (1 << COM1A1); // PWM to OCR1A - PB1\n\n      ❸ ICR1=39999;\n\n      }\n\n```", "```\n\n      // Project 56 - Experimenting with Servos\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      ❶ void initPWM()\n\n      {\n\n      // Activate PWM on PB1\n\n      TCCR1A |= (1 << WGM11);\n\n      TCCR1B |= (1 << WGM12)|(1 << WGM13)|(1 << CS11);\n\n      // Connect PWM to PB1\n\n      TCCR1A |= (1 << COM1A1); // PWM to OCR1A - PB1\n\n      ICR1=39999;\n\n      }\n\n      ❷ void servoRange()\n\n      {\n\n      OCR1A=4799;              // 0 degrees\n\n      _delay_ms(1000);\n\n      OCR1A=1199;              // 180 degrees\n\n      _delay_ms(1000);\n\n      }\n\n      ❸ void servoAngle(uint8_t angle)\n\n      {\n\n      // Rotate servo to 'angle' position\n\n      ❹ OCR1A = ((angle-239.95)/-0.05);\n\n      // Convert angle to OCR1A (duty cycle) value\n\n      }\n\n      int main()\n\n      {\n\n      ❺ DDRB|=(1<<PB1);\n\n      initPWM();\n\n      uint8_t i;\n\n      while(1)\n\n      {\n\n      ❻ servoRange();\n\n      _delay_ms(1000);\n\n      for (i=0; i<=180; i++)\n\n      {\n\n      ❼ servoAngle(i);\n\n      _delay_ms(25);\n\n      }\n\n      for (i=180; i>0; --i)\n\n      {\n\n      ❽ servoAngle(i);\n\n      _delay_ms(5);\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n      // Project 57 - Creating an Analog Thermometer\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #include <stdlib.h>\n\n      #include <math.h>\n\n      void startADC()\n\n      // Set up the ADC\n\n      {\n\n      ADMUX |= (1 << REFS0);                 // Use AVcc pin with ADC\n\n      ADMUX |= (1 << MUX2) | (1 << MUX0);    // Use ADC5 (pin 28)\n\n      ADCSRA |= (1 << ADPS2) |(1 << ADPS1) | (1 << ADPS0);\n\n      // Prescaler for 16MHz (/128)\n\n      ADCSRA |= (1 << ADEN);                 // Enable ADC\n\n      }\n\n      void initPWM()\n\n      {\n\n      // Activate PWM on PB1\n\n      TCCR1A |= (1 << WGM11);\n\n      TCCR1B |= (1 << WGM12)|(1 << WGM13)|(1 << CS11);\n\n      // Connect PWM to PB1\n\n      TCCR1A |= (1 << COM1A1);\n\n      // PWM to OCR1A - PB1\n\n      ICR1=39999;\n\n      }\n\n      void servoAngle(uint8_t angle)\n\n      {\n\n      // Rotate servo to 'angle' position\n\n      OCR1A = ((angle-239.95)/-0.05);\n\n      // Convert angle to OCR1A (duty cycle) value\n\n      }\n\n      int main()\n\n      {\n\n      ❶ DDRB|=(1<<PB1);  // Set PORTB1 as output for servo control\n\n      ❷ DDRC|=(0<<PC5);  // Set PORTC5 as input for TMP36 measurement\n\n      ❸ float temperature;\n\n      float voltage;\n\n      uint16_t ADCvalue;\n\n      uint8_t finalAngle;\n\n      ❹ startADC();\n\n      ❺ initPWM();\n\n      while(1)\n\n      {\n\n      ❻ ADCSRA |= (1 << ADSC);        // Start ADC measurement\n\n      while (ADCSRA & (1 << ADSC)); // Wait for conversion\n\n      _delay_ms(10);\n\n      ❼ ADCvalue = ADC;\n\n      // Convert reading to temperature value (Celsius)\n\n      ❽ voltage = (ADCvalue * 5);\n\n      voltage = voltage / 1024;\n\n      temperature = ((voltage - 0.5) * 100);\n\n      // Display temperature using servo\n\n      ❾ finalAngle = 6 * temperature;\n\n      servoAngle(finalAngle);\n\n      _delay_ms(500);\n\n      }\n\n      }\n\n```", "```\n\n      // Project 58 - Controlling Two Servos\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      ❶ void initPWM()\n\n      {\n\n      // Activate PWM\n\n      TCCR1A |= (1 << WGM11);\n\n      TCCR1B |= (1 << WGM12)|(1 << WGM13)|(1 << CS11);\n\n      // Connect PWM to PB1 and PB2\n\n      ❷ TCCR1A |= (1 << COM1A1)|(1 << COM1B1);\n\n      // PWM to OCR1A - PB1 and OCR1B - PB2\n\n      ICR1=39999;\n\n      }\n\n      ❸ void servoAngleA(uint8_t angle)\n\n      {\n\n      // Rotate servo on OCR1A to 'angle' position\n\n      OCR1A = ((angle-239.95)/-0.05);\n\n      // Convert angle to OCR1A (duty cycle) value\n\n      }\n\n      ❹ void servoAngleB(uint8_t angle)\n\n      // Rotate servo on OCR1B to 'angle' position\n\n      {\n\n      OCR1B = ((angle-239.95)/-0.05);\n\n      // Convert angle to OCR1A (duty cycle) value\n\n      }\n\n      ❺ void servoRange()\n\n      {\n\n      OCR1A=4799;               // 0 degrees\n\n      OCR1B=4799;\n\n      _delay_ms(1000);\n\n      OCR1A=1199;               // 180 degrees\n\n      OCR1B=1199;               // 180 degrees\n\n      _delay_ms(1000);\n\n      }\n\n      int main()\n\n      {\n\n      DDRB|=(1<<PB1)|(1<<PB2);  // Set PB1 and PB2 to outputs\n\n      initPWM();\n\n      uint8_t i;\n\n      while(1)\n\n      {\n\n      servoRange();\n\n      _delay_ms(1000);\n\n      for (i=0; i<=180; i++)\n\n      {\n\n      servoAngleA(i);\n\n      servoAngleB(i);\n\n      _delay_ms(25);\n\n      }\n\n      for (i=180; i>0; --i)\n\n      {\n\n      servoAngleA(i);\n\n      servoAngleB(i);\n\n      _delay_ms(5);\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n      // Project 59 - Building an Analog Clock with Servo Hands\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      // Variables to store time and date\n\n      uint8_t hours, minutes, seconds, dow, dom, mo, years;\n\n      void I2Cenable()\n\n      // Enable I2C bus\n\n      {\n\n      TWBR = 72;           // 100 kHz I2C bus\n\n      TWCR |= (1 << TWEN); // Enable I2C on PORTC4 and 5\n\n      }\n\n      void I2Cwait()\n\n      // Wait until I2C finishes an operation\n\n      {\n\n      // Wait until bit TWINT in TWCR is set to 1\n\n      while (!(TWCR & (1<<TWINT)));\n\n      }\n\n      void I2CstartWait(unsigned char address)\n\n      {\n\n      // Start I2C bus\n\n      uint8_t status;\n\n      while (1)\n\n      {\n\n      // Send START condition\n\n      TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status != 0b00001000) && (status != 0b00010000)) continue;\n\n      // Send device address\n\n      TWDR = address;\n\n      TWCR = (1<<TWINT) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status == 0b00100000 )||(status == 0b01011000))\n\n      {\n\n      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);\n\n      // Wait until stop condition is executed and I2C bus is released\n\n      while(TWCR & (1<<TWSTO));\n\n      continue;\n\n      }\n\n      break;\n\n      }\n\n      }\n\n      void I2Cstop()\n\n      // Stop I2C bus and release GPIO pins\n\n      {\n\n      // Clear interrupt, enable I2C, generate stop condition\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWSTO);\n\n      }\n\n      void I2Cwrite(uint8_t data)\n\n      // Send 'data' to I2C bus\n\n      {\n\n      TWDR = data;\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      }\n\n      uint8_t I2Cread()\n\n      // Read incoming byte of data from I2C bus\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      return TWDR;\n\n      }\n\n      uint8_t I2CreadACK()\n\n      // Read incoming byte of data from I2C bus and ACK signal\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWEA);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      uint8_t decimalToBcd(uint8_t val)\n\n      // Convert integer to BCD\n\n      {\n\n      return((val/10*16)+(val%10));\n\n      }\n\n      uint8_t bcdToDec(uint8_t val)\n\n      // Convert BCD to integer\n\n      {\n\n      return((val/16*10)+(val%16));\n\n      }\n\n      void setTimeDS3231(uint8_t hh, uint8_t mm, uint8_t ss, uint8_t dw,\n\n      uint8_t dd, uint8_t mo, uint8_t yy)\n\n      // Set time on DS3231\n\n      {\n\n      I2CstartWait(0xD0);         // DS3231 write\n\n      I2Cwrite(0x00);             // Start with hours register\n\n      I2Cwrite(decimalToBcd(ss)); // Seconds\n\n      I2Cwrite(decimalToBcd(mm)); // Minutes\n\n      I2Cwrite(decimalToBcd(hh)); // Hours\n\n      I2Cwrite(decimalToBcd(dw)); // Day of week\n\n      I2Cwrite(decimalToBcd(dd)); // Date\n\n      I2Cwrite(decimalToBcd(mo)); // Month\n\n      I2Cwrite(decimalToBcd(yy)); // Year\n\n      I2Cstop();\n\n      }\n\n      void readTimeDS3231()\n\n      // Retrieve time and date from DS3231\n\n      {\n\n      I2CstartWait(0xD0);         // DS3231 write\n\n      I2Cwrite(0x00);             // Seconds register\n\n      I2CstartWait(0xD1);         // DS3231 read\n\n      seconds = bcdToDec(I2CreadACK());\n\n      minutes = bcdToDec(I2CreadACK());\n\n      hours = bcdToDec(I2CreadACK());\n\n      dow = bcdToDec(I2CreadACK());\n\n      dom = bcdToDec(I2CreadACK());\n\n      mo = bcdToDec(I2CreadACK());\n\n      years = bcdToDec(I2CreadACK());\n\n      }\n\n      void initPWM()\n\n      // Activate PWM\n\n      {\n\n      TCCR1A |= (1 << WGM11);\n\n      TCCR1B |= (1 << WGM12)|(1 << WGM13)|(1 << CS11);\n\n      // Connect PWM to PB1 and PB2\n\n      TCCR1A |= (1 << COM1A1)|(1 << COM1B1);\n\n      ICR1=39999;\n\n      }\n\n      void servoAngleA(uint8_t angle)        // Hours servo\n\n      // Rotate servo on OCR1A to 'angle' position\n\n      {\n\n      OCR1A = ((angle-239.95)/-0.05);\n\n      // Convert angle to OCR1A (duty cycle) value\n\n      }\n\n      void servoAngleB(uint8_t angle)        // Minutes servo\n\n      // Rotate servo on OCR1B to 'angle' position\n\n      {\n\n      OCR1B = ((angle-239.95)/-0.05);\n\n      // Convert angle to OCR1A (duty cycle) value\n\n      }\n\n      ❶ void displayServoTime()\n\n      {  // Displays hours on servo A, minutes on servo B\n\n      uint8_t _hours;\n\n      uint8_t _minutes;\n\n      ❷ _hours = hours * 15;\n\n      ❸ servoAngleA(_hours);\n\n      ❹ _minutes = minutes * 3;\n\n      ❺ servoAngleB(_minutes);\n\n      }\n\n      int main()\n\n      {\n\n      DDRB = 0b11111111;                  // Set PORTB as outputs\n\n      I2Cenable();\n\n      initPWM();\n\n      // Uncomment to set time & date, then comment and reflash code\n\n      // setTimeDS3231(9,13,0,5,29,4,21); // h,m,s,dow,dom,m,y\n\n      while(1)\n\n      {\n\n      readTimeDS3231();\n\n      displayServoTime();\n\n      _delay_ms(1000);\n\n      }\n\n      }\n\n```"]