<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch04">
  <div id="header0401" class="chapter">
   <h1 class="cn">
    <span class="page" id="p91">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch04">
     4
    </a>
   </h1>
   <h1 class="ctfm">
    Communicating with the Outside World using the USART
   </h1>
  </div>
  <div class="figure" id="ct04">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   This chapter will teach you to use the
   <i class="calibre5">
    universal synchronous and asynchronous receiver-transmitter (USART)
   </i>
   , a dedicated two-way port that transfers information from the AVR to a computer and allows the two to communicate. The USART lets you control your AVR projects from a computer. It can also help you debug your projects, since you can send status reports from the AVR back to the computer to keep track of the code’s progress.
  </p>
  <p class="calibre8">
   In this chapter you will:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Use terminal emulation software on your computer to act as an input and output device for your AVR-based projects.
   </li>
   <li class="bl">
    • Send serial data between your AVR and your computer.
   </li>
   <li class="bl">
    <span id="p92">
    </span>
    • Transfer data, including numbers and letters, from an AVR to a computer.
   </li>
   <li class="bll">
    • Familiarize yourself with ASCII codes.
   </li>
  </ul>
  <p class="calibre8">
   Along the way, you’ll learn to log temperature readings from a thermometer to a PC for later analysis and build a simple calculator.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah0601">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0601">
     Introducing the USART
    </a>
   </h2>
   <p class="paft">
    There are many ways for computers to communicate with one another. One method is to use
    <i class="calibre5">
     serial data
    </i>
    , the process of sequentially sending data one bit at a time. AVR-based projects do this using the AVR’s USART. The USART on the ATmega328P-PU microcontroller uses pin 2 to receive data and pin 3 to send data. Data is sent and received in
    <i class="calibre5">
     bytes
    </i>
    , where each byte represents 8 bits of data.
   </p>
   <p class="calibre8">
    Instead of sending 1s and 0s, which is how computers represent bytes, their values are represented by changing voltage levels over a certain time period. A high voltage represents a 1, while a low voltage represents a 0. Each byte begins with a start bit, which is always a 0, and an end bit, which is always a 1. The byte of data is sent and received with the rightmost or least significant bit first.
   </p>
   <p class="calibre8">
    I’ll demonstrate what these bytes of data look like with a digital storage oscilloscope, which, as you saw in
    <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
     Chapter 3
    </a>
    , is a device that can display the change in voltage over a period of time. For example, consider
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04001">
     Figure 4-1
    </a>
    , which shows a byte of data representing the number 10 sent from the USART.
   </p>
   <div class="figure" id="f04001">
    <p class="fig">
     <img alt="A screenshot showing a graph of voltage going low and high with the numbers 0010100001 below accordingly" height="680" src="images/nsp-boxall502581-f04001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 4-1:
      </span>
      A byte of data represented on the DSO
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p93">
    </span>
    Let’s see how to translate this into the decimal number 10. The start bit is always 0, so the voltage is first low, then low again (0), then high (1), then low, then high, then low for four periods, followed by high (the end bit, which is always 1). This gives us the binary number 01010000, but because bytes are sent and received with the LSB first, we have to flip it around. This leaves us with 00001010, the binary representation of the decimal number 10.
   </p>
   <p class="calibre8">
    Data is sent and received at various speeds. In
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04001">
     Figure 4-1
    </a>
    , and all our projects in this chapter, the data speed is 4,800bps (bits per second).
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0602">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0602">
     Hardware and Software for USART Communication
    </a>
   </h2>
   <p class="paft">
    To prepare your computer to send and receive data to and from your AVR microcontroller, you’ll need two things: a USB-to-serial converter and suitable terminal software on your computer.
   </p>
   <p class="calibre8">
    Let’s begin with the
    <i class="calibre5">
     USB-to-serial converter
    </i>
    , the easiest way to connect your AVR projects to a computer. There are many different types of these converters, but for this book, I recommend using one built into a cable for convenience. I use a PL2303TA-type USB-to-serial cable, like the one shown in
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04002">
     Figure 4-2
    </a>
    . CP2102 and CP2104 cables are also popular. Install the drivers for your converter cable as instructed by the supplier.
   </p>
   <div class="figure" id="f04002">
    <p class="fig">
     <img alt="Image of a PL2303TA USB-to-serial converter cable" height="860" src="images/nsp-boxall502581-f04002.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 4-2:
      </span>
      A PL2303TA-type USB-to-serial converter cable
     </p>
    </div>
   </div>
   <p class="calibre8">
    To interact with your computer via your AVR-based project, you’ll also need a
    <i class="calibre5">
     terminal emulator
    </i>
    , a simple program that captures and displays incoming data from your AVR and lets you send data from your computer to the AVR. CoolTerm is an excellent terminal emulator by Roger Meier available for various platforms; you can download it from his website at
    <a class="url-i" href="http://freeware.the-meiers.org/">
     http://freeware.the-meiers.org/
    </a>
    . The software is free, but please consider donating via the website to support Meier’s efforts.
   </p>
   <p class="calibre8">
    Once you have downloaded and installed CoolTerm, plug your USB-to-serial converter into your computer, open CoolTerm, and click the
    <b class="calibre4">
     Options
    </b>
    button located at the top of the window. The screen in
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04003">
     Figure 4-3
    </a>
    should appear.
   </p>
   <div class="figure" id="f04003">
    <p class="fig">
     <span id="p94">
     </span>
     <img alt="A screenshot of CoolTerm’s Connection Options window, displaying the Serial Port configuration options. Port is set to COM5, Baudrate to 4800, and Data Bits to 8; the remaining options use the default values." height="1200" src="images/nsp-boxall502581-f04003.jpg" width="1175" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 4-3:
      </span>
      CoolTerm’s Serial Port Options configuration screen
     </p>
    </div>
   </div>
   <p class="calibre8">
    I use Windows in my examples throughout this book, but CoolTerm should look similar when running on other platforms. Change the serial port options settings to match those shown in
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04003">
     Figure 4-3
    </a>
    , except for Port, which will vary depending on your computer—change it to match the name of your USB converter. For example, for Windows PCs, use the drop-down menu beside Port to select the COM port your USB-to-serial converter is using.
   </p>
   <p class="calibre8">
    Next, select the
    <b class="calibre4">
     Terminal
    </b>
    option from the list on the left, change the settings to match those shown in
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04004">
     Figure 4-4
    </a>
    , and click
    <b class="calibre4">
     OK
    </b>
    .
   </p>
   <div class="figure" id="f04004">
    <p class="fig">
     <img alt="A screenshot of CoolTerm’s Connection Options window displaying the terminal options. The Terminal Mode option is set to Line Mode and the other options are the defaults." height="1200" src="images/nsp-boxall502581-f04004.jpg" width="1178" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 4-4:
      </span>
      CoolTerm’s Terminal Options configuration screen
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p95">
    </span>
    Once CoolTerm is configured correctly, the window shown in
    <a class="url" href="nsp-boxall502581-0014.xhtml#f04005">
     Figure 4-5
    </a>
    should appear, indicating CoolTerm is ready for use.
   </p>
   <div class="figure" id="f04005">
    <p class="fig">
     <img alt="A screenshot showing the CoolTerm terminal software ready for use, but not connected to the serial port" height="562" src="images/nsp-boxall502581-f04005.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 4-5:
      </span>
      CoolTerm ready for use
     </p>
    </div>
   </div>
   <p class="calibre8">
    You’re now ready to put your USB-to-serial converter and terminal software to the test.
   </p>
   <p class="hd" id="pro16">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro16">
     <span class="ccust1">
      Project 16: Testing the USART
     </span>
    </a>
   </p>
   <p class="paft">
    In this project you’ll use the USART for the first time, testing your USB-to-serial connection and hardware. This will prepare you for more advanced projects in which you send data from your AVR back to the computer to debug your code and check its progress.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0601">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0601">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • USB-to-serial converter
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Connect the USBasp to your microcontroller via the solderless breadboard, as you have for the previous projects. Next, find the four connections on your USB-to-serial converter: GND, TX, RX, and V
     <sub class="calibre28">
      CC
     </sub>
     (or 5 V). Connect the first three pins to the microcontroller as directed in
     <a class="url" href="nsp-boxall502581-0014.xhtml#tab0401">
      Table 4-1
     </a>
     . If you are using the PL2303TA cable shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04002">
      Figure 4-2
     </a>
     , the white wire is RX and the green wire is TX. If you are using a different model, consult the supplier’s instructions to determine the correct wires.
    </p>
    <table id="tab0401" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="2" class="calibre16">
        <p class="th1">
         <span id="p96">
         </span>
         <span class="calibre4">
          Table 4-1
         </span>
         : USB-to-Serial Converter to Microcontroller Connections
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         USB-to-serial converter pin
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         ATmega328P-PU pin
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         GND
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         8 GND
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         TX
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         2 RX
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         RX
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         3 TX
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="pcon">
     You’ll be using this hardware for the next three projects in this chapter, so keep it intact once you’ve assembled it.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0602">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0602">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 16
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 4
     </i>
     folder, and enter the
     <code class="b">
      make flash
     </code>
     command. The toolchain should compile the program files in the subfolder and then upload the data to the microcontroller.
    </p>
    <p class="calibre8">
     Next, switch over to the terminal software and click the
     <b class="calibre4">
      Connect
     </b>
     button. After a moment, the CoolTerm window should fill with the timeless message
     <code class="calibre23">
      Hello world
     </code>
     , as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04006">
      Figure 4-6
     </a>
     .
    </p>
    <div class="figure" id="f04006">
     <p class="fig">
      <img alt="A screenshot showing the CoolTerm terminal receiving text from the AVR project via the serial-to-USB adaptor. The text “Hello world” is displayed repeatedly on a series of lines, as this is what the project is transmitting." height="631" src="images/nsp-boxall502581-f04006.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-6:
       </span>
       Success! The
       <a class="url" href="nsp-boxall502581-0014.xhtml#pro16">
        Project 16
       </a>
       code prints “Hello world” across the terminal.
      </p>
     </div>
    </div>
    <p class="calibre8">
     To see how this is accomplished, open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 16
     </i>
     subfolder, which contains the following code:
    </p>
    <pre>
     <p class="clf">
      // Project 16 - Testing the USART
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl2">
      <!--<ccust1>1</ccust1>-->
      ❶ #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      <span id="p97">
      </span>
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="cl">
      // Set data type to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="cl">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void USARTSendByte(uint8_t u8Data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2">
      <!--<ccust1>4</ccust1>-->
      ❹ void HelloWorld(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(72);  // H
     </p>
     <p class="cl">
      USARTSendByte(101); // e
     </p>
     <p class="cl">
      USARTSendByte(108); // l
     </p>
     <p class="cl">
      USARTSendByte(108); // l
     </p>
     <p class="cl">
      USARTSendByte(111); // o
     </p>
     <p class="cl">
      USARTSendByte(32);  // space
     </p>
     <p class="cl">
      USARTSendByte(119); // w
     </p>
     <p class="cl">
      USARTSendByte(111); // o
     </p>
     <p class="cl">
      USARTSendByte(114); // r
     </p>
     <p class="cl">
      USARTSendByte(108); // l
     </p>
     <p class="cl">
      USARTSendByte(100); // d
     </p>
     <p class="cl">
      USARTSendByte(32);  // space
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Initialize USART0
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ USARTInit();
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      HelloWorld();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     Before using the USART, you must initialize it and set the data speed (4800bps in this example)
     <!--<ccust1>1</ccust1>-->
     ❶. All the initialization code is inside the
     <code class="calibre23">
      USARTInit()
     </code>
     function
     <!--<ccust1>2</ccust1>-->
     ❷, which needs to be called once during the main loop in the code
     <!--<ccust1>5</ccust1>-->
     ❺.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      USARTSendByte()
     </code>
     function
     <!--<ccust1>3</ccust1>-->
     ❸ sends a byte of data from the USART to your computer. This function waits for the USART to clear old data before sending the new byte of data in the form of an 8-bit integer (the data type
     <code class="calibre23">
      uint8_t
     </code>
     ).
    </p>
    <p class="calibre8">
     Finally, the text “Hello world” is sent using the
     <code class="calibre23">
      HelloWorld()
     </code>
     function
     <!--<ccust1>4</ccust1>-->
     ❹. Notice that instead of directly sending letters, we send numbers that each represent a letter. For reference, I’ve commented in the code which letters each number corresponds to. These numbers are part of
     <i class="calibre5">
      ASCII code
     </i>
     ,
     <span id="p98">
     </span>
     originally devised for sending messages between telegraph and older communications systems. You can find a copy of the ASCII control code chart at
     <a class="url-i" href="https://en.wikipedia.org/wiki/ASCII">
      https://en.wikipedia.org/wiki/ASCII
     </a>
     .
    </p>
    <p class="calibre8">
     You can experiment with this code by changing the text sent to the computer; just substitute your own ASCII codes in the
     <code class="calibre23">
      USARTSendByte()
     </code>
     function calls. Don’t spend too long on this, though, because the
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro17">
      next project
     </a>
     shows you a better way to transmit text.
    </p>
    <p class="calibre8">
     Finally, always click
     <b class="calibre4">
      Disconnect
     </b>
     in CoolTerm when you’ve finished monitoring the USART.
    </p>
    <p class="hd" id="pro17">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro17">
      <span class="ccust1">
       Project 17: Sending Text with the USART
      </span>
     </a>
    </p>
    <p class="paft">
     This project uses the same hardware as
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro16">
      Project 16
     </a>
     . Open a terminal window, navigate to the
     <i class="calibre5">
      Project 17
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 4
     </i>
     folder, and enter the
     <code class="b">
      make flash
     </code>
     command to upload the code from
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro17">
      Project 17
     </a>
     as usual.
    </p>
    <p class="calibre8">
     Next, switch over to the terminal software and click the
     <b class="calibre4">
      Connect
     </b>
     button. After a moment, the screen should once again fill with
     <code class="calibre23">
      Hello, world
     </code>
     —this time in a single column, as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04007">
      Figure 4-7
     </a>
     .
    </p>
    <div class="figure" id="f04007">
     <p class="fig">
      <img alt="A screenshot showing the CoolTerm terminal software displaying the text “Hello, world” repeatedly, once per line" height="631" src="images/nsp-boxall502581-f04007.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-7:
       </span>
       Example result from
       <a class="url" href="nsp-boxall502581-0014.xhtml#pro17">
        Project 17
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     The code for
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro17">
      Project 17
     </a>
     is the same as that for
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro16">
      Project 16
     </a>
     , except that it except it uses a
     <i class="calibre5">
      character array
     </i>
     to simplify the process of sending text. These arrays store one or more characters, which can be letters, numbers, symbols, and anything else you can generate with your keyboard. They are defined as follows:
    </p>
    <pre>
     <p class="cls">
      char i[
      <code class="i1">
       x
      </code>
      ] = ""
     </p>
    </pre>
    <p class="pcon">
     where
     <code class="i1">
      x
     </code>
     is the maximum number of characters that can appear in the array (it’s always a good idea to include this).
    </p>
    <p class="calibre8">
     To see how to transmit text in this way, open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 17
     </i>
     subfolder, which contains the following code:
    </p>
    <pre>
     <p class="clf">
      <span id="p99">
      </span>
      // Project 17 - Sending Text with the USART
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="clf">
      void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="cl">
      // Set data frame format to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="cl">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      void USARTSendByte(unsigned char u8Data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2">
      <!--<ccust1>1</ccust1>-->
      ❶ void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ char z[15] = "Hello, world\r\n"; // Make sure you use " instead of ”
     </p>
     <p class="cl">
      // Initialize USART
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      sendString(z);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     In the main loop, we define a character array with our
     <code class="calibre23">
      Hello, world
     </code>
     message
     <!--<ccust1>2</ccust1>-->
     ❷. The
     <code class="calibre23">
      \r
     </code>
     and
     <code class="calibre23">
      \n
     </code>
     beside that message are
     <i class="calibre5">
      silent control codes
     </i>
     , also known as
     <i class="calibre5">
      escape sequences
     </i>
     , which send information to the terminal software but aren’t themselves displayed.
     <code class="calibre23">
      \r
     </code>
     instructs the software to move the cursor to the start of the line and
     <code class="calibre23">
      \n
     </code>
     instructs it to move the cursor down to the next vertical position; the combination
     <code class="calibre23">
      \r\n
     </code>
     thus moves the cursor to the start of the next line in the terminal display, so that the output is printed in an organized column.
    </p>
    <p class="calibre8">
     <span id="p100">
     </span>
     We use a new function called
     <code class="calibre23">
      sendString()
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶ to read each character of the array we defined and send them to the USART one by one, by looping from zero (the first position of an array is always zero) until there are no more characters. During each iteration of the loop, the AVR sends the current byte in the array to the USART.
    </p>
    <p class="calibre8">
     If you receive an error message after entering your code, such as:
    </p>
    <pre>
     <p class="cls">
      <code class="calibre23">
       main.c:42:2: error: stray '\342' in program
      </code>
     </p>
    </pre>
    <p class="pcon">
     that means you’re using the wrong kind of quotes to define your character array. Make sure you are using straight quotes (
     <code class="calibre23">
      "
     </code>
     ) and not curly quotes (
     <code class="calibre23">
      ”
     </code>
     ). You may need to change the auto-correct settings in your text editor to prevent the incorrect quotes from appearing.
    </p>
    <p class="calibre8">
     In the
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro18">
      next project
     </a>
     , you’ll learn how to send data from the AVR to the terminal software on your computer.
    </p>
    <p class="hd" id="pro18">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro18">
      <span class="ccust1">
       Project 18: Sending Numbers with the USART
      </span>
     </a>
    </p>
    <p class="paft">
     You’ll often need to send numbers between your AVR and your computer. For example, you may want to log data generated by your hardware, send output from an interface you created, or just send simple status reports from your AVR when debugging a project. In this project, you’ll learn how to send both integers and floating-point numbers.
    </p>
    <p class="calibre8">
     This project once again uses the same hardware as
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro16">
      Project 16
     </a>
     . Open a terminal window, navigate to the
     <i class="calibre5">
      Project 18
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 4
     </i>
     folder, and enter the
     <code class="b">
      make flash
     </code>
     command to upload the code as usual.
    </p>
    <p class="calibre8">
     Next, switch over to the terminal software and click the
     <b class="calibre4">
      Connect
     </b>
     button. After a moment the terminal software should display an integer and a floating-point number in turn, as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04008">
      Figure 4-8
     </a>
     .
    </p>
    <div class="figure" id="f04008">
     <p class="fig">
      <img alt="A screenshot of the CoolTerm terminal software displaying the output from Project 18: alternating lines of “Float— -12345.67” and “Integer— -32767.”" height="633" src="images/nsp-boxall502581-f04008.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-8:
       </span>
       Results of
       <a class="url" href="nsp-boxall502581-0014.xhtml#pro18">
        Project 18
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p101">
     </span>
     Now open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 18
     </i>
     subfolder, which contains the following code:
    </p>
    <pre>
     <p class="clf">
      // Project 18 - Sending Numbers with the USART
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdio.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;string.h&gt;
     </p>
     <p class="cl">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="clf">
      void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="clf">
      // Set data frame format to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="clf">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void USARTSendByte(unsigned char u8Data) // Send a byte to the USART
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      char a[10] = "Float - ";
     </p>
     <p class="cl">
      char b[10] = "Integer - ";
     </p>
     <p class="cl">
      char t[10] = "";                      // For our dtostrf test
     </p>
     <p class="cl">
      char newline[4] = "\r\n";
     </p>
     <p class="cl">
      int16_t  i = -32767;
     </p>
     <p class="cl">
      float j = -12345.67;
     </p>
     <p class="clf">
      // Initialize USART
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="cl">
      <span id="p102">
      </span>
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ dtostrf(j,12,2,t);
     </p>
     <p class="cl">
      sendString(a);                     // "Float - "
     </p>
     <p class="cl">
      sendString(t);                     // Send float
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ dtostrf((float)i,12,0,t);
     </p>
     <p class="cl">
      sendString(b);                     // "Integer - "
     </p>
     <p class="cl">
      printf(t);                         // Send integer
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code sends text stored in character arrays to the computer, just like in
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro17">
      Project 17
     </a>
     . However, it includes some incredibly useful new functions. Before we can send floating-point and integer variables to the USART, we need to convert them into character arrays themselves. We do so with the
     <code class="calibre23">
      dtostrf()
     </code>
     function, included by default in AVR C compilers:
    </p>
    <pre>
     <p class="cls">
      dtostrf(float j, w, d, char t[]);
     </p>
    </pre>
    <p class="calibre8">
     This function takes the floating-point number
     <code class="calibre23">
      j
     </code>
     and places it into character array
     <code class="calibre23">
      t[]
     </code>
     . The variable
     <code class="calibre23">
      d
     </code>
     sets the number of decimal places for the fraction, and the variable
     <code class="calibre23">
      w
     </code>
     sets the total number of characters that display the array. We use the
     <code class="calibre23">
      dtostrf()
     </code>
     function in the project code to convert our floating-point variable to a character array before sending it to the USART
     <!--<ccust1>1</ccust1>-->
     ❶. To convert an integer to a character array, we use the same function but place the prefix
     <code class="calibre23">
      (float)
     </code>
     before the integer variable
     <!--<ccust1>2</ccust1>-->
     ❷.
    </p>
    <p class="calibre8">
     In the
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro19">
      next project
     </a>
     , you’ll put your newfound knowledge of converting integers and floats into character arrays to good use by sending thermometer data to your PC.
    </p>
    <p class="hd" id="pro19">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro19">
      <span class="ccust1">
       Project 19: Creating a Temperature Data Logger
      </span>
     </a>
    </p>
    <p class="paft">
     In this project you’ll send readings from the TMP36 temperature sensor you used in
     <a class="url" href="nsp-boxall502581-0013.xhtml#pro15">
      Project 15
     </a>
     in
     <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
      Chapter 3
     </a>
     to your computer. The terminal software will capture the data in a text file, which you can then open in a spreadsheet for further analysis.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0603">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0603">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      <span id="p103">
      </span>
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bll">
      • USB-to-serial converter
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04009">
      Figure 4-9
     </a>
     , then connect your USB-to-serial converter as usual.
    </p>
    <div class="figure" id="f04009">
     <p class="fig">
      <img alt="Schematic diagram for Project 19" height="1084" src="images/nsp-boxall502581-f04009.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-9:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0014.xhtml#pro19">
        Project 19
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 19
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 4
     </i>
     folder, and enter the
     <code class="b">
      make flash
     </code>
     command to upload the code for
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro19">
      Project 19
     </a>
     .
    </p>
    <p class="calibre8">
     Next, switch over to the terminal software and click the
     <b class="calibre4">
      Connect
     </b>
     button. After a moment, the terminal software should begin displaying the ambient temperature as measured by the sensor, as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04010">
      Figure 4-10
     </a>
     .
    </p>
    <div class="figure" id="f04010">
     <p class="fig">
      <span id="p104">
      </span>
      <img alt="A screenshot of Project 19 in operation. Temperature output from the AVR is displayed in CoolTerm and is updated around once per second, varying between 10.80 and 14.60 degrees Celsius." height="779" src="images/nsp-boxall502581-f04010.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-10:
       </span>
       The temperature sensor at work
      </p>
     </div>
    </div>
    <p class="calibre8">
     As you can see, this project combines your existing knowledge of the temperature sensor and sending text and numbers to the terminal software via the USART. To show some variance in the example output, I used a small fan to change the airflow around the temperature sensor. This helped change the measured temperature, which is captured once per second.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0604">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0604">
      The Code
     </a>
    </h3>
    <p class="paft">
     To see how the functions used in this project convert the temperature into an array and send it out, open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 19
     </i>
     subfolder and take a look at the code:
    </p>
    <pre>
     <p class="clf">
      // Project 19 - Creating a Temperature Data Logger
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdio.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void startADC()         // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX =  0b01000101; // Set ADC pin to 28
     </p>
     <p class="cl">
      ADCSRA = 0b10000011; // Set prescaler speed for 1 MHz
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      <span id="p105">
      </span>
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="clf">
      // Set data frame format to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="clf">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void USARTSendByte(unsigned char u8Data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      float temperature;
     </p>
     <p class="cl">
      float voltage;
     </p>
     <p class="cl">
      uint8_t ADCvalue;
     </p>
     <p class="cl">
      char t[10] = "";                  // Will hold temperature for sending via USART
     </p>
     <p class="cl">
      char a[14] = "Temperature: ";     // Make sure you have " instead of ”
     </p>
     <p class="cl">
      char b[14] = " degrees C ";       // Make sure you have " instead of ”
     </p>
     <p class="cl">
      char newline[4] = "\r\n";
     </p>
     <p class="clf">
      DDRD = 0b00000000; // Set PORTD to inputs
     </p>
     <p class="cl">
      startADC();
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Get reading from TMP36 via ADC
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADSC);         // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) ); // Wait until conversion is complete
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="clf">
      <!--<ccust1>2</ccust1>-->
      ❷ // Get value from ADC register, place in ADCvalue
     </p>
     <p class="cl">
      ADCvalue = ADC;
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ // Convert reading to temperature value (Celsius)
     </p>
     <p class="cl">
      voltage = (ADC * 5);
     </p>
     <p class="cl">
      voltage = voltage / 1024;
     </p>
     <p class="cl">
      temperature = ((voltage - 0.5) * 100);
     </p>
     <p class="clf">
      <span id="p106">
      </span>
      <!--<ccust1>4</ccust1>-->
      ❹ // Send temperature to PC via USART
     </p>
     <p class="cl">
      sendString(a);
     </p>
     <p class="cl">
      dtostrf(temperature,6,2,t);
     </p>
     <p class="cl">
      sendString(t);
     </p>
     <p class="cl">
      sendString(b);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     In the code between
     <!--<ccust1>1</ccust1>-->
     ❶ and
     <!--<ccust1>2</ccust1>-->
     ❷ the microcontroller’s ADCs are initialized, then used. Next, we convert the ADC data to a temperature in degrees Celsius
     <!--<ccust1>3</ccust1>-->
     ❸. Finally, we convert the temperature to a character array, which we send to the terminal emulator to create a nice output
     <!--<ccust1>4</ccust1>-->
     ❹. This is repeated once per second.
    </p>
    <p class="calibre8">
     At this point, the terminal emulator software can capture the data received from the microcontroller into a text file, which you can open in a text editor or a spreadsheet for further analysis. To enable this in CoolTerm, select
     <b class="calibre4">
      Connection
     </b>
     ▸
     <b class="calibre4">
      Capture to Text/Binary File
     </b>
     ▸
     <b class="calibre4">
      Start
     </b>
     , as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04011">
      Figure 4-11
     </a>
     .
    </p>
    <div class="figure" id="f04011">
     <p class="fig">
      <img alt="A screenshot showing the CoolTerm software in operation displaying temperature data sent from the project, with the Connection menu open and set to start recording by capturing data to a text file on the PC." height="856" src="images/nsp-boxall502581-f04011.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-11:
       </span>
       Start recording data from the terminal.
      </p>
     </div>
    </div>
    <p class="calibre8">
     CoolTerm then asks you to select a location and name for the text file, as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04012">
      Figure 4-12
     </a>
     . Once you’ve done that, click
     <b class="calibre4">
      Save
     </b>
     , and the recording should start. You can pause and finish recording using the Pause and Stop options, respectively.
    </p>
    <div class="figure" id="f04012">
     <p class="fig">
      <span id="p107">
      </span>
      <img alt="" height="752" src="images/nsp-boxall502581-f04012.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-12:
       </span>
       Select the filename and location to store the text file.
      </p>
     </div>
    </div>
    <p class="calibre8">
     Once you have captured all the temperature data you want, stop the recording in the terminal emulator software (
     <b class="calibre4">
      Connection
     </b>
     ▸
     <b class="calibre4">
      Capture to Text/Binary File
     </b>
     ▸
     <b class="calibre4">
      Stop
     </b>
     ) and open the resulting text file in your spreadsheet software. For demonstration purposes, I’ve used Excel. Because this is a text file, you will be prompted to select a
     <i class="calibre5">
      text delimiter
     </i>
     , a single character to insert between data values to allow other software to easily collate the data. Select a space as your delimiter, as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04013">
      Figure 4-13
     </a>
     . Note that in the screenshot, “Treat consecutive delimiters as one” is selected; this removes duplicate blank columns if there are double spaces in your file.
    </p>
    <div class="figure" id="f04013">
     <p class="fig">
      <img alt="A screenshot showing the Text Import Wizard in Microsoft Excel, with Space selected as the delimiter and the “Treat consecutive delimiters as one” box checked. A preview of the data is provided at the bottom of the screen." height="859" src="images/nsp-boxall502581-f04013.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-13:
       </span>
       Select the delimiter and preview the data.
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p108">
     </span>
     Click
     <b class="calibre4">
      Next
     </b>
     to import the data. This should create a neat temperature data spreadsheet like the one in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04014">
      Figure 4-14
     </a>
     , which you can analyze to your heart’s content.
    </p>
    <div class="figure" id="f04014">
     <p class="fig">
      <img alt="A screenshot of Microsoft Excel showing temperature data on the left in numeric form, and in a line graph on the right" height="796" src="images/nsp-boxall502581-f04014.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 4-14:
       </span>
       Temperature data ready for analysis
      </p>
     </div>
    </div>
    <p class="calibre8">
     Although this project uses temperature data, you can log anything sent from the AVR’s USART using the method demonstrated here. Keep this in mind if you need to record data in future experiments. For now, we’ll turn to our
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro20">
      next project
     </a>
     : sending data from the terminal software on the computer back to the AVR.
    </p>
    <p class="hd" id="pro20">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro20">
      <span class="ccust1">
       Project 20: Receiving Data from Your Computer
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll learn how to use your computer to control your AVR-based projects or make your own input device by sending data between your computer and the microcontroller in both directions via the USART.
    </p>
    <p class="calibre8">
     This project uses the same hardware as
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro16">
      Project 16
     </a>
     . After reproducing that, open a terminal window, navigate to the
     <i class="calibre5">
      Project 20
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 4
     </i>
     folder, and enter the
     <code class="b">
      make flash
     </code>
     command to upload the code for
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro20">
      Project 20
     </a>
     .
    </p>
    <p class="calibre8">
     Next, switch over to the terminal emulation software and click the
     <b class="calibre4">
      Options
     </b>
     button, then select
     <b class="calibre4">
      Terminal
     </b>
     from the list on the left-hand side of the window. Set Terminal Mode to
     <b class="calibre4">
      Raw Mode
     </b>
     , as shown in
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04015">
      Figure 4-15
     </a>
     , then click
     <b class="calibre4">
      OK
     </b>
     , then
     <b class="calibre4">
      Connect
     </b>
     .
    </p>
    <div class="figure" id="f04015">
     <p class="fig">
      <span id="p109">
      </span>
      <img alt="A screenshot of the Connection Options window in CoolTerm, with the Terminal Mode set to Raw Mode" height="1200" src="images/nsp-boxall502581-f04015.jpg" width="1166" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-15:
       </span>
       Changing the terminal emulator back to raw mode
      </p>
     </div>
    </div>
    <p class="calibre8">
     Once you have the terminal emulator in raw mode, type something on your keyboard. Every keystroke you type is sent to the AVR, which then sends it back to the terminal emulator for display. Whatever you type should appear in the terminal window, and the TX and RX indicators should blink.
    </p>
    <p class="calibre8">
     To see how the USART receives your keystrokes and sends them back out, open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 20
     </i>
     subfolder and take a look at the code:
    </p>
    <pre>
     <p class="clf">
      // Project 20 - Receiving Data from Your Computer
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="clf">
      void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="clf">
      <span id="p110">
      </span>
      // Set data frame format to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="clf">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void USARTSendByte(uint8_t sentByte)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = sentByte;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ uint8_t USARTReceiveByte()
     </p>
     <p class="cl">
      // Receives a byte of data from the computer into the USART register
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait for byte from computer
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;RXC0))){};
     </p>
     <p class="cl">
      // Return byte
     </p>
     <p class="cl">
      return UDR0;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t tempByte;
     </p>
     <p class="cl">
      // Initialize USART0
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Receive data from PC via USART
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ tempByte = USARTReceiveByte();
     </p>
     <p class="clf">
      // Send same data back to PC via USART
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ USARTSendByte(tempByte);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code should be quite familiar to you now; it begins with the usual functions to initialize the USART and send bytes to the computer. However, it includes a new function called
     <code class="calibre23">
      USARTReceiveByte()
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶, which waits for a byte of data to arrive at the USART, then places that data into an integer variable. In this case, the function places the incoming byte into the variable
     <code class="calibre23">
      tempByte
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷. The
     <code class="calibre23">
      USARTSendByte()
     </code>
     function then sends the same byte of data back to the terminal emulator
     <!--<ccust1>3</ccust1>-->
     ❸. It’s as simple as that: a byte comes in and is sent back out.
    </p>
    <p class="hd" id="pro21">
     <span class="page" id="p111">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro21">
      <span class="ccust1">
       Project 21: Building a Four-Function Calculator
      </span>
     </a>
    </p>
    <p class="paft">
     By now, you’ve learned to send and receive data between your AVR projects and a computer so that your projects can work with external data and commands. In this project you’ll use all the knowledge you’ve acquired in this and previous chapters to make a simple four-function calculator.
    </p>
    <p class="calibre8">
     As in the previous projects in this chapter, you’ll use the basic AVR and USB-to-serial converter. After reproducing that setup, open a terminal window, navigate to the
     <i class="calibre5">
      Project 21
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 4
     </i>
     folder, and enter the
     <code class="b">
      make flash
     </code>
     command to upload this project’s code. When you flash the microcontroller with the code, you might receive a warning such as:
    </p>
    <pre>
     <p class="cls">
      warning: 'answer' may be used uninitialized in this function
     </p>
    </pre>
    <p class="calibre8">
     That’s okay, you can just continue as normal.
    </p>
    <p class="calibre8">
     Next, open the terminal emulator, make sure the terminal mode is set to raw mode as in
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro20">
      Project 20
     </a>
     , then click
     <b class="calibre4">
      Connect
     </b>
     . After a moment, the calculator interface should appear in the terminal window, and you should be prompted to enter a command. This calculator can add, subtract, multiply, and divide single-digit numbers.
     <a class="url" href="nsp-boxall502581-0014.xhtml#f04016">
      Figure 4-16
     </a>
     shows some examples; have fun and enter your own commands to see the results.
    </p>
    <div class="figure" id="f04016">
     <p class="fig">
      <img alt="A screenshot of CoolTerm showing the output of Project 21 in use. The output is examples of the user making calculations with all four operators." height="841" src="images/nsp-boxall502581-f04016.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 4-16:
       </span>
       The calculator at work
      </p>
     </div>
    </div>
    <p class="calibre8">
     Open the
     <i class="calibre5">
      main.c
     </i>
     file in the
     <i class="calibre5">
      Project 21
     </i>
     subfolder. The code is just a sequence of events using functions from previous projects.
    </p>
    <pre>
     <p class="clf">
      <span id="p112">
      </span>
      // Project 21 - Building a Four-Function Calculator
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdio.h&gt;
     </p>
     <p class="cl">
      #include &lt;string.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="clf">
      void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="cl">
      // Set data frame format to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="clf">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void USARTSendByte(uint8_t sentByte)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = sentByte;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t USARTReceiveByte()
     </p>
     <p class="cl">
      // Receives a byte of data from the computer into the USART register
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait for byte from computer
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;RXC0))){};
     </p>
     <p class="cl">
      // Return byte
     </p>
     <p class="cl">
      return UDR0;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t digit1;
     </p>
     <p class="cl">
      <span id="p113">
      </span>
      uint8_t digit2;
     </p>
     <p class="cl">
      uint8_t operator;
     </p>
     <p class="cl">
      float answer=0;
     </p>
     <p class="cl">
      float d1=0;
     </p>
     <p class="cl">
      float d2=0;
     </p>
     <p class="clf">
      <!--<ccust1>1</ccust1>-->
      ❶ char a[26] = "Enter command (e.g. 5*2) ";
     </p>
     <p class="cl">
      char b[11] = "Answer is ";
     </p>
     <p class="cl">
      char answerString[20] = ""; // Holds answer
     </p>
     <p class="cl">
      char newline[4] = "\r\n";
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      sendString(a);
     </p>
     <p class="clf">
      <!--<ccust1>2</ccust1>-->
      ❷ digit1 = USARTReceiveByte();
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ USARTSendByte(digit1);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ switch (digit1)          // Convert ASCII code of digit1 to actual number
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 48 : digit1 = 0; break;
     </p>
     <p class="cl">
      case 49 : digit1 = 1; break;
     </p>
     <p class="cl">
      case 50 : digit1 = 2; break;
     </p>
     <p class="cl">
      case 51 : digit1 = 3; break;
     </p>
     <p class="cl">
      case 52 : digit1 = 4; break;
     </p>
     <p class="cl">
      case 53 : digit1 = 5; break;
     </p>
     <p class="cl">
      case 54 : digit1 = 6; break;
     </p>
     <p class="cl">
      case 55 : digit1 = 7; break;
     </p>
     <p class="cl">
      case 56 : digit1 = 8; break;
     </p>
     <p class="cl">
      case 57 : digit1 = 9; break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ operator = USARTReceiveByte();
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ USARTSendByte(operator);
     </p>
     <p class="clf">
      <!--<ccust1>7</ccust1>-->
      ❼ digit2 = USARTReceiveByte();
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ USARTSendByte(digit2);
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ switch (digit2)          // Convert ASCII code of digit2 to actual number
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 48 : digit2 = 0; break;
     </p>
     <p class="cl">
      case 49 : digit2 = 1; break;
     </p>
     <p class="cl">
      case 50 : digit2 = 2; break;
     </p>
     <p class="cl">
      case 51 : digit2 = 3; break;
     </p>
     <p class="cl">
      case 52 : digit2 = 4; break;
     </p>
     <p class="cl">
      case 53 : digit2 = 5; break;
     </p>
     <p class="cl">
      case 54 : digit2 = 6; break;
     </p>
     <p class="cl">
      case 55 : digit2 = 7; break;
     </p>
     <p class="cl">
      case 56 : digit2 = 8; break;
     </p>
     <p class="cl">
      case 57 : digit2 = 9; break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="clf">
      // Convert entered numbers into float variables
     </p>
     <p class="cl">
      d1 = digit1;
     </p>
     <p class="cl">
      <span id="p114">
      </span>
      d2 = digit2;
     </p>
     <p class="clf">
      // Calculate result
     </p>
     <p class="cl">
      switch (operator)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 43 : answer = d1 + d2; break; // Add
     </p>
     <p class="cl">
      case 45 : answer = d1 - d2; break; // Subtract
     </p>
     <p class="cl">
      case 42 : answer = d1 * d2; break; // Multiply
     </p>
     <p class="cl">
      case 47 : answer = d1 / d2; break; // Divide
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      // Send result to PC via USART
     </p>
     <p class="cl">
      <!--<ccust1>0</ccust1>-->
      ⓿ sendString(b);
     </p>
     <p class="cl">
      dtostrf(answer,6,2,answerString);
     </p>
     <p class="cl">
      sendString(answerString);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     In this code, we first initialize the variables inside the
     <code class="calibre23">
      main()
     </code>
     function, then initialize the USART with the lines beginning at
     <!--<ccust1>1</ccust1>-->
     ❶. The program prompts the user to enter a command consisting of 3 bytes of data: the first digit, the operator, and then the second digit. The USART receives the first digit
     <!--<ccust1>2</ccust1>-->
     ❷, the operator
     <!--<ccust1>5</ccust1>-->
     ❺, and the second digit
     <!--<ccust1>7</ccust1>-->
     ❼ and sends them back to the terminal to give visual feedback at
     <!--<ccust1>3</ccust1>-->
     ❸,
     <!--<ccust1>6</ccust1>-->
     ❻, and
     <!--<ccust1>8</ccust1>-->
     ❽, respectively.
    </p>
    <p class="calibre8">
     When the user enters a digit, the terminal emulator sends the ASCII code for the digit, not the digit itself, to the AVR. The program then converts the ASCII code into the actual digit
     <!--<ccust1>4</ccust1>-->
     ❹ and places it in an integer variable
     <!--<ccust1>9</ccust1>-->
     ❾. This same process for converting ASCII codes to digits also determines which operator has been entered (for example,
     <code class="calibre23">
      +
     </code>
     ,
     <code class="calibre23">
      -
     </code>
     ,
     <code class="calibre23">
      *
     </code>
     , or
     <code class="calibre23">
      /
     </code>
     ).
    </p>
    <p class="calibre8">
     The program then performs the required calculation on the two digits via the functions in the code’s last
     <code class="calibre23">
      switch()
     </code>
     function. Finally, the calculation’s result is converted to a character array and sent back to the terminal emulator with
     <code class="calibre23">
      sendString(b)
     </code>
     for the user to read
     <!--<ccust1>0</ccust1>-->
     ⓿. The calculator is now ready for another calculation.
    </p>
    <p class="calibre8">
     The projects in this chapter showed you how to use your computer as a terminal with your AVR to send and receive data, preparing you to record and analyze data. In the
     <a class="url" href="nsp-boxall502581-0015.xhtml#ch05">
      next chapter
     </a>
     I’ll show you how to use interrupts, a neat way to let your AVR to respond to input whenever it occurs, instead of at a planned moment in time.
    </p>
   </div>
  </div>
 </div>
</div></body></html>