["```\n// Start the clock\nvar clock = Stopwatch.StartNew();\n// Run the code to be measured\nvar result = SomeTask();\n// Stop the clock, and record elapsed time\nclock.Stop();\nvar millisecs = clock.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n```", "```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = (r, g, b);\n    public int Red {get;}\n    public int Green {get;}\n    public int Blue {get;}\n}\n```", "```\nvar rng = new Random(1);\nvar items = Enumerable.Range(0, 25000)\n    .Select(_ => rng.Next())\n    .Select(r => new Color(r >> 16 & 0xFF, r >> 8 & 0xFF, r & 0xFF))\n    .ToHashSet();\n```", "```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = **((byte)r, (byte)g, (byte)b)**;\n public **byte** Red {get;}\n    public **byte** Green {get;}\n    public **byte** Blue {get;}\n}\n```", "```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = ((byte)r, (byte)g, (byte)b);\n    public byte Red {get;}\n    public byte Green {get;}\n    public byte Blue {get;}\n    **public override bool Equals(object? obj)**\n        **=>** **obj is Color other &&**\n           **Red** **==** **other.Red && Green** **==** **other.Green && Blue** **==** **other.Blue;**\n}\n```", "```\npublic override bool Equals(object? obj)\n    => obj is Color other &&\n       Red == other.Red && Green == other.Green && Blue == other.Blue;\npublic override int GetHashCode()\n    => HashCode.Combine(Red, Green, Blue);\n```", "```\npublic readonly struct Purchase\n{\n    public Purchase(Product item, DateTime ordered, int quantity)\n        => (Item, Ordered, Quantity) = (item, ordered, quantity);\n    **public Product   Item {get;}**\n    public DateTime  Ordered {get;}\n    public int       Quantity {get;}\n    public override bool Equals(object? obj)\n        => obj is Purchase other &&\n           Item.Equals(other.Item) &&\n           Ordered == other.Ordered && Quantity == other.Quantity;\n    public override int GetHashCode()\n        => HashCode.Combine(Item, Ordered, Quantity);\n}\n```", "```\npublic readonly struct Product\n{\n    public Product(int id, decimal price, string name)\n        => (Id, Price, Name) = (id, price, name);\n    public int     Id {get;}\n    public decimal Price {get;}\n    public string  Name {get;}\n    public override bool Equals(object? obj)\n        => obj is Product other &&\n           Id == other.Id && Price == other.Price && Name == other.Name;\n    public override int GetHashCode()\n        => HashCode.Combine(Id, Price, Name);\n}\n```", "```\nvar items = Enumerable.Range(0, 10_000_000)\n    .Select(id => new Purchase(new Product(id, id, \"Some Description\"),\n                               DateTime.MinValue, id))\n    .ToList();\nAssert.That(items.SequenceEqual(items), Is.True);\n```", "```\npublic readonly struct Purchase : IEquatable<Purchase>\n{\n    `--snip--`\n    public bool Equals(Purchase other)\n        => Item.Equals(other.Item) &&\n           Ordered == other.Ordered && Quantity == other.Quantity;\n    public override bool Equals(object? obj)\n        => obj is Purchase other && Equals(other);\n}\n```", "```\npublic readonly struct Product : IEquatable<Product>\n{\n    `--snip--`\n    public bool Equals(Product other)\n        => Id == other.Id && Price == other.Price && Name == other.Name;\n    public override bool Equals(object? obj)\n        => obj is Product other && Equals(other);\n}\n```", "```\npublic readonly struct Purchase : IEquatable<Purchase>\n{\n    public Purchase(Product item, DateTime ordered, int quantity)\n        => (this.item, this.ordered, this.quantity) = (item, ordered, quantity);\n    public Product  Item => item;\n    public DateTime Ordered => ordered;\n    public int      Quantity => quantity;\n    public bool Equals(Purchase other)\n        => item.Equals(other.item) &&\n           **ordered** **==** **other.ordered && quantity** **==** **other.quantity;**\n    public override bool Equals(object? obj)\n        => obj is Purchase other && Equals(other);\n    public override int GetHashCode()\n        => HashCode.Combine(item, ordered, quantity);\n    **private readonly Product item;**\n    **private readonly DateTime ordered;**\n    **private readonly int quantity;**\n}\n```", "```\npublic readonly struct Purchase : IEquatable<Purchase>\n{\n    `--snip--`\n    public bool Equals(Purchase other)\n        => item == other.item &&\n           ordered == other.ordered && quantity == other.quantity;\n    public static bool operator==(Purchase left, Purchase right)\n        => left.Equals(right);\n    public static bool operator!=(Purchase left, Purchase right)\n        => !left.Equals(right);\n}\n```", "```\npublic sealed class EqualsOperatorComparer : IEqualityComparer<Purchase>\n{\n    **public bool Equals(Purchase x, Purchase y)**\n        **=>** **x** **==** **y;**\n    public int GetHashCode(Purchase obj)\n        => obj.GetHashCode();\n}\nvar items = Enumerable.Range(0, 10_000_000)\n    .Select(MakePurchase)\n    .ToList();\nAssert.That(items.SequenceEqual(items, **new EqualsOperatorComparer()**));\n```", "```\npublic readonly struct Purchase : IEquatable<Purchase>\n{\n    `--snip--`\n    **public bool Equals(in Purchase other)**\n        **=>** **item** **==** **other.item &&**\n           **ordered** **==** **other.ordered && quantity** **==** **other.quantity;**\n    public bool Equals(Purchase other)\n        => Equals(in other);\n    public static bool operator==(**in Purchase left, in Purchase right**)\n        => **left.Equals(in right);**\n    public static bool operator!=(in Purchase left, in Purchase right)\n        => !left.Equals(in right);\n}\n```", "```\npublic readonly struct IntField : IEquatable<IntField>\n{\n    public IntField(int value)\n        => this.value = value;\n    public bool Equals(IntField other)\n        => value == other.value;\n    private readonly int value;\n}\n```", "```\nvar items = Enumerable.Range(0, 10_000_000)\n    .Select(i => new IntField(i))\n    .ToList();\nAssert.That(items.SequenceEqual(items));\n```", "```\npublic readonly struct IntPlus3x16 : IEquatable<IntPlus3x16>\n{\n    public IntPlus3x16(int value)\n        => this.value = value;\n    public bool Equals(IntPlus3x16 other)\n        => value == other.value;\n    private readonly int value;\n    **private readonly Guid _padding1** **=** **Guid.Empty;**\n    **private readonly Guid _padding2** **=** **Guid.Empty;**\n    **private readonly Guid _padding3** **=** **Guid.Empty;**\n}\n```", "```\npublic readonly record struct Product\n    (int Id, decimal Price, string Name);\npublic readonly record struct Purchase\n    (Product Item, DateTime Ordered, int Quantity);\n```", "```\nprivate static Purchase MakePurchase(int id)\n    => new Purchase(new Product(id, id, \"Some Description\"),\n        DateTime.MinValue, id);\npublic static void CompareSequences(int count)\n{\n    var items = Enumerable.Range(0, count)\n        **.Select(MakePurchase)**\n        .ToList();\n    Assert.That(items.SequenceEqual(items));\n}\n```", "```\npublic sealed record Product\n    (int Id, decimal Price, string Name);\n```", "```\nprivate static readonly List<Product> SharedProducts = new()\n{\n    new Product(0, 0, \"Some Description\"),\n    new Product(1, 1, \"Some Description\"),\n    new Product(2, 2, \"Some Description\"),\n    new Product(3, 3, \"Some Description\"),\n    new Product(4, 4, \"Some Description\"),\n};\nprivate static Purchase MakePurchase(int id)\n{\n    **var component** **=** **SharedProducts[id % SharedProducts.Count];**\n    return new Purchase(component, DateTime.MinValue, id);\n}\n```", "```\npublic bool Equals(Purchase other)\n    => EqualityComparer<Product>.Default.Equals(_Item_field, other._Item_field) &&\n       EqualityComparer<DateTime>.Default.Equals(_Ordered_field, other._Ordered_field) &&\n       EqualityComparer<int>.Default.Equals(_Quantity_field, other._Quantity_field);\n```", "```\npublic readonly record struct Purchase\n{\n    public Purchase(Product item, DateTime ordered, int quantity)\n        => (this.item, this.ordered, this.quantity) =\n              (item, ordered, quantity);\n    `--snip--`\n    public bool Equals(Purchase other)\n        => item.Equals(other.item) &&\n           ordered.Equals(other.ordered) && quantity == other.quantity;\n    private readonly Product item;\n    private readonly DateTime ordered;\n    private readonly int quantity;\n}\n```", "```\nprivate static Purchase MakePurchase(int id)\n    => new Purchase(new Product(id, id, \"Some Description\"),\n        DateTime.MinValue, id);\nvar items = Enumerable.Range(0, count)\n    .Select(i => MakePurchase(i))\n    .ToList();\n```", "```\nvar query = from i in Enumerable.Range(0, count)\n            select MakePurchase(i);\nvar items = query.ToList();\n```", "```\nvar items = Enumerable.Range(0, count)\n    .Select(MakePurchase)\n    .ToList();\n```", "```\npublic static List<Purchase> ToList(int count)\n{\n    var items = new List<Purchase>();\n    foreach(var i in Enumerable.Range(0, count))\n    {\n        items.Add(MakePurchase(i));\n    }\n    return items;\n}\n```", "```\nvar items = new List<Purchase>(count);\n```", "```\npublic static List<Purchase> ToList(int count)\n{\n    var items = new List<Purchase>(count);\n    for(int i = 0; i != count; ++i)\n    {\n        items.Add(MakePurchase(i));\n    }\n    return items;\n}\n```", "```\nprivate const double ZeroKelvin = -273.15;\nprivate Temperature(double celsius)\n    => amount = celsius switch\n    {\n        double.NaN\n            => throw new ArgumentException(`--snip--`),\n        < ZeroKelvin or double.PositiveInfinity\n            => throw new ArgumentOutOfRangeException(`--snip--`),\n        _ => celsius\n    };\n```", "```\nprivate Temperature(double celsius)\n{\n    if(celsius is double.NaN)\n    {\n        throw new ArgumentException(`--snip--`);\n    }\n    else if(celsius < ZeroKelvin || celsius is double.PositiveInfinity)\n    {\n        throw new ArgumentOutOfRangeException(`--snip--`);\n    }\n    else\n    {\n        this.amount = celsius;\n    }\n}\n```", "```\nswitch (celsius)\n{\n    case double.NaN:\n         throw new ArgumentException(`--snip--`);\n    case < ZeroKelvin:\n    case double.PositiveInfinity:\n         throw new ArgumentOutOfRangeException(`--snip--`);\n    default:\n         this.amount = celsius;\n         break;\n}\n```"]