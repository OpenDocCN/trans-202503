- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Applying Evasive Techniques and Rate Limit Testing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用规避技术和速率限制测试
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll cover techniques for evading or bypassing common API
    security controls. Then we’ll apply these evasion techniques to test and bypass
    rate limiting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍绕过或规避常见 API 安全控制的技术。然后，我们将应用这些规避技术来测试和绕过速率限制。
- en: When testing almost any API, you’ll encounter security controls that hinder
    your progress. These could be in the form of a WAF that scans your requests for
    common attacks, input validation that restricts the type of input you send, or
    a rate limit that restricts how many requests you can make.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试几乎任何 API 时，你都会遇到一些安全控制措施，它们会妨碍你的进度。这些控制可能表现为扫描你请求的 WAF（Web 应用防火墙），对你发送的输入进行验证的输入验证，或者限制你能发送请求数量的速率限制。
- en: Because REST APIs are stateless, API providers must find ways to effectively
    attribute the origin of requests, and they’ll use some detail about that attribution
    to block your attacks. As you’ll soon see, if we can discover those details, we
    can often trick the API.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 REST API 是无状态的，API 提供商必须找到有效的方式来追踪请求的来源，并利用这些细节来阻止攻击。正如你将很快看到的，如果我们能发现这些细节，我们通常可以欺骗
    API。
- en: Evading API Security Controls
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过 API 安全控制
- en: Some of the environments you’ll come across might have web application firewalls
    (WAFs) and “artificially intelligent” Skynet machines monitoring the network traffic,
    prepared to block every anomalous request you send their way. WAFs are the most
    common security control in place to protect APIs. A WAF is essentially software
    that inspects API requests for malicious activity. It measures all traffic against
    a certain threshold and then takes action if it finds anything abnormal. If you
    notice that a WAF is present, you can take preventative measures to avoid being
    blocked from interacting with your target.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的一些环境中会有 Web 应用防火墙（WAF）和“人工智能” Skynet 机器监控网络流量，准备阻止你发送的任何异常请求。WAF 是最常见的
    API 安全控制，旨在保护 API 免受攻击。WAF 本质上是一种软件，用于检查 API 请求中的恶意活动。它会衡量所有流量是否超过某个阈值，如果发现任何异常，就会采取行动。如果你注意到存在
    WAF，你可以采取预防措施，以避免在与目标交互时被阻止。
- en: How Security Controls Work
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全控制是如何工作的
- en: 'Security controls may differ from one API provider to the next, but at a high
    level, they will have some threshold for malicious activity that will trigger
    a response. WAFs, for example, can be triggered by a wide variety of things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全控制可能因 API 提供商的不同而有所不同，但从大体上看，它们会设置某个恶意活动的阈值，一旦超出该阈值就会触发反应。例如，WAF 就能通过多种方式触发：
- en: Too many requests for resources that do not exist
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对不存在的资源发送过多请求
- en: Too many requests within a small amount of time
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在短时间内发送过多请求
- en: Common attack attempts such as SQL injection and XSS attacks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的攻击尝试，如 SQL 注入和 XSS 攻击
- en: Abnormal behavior such as tests for authorization vulnerabilities
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常行为，如授权漏洞测试
- en: 'Let’s say that a WAF’s threshold for each of these categories is three requests.
    On the fourth malicious-seeming request, the WAF will have some sort of response,
    whether this means sending you a warning, alerting API defenders, monitoring your
    activity with more scrutiny, or simply blocking you. For example, if a WAF is
    present and doing its job, common attacks like the following injection attempts
    will trigger a response:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某个 WAF 对每一类请求的阈值是三次请求。在第四次看似恶意的请求时，WAF 会作出某种反应，无论是发送警告，通知 API 防守人员，监控你的活动，还是直接阻止你。例如，如果存在
    WAF 并且它正常工作，像以下的常见攻击尝试（如注入攻击）将会触发反应：
- en: '`'' OR 1=1`'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`'' OR 1=1`'
- en: '`admin''`'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`admin''`'
- en: '`<script>alert(''XSS'')</script>`'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<script>alert(''XSS'')</script>`'
- en: The question is, How can the API provider’s security controls block you when
    it detects these? These controls must have some way of determining who you are.
    *Attribution* is the use of some information to uniquely identify an attacker
    and their requests. Remember that RESTful APIs are stateless, so any information
    used for attribution must be contained within the request. This information commonly
    includes your IP address, origin headers, authorization tokens, and metadata.
    *Metadata* is information extrapolated by the API defenders, such as patterns
    of requests, the rate of request, and the combination of the headers included
    in requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，当API提供商的安全控制检测到这些信息时，它们如何阻止你？这些控制必须有某种方式来确定你是谁。*归属*是使用一些信息来唯一地识别攻击者及其请求。记住，RESTful
    API是无状态的，所以任何用于归属的信息必须包含在请求中。这些信息通常包括你的IP地址、来源头部、授权令牌和元数据。*元数据*是由API防御者推断出的信息，例如请求的模式、请求的频率以及请求中头部的组合。
- en: Of course, more advanced products could block you based on pattern recognition
    and anomalous behavior. For example, if 99 percent of an API’s user base performs
    requests in certain ways, the API provider could use a technology that develops
    a baseline of expected behavior and then blocks any unusual requests. However,
    some API providers won’t be comfortable using these tools, as they risk blocking
    a potential customer who deviates from the norm. There is often a tug-of-war between
    convenience and security.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，更高级的产品可能会基于模式识别和异常行为来阻止你。例如，如果99%的API用户按照特定方式发起请求，API提供商可以使用一种技术来建立预期行为的基准，然后阻止任何异常请求。然而，一些API提供商可能不愿使用这些工具，因为它们有可能阻止那些偏离常规的潜在客户。在便利性和安全性之间，常常会存在拉锯战。
- en: API Security Control Detection
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API安全控制检测
- en: 'The easiest way to detect API security controls is to attack the API with guns
    blazing. If you throw the kitchen sink at it by scanning, fuzzing, and sending
    it malicious requests, you will quickly find out whether security controls will
    hinder your testing. The only problem with this approach is that you might learn
    only one thing: that you’ve been blocked from making any further requests to the
    host.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 检测API安全控制的最简单方法就是采用攻击性策略。如果你通过扫描、模糊测试和发送恶意请求来猛攻API，你很快就能发现安全控制是否会妨碍你的测试。这个方法唯一的问题是，你可能只能学到一件事：那就是你被阻止了，无法再向主机发送任何请求。
- en: Instead of the attack-first, ask-questions-later approach, I recommend you first
    use the API as it was intended. That way, you should have a chance to understand
    the app’s functionality before getting into trouble. You could, for example, review
    documentation or build out a collection of valid requests and then map out the
    API as a valid user. You could also use this time to review the API responses
    for evidence of a WAF. WAFs often will include headers with their responses.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐你在采取攻击性策略之前，首先按照API设计的方式使用它。这样，你应该有机会在遇到麻烦之前理解应用程序的功能。你可以，例如，查看文档或构建一个有效请求的集合，然后以有效用户的身份绘制API地图。你还可以利用这个时间来检查API响应，以寻找WAF的迹象。WAF的响应中通常会包含相关的头部信息。
- en: 'Also pay attention to headers such as `X-CDN` in the request or response, which
    mean that the API is leveraging a *content delivery network (CDN)*. CDNs provide
    a way to reduce latency globally by caching the API provider’s requests. In addition
    to this, CDNs will often provide WAFs as a service. API providers that proxy their
    traffic through CDNs will often include headers such as these:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意请求或响应中的诸如`X-CDN`之类的头部信息，它们表示API正在利用*内容分发网络（CDN）*。CDN通过缓存API提供商的请求，在全球范围内减少延迟。除此之外，CDN通常还会提供WAF服务。通过CDN代理流量的API提供商通常会包括类似的头部信息：
- en: '`X-CDN: Imperva`'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-CDN: Imperva`'
- en: '`X-CDN: Served-By-Zenedge`'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-CDN: Served-By-Zenedge`'
- en: '`X-CDN: fastly`'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-CDN: fastly`'
- en: '`X-CDN: akamai`'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-CDN: akamai`'
- en: '`X-CDN: Incapsula`'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-CDN: Incapsula`'
- en: '`X-Kong-Proxy-Latency: 123`'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-Kong-Proxy-Latency: 123`'
- en: '`Server: Zenedge`'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Server: Zenedge`'
- en: '`Server: Kestrel`'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Server: Kestrel`'
- en: '`X-Zen-Fury`'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-Zen-Fury`'
- en: '`X-Original-URI`'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X-Original-URI`'
- en: Another method for detecting WAFs, and especially those provided by a CDN, is
    to use Burp Suite’s Proxy and Repeater to watch for your requests being sent to
    a proxy. A 302 response that forwards you to a CDN would be an indication of this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检测WAF（特别是CDN提供的WAF）的一种方法是使用Burp Suite的Proxy和Repeater来观察你的请求是否被发送到代理。如果302响应将你转发到CDN，那就表明可能是这种情况。
- en: 'In addition to manually analyzing responses, you could use a tool such as W3af,
    Wafw00f, or Bypass WAF to proactively detect WAFs. Nmap also has a script to help
    detect WAFs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动分析响应，你还可以使用W3af、Wafw00f或Bypass WAF等工具主动检测WAF。Nmap也有一个脚本可以帮助检测WAF：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you’ve discovered how to bypass a WAF or other security control, it will
    help to automate your evasion method to send larger payload sets. At the end of
    this chapter, I’ll demonstrate how you can leverage functionality built into both
    Burp Suite and Wfuzz to do this.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了如何绕过WAF或其他安全控制，自动化你的绕过方法将有助于发送更大的有效载荷。在本章结束时，我将演示如何利用Burp Suite和Wfuzz中的功能来实现这一点。
- en: Using Burner Accounts
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用临时账户
- en: Once you’ve detected the presence of a WAF, it’s time to discover how it responds
    to attacks. This means you’ll need to develop a baseline for the API security
    controls in place, similar to the baselines you established while fuzzing in Chapter
    9. To perform this testing, I recommend using burner accounts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了WAF的存在，就该开始了解它如何对攻击作出响应。这意味着你需要建立API安全控制的基准，就像你在第9章模糊测试时建立的基准一样。为了进行这项测试，我建议使用临时账户。
- en: '*Burner accounts* are accounts or tokens you can dispose of should an API defense
    mechanism ban you. These accounts make your testing safer. The idea is simple:
    create several extra accounts before you start any attacks and then obtain a short
    list of authorization tokens you can use during testing. When registering these
    accounts, make sure you use information that isn’t associated with your other
    accounts. Otherwise, a smart API defender or defense system could collect the
    data you provide and associate it with the tokens you create. Therefore, if the
    registration process requires an email address or full name, make sure to use
    different names and email addresses for each one. Depending on your target, you
    may even want to take it to the next level and disguise your IP address by using
    a VPN or proxy while you register for an account.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*临时账户*是指你可以丢弃的账户或令牌，如果API防御机制封禁了你。这些账户可以使你的测试更加安全。其思路很简单：在进行攻击之前，先创建多个额外的账户，然后获取一份短的授权令牌列表，在测试过程中使用。当注册这些账户时，确保使用与你其他账户无关的信息。否则，聪明的API防御者或防御系统可能会收集你提供的数据，并将其与你创建的令牌关联起来。因此，如果注册过程要求提供电子邮件地址或全名，确保为每个账户使用不同的名字和电子邮件地址。根据你的目标，你甚至可能需要进一步采取措施，通过使用VPN或代理来伪装你的IP地址，以便注册账户。'
- en: Ideally, you won’t need to burn any of these accounts. If you can evade detection
    in the first place, you won’t need to worry about bypassing controls, so let’s
    start there.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你不需要浪费任何这些账户。如果你能在一开始就避免被检测，就不需要担心绕过控制，因此我们从这里开始。
- en: Evasive Techniques
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规避技术
- en: Evading security controls is a process of trial and error. Some security controls
    may not advertise their presence with response headers; instead, they may wait
    in secret for your misstep. Burner accounts will help you identify actions that
    will trigger a response, and you can then attempt to avoid those actions or bypass
    detection with your next account.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过安全控制是一个反复试验的过程。有些安全控制可能不会通过响应头部显示其存在，而是秘密等待你的失误。临时账户将帮助你识别哪些操作会触发响应，然后你可以尝试避免这些操作，或者使用下一个账户绕过检测。
- en: The following measures can be effective at bypassing these restrictions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下措施可以有效绕过这些限制。
- en: String Terminators
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串终止符
- en: Null bytes and other combinations of symbols often act as *string terminators*,
    or metacharacters used to end a string. If these symbols are not filtered out,
    they could terminate the API security control filters that may be in place. For
    instance, when you’re able to successfully send a null byte, it is interpreted
    by many backend programming languages as a signifier to stop processing. If the
    null byte is processed by a backend program that validates user input, that validation
    program could be bypassed because it stops processing the input.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 空字节和其他符号组合通常作为*字符串终止符*，或者用作结束字符串的元字符。如果这些符号没有被过滤，它们可能会终止API安全控制过滤器。例如，当你成功发送一个空字节时，许多后端编程语言会将其解释为停止处理的标志。如果空字节被后端程序处理，并且该程序验证用户输入，那么该验证程序可能会被绕过，因为它会停止处理输入。
- en: 'Here is a list of potential string terminators you can use:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以使用的潜在字符串终止符列表：
- en: '`%00`'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%00`'
- en: '`0x00`'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0x00`'
- en: '`//`'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`//`'
- en: '`;`'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`;`'
- en: '`%`'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%`'
- en: '`!`'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`!`'
- en: '`?`'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`?`'
- en: '`[]`'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[]`'
- en: '`%5B%5D`'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%5B%5D`'
- en: '`%09`'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%09`'
- en: '`%0a`'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0a`'
- en: '`%0b`'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0b`'
- en: '`%0c`'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0c`'
- en: '`%0e`'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%0e`'
- en: 'String terminators can be placed in different parts of the request to attempt
    to bypass any restrictions in place. For example, in the following XSS attack
    on the user profile page, the null bytes entered into the payload could bypass
    filtering rules that ban script tags:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串终止符可以放置在请求的不同部分，以尝试绕过任何现有的限制。例如，在以下对用户资料页面的XSS攻击中，输入的空字节负载可以绕过禁止脚本标签的过滤规则：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some wordlists out there can be used for general fuzzing attempts, such as SecLists’
    metacharacters list (found under the Fuzzing directory) and the Wfuzz bad characters
    list (found under the Injections directory). Beware of the risk of being banned
    when using wordlists like this in a well-defended environment. In a sensitive
    environment, it might be better to test out metacharacters slowly across different
    burner accounts. You can add a metacharacter to the requests you’re testing by
    inserting it into different attacks and reviewing the results for unique errors
    or other anomalies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上一些字典可以用于一般的模糊测试尝试，例如SecLists的元字符列表（可以在Fuzzing目录下找到）和Wfuzz的坏字符列表（可以在Injections目录下找到）。在防御严密的环境中使用这样的字典时，要小心被封禁的风险。在敏感环境中，最好通过不同的临时账户缓慢测试元字符。你可以通过将元字符插入不同的攻击中，并查看独特的错误或其他异常，来向你正在测试的请求添加元字符。
- en: Case Switching
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小写切换
- en: 'Sometimes, API security controls are dumb. They might even be so dumb that
    all it takes to bypass them is changing the case of the characters used in your
    attack payloads. Try capitalizing some letters and leaving others lowercase. A
    cross-site scripting attempt would turn into something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，API的安全控制非常简单。它们甚至可能愚蠢到只需要改变攻击负载中字符的大小写，就能绕过它们。尝试将一些字母大写，另一些保持小写。一次跨站脚本攻击可能变成这样：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or you might try the following SQL injection request:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以尝试以下SQL注入请求：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the defense uses rules to block certain attacks, there is a chance that changing
    the case will bypass those rules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果防御系统使用规则来阻止某些攻击，改变大小写可能会绕过这些规则。
- en: Encoding Payloads
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编码负载
- en: To take your WAF-bypassing attempts to the next level, try encoding payloads.
    Encoded payloads can often trick WAFs while still being processed by the target
    application or database. Even if the WAF or an input validation rule blocks certain
    characters or strings, it might miss encoded versions of those characters. Security
    controls are dependent on the resources allocated to them; trying to predict every
    attack is impractical for API providers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你的WAF绕过尝试提升到一个新层次，尝试编码负载。编码后的负载常常能够欺骗WAF，同时仍然被目标应用程序或数据库处理。即使WAF或输入验证规则阻止某些字符或字符串，它也可能会忽略这些字符的编码版本。安全控制取决于分配给它们的资源；预测每种攻击是不现实的，API提供商无法做到这一点。
- en: Burp Suite’s Decoder module is perfect for quickly encoding and decoding payloads.
    Simply input the payload you want to encode and choose the type of encoding you
    want (see [Figure 13-1](#figure13-1)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的Decoder模块非常适合快速编码和解码负载。只需输入你想要编码的负载并选择你想要的编码类型（参见[图13-1](#figure13-1)）。
- en: '![screenshot of burp suite’s decoder module that shows the input and output
    of the payload on the left-hand side, and options to choose the type of decoding
    and encoding on the right](image_fi/502444c13/F13001.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite的Decoder模块截图，左侧显示负载的输入和输出，右侧显示选择解码和编码类型的选项](image_fi/502444c13/F13001.png)'
- en: 'Figure 13-1: Burp Suite Decoder'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：Burp Suite Decoder
- en: For the most part, the URL encoding has the best chance of being interpreted
    by the targeted application, but HTML or base64 could often work as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，URL编码最有可能被目标应用程序解释，但HTML编码或base64编码也常常有效。
- en: 'When encoding, focus on the characters that may be blocked, such as these:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，重点关注可能被阻止的字符，例如以下这些：
- en: '`< > ( ) [ ] { } ; '' / \ |`'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`< > ( ) [ ] { } ; '' / \ |`'
- en: 'You could either encode part of a payload or the entire payload. Here are examples
    of encoded XSS payloads:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择对负载的部分或整个负载进行编码。以下是编码后的XSS负载示例：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You could even double-encode the payload. This would succeed if the security
    control that checks user input performs a decoding process and then the backend
    services of an application perform a second round of decoding. The double-encoded
    payload could bypass detection from the security control and then be passed to
    the backend, where it would again be decoded and processed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以对payload进行双重编码。如果检查用户输入的安全控制执行了解码过程，而应用的后端服务执行第二轮解码，则双重编码的payload可能绕过安全控制的检测，之后传递到后端，在那里再次进行解码并处理。
- en: Automating Evasion with Burp Suite
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Burp Suite自动化规避攻击
- en: Once you’ve discovered a successful method of bypassing a WAF, it’s time to
    leverage the functionality built into your fuzzing tools to automate your evasive
    attacks. Let’s start with Burp Suite’s Intruder. Under the Intruder Payloads option
    is a section called Payload Processing that allows you to add rules that Burp
    will apply to each payload before it is sent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了绕过WAF的成功方法，就可以利用模糊测试工具中内置的功能来自动化你的规避攻击。我们从Burp Suite的Intruder开始。在Intruder
    Payloads选项下，有一个名为Payload Processing的部分，允许你添加规则，Burp会在发送每个payload之前应用这些规则。
- en: Clicking the Add button brings up a screen that lets you add various rules to
    each payload, such as a prefix, a suffix, encoding, hashing, and custom input
    (see [Figure 13-2](#figure13-2)). It can also match and replace various characters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加按钮会弹出一个界面，允许你为每个payload添加各种规则，例如前缀、后缀、编码、哈希和自定义输入（见[图13-2](#figure13-2)）。它还可以匹配并替换各种字符。
- en: '![screenshot of burp suite’s add payload processing rule window that shows
    various options to encode characters and convert to other programming language
    strings](image_fi/502444c13/F13002.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite的添加Payload处理规则窗口截图，显示了编码字符和转换为其他编程语言字符串的各种选项](image_fi/502444c13/F13002.png)'
- en: 'Figure 13-2: The Add Payload Processing Rule screen'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：添加Payload处理规则界面
- en: Let’s say you discover you can bypass a WAF by adding a null byte before and
    after a URL-encoded payload. You could either edit the wordlist to match these
    requirements or add processing rules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你发现通过在URL编码的payload前后添加一个空字节，可以绕过WAF。你可以编辑字典文件以匹配这些要求，或者添加处理规则。
- en: For our example, we’ll need to create three rules. Burp Suite applies the payload-processing
    rules from top to bottom, so if we don’t want the null bytes to be encoded, for
    example, we’ll need to first encode the payload and then add the null bytes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们需要创建三条规则。Burp Suite会按从上到下的顺序应用payload处理规则，因此，如果我们不希望空字节被编码，比如，我们需要首先对payload进行编码，然后再添加空字节。
- en: The first rule will be to URL-encode all characters in the payload. Select the
    **Encode** rule type, select the **URL-Encode All Characters** option, and then
    click **OK** to add the rule. The second rule will be to add the null byte before
    the payload. This can be done by selecting the **Add Prefix** rule and setting
    the prefix to **%00**. Finally, create a rule to add a null byte after the payload.
    For this, use the **Add Suffix** rule and set the suffix to **%00**. If you have
    followed along, your payload-processing rules should match [Figure 13-3](#figure13-3).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是对payload中的所有字符进行URL编码。选择**编码**规则类型，选择**URL编码所有字符**选项，然后点击**确定**以添加该规则。第二条规则是在payload之前添加空字节。这可以通过选择**添加前缀**规则并将前缀设置为**%00**来完成。最后，创建一条规则，在payload后添加空字节。为此，使用**添加后缀**规则并将后缀设置为**%00**。如果你跟着操作，你的payload处理规则应该与[图13-3](#figure13-3)一致。
- en: '![screenshot of burp suite’s intruder payload processing options that shows
    the following rules as enabled: url-encode all characters; add prefix: %00; add
    suffix: %00](image_fi/502444c13/F13003.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Intruder的payload处理选项截图，显示以下启用的规则：对所有字符进行URL编码；添加前缀：%00；添加后缀：%00](image_fi/502444c13/F13003.png)'
- en: 'Figure 13-3: Intruder’s payload-processing options'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：Intruder的payload处理选项
- en: 'To test your payload processing, launch an attack and review the request payloads:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的payload处理，启动一次攻击并检查请求的payload：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Check the Payload column of your attack to make sure the payloads have been
    processed properly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 检查攻击的Payload列，确保payload已经正确处理。
- en: Automating Evasion with Wfuzz
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Wfuzz自动化规避攻击
- en: Wfuzz also has some great capabilities for payload processing. You can find
    its payload-processing documentation under the Advanced Usage section at [https://wfuzz.readthedocs.io](https://wfuzz.readthedocs.io).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz也具有很棒的payload处理功能。你可以在[https://wfuzz.readthedocs.io](https://wfuzz.readthedocs.io)的高级用法部分找到其payload处理文档。
- en: 'If you need to encode a payload, you’ll need to know the name of the encoder
    you want to use (see [Table 13-1](#table13-1)). To see a list of all Wfuzz encoders,
    use the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对有效负载进行编码，首先需要知道你想使用的编码器名称（参见[表13-1](#table13-1)）。要查看所有Wfuzz编码器的列表，请使用以下命令：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Table 13-1: A Sample of the Available Wfuzz Encoders'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1：可用Wfuzz编码器示例
- en: '| **Category** | **Name** | **Summary** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **名称** | **总结** |'
- en: '| --- | --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| hashes | `base64` | Encodes the given string using base64. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 哈希 | `base64` | 使用base64对给定的字符串进行编码。 |'
- en: '| url | `urlencode` | Replaces special characters in strings using the `%xx`
    escape. Letters, digits, and the characters `'' _ . - ''` are never quoted. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| URL | `urlencode` | 使用`%xx`转义替换字符串中的特殊字符。字母、数字和字符`'' _ . - ''`永远不会被转义。 |'
- en: '| default | `random_upper` | Replaces random characters in strings with capital
    letters. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | `random_upper` | 将字符串中的随机字符替换为大写字母。 |'
- en: '| hashes | `md5` | Applies an MD5 hash to the given string. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 哈希 | `md5` | 对给定的字符串应用MD5哈希。 |'
- en: '| default | `none` | Returns all characters without changes. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | `none` | 返回所有字符而不做任何更改。 |'
- en: '| default | `hexlify` | Converts every byte of data to its corresponding two-digit
    hex representation. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | `hexlify` | 将每个字节数据转换为相应的两位十六进制表示。 |'
- en: 'Next, to use an encoder, add a comma to the payload and specify its name:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要使用编码器，请在有效负载后添加逗号并指定其名称：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, every payload would be base64-encoded before being sent in
    a request.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个有效负载都会在发送请求之前进行base64编码。
- en: 'The encoder feature can also be used with multiple encoders. To have a payload
    processed by multiple encoders in separate requests, specify them with a hyphen.
    For example, say you specified the payload “a” with the encoding applied like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器功能还可以与多个编码器一起使用。要让一个有效负载通过多个编码器在单独的请求中处理，使用连字符指定它们。例如，假设你指定了有效负载“a”并应用了如下编码：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You would receive one payload encoded to base64, another payload encoded by
    MD5, and a final payload in its original form (the `none` encoder means “not encoded”).
    This would result in three different payloads.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你将接收到一个base64编码的有效负载，一个通过MD5编码的有效负载，以及一个原始形式的有效负载（`none`编码表示“未编码”）。这将导致三个不同的有效负载。
- en: 'If you specified three payloads, using a hyphen for three encoders would send
    nine total requests, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了三个有效负载，使用连字符连接三个编码器将会发送九个请求，如下所示：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If, instead, you want each payload to be processed by multiple encoders, separate
    the encoders with an `@` sign:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望每个有效负载都由多个编码器处理，可以使用`@`符号分隔编码器：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, Wfuzz would first apply random uppercase letters to each payload
    and then base64-encode that payload. This results in one request sent per payload.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Wfuzz首先会对每个有效负载应用随机大写字母，然后对该有效负载进行base64编码。这样每个有效负载都会发送一个请求。
- en: These Burp Suite and Wfuzz options will help you process your attacks in ways
    that help you sneak past whatever security controls stand in your way. To dive
    deeper into the topic of WAF bypassing, I recommend checking out the incredible
    Awesome-WAF GitHub repo ([https://github.com/0xInfection/Awesome-WAF](https://github.com/0xInfection/Awesome-WAF)),
    where you’ll find a ton of great information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Burp Suite和Wfuzz选项将帮助你以不同的方式处理攻击，帮助你突破任何阻挡你前进的安全控制。要深入了解WAF绕过的话，我推荐你查看这个令人惊叹的Awesome-WAF
    GitHub仓库（[https://github.com/0xInfection/Awesome-WAF](https://github.com/0xInfection/Awesome-WAF)），你会发现很多精彩的资料。
- en: Testing Rate Limits
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试速率限制
- en: Now that you understand several evasion techniques, let’s use them to test an
    API’s rate limiting. Without rate limiting, API consumers could request as much
    information as they want, as often as they’d like. As a result, the provider might
    incur additional costs associated with its computing resources or even fall victim
    to a DoS attack. In addition, API providers often use rate limiting as a method
    of monetizing their APIs. Therefore, rate limiting is an important security control
    for hackers to test.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了几种规避技术，让我们用它们来测试API的速率限制。如果没有速率限制，API用户可以随时请求他们想要的任何信息，且可以频繁请求。这样，提供方可能会增加与计算资源相关的额外费用，甚至可能成为拒绝服务（DoS）攻击的受害者。此外，API提供方通常使用速率限制作为将API货币化的一种方式。因此，速率限制是黑客进行测试时的重要安全控制。
- en: 'To identify a rate limit, first consult the API documentation and marketing
    materials for any relevant information. An API provider may include its rate limiting
    details publicly on its website or in API documentation. If this information isn’t
    advertised, check the API’s headers. APIs often include headers like the following
    to let you know how many more requests you can make before you violate the limit:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`x-rate-limit:`'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x-rate-limit-remaining:`'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other APIs won’t have any rate limit indicators, but if you exceed the limit,
    you’ll find yourself temporarily blocked or banned. You might start receiving
    new response codes, such as 429 Too Many Requests. These might include a header
    like `Retry-After:` that indicates when you can submit additional requests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In order for rate limiting to work, the API has to get many things right. This
    means a hacker only has to find a single weakness in the system. Like with other
    security controls, rate limiting only works if the API provider is able to attribute
    requests to a single user, usually with their IP address, request data, and metadata.
    The most obvious of these factors used to block an attacker are their IP address
    and authorization token. In API requests, the authorization token is used as a
    primary means of identity, so if too many requests are sent from a token, it could
    be put on a naughty list and temporarily or permanently banned. If a token isn’t
    used, a WAF could treat a given IP address the same way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to go about testing rate limiting. One is to avoid being
    rate limited altogether. The second is to bypass the mechanism that is blocking
    you once you are rate limited. We will explore both methods throughout the remainder
    of this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Lax Rate Limits
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, some rate limits may be so lax that you don’t need to bypass them
    to conduct an attack. Let’s say a rate limit is set to 15,000 requests per minute
    and you want to brute-force a password with 150,000 different possibilities. You
    could easily stay within the rate limit by taking 10 minutes to cycle through
    every possible password.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, you’ll just have to ensure that your brute-forcing speed doesn’t
    exceed this limitation. For example, I’ve experienced Wfuzz reaching speeds of
    10,000 requests in just under 24 seconds (that’s 428 requests per second). In
    that case, you’d need to throttle Wfuzz’s speed to stay within this limitation.
    Using the `-t` option allows you to specify the concurrent number of connections,
    and the `-s` option allows you to specify a time delay between requests. [Table
    13-2](#table13-2) shows the possible Wfuzz `-s` options.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-2: Wfuzz `-s` Options for Throttling Requests'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| **Delay between requests (seconds)** | **Approximate number of requests sent**
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| 0.01 | 10 per second |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 per second |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 6 | 10 per minute |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| 60 | 1 per minute |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: As Burp Suite CE’s Intruder is throttled by design, it provides another great
    way to stay within certain low rate limit restrictions. If you’re using Burp Suite
    Pro, set up Intruder’s Resource Pool to limit the rate at which requests are sent
    (see [Figure 13-4](#figure13-4)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Burp Suite CE的Intruder设计上有速率限制，它提供了另一种保持在某些低速率限制内的好方法。如果你使用的是Burp Suite Pro，请设置Intruder的资源池来限制请求发送的速率（参见[图
    13-4](#figure13-4)）。
- en: '![screenshot of burp suite’s resource pool window that shows a new resource
    pool, evasive maneuvers, being created. the delay between requests is set for
    101 milliseconds.](image_fi/502444c13/F13004.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite的资源池窗口截图，显示正在创建一个新的资源池，延迟请求之间的时间设置为101毫秒。](image_fi/502444c13/F13004.png)'
- en: 'Figure 13-4: Burp Suite Intruder’s Resource Pool'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：Burp Suite Intruder资源池
- en: Unlike Wfuzz, Intruder calculates delays in milliseconds. Thus, setting a delay
    of 100 milliseconds will result in a total of 10 requests sent per second. [Table
    13-3](#table13-3) can help you adjust Burp Suite Intruder’s Resource Pool values
    to create various delays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与Wfuzz不同，Intruder以毫秒为单位计算延迟。因此，设置100毫秒的延迟将导致每秒发送10个请求。[表 13-3](#table13-3)可以帮助你调整Burp
    Suite Intruder的资源池值，从而创建不同的延迟。
- en: 'Table 13-3: Burp Suite Intruder’s Resource Pool Delay Options for Throttling
    Requests'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-3：Burp Suite Intruder资源池的请求延迟选项
- en: '| **Delay between requests (milliseconds)** | **Approximate requests** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **请求之间的延迟（毫秒）** | **大致请求次数** |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 100 | 10 per second |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 每秒 10 次 |'
- en: '| 1000 | 1 per second |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 每秒 1 次 |'
- en: '| 6000 | 10 per minute |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 6000 | 每分钟 10 次 |'
- en: '| 60000 | 1 per minute |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 60000 | 每分钟 1 次 |'
- en: If you manage to attack an API without exceeding its rate limitations, your
    attack can serve as a demonstration of the rate limiting’s weakness.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够在不超过API速率限制的情况下攻击API，那么你的攻击可以作为速率限制漏洞的演示。
- en: Before you move on to bypassing rate limiting, determine if consumers face any
    consequences for exceeding a rate limit. If rate limiting has been misconfigured,
    there is a chance exceeding the limit causes no consequences. If this is the case,
    you’ve identified a vulnerability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续绕过速率限制之前，确定消费者超出速率限制是否会面临任何后果。如果速率限制配置错误，超出限制可能不会造成任何后果。如果是这种情况，你已经找到了一个漏洞。
- en: Path Bypass
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径绕过
- en: 'One of the simplest ways to get around a rate limit is to slightly alter the
    URL path. For example, try using case switching or string terminators in your
    requests. Let’s say you are targeting a social media site by attempting an IDOR
    attack against a `uid` parameter in the following POST request:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过速率限制的最简单方法之一是稍微修改URL路径。例如，尝试在请求中使用大小写切换或字符串终止符。假设你正在通过对以下POST请求中的`uid`参数进行IDOR攻击，针对一个社交媒体网站：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The API may allow 100 requests per minute, but based on the length of the `uid`
    value, you know that to brute-force it, you’ll need to send 10,000 requests. You
    could slowly send requests over the span of an hour and 40 minutes or else attempt
    to bypass the restriction altogether.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该API可能允许每分钟100次请求，但根据`uid`值的长度，你知道要进行暴力破解，你需要发送10,000个请求。你可以在一个小时40分钟的时间内缓慢发送请求，或者尝试完全绕过这个限制。
- en: 'If you reach the rate limit for this request, try altering the URL path with
    string terminators or various upper- and lowercase letters, like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你达到了该请求的速率限制，尝试通过字符串终止符或各种大小写字母修改URL路径，如下所示：
- en: '`POST /api/myprofile%00`'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /api/myprofile%00`'
- en: '`POST /api/myprofile%20`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /api/myprofile%20`'
- en: '`POST /api/myProfile`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /api/myProfile`'
- en: '`POST /api/MyProfile`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /api/MyProfile`'
- en: '`POST /api/my-profile`'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /api/my-profile`'
- en: 'Each of these path iterations could cause the API provider to handle the request
    differently, potentially bypassing the rate limit. You might also achieve the
    same result by including meaningless parameters in the path:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径变体可能会导致API提供者以不同的方式处理请求，可能绕过速率限制。你也可能通过在路径中包含无意义的参数来达到相同的结果：
- en: '`POST /api/myprofile?test=1`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /api/myprofile?test=1`'
- en: 'If the meaningless parameter results in a successful request, it may restart
    the rate limit. In that case, try changing the parameter’s value in every request.
    Simply add a new payload position for the meaningless parameter and then use a
    list of numbers of the same length as the number of requests you would like to
    send:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无意义的参数导致请求成功，它可能会重新启动速率限制。在这种情况下，尝试在每个请求中更改参数的值。只需为无意义的参数添加一个新的负载位置，然后使用与要发送的请求数相同长度的数字列表：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you were using Burp Suite’s Intruder for this attack, you could set the attack
    type to pitchfork and use the same value for both payload positions. This tactic
    allows you to use the smallest number of requests required to brute-force the
    `uid`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Origin Header Spoofing
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some API providers use headers to enforce rate limiting. These *origin* request
    headers tell the web server where a request came from. If the client generates
    origin headers, we could manipulate them to evade rate limiting. Try including
    common origin headers in your request like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`X-Forwarded-For`'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X-Forwarded-Host`'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X-Host`'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X-Originating-IP`'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X-Remote-IP`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X-Client-IP`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X-Remote-Addr`'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As far as the values for these headers, plug into your adversarial mindset and
    get creative. You might try including private IP addresses, the localhost IP address
    (127.0.0.1), or an IP address relevant to your target. If you’ve done enough reconnaissance,
    you could use some of the other IP addresses in the target’s attack surface.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Next, try either sending every possible origin header at once or including them
    in individual requests. If you include all headers at once, you may receive a
    431 Request Header Fields Too Large status code. In that case, send fewer headers
    per request until you succeed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to origin headers, API defenders may also include the `User-Agent`
    header to attribute requests to a user. `User-Agent` headers are meant to identify
    the client browser, browser versioning information, and client operating system.
    Here’s an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sometimes, this header will be used in combination with other headers to help
    identify and block an attacker. Luckily, SecLists includes `User-Agent` wordlists
    you can use to cycle through different values in your requests under the directory
    *seclists/Fuzzing/User-Agents* ([https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/User-Agents/UserAgents.fuzz.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/User-Agents/UserAgents.fuzz.txt)).
    Simply add payload positions around the `User-Agent` value and update it in each
    request you send. You may be able to work your way around a rate limit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You’ll know you’ve succeeded if an `x-rate-limit` header resets or if you’re
    able to make successful requests after being blocked.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Rotating IP Addresses in Burp Suite
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One security measure that will stop fuzzing dead in its tracks is IP-based restrictions
    from a WAF. You might kick off a scan of an API and, sure enough, receive a message
    that your IP address has been blocked. If this happens, you can make certain assumptions—namely,
    that the WAF contains some logic to ban the requesting IP address when it receives
    several bad requests in a short time frame.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To help defeat IP-based blocking, Rhino Security Labs released a Burp Suite
    extension and guide for performing an awesome evasion technique. Called IP Rotate,
    the extension is available for Burp Suite Community Edition. To use it, you’ll
    need an AWS account in which you can create an IAM user.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, this tool allows you to proxy your traffic through the AWS
    API gateway, which will then cycle through IP addresses so that each request comes
    from a unique address. This is next-level evasion, because you’re not spoofing
    any information; instead, your requests are actually originating from different
    IP addresses across AWS zones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the extension, you’ll need a tool called Boto3 as well as the Jython
    implementation of the Python programming language. To install Boto3, use the following
    `pip3` command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, download the Jython standalone file from [https://www.jython.org/download.html](https://www.jython.org/download.html).
    Once you’ve downloaded the file, go to the Burp Suite Extender options and specify
    the Jython standalone file under Python Environment, as seen in [Figure 13-5](#figure13-5).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of burp suite’s extender options that shows the location of the
    jython file selected under the python environment settings](image_fi/502444c13/F13005.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: Burp Suite Extender options'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Burp Suite Extender’s BApp Store and search for IP Rotate. You
    should now be able to click the **Install** button (see [Figure 13-6](#figure13-6)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of burp suite’s bapp store that shows information for ip rotate
    with a button to install ip rotate located directly underneath this information](image_fi/502444c13/F13006.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: IP Rotate in the BApp Store'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: After logging in to your AWS management account, navigate to the IAM service
    page. This can be done by searching for IAM or navigating through the Services
    drop-down options (see [Figure 13-7](#figure13-7)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of aws that shows search results for iam](image_fi/502444c13/F13007.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: Finding the AWS IAM service'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: After loading the IAM Services page, click **Add Users** and create a user account
    with programmatic access selected (see [Figure 13-8](#figure13-8)). Proceed to
    the next page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of aws’s set user details page that shows a new user being created](image_fi/502444c13/F13008.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: AWS Set User Details page'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: On the Set Permissions page, select **Attach Existing Policies Directly**. Next,
    filter policies by searching for “API.” Select the **AmazonAPIGatewayAdministrator**
    and **AmazonAPIGatewayInvokeFullAccess** permissions, as seen in [Figure 13-9](#figure13-9).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of aws’s set permissions page that shows various policies as filtered
    by api](image_fi/502444c13/F13009.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: AWS Set Permissions page'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Proceed to the review page. No tags are necessary, so you can skip ahead and
    create the user. Now you can download the CSV file containing your user’s access
    key and secret access key. Once you have the two keys, open Burp Suite and navigate
    to the IP Rotate module (see [Figure 13-10](#figure13-10)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of burp suite’s ip rotate module that shows boxes to input the
    access key, secret key, and target host](image_fi/502444c13/F13010.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: The Burp Suite IP Rotate module'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste your access key and secret key into the relevant fields. Click
    the **Save Keys** button. When you are ready to use IP Rotate, update the target
    host field to your target API and click **Enable**. Note that you do not need
    to enter in the protocol (HTTP or HTTPS) in the target host field. Instead, use
    the **Target Protocol** button to specify either HTTP or HTTPS.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: A cool test you can do to see IP Rotate in action is to specify *ipchicken.com*
    as your target. (IPChicken is a website that displays your public IP address,
    as seen in [Figure 13-11](#figure13-11).) Then proxy a request to [https://ipchicken.com](https://ipchicken.com).
    Forward that request and watch how your rotating IP is displayed with every refresh
    of [https://ipchicken.com](https://ipchicken.com).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![two screenshots of ip chicken’s web page that show two distinct current ip
    addresses](image_fi/502444c13/F13011.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: IPChicken'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Now, security controls that block you based solely on your IP address will stand
    no chance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, I discussed techniques you can use to evade API security controls.
    Be sure to gather as much information as you can as an end user before you launch
    an all-out attack. Also, create burner accounts to continue testing if one of
    your accounts is banned.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'We applied evasive skills to test out one of the most common API security controls:
    rate limiting. Finding a way to bypass rate limiting gives you an unlimited, all-access
    pass to attacking an API with all the brute force you can muster. In the next
    chapter, we’ll be applying the techniques developed throughout this book to attacking
    a GraphQL API.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
