- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming and Math Conventions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have an environment to work in, let’s discuss the programming language
    we’ll be using. This book assumes you have a basic familiarity with programming
    concepts such as loops, variables, conditionals, and functions, so this chapter
    isn’t meant to be a comprehensive introduction to Python. Rather, it’s intended
    to illustrate some finer points that will help you understand the examples in
    this book and in other tutorials. Of course, the programming in the book centers
    on implementing math concepts from research papers, so it’s equally important
    that we have a common understanding of the notation used in that type of material.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactical Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although this book isn’t meant to serve as an introduction to Python programming,
    there are some useful syntactical constructs you should be familiar with before
    diving in. It’s important to balance the use of these more advanced features to
    maintain the readability and understandability of your code. I’ve used the constructs
    described in this section throughout the book’s projects for code brevity. If
    you’re still learning Python, some of the syntax may seem daunting at first, but
    once you apply these constructs a few times in your own code you’ll wonder how
    you ever got anything done without them!
  prefs: []
  type: TYPE_NORMAL
- en: List Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comprehension constructs come in handy whenever you need to create a list (or
    dictionary) of values by iterating over some code. The simplest use case is to
    apply a function to every element in a list. For example, suppose you have a list
    of strings, called `names`, that you want to convert to uppercase. You could use
    a loop similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are a couple of downsides to this method. First, it requires two
    lists: one for inputs (`names`) and one for outputs (`names_2`). When you have
    very large lists of complex objects, copying the whole list in memory for a simple
    change like this is inefficient. You could add more code to overwrite names with
    the contents of `names_2` and then free up the memory used by `name_2` explicitly,
    but that’s a pain and makes the code messy. This leads us to the second problem:
    the code takes up more lines than necessary. In complex applications you may have
    hundreds of functions to maintain. Keeping your code concise saves you time when
    writing and modifying your code in large code bases. You could condense the whole
    process into a single line like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a list comprehension, the first variable defines what will be stored in
    the resulting list. In this case `n` is a string we’re converting to uppercase,
    hence `n.upper`. We define the values for `n` using the `for` statement to its
    right, which iterates through the `names` list and selects each `n`. The resulting
    list is then assigned directly to the `names` variable, overwriting its previous
    value and freeing up the memory used by the loop automatically. We can add some
    conditional logic to the end of the statement to filter the results. For example,
    suppose we want to also filter the `names` list on whether the first letter of
    each string is `m`. Once again, you could write this as a loop with a block of
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now within each iteration of the `for` loop we have a conditional statement
    to check if the string starts with `m` and, if so, it appends the uppercase version
    to the `m_names_upper` list. This method suffers from the same drawbacks as the
    previous loop example, though, and takes up even more space! This code can also
    be shortened to a single line with a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added some conditional logic to the end of the list comprehension statement
    to filter the results; again, we’ll add `n.upper` only if `n` starts with an `m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two examples will produce the same output; it’s open for debate which is
    simpler or easier to explain, so the approach you choose will often be a matter
    of preference. Note that you can add an `else` condition to the list comprehension
    to control what happens in the event the `if` returns `False`. In cases where
    the conditional logic is `False`—for example, when a function expects two lists
    to be the same length so it can do some pairwise manipulation on the values—you
    might want to add a static value to your output list rather than excluding the
    element altogether. Let’s say we want to rename everyone whose name doesn’t start
    with `m` to `marcus`. With a traditional loop structure, this requires adding
    an `else` block after the `if` block to handle inserting the value. I’ll skip
    that, as we’ve all seen `else` blocks in Python (hopefully), and we’re discussing
    list comprehensions. Adding the additional `else` clause to a list comprehension
    changes the syntax so the `if...else` logic comes before the `for` loop logic,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `if` statement moves directly after the variable to be stored,
    `n`. You then add the `else` condition, which defines the value to be added to
    the output list `m_names` in cases where the `if` statement is `False`. In this
    example, if a name starts with an `m`, it will be added to the output list; otherwise,
    the string literal `marcus` will be added instead.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of more practical uses for list comprehensions, and you’ll
    see them sprinkled through the code in this book and other examples, so it’s best
    to become familiar with them and how they translate into more traditional looping
    code structures. It’s also important to understand the limitations of list comprehensions.
    If your conditional selection logic is fairly complex, you might want to consider
    abstracting it to its own function. You can then use the function in a list comprehension
    to apply it to each element (a method you’ll see used in this book as well). The
    only real limitations within the list comprehension itself are that you can apply
    only one conditional statement, and the output at the end of each iteration must
    be something that can be included in a Python list object.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dictionaries are one of the most prevalent data structures in Python. They
    are used for everything from simple key/value pairing up to handling complex,
    user-defined classes. Luckily they are also extremely easy to work with, and a
    lot of the concepts we just discussed for list comprehensions apply equally well
    to defining dictionary objects, though you’ll tend to run across fewer examples
    in the wild. As an illustration, consider the following code, which merges a list
    of keys with an accompanying list of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the power of dictionary comprehension allows us to shorten this
    code block to a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice there are only a few differences between the list comprehension
    and the dictionary comprehensions syntax. Python’s developers have done this to
    make them both easier to understand in relation to each other. If you understand
    list comprehensions, then you understand 90 percent of dictionary comprehensions.
    The two things to remember are: dictionaries are defined using braces `{}` instead
    of square brackets, and the left part before the `for` keyword expresses both
    a key and a value, separated by a colon. Here, we define our key as the *i*th
    value in the list called `keys`. We’re assigning the value for that key from the
    second list, `values`, using the same index, *i*. We then define a `for` statement
    that loops over the integer values between 0 and the length of the `keys` list
    using the `range` function. This is an example of a function that naively assumes
    both the `keys` and `values` lists are the same length. If `keys` is ever longer
    than `values`, this code will raise an error when it attempts to access a nonexistent
    index on `values`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a function to define both the key variable and the value variable,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we’ve changed the previous code so all the keys are converted
    to uppercase and all the values are cast to `float`. We could, of course, replace
    these functions with anything that suits our needs. As long as the result for
    each function can be used as a key or value in a regular Python dictionary, the
    function can be used. The same caveat applies to this conditional logic as with
    list comprehensions. If you need more complex logic, you should consider abstracting
    the key and value definition into its own function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the keys and values are being defined by the return value from the function
    call `my_logic(keys)`. It doesn’t matter what this function does; all that matters
    is that the function returns a list that contains tuples (or nested lists) that
    each contain two items. The first item in each tuple will be treated as the key
    `k`, and the second item as the corresponding value. And there’s the dirty little
    secret of dictionary comprehensions: they’re really just list comprehensions in
    disguise! You may have already realized this because the `range` function produces
    a list as well. This is a handy shortcut when you want to run a function on every
    item in a list and store the result as a dictionary that relates the item with
    the result of calling the function on that item.'
  prefs: []
  type: TYPE_NORMAL
- en: Zipping and Unpacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s built-in `zip` function returns an iterator of tuples, where the *i*th
    tuple contains the *i*th element from each argument passed in. Suppose you wanted
    to combine the previous list of names stored in `names` with the list of colors
    and numbers stored in `keys` and `values`, respectively. The `zip` function will
    allow you to efficiently generate these combinations as a list of tuples, again
    with a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `a` now holds a `zip` object that, when cast to a list, will contain
    triples like `("bob","Red",1)`. It’s important to pay attention to the order in
    which you pass the lists, as left-to-right processing is guaranteed. Also be aware
    that the iterator stops when the shortest-length input is exhausted. Unpacking
    is the reverse of the `zip` function, but it’s a behavior of Python rather than
    a function that you need to call. For example, you can unpack the three values
    that make up the first item in the `zip` object `a` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This line of code takes the three values in the first tuple in `a` and assigns
    them to the three variables (left-to-right order) on the left side of the equal
    sign. You must have the same number of variables as items in the tuple, or the
    code will raise an exception. Zipping and unpacking are useful when you want to
    transport data around your application. Rather than defining multiple variables
    to hold the three output lists, we can apply the `zip` function to return a single
    `zip` object, which preserves the relationship between all three lists. You can
    then iterate over the results and unpack the values into distinct variables as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code you see will be pretty standard Python. I’ll point out
    the syntax for specific libraries as we come to use them in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll dive into the exciting world of math notation. As you’ll see, understanding
    the symbols used plays a crucial role in advanced mathematics. It provides a flexible
    form of shorthand that makes the formulas easier to remember. Unfortunately, as
    with programming, these symbols can take on multiple meanings. Mathematical notations
    often have a dual nature since they can signify both the math being performed
    and variables on which it’s being performed.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematical notation is a tricky beast, especially when you intend to cover
    more than one field in a text. The reason is that a lot of mathematical symbols
    are *overloaded*, meaning they have many possible meanings, and to know which
    meaning applies, you need to look at the context. A perfect example of this is
    the Greek letter theta, θ. In machine learning literature, θ usually refers to
    the set of feature weights calculated for a set of data. This “hypothesis” function
    is commonly seen in the first weeks of machine learning, when linear regression
    models are covered.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c02/m02001.png)'
  prefs: []
  type: TYPE_IMG
- en: However, in geometry and trigonometry, θ is often used as a “degrees” variable—for
    example, in the Pythagorean theorem, as shown in [Figure 2-1](#figure2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: The Pythagorean theorem using theta to represent an angle in degrees'
  prefs: []
  type: TYPE_NORMAL
- en: Where possible, I stick to the notation used in the prevailing material on the
    subject. In cases where the notation becomes overloaded, I’ve included explanations
    of the intended meanings.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most often applied (and most often overlooked) concepts you’ll see
    in applied mathematics is Boolean algebra. A *Boolean* is a primitive data type
    that can hold only one of two possible values at any given moment. The value is
    determined by the *logical statement* that accompanies it. For example, we can
    ask if two numbers, *x* and *y*, are equal to each other. The answer to this question
    will always be yes or no, depending on the inputs. There will never be a case
    that produces a third answer.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean symbols are most often denoted in the form of a *truth table*. In the
    interest of saving space, I haven’t included any full truth tables in this book;
    you can find many excellent references for these tables online. We’ll focus instead
    on the symbols used to write the logical statements and how you can interpret
    them. [Table 2-1](#table2-1) covers each of the major Boolean algebra symbols
    and the intuitive meaning, with an example of the logic applied to a statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: Boolean Logic Examples'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Meaning** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| AND: A ∧ B | Both *A* and *B* must be `True` for the statement to be `True`.
    Algebraically, *A* × *B* or just *AB*. | *Cats are mammals* AND *planes fly* is
    `True` since both statements are `True`. If either statement is `False`, the whole
    statement is `False` (equal to `0`). |'
  prefs: []
  type: TYPE_TB
- en: '| OR: A ∨ B | If either *A* or *B* or both *A* and *B* are `True`, this statement
    is `True`. Algebraically, *A* + *B*. | *Cats are dogs* OR *birds are cats* is
    `False` because neither *A* nor *B* is `True`. Changing either or both to `True`
    statements would change the result. |'
  prefs: []
  type: TYPE_TB
- en: '| NOT: ¬ A, À | This statement is `True` when the statement *A* is `False`.
    It is an inverter that outputs the opposite of its input. | If *A* represents
    the statement *cats are fish*, this could be written as *NOT cats are fish*. *NOT
    cats are fish* is `True` because the statement *ca**ts are fish* is `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| XOR: A ⊕ B | If either *A* or *B* but NOT both *A* and *B* are `True`, this
    statement is `True`. Algebraically, ( AB̀ ) + ( ÀB ). | *The shirt is red* XOR
    *the shirt is blue* is `True` if the shirt is either red or blue, but not both
    red and blue. |'
  prefs: []
  type: TYPE_TB
- en: These deceptively simple components can be used to describe the most arbitrarily
    complex systems known to humankind through the use of chained Boolean statements.
    It’s very important to be aware of the order of operations and placement of parentheses
    in Boolean expressions. Operator precedence is the same as in traditional algebra,
    with fewer functions. Any operations inside parentheses are handled first, followed
    by any AND conditions (multiplication), and finally, OR statements (addition).
    Negations are handled during the final step of the operation being negated, so
    they don’t need any special handling. Traditionally we evaluate multiple parentheses
    from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Most runtime environments, like Python’s interpreter, stop evaluating as soon
    as the truth of a statement can be determined. They won’t continue to check additional
    statements that can no longer change the result. For example, the logical statement
  prefs: []
  type: TYPE_NORMAL
- en: ( Cats fly ∧ dogs bark )
  prefs: []
  type: TYPE_NORMAL
- en: will first check the *Cats fly* statement. Since this is `False`, the value
    of the second statement can’t impact the result of the AND statement. Python determines
    that the total statement is `False` without ever checking the *dogs bark* condition.
    To understand how Python parses more complex logical statements, let’s look at
    another example. The statement
  prefs: []
  type: TYPE_NORMAL
- en: ( Cats meow ∧ dogs bark ) ⊕ ( Fish swim ∧ ¬birds fly )
  prefs: []
  type: TYPE_NORMAL
- en: is evaluated in the interpreter as follows. First the parentheses group
  prefs: []
  type: TYPE_NORMAL
- en: ( Cats meow ∧ dogs bark )
  prefs: []
  type: TYPE_NORMAL
- en: is evaluated. It is `True`, because both statements it contains are `True` (cats
    do meow and dogs do bark). Since the second set of parentheses can still affect
    the outcome (a XOR operation always requires us to evaluate both sides),
  prefs: []
  type: TYPE_NORMAL
- en: ( Fish swim ∧ ¬birds fly )
  prefs: []
  type: TYPE_NORMAL
- en: is evaluated next. The negation on *birds fly* makes this second statement `False`
    (*birds fly* is `True`, so *NOT birds fly* is `False`). Now we evaluate the XOR
    operation
  prefs: []
  type: TYPE_NORMAL
- en: ( AB̀) + ( ÀB )
  prefs: []
  type: TYPE_NORMAL
- en: where *A* is the result of the first parentheses group, and *B* is the result
    of the second parentheses group. We can solve this easily by recursively applying
    the operator precedence.
  prefs: []
  type: TYPE_NORMAL
- en: ( 1 × 0̀) + ( 1̀ × 0 ) = ( 1 × 1 ) + ( 0 × 0 ) = ( 1 + 0 ) = 1
  prefs: []
  type: TYPE_NORMAL
- en: We interpret a `1` to mean the overall statement
  prefs: []
  type: TYPE_NORMAL
- en: ( Cats meow ∧ dogs bark ) ⊕ ( Fish swim ∧ ¬birds fly )
  prefs: []
  type: TYPE_NORMAL
- en: is `True`, which matches what we’d expect because XOR requires exactly one of
    the conditions to be `True` for the outcome to be `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Set Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In mathematics, we often want to denote groups of objects rather than individual
    objects. For example, we might say that all the students who go to a particular
    school make up a *set*. Each student can occur in the set only once.
  prefs: []
  type: TYPE_NORMAL
- en: We could denote the set of students *S*. (I’ll follow the convention of using
    a capitalized English variable name for sets, with a few exceptions.) This defines
    what items are, or are not, considered to be part of the set. This is often called
    a *membership rule*. Now that we have a definition of membership, we can denote
    what items *i* are in the set (*i* ∈ *S*) or, of course, not in the set (*i* ∉
    *S*). In this example, *i* ∉ *S* is syntactically equivalent to saying, “All things
    that are not students at the defined school.” When dealing with multiple sets,
    we may be interested in which set contains an item (*S* ∋ *i*). Assuming we created
    a set for each school in a district, this would be equivalent to asking, “What
    school does a given student attend?” [Table 2-2](#table2-2) describes the symbols
    used throughout this text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-2: Set Notation Examples'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Meaning** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| i ∈ S | Boolean: Item *i* in set *S*. | 3 in the set of odd integers is `True`.
    4 in the set of odd integers is `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| i ∉ S | Boolean: Item *i* not in set *S*. | 3 not in the set of odd integers
    is `False`. 4 not in the set of odd numbers is `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| S ∋ i | Boolean: Set *S* contains item *i*. | Set of odd integers contains
    7 is `True`. Set of cars contains a bicycle is `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| A ∩ B | Product: i ∈ A ∧ i ∈ B. All items in set *A* that are also in set
    *B*. | Will produce a set of all items that meet both *A* and *B*. If *A* is the
    set of all animals and *B* is the set of all mammals, a cat could be included
    in the product because it’s in both the set of animals and the set of mammals.
    |'
  prefs: []
  type: TYPE_TB
- en: '| A \ B | Product: ( i ∈ A ¬ i ∈ B ) + ( i ∈ B ¬ i ∈ A ). All items in set
    *A* that are not in set *B* plus all items in set *B* that are not in set *A*.
    | All topics from security that do not involve medical tech, plus all topics from
    medical tech that do not involve security. |'
  prefs: []
  type: TYPE_TB
- en: '| A ∪ B | Product: i ∈ A ∨ i ∈ B. All items in set *A* or in set *B* or in
    both sets. | All places that are gas stations or grocery stores or both a gas
    station and a grocery store. |'
  prefs: []
  type: TYPE_TB
- en: '| p ⊂ S, p ⊆ S | Boolean: Items in subset *p* are all in the superset *S*.
    If *p* can contain all the members of *S*, we use ⊆. | A subset of door locks
    is from the superset of all security devices is `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| p ⊄ S | Boolean: One or more items in subset *p* is not in the superset *S*.
    | [Pear, Grape, Rock] is not a subset of foods is `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| ∀ p ∈ S F | For all items *p* in *S*, apply function *F*. | For all the people
    in the room, say “hello.” |'
  prefs: []
  type: TYPE_TB
- en: '| ![m02002](image_fi/502567c02/m02002.png) or nCk | The number of unordered
    combinations of *k* elements drawn from a set of *n* elements. Read “from *n*
    choose *k*.” | From [Ron, Tom, Ann] choose two names: ![m02003](image_fi/502567c02/m02003.png)
    |'
  prefs: []
  type: TYPE_TB
- en: Finally, there are a few reserved sets that come up so frequently that they’ve
    been given standardized symbols throughout most of the literature. You can find
    these listed in [Table 2-3](#table2-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-3: Reserved Sets'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Membership rule** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ∅ | An empty set. Often seen as a parameter in algorithms (breadth-first
    search, for example). |'
  prefs: []
  type: TYPE_TB
- en: '| ℤ | Set of all integers (1, 2, 3, . . .) − ∞ to ∞. Can also be used for a
    subset of integers with a defined membership parameter (such as all multiples
    of 3). |'
  prefs: []
  type: TYPE_TB
- en: '| ℝ | Set of all real numbers (0.25, 1.0, 2.3, . . .) Often just 0.0–1.0 with
    a scaling factor. |'
  prefs: []
  type: TYPE_TB
- en: Attribute Characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Special attribute symbols are another case where mathematicians love to overload
    the meanings of symbols. They’re used in formulas to denote special conditions
    for variables, function outputs, sets, and the like. They’re also used to distinguish
    related variables that may share a letter (which suggests that they’re related).
    For example, (*y* – *ŷ*) is often used to denote the difference between the actual
    and predicted values of some regression function. The variable *ŷ* holds the predicted
    value, and a difference closer to 0 denotes a more accurate prediction. This notation
    allows us to intuitively understand that the variables are related to each other,
    while distinguishing the one of particular interest with the attribute character.
  prefs: []
  type: TYPE_NORMAL
- en: When an attribute character is used in this text, it will be accompanied by
    a description of its intended meaning in that context.
  prefs: []
  type: TYPE_NORMAL
- en: Greek Letters and Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let’s discuss the use of the Greek alphabet to denote different variables,
    functions, and so on. I mentioned one of these symbols already, theta (θ), and
    how its interpretation is context-driven. You’re probably already familiar with
    some of the others as well. Some will be used fairly consistently, such as pi
    (π), which will always denote half the circumference of a circle. Others, such
    as alpha (α), will be used more liberally. To maintain clarity, we’ll discuss
    the meaning of these symbols in the context of each formula that includes them.
    [Table 2-4](#table2-4) outlines some common functions that are also denoted using
    symbols for shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-4: Function Notation Examples'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name/symbol** | **Common interpretation** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ABS &#124;A&#124; | Absolute value of *A*. Can also be the length of a vector
    or array (the number of items contained within the array). | &#124; [ a,b,c ]
    &#124; = 3 or &#124; 3 − 5 &#124; = 2 |'
  prefs: []
  type: TYPE_TB
- en: '| SUM ![m02004](image_fi/502567c02/m02004.png) | Sum of performing a function
    *F* some number of times from *i* to *j*. | ![m02005](image_fi/502567c02/m02005.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PROD ![m02006](image_fi/502567c02/m02006.png) | Product of performing a function
    *F* some number of times from *i* to *j*. | ![m02007](image_fi/502567c02/m02007.png)
    |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learning to interpret the symbols and remembering how to apply them is the most
    daunting part of proof-of-concept engineering. From here on, the actual math we’ll
    be doing is quite simple. If you’ve completed an algebra course and know how to
    perform addition, subtraction, multiplication, and division, the coming projects
    will be no problem for you to understand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we’ll begin discussing the important fields of mathematical
    theory and building projects to prove their usefulness. Each theory chapter and
    the accompanying projects are meant to illustrate some of the theories security
    researchers can benefit from applying in their tool development immediately. They
    aren’t meant to be a comprehensive treatise on any one theory or any particular
    security topic. I hope that, by the end of the projects, you begin to see the
    vast number of ways in which programming applied mathematical concepts can impact
    your work in security and your daily life.
  prefs: []
  type: TYPE_NORMAL
