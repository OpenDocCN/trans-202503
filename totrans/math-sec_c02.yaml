- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Programming and Math Conventions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程与数学约定
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that you have an environment to work in, let’s discuss the programming language
    we’ll be using. This book assumes you have a basic familiarity with programming
    concepts such as loops, variables, conditionals, and functions, so this chapter
    isn’t meant to be a comprehensive introduction to Python. Rather, it’s intended
    to illustrate some finer points that will help you understand the examples in
    this book and in other tutorials. Of course, the programming in the book centers
    on implementing math concepts from research papers, so it’s equally important
    that we have a common understanding of the notation used in that type of material.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个工作环境，我们来讨论一下我们将使用的编程语言。本书假设你对编程概念如循环、变量、条件语句和函数有基本的了解，因此本章并不打算作为 Python
    的全面介绍。相反，它旨在说明一些更细微的要点，这些要点将帮助你理解本书中的示例以及其他教程中的示例。当然，本书的编程内容主要集中在实现研究论文中的数学概念，因此我们对这类材料中使用的符号有一个共同的理解同样非常重要。
- en: Syntactical Constructs
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法构造
- en: Although this book isn’t meant to serve as an introduction to Python programming,
    there are some useful syntactical constructs you should be familiar with before
    diving in. It’s important to balance the use of these more advanced features to
    maintain the readability and understandability of your code. I’ve used the constructs
    described in this section throughout the book’s projects for code brevity. If
    you’re still learning Python, some of the syntax may seem daunting at first, but
    once you apply these constructs a few times in your own code you’ll wonder how
    you ever got anything done without them!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书并不打算作为 Python 编程的入门教材，但在深入之前，你应该熟悉一些有用的语法构造。平衡使用这些高级特性非常重要，以保持代码的可读性和易理解性。在本书的项目中，我使用了本节中描述的构造，以简化代码。如果你还在学习
    Python，刚开始可能会觉得某些语法有些令人生畏，但一旦你在自己的代码中使用这些构造几次后，你会惊讶于没有它们你是如何完成工作的！
- en: List Comprehensions
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表推导
- en: 'Comprehension constructs come in handy whenever you need to create a list (or
    dictionary) of values by iterating over some code. The simplest use case is to
    apply a function to every element in a list. For example, suppose you have a list
    of strings, called `names`, that you want to convert to uppercase. You could use
    a loop similar to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要通过遍历一些代码来创建一个值的列表（或字典）时，理解构造非常有用。最简单的使用场景是对列表中的每个元素应用一个函数。例如，假设你有一个字符串列表，叫做`names`，你想将它转换为大写。你可以使用类似下面的循环：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But there are a couple of downsides to this method. First, it requires two
    lists: one for inputs (`names`) and one for outputs (`names_2`). When you have
    very large lists of complex objects, copying the whole list in memory for a simple
    change like this is inefficient. You could add more code to overwrite names with
    the contents of `names_2` and then free up the memory used by `name_2` explicitly,
    but that’s a pain and makes the code messy. This leads us to the second problem:
    the code takes up more lines than necessary. In complex applications you may have
    hundreds of functions to maintain. Keeping your code concise saves you time when
    writing and modifying your code in large code bases. You could condense the whole
    process into a single line like so:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种方法也有一些缺点。首先，它需要两个列表：一个用于输入（`names`），一个用于输出（`names_2`）。当你有非常大的复杂对象列表时，像这样为了简单的改变而复制整个列表到内存是低效的。你可以添加更多的代码，用`names_2`的内容覆盖`names`，然后显式地释放`names_2`所占用的内存，但那样做既麻烦又让代码显得混乱。这引出了第二个问题：代码占用了比必要更多的行。在复杂的应用中，你可能需要维护数百个函数。保持代码简洁能在编写和修改大型代码库时节省时间。你可以将整个过程浓缩成一行代码，像这样：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a list comprehension, the first variable defines what will be stored in
    the resulting list. In this case `n` is a string we’re converting to uppercase,
    hence `n.upper`. We define the values for `n` using the `for` statement to its
    right, which iterates through the `names` list and selects each `n`. The resulting
    list is then assigned directly to the `names` variable, overwriting its previous
    value and freeing up the memory used by the loop automatically. We can add some
    conditional logic to the end of the statement to filter the results. For example,
    suppose we want to also filter the `names` list on whether the first letter of
    each string is `m`. Once again, you could write this as a loop with a block of
    code like the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式中，第一个变量定义了结果列表中将存储的内容。在这种情况下，`n` 是我们要转换为大写的字符串，因此是 `n.upper`。我们通过右边的 `for`
    语句定义 `n` 的值，该语句会遍历 `names` 列表并选择每个 `n`。然后，结果列表会直接赋值给 `names` 变量，覆盖其先前的值，并自动释放循环所使用的内存。我们可以在语句末尾添加一些条件逻辑来过滤结果。例如，假设我们想根据每个字符串的首字母是否是
    `m` 来过滤 `names` 列表。你可以像下面这样写一个循环块：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now within each iteration of the `for` loop we have a conditional statement
    to check if the string starts with `m` and, if so, it appends the uppercase version
    to the `m_names_upper` list. This method suffers from the same drawbacks as the
    previous loop example, though, and takes up even more space! This code can also
    be shortened to a single line with a list comprehension:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `for` 循环的每次迭代中，我们有一个条件语句来检查字符串是否以 `m` 开头，如果是，它会将大写版本追加到 `m_names_upper`
    列表中。然而，这种方法和之前的循环示例有相同的缺点，而且占用了更多的空间！这段代码也可以通过列表推导式缩短为一行：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve added some conditional logic to the end of the list comprehension statement
    to filter the results; again, we’ll add `n.upper` only if `n` starts with an `m`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表推导式语句的末尾添加了一些条件逻辑来过滤结果；同样，只有当 `n` 以 `m` 开头时，我们才会添加 `n.upper`。
- en: 'The two examples will produce the same output; it’s open for debate which is
    simpler or easier to explain, so the approach you choose will often be a matter
    of preference. Note that you can add an `else` condition to the list comprehension
    to control what happens in the event the `if` returns `False`. In cases where
    the conditional logic is `False`—for example, when a function expects two lists
    to be the same length so it can do some pairwise manipulation on the values—you
    might want to add a static value to your output list rather than excluding the
    element altogether. Let’s say we want to rename everyone whose name doesn’t start
    with `m` to `marcus`. With a traditional loop structure, this requires adding
    an `else` block after the `if` block to handle inserting the value. I’ll skip
    that, as we’ve all seen `else` blocks in Python (hopefully), and we’re discussing
    list comprehensions. Adding the additional `else` clause to a list comprehension
    changes the syntax so the `if...else` logic comes before the `for` loop logic,
    which looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子会产生相同的输出；哪个更简单或者更容易解释是可以争论的，所以你选择的方式通常是个人偏好的问题。请注意，你可以在列表推导式中添加 `else`
    条件来控制 `if` 返回 `False` 时发生的情况。在条件逻辑为 `False` 的情况下——例如，当一个函数期望两个列表具有相同的长度，以便对其中的值进行配对操作——你可能希望向输出列表添加一个静态值，而不是完全排除该元素。假设我们想要将所有名字不以
    `m` 开头的人重命名为 `marcus`。使用传统的循环结构，这需要在 `if` 块之后添加一个 `else` 块来处理插入值。我会跳过这一部分，因为我们都见过
    Python 中的 `else` 块（希望如此），而我们现在讨论的是列表推导式。向列表推导式添加额外的 `else` 子句会改变语法，使得 `if...else`
    逻辑出现在 `for` 循环逻辑之前，像这样：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the `if` statement moves directly after the variable to be stored,
    `n`. You then add the `else` condition, which defines the value to be added to
    the output list `m_names` in cases where the `if` statement is `False`. In this
    example, if a name starts with an `m`, it will be added to the output list; otherwise,
    the string literal `marcus` will be added instead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`if` 语句紧跟在要存储的变量 `n` 后面。然后，你添加 `else` 条件，它定义了在 `if` 语句为 `False` 时将添加到输出列表
    `m_names` 中的值。在这个例子中，如果一个名字以 `m` 开头，它将被添加到输出列表中；否则，字符串字面量 `marcus` 将会被添加。
- en: There are plenty of more practical uses for list comprehensions, and you’ll
    see them sprinkled through the code in this book and other examples, so it’s best
    to become familiar with them and how they translate into more traditional looping
    code structures. It’s also important to understand the limitations of list comprehensions.
    If your conditional selection logic is fairly complex, you might want to consider
    abstracting it to its own function. You can then use the function in a list comprehension
    to apply it to each element (a method you’ll see used in this book as well). The
    only real limitations within the list comprehension itself are that you can apply
    only one conditional statement, and the output at the end of each iteration must
    be something that can be included in a Python list object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式有许多更实际的用途，你将在本书和其他示例的代码中看到它们的身影，因此最好熟悉它们以及它们如何转化为更传统的循环代码结构。同样，理解列表推导式的局限性也很重要。如果你的条件选择逻辑比较复杂，你可能需要考虑将其抽象为一个单独的函数。然后，你可以在列表推导式中使用该函数，并将其应用于每个元素（这种方法你也会在本书中看到）。列表推导式本身的唯一真正限制是，你只能应用一个条件语句，并且每次迭代结束时的输出必须是可以包含在
    Python 列表对象中的内容。
- en: Dictionary Comprehensions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'Dictionaries are one of the most prevalent data structures in Python. They
    are used for everything from simple key/value pairing up to handling complex,
    user-defined classes. Luckily they are also extremely easy to work with, and a
    lot of the concepts we just discussed for list comprehensions apply equally well
    to defining dictionary objects, though you’ll tend to run across fewer examples
    in the wild. As an illustration, consider the following code, which merges a list
    of keys with an accompanying list of values:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是 Python 中最常见的数据结构之一。它们用于从简单的键/值配对到处理复杂的用户定义类等各种场景。幸运的是，字典也非常容易使用，我们刚才讨论的关于列表推导式的很多概念同样适用于定义字典对象，尽管你在实际应用中可能会遇到的例子较少。作为说明，考虑以下代码，它将一个键的列表与一个值的列表合并：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once again, the power of dictionary comprehension allows us to shorten this
    code block to a single line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，字典推导式的强大功能使我们能够将这段代码缩短为一行：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You may notice there are only a few differences between the list comprehension
    and the dictionary comprehensions syntax. Python’s developers have done this to
    make them both easier to understand in relation to each other. If you understand
    list comprehensions, then you understand 90 percent of dictionary comprehensions.
    The two things to remember are: dictionaries are defined using braces `{}` instead
    of square brackets, and the left part before the `for` keyword expresses both
    a key and a value, separated by a colon. Here, we define our key as the *i*th
    value in the list called `keys`. We’re assigning the value for that key from the
    second list, `values`, using the same index, *i*. We then define a `for` statement
    that loops over the integer values between 0 and the length of the `keys` list
    using the `range` function. This is an example of a function that naively assumes
    both the `keys` and `values` lists are the same length. If `keys` is ever longer
    than `values`, this code will raise an error when it attempts to access a nonexistent
    index on `values`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，列表推导式和字典推导式的语法之间只有少数几个差异。Python 的开发者这样做是为了使它们之间的关系更容易理解。如果你理解了列表推导式，那么你就理解了
    90% 的字典推导式。需要记住的两点是：字典是使用大括号 `{}` 来定义的，而不是方括号，并且 `for` 关键字前的左侧部分表示一个键和值，用冒号分隔。在这里，我们将键定义为名为
    `keys` 的列表中的第 *i* 个值。我们通过使用相同的索引 *i* 从第二个列表 `values` 中为该键分配值。然后我们定义一个 `for` 语句，使用
    `range` 函数循环遍历从 0 到 `keys` 列表长度之间的整数值。这是一个假设 `keys` 和 `values` 列表长度相同的函数示例。如果
    `keys` 的长度大于 `values`，当尝试访问 `values` 中一个不存在的索引时，代码会引发错误。
- en: 'You can also use a function to define both the key variable and the value variable,
    like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个函数来定义键变量和值变量，像这样：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example we’ve changed the previous code so all the keys are converted
    to uppercase and all the values are cast to `float`. We could, of course, replace
    these functions with anything that suits our needs. As long as the result for
    each function can be used as a key or value in a regular Python dictionary, the
    function can be used. The same caveat applies to this conditional logic as with
    list comprehensions. If you need more complex logic, you should consider abstracting
    the key and value definition into its own function, like so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们修改了之前的代码，使所有的键都被转换为大写字母，所有的值都被转换为`float`。当然，我们可以将这些函数替换为任何符合我们需求的函数。只要每个函数的返回结果能够作为常规
    Python 字典中的键或值，就可以使用该函数。与列表推导式一样，这里的条件逻辑也有一个注意事项。如果需要更复杂的逻辑，应该考虑将键和值的定义提取到一个独立的函数中，像这样：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here the keys and values are being defined by the return value from the function
    call `my_logic(keys)`. It doesn’t matter what this function does; all that matters
    is that the function returns a list that contains tuples (or nested lists) that
    each contain two items. The first item in each tuple will be treated as the key
    `k`, and the second item as the corresponding value. And there’s the dirty little
    secret of dictionary comprehensions: they’re really just list comprehensions in
    disguise! You may have already realized this because the `range` function produces
    a list as well. This is a handy shortcut when you want to run a function on every
    item in a list and store the result as a dictionary that relates the item with
    the result of calling the function on that item.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的键和值是通过函数调用`my_logic(keys)`的返回值来定义的。这个函数的具体作用并不重要；重要的是，函数返回的是一个包含元组（或嵌套列表）的列表，每个元组包含两个元素。每个元组中的第一个元素将被视为键`k`，第二个元素则是对应的值。这就是字典推导式的小秘密：它们其实只是伪装成字典的列表推导式！你可能已经意识到这一点，因为`range`函数也会生成一个列表。当你希望对列表中的每个项执行某个函数，并将结果作为字典保存，关联每个项及其函数调用结果时，这是一个非常方便的快捷方式。
- en: Zipping and Unpacking
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打包与解包
- en: 'Python’s built-in `zip` function returns an iterator of tuples, where the *i*th
    tuple contains the *i*th element from each argument passed in. Suppose you wanted
    to combine the previous list of names stored in `names` with the list of colors
    and numbers stored in `keys` and `values`, respectively. The `zip` function will
    allow you to efficiently generate these combinations as a list of tuples, again
    with a single line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内建的`zip`函数返回一个元组迭代器，其中第*i*个元组包含从每个传入参数中提取的第*i*个元素。假设你想将之前存储在`names`中的姓名列表与分别存储在`keys`和`values`中的颜色和数字列表结合起来。`zip`函数将允许你高效地生成这些组合，以元组列表的形式，并且只需一行代码：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The variable `a` now holds a `zip` object that, when cast to a list, will contain
    triples like `("bob","Red",1)`. It’s important to pay attention to the order in
    which you pass the lists, as left-to-right processing is guaranteed. Also be aware
    that the iterator stops when the shortest-length input is exhausted. Unpacking
    is the reverse of the `zip` function, but it’s a behavior of Python rather than
    a function that you need to call. For example, you can unpack the three values
    that make up the first item in the `zip` object `a` like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`现在持有一个`zip`对象，当它被转换为列表时，将包含像`("bob","Red",1)`这样的三元组。需要注意的是，传入列表的顺序很重要，因为从左到右的处理顺序是保证的。还需要留意，迭代器会在最短的输入耗尽时停止。解包是`zip`函数的逆操作，但它是
    Python 的一种行为，而不是一个需要调用的函数。例如，你可以像下面这样解包`zip`对象`a`中第一个元组的三个值：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This line of code takes the three values in the first tuple in `a` and assigns
    them to the three variables (left-to-right order) on the left side of the equal
    sign. You must have the same number of variables as items in the tuple, or the
    code will raise an exception. Zipping and unpacking are useful when you want to
    transport data around your application. Rather than defining multiple variables
    to hold the three output lists, we can apply the `zip` function to return a single
    `zip` object, which preserves the relationship between all three lists. You can
    then iterate over the results and unpack the values into distinct variables as
    needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码将`a`中第一个元组的三个值分配给等号左侧的三个变量（从左到右的顺序）。你必须确保变量的数量与元组中的元素数量一致，否则代码将抛出异常。打包和解包在你需要在应用程序中传输数据时非常有用。与其定义多个变量来保存三个输出列表，我们可以应用`zip`函数来返回一个单一的`zip`对象，这样可以保留三个列表之间的关系。然后，你可以遍历结果，并根据需要将值解包到不同的变量中。
- en: The rest of the code you see will be pretty standard Python. I’ll point out
    the syntax for specific libraries as we come to use them in our projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的其余代码将是标准的 Python 代码。当我们在项目中使用特定库时，我会指出相关的语法。
- en: Next, we’ll dive into the exciting world of math notation. As you’ll see, understanding
    the symbols used plays a crucial role in advanced mathematics. It provides a flexible
    form of shorthand that makes the formulas easier to remember. Unfortunately, as
    with programming, these symbols can take on multiple meanings. Mathematical notations
    often have a dual nature since they can signify both the math being performed
    and variables on which it’s being performed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨数学符号的精彩世界。正如你将看到的，理解所使用的符号在高级数学中扮演着至关重要的角色。它提供了一种灵活的速记形式，使得公式更容易记住。不幸的是，与编程类似，这些符号可以具有多重含义。数学符号通常具有双重性质，因为它们既可以表示正在进行的数学操作，也可以表示执行这些操作的变量。
- en: Mathematical Notation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学符号
- en: Mathematical notation is a tricky beast, especially when you intend to cover
    more than one field in a text. The reason is that a lot of mathematical symbols
    are *overloaded*, meaning they have many possible meanings, and to know which
    meaning applies, you need to look at the context. A perfect example of this is
    the Greek letter theta, θ. In machine learning literature, θ usually refers to
    the set of feature weights calculated for a set of data. This “hypothesis” function
    is commonly seen in the first weeks of machine learning, when linear regression
    models are covered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数学符号是一个棘手的领域，尤其是当你试图在文本中涵盖多个领域时。原因是许多数学符号是*重载*的，这意味着它们有许多可能的含义，要知道适用的是哪一种含义，就需要查看上下文。一个完美的例子是希腊字母θ。在机器学习文献中，θ通常指的是为一组数据计算出的特征权重集。这个“假设”函数常见于机器学习的前几周，通常会讲解线性回归模型。
- en: '![](image_fi/502567c02/m02001.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c02/m02001.png)'
- en: However, in geometry and trigonometry, θ is often used as a “degrees” variable—for
    example, in the Pythagorean theorem, as shown in [Figure 2-1](#figure2-1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在几何学和三角学中，θ通常用作“角度”变量——例如，在[图2-1](#figure2-1)所示的勾股定理中。
- en: '![](image_fi/502567c02/f02001.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c02/f02001.png)'
- en: 'Figure 2-1: The Pythagorean theorem using theta to represent an angle in degrees'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：使用θ表示角度（度数）的勾股定理
- en: Where possible, I stick to the notation used in the prevailing material on the
    subject. In cases where the notation becomes overloaded, I’ve included explanations
    of the intended meanings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我坚持使用该领域内主流材料中使用的符号。在符号出现重载的情况下，我会附上意图含义的解释。
- en: Boolean Notation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔符号
- en: One of the most often applied (and most often overlooked) concepts you’ll see
    in applied mathematics is Boolean algebra. A *Boolean* is a primitive data type
    that can hold only one of two possible values at any given moment. The value is
    determined by the *logical statement* that accompanies it. For example, we can
    ask if two numbers, *x* and *y*, are equal to each other. The answer to this question
    will always be yes or no, depending on the inputs. There will never be a case
    that produces a third answer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用数学中，你会看到最常用（也是最常被忽视）的一项概念就是布尔代数。*布尔*是一种原始数据类型，在任何给定时刻，它只能承载两个可能的值之一。该值由与之相关的*逻辑语句*决定。例如，我们可以问两个数字，*x*
    和 *y*，是否相等。这个问题的答案始终是“是”或“否”，取决于输入值。永远不会出现第三种答案。
- en: Boolean symbols are most often denoted in the form of a *truth table*. In the
    interest of saving space, I haven’t included any full truth tables in this book;
    you can find many excellent references for these tables online. We’ll focus instead
    on the symbols used to write the logical statements and how you can interpret
    them. [Table 2-1](#table2-1) covers each of the major Boolean algebra symbols
    and the intuitive meaning, with an example of the logic applied to a statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔符号通常以*真值表*的形式表示。为了节省空间，我没有在本书中包含完整的真值表；你可以在网上找到许多关于这些表的优秀参考资料。我们将重点讨论用于编写逻辑语句的符号以及如何解释它们。[表2-1](#table2-1)涵盖了每个主要的布尔代数符号及其直观意义，并提供了将逻辑应用于语句的示例。
- en: 'Table 2-1: Boolean Logic Examples'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：布尔逻辑示例
- en: '| **Notation** | **Meaning** | **Example** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| AND: A ∧ B | Both *A* and *B* must be `True` for the statement to be `True`.
    Algebraically, *A* × *B* or just *AB*. | *Cats are mammals* AND *planes fly* is
    `True` since both statements are `True`. If either statement is `False`, the whole
    statement is `False` (equal to `0`). |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 与：A ∧ B | 只有当 *A* 和 *B* 都为 `True` 时，整个语句才为 `True`。在代数中，*A* × *B* 或者仅为 *AB*。
    | *猫是哺乳动物* 与 *飞机会飞* 为 `True`，因为两个语句都是 `True`。如果任何一个语句为 `False`，整个语句就会是 `False`（等于
    `0`）。 |'
- en: '| OR: A ∨ B | If either *A* or *B* or both *A* and *B* are `True`, this statement
    is `True`. Algebraically, *A* + *B*. | *Cats are dogs* OR *birds are cats* is
    `False` because neither *A* nor *B* is `True`. Changing either or both to `True`
    statements would change the result. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 或：A ∨ B | 只要 *A* 或 *B* 或者 *A* 和 *B* 中的任何一个为 `True`，整个语句就是 `True`。在代数中，*A*
    + *B*。 | *猫是狗* 或 *鸟是猫* 为 `False`，因为 *A* 和 *B* 都不是 `True`。如果其中任何一个语句改为 `True`，结果就会改变。
    |'
- en: '| NOT: ¬ A, À | This statement is `True` when the statement *A* is `False`.
    It is an inverter that outputs the opposite of its input. | If *A* represents
    the statement *cats are fish*, this could be written as *NOT cats are fish*. *NOT
    cats are fish* is `True` because the statement *ca**ts are fish* is `False`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 非：¬ A, À | 当语句 *A* 为 `False` 时，该语句为 `True`。它是一个反转器，输出其输入的相反值。 | 如果 *A* 代表语句
    *猫是鱼*，这可以写作 *非猫是鱼*。*非猫是鱼* 为 `True`，因为语句 *猫是鱼* 为 `False`。 |'
- en: '| XOR: A ⊕ B | If either *A* or *B* but NOT both *A* and *B* are `True`, this
    statement is `True`. Algebraically, ( AB̀ ) + ( ÀB ). | *The shirt is red* XOR
    *the shirt is blue* is `True` if the shirt is either red or blue, but not both
    red and blue. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 异或：A ⊕ B | 如果 *A* 或 *B* 其中之一为 `True`，但 *A* 和 *B* 都不是 `True`，则该语句为 `True`。在代数中，(
    AB̀ ) + ( ÀB )。 | *衬衫是红色的* 异或 *衬衫是蓝色的* 为 `True`，如果衬衫是红色或蓝色，但不是同时是红色和蓝色。 |'
- en: These deceptively simple components can be used to describe the most arbitrarily
    complex systems known to humankind through the use of chained Boolean statements.
    It’s very important to be aware of the order of operations and placement of parentheses
    in Boolean expressions. Operator precedence is the same as in traditional algebra,
    with fewer functions. Any operations inside parentheses are handled first, followed
    by any AND conditions (multiplication), and finally, OR statements (addition).
    Negations are handled during the final step of the operation being negated, so
    they don’t need any special handling. Traditionally we evaluate multiple parentheses
    from left to right.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看似简单的组件可以通过链式布尔语句来描述人类已知的最复杂的系统。了解布尔表达式中的操作顺序和括号的使用非常重要。运算符优先级与传统代数相同，但功能较少。括号内的运算优先进行，然后是所有的
    AND 条件（乘法），最后是 OR 语句（加法）。否定操作在操作的最终步骤中处理，因此无需特别处理。传统上，我们从左到右评估多个括号。
- en: Most runtime environments, like Python’s interpreter, stop evaluating as soon
    as the truth of a statement can be determined. They won’t continue to check additional
    statements that can no longer change the result. For example, the logical statement
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运行时环境，比如 Python 的解释器，会在一旦语句的真假能够确定时就停止评估。它们不会继续检查那些已不再影响结果的其他语句。例如，逻辑语句
- en: ( Cats fly ∧ dogs bark )
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ( 猫会飞 ∧ 狗会吠 )
- en: will first check the *Cats fly* statement. Since this is `False`, the value
    of the second statement can’t impact the result of the AND statement. Python determines
    that the total statement is `False` without ever checking the *dogs bark* condition.
    To understand how Python parses more complex logical statements, let’s look at
    another example. The statement
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 会首先检查 *猫会飞* 语句。由于这是 `False`，第二个语句的值不会影响 AND 语句的结果。Python 会判断整个语句为 `False`，而无需检查
    *狗会吠* 的条件。为了理解 Python 如何解析更复杂的逻辑语句，我们来看另一个例子。语句
- en: ( Cats meow ∧ dogs bark ) ⊕ ( Fish swim ∧ ¬birds fly )
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ( 猫叫 ∧ 狗吠 ) ⊕ ( 鱼会游 ∧ ¬鸟会飞 )
- en: is evaluated in the interpreter as follows. First the parentheses group
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释器中按如下方式评估。首先，括号内的语句
- en: ( Cats meow ∧ dogs bark )
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ( 猫叫 ∧ 狗吠 )
- en: is evaluated. It is `True`, because both statements it contains are `True` (cats
    do meow and dogs do bark). Since the second set of parentheses can still affect
    the outcome (a XOR operation always requires us to evaluate both sides),
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 被评估。它为 `True`，因为它包含的两个语句都为 `True`（猫会叫且狗会吠）。由于第二组括号仍然可能影响结果（XOR 操作总是要求我们评估两边），
- en: ( Fish swim ∧ ¬birds fly )
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ( 鱼会游 ∧ ¬鸟会飞 )
- en: is evaluated next. The negation on *birds fly* makes this second statement `False`
    (*birds fly* is `True`, so *NOT birds fly* is `False`). Now we evaluate the XOR
    operation
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来进行求值。*鸟飞*的否定使得第二个陈述为 `False`（*鸟飞*是 `True`，所以 *NOT 鸟飞* 是 `False`）。现在我们求解 XOR
    操作
- en: ( AB̀) + ( ÀB )
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ( AB̀) + ( ÀB )
- en: where *A* is the result of the first parentheses group, and *B* is the result
    of the second parentheses group. We can solve this easily by recursively applying
    the operator precedence.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *A* 是第一个括号组的结果，*B* 是第二个括号组的结果。我们可以通过递归应用操作符优先级轻松解决这个问题。
- en: ( 1 × 0̀) + ( 1̀ × 0 ) = ( 1 × 1 ) + ( 0 × 0 ) = ( 1 + 0 ) = 1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ( 1 × 0̀) + ( 1̀ × 0 ) = ( 1 × 1 ) + ( 0 × 0 ) = ( 1 + 0 ) = 1
- en: We interpret a `1` to mean the overall statement
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `1` 解释为整体陈述
- en: ( Cats meow ∧ dogs bark ) ⊕ ( Fish swim ∧ ¬birds fly )
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ( 猫叫 ∧ 狗叫 ) ⊕ ( 鱼游 ∧ ¬鸟飞 )
- en: is `True`, which matches what we’d expect because XOR requires exactly one of
    the conditions to be `True` for the outcome to be `True`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是 `True`，这符合我们的预期，因为 XOR 运算要求条件中恰好有一个为 `True`，结果才为 `True`。
- en: Set Notation
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合符号
- en: In mathematics, we often want to denote groups of objects rather than individual
    objects. For example, we might say that all the students who go to a particular
    school make up a *set*. Each student can occur in the set only once.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，我们通常想表示一组对象，而不是单个对象。例如，我们可能会说，所有去同一所学校的学生构成一个 *集合*。每个学生在集合中只会出现一次。
- en: We could denote the set of students *S*. (I’ll follow the convention of using
    a capitalized English variable name for sets, with a few exceptions.) This defines
    what items are, or are not, considered to be part of the set. This is often called
    a *membership rule*. Now that we have a definition of membership, we can denote
    what items *i* are in the set (*i* ∈ *S*) or, of course, not in the set (*i* ∉
    *S*). In this example, *i* ∉ *S* is syntactically equivalent to saying, “All things
    that are not students at the defined school.” When dealing with multiple sets,
    we may be interested in which set contains an item (*S* ∋ *i*). Assuming we created
    a set for each school in a district, this would be equivalent to asking, “What
    school does a given student attend?” [Table 2-2](#table2-2) describes the symbols
    used throughout this text.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以表示学生集合 *S*。(我将遵循使用大写字母的英文变量名表示集合的惯例，尽管有一些例外)。这定义了哪些元素是或不是集合的一部分。这通常称为 *成员规则*。现在我们有了成员的定义，我们可以表示元素
    *i* 是否在集合中 (*i* ∈ *S*)，或者当然，它不在集合中 (*i* ∉ *S*)。在这个例子中，*i* ∉ *S* 与“所有不是该学校学生的东西”在语法上等价。当处理多个集合时，我们可能感兴趣的是哪个集合包含某个元素
    (*S* ∋ *i*)。假设我们为区内每个学校创建了一个集合，那么这就相当于问，“某个学生在哪所学校就读？”[表 2-2](#table2-2) 描述了本文中使用的符号。
- en: 'Table 2-2: Set Notation Examples'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2：集合符号示例
- en: '| **Notation** | **Meaning** | **Example** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| i ∈ S | Boolean: Item *i* in set *S*. | 3 in the set of odd integers is `True`.
    4 in the set of odd integers is `False`. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| i ∈ S | 布尔值：集合 *S* 中的元素 *i*。 | 3 在奇数集合中为 `True`。4 在奇数集合中为 `False`。 |'
- en: '| i ∉ S | Boolean: Item *i* not in set *S*. | 3 not in the set of odd integers
    is `False`. 4 not in the set of odd numbers is `True`. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| i ∉ S | 布尔值：集合 *S* 中不包含元素 *i*。 | 3 不在奇数集合中为 `False`。4 不在奇数集合中为 `True`。 |'
- en: '| S ∋ i | Boolean: Set *S* contains item *i*. | Set of odd integers contains
    7 is `True`. Set of cars contains a bicycle is `False`. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| S ∋ i | 布尔值：集合 *S* 包含元素 *i*。 | 奇数集合包含 7 为 `True`。汽车集合包含自行车为 `False`。 |'
- en: '| A ∩ B | Product: i ∈ A ∧ i ∈ B. All items in set *A* that are also in set
    *B*. | Will produce a set of all items that meet both *A* and *B*. If *A* is the
    set of all animals and *B* is the set of all mammals, a cat could be included
    in the product because it’s in both the set of animals and the set of mammals.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| A ∩ B | 乘积：i ∈ A 且 i ∈ B。所有同时在集合 *A* 和集合 *B* 中的元素。 | 会生成一个集合，包含所有同时满足 *A*
    和 *B* 的元素。如果 *A* 是所有动物的集合，*B* 是所有哺乳动物的集合，那么猫可以出现在这个乘积中，因为它既是动物集合中的元素，又是哺乳动物集合中的元素。
    |'
- en: '| A \ B | Product: ( i ∈ A ¬ i ∈ B ) + ( i ∈ B ¬ i ∈ A ). All items in set
    *A* that are not in set *B* plus all items in set *B* that are not in set *A*.
    | All topics from security that do not involve medical tech, plus all topics from
    medical tech that do not involve security. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| A \ B | 乘积： ( i ∈ A 且 i ∉ B ) + ( i ∈ B 且 i ∉ A )。所有在集合 *A* 中但不在集合 *B* 中的元素，加上所有在集合
    *B* 中但不在集合 *A* 中的元素。 | 所有与安全相关的、不涉及医疗技术的主题，加上所有与医疗技术相关的、不涉及安全的主题。 |'
- en: '| A ∪ B | Product: i ∈ A ∨ i ∈ B. All items in set *A* or in set *B* or in
    both sets. | All places that are gas stations or grocery stores or both a gas
    station and a grocery store. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| A ∪ B | 并集：i ∈ A ∨ i ∈ B。所有在集合 *A* 中或集合 *B* 中或两个集合中都有的项目。 | 所有是加油站或杂货店或同时是加油站和杂货店的地方。
    |'
- en: '| p ⊂ S, p ⊆ S | Boolean: Items in subset *p* are all in the superset *S*.
    If *p* can contain all the members of *S*, we use ⊆. | A subset of door locks
    is from the superset of all security devices is `True`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| p ⊂ S, p ⊆ S | 布尔值：子集 *p* 中的所有项目都在超集 *S* 中。如果 *p* 可以包含 *S* 中的所有成员，则使用 ⊆。
    | 门锁的子集是所有安全设备超集的一部分，这是`True`。 |'
- en: '| p ⊄ S | Boolean: One or more items in subset *p* is not in the superset *S*.
    | [Pear, Grape, Rock] is not a subset of foods is `True`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| p ⊄ S | 布尔值：子集 *p* 中的一个或多个项目不在超集 *S* 中。 | [梨子，葡萄，岩石] 不是食物的子集，这是`True`。 |'
- en: '| ∀ p ∈ S F | For all items *p* in *S*, apply function *F*. | For all the people
    in the room, say “hello.” |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| ∀ p ∈ S F | 对于集合 *S* 中的所有项目 *p*，应用函数 *F*。 | 对于房间里的所有人，说“你好”。 |'
- en: '| ![m02002](image_fi/502567c02/m02002.png) or nCk | The number of unordered
    combinations of *k* elements drawn from a set of *n* elements. Read “from *n*
    choose *k*.” | From [Ron, Tom, Ann] choose two names: ![m02003](image_fi/502567c02/m02003.png)
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| ![m02002](image_fi/502567c02/m02002.png) 或 nCk | 从 *n* 个元素中选取 *k* 个元素的无序组合的数量。读作“从
    *n* 中选择 *k*。” | 从 [Ron, Tom, Ann] 中选择两个名字：![m02003](image_fi/502567c02/m02003.png)
    |'
- en: Finally, there are a few reserved sets that come up so frequently that they’ve
    been given standardized symbols throughout most of the literature. You can find
    these listed in [Table 2-3](#table2-3).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些保留集合由于在文献中频繁出现，已经被赋予了标准化符号。你可以在[表 2-3](#table2-3)中找到它们的列表。
- en: 'Table 2-3: Reserved Sets'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3：保留集合
- en: '| **Notation** | **Membership rule** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **成员规则** |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ∅ | An empty set. Often seen as a parameter in algorithms (breadth-first
    search, for example). |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ∅ | 空集。常在算法中作为参数使用（例如广度优先搜索）。 |'
- en: '| ℤ | Set of all integers (1, 2, 3, . . .) − ∞ to ∞. Can also be used for a
    subset of integers with a defined membership parameter (such as all multiples
    of 3). |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| ℤ | 所有整数的集合（1，2，3，……） − ∞ 到 ∞。也可以用于具有定义成员参数的整数子集（例如所有 3 的倍数）。 |'
- en: '| ℝ | Set of all real numbers (0.25, 1.0, 2.3, . . .) Often just 0.0–1.0 with
    a scaling factor. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| ℝ | 所有实数的集合（0.25，1.0，2.3，……）。通常仅使用 0.0–1.0 以及一个缩放因子。 |'
- en: Attribute Characters
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性字符
- en: Special attribute symbols are another case where mathematicians love to overload
    the meanings of symbols. They’re used in formulas to denote special conditions
    for variables, function outputs, sets, and the like. They’re also used to distinguish
    related variables that may share a letter (which suggests that they’re related).
    For example, (*y* – *ŷ*) is often used to denote the difference between the actual
    and predicted values of some regression function. The variable *ŷ* holds the predicted
    value, and a difference closer to 0 denotes a more accurate prediction. This notation
    allows us to intuitively understand that the variables are related to each other,
    while distinguishing the one of particular interest with the attribute character.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊属性符号是数学家喜欢对符号进行多重赋义的另一种情况。它们在公式中用于表示变量、函数输出、集合等的特殊条件。它们还用于区分可能共享一个字母（暗示它们相关）的相关变量。例如，(*y*
    – *ŷ*) 常用来表示某个回归函数的实际值与预测值之间的差异。变量 *ŷ* 表示预测值，差异越接近 0，表示预测越准确。这种表示法让我们直观地理解这些变量之间的关系，同时通过属性字符区分出特别关注的变量。
- en: When an attribute character is used in this text, it will be accompanied by
    a description of its intended meaning in that context.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本中使用属性字符时，它将伴随一个描述，说明该字符在该上下文中的预期含义。
- en: Greek Letters and Functions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 希腊字母和函数
- en: Finally, let’s discuss the use of the Greek alphabet to denote different variables,
    functions, and so on. I mentioned one of these symbols already, theta (θ), and
    how its interpretation is context-driven. You’re probably already familiar with
    some of the others as well. Some will be used fairly consistently, such as pi
    (π), which will always denote half the circumference of a circle. Others, such
    as alpha (α), will be used more liberally. To maintain clarity, we’ll discuss
    the meaning of these symbols in the context of each formula that includes them.
    [Table 2-4](#table2-4) outlines some common functions that are also denoted using
    symbols for shorthand.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论使用希腊字母表示不同变量、函数等的方式。我已经提到过其中一个符号，theta（θ），以及它的解释是如何根据上下文来决定的。你可能已经熟悉其他一些符号了。有些符号会比较固定使用，比如
    pi（π），它总是表示圆的半径的一半。其他符号，比如 alpha（α），则会使用得更加自由。为了保持清晰性，我们将讨论这些符号在包含它们的每个公式中的含义。[表
    2-4](#table2-4)列出了使用符号缩写表示的一些常见函数。
- en: 'Table 2-4: Function Notation Examples'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4：函数表示法示例
- en: '| **Name/symbol** | **Common interpretation** | **Example** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **名称/符号** | **常见解释** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ABS &#124;A&#124; | Absolute value of *A*. Can also be the length of a vector
    or array (the number of items contained within the array). | &#124; [ a,b,c ]
    &#124; = 3 or &#124; 3 − 5 &#124; = 2 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| ABS &#124;A&#124; | *A* 的绝对值。也可以是向量或数组的长度（数组中包含的项数）。 | &#124; [ a,b,c ] &#124;
    = 3 或 &#124; 3 − 5 &#124; = 2 |'
- en: '| SUM ![m02004](image_fi/502567c02/m02004.png) | Sum of performing a function
    *F* some number of times from *i* to *j*. | ![m02005](image_fi/502567c02/m02005.png)
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| SUM ![m02004](image_fi/502567c02/m02004.png) | 对函数 *F* 从 *i* 到 *j* 执行若干次的和。
    | ![m02005](image_fi/502567c02/m02005.png) |'
- en: '| PROD ![m02006](image_fi/502567c02/m02006.png) | Product of performing a function
    *F* some number of times from *i* to *j*. | ![m02007](image_fi/502567c02/m02007.png)
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| PROD ![m02006](image_fi/502567c02/m02006.png) | 对函数 *F* 从 *i* 到 *j* 执行若干次的乘积。
    | ![m02007](image_fi/502567c02/m02007.png) |'
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Learning to interpret the symbols and remembering how to apply them is the most
    daunting part of proof-of-concept engineering. From here on, the actual math we’ll
    be doing is quite simple. If you’ve completed an algebra course and know how to
    perform addition, subtraction, multiplication, and division, the coming projects
    will be no problem for you to understand.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 学会解读这些符号，并记住如何应用它们，是概念验证工程中最具挑战性的部分。从现在开始，我们将进行的数学内容相当简单。如果你已经完成了代数课程，并且知道如何进行加法、减法、乘法和除法，那么接下来的项目你应该能够轻松理解。
- en: In the next chapters, we’ll begin discussing the important fields of mathematical
    theory and building projects to prove their usefulness. Each theory chapter and
    the accompanying projects are meant to illustrate some of the theories security
    researchers can benefit from applying in their tool development immediately. They
    aren’t meant to be a comprehensive treatise on any one theory or any particular
    security topic. I hope that, by the end of the projects, you begin to see the
    vast number of ways in which programming applied mathematical concepts can impact
    your work in security and your daily life.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开始讨论数学理论的重要领域，并构建项目来证明它们的实用性。每个理论章节和附带的项目旨在说明安全研究人员可以立即应用在工具开发中的一些理论。这些内容并不是为了成为某一理论或特定安全话题的全面论述。希望通过这些项目的完成，你能开始看到应用编程数学概念对安全工作和日常生活的巨大影响。
