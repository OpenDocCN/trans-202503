- en: '10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FINDING BUILD DEPENDENCIES WITH PKG-CONFIG
  prefs: []
  type: TYPE_NORMAL
- en: '*A common mistake that people make when trying to design something completely
    foolproof is to underestimate the ingenuity of complete fools.'
  prefs: []
  type: TYPE_NORMAL
- en: —Douglas Adams*, The Hitchhiker’s Guide to the Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s say your project depends on a library called *stpl*—some third-party library.
    How can your build system determine where *libstpl.so* is installed on an end
    user’s system? Where are *stpl*’s header files to be found? Do you simply assume
    */usr/lib* and */usr/include*? This is effectively what Autoconf does if you don’t
    tell it to look elsewhere, and for many packages perhaps that’s fine—it’s a common
    convention to install libraries and headers into these directories.
  prefs: []
  type: TYPE_NORMAL
- en: But what if they aren’t installed in these locations? Or perhaps they were built
    locally and installed into the */usr/local* tree. What compiler and linker options
    should be used when using *stpl* in your project? These are a few issues that
    have plagued developers from the beginning, and the Autotools don’t really do
    much to manage this problem. Autoconf expects any libraries you use to be installed
    into “standard places,” meaning into directories where the preprocessor and linker
    automatically look for header files and libraries. If a user has the library but
    it’s installed in a different location, the Autotools expect end users to know
    how to interpret the configuration failure. As it happens, there are several good
    reasons why many libraries are not installed in these standard places.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Autoconf can’t easily find libraries that are not installed at
    all. For example, you may have just built a library package and you want another
    package to pick up headers and libraries from the first package’s build directory
    structure. This is possible with Autoconf, but it involves the end user setting
    variables like `CPPFLAGS` and `LDFLAGS` on the `configure` command line. The project
    maintainer can make things a little easier by providing user-specified configuration
    options with the `AC_ARG_ENABLE` and `AC_ARG_WITH` macros for libraries they anticipate
    might not be easy to find in standard places, but if your project uses a lot of
    third-party libraries, it’s just guesswork trying to determine which of these
    will be particularly problematic for users. And then, users are not often programmers;
    we cannot rely on them to have enough background to know what to use for option
    values, even if we do supply command line options for problematic dependencies.
    Throughout this chapter, I’ll refer to these as *build dependency issues*.
  prefs: []
  type: TYPE_NORMAL
- en: There is a tool that provides a solution for these types of problems in a more
    elegant fashion using a very common tactic in software design—by providing another
    layer of indirection. And it’s not part of the GNU Autotools. Regardless, its
    use has become so prolific over the past 20 years that it would be an oversight
    to exclude a description of *pkg-config* in any book that discusses Linux build
    systems. Pkg-config is as useful as it is today because a lot of projects have
    begun to use it—especially library projects, and most especially library projects
    that install into nonstandard locations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at pkg-config’s components and functionality and
    how to use it in your projects. For your own library projects, we’ll also discuss
    how to update the pkg-config database as your package is installed onto users’
    (or as I like to call them, potential contributors’) systems.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, allow me to state up front that this chapter makes a
    lot of references to filesystem objects that may or may not exist on your flavor
    of Linux, or perhaps exist in a different form or location. It’s the nature of
    what we’re doing here—we’re discussing packages with libraries and header files
    that probably exist in different locations on different Linux flavors. I’ll try
    to point out such potential differences as we come to them so you’ll not be too
    surprised when things don’t line up exactly on our two systems.
  prefs: []
  type: TYPE_NORMAL
- en: A pkg-config Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pkg-config is an open source software utility maintained by the *[freedesktop.org](http://freedesktop.org)*
    project. The pkg-config website is a part of the [freedesktop.org](http://freedesktop.org)
    project website. The pkg-config project is the result of an effort to turn the
    `gnome-config` script—a part of the gnome build system—into a more general-purpose
    tool, and it seems to have caught on. Some inspiration for pkg-config also came
    from the `gtk-config` program.
  prefs: []
  type: TYPE_NORMAL
- en: A NOTE ABOUT PKG-CONFIG CLONES
  prefs: []
  type: TYPE_NORMAL
- en: The [freedesktop.org](http://freedesktop.org) pkg-config project has been around
    for a long time and has garnered a somewhat loyal following. As a direct result,
    other projects now exist that offer functionality that is similar—often identical—to
    the pkg-config project. One that comes to mind is the pkgconf project (which Red
    Hat’s Fedora Linux seems to prefer when you ask the `yum` package manager to install
    pkg-config for you).
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse these two. The pkgconf project is a modern clone of the original
    pkg-config project that comes with claims of higher efficiency—and as far as I’m
    concerned, it may very well live up to these claims. Regardless, this chapter
    is about pkg-config. If you’ve found a project that provides functionality similar
    to pkg-config and you like it, then by all means use it. My goal here is to teach
    you about pkg-config. If this material helps you understand how to use pkgconf,
    or another pkg-config clone, then you’re getting from this book exactly what I
    hoped to convey.
  prefs: []
  type: TYPE_NORMAL
- en: That said, however, I cannot cover all of the nuanced differences among the
    different pkg-config clones. If you want to follow along with my examples and
    your flavor of Linux won’t install the original pkg-config package for you, you
    can always navigate in your browser to *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*
    and download and install version 0.29.2 of the original pkg-config project
  prefs: []
  type: TYPE_NORMAL
- en: Pkg-config is used simply by invoking the `pkg-config` command line utility
    with options that display the desired data. When you’re looking for libraries
    and header files, the “desired data” includes package version information as well
    as compiler and linker options wherein library and header file locations are specified.
    For instance, to obtain C-preprocessor flags required to access a library’s header
    files, one need only specify the `--cflags` option on the `pkg-config` command
    line, and compiler options appropriate for the package are displayed to `stdout`.
    This display can be captured and appended to compiler command lines in your configuration
    scripts and makefiles as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’re wondering why we even need a tool like `pkg-config` when Autoconf
    provides the `AC_CHECK_LIB` and `AC_SEARCH_LIBS` macros. In the first place, as
    I mentioned previously, the Autoconf macros are designed to only look in “standard
    locations” for libraries. You can trick the macros into looking in other places
    by preloading search paths into `CPPFLAGS` (using `-I` options) and `LDFLAGS`
    (using `-L` options). However, pkg-config is designed to help you find libraries
    that may be installed in places only your users’ pkg-config installations know
    about; the best thing about pkg-config is that it knows how to find libraries
    and headers on end users’ systems that these users don’t even know about. Pkg-config
    can also tell your build system about additional dependencies required when your
    users are trying to statically link to your libraries. Therefore, it effectively
    hides such details from users, and that’s the sort of user experience we’re looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, some caveats to using pkg-config with the Autotools. In
    the first edition of this book, I suggested that the `PKG_CHECK_MODULES` add-on
    M4 macro that’s shipped with pkg-config was a good approach to using it with Autoconf.
    I’ve since amended my thoughts on this issue as I’ve discovered over the years
    that the use of this macro can cause more problems than it solves under some rather
    common conditions. Additionally, `pkg-config` is so simple to use directly in
    shell script that it makes little sense to wrap it with less-than-transparent
    M4 macros. We’ll discuss this topic in much more detail in this chapter, but I
    wanted to set the stage for the pattern of use you’ll see in the examples that
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: Diving In
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the output of the `--help` option for the `pkg-config`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I’ve only shown what I consider the most useful options here. There are another
    dozen or so, but these are the ones we’ll use all the time in our *configure.ac*
    files. (I’ve taken the liberty of wrapping long description lines as pkg-config
    seems to think everyone has a 300-column monitor.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by listing all of the modules pkg-config is aware of on the system.
    Here’s a sampling of the ones on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pkg-config becomes *aware* of a package by having the package installation process
    update the pkg-config database, which is nothing more than a well-known directory
    that `pkg-config` examines to resolve queries. The database entries are simply
    plaintext files ending in a *.pc* extension. Therefore, making pkg-config aware
    of your library project during installation is nothing more difficult than generating
    and installing a text file, and Autoconf can help us generate this file, as we’ll
    see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pkg-config` utility looks in several directories to find these files.
    We can discover what directories it looks in, and the order of the search, by
    calling it with the `--debug` option and piping the output (sent to `stderr`)
    through `grep` in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first three directories that `pkg-config` tried to look in on my system
    did not exist. These are all in the */usr/local* tree. I haven’t built and installed
    many packages on this system; as a result, I haven’t installed any *.pc* files
    into the */usr/local* tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output, it’s clear that *.pc* files must be installed into one of
    these six directories: */usr(/local)/lib/x86_64-linux-gnu/pkgconfig*, */usr(/local)/lib/pkgconfig*,
    or */usr(/local)/share/pkgconfig*. When you think about it, you’ll recognize these
    paths as what amounts to pkg-config’s `${libdir}`*/**pkgconfig* and `${datadir}`*/pkgconfig*
    directories if, that is, pkg-config didn’t need to choose between */usr* and */usr/local*
    during its installation. In the early days, these were indeed just pkg-config’s
    library and data installation paths, but it didn’t take long for the project developers
    to realize that where pkg-config was installed was not really germane to where
    pkg-config should search on users’ systems for *.pc* files—they could be found
    in many locations, depending not on where pkg-config was installed but on where
    the users had installed packages on their systems—all over the place.'
  prefs: []
  type: TYPE_NORMAL
- en: But what about packages installed into custom locations or packages not yet
    installed? Pkg-config has solutions for these cases as well. The `PKG_CONFIG_PATH`
    environment variable can prepend user-specified paths to the default search path
    `pkg-config` uses to search for its data files. We’ll discover how to use this
    functionality as we cover more details about using the `pkg-config` command in
    *configure.ac*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing pkg-config Metadata Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated earlier, pkg-config’s *.pc* files are simply short text files that
    describe critical aspects of the build-and-link process to consumer build processes
    that use components of these dependent packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a sample *.pc* file on my system—the one for the *libssl*
    library, a part of the OpenSSL package. First we’ll need to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `--variable` option allows you to query the value of a variable, and `pcfiledir`
    is a pkg-config-defined variable that exists for every *.pc* file. I cover the
    complete list of predefined variables later in this chapter. The `pcfiledir` variable
    shows you the current location of the file as discovered by `pkg-config`. The
    nice thing about this variable is that it can also be used within your *.pc* file
    to provide a sort of relocation mechanism. If your library and include file paths
    are all relative to `${pcfiledir}` within your *.pc* file, you can move it anywhere
    you like (as long as you move the libraries and header files it locates to the
    same relative locations).
  prefs: []
  type: TYPE_NORMAL
- en: I’ve provided the full contents of my *libssl.pc* file in [Listing 10-1](ch10.xhtml#ch10ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1:* libssl.pc: *A sample* .pc *file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *.pc* file contains two types of entities: variable definitions (starting
    at ➊), which may reference other variables using Bourne shell–like syntax, and
    key-value tags (starting at ➋), which define the types of data that `pkg-config`
    can return about an installed package. These files can contain as little or as
    much of the pkg-config specification as is required by the package. Besides these
    entities, *.pc* files may also contain comments—any text preceded by a hash (`#`)
    mark. While these types of entities may be intermixed, it’s common convention
    to put variable definitions at the top, followed by the key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables look and act like shell variables; definitions are formatted as a
    variable name, followed by an equal (`=`) sign, followed by a value. You do not
    need to quote the value portion, even if it contains whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Pkg-config makes some predefined variables available for use within the *.pc*
    file and (as we’ve already seen) from the command line. [Table 10-1](ch10.xhtml#ch10tab1)
    shows these variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** Pre-Defined Variables Recognized by pkg-config'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `pc_path` | The default search path used by `pkg-config` to find the *.pc*
    file |'
  prefs: []
  type: TYPE_TB
- en: '| `pcfiledir` | The installed location of the *.pc* file |'
  prefs: []
  type: TYPE_TB
- en: '| `pc_sysrootdir` | The system root directory set by the user, or */* by default
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pc_top_builddir` | The location of the user’s top build directory when executing
    `pkg-config` |'
  prefs: []
  type: TYPE_TB
- en: After you’ve looked at enough *.pc* files, you may begin to wonder if variables
    like `prefix`, `exec_prefix`, `includedir`, `libdir`, and `datadir` have any special
    meaning to pkg-config. They don’t; it’s just nice to define these paths relative
    to each other to reduce duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Key-value pairs are formatted as a well-known keyword, followed by a colon (`:`)
    character, followed by some text that makes up the value portion. Values may reference
    variables; referencing an undefined variable merely expands to nothing. Quotes
    are not needed in these values either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys of key-value pairs are well-known and documented, although putting
    unknown keys in the file has no effect on `pkg-config`’s ability to use the rest
    of the data in the file. The keys shown in [Table 10-2](ch10.xhtml#ch10tab2) are
    well-known:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-2:** Well-Known Keys in Key-Value Pairs Recognized by pkg-config'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | A human-readable name for the library or package. |'
  prefs: []
  type: TYPE_TB
- en: '| `Description` | A brief human-readable description of the package. |'
  prefs: []
  type: TYPE_TB
- en: '| `URL` | A URL associated with the package—perhaps the package download site.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Version` | A version string for the package. |'
  prefs: []
  type: TYPE_TB
- en: '| `Requires` | A list of packages required by this package; specific versions
    may be specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `Requires.private` | A list of private packages required by this package.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Conflicts` | An optional field describing packages that this package conflicts
    with. |'
  prefs: []
  type: TYPE_TB
- en: '| `Cflags` | Compiler flags that should be used with this package. |'
  prefs: []
  type: TYPE_TB
- en: '| `Libs` | Linker flags that should be used with this package. |'
  prefs: []
  type: TYPE_TB
- en: '| `Libs.private` | Linker flags for private libraries required by this package.
    |'
  prefs: []
  type: TYPE_TB
- en: '*Informational Fields*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get the `pkg-config --exists` command to return zero to the shell, you need
    to specify `Name`, `Description`, and `Version`, at the very least. To be complete,
    consider also providing a URL if your project has one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not sure why a particular `pkg-config` command is not working as
    expected, use the `--print-errors` option. Where `pkg-config` would normally silently
    return a shell code, `--print-errors` will display a reason for a nonzero shell
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `--validate` option will also provide this information for both installed
    and uninstalled* .pc *files.*'
  prefs: []
  type: TYPE_NORMAL
- en: One obvious oversight is the lack of options for displaying the name and description
    information belonging to a package. The description is displayed when using the
    `--list-all` option; however, even the package name that shows up in that listing
    is actually the base name of the *.pc* file, not the value of the `Name` field
    from within the file. In spite of this, as mentioned previously, these three fields—`Name`,
    `Description`, and `Version`—are required; otherwise, as far as `pkg-config` is
    concerned, the package does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional Fields*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The category of the `Version` field crosses over from informational to functional,
    as there are some `pkg-config` command line options that can make use of the value
    of this field to provide data about the package to configuration scripts. The
    `Requires`, `Requires.private`, `Cflags`, `Libs`, and `Libs.private` fields also
    provide machine-readable information to configuration scripts and makefiles. `Cflags`,
    `Libs`, and `Libs.private` directly provide command line options for the C compiler
    and linker. The options to be added to these tools’ command lines are accessed
    by using various of the `pkg-config` command line options.
  prefs: []
  type: TYPE_NORMAL
- en: While pkg-config is conceptually simple, some of the details are a bit elusive
    if you haven’t played with it long enough to glean a proper understanding. Let’s
    cover each of these fields in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The informational fields are designed to be read by people. The package version,
    for instance, can be displayed using the `--modversion` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not confuse the `--version` option with the *`--modversion`* option. If
    you do, you’ll quietly get pkg-config’s version, regardless of what module you
    specify after *`--version`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `Version` field can also be used to indicate to configuration
    scripts if a package’s version meets requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Library version checks go against Autoconf’s general philosophy of checking
    for required functionality, rather than checking for a specific version of a library,
    because some distro providers backport functionality to older versions of libraries
    so they can use that functionality without upgrading the library on a target version
    of their distro (mostly for convenience, as newer versions of libraries sometimes
    come with newer dependency requirements that can propagate for several levels).
    These examples are provided merely to show you what’s possible with the functionality
    provided by pkg-config.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the functional fields, some are more obvious than others. We’ll cover each
    of them, starting with the more trivial ones. The `Cflags` field is probably the
    simplest to comprehend. It merely provides include path additions and other options
    to the C preprocessor and compiler. All options for both of these tools are combined
    into this one field, but `pkg-config` provides command line options for returning
    portions of the field value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The important thing to notice here is that the *`Cflags`* field contains compiler
    command line options, not portions of compiler command line options. For example,
    to define an include path for your library, ensure the value in *`Cflags`* contains
    both the *`-I`* flag and the path, just as you would on the compiler command line.*'
  prefs: []
  type: TYPE_NORMAL
- en: The other options that affect the output of the `Cflags` field are `--cflags-only-I`
    and `--cflags-only-other`. As you can see, `pkg-config` is aware of the difference
    between `-I` options and other options; if you specify `--cflags-only-I`, you’ll
    only see the `-I` options in the *.pc* file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Libs` field provides a place to set `-L`, `-l`, and any other options destined
    for the linker. For instance, if your package provides the *stpl* library, *libstpl.so*,
    you would add the `-L`*`/installed/lib/path`* and `-lstpl` options to the `Libs`
    field. Pkg-config’s `--libs` option returns the entire value, and, as with `Cflags`,
    there are separate options (`--libs-only-l`, `--libs-only-L`, and `--libs-only-other`)
    that separate and return subsets of the `Libs` options.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat harder to grasp is the use of the `Libs.private` field. This field
    is documented as being for libraries “required by this package but not exposed
    to applications.” In reality, however, while these are libraries required to build
    the library published by the package, they’re also libraries required by the consumer
    of the package if they’re linking statically to the package’s library.^([1](footnote.xhtml#ch10fn1))
    In fact, the use of `pkg-config`’s `--static` command line option, in conjunction
    with the `--libs` (or variations thereof) option, will display a combination of
    the `Libs` and `Libs.private` field options. This is because linking to a static
    library requires, at link time, all of the symbols required by all of the code
    pulled in from the static library to which you are directly linking.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an important concept, and understanding how it works is the key to
    properly writing *.pc* files for your projects. Think about it from the end user’s
    perspective: they want to compile some project, and they want it to be linked
    statically with your library (we must also assume your project builds and installs
    a static version of your library, of course). In order to do this, what options
    and libraries will be required on the compiler and linker command lines, *in addition
    to those already required when linking to your dynamic library*, in order to successfully
    perform this task? The answer to this question will tell you what should go into
    the `Libs.private` field in the *.pc* file for your project.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that those topics are behind us, we can properly discuss the `Requires`
    and `Requires.private` fields. The values in these fields are other pkg-config
    package names, with optional version specifications. If your package requires
    a particular version of another package that’s also managed by pkg-config, you
    need only specify that package in the `Requires` field if its `Cflags` and `Libs`
    field values are required by your users’ build processes in order to consume your
    package’s shared library, or in the `Requires.private` field if its `Cflags` and
    `Libs.private` field values are required in order to consume your package’s static
    library.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of `Requires` and `Requires.private`, we can now see
    that additional options required by pkg-config packages that you’d normally put
    into your `Cflags` and `Libs` or `Libs.private` fields are not needed in those
    fields because you can simply reference the package by name (and version or version
    range) in `Requires` or `Requires.private`. Pkg-config will recursively find and
    combine options from all the packages’ fields as needed.
  prefs: []
  type: TYPE_NORMAL
- en: If the package required by your package is not managed by pkg-config, you must
    add the options you’d normally find in such *.pc* files into your own `Cflags`,
    `Libs`, and `Libs.private` fields.
  prefs: []
  type: TYPE_NORMAL
- en: The version specification used in the `Requires` and `Requires.private` fields
    matches that of the RPM version specification. You may use `>`, `>=`, `=`, `<=`,
    or `<`. Sadly, these fields only allow one instance of a given library, which
    means you can’t apply both upper and lower bounds on the versions of required
    packages. [Listing 10-2](ch10.xhtml#ch10ex2) provides a contrived example of using
    version ranges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-2: Specifying version and version ranges in `Requires`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Requires` field indicates that two libraries are required here: *chooser*
    and *player*. The version of *chooser* must be 1.0.1 or higher, and the version
    of *player* must be less than 3.0.^([2](footnote.xhtml#ch10fn2))'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Conflicts` field merely allows you as the author of a package
    to define packages that conflict with your package, and the format of the field
    is identical to that of `Requires` and `Requires.private`. For this field you
    may provide the same package more than once in order to define specific ranges
    of versions that conflict with your package.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve completed writing your *.pc* file, you can validate it using the
    `--validate` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can use any *`pkg-config`* options that provide field information on either
    an installed* .pc *file, by using just the base name of the file, or on an uninstalled*
    .pc *file, by specifying the full name of the file, as is done in this example.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you have any errors that `pkg-config` can detect, they’ll be displayed. If
    you see nothing, then you know that `pkg-config` can at least parse your file
    properly and that a few basic checks pass.
  prefs: []
  type: TYPE_NORMAL
- en: Generating .pc Files with Autoconf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand the basic structure of a *.pc* file, let’s consider
    how we might use configuration data generated by our configuration scripts to
    generate a *.pc* file. Consider the types of information provided by pkg-config.
    Much of it is path information, and configuration scripts are designed to manage
    all these paths, including install locations for built products.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the user may specify an installation prefix on the `configure`
    command line. This prefix determines where the package’s include files and libraries
    will end up on their system when they install the package. The *.pc* file had
    better know these locations, and it would be nice of us to provide a build system
    that automatically updates this file to reflect the prefix path the user specified
    on their `configure` command line.
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating pc Files from pc.in Templates*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To accomplish this, we won’t write *.pc* files. Instead, we’ll write *.pc.in*
    template files for Autoconf and set the value of the `prefix` variable to `@prefix@`
    in these templates. That way, `configure` will replace this reference with the
    actual configured prefix when it converts the *.pc.in* template into the installable
    *.pc* file.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set the value of the `Version` field to `@PACKAGE_VERSION@`, which
    is defined by the value you pass to the Autoconf `AC_INIT` macro in *configure.ac*.
    To facilitate an experiment, create a *configure.ac* file in an empty directory,
    as shown in [Listing 10-3](ch10.xhtml#ch10ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-3:* configure.ac: *Generating test*.pc *from* test.pc.in'
  prefs: []
  type: TYPE_NORMAL
- en: Now create a *test.pc.in* file in the same directory, like the one shown in
    [Listing 10-4](ch10.xhtml#ch10ex4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-4:* test.pc.in: *A* .pc *template file*'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve specified the `prefix` and `Version` field values at ➊ and ➋ as Autoconf
    substitution variable references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the file and check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see at ➊ and ➋ in the console output, the Autoconf variable references
    were replaced in the generated *test.pc* file with the values of those Autoconf
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating .pc Files with make*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generating *.pc* files from templates using Autoconf has the disadvantage of
    inhibiting the user’s ability to change their prefix choices when they run `make`.
    This minor issue can be overcome by writing *Makefile.am* rules to generate the
    *.pc* files. Change the *configure.ac* file from the previous experiment, as shown
    in [Listing 10-5](ch10.xhtml#ch10ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-5:* configure.ac: *Changes required to [Listing 10-3](ch10.xhtml#ch10ex3)
    to generate* test.pc *using* `make`'
  prefs: []
  type: TYPE_NORMAL
- en: Now add a *Makefile.am* file, as shown in [Listing 10-6](ch10.xhtml#ch10ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-6:* Makefile.am: *Adding* `make` *rules to generate* test.pc'
  prefs: []
  type: TYPE_NORMAL
- en: The key functionality in [Listing 10-6](ch10.xhtml#ch10ex6) is encapsulated
    in the pattern rule that converts *.pc.in* files into *.pc* files using a simple
    `sed` command. The only odd bit in this `sed` command is the use of square brackets
    around the leading at (`@`) sign on the variables to be replaced. Those brackets
    are treated by `sed` as extraneous regular expression syntax, but the effect they
    have on Autoconf is to inhibit it from interpreting the sequence as the opening
    character of a replacement variable. We don’t want Autoconf replacing this variable.
    Rather, we want `sed` to look for the sequence in *test.pc.in*. Another solution
    is to come up with your own format for variables to be replaced, but do note that
    this syntax is fairly common in the Autotools community for this very purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pattern rules are specific to GNU *`make`* and are therefore not portable.
    There has been some chatter recently on the Automake mailing list of relaxing
    the restriction requiring the generation of portable *`make`* syntax and simply
    requiring GNU *`make`* because GNU *`make`* has been ported so widely these days.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, I’ve added *test.pc* to the Automake `EXTRA_DIST` variable
    so it will be built when `make dist` or `distclean` is executed, but you can add
    *test.pc* as a prerequisite to any target in your *Makefile.am* files to make
    it available to that stage of the build if required. Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that I added `prefix=/usr` to the `make` command line; thus, *test.pc*
    was generated with that value in the `prefix` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalled .pc Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned at the outset of this chapter that pkg-config had the ability to
    handle resolving references to uninstalled libraries and header files also. By
    *uninstalled*, I mean products that have been built but not installed; they’re
    still sitting in another project’s build output directory. Let’s now consider
    how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, a user would set `PKG_CONFIG_PATH` to point to a directory containing
    a *-uninstalled* variant of a required package’s *.pc* file. By “*-uninstalled*
    variant,” I mean that a *.pc* file named *test.pc* would have a *-uninstalled*
    variant named *test-uninstalled.pc*. The *-uninstalled* variant is not installed
    in a pkg-config database directory but, rather, is still sitting in the project
    source directory for the third-party dependency that the user has built. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’m following the Autoconf recommended procedure here of passing environment
    variables as parameters to *`configure`*. Setting the variable in the environment
    or setting it on the same command line before *`configure`* works also, but is
    not recommended because *`configure`* is less aware of variables set in these
    other ways.*'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming *`$HOME`**/required/pkg* was where the required package was unpacked
    and built, and assuming the same directory held the (possibly generated) *.pc*
    files for that package and that there was a *-uninstalled* variant in that directory,
    that file would be accessed by executions of the `pkg-config` utility that reference
    the required package’s name from within our `configure` script.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you would not want to install the *-uninstalled* variant of any of
    your *.pc* files—they’re designed to be used only in this fashion, from within
    a build directory. Perhaps not quite as obvious is the fact that the *-uninstalled*
    variants of your *.pc* files don’t contain all the same options as their installed
    counterparts. The difference, simply stated, is in the path options. The *-uninstalled*
    variants should contain absolute paths relative to the source location of your
    header files and the build location of your libraries so that when the options
    are passed to consumers’ tools, they’ll be able to find the products (header files
    and libraries) in those paths.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it out. Edit the *configure.ac* file you created from [Listing 10-3](ch10.xhtml#ch10ex3)
    to be like that shown in [Listing 10-7](ch10.xhtml#ch10ex7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-7:* configure.ac: *Generating the* -uninstalled *variant of* test.pc'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute paths can be derived by using appropriate Autoconf substitution variables,
    like `@abs_top_srcdir@` and `@abs_top_builddir@`, in the manner shown in [Listing
    10-8](ch10.xhtml#ch10ex8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-8:* test-uninstalled.pc: *A* -uninstalled *variant of* test.pc.in'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the *-uninstalled* variant of the *.pc* file from [Listing 10-4](ch10.xhtml#ch10ex4).
    I’ve removed the `prefix` variable, as it no longer makes sense in this context.
    I’ve replaced the `${prefix}` references with `@abs_top_builddir@` in the `libdir`
    pkg-config variable at ➊ and `@abs_top_srcdir@` in the `includedir` pkg-config
    variable at ➋. Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may be asking yourself at this point why this is supposed to be so much
    easier than just setting `CFLAGS` (or `CPPFLAGS`) and `LDFLAGS` on the `configure`
    command line. Well, for one thing, it’s easier to remember `PKG_CONFIG_PATH` than
    all of the potentially required individual tool variables. Another reason is the
    options are encapsulated where they’re best understood—within *.pc* files written
    by the required package’s author. Finally, if these options change, you’ll have
    to change your use of individual variables accordingly, but the `PKG_CONFIG_PATH`
    will remain the same. The extra level of indirection afforded by pkg-config hides
    all the details from both you and your power users and contributors.
  prefs: []
  type: TYPE_NORMAL
- en: Using pkg-config in configure.ac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen the way *.pc* files are put together. Now let’s take a look at how
    to consume this functionality in *configure.ac*. As mentioned in the previous
    section, the `--cflags` option provides access to the `Cflags` fields your compiler
    needs in order to compile this package. Let’s try this out with the *libssl.pc*
    file we saw previously. I’ve reproduced the relevant portion of [Listing 10-1](ch10.xhtml#ch10ex1)
    here in [Listing 10-9](ch10.xhtml#ch10ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-9:* libssl.pc: *Relevant portion of this* .pc *file*'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `--cflags` option against this *.pc* file, we now understand
    that we should see a `-I` compiler command line option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And . . . nothing is printed. Huh, did we do something wrong? The *libssl.pc*
    file shows us that if we mentally expand the variables, we should see something
    like `-I/usr/include`, right? Actually, `pkg-config` is doing exactly what it
    should do—it’s printing *the additional command line options* necessary to find
    the *libssl* header files. We don’t need to tell the compiler about the */usr**/include*
    directory, as this is a standard location and `pkg-config` knows this and omits
    such options automatically.^([3](footnote.xhtml#ch10fn3))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a *.pc* file whose `Cflags` value includes something other than standard
    include locations. Note here that I’m using `pkg-config` itself to find the location
    of its database directory for the *xorg-wacom.pc* file because it’s different
    on different Linux distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since */usr/include/xorg* is not a standard include path, a `-I` option for
    that path is displayed.^([4](footnote.xhtml#ch10fn4)) All of this means that you
    can be complete in documenting your package’s requirements in your *.pc* files
    without worrying about cluttering consumer compiler and linker command lines with
    pointless redundant definitions.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we use this output? Nothing more difficult than a little shell script,
    as shown in [Listing 10-10](ch10.xhtml#ch10ex10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-10: Using `pkg-config` to populate `CFLAGS` in* configure.ac'
  prefs: []
  type: TYPE_NORMAL
- en: The dollar-parens notation captures the output of this `pkg-config` command
    in the `LIBSSL_CFLAGS` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may, of course, use backticks rather than the dollar-parens notation I
    used in [Listing 10-10](ch10.xhtml#ch10ex10) to accomplish the same goal. The
    backtick format is older and slightly more portable, but it has the drawback of
    not being easily nestable. For example, you cannot do something like *`$(pkg-config
    --cflags $(cat libssl-pc-file.txt))`* with backticks without a lot of escape magic.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The linker options are accessed in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Referring back to the *libssl.pc* file in [Listing 10-1](ch10.xhtml#ch10ex1),
    we can indeed see that the `Libs` line contained `-lssl`. Also, as we just discovered,
    the `-L` option, referring a standard linker location, */usr/lib/x86_64-linux-gnu*,
    was automatically omitted. We can add this to our *configure.ac* file in the manner
    shown in [Listing 10-11](ch10.xhtml#ch10ex11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-11: Using `pkg-config` to populate `LIBS` in* configure.ac'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tie it all together by populating all required variables for compiling
    *libssl* header files and linking with *libssl*. [Listing 10-12](ch10.xhtml#ch10ex12)
    shows how this might be done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-12: Using `pkg-config` to access* libssl *in* configure.ac'
  prefs: []
  type: TYPE_NORMAL
- en: 'Could it be any simpler or any more readable? I doubt it. Let’s look at one
    more example—that of linking statically to *libssl*, which also requires (privately)
    *libcrytpo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this console example at ➊, *libssl* privately requires the
    pkg-config-managed *libcrypto* package, meaning that linking to the *libssl* shared
    library does not require the addition of `-lcrypto` on the linker command line,
    but linking to it statically does require this additional library option. We can
    also see at ➋ that *libssl* privately requires a library that’s not maintained
    by pkg-config, *libdl.so*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may find the contents of your* libssl.pc *and* libcrypto.pc *files are
    somewhat different from mine, depending on your Linux distribution and the version
    of openssl you have installed. Don’t worry about the differences—things will work
    fine on your system with your* .pc *files. The important part of this example
    is to understand the concepts I’m explaining.*'
  prefs: []
  type: TYPE_NORMAL
- en: Moving down to the *libcrypto.pc* file, we see at ➌ that *libcrypto* also privately
    requires *libdl.so*.
  prefs: []
  type: TYPE_NORMAL
- en: The noteworthy item at ➍ is that pkg-config is “smart enough” to understand
    the linker’s library ordering requirements and set `-ldl` on the output line after
    both `-lssl` and `-lcrypto`.^([5](footnote.xhtml#ch10fn5)) We humans have a hard
    enough time doing this stuff manually at times. It’s nice when a tool comes along
    that just manages everything the way it should without making us worry about how
    it’s done. Ultimately, the point I’m trying to make is that pkg-config puts control
    of the options squarely in the hands of the person most likely to understand how
    all these options should be specified and ordered—the maintainer of our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: pkg-config Autoconf Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned at the outset of this chapter, pkg-config also ships a set of
    Autoconf extension macros in a file called *pkg.m4* that’s installed into the
    */usr**(/local)/share/aclocal* directory, which is where `autoconf` looks for
    *.m4* files containing the Autoconf standard macros that you can use in your *configure.ac*
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Why didn’t I use these in my examples? Well, there are a couple of reasons why
    I tend to avoid these macros, one obvious and the other more subtle—nefarious
    even. The obvious reason is how easy it is to use the `pkg-config` utility directly
    in shell script in *configure.ac*. Why would you try to wrap that in an M4 macro?
  prefs: []
  type: TYPE_NORMAL
- en: As for the second reason, recall from previous discussions that the input to
    `autoconf` is a data stream containing the contents of your *configure.ac* file,
    along with all of the macro definitions required to allow M4 to expand all macro
    invocations into shell script. These macro definitions become part of the input
    stream because `autoconf` reads all of the *.m4* files in the */usr**(/local)/share/aclocal*
    directory first, before reading your *configure.ac* file. In other words, there
    is no indication to `autoconf` that a required *.m4* file is missing. It simply
    expects all macro definitions required by *configure.ac* to be found in the *.m4*
    files in the installation paths’ *aclocal* directory. As a result, `autoconf`
    cannot tell you if a macro definition in the input stream is not present. It simply
    fails to realize that `PKG_CHECK_MODULES` is a macro and, therefore, does not
    expand it to valid shell script. All of this happens when you run `autoconf` (or
    `autoreconf`). When you then try to run `configure`, it fails with messages that
    are so far removed from the actual problem that you couldn’t possibly know just
    from reading them what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: A picture is worth a thousand words, so let’s try a quick experiment. Create
    a *configure.ac* file in an empty directory, as shown in [Listing 10-13](ch10.xhtml#ch10ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-13: A* configure.ac *file with an unknown* macro *expansion*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute `autoconf`, followed by `./configure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice how you get no error while `autoconf` is converting *configure.ac* into
    *configure*. This makes complete sense because `m4`, being a text-based macro
    processor, doesn’t try to interpret anything in the data stream except for known
    macros. Everything else is passed directly though to the output stream, as if
    it were actual shell script.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran `configure`, we got a cryptic error about unexpected end-of-file
    (at line 1675\. . . from a two-line *configure.ac* file). What’s really happening
    here is that you unintentionally started defining a shell function called `AN_UNDEFINED_MACRO`
    but didn’t supply a body in curly braces for the function. The shell thought this
    was not cool and told you about it in its usual succinct manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Had we left the parentheses off of `AN_UNDEFINED_MACRO`, the shell would have
    been a bit more informational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At least this time, the shell told us the name of the problematic item, giving
    us the opportunity to go looking for it in *configure.ac* and perhaps figure out
    what’s wrong.^([6](footnote.xhtml#ch10fn6))
  prefs: []
  type: TYPE_NORMAL
- en: The point is, this is exactly what happens when you *think* you’re using a pkg-config
    macro but *pkg.m4* was not found by `autoconf` while it was looking through the
    usual macro directories. Not very enlightening. In my humble opinion, you’re much
    better off just skipping the hundreds of lines of nontransparent macro code and
    using `pkg-config` directly in your *configure.ac* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons why `autoconf` might not find your installed *pkg.m4* file are
    enlightening, however. One common reason is that you installed the *pkg-config*
    package (or it was automatically installed when the OS was installed) from your
    distro’s package repository, using `yum` or `apt`. But you downloaded, built,
    and installed Autoconf from the GNU website because your distro’s version of Autoconf
    is four revisions behind and you need the latest. Where did pkg-config’s installation
    process install *pkg.m4*? (Hint: */usr/share/aclocal*.) Where is `autoconf` getting
    its macro files from? (Hint: */usr/*local*/share/aclocal*.) You can, of course,
    easily remedy this problem by copying */usr/share/aclocal/pkg.m4* into */usr/local/share/aclocal*,
    and once you’ve hit this problem one or two times, you’ll never be caught by it
    again. But your power users and contributors will have to go through the same
    process—or you could just tell them all to buy this book and read [Chapter 10](ch10.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve discussed the benefits of using Autoconf with pkg-config,
    how to generate *.pc* files from Autoconf templates, how to use `pkg-config` from
    *configure.ac* files, and various nuances of pkg-config features.
  prefs: []
  type: TYPE_NORMAL
- en: You can read *somewhat* more about the proper use of the *pkg-config* package
    on the official pkg-config website at *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*.
    Dan Nicholson has written a concise and easy-to-follow tutorial on using pkg-config
    on his personal page at [freedesktop.org](http://freedesktop.org) (*[http://people.freedesktop.org/~dbn/pkg-config-guide.html](http://people.freedesktop.org/~dbn/pkg-config-guide.html)*).
    This page can also be accessed via links on the pkg-config website.
  prefs: []
  type: TYPE_NORMAL
- en: The *pkg-config* man page has a bit more information about the proper use of
    `pkg-config`, but, honestly, there isn’t much more out there, other than blog
    entries written by enterprising individuals. Thankfully, there really isn’t very
    much more to figure out about pkg-config. It’s well written and well documented
    (as far as software goes), with a few minor exceptions, which I’ve tried to cover
    here.
  prefs: []
  type: TYPE_NORMAL
