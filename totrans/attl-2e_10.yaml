- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: FINDING BUILD DEPENDENCIES WITH PKG-CONFIG
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PKG-CONFIG 查找构建依赖
- en: '*A common mistake that people make when trying to design something completely
    foolproof is to underestimate the ingenuity of complete fools.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*人们在尝试设计完全防傻的东西时常犯的一个错误，就是低估了彻头彻尾的傻瓜的创造力。'
- en: —Douglas Adams*, The Hitchhiker’s Guide to the Galaxy
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —道格拉斯·亚当斯*，《银河系漫游指南》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Let’s say your project depends on a library called *stpl*—some third-party library.
    How can your build system determine where *libstpl.so* is installed on an end
    user’s system? Where are *stpl*’s header files to be found? Do you simply assume
    */usr/lib* and */usr/include*? This is effectively what Autoconf does if you don’t
    tell it to look elsewhere, and for many packages perhaps that’s fine—it’s a common
    convention to install libraries and headers into these directories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目依赖于一个叫做 *stpl* 的库——一个第三方库。你的构建系统如何确定 *libstpl.so* 在终端用户系统上的安装位置？*stpl*
    的头文件在哪里？你是不是仅仅假设它们在 */usr/lib* 和 */usr/include* 中？如果你没有告诉 Autoconf 去别的地方找，这实际上就是
    Autoconf 的工作方式，对于许多软件包来说，这也许没问题——将库和头文件安装到这些目录是一个常见的约定。
- en: But what if they aren’t installed in these locations? Or perhaps they were built
    locally and installed into the */usr/local* tree. What compiler and linker options
    should be used when using *stpl* in your project? These are a few issues that
    have plagued developers from the beginning, and the Autotools don’t really do
    much to manage this problem. Autoconf expects any libraries you use to be installed
    into “standard places,” meaning into directories where the preprocessor and linker
    automatically look for header files and libraries. If a user has the library but
    it’s installed in a different location, the Autotools expect end users to know
    how to interpret the configuration failure. As it happens, there are several good
    reasons why many libraries are not installed in these standard places.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它们没有安装在这些位置呢？或者它们可能是本地构建并安装到 */usr/local* 目录树中。当你在项目中使用 *stpl* 时，应该使用哪些编译器和链接器选项？这些问题从一开始就困扰着开发人员，而
    Autotools 并没有真正解决这个问题。Autoconf 期望你使用的任何库都被安装到“标准位置”，也就是预处理器和链接器自动查找头文件和库的目录。如果用户有这个库，但它安装在了其他位置，Autotools
    就期望终端用户知道如何解释配置失败。事实上，有几个充分的理由解释了为什么许多库不会安装在这些标准位置。
- en: Additionally, Autoconf can’t easily find libraries that are not installed at
    all. For example, you may have just built a library package and you want another
    package to pick up headers and libraries from the first package’s build directory
    structure. This is possible with Autoconf, but it involves the end user setting
    variables like `CPPFLAGS` and `LDFLAGS` on the `configure` command line. The project
    maintainer can make things a little easier by providing user-specified configuration
    options with the `AC_ARG_ENABLE` and `AC_ARG_WITH` macros for libraries they anticipate
    might not be easy to find in standard places, but if your project uses a lot of
    third-party libraries, it’s just guesswork trying to determine which of these
    will be particularly problematic for users. And then, users are not often programmers;
    we cannot rely on them to have enough background to know what to use for option
    values, even if we do supply command line options for problematic dependencies.
    Throughout this chapter, I’ll refer to these as *build dependency issues*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Autoconf 并不容易找到那些根本没有安装的库。例如，你可能刚刚构建了一个库包，而你希望另一个包从第一个包的构建目录结构中获取头文件和库。这是
    Autoconf 可以做到的，但它需要终端用户在 `configure` 命令行中设置像 `CPPFLAGS` 和 `LDFLAGS` 这样的变量。项目维护者可以通过提供用户指定的配置选项，利用
    `AC_ARG_ENABLE` 和 `AC_ARG_WITH` 宏来简化这一过程，特别是针对他们预期不容易在标准位置找到的库。但是，如果你的项目使用了大量的第三方库，那么确定哪些库对于用户来说特别棘手，实际上只是猜测。而且，用户通常不是程序员；我们不能指望他们有足够的背景知识来知道应该为选项值使用什么，即使我们提供了命令行选项来解决问题依赖。贯穿本章，我将这些问题称为
    *构建依赖问题*。
- en: There is a tool that provides a solution for these types of problems in a more
    elegant fashion using a very common tactic in software design—by providing another
    layer of indirection. And it’s not part of the GNU Autotools. Regardless, its
    use has become so prolific over the past 20 years that it would be an oversight
    to exclude a description of *pkg-config* in any book that discusses Linux build
    systems. Pkg-config is as useful as it is today because a lot of projects have
    begun to use it—especially library projects, and most especially library projects
    that install into nonstandard locations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种工具通过使用软件设计中非常常见的策略——提供另一层间接性，优雅地解决了这些问题。它并不属于 GNU Autotools 的一部分。尽管如此，过去
    20 年来它的使用已经变得如此广泛，以至于如果在任何讨论 Linux 构建系统的书籍中不描述 *pkg-config*，那将是一个疏忽。pkg-config
    之所以如此有用，正是因为许多项目开始使用它——尤其是库项目，特别是那些安装到非标准位置的库项目。
- en: In this chapter, we’ll look at pkg-config’s components and functionality and
    how to use it in your projects. For your own library projects, we’ll also discuss
    how to update the pkg-config database as your package is installed onto users’
    (or as I like to call them, potential contributors’) systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 pkg-config 的组件和功能，以及如何在你的项目中使用它。对于你自己的库项目，我们还将讨论如何在你的包安装到用户（或者我喜欢称他们为潜在贡献者）系统时，更新
    pkg-config 数据库。
- en: Before we get started, allow me to state up front that this chapter makes a
    lot of references to filesystem objects that may or may not exist on your flavor
    of Linux, or perhaps exist in a different form or location. It’s the nature of
    what we’re doing here—we’re discussing packages with libraries and header files
    that probably exist in different locations on different Linux flavors. I’ll try
    to point out such potential differences as we come to them so you’ll not be too
    surprised when things don’t line up exactly on our two systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请允许我提前说明，本章中涉及到的很多文件系统对象可能在你的 Linux 版本中并不存在，或者可能以不同的形式或位置存在。这是我们所做的事情的本质——我们讨论的是包含库和头文件的包，这些文件可能在不同的
    Linux 版本中位于不同的位置。我会尽量指出这些潜在的差异，以便在两套系统中出现不完全一致时，你不会感到过于惊讶。
- en: A pkg-config Overview
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pkg-config 概述
- en: Pkg-config is an open source software utility maintained by the *[freedesktop.org](http://freedesktop.org)*
    project. The pkg-config website is a part of the [freedesktop.org](http://freedesktop.org)
    project website. The pkg-config project is the result of an effort to turn the
    `gnome-config` script—a part of the gnome build system—into a more general-purpose
    tool, and it seems to have caught on. Some inspiration for pkg-config also came
    from the `gtk-config` program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg-config 是一个开源软件工具，由 *[freedesktop.org](http://freedesktop.org)* 项目维护。pkg-config
    网站是 [freedesktop.org](http://freedesktop.org) 项目网站的一部分。pkg-config 项目是将 `gnome-config`
    脚本——gnome 构建系统的一部分——转变为一个更通用工具的努力结果，而且它似乎得到了广泛应用。pkg-config 的灵感也来自于 `gtk-config`
    程序。
- en: A NOTE ABOUT PKG-CONFIG CLONES
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PKG-CONFIG 克隆的说明
- en: The [freedesktop.org](http://freedesktop.org) pkg-config project has been around
    for a long time and has garnered a somewhat loyal following. As a direct result,
    other projects now exist that offer functionality that is similar—often identical—to
    the pkg-config project. One that comes to mind is the pkgconf project (which Red
    Hat’s Fedora Linux seems to prefer when you ask the `yum` package manager to install
    pkg-config for you).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[freedesktop.org](http://freedesktop.org) 的 pkg-config 项目已经存在很长时间，并且拥有一定数量的忠实用户。因此，现在有其他项目提供类似的功能——通常是完全相同的——与
    pkg-config 项目类似。其中一个就是 pkgconf 项目（当你要求 `yum` 包管理器为你安装 pkg-config 时，Red Hat 的 Fedora
    Linux 似乎更偏向使用它）。'
- en: Do not confuse these two. The pkgconf project is a modern clone of the original
    pkg-config project that comes with claims of higher efficiency—and as far as I’m
    concerned, it may very well live up to these claims. Regardless, this chapter
    is about pkg-config. If you’ve found a project that provides functionality similar
    to pkg-config and you like it, then by all means use it. My goal here is to teach
    you about pkg-config. If this material helps you understand how to use pkgconf,
    or another pkg-config clone, then you’re getting from this book exactly what I
    hoped to convey.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这两者混淆。pkgconf 项目是原始 pkg-config 项目的现代克隆，声称具有更高的效率——就我而言，它很可能确实能够兑现这些声明。不管怎样，本章是关于
    pkg-config 的。如果你发现某个项目提供类似于 pkg-config 的功能，并且你喜欢它，那么请随意使用它。我的目标是教你关于 pkg-config
    的知识。如果这些内容帮助你理解如何使用 pkgconf 或其他 pkg-config 克隆项目，那你从本书中得到的正是我希望传达的内容。
- en: That said, however, I cannot cover all of the nuanced differences among the
    different pkg-config clones. If you want to follow along with my examples and
    your flavor of Linux won’t install the original pkg-config package for you, you
    can always navigate in your browser to *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*
    and download and install version 0.29.2 of the original pkg-config project
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，话虽如此，我不能涵盖不同pkg-config克隆之间所有细微的差异。如果你想跟随我的示例，但你的Linux版本无法为你安装原版pkg-config包，你总是可以通过浏览器访问*[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*，下载并安装原版pkg-config项目的0.29.2版本。
- en: Pkg-config is used simply by invoking the `pkg-config` command line utility
    with options that display the desired data. When you’re looking for libraries
    and header files, the “desired data” includes package version information as well
    as compiler and linker options wherein library and header file locations are specified.
    For instance, to obtain C-preprocessor flags required to access a library’s header
    files, one need only specify the `--cflags` option on the `pkg-config` command
    line, and compiler options appropriate for the package are displayed to `stdout`.
    This display can be captured and appended to compiler command lines in your configuration
    scripts and makefiles as needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pkg-config非常简单，只需调用`pkg-config`命令行工具，并使用显示所需数据的选项。当你寻找库和头文件时，“所需数据”包括包的版本信息以及指定库和头文件位置的编译器和链接器选项。例如，要获取访问库头文件所需的C预处理器标志，只需在`pkg-config`命令行中指定`--cflags`选项，适用于该包的编译器选项就会显示在`stdout`中。这个输出可以捕捉并根据需要附加到你的配置脚本和makefile中的编译器命令行。
- en: Perhaps you’re wondering why we even need a tool like `pkg-config` when Autoconf
    provides the `AC_CHECK_LIB` and `AC_SEARCH_LIBS` macros. In the first place, as
    I mentioned previously, the Autoconf macros are designed to only look in “standard
    locations” for libraries. You can trick the macros into looking in other places
    by preloading search paths into `CPPFLAGS` (using `-I` options) and `LDFLAGS`
    (using `-L` options). However, pkg-config is designed to help you find libraries
    that may be installed in places only your users’ pkg-config installations know
    about; the best thing about pkg-config is that it knows how to find libraries
    and headers on end users’ systems that these users don’t even know about. Pkg-config
    can also tell your build system about additional dependencies required when your
    users are trying to statically link to your libraries. Therefore, it effectively
    hides such details from users, and that’s the sort of user experience we’re looking
    for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想，既然Autoconf已经提供了`AC_CHECK_LIB`和`AC_SEARCH_LIBS`宏，为什么我们还需要像`pkg-config`这样的工具呢？首先，正如我之前提到的，Autoconf的宏只会在“标准位置”查找库。你可以通过将搜索路径预加载到`CPPFLAGS`（使用`-I`选项）和`LDFLAGS`（使用`-L`选项）来欺骗这些宏，使其查找其他地方。然而，pkg-config的设计目的是帮助你找到那些可能安装在只有用户的pkg-config安装才知道的位置的库；pkg-config最棒的一点是，它知道如何在最终用户系统上找到那些用户自己都不知道的库和头文件。pkg-config还可以告诉你的构建系统，在用户尝试静态链接到你的库时，需要哪些额外的依赖项。因此，它有效地将这些细节从用户那里隐藏开来，这就是我们所追求的用户体验。
- en: There are, however, some caveats to using pkg-config with the Autotools. In
    the first edition of this book, I suggested that the `PKG_CHECK_MODULES` add-on
    M4 macro that’s shipped with pkg-config was a good approach to using it with Autoconf.
    I’ve since amended my thoughts on this issue as I’ve discovered over the years
    that the use of this macro can cause more problems than it solves under some rather
    common conditions. Additionally, `pkg-config` is so simple to use directly in
    shell script that it makes little sense to wrap it with less-than-transparent
    M4 macros. We’ll discuss this topic in much more detail in this chapter, but I
    wanted to set the stage for the pattern of use you’ll see in the examples that
    follow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用pkg-config与Autotools时，有一些注意事项。在本书的第一版中，我曾建议使用与pkg-config一起发布的`PKG_CHECK_MODULES`附加M4宏来与Autoconf配合使用，这是一种很好的方法。但随着多年来的发现，我已修改了对此问题的看法，因为我发现，在一些相当常见的情况下，使用这个宏可能会带来比解决问题更多的问题。此外，`pkg-config`在Shell脚本中直接使用非常简单，因此用不透明的M4宏将其包装起来几乎没有意义。本章我们将更加详细地讨论这一主题，但我想先为接下来的示例展示一种使用模式。
- en: Diving In
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入探讨
- en: 'Let’s start by looking at the output of the `--help` option for the `pkg-config`
    command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一下`pkg-config`命令的`--help`选项的输出：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ve only shown what I consider the most useful options here. There are another
    dozen or so, but these are the ones we’ll use all the time in our *configure.ac*
    files. (I’ve taken the liberty of wrapping long description lines as pkg-config
    seems to think everyone has a 300-column monitor.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里只展示了我认为最有用的选项。还有十几个其他的选项，但这些是我们在 *configure.ac* 文件中会经常使用的选项。（我已经将较长的描述行进行了换行，因为
    pkg-config 似乎认为每个人都有一个 300 列的显示器。）
- en: 'Let’s start by listing all of the modules pkg-config is aware of on the system.
    Here’s a sampling of the ones on my system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先列出系统中 pkg-config 已知的所有模块。以下是我系统上的一些示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pkg-config becomes *aware* of a package by having the package installation process
    update the pkg-config database, which is nothing more than a well-known directory
    that `pkg-config` examines to resolve queries. The database entries are simply
    plaintext files ending in a *.pc* extension. Therefore, making pkg-config aware
    of your library project during installation is nothing more difficult than generating
    and installing a text file, and Autoconf can help us generate this file, as we’ll
    see later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: pkg-config 通过让包的安装过程更新 pkg-config 数据库来“了解”一个包，这个数据库实际上只是一个知名目录，`pkg-config`
    会检查该目录来解决查询。数据库条目只是以 *.pc* 扩展名结尾的纯文本文件。因此，让 pkg-config 在安装过程中了解你的库项目，其实并没有比生成并安装一个文本文件更难，Autoconf
    可以帮助我们生成这个文件，稍后我们将看到这一点。
- en: 'The `pkg-config` utility looks in several directories to find these files.
    We can discover what directories it looks in, and the order of the search, by
    calling it with the `--debug` option and piping the output (sent to `stderr`)
    through `grep` in this manner:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg-config` 工具会在多个目录中查找这些文件。我们可以通过调用它并使用 `--debug` 选项，将输出（发送到 `stderr`）通过
    `grep` 管道来查看它查找的目录和搜索顺序，方法如下：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first three directories that `pkg-config` tried to look in on my system
    did not exist. These are all in the */usr/local* tree. I haven’t built and installed
    many packages on this system; as a result, I haven’t installed any *.pc* files
    into the */usr/local* tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg-config` 在我的系统上尝试查找的前三个目录不存在。这些目录都位于 */usr/local* 目录树中。我在这个系统上并没有构建和安装很多包，因此没有将任何
    *.pc* 文件安装到 */usr/local* 目录树中。'
- en: 'From the output, it’s clear that *.pc* files must be installed into one of
    these six directories: */usr(/local)/lib/x86_64-linux-gnu/pkgconfig*, */usr(/local)/lib/pkgconfig*,
    or */usr(/local)/share/pkgconfig*. When you think about it, you’ll recognize these
    paths as what amounts to pkg-config’s `${libdir}`*/**pkgconfig* and `${datadir}`*/pkgconfig*
    directories if, that is, pkg-config didn’t need to choose between */usr* and */usr/local*
    during its installation. In the early days, these were indeed just pkg-config’s
    library and data installation paths, but it didn’t take long for the project developers
    to realize that where pkg-config was installed was not really germane to where
    pkg-config should search on users’ systems for *.pc* files—they could be found
    in many locations, depending not on where pkg-config was installed but on where
    the users had installed packages on their systems—all over the place.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以清楚地看到，*.pc* 文件必须安装到以下六个目录中的一个：*/usr(/local)/lib/x86_64-linux-gnu/pkgconfig*、*/usr(/local)/lib/pkgconfig*
    或 */usr(/local)/share/pkgconfig*。当你仔细思考时，你会认识到这些路径本质上就是 pkg-config 的 `${libdir}`*/**pkgconfig*
    和 `${datadir}`*/pkgconfig* 目录，如果说 pkg-config 在安装时不需要在 */usr* 和 */usr/local* 之间做选择的话。早期，这些确实就是
    pkg-config 的库和数据安装路径，但不久之后，项目开发者就意识到 pkg-config 安装的位置与其应该在用户系统上搜索 *.pc* 文件的位置并无太大关系——这些文件可能分布在很多地方，取决于用户在系统上安装包的位置，而不是
    pkg-config 安装的位置。
- en: But what about packages installed into custom locations or packages not yet
    installed? Pkg-config has solutions for these cases as well. The `PKG_CONFIG_PATH`
    environment variable can prepend user-specified paths to the default search path
    `pkg-config` uses to search for its data files. We’ll discover how to use this
    functionality as we cover more details about using the `pkg-config` command in
    *configure.ac*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何处理安装到自定义位置的包或尚未安装的包呢？pkg-config 对这些情况也有解决方案。`PKG_CONFIG_PATH` 环境变量可以将用户指定的路径添加到
    `pkg-config` 用来搜索数据文件的默认搜索路径之前。随着我们在 *configure.ac* 中介绍更多使用 `pkg-config` 命令的细节，我们将学习如何使用这一功能。
- en: Writing pkg-config Metadata Files
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 pkg-config 元数据文件
- en: As stated earlier, pkg-config’s *.pc* files are simply short text files that
    describe critical aspects of the build-and-link process to consumer build processes
    that use components of these dependent packages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，pkg-config的*.pc*文件仅仅是简短的文本文件，它描述了构建和链接过程中的关键方面，供使用这些依赖包组件的消费端构建过程使用。
- en: 'Let’s take a look at a sample *.pc* file on my system—the one for the *libssl*
    library, a part of the OpenSSL package. First we’ll need to find it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我系统上的一个示例*.pc*文件——它是*libssl*库的文件，属于OpenSSL包的一部分。首先，我们需要找到它：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `--variable` option allows you to query the value of a variable, and `pcfiledir`
    is a pkg-config-defined variable that exists for every *.pc* file. I cover the
    complete list of predefined variables later in this chapter. The `pcfiledir` variable
    shows you the current location of the file as discovered by `pkg-config`. The
    nice thing about this variable is that it can also be used within your *.pc* file
    to provide a sort of relocation mechanism. If your library and include file paths
    are all relative to `${pcfiledir}` within your *.pc* file, you can move it anywhere
    you like (as long as you move the libraries and header files it locates to the
    same relative locations).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`--variable`选项允许你查询变量的值，`pcfiledir`是pkg-config为每个*.pc*文件定义的一个变量。我将在本章后面介绍预定义变量的完整列表。`pcfiledir`变量显示了`pkg-config`发现的文件当前所在位置。这一变量的好处在于，它也可以在你的*.pc*文件中使用，提供一种类似重定位的机制。如果你的库和包含文件路径都相对于`${pcfiledir}`在*.pc*文件中定义，你可以随意移动文件（只要你将它定位的库和头文件也移动到相同的相对位置）。'
- en: I’ve provided the full contents of my *libssl.pc* file in [Listing 10-1](ch10.xhtml#ch10ex1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[清单 10-1](ch10.xhtml#ch10ex1)中提供了我的*libssl.pc*文件的完整内容。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-1:* libssl.pc: *A sample* .pc *file*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1:* libssl.pc：*一个示例* .pc *文件*'
- en: 'A *.pc* file contains two types of entities: variable definitions (starting
    at ➊), which may reference other variables using Bourne shell–like syntax, and
    key-value tags (starting at ➋), which define the types of data that `pkg-config`
    can return about an installed package. These files can contain as little or as
    much of the pkg-config specification as is required by the package. Besides these
    entities, *.pc* files may also contain comments—any text preceded by a hash (`#`)
    mark. While these types of entities may be intermixed, it’s common convention
    to put variable definitions at the top, followed by the key-value pairs.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*.pc*文件包含两种类型的实体：变量定义（以➊开始），它们可以使用类似Bourne shell的语法引用其他变量；以及键值对标签（以➋开始），它们定义了`pkg-config`可以返回的关于已安装包的数据类型。这些文件可以包含pkg-config规范所需的任何内容，也可以只是包含最少的信息。除了这些实体，*.pc*文件还可以包含注释——任何以井号（`#`）标记开头的文本。虽然这些类型的实体可以混合出现，但通常的约定是将变量定义放在最上面，接着是键值对。'
- en: Variables look and act like shell variables; definitions are formatted as a
    variable name, followed by an equal (`=`) sign, followed by a value. You do not
    need to quote the value portion, even if it contains whitespace.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的外观和作用类似于shell变量；定义格式为变量名，后跟等号（`=`），再后跟值。即使值包含空格，你也无需对其进行引号处理。
- en: Pkg-config makes some predefined variables available for use within the *.pc*
    file and (as we’ve already seen) from the command line. [Table 10-1](ch10.xhtml#ch10tab1)
    shows these variables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg-config提供了一些预定义的变量，可以在*.pc*文件中使用，也可以通过命令行访问（正如我们之前所见）。[表 10-1](ch10.xhtml#ch10tab1)显示了这些变量。
- en: '**Table 10-1:** Pre-Defined Variables Recognized by pkg-config'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1:** pkg-config识别的预定义变量'
- en: '| **Variable** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| `pc_path` | The default search path used by `pkg-config` to find the *.pc*
    file |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `pc_path` | `pkg-config`用来查找*.pc*文件的默认搜索路径 |'
- en: '| `pcfiledir` | The installed location of the *.pc* file |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `pcfiledir` | *.pc*文件的安装位置 |'
- en: '| `pc_sysrootdir` | The system root directory set by the user, or */* by default
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `pc_sysrootdir` | 用户设置的系统根目录，默认值为`/*` |'
- en: '| `pc_top_builddir` | The location of the user’s top build directory when executing
    `pkg-config` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `pc_top_builddir` | 执行`pkg-config`时用户的顶级构建目录的位置 |'
- en: After you’ve looked at enough *.pc* files, you may begin to wonder if variables
    like `prefix`, `exec_prefix`, `includedir`, `libdir`, and `datadir` have any special
    meaning to pkg-config. They don’t; it’s just nice to define these paths relative
    to each other to reduce duplication.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你查看足够多的*.pc*文件后，你可能会开始想，像`prefix`、`exec_prefix`、`includedir`、`libdir`和`datadir`这些变量是否对pkg-config有特殊的意义。它们没有；它们只是用来相对定义这些路径，以减少重复。
- en: Key-value pairs are formatted as a well-known keyword, followed by a colon (`:`)
    character, followed by some text that makes up the value portion. Values may reference
    variables; referencing an undefined variable merely expands to nothing. Quotes
    are not needed in these values either.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对格式为一个知名关键词，后跟冒号（`:`）字符，然后是构成值部分的文本。值可以引用变量；引用未定义的变量仅会展开为空。这些值中也不需要使用引号。
- en: 'The keys of key-value pairs are well-known and documented, although putting
    unknown keys in the file has no effect on `pkg-config`’s ability to use the rest
    of the data in the file. The keys shown in [Table 10-2](ch10.xhtml#ch10tab2) are
    well-known:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对的键是知名且有文档记录的，尽管在文件中放置未知键不会影响`pkg-config`使用文件中其余数据的能力。[表 10-2](ch10.xhtml#ch10tab2)中显示的键是知名的：
- en: '**Table 10-2:** Well-Known Keys in Key-Value Pairs Recognized by pkg-config'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** pkg-config 识别的键值对中的知名键'
- en: '| **Key** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **描述** |'
- en: '| `Name` | A human-readable name for the library or package. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Name` | 库或包的可读名称。 |'
- en: '| `Description` | A brief human-readable description of the package. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Description` | 包的简短可读描述。 |'
- en: '| `URL` | A URL associated with the package—perhaps the package download site.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `URL` | 与包关联的 URL——可能是包的下载站点。 |'
- en: '| `Version` | A version string for the package. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Version` | 包的版本字符串。 |'
- en: '| `Requires` | A list of packages required by this package; specific versions
    may be specified. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Requires` | 本包所需的包列表；可以指定特定版本。 |'
- en: '| `Requires.private` | A list of private packages required by this package.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Requires.private` | 本包所需的私有包列表。 |'
- en: '| `Conflicts` | An optional field describing packages that this package conflicts
    with. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Conflicts` | 可选字段，描述本包与哪些包存在冲突。 |'
- en: '| `Cflags` | Compiler flags that should be used with this package. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Cflags` | 应该与此包一起使用的编译器标志。 |'
- en: '| `Libs` | Linker flags that should be used with this package. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Libs` | 应该与此包一起使用的链接器标志。 |'
- en: '| `Libs.private` | Linker flags for private libraries required by this package.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Libs.private` | 本包所需的私有库的链接器标志。 |'
- en: '*Informational Fields*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*信息字段*'
- en: To get the `pkg-config --exists` command to return zero to the shell, you need
    to specify `Name`, `Description`, and `Version`, at the very least. To be complete,
    consider also providing a URL if your project has one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`pkg-config --exists`命令返回零到 shell，你至少需要指定`Name`、`Description`和`Version`。为了完整起见，考虑在项目有
    URL 时也提供一个 URL。
- en: 'If you’re not sure why a particular `pkg-config` command is not working as
    expected, use the `--print-errors` option. Where `pkg-config` would normally silently
    return a shell code, `--print-errors` will display a reason for a nonzero shell
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定为什么某个特定的`pkg-config`命令没有按预期工作，可以使用`--print-errors`选项。在`pkg-config`通常会默默返回一个
    shell 代码的地方，`--print-errors`会显示非零 shell 代码的原因：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `--validate` option will also provide this information for both installed
    and uninstalled* .pc *files.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*`--validate`选项也会为已安装和未安装的*.pc*文件提供此信息。*'
- en: One obvious oversight is the lack of options for displaying the name and description
    information belonging to a package. The description is displayed when using the
    `--list-all` option; however, even the package name that shows up in that listing
    is actually the base name of the *.pc* file, not the value of the `Name` field
    from within the file. In spite of this, as mentioned previously, these three fields—`Name`,
    `Description`, and `Version`—are required; otherwise, as far as `pkg-config` is
    concerned, the package does not exist.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的疏漏是缺乏显示属于某个包的名称和描述信息的选项。描述信息在使用`--list-all`选项时会显示；然而，即使在该列表中显示的包名称实际上也是*.pc*文件的基础名称，而不是文件中`Name`字段的值。尽管如此，正如前面所提到的，这三个字段——`Name`、`Description`和`Version`——是必需的；否则，`pkg-config`认为该包不存在。
- en: '*Functional Fields*'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*功能字段*'
- en: The category of the `Version` field crosses over from informational to functional,
    as there are some `pkg-config` command line options that can make use of the value
    of this field to provide data about the package to configuration scripts. The
    `Requires`, `Requires.private`, `Cflags`, `Libs`, and `Libs.private` fields also
    provide machine-readable information to configuration scripts and makefiles. `Cflags`,
    `Libs`, and `Libs.private` directly provide command line options for the C compiler
    and linker. The options to be added to these tools’ command lines are accessed
    by using various of the `pkg-config` command line options.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Version` 字段的类别跨越了信息性到功能性，因为有一些 `pkg-config` 命令行选项可以利用该字段的值，为配置脚本提供有关包的数据。`Requires`、`Requires.private`、`Cflags`、`Libs`
    和 `Libs.private` 字段也为配置脚本和 makefile 提供机器可读的信息。`Cflags`、`Libs` 和 `Libs.private`
    直接提供了 C 编译器和链接器的命令行选项。通过使用不同的 `pkg-config` 命令行选项，可以访问这些工具命令行中要添加的选项。'
- en: While pkg-config is conceptually simple, some of the details are a bit elusive
    if you haven’t played with it long enough to glean a proper understanding. Let’s
    cover each of these fields in more detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 pkg-config 在概念上很简单，但一些细节如果你没有足够的实践，可能会有些难以捉摸。接下来我们将更详细地讲解这些字段。
- en: 'The informational fields are designed to be read by people. The package version,
    for instance, can be displayed using the `--modversion` option:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 信息性字段是为人类阅读而设计的。例如，可以使用 `--modversion` 选项显示包的版本：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not confuse the `--version` option with the *`--modversion`* option. If
    you do, you’ll quietly get pkg-config’s version, regardless of what module you
    specify after *`--version`*.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将 `--version` 选项与 *`--modversion`* 选项混淆。如果你混淆了，它会默默返回 pkg-config 的版本，无论你在
    *`--version`* 后指定什么模块。*'
- en: 'However, the `Version` field can also be used to indicate to configuration
    scripts if a package’s version meets requirements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Version` 字段也可以用来向配置脚本指示一个包的版本是否满足要求：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Library version checks go against Autoconf’s general philosophy of checking
    for required functionality, rather than checking for a specific version of a library,
    because some distro providers backport functionality to older versions of libraries
    so they can use that functionality without upgrading the library on a target version
    of their distro (mostly for convenience, as newer versions of libraries sometimes
    come with newer dependency requirements that can propagate for several levels).
    These examples are provided merely to show you what’s possible with the functionality
    provided by pkg-config.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*库版本检查与 Autoconf 的一般哲学相悖，后者检查的是所需功能而不是库的特定版本，因为某些发行版提供商会将功能回移植到旧版本的库，以便在不升级库的情况下在其发行版的目标版本上使用该功能（主要是为了方便，因为较新版本的库有时会带来新的依赖要求，这些要求可能会传播到多个级别）。这些示例仅用于向你展示
    pkg-config 提供的功能的可能性。*'
- en: 'Of the functional fields, some are more obvious than others. We’ll cover each
    of them, starting with the more trivial ones. The `Cflags` field is probably the
    simplest to comprehend. It merely provides include path additions and other options
    to the C preprocessor and compiler. All options for both of these tools are combined
    into this one field, but `pkg-config` provides command line options for returning
    portions of the field value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能字段中，有些比其他的更为直观。我们将逐一讲解每个字段，从较简单的开始。`Cflags` 字段可能是最简单的理解，它只是提供了包含路径的附加和其他选项给
    C 预处理器和编译器。这两个工具的所有选项都汇聚在这一字段中，但 `pkg-config` 提供了命令行选项，用于返回字段值的部分内容：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The important thing to notice here is that the *`Cflags`* field contains compiler
    command line options, not portions of compiler command line options. For example,
    to define an include path for your library, ensure the value in *`Cflags`* contains
    both the *`-I`* flag and the path, just as you would on the compiler command line.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里需要注意的重要事项是，*`Cflags`* 字段包含的是编译器命令行选项，而不是编译器命令行选项的部分。例如，要为你的库定义包含路径，确保 *`Cflags`*
    中包含 *`-I`* 标志和路径，就像在编译器命令行中那样。*'
- en: The other options that affect the output of the `Cflags` field are `--cflags-only-I`
    and `--cflags-only-other`. As you can see, `pkg-config` is aware of the difference
    between `-I` options and other options; if you specify `--cflags-only-I`, you’ll
    only see the `-I` options in the *.pc* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 影响 `Cflags` 字段输出的其他选项包括 `--cflags-only-I` 和 `--cflags-only-other`。如你所见，`pkg-config`
    区分了 `-I` 选项和其他选项；如果你指定了 `--cflags-only-I`，你只会看到 *.pc* 文件中的 `-I` 选项。
- en: The `Libs` field provides a place to set `-L`, `-l`, and any other options destined
    for the linker. For instance, if your package provides the *stpl* library, *libstpl.so*,
    you would add the `-L`*`/installed/lib/path`* and `-lstpl` options to the `Libs`
    field. Pkg-config’s `--libs` option returns the entire value, and, as with `Cflags`,
    there are separate options (`--libs-only-l`, `--libs-only-L`, and `--libs-only-other`)
    that separate and return subsets of the `Libs` options.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Libs`字段提供了设置`-L`、`-l`和其他面向链接器的选项的位置。例如，如果你的包提供了*stpl*库，即*libstpl.so*，你需要在`Libs`字段中添加`-L`*`/installed/lib/path`*和`-lstpl`选项。Pkg-config的`--libs`选项返回完整的值，并且与`Cflags`一样，有一些单独的选项（`--libs-only-l`，`--libs-only-L`，和`--libs-only-other`），它们将返回`Libs`选项的子集。'
- en: Somewhat harder to grasp is the use of the `Libs.private` field. This field
    is documented as being for libraries “required by this package but not exposed
    to applications.” In reality, however, while these are libraries required to build
    the library published by the package, they’re also libraries required by the consumer
    of the package if they’re linking statically to the package’s library.^([1](footnote.xhtml#ch10fn1))
    In fact, the use of `pkg-config`’s `--static` command line option, in conjunction
    with the `--libs` (or variations thereof) option, will display a combination of
    the `Libs` and `Libs.private` field options. This is because linking to a static
    library requires, at link time, all of the symbols required by all of the code
    pulled in from the static library to which you are directly linking.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较难理解的是`Libs.private`字段的使用。该字段的文档说明它是“该包所需但不暴露给应用程序的库”。然而，实际上，虽然这些是构建包发布的库所需的库，它们也是包的消费者在静态链接到该包的库时所需的库。^([1](footnote.xhtml#ch10fn1))事实上，使用`pkg-config`的`--static`命令行选项，配合`--libs`（或类似选项）选项，将会显示`Libs`和`Libs.private`字段选项的组合。这是因为，静态链接库时，在链接阶段，所有从静态库中直接链接的代码所需的符号都必须被链接。
- en: 'This is an important concept, and understanding how it works is the key to
    properly writing *.pc* files for your projects. Think about it from the end user’s
    perspective: they want to compile some project, and they want it to be linked
    statically with your library (we must also assume your project builds and installs
    a static version of your library, of course). In order to do this, what options
    and libraries will be required on the compiler and linker command lines, *in addition
    to those already required when linking to your dynamic library*, in order to successfully
    perform this task? The answer to this question will tell you what should go into
    the `Libs.private` field in the *.pc* file for your project.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的概念，理解它的工作原理是正确编写项目的*.pc*文件的关键。从终端用户的角度考虑：他们想要编译某个项目，并且希望将其与你的库静态链接（当然，我们还必须假设你的项目会构建并安装一个静态版本的库）。为了做到这一点，编译器和链接器命令行上需要哪些选项和库，*除了那些在链接到动态库时已经要求的选项*，才能成功完成这个任务？这个问题的答案将告诉你在你项目的*.pc*文件中`Libs.private`字段应填入什么内容。
- en: Now that those topics are behind us, we can properly discuss the `Requires`
    and `Requires.private` fields. The values in these fields are other pkg-config
    package names, with optional version specifications. If your package requires
    a particular version of another package that’s also managed by pkg-config, you
    need only specify that package in the `Requires` field if its `Cflags` and `Libs`
    field values are required by your users’ build processes in order to consume your
    package’s shared library, or in the `Requires.private` field if its `Cflags` and
    `Libs.private` field values are required in order to consume your package’s static
    library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些话题已经讲完，我们可以正式讨论`Requires`和`Requires.private`字段。这些字段中的值是其他pkg-config包的名称，并可以选择性地指定版本。如果你的包依赖于另一个由pkg-config管理的特定版本的包，只需要在`Requires`字段中指定该包，前提是它的`Cflags`和`Libs`字段的值是用户的构建过程需要的，以便使用你包的共享库；如果它的`Cflags`和`Libs.private`字段的值是用户构建静态库时需要的，则应将该包指定在`Requires.private`字段中。
- en: With this understanding of `Requires` and `Requires.private`, we can now see
    that additional options required by pkg-config packages that you’d normally put
    into your `Cflags` and `Libs` or `Libs.private` fields are not needed in those
    fields because you can simply reference the package by name (and version or version
    range) in `Requires` or `Requires.private`. Pkg-config will recursively find and
    combine options from all the packages’ fields as needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解`Requires`和`Requires.private`字段，我们现在可以看到，pkg-config包所需的附加选项，通常会放在`Cflags`和`Libs`或`Libs.private`字段中，其实不需要放在这些字段中，因为你可以简单地通过名称（以及版本或版本范围）在`Requires`或`Requires.private`中引用该包。Pkg-config会递归地查找并根据需要合并所有包字段中的选项。
- en: If the package required by your package is not managed by pkg-config, you must
    add the options you’d normally find in such *.pc* files into your own `Cflags`,
    `Libs`, and `Libs.private` fields.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你包所需的包不是由pkg-config管理的，你必须将通常会出现在*.pc*文件中的选项添加到你自己的`Cflags`、`Libs`和`Libs.private`字段中。
- en: The version specification used in the `Requires` and `Requires.private` fields
    matches that of the RPM version specification. You may use `>`, `>=`, `=`, `<=`,
    or `<`. Sadly, these fields only allow one instance of a given library, which
    means you can’t apply both upper and lower bounds on the versions of required
    packages. [Listing 10-2](ch10.xhtml#ch10ex2) provides a contrived example of using
    version ranges.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Requires`和`Requires.private`字段中使用的版本规范与RPM版本规范相同。你可以使用`>`、`>=`、`=`、`<=`或`<`。遗憾的是，这些字段只允许一个给定库的实例，这意味着你无法对所需包的版本同时应用上下界。[清单
    10-2](ch10.xhtml#ch10ex2)提供了一个使用版本范围的做法示例。
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-2: Specifying version and version ranges in `Requires`*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：在`Requires`中指定版本和版本范围*'
- en: 'The `Requires` field indicates that two libraries are required here: *chooser*
    and *player*. The version of *chooser* must be 1.0.1 or higher, and the version
    of *player* must be less than 3.0.^([2](footnote.xhtml#ch10fn2))'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Requires`字段表示这里需要两个库：*chooser*和*player*。*chooser*的版本必须是1.0.1或更高，而*player*的版本必须低于3.0。^([2](footnote.xhtml#ch10fn2))'
- en: Finally, the `Conflicts` field merely allows you as the author of a package
    to define packages that conflict with your package, and the format of the field
    is identical to that of `Requires` and `Requires.private`. For this field you
    may provide the same package more than once in order to define specific ranges
    of versions that conflict with your package.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Conflicts`字段只是让你作为包的作者定义与包冲突的其他包，字段的格式与`Requires`和`Requires.private`相同。对于这个字段，你可以多次提供相同的包，以便定义与包冲突的特定版本范围。
- en: 'When you’ve completed writing your *.pc* file, you can validate it using the
    `--validate` option:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成*.pc*文件的编写后，可以使用`--validate`选项来验证它：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use any *`pkg-config`* options that provide field information on either
    an installed* .pc *file, by using just the base name of the file, or on an uninstalled*
    .pc *file, by specifying the full name of the file, as is done in this example.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用任何提供字段信息的*`pkg-config`*选项，这些信息可以来源于已安装的*.pc*文件（只需使用文件的基本名称），也可以来源于未安装的*.pc*文件（通过指定文件的完整名称），正如这个示例所示。*'
- en: If you have any errors that `pkg-config` can detect, they’ll be displayed. If
    you see nothing, then you know that `pkg-config` can at least parse your file
    properly and that a few basic checks pass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pkg-config`能够检测到任何错误，它们会被显示出来。如果什么都没有显示，那就说明`pkg-config`至少能够正确解析你的文件，并且一些基本检查通过了。
- en: Generating .pc Files with Autoconf
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Autoconf生成*.pc*文件
- en: Now that you understand the basic structure of a *.pc* file, let’s consider
    how we might use configuration data generated by our configuration scripts to
    generate a *.pc* file. Consider the types of information provided by pkg-config.
    Much of it is path information, and configuration scripts are designed to manage
    all these paths, including install locations for built products.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了*.pc*文件的基本结构，我们来考虑一下如何利用配置脚本生成的配置数据来生成*.pc*文件。考虑pkg-config提供的信息类型，其中大部分是路径信息，而配置脚本的目的是管理所有这些路径，包括构建产品的安装位置。
- en: For example, the user may specify an installation prefix on the `configure`
    command line. This prefix determines where the package’s include files and libraries
    will end up on their system when they install the package. The *.pc* file had
    better know these locations, and it would be nice of us to provide a build system
    that automatically updates this file to reflect the prefix path the user specified
    on their `configure` command line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可能会在`configure`命令行中指定安装前缀。该前缀决定了包的包含文件和库在用户安装该包时将被放置在系统的哪个位置。*.pc*文件最好能够知道这些位置，而且，如果我们能提供一个自动更新该文件的构建系统，使其反映用户在`configure`命令行中指定的前缀路径，那将是非常方便的。
- en: '*Generating pc Files from pc.in Templates*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从pc.in模板生成pc文件*'
- en: To accomplish this, we won’t write *.pc* files. Instead, we’ll write *.pc.in*
    template files for Autoconf and set the value of the `prefix` variable to `@prefix@`
    in these templates. That way, `configure` will replace this reference with the
    actual configured prefix when it converts the *.pc.in* template into the installable
    *.pc* file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们不会直接编写*.pc*文件。相反，我们将为Autoconf编写*.pc.in*模板文件，并将`prefix`变量的值设置为`@prefix@`，以便在`configure`将*.pc.in*模板转换为可安装的*.pc*文件时，替换该引用为实际的配置前缀。
- en: We can also set the value of the `Version` field to `@PACKAGE_VERSION@`, which
    is defined by the value you pass to the Autoconf `AC_INIT` macro in *configure.ac*.
    To facilitate an experiment, create a *configure.ac* file in an empty directory,
    as shown in [Listing 10-3](ch10.xhtml#ch10ex3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`Version`字段的值设置为`@PACKAGE_VERSION@`，该值由你传递给Autoconf `AC_INIT`宏的值定义，位于*configure.ac*中。为了方便实验，在一个空目录中创建一个*configure.ac*文件，如[示例
    10-3](ch10.xhtml#ch10ex3)所示。
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-3:* configure.ac: *Generating test*.pc *from* test.pc.in'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-3:* configure.ac: *生成* test.pc *文件，源自* test.pc.in'
- en: Now create a *test.pc.in* file in the same directory, like the one shown in
    [Listing 10-4](ch10.xhtml#ch10ex4).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一目录下创建一个*test.pc.in*文件，如[示例 10-4](ch10.xhtml#ch10ex4)所示。
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-4:* test.pc.in: *A* .pc *template file*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-4:* test.pc.in: *一个* .pc *模板文件*'
- en: Here we’ve specified the `prefix` and `Version` field values at ➊ and ➋ as Autoconf
    substitution variable references.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在➊和➋处指定了`prefix`和`Version`字段的值，作为Autoconf替换变量引用。
- en: 'Generate the file and check the result:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 生成文件并检查结果：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see at ➊ and ➋ in the console output, the Autoconf variable references
    were replaced in the generated *test.pc* file with the values of those Autoconf
    variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在控制台输出的➊和➋处看到的，生成的*test.pc*文件中的Autoconf变量引用被替换为这些Autoconf变量的值。
- en: '*Generating .pc Files with make*'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用make生成.pc文件*'
- en: Generating *.pc* files from templates using Autoconf has the disadvantage of
    inhibiting the user’s ability to change their prefix choices when they run `make`.
    This minor issue can be overcome by writing *Makefile.am* rules to generate the
    *.pc* files. Change the *configure.ac* file from the previous experiment, as shown
    in [Listing 10-5](ch10.xhtml#ch10ex5).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Autoconf从模板生成*.pc*文件的缺点是，它限制了用户在运行`make`时更改前缀选择的能力。这个小问题可以通过编写*Makefile.am*规则来生成*.pc*文件来解决。请按照[示例
    10-5](ch10.xhtml#ch10ex5)中所示，修改之前实验中的*configure.ac*文件。
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-5:* configure.ac: *Changes required to [Listing 10-3](ch10.xhtml#ch10ex3)
    to generate* test.pc *using* `make`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-5:* configure.ac: *修改[示例 10-3](ch10.xhtml#ch10ex3)以使用* `make` *生成* test.pc'
- en: Now add a *Makefile.am* file, as shown in [Listing 10-6](ch10.xhtml#ch10ex6).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个*Makefile.am*文件，如[示例 10-6](ch10.xhtml#ch10ex6)所示。
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-6:* Makefile.am: *Adding* `make` *rules to generate* test.pc'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-6:* Makefile.am: *添加* `make` *规则来生成* test.pc'
- en: The key functionality in [Listing 10-6](ch10.xhtml#ch10ex6) is encapsulated
    in the pattern rule that converts *.pc.in* files into *.pc* files using a simple
    `sed` command. The only odd bit in this `sed` command is the use of square brackets
    around the leading at (`@`) sign on the variables to be replaced. Those brackets
    are treated by `sed` as extraneous regular expression syntax, but the effect they
    have on Autoconf is to inhibit it from interpreting the sequence as the opening
    character of a replacement variable. We don’t want Autoconf replacing this variable.
    Rather, we want `sed` to look for the sequence in *test.pc.in*. Another solution
    is to come up with your own format for variables to be replaced, but do note that
    this syntax is fairly common in the Autotools community for this very purpose.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-6](ch10.xhtml#ch10ex6) 中的关键功能是封装在模式规则中，使用一个简单的 `sed` 命令将 *.pc.in* 文件转换为
    *.pc* 文件。这个 `sed` 命令中唯一不同的部分是，在要替换的变量的前导 @ 符号周围使用了方括号。`sed` 将这些方括号视为多余的正则表达式语法，但它们对
    Autoconf 的作用是阻止它将该序列解释为替换变量的开头字符。我们不希望 Autoconf 替换这个变量，而是希望 `sed` 在 *test.pc.in*
    文件中查找这个序列。另一种解决方法是自己制定变量替换格式，但需要注意，这种语法在 Autotools 社区中用于此目的是相当常见的。'
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Pattern rules are specific to GNU *`make`* and are therefore not portable.
    There has been some chatter recently on the Automake mailing list of relaxing
    the restriction requiring the generation of portable *`make`* syntax and simply
    requiring GNU *`make`* because GNU *`make`* has been ported so widely these days.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式规则是特定于 GNU *`make`* 的，因此不可移植。最近，Automake 邮件列表中有一些讨论，提到是否放宽要求生成可移植 *`make`*
    语法的限制，而仅要求使用 GNU *`make`*，因为 GNU *`make`* 目前已经广泛移植。*'
- en: 'For this example, I’ve added *test.pc* to the Automake `EXTRA_DIST` variable
    so it will be built when `make dist` or `distclean` is executed, but you can add
    *test.pc* as a prerequisite to any target in your *Makefile.am* files to make
    it available to that stage of the build if required. Let’s try it out:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我已将 *test.pc* 添加到 Automake 的 `EXTRA_DIST` 变量中，以便在执行 `make dist` 或 `distclean`
    时构建它，但你也可以将 *test.pc* 作为任何目标的前提条件添加到你的 *Makefile.am* 文件中，以便在构建的该阶段使其可用（如果需要的话）。我们来试试：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that I added `prefix=/usr` to the `make` command line; thus, *test.pc*
    was generated with that value in the `prefix` variable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在 `make` 命令行中添加了 `prefix=/usr`；因此，*test.pc* 是使用该值在 `prefix` 变量中生成的。
- en: Uninstalled .pc Files
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载的 .pc 文件
- en: I mentioned at the outset of this chapter that pkg-config had the ability to
    handle resolving references to uninstalled libraries and header files also. By
    *uninstalled*, I mean products that have been built but not installed; they’re
    still sitting in another project’s build output directory. Let’s now consider
    how this is done.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章开头提到过，pkg-config 也能够处理解析未安装的库和头文件的引用。这里所说的 *未安装*，指的是已经构建但未安装的产品；它们仍然保留在另一个项目的构建输出目录中。现在我们来看看如何实现这一点。
- en: 'To use it, a user would set `PKG_CONFIG_PATH` to point to a directory containing
    a *-uninstalled* variant of a required package’s *.pc* file. By “*-uninstalled*
    variant,” I mean that a *.pc* file named *test.pc* would have a *-uninstalled*
    variant named *test-uninstalled.pc*. The *-uninstalled* variant is not installed
    in a pkg-config database directory but, rather, is still sitting in the project
    source directory for the third-party dependency that the user has built. Here’s
    an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，用户需要将 `PKG_CONFIG_PATH` 设置为指向包含所需软件包的 *-uninstalled* 变体 *.pc* 文件的目录。这里所说的“*-uninstalled*
    变体”是指一个名为 *test.pc* 的 *.pc* 文件，会有一个名为 *test-uninstalled.pc* 的 *-uninstalled* 变体。该
    *-uninstalled* 变体并未安装在 pkg-config 数据库目录中，而是仍然保留在用户已构建的第三方依赖项的项目源目录中。以下是一个示例：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**NOTE**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’m following the Autoconf recommended procedure here of passing environment
    variables as parameters to *`configure`*. Setting the variable in the environment
    or setting it on the same command line before *`configure`* works also, but is
    not recommended because *`configure`* is less aware of variables set in these
    other ways.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里遵循的是 Autoconf 推荐的做法，即将环境变量作为参数传递给 *`configure`*。在环境中设置变量或在 *`configure`*
    前的同一命令行中设置它也可以，但不推荐这样做，因为 *`configure`* 对这些通过其他方式设置的变量了解较少。*'
- en: Assuming *`$HOME`**/required/pkg* was where the required package was unpacked
    and built, and assuming the same directory held the (possibly generated) *.pc*
    files for that package and that there was a *-uninstalled* variant in that directory,
    that file would be accessed by executions of the `pkg-config` utility that reference
    the required package’s name from within our `configure` script.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*`$HOME`**/required/pkg*是所需包解压和构建的目录，并且假设该目录中包含该包的（可能生成的）*.pc*文件，并且该目录中有*-uninstalled*版本，则该文件将通过执行`pkg-config`工具时引用所需包名称的方式进行访问，这些执行来自我们`configure`脚本中的引用。
- en: Obviously, you would not want to install the *-uninstalled* variant of any of
    your *.pc* files—they’re designed to be used only in this fashion, from within
    a build directory. Perhaps not quite as obvious is the fact that the *-uninstalled*
    variants of your *.pc* files don’t contain all the same options as their installed
    counterparts. The difference, simply stated, is in the path options. The *-uninstalled*
    variants should contain absolute paths relative to the source location of your
    header files and the build location of your libraries so that when the options
    are passed to consumers’ tools, they’ll be able to find the products (header files
    and libraries) in those paths.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不希望安装任何带有*-uninstalled*后缀的*.pc*文件变体——它们仅设计用于在构建目录中以这种方式使用。或许不那么明显的是，带有*-uninstalled*后缀的*.pc*文件并不包含与已安装版本相同的所有选项。简而言之，它们的区别在于路径选项。*-uninstalled*版本应包含相对于头文件源位置和库构建位置的绝对路径，以便当选项传递给消费者工具时，它们能够在这些路径中找到产品（头文件和库）。
- en: Let’s try it out. Edit the *configure.ac* file you created from [Listing 10-3](ch10.xhtml#ch10ex3)
    to be like that shown in [Listing 10-7](ch10.xhtml#ch10ex7).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。编辑你在[示例 10-3](ch10.xhtml#ch10ex3)中创建的*configure.ac*文件，使其与[示例 10-7](ch10.xhtml#ch10ex7)中显示的文件相同。
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-7:* configure.ac: *Generating the* -uninstalled *variant of* test.pc'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-7:* configure.ac: *生成* -uninstalled *版本的* test.pc'
- en: Absolute paths can be derived by using appropriate Autoconf substitution variables,
    like `@abs_top_srcdir@` and `@abs_top_builddir@`, in the manner shown in [Listing
    10-8](ch10.xhtml#ch10ex8).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径可以通过使用适当的Autoconf替换变量来推导，例如在[示例 10-8](ch10.xhtml#ch10ex8)中所示的`@abs_top_srcdir@`和`@abs_top_builddir@`。
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-8:* test-uninstalled.pc: *A* -uninstalled *variant of* test.pc.in'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-8:* test-uninstalled.pc: *test.pc.in的* -uninstalled *版本*'
- en: 'This is the *-uninstalled* variant of the *.pc* file from [Listing 10-4](ch10.xhtml#ch10ex4).
    I’ve removed the `prefix` variable, as it no longer makes sense in this context.
    I’ve replaced the `${prefix}` references with `@abs_top_builddir@` in the `libdir`
    pkg-config variable at ➊ and `@abs_top_srcdir@` in the `includedir` pkg-config
    variable at ➋. Let’s try it out:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自[示例 10-4](ch10.xhtml#ch10ex4)的*.pc*文件的*-uninstalled*版本。我已经删除了`prefix`变量，因为在这种情况下它已经没有意义。我已将`${prefix}`引用替换为在`libdir`
    pkg-config变量中使用`@abs_top_builddir@`，在`includedir` pkg-config变量中使用`@abs_top_srcdir@`，如图➊和➋所示。让我们试试：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may be asking yourself at this point why this is supposed to be so much
    easier than just setting `CFLAGS` (or `CPPFLAGS`) and `LDFLAGS` on the `configure`
    command line. Well, for one thing, it’s easier to remember `PKG_CONFIG_PATH` than
    all of the potentially required individual tool variables. Another reason is the
    options are encapsulated where they’re best understood—within *.pc* files written
    by the required package’s author. Finally, if these options change, you’ll have
    to change your use of individual variables accordingly, but the `PKG_CONFIG_PATH`
    will remain the same. The extra level of indirection afforded by pkg-config hides
    all the details from both you and your power users and contributors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么这比在`configure`命令行中直接设置`CFLAGS`（或`CPPFLAGS`）和`LDFLAGS`要容易得多。嗯，一方面，记住`PKG_CONFIG_PATH`比记住所有可能需要的单个工具变量更容易。另一个原因是，这些选项被封装在最能理解它们的地方——即由所需软件包的作者编写的*.pc*文件中。最后，如果这些选项发生变化，你必须相应地改变你使用的单个变量，但`PKG_CONFIG_PATH`将保持不变。pkg-config提供的额外间接层次将所有细节隐藏在你和你的高级用户以及贡献者之外。
- en: Using pkg-config in configure.ac
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在configure.ac中使用pkg-config
- en: We’ve seen the way *.pc* files are put together. Now let’s take a look at how
    to consume this functionality in *configure.ac*. As mentioned in the previous
    section, the `--cflags` option provides access to the `Cflags` fields your compiler
    needs in order to compile this package. Let’s try this out with the *libssl.pc*
    file we saw previously. I’ve reproduced the relevant portion of [Listing 10-1](ch10.xhtml#ch10ex1)
    here in [Listing 10-9](ch10.xhtml#ch10ex9).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 *.pc* 文件是如何构建的。现在，让我们来看看如何在 *configure.ac* 中使用这个功能。如前一节所述，`--cflags`
    选项提供了编译器所需的 `Cflags` 字段，以便编译此包。让我们用之前看到的 *libssl.pc* 文件来试一试。我在 [清单 10-1](ch10.xhtml#ch10ex1)
    中的相关部分已在 [清单 10-9](ch10.xhtml#ch10ex9) 中重现。
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 10-9:* libssl.pc: *Relevant portion of this* .pc *file*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9:* libssl.pc: *此* .pc *文件的相关部分*'
- en: When we use the `--cflags` option against this *.pc* file, we now understand
    that we should see a `-I` compiler command line option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对这个 *.pc* 文件使用 `--cflags` 选项时，我们现在明白应该看到一个 `-I` 编译器命令行选项。
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And . . . nothing is printed. Huh, did we do something wrong? The *libssl.pc*
    file shows us that if we mentally expand the variables, we should see something
    like `-I/usr/include`, right? Actually, `pkg-config` is doing exactly what it
    should do—it’s printing *the additional command line options* necessary to find
    the *libssl* header files. We don’t need to tell the compiler about the */usr**/include*
    directory, as this is a standard location and `pkg-config` knows this and omits
    such options automatically.^([3](footnote.xhtml#ch10fn3))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，什么也没有打印出来。嗯，我们做错什么了吗？*libssl.pc* 文件告诉我们，如果我们将变量展开，我们应该看到类似于 `-I/usr/include`
    的内容，对吧？实际上，`pkg-config` 正在做它应该做的事情——它正在打印出找到 *libssl* 头文件所需的*附加命令行选项*。我们不需要告诉编译器关于
    */usr**/include* 目录的事情，因为这是一个标准位置，`pkg-config` 知道这一点，并会自动省略这类选项。^([3](footnote.xhtml#ch10fn3))
- en: 'Let’s try a *.pc* file whose `Cflags` value includes something other than standard
    include locations. Note here that I’m using `pkg-config` itself to find the location
    of its database directory for the *xorg-wacom.pc* file because it’s different
    on different Linux distributions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试一个 `Cflags` 值包含非标准包含位置的 *.pc* 文件。请注意，我在这里使用 `pkg-config` 本身来查找其数据库目录的路径，因为在不同的
    Linux 发行版上，这个路径是不同的，用来查找 *xorg-wacom.pc* 文件：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since */usr/include/xorg* is not a standard include path, a `-I` option for
    that path is displayed.^([4](footnote.xhtml#ch10fn4)) All of this means that you
    can be complete in documenting your package’s requirements in your *.pc* files
    without worrying about cluttering consumer compiler and linker command lines with
    pointless redundant definitions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 */usr/include/xorg* 不是一个标准的包含路径，因此会显示该路径的 `-I` 选项。^([4](footnote.xhtml#ch10fn4))
    这意味着你可以在你的 *.pc* 文件中完整地记录包的需求，而不必担心在消费者的编译器和链接器命令行中添加冗余的无用定义。
- en: So, how do we use this output? Nothing more difficult than a little shell script,
    as shown in [Listing 10-10](ch10.xhtml#ch10ex10).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这个输出呢？其实没有什么比一个小的 shell 脚本更难的了，正如在 [清单 10-10](ch10.xhtml#ch10ex10)
    中所示。
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 10-10: Using `pkg-config` to populate `CFLAGS` in* configure.ac'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：使用 `pkg-config` 填充 `CFLAGS` 在* configure.ac'
- en: The dollar-parens notation captures the output of this `pkg-config` command
    in the `LIBSSL_CFLAGS` environment variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用美元括号符号（dollar-parens notation）可以将此 `pkg-config` 命令的输出捕获到 `LIBSSL_CFLAGS` 环境变量中。
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may, of course, use backticks rather than the dollar-parens notation I
    used in [Listing 10-10](ch10.xhtml#ch10ex10) to accomplish the same goal. The
    backtick format is older and slightly more portable, but it has the drawback of
    not being easily nestable. For example, you cannot do something like *`$(pkg-config
    --cflags $(cat libssl-pc-file.txt))`* with backticks without a lot of escape magic.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，你可以使用反引号（backticks）来代替我在 [清单 10-10](ch10.xhtml#ch10ex10) 中使用的美元括号符号来实现相同的目标。反引号格式较旧，并且略微具有更好的可移植性，但它的缺点是无法轻松嵌套。例如，你不能像
    *`$(pkg-config --cflags $(cat libssl-pc-file.txt))`* 这样使用反引号，而不进行大量的转义魔法。*'
- en: 'The linker options are accessed in a similar manner:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器选项的访问方式类似：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Referring back to the *libssl.pc* file in [Listing 10-1](ch10.xhtml#ch10ex1),
    we can indeed see that the `Libs` line contained `-lssl`. Also, as we just discovered,
    the `-L` option, referring a standard linker location, */usr/lib/x86_64-linux-gnu*,
    was automatically omitted. We can add this to our *configure.ac* file in the manner
    shown in [Listing 10-11](ch10.xhtml#ch10ex11).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [列表 10-1](ch10.xhtml#ch10ex1) 中提到的 *libssl.pc* 文件，我们确实可以看到 `Libs` 行包含了 `-lssl`。同时，正如我们刚刚发现的，`-L`
    选项，指向一个标准的链接器位置，*/usr/lib/x86_64-linux-gnu*，被自动省略。我们可以按照 [列表 10-11](ch10.xhtml#ch10ex11)
    中展示的方式，将其添加到我们的 *configure.ac* 文件中。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-11: Using `pkg-config` to populate `LIBS` in* configure.ac'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-11：在 `pkg-config` 中填充 configure.ac 中的 `LIBS`*'
- en: Let’s tie it all together by populating all required variables for compiling
    *libssl* header files and linking with *libssl*. [Listing 10-12](ch10.xhtml#ch10ex12)
    shows how this might be done.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有内容结合起来，填充编译 *libssl* 头文件并与 *libssl* 链接所需的所有变量。[列表 10-12](ch10.xhtml#ch10ex12)
    展示了这可能是如何实现的。
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-12: Using `pkg-config` to access* libssl *in* configure.ac'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-12：在 `pkg-config` 中使用 libssl 访问 configure.ac*'
- en: 'Could it be any simpler or any more readable? I doubt it. Let’s look at one
    more example—that of linking statically to *libssl*, which also requires (privately)
    *libcrytpo*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 难道还有比这更简单或更易读的方法吗？我怀疑。让我们看一个更多的例子——即静态链接到 *libssl*，这也要求（私下）链接 *libcrypto*：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see in this console example at ➊, *libssl* privately requires the
    pkg-config-managed *libcrypto* package, meaning that linking to the *libssl* shared
    library does not require the addition of `-lcrypto` on the linker command line,
    but linking to it statically does require this additional library option. We can
    also see at ➋ that *libssl* privately requires a library that’s not maintained
    by pkg-config, *libdl.so*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在此控制台示例中看到的 ➊，*libssl* 私下要求由 pkg-config 管理的 *libcrypto* 包，这意味着链接到 *libssl*
    共享库时不需要在链接命令行中添加 `-lcrypto`，但静态链接时确实需要这个额外的库选项。我们还可以在 ➋ 看到，*libssl* 私下要求一个非 pkg-config
    管理的库 *libdl.so*。
- en: '**NOTE**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may find the contents of your* libssl.pc *and* libcrypto.pc *files are
    somewhat different from mine, depending on your Linux distribution and the version
    of openssl you have installed. Don’t worry about the differences—things will work
    fine on your system with your* .pc *files. The important part of this example
    is to understand the concepts I’m explaining.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会发现你的* libssl.pc *和* libcrypto.pc *文件的内容与我的有所不同，这取决于你所使用的 Linux 发行版和你安装的
    openssl 版本。别担心这些差异——你的系统和你的 * .pc * 文件上的一切都会正常工作。这个例子中最重要的是理解我所解释的概念。*'
- en: Moving down to the *libcrypto.pc* file, we see at ➌ that *libcrypto* also privately
    requires *libdl.so*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 *libcrypto.pc* 文件，我们在 ➌ 看到 *libcrypto* 还私下要求 *libdl.so*。
- en: The noteworthy item at ➍ is that pkg-config is “smart enough” to understand
    the linker’s library ordering requirements and set `-ldl` on the output line after
    both `-lssl` and `-lcrypto`.^([5](footnote.xhtml#ch10fn5)) We humans have a hard
    enough time doing this stuff manually at times. It’s nice when a tool comes along
    that just manages everything the way it should without making us worry about how
    it’s done. Ultimately, the point I’m trying to make is that pkg-config puts control
    of the options squarely in the hands of the person most likely to understand how
    all these options should be specified and ordered—the maintainer of our dependencies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍ 处，值得注意的是，pkg-config “足够智能” 能理解链接器的库排序要求，并将 `-ldl` 设置在输出行中，排在 `-lssl` 和 `-lcrypto`
    之后。^([5](footnote.xhtml#ch10fn5)) 我们人类有时很难手动完成这些事情。幸运的是，当一个工具能够处理一切，且不需要我们担心它是如何完成的时，真是太好了。最终，我想强调的是，pkg-config
    将选项的控制权牢牢掌握在最有可能理解这些选项如何指定和排序的人手中——我们依赖项的维护者。
- en: pkg-config Autoconf Macros
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pkg-config Autoconf 宏
- en: As I mentioned at the outset of this chapter, pkg-config also ships a set of
    Autoconf extension macros in a file called *pkg.m4* that’s installed into the
    */usr**(/local)/share/aclocal* directory, which is where `autoconf` looks for
    *.m4* files containing the Autoconf standard macros that you can use in your *configure.ac*
    files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开始时提到的，pkg-config 还提供了一组 Autoconf 扩展宏，存放在一个名为 *pkg.m4* 的文件中，并安装在 */usr**(/local)/share/aclocal*
    目录下，这也是 `autoconf` 查找 *.m4* 文件的位置，包含了你可以在 *configure.ac* 文件中使用的 Autoconf 标准宏。
- en: Why didn’t I use these in my examples? Well, there are a couple of reasons why
    I tend to avoid these macros, one obvious and the other more subtle—nefarious
    even. The obvious reason is how easy it is to use the `pkg-config` utility directly
    in shell script in *configure.ac*. Why would you try to wrap that in an M4 macro?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我在例子中没有使用这些宏？嗯，避免使用这些宏有几个原因，一个显而易见，另一个则更为微妙——甚至有些狡猾。显而易见的原因是，直接在 *configure.ac*
    中使用 `pkg-config` 工具在 shell 脚本中是多么容易。为什么要试图将它封装在 M4 宏中呢？
- en: As for the second reason, recall from previous discussions that the input to
    `autoconf` is a data stream containing the contents of your *configure.ac* file,
    along with all of the macro definitions required to allow M4 to expand all macro
    invocations into shell script. These macro definitions become part of the input
    stream because `autoconf` reads all of the *.m4* files in the */usr**(/local)/share/aclocal*
    directory first, before reading your *configure.ac* file. In other words, there
    is no indication to `autoconf` that a required *.m4* file is missing. It simply
    expects all macro definitions required by *configure.ac* to be found in the *.m4*
    files in the installation paths’ *aclocal* directory. As a result, `autoconf`
    cannot tell you if a macro definition in the input stream is not present. It simply
    fails to realize that `PKG_CHECK_MODULES` is a macro and, therefore, does not
    expand it to valid shell script. All of this happens when you run `autoconf` (or
    `autoreconf`). When you then try to run `configure`, it fails with messages that
    are so far removed from the actual problem that you couldn’t possibly know just
    from reading them what they mean.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第二个原因，回顾之前的讨论，`autoconf` 的输入是包含 *configure.ac* 文件内容的一个数据流，以及所有宏定义，这些宏定义允许
    M4 将所有宏调用展开为 shell 脚本。这些宏定义成为输入流的一部分，因为 `autoconf` 在读取你的 *configure.ac* 文件之前，首先会读取
    */usr**(/local)/share/aclocal* 目录中的所有 *.m4* 文件。换句话说，`autoconf` 并不知道一个必需的 *.m4*
    文件缺失。它仅仅期望在安装路径的 *aclocal* 目录中的 *.m4* 文件中找到 *configure.ac* 所需要的所有宏定义。因此，`autoconf`
    无法告诉你输入流中是否缺少某个宏定义。它只是没有意识到 `PKG_CHECK_MODULES` 是一个宏，因此没有将它展开成有效的 shell 脚本。所有这些都发生在你运行
    `autoconf`（或 `autoreconf`）时。当你接着尝试运行 `configure` 时，它会失败，并显示与实际问题相差甚远的错误信息，你仅凭这些信息无法知道它们的含义。
- en: A picture is worth a thousand words, so let’s try a quick experiment. Create
    a *configure.ac* file in an empty directory, as shown in [Listing 10-13](ch10.xhtml#ch10ex13).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅图胜过千言万语，所以让我们尝试一个快速实验。在一个空目录中创建一个 *configure.ac* 文件，如 [列表 10-13](ch10.xhtml#ch10ex13)
    所示。
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-13: A* configure.ac *file with an unknown* macro *expansion*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-13：一个* configure.ac *文件，其中有一个未知的* 宏 *扩展*'
- en: 'Now execute `autoconf`, followed by `./configure`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行 `autoconf`，然后是 `./configure`：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how you get no error while `autoconf` is converting *configure.ac* into
    *configure*. This makes complete sense because `m4`, being a text-based macro
    processor, doesn’t try to interpret anything in the data stream except for known
    macros. Everything else is passed directly though to the output stream, as if
    it were actual shell script.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `autoconf` 将 *configure.ac* 转换为 *configure* 时，你不会收到任何错误。这完全是合理的，因为 `m4`
    作为一个基于文本的宏处理器，只会尝试解释数据流中已知的宏。其他所有内容都会直接传递到输出流，就好像它是实际的 shell 脚本一样。
- en: When we ran `configure`, we got a cryptic error about unexpected end-of-file
    (at line 1675\. . . from a two-line *configure.ac* file). What’s really happening
    here is that you unintentionally started defining a shell function called `AN_UNDEFINED_MACRO`
    but didn’t supply a body in curly braces for the function. The shell thought this
    was not cool and told you about it in its usual succinct manner.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `configure` 时，得到了一个关于意外文件结束的加密错误（在第 1675 行……来自一个只有两行的 *configure.ac* 文件）。实际上发生的情况是，你不小心开始定义了一个名为
    `AN_UNDEFINED_MACRO` 的 shell 函数，但没有在大括号中提供该函数的主体。shell 认为这不对劲，并用它一贯简洁的方式告诉了你。
- en: 'Had we left the parentheses off of `AN_UNDEFINED_MACRO`, the shell would have
    been a bit more informational:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了 `AN_UNDEFINED_MACRO` 后面的圆括号，shell 会给出更具信息性的错误：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At least this time, the shell told us the name of the problematic item, giving
    us the opportunity to go looking for it in *configure.ac* and perhaps figure out
    what’s wrong.^([6](footnote.xhtml#ch10fn6))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 至少这次，shell 告诉了我们问题项的名称，给了我们机会去 *configure.ac* 中查找它，并可能弄清楚出了什么问题。^([6](footnote.xhtml#ch10fn6))
- en: The point is, this is exactly what happens when you *think* you’re using a pkg-config
    macro but *pkg.m4* was not found by `autoconf` while it was looking through the
    usual macro directories. Not very enlightening. In my humble opinion, you’re much
    better off just skipping the hundreds of lines of nontransparent macro code and
    using `pkg-config` directly in your *configure.ac* file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，当你*认为*自己在使用 pkg-config 宏，但 `autoconf` 在查找常规宏目录时没有找到 *pkg.m4* 时，就会发生这种情况。其实并没有太多启发。在我个人的谦虚意见中，你最好跳过那几百行不透明的宏代码，直接在
    *configure.ac* 文件中使用 `pkg-config`。
- en: 'The reasons why `autoconf` might not find your installed *pkg.m4* file are
    enlightening, however. One common reason is that you installed the *pkg-config*
    package (or it was automatically installed when the OS was installed) from your
    distro’s package repository, using `yum` or `apt`. But you downloaded, built,
    and installed Autoconf from the GNU website because your distro’s version of Autoconf
    is four revisions behind and you need the latest. Where did pkg-config’s installation
    process install *pkg.m4*? (Hint: */usr/share/aclocal*.) Where is `autoconf` getting
    its macro files from? (Hint: */usr/*local*/share/aclocal*.) You can, of course,
    easily remedy this problem by copying */usr/share/aclocal/pkg.m4* into */usr/local/share/aclocal*,
    and once you’ve hit this problem one or two times, you’ll never be caught by it
    again. But your power users and contributors will have to go through the same
    process—or you could just tell them all to buy this book and read [Chapter 10](ch10.xhtml).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`autoconf` 无法找到已安装的 *pkg.m4* 文件的原因却颇具启发性。有一个常见的原因是，你从你的发行版的包仓库中安装了 *pkg-config*
    包（或者在操作系统安装时它被自动安装了），使用了 `yum` 或 `apt`。但你从 GNU 网站下载、构建并安装了 Autoconf，因为你的发行版版本的
    Autoconf 版本落后了四个版本，而你需要最新的版本。那么，pkg-config 的安装过程将 *pkg.m4* 安装到了哪里？（提示：*/usr/share/aclocal*。）`autoconf`
    从哪里获取宏文件？（提示：*/usr/*local*/share/aclocal*。）当然，你可以通过将 */usr/share/aclocal/pkg.m4*
    复制到 */usr/local/share/aclocal* 来轻松解决这个问题，一旦你遇到这个问题一两次，你就再也不会被它困住了。但是你的高级用户和贡献者将不得不经历同样的过程——或者你也可以直接告诉他们都买本书，去读
    [第10章](ch10.xhtml)。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve discussed the benefits of using Autoconf with pkg-config,
    how to generate *.pc* files from Autoconf templates, how to use `pkg-config` from
    *configure.ac* files, and various nuances of pkg-config features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了将 Autoconf 与 pkg-config 一起使用的好处，如何从 Autoconf 模板生成 *.pc* 文件，如何从 *configure.ac*
    文件中使用 `pkg-config`，以及 pkg-config 特性的一些细微差别。
- en: You can read *somewhat* more about the proper use of the *pkg-config* package
    on the official pkg-config website at *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*.
    Dan Nicholson has written a concise and easy-to-follow tutorial on using pkg-config
    on his personal page at [freedesktop.org](http://freedesktop.org) (*[http://people.freedesktop.org/~dbn/pkg-config-guide.html](http://people.freedesktop.org/~dbn/pkg-config-guide.html)*).
    This page can also be accessed via links on the pkg-config website.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方的 pkg-config 网站上阅读一些关于正确使用 *pkg-config* 包的更多内容，网址是 *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*。Dan
    Nicholson 在他个人页面上写了一篇简明易懂的教程，介绍如何使用 pkg-config，网址是 [freedesktop.org](http://freedesktop.org)
    (*[http://people.freedesktop.org/~dbn/pkg-config-guide.html](http://people.freedesktop.org/~dbn/pkg-config-guide.html)*)。这个页面也可以通过
    pkg-config 网站上的链接访问。
- en: The *pkg-config* man page has a bit more information about the proper use of
    `pkg-config`, but, honestly, there isn’t much more out there, other than blog
    entries written by enterprising individuals. Thankfully, there really isn’t very
    much more to figure out about pkg-config. It’s well written and well documented
    (as far as software goes), with a few minor exceptions, which I’ve tried to cover
    here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg-config* 手册页提供了有关如何正确使用 `pkg-config` 的更多信息，但老实说，除了由一些有胆识的个人撰写的博客文章外，几乎没有其他更多的资料。幸运的是，关于
    pkg-config 其实没有太多需要搞明白的东西。它写得很好，文档也很完善（就软件而言），只有少数几个小问题，我已经在这里尝试覆盖了这些问题。'
