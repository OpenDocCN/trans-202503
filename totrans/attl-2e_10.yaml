- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: FINDING BUILD DEPENDENCIES WITH PKG-CONFIG
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PKG-CONFIG 查找构建依赖
- en: '*A common mistake that people make when trying to design something completely
    foolproof is to underestimate the ingenuity of complete fools.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*人们在尝试设计完全防傻的东西时常犯的一个错误，就是低估了彻头彻尾的傻瓜的创造力。'
- en: —Douglas Adams*, The Hitchhiker’s Guide to the Galaxy
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —道格拉斯·亚当斯*，《银河系漫游指南》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Let’s say your project depends on a library called *stpl*—some third-party library.
    How can your build system determine where *libstpl.so* is installed on an end
    user’s system? Where are *stpl*’s header files to be found? Do you simply assume
    */usr/lib* and */usr/include*? This is effectively what Autoconf does if you don’t
    tell it to look elsewhere, and for many packages perhaps that’s fine—it’s a common
    convention to install libraries and headers into these directories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目依赖于一个叫做 *stpl* 的库——一个第三方库。你的构建系统如何确定 *libstpl.so* 在终端用户系统上的安装位置？*stpl*
    的头文件在哪里？你是不是仅仅假设它们在 */usr/lib* 和 */usr/include* 中？如果你没有告诉 Autoconf 去别的地方找，这实际上就是
    Autoconf 的工作方式，对于许多软件包来说，这也许没问题——将库和头文件安装到这些目录是一个常见的约定。
- en: But what if they aren’t installed in these locations? Or perhaps they were built
    locally and installed into the */usr/local* tree. What compiler and linker options
    should be used when using *stpl* in your project? These are a few issues that
    have plagued developers from the beginning, and the Autotools don’t really do
    much to manage this problem. Autoconf expects any libraries you use to be installed
    into “standard places,” meaning into directories where the preprocessor and linker
    automatically look for header files and libraries. If a user has the library but
    it’s installed in a different location, the Autotools expect end users to know
    how to interpret the configuration failure. As it happens, there are several good
    reasons why many libraries are not installed in these standard places.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它们没有安装在这些位置呢？或者它们可能是本地构建并安装到 */usr/local* 目录树中。当你在项目中使用 *stpl* 时，应该使用哪些编译器和链接器选项？这些问题从一开始就困扰着开发人员，而
    Autotools 并没有真正解决这个问题。Autoconf 期望你使用的任何库都被安装到“标准位置”，也就是预处理器和链接器自动查找头文件和库的目录。如果用户有这个库，但它安装在了其他位置，Autotools
    就期望终端用户知道如何解释配置失败。事实上，有几个充分的理由解释了为什么许多库不会安装在这些标准位置。
- en: Additionally, Autoconf can’t easily find libraries that are not installed at
    all. For example, you may have just built a library package and you want another
    package to pick up headers and libraries from the first package’s build directory
    structure. This is possible with Autoconf, but it involves the end user setting
    variables like `CPPFLAGS` and `LDFLAGS` on the `configure` command line. The project
    maintainer can make things a little easier by providing user-specified configuration
    options with the `AC_ARG_ENABLE` and `AC_ARG_WITH` macros for libraries they anticipate
    might not be easy to find in standard places, but if your project uses a lot of
    third-party libraries, it’s just guesswork trying to determine which of these
    will be particularly problematic for users. And then, users are not often programmers;
    we cannot rely on them to have enough background to know what to use for option
    values, even if we do supply command line options for problematic dependencies.
    Throughout this chapter, I’ll refer to these as *build dependency issues*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Autoconf 并不容易找到那些根本没有安装的库。例如，你可能刚刚构建了一个库包，而你希望另一个包从第一个包的构建目录结构中获取头文件和库。这是
    Autoconf 可以做到的，但它需要终端用户在 `configure` 命令行中设置像 `CPPFLAGS` 和 `LDFLAGS` 这样的变量。项目维护者可以通过提供用户指定的配置选项，利用
    `AC_ARG_ENABLE` 和 `AC_ARG_WITH` 宏来简化这一过程，特别是针对他们预期不容易在标准位置找到的库。但是，如果你的项目使用了大量的第三方库，那么确定哪些库对于用户来说特别棘手，实际上只是猜测。而且，用户通常不是程序员；我们不能指望他们有足够的背景知识来知道应该为选项值使用什么，即使我们提供了命令行选项来解决问题依赖。贯穿本章，我将这些问题称为
    *构建依赖问题*。
- en: There is a tool that provides a solution for these types of problems in a more
    elegant fashion using a very common tactic in software design—by providing another
    layer of indirection. And it’s not part of the GNU Autotools. Regardless, its
    use has become so prolific over the past 20 years that it would be an oversight
    to exclude a description of *pkg-config* in any book that discusses Linux build
    systems. Pkg-config is as useful as it is today because a lot of projects have
    begun to use it—especially library projects, and most especially library projects
    that install into nonstandard locations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种工具通过使用软件设计中非常常见的策略——提供另一层间接性，优雅地解决了这些问题。它并不属于 GNU Autotools 的一部分。尽管如此，过去
    20 年来它的使用已经变得如此广泛，以至于如果在任何讨论 Linux 构建系统的书籍中不描述 *pkg-config*，那将是一个疏忽。pkg-config
    之所以如此有用，正是因为许多项目开始使用它——尤其是库项目，特别是那些安装到非标准位置的库项目。
- en: In this chapter, we’ll look at pkg-config’s components and functionality and
    how to use it in your projects. For your own library projects, we’ll also discuss
    how to update the pkg-config database as your package is installed onto users’
    (or as I like to call them, potential contributors’) systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 pkg-config 的组件和功能，以及如何在你的项目中使用它。对于你自己的库项目，我们还将讨论如何在你的包安装到用户（或者我喜欢称他们为潜在贡献者）系统时，更新
    pkg-config 数据库。
- en: Before we get started, allow me to state up front that this chapter makes a
    lot of references to filesystem objects that may or may not exist on your flavor
    of Linux, or perhaps exist in a different form or location. It’s the nature of
    what we’re doing here—we’re discussing packages with libraries and header files
    that probably exist in different locations on different Linux flavors. I’ll try
    to point out such potential differences as we come to them so you’ll not be too
    surprised when things don’t line up exactly on our two systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请允许我提前说明，本章中涉及到的很多文件系统对象可能在你的 Linux 版本中并不存在，或者可能以不同的形式或位置存在。这是我们所做的事情的本质——我们讨论的是包含库和头文件的包，这些文件可能在不同的
    Linux 版本中位于不同的位置。我会尽量指出这些潜在的差异，以便在两套系统中出现不完全一致时，你不会感到过于惊讶。
- en: A pkg-config Overview
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pkg-config 概述
- en: Pkg-config is an open source software utility maintained by the *[freedesktop.org](http://freedesktop.org)*
    project. The pkg-config website is a part of the [freedesktop.org](http://freedesktop.org)
    project website. The pkg-config project is the result of an effort to turn the
    `gnome-config` script—a part of the gnome build system—into a more general-purpose
    tool, and it seems to have caught on. Some inspiration for pkg-config also came
    from the `gtk-config` program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg-config 是一个开源软件工具，由 *[freedesktop.org](http://freedesktop.org)* 项目维护。pkg-config
    网站是 [freedesktop.org](http://freedesktop.org) 项目网站的一部分。pkg-config 项目是将 `gnome-config`
    脚本——gnome 构建系统的一部分——转变为一个更通用工具的努力结果，而且它似乎得到了广泛应用。pkg-config 的灵感也来自于 `gtk-config`
    程序。
- en: A NOTE ABOUT PKG-CONFIG CLONES
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PKG-CONFIG 克隆的说明
- en: The [freedesktop.org](http://freedesktop.org) pkg-config project has been around
    for a long time and has garnered a somewhat loyal following. As a direct result,
    other projects now exist that offer functionality that is similar—often identical—to
    the pkg-config project. One that comes to mind is the pkgconf project (which Red
    Hat’s Fedora Linux seems to prefer when you ask the `yum` package manager to install
    pkg-config for you).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[freedesktop.org](http://freedesktop.org) 的 pkg-config 项目已经存在很长时间，并且拥有一定数量的忠实用户。因此，现在有其他项目提供类似的功能——通常是完全相同的——与
    pkg-config 项目类似。其中一个就是 pkgconf 项目（当你要求 `yum` 包管理器为你安装 pkg-config 时，Red Hat 的 Fedora
    Linux 似乎更偏向使用它）。'
- en: Do not confuse these two. The pkgconf project is a modern clone of the original
    pkg-config project that comes with claims of higher efficiency—and as far as I’m
    concerned, it may very well live up to these claims. Regardless, this chapter
    is about pkg-config. If you’ve found a project that provides functionality similar
    to pkg-config and you like it, then by all means use it. My goal here is to teach
    you about pkg-config. If this material helps you understand how to use pkgconf,
    or another pkg-config clone, then you’re getting from this book exactly what I
    hoped to convey.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这两者混淆。pkgconf 项目是原始 pkg-config 项目的现代克隆，声称具有更高的效率——就我而言，它很可能确实能够兑现这些声明。不管怎样，本章是关于
    pkg-config 的。如果你发现某个项目提供类似于 pkg-config 的功能，并且你喜欢它，那么请随意使用它。我的目标是教你关于 pkg-config
    的知识。如果这些内容帮助你理解如何使用 pkgconf 或其他 pkg-config 克隆项目，那你从本书中得到的正是我希望传达的内容。
- en: That said, however, I cannot cover all of the nuanced differences among the
    different pkg-config clones. If you want to follow along with my examples and
    your flavor of Linux won’t install the original pkg-config package for you, you
    can always navigate in your browser to *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*
    and download and install version 0.29.2 of the original pkg-config project
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，话虽如此，我不能涵盖不同pkg-config克隆之间所有细微的差异。如果你想跟随我的示例，但你的Linux版本无法为你安装原版pkg-config包，你总是可以通过浏览器访问*[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*，下载并安装原版pkg-config项目的0.29.2版本。
- en: Pkg-config is used simply by invoking the `pkg-config` command line utility
    with options that display the desired data. When you’re looking for libraries
    and header files, the “desired data” includes package version information as well
    as compiler and linker options wherein library and header file locations are specified.
    For instance, to obtain C-preprocessor flags required to access a library’s header
    files, one need only specify the `--cflags` option on the `pkg-config` command
    line, and compiler options appropriate for the package are displayed to `stdout`.
    This display can be captured and appended to compiler command lines in your configuration
    scripts and makefiles as needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pkg-config非常简单，只需调用`pkg-config`命令行工具，并使用显示所需数据的选项。当你寻找库和头文件时，“所需数据”包括包的版本信息以及指定库和头文件位置的编译器和链接器选项。例如，要获取访问库头文件所需的C预处理器标志，只需在`pkg-config`命令行中指定`--cflags`选项，适用于该包的编译器选项就会显示在`stdout`中。这个输出可以捕捉并根据需要附加到你的配置脚本和makefile中的编译器命令行。
- en: Perhaps you’re wondering why we even need a tool like `pkg-config` when Autoconf
    provides the `AC_CHECK_LIB` and `AC_SEARCH_LIBS` macros. In the first place, as
    I mentioned previously, the Autoconf macros are designed to only look in “standard
    locations” for libraries. You can trick the macros into looking in other places
    by preloading search paths into `CPPFLAGS` (using `-I` options) and `LDFLAGS`
    (using `-L` options). However, pkg-config is designed to help you find libraries
    that may be installed in places only your users’ pkg-config installations know
    about; the best thing about pkg-config is that it knows how to find libraries
    and headers on end users’ systems that these users don’t even know about. Pkg-config
    can also tell your build system about additional dependencies required when your
    users are trying to statically link to your libraries. Therefore, it effectively
    hides such details from users, and that’s the sort of user experience we’re looking
    for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想，既然Autoconf已经提供了`AC_CHECK_LIB`和`AC_SEARCH_LIBS`宏，为什么我们还需要像`pkg-config`这样的工具呢？首先，正如我之前提到的，Autoconf的宏只会在“标准位置”查找库。你可以通过将搜索路径预加载到`CPPFLAGS`（使用`-I`选项）和`LDFLAGS`（使用`-L`选项）来欺骗这些宏，使其查找其他地方。然而，pkg-config的设计目的是帮助你找到那些可能安装在只有用户的pkg-config安装才知道的位置的库；pkg-config最棒的一点是，它知道如何在最终用户系统上找到那些用户自己都不知道的库和头文件。pkg-config还可以告诉你的构建系统，在用户尝试静态链接到你的库时，需要哪些额外的依赖项。因此，它有效地将这些细节从用户那里隐藏开来，这就是我们所追求的用户体验。
- en: There are, however, some caveats to using pkg-config with the Autotools. In
    the first edition of this book, I suggested that the `PKG_CHECK_MODULES` add-on
    M4 macro that’s shipped with pkg-config was a good approach to using it with Autoconf.
    I’ve since amended my thoughts on this issue as I’ve discovered over the years
    that the use of this macro can cause more problems than it solves under some rather
    common conditions. Additionally, `pkg-config` is so simple to use directly in
    shell script that it makes little sense to wrap it with less-than-transparent
    M4 macros. We’ll discuss this topic in much more detail in this chapter, but I
    wanted to set the stage for the pattern of use you’ll see in the examples that
    follow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用pkg-config与Autotools时，有一些注意事项。在本书的第一版中，我曾建议使用与pkg-config一起发布的`PKG_CHECK_MODULES`附加M4宏来与Autoconf配合使用，这是一种很好的方法。但随着多年来的发现，我已修改了对此问题的看法，因为我发现，在一些相当常见的情况下，使用这个宏可能会带来比解决问题更多的问题。此外，`pkg-config`在Shell脚本中直接使用非常简单，因此用不透明的M4宏将其包装起来几乎没有意义。本章我们将更加详细地讨论这一主题，但我想先为接下来的示例展示一种使用模式。
- en: Diving In
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入探讨
- en: 'Let’s start by looking at the output of the `--help` option for the `pkg-config`
    command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一下`pkg-config`命令的`--help`选项的输出：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ve only shown what I consider the most useful options here. There are another
    dozen or so, but these are the ones we’ll use all the time in our *configure.ac*
    files. (I’ve taken the liberty of wrapping long description lines as pkg-config
    seems to think everyone has a 300-column monitor.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里只展示了我认为最有用的选项。还有十几个其他的选项，但这些是我们在 *configure.ac* 文件中会经常使用的选项。（我已经将较长的描述行进行了换行，因为
    pkg-config 似乎认为每个人都有一个 300 列的显示器。）
- en: 'Let’s start by listing all of the modules pkg-config is aware of on the system.
    Here’s a sampling of the ones on my system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先列出系统中 pkg-config 已知的所有模块。以下是我系统上的一些示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pkg-config becomes *aware* of a package by having the package installation process
    update the pkg-config database, which is nothing more than a well-known directory
    that `pkg-config` examines to resolve queries. The database entries are simply
    plaintext files ending in a *.pc* extension. Therefore, making pkg-config aware
    of your library project during installation is nothing more difficult than generating
    and installing a text file, and Autoconf can help us generate this file, as we’ll
    see later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: pkg-config 通过让包的安装过程更新 pkg-config 数据库来“了解”一个包，这个数据库实际上只是一个知名目录，`pkg-config`
    会检查该目录来解决查询。数据库条目只是以 *.pc* 扩展名结尾的纯文本文件。因此，让 pkg-config 在安装过程中了解你的库项目，其实并没有比生成并安装一个文本文件更难，Autoconf
    可以帮助我们生成这个文件，稍后我们将看到这一点。
- en: 'The `pkg-config` utility looks in several directories to find these files.
    We can discover what directories it looks in, and the order of the search, by
    calling it with the `--debug` option and piping the output (sent to `stderr`)
    through `grep` in this manner:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg-config` 工具会在多个目录中查找这些文件。我们可以通过调用它并使用 `--debug` 选项，将输出（发送到 `stderr`）通过
    `grep` 管道来查看它查找的目录和搜索顺序，方法如下：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first three directories that `pkg-config` tried to look in on my system
    did not exist. These are all in the */usr/local* tree. I haven’t built and installed
    many packages on this system; as a result, I haven’t installed any *.pc* files
    into the */usr/local* tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg-config` 在我的系统上尝试查找的前三个目录不存在。这些目录都位于 */usr/local* 目录树中。我在这个系统上并没有构建和安装很多包，因此没有将任何
    *.pc* 文件安装到 */usr/local* 目录树中。'
- en: 'From the output, it’s clear that *.pc* files must be installed into one of
    these six directories: */usr(/local)/lib/x86_64-linux-gnu/pkgconfig*, */usr(/local)/lib/pkgconfig*,
    or */usr(/local)/share/pkgconfig*. When you think about it, you’ll recognize these
    paths as what amounts to pkg-config’s `${libdir}`*/**pkgconfig* and `${datadir}`*/pkgconfig*
    directories if, that is, pkg-config didn’t need to choose between */usr* and */usr/local*
    during its installation. In the early days, these were indeed just pkg-config’s
    library and data installation paths, but it didn’t take long for the project developers
    to realize that where pkg-config was installed was not really germane to where
    pkg-config should search on users’ systems for *.pc* files—they could be found
    in many locations, depending not on where pkg-config was installed but on where
    the users had installed packages on their systems—all over the place.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以清楚地看到，*.pc* 文件必须安装到以下六个目录中的一个：*/usr(/local)/lib/x86_64-linux-gnu/pkgconfig*、*/usr(/local)/lib/pkgconfig*
    或 */usr(/local)/share/pkgconfig*。当你仔细思考时，你会认识到这些路径本质上就是 pkg-config 的 `${libdir}`*/**pkgconfig*
    和 `${datadir}`*/pkgconfig* 目录，如果说 pkg-config 在安装时不需要在 */usr* 和 */usr/local* 之间做选择的话。早期，这些确实就是
    pkg-config 的库和数据安装路径，但不久之后，项目开发者就意识到 pkg-config 安装的位置与其应该在用户系统上搜索 *.pc* 文件的位置并无太大关系——这些文件可能分布在很多地方，取决于用户在系统上安装包的位置，而不是
    pkg-config 安装的位置。
- en: But what about packages installed into custom locations or packages not yet
    installed? Pkg-config has solutions for these cases as well. The `PKG_CONFIG_PATH`
    environment variable can prepend user-specified paths to the default search path
    `pkg-config` uses to search for its data files. We’ll discover how to use this
    functionality as we cover more details about using the `pkg-config` command in
    *configure.ac*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何处理安装到自定义位置的包或尚未安装的包呢？pkg-config 对这些情况也有解决方案。`PKG_CONFIG_PATH` 环境变量可以将用户指定的路径添加到
    `pkg-config` 用来搜索数据文件的默认搜索路径之前。随着我们在 *configure.ac* 中介绍更多使用 `pkg-config` 命令的细节，我们将学习如何使用这一功能。
- en: Writing pkg-config Metadata Files
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 pkg-config 元数据文件
- en: As stated earlier, pkg-config’s *.pc* files are simply short text files that
    describe critical aspects of the build-and-link process to consumer build processes
    that use components of these dependent packages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，pkg-config的*.pc*文件仅仅是简短的文本文件，它描述了构建和链接过程中的关键方面，供使用这些依赖包组件的消费端构建过程使用。
- en: 'Let’s take a look at a sample *.pc* file on my system—the one for the *libssl*
    library, a part of the OpenSSL package. First we’ll need to find it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我系统上的一个示例*.pc*文件——它是*libssl*库的文件，属于OpenSSL包的一部分。首先，我们需要找到它：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `--variable` option allows you to query the value of a variable, and `pcfiledir`
    is a pkg-config-defined variable that exists for every *.pc* file. I cover the
    complete list of predefined variables later in this chapter. The `pcfiledir` variable
    shows you the current location of the file as discovered by `pkg-config`. The
    nice thing about this variable is that it can also be used within your *.pc* file
    to provide a sort of relocation mechanism. If your library and include file paths
    are all relative to `${pcfiledir}` within your *.pc* file, you can move it anywhere
    you like (as long as you move the libraries and header files it locates to the
    same relative locations).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`--variable`选项允许你查询变量的值，`pcfiledir`是pkg-config为每个*.pc*文件定义的一个变量。我将在本章后面介绍预定义变量的完整列表。`pcfiledir`变量显示了`pkg-config`发现的文件当前所在位置。这一变量的好处在于，它也可以在你的*.pc*文件中使用，提供一种类似重定位的机制。如果你的库和包含文件路径都相对于`${pcfiledir}`在*.pc*文件中定义，你可以随意移动文件（只要你将它定位的库和头文件也移动到相同的相对位置）。'
- en: I’ve provided the full contents of my *libssl.pc* file in [Listing 10-1](ch10.xhtml#ch10ex1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[清单 10-1](ch10.xhtml#ch10ex1)中提供了我的*libssl.pc*文件的完整内容。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-1:* libssl.pc: *A sample* .pc *file*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1:* libssl.pc：*一个示例* .pc *文件*'
- en: 'A *.pc* file contains two types of entities: variable definitions (starting
    at ➊), which may reference other variables using Bourne shell–like syntax, and
    key-value tags (starting at ➋), which define the types of data that `pkg-config`
    can return about an installed package. These files can contain as little or as
    much of the pkg-config specification as is required by the package. Besides these
    entities, *.pc* files may also contain comments—any text preceded by a hash (`#`)
    mark. While these types of entities may be intermixed, it’s common convention
    to put variable definitions at the top, followed by the key-value pairs.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*.pc*文件包含两种类型的实体：变量定义（以➊开始），它们可以使用类似Bourne shell的语法引用其他变量；以及键值对标签（以➋开始），它们定义了`pkg-config`可以返回的关于已安装包的数据类型。这些文件可以包含pkg-config规范所需的任何内容，也可以只是包含最少的信息。除了这些实体，*.pc*文件还可以包含注释——任何以井号（`#`）标记开头的文本。虽然这些类型的实体可以混合出现，但通常的约定是将变量定义放在最上面，接着是键值对。'
- en: Variables look and act like shell variables; definitions are formatted as a
    variable name, followed by an equal (`=`) sign, followed by a value. You do not
    need to quote the value portion, even if it contains whitespace.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的外观和作用类似于shell变量；定义格式为变量名，后跟等号（`=`），再后跟值。即使值包含空格，你也无需对其进行引号处理。
- en: Pkg-config makes some predefined variables available for use within the *.pc*
    file and (as we’ve already seen) from the command line. [Table 10-1](ch10.xhtml#ch10tab1)
    shows these variables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg-config提供了一些预定义的变量，可以在*.pc*文件中使用，也可以通过命令行访问（正如我们之前所见）。[表 10-1](ch10.xhtml#ch10tab1)显示了这些变量。
- en: '**Table 10-1:** Pre-Defined Variables Recognized by pkg-config'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1:** pkg-config识别的预定义变量'
- en: '| **Variable** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| `pc_path` | The default search path used by `pkg-config` to find the *.pc*
    file |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `pc_path` | `pkg-config`用来查找*.pc*文件的默认搜索路径 |'
- en: '| `pcfiledir` | The installed location of the *.pc* file |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `pcfiledir` | *.pc*文件的安装位置 |'
- en: '| `pc_sysrootdir` | The system root directory set by the user, or */* by default
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `pc_sysrootdir` | 用户设置的系统根目录，默认值为`/*` |'
- en: '| `pc_top_builddir` | The location of the user’s top build directory when executing
    `pkg-config` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `pc_top_builddir` | 执行`pkg-config`时用户的顶级构建目录的位置 |'
- en: After you’ve looked at enough *.pc* files, you may begin to wonder if variables
    like `prefix`, `exec_prefix`, `includedir`, `libdir`, and `datadir` have any special
    meaning to pkg-config. They don’t; it’s just nice to define these paths relative
    to each other to reduce duplication.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你查看足够多的*.pc*文件后，你可能会开始想，像`prefix`、`exec_prefix`、`includedir`、`libdir`和`datadir`这些变量是否对pkg-config有特殊的意义。它们没有；它们只是用来相对定义这些路径，以减少重复。
- en: Key-value pairs are formatted as a well-known keyword, followed by a colon (`:`)
    character, followed by some text that makes up the value portion. Values may reference
    variables; referencing an undefined variable merely expands to nothing. Quotes
    are not needed in these values either.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对格式为一个知名关键词，后跟冒号（`:`）字符，然后是构成值部分的文本。值可以引用变量；引用未定义的变量仅会展开为空。这些值中也不需要使用引号。
- en: 'The keys of key-value pairs are well-known and documented, although putting
    unknown keys in the file has no effect on `pkg-config`’s ability to use the rest
    of the data in the file. The keys shown in [Table 10-2](ch10.xhtml#ch10tab2) are
    well-known:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对的键是知名且有文档记录的，尽管在文件中放置未知键不会影响`pkg-config`使用文件中其余数据的能力。[表 10-2](ch10.xhtml#ch10tab2)中显示的键是知名的：
- en: '**Table 10-2:** Well-Known Keys in Key-Value Pairs Recognized by pkg-config'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** pkg-config 识别的键值对中的知名键'
- en: '| **Key** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **描述** |'
- en: '| `Name` | A human-readable name for the library or package. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Name` | 库或包的可读名称。 |'
- en: '| `Description` | A brief human-readable description of the package. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Description` | 包的简短可读描述。 |'
- en: '| `URL` | A URL associated with the package—perhaps the package download site.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `URL` | 与包关联的 URL——可能是包的下载站点。 |'
- en: '| `Version` | A version string for the package. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Version` | 包的版本字符串。 |'
- en: '| `Requires` | A list of packages required by this package; specific versions
    may be specified. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Requires` | 本包所需的包列表；可以指定特定版本。 |'
- en: '| `Requires.private` | A list of private packages required by this package.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Requires.private` | 本包所需的私有包列表。 |'
- en: '| `Conflicts` | An optional field describing packages that this package conflicts
    with. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Conflicts` | 可选字段，描述本包与哪些包存在冲突。 |'
- en: '| `Cflags` | Compiler flags that should be used with this package. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Cflags` | 应该与此包一起使用的编译器标志。 |'
- en: '| `Libs` | Linker flags that should be used with this package. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Libs` | 应该与此包一起使用的链接器标志。 |'
- en: '| `Libs.private` | Linker flags for private libraries required by this package.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Libs.private` | 本包所需的私有库的链接器标志。 |'
- en: '*Informational Fields*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*信息字段*'
- en: To get the `pkg-config --exists` command to return zero to the shell, you need
    to specify `Name`, `Description`, and `Version`, at the very least. To be complete,
    consider also providing a URL if your project has one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`pkg-config --exists`命令返回零到 shell，你至少需要指定`Name`、`Description`和`Version`。为了完整起见，考虑在项目有
    URL 时也提供一个 URL。
- en: 'If you’re not sure why a particular `pkg-config` command is not working as
    expected, use the `--print-errors` option. Where `pkg-config` would normally silently
    return a shell code, `--print-errors` will display a reason for a nonzero shell
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定为什么某个特定的`pkg-config`命令没有按预期工作，可以使用`--print-errors`选项。在`pkg-config`通常会默默返回一个
    shell 代码的地方，`--print-errors`会显示非零 shell 代码的原因：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `--validate` option will also provide this information for both installed
    and uninstalled* .pc *files.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*`--validate`选项也会为已安装和未安装的*.pc*文件提供此信息。*'
- en: One obvious oversight is the lack of options for displaying the name and description
    information belonging to a package. The description is displayed when using the
    `--list-all` option; however, even the package name that shows up in that listing
    is actually the base name of the *.pc* file, not the value of the `Name` field
    from within the file. In spite of this, as mentioned previously, these three fields—`Name`,
    `Description`, and `Version`—are required; otherwise, as far as `pkg-config` is
    concerned, the package does not exist.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的疏漏是缺乏显示属于某个包的名称和描述信息的选项。描述信息在使用`--list-all`选项时会显示；然而，即使在该列表中显示的包名称实际上也是*.pc*文件的基础名称，而不是文件中`Name`字段的值。尽管如此，正如前面所提到的，这三个字段——`Name`、`Description`和`Version`——是必需的；否则，`pkg-config`认为该包不存在。
- en: '*Functional Fields*'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*功能字段*'
- en: The category of the `Version` field crosses over from informational to functional,
    as there are some `pkg-config` command line options that can make use of the value
    of this field to provide data about the package to configuration scripts. The
    `Requires`, `Requires.private`, `Cflags`, `Libs`, and `Libs.private` fields also
    provide machine-readable information to configuration scripts and makefiles. `Cflags`,
    `Libs`, and `Libs.private` directly provide command line options for the C compiler
    and linker. The options to be added to these tools’ command lines are accessed
    by using various of the `pkg-config` command line options.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Version` 字段的类别跨越了信息性到功能性，因为有一些 `pkg-config` 命令行选项可以利用该字段的值，为配置脚本提供有关包的数据。`Requires`、`Requires.private`、`Cflags`、`Libs`
    和 `Libs.private` 字段也为配置脚本和 makefile 提供机器可读的信息。`Cflags`、`Libs` 和 `Libs.private`
    直接提供了 C 编译器和链接器的命令行选项。通过使用不同的 `pkg-config` 命令行选项，可以访问这些工具命令行中要添加的选项。'
- en: While pkg-config is conceptually simple, some of the details are a bit elusive
    if you haven’t played with it long enough to glean a proper understanding. Let’s
    cover each of these fields in more detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 pkg-config 在概念上很简单，但一些细节如果你没有足够的实践，可能会有些难以捉摸。接下来我们将更详细地讲解这些字段。
- en: 'The informational fields are designed to be read by people. The package version,
    for instance, can be displayed using the `--modversion` option:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 信息性字段是为人类阅读而设计的。例如，可以使用 `--modversion` 选项显示包的版本：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not confuse the `--version` option with the *`--modversion`* option. If
    you do, you’ll quietly get pkg-config’s version, regardless of what module you
    specify after *`--version`*.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将 `--version` 选项与 *`--modversion`* 选项混淆。如果你混淆了，它会默默返回 pkg-config 的版本，无论你在
    *`--version`* 后指定什么模块。*'
- en: 'However, the `Version` field can also be used to indicate to configuration
    scripts if a package’s version meets requirements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Version` 字段也可以用来向配置脚本指示一个包的版本是否满足要求：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Library version checks go against Autoconf’s general philosophy of checking
    for required functionality, rather than checking for a specific version of a library,
    because some distro providers backport functionality to older versions of libraries
    so they can use that functionality without upgrading the library on a target version
    of their distro (mostly for convenience, as newer versions of libraries sometimes
    come with newer dependency requirements that can propagate for several levels).
    These examples are provided merely to show you what’s possible with the functionality
    provided by pkg-config.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*库版本检查与 Autoconf 的一般哲学相悖，后者检查的是所需功能而不是库的特定版本，因为某些发行版提供商会将功能回移植到旧版本的库，以便在不升级库的情况下在其发行版的目标版本上使用该功能（主要是为了方便，因为较新版本的库有时会带来新的依赖要求，这些要求可能会传播到多个级别）。这些示例仅用于向你展示
    pkg-config 提供的功能的可能性。*'
- en: 'Of the functional fields, some are more obvious than others. We’ll cover each
    of them, starting with the more trivial ones. The `Cflags` field is probably the
    simplest to comprehend. It merely provides include path additions and other options
    to the C preprocessor and compiler. All options for both of these tools are combined
    into this one field, but `pkg-config` provides command line options for returning
    portions of the field value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能字段中，有些比其他的更为直观。我们将逐一讲解每个字段，从较简单的开始。`Cflags` 字段可能是最简单的理解，它只是提供了包含路径的附加和其他选项给
    C 预处理器和编译器。这两个工具的所有选项都汇聚在这一字段中，但 `pkg-config` 提供了命令行选项，用于返回字段值的部分内容：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The important thing to notice here is that the *`Cflags`* field contains compiler
    command line options, not portions of compiler command line options. For example,
    to define an include path for your library, ensure the value in *`Cflags`* contains
    both the *`-I`* flag and the path, just as you would on the compiler command line.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里需要注意的重要事项是，*`Cflags`* 字段包含的是编译器命令行选项，而不是编译器命令行选项的部分。例如，要为你的库定义包含路径，确保 *`Cflags`*
    中包含 *`-I`* 标志和路径，就像在编译器命令行中那样。*'
- en: The other options that affect the output of the `Cflags` field are `--cflags-only-I`
    and `--cflags-only-other`. As you can see, `pkg-config` is aware of the difference
    between `-I` options and other options; if you specify `--cflags-only-I`, you’ll
    only see the `-I` options in the *.pc* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 影响 `Cflags` 字段输出的其他选项包括 `--cflags-only-I` 和 `--cflags-only-other`。如你所见，`pkg-config`
    区分了 `-I` 选项和其他选项；如果你指定了 `--cflags-only-I`，你只会看到 *.pc* 文件中的 `-I` 选项。
- en: The `Libs` field provides a place to set `-L`, `-l`, and any other options destined
    for the linker. For instance, if your package provides the *stpl* library, *libstpl.so*,
    you would add the `-L`*`/installed/lib/path`* and `-lstpl` options to the `Libs`
    field. Pkg-config’s `--libs` option returns the entire value, and, as with `Cflags`,
    there are separate options (`--libs-only-l`, `--libs-only-L`, and `--libs-only-other`)
    that separate and return subsets of the `Libs` options.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Libs`字段提供了设置`-L`、`-l`和其他面向链接器的选项的位置。例如，如果你的包提供了*stpl*库，即*libstpl.so*，你需要在`Libs`字段中添加`-L`*`/installed/lib/path`*和`-lstpl`选项。Pkg-config的`--libs`选项返回完整的值，并且与`Cflags`一样，有一些单独的选项（`--libs-only-l`，`--libs-only-L`，和`--libs-only-other`），它们将返回`Libs`选项的子集。'
- en: Somewhat harder to grasp is the use of the `Libs.private` field. This field
    is documented as being for libraries “required by this package but not exposed
    to applications.” In reality, however, while these are libraries required to build
    the library published by the package, they’re also libraries required by the consumer
    of the package if they’re linking statically to the package’s library.^([1](footnote.xhtml#ch10fn1))
    In fact, the use of `pkg-config`’s `--static` command line option, in conjunction
    with the `--libs` (or variations thereof) option, will display a combination of
    the `Libs` and `Libs.private` field options. This is because linking to a static
    library requires, at link time, all of the symbols required by all of the code
    pulled in from the static library to which you are directly linking.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较难理解的是`Libs.private`字段的使用。该字段的文档说明它是“该包所需但不暴露给应用程序的库”。然而，实际上，虽然这些是构建包发布的库所需的库，它们也是包的消费者在静态链接到该包的库时所需的库。^([1](footnote.xhtml#ch10fn1))事实上，使用`pkg-config`的`--static`命令行选项，配合`--libs`（或类似选项）选项，将会显示`Libs`和`Libs.private`字段选项的组合。这是因为，静态链接库时，在链接阶段，所有从静态库中直接链接的代码所需的符号都必须被链接。
- en: 'This is an important concept, and understanding how it works is the key to
    properly writing *.pc* files for your projects. Think about it from the end user’s
    perspective: they want to compile some project, and they want it to be linked
    statically with your library (we must also assume your project builds and installs
    a static version of your library, of course). In order to do this, what options
    and libraries will be required on the compiler and linker command lines, *in addition
    to those already required when linking to your dynamic library*, in order to successfully
    perform this task? The answer to this question will tell you what should go into
    the `Libs.private` field in the *.pc* file for your project.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的概念，理解它的工作原理是正确编写项目的*.pc*文件的关键。从终端用户的角度考虑：他们想要编译某个项目，并且希望将其与你的库静态链接（当然，我们还必须假设你的项目会构建并安装一个静态版本的库）。为了做到这一点，编译器和链接器命令行上需要哪些选项和库，*除了那些在链接到动态库时已经要求的选项*，才能成功完成这个任务？这个问题的答案将告诉你在你项目的*.pc*文件中`Libs.private`字段应填入什么内容。
- en: Now that those topics are behind us, we can properly discuss the `Requires`
    and `Requires.private` fields. The values in these fields are other pkg-config
    package names, with optional version specifications. If your package requires
    a particular version of another package that’s also managed by pkg-config, you
    need only specify that package in the `Requires` field if its `Cflags` and `Libs`
    field values are required by your users’ build processes in order to consume your
    package’s shared library, or in the `Requires.private` field if its `Cflags` and
    `Libs.private` field values are required in order to consume your package’s static
    library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些话题已经讲完，我们可以正式讨论`Requires`和`Requires.private`字段。这些字段中的值是其他pkg-config包的名称，并可以选择性地指定版本。如果你的包依赖于另一个由pkg-config管理的特定版本的包，只需要在`Requires`字段中指定该包，前提是它的`Cflags`和`Libs`字段的值是用户的构建过程需要的，以便使用你包的共享库；如果它的`Cflags`和`Libs.private`字段的值是用户构建静态库时需要的，则应将该包指定在`Requires.private`字段中。
- en: With this understanding of `Requires` and `Requires.private`, we can now see
    that additional options required by pkg-config packages that you’d normally put
    into your `Cflags` and `Libs` or `Libs.private` fields are not needed in those
    fields because you can simply reference the package by name (and version or version
    range) in `Requires` or `Requires.private`. Pkg-config will recursively find and
    combine options from all the packages’ fields as needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: If the package required by your package is not managed by pkg-config, you must
    add the options you’d normally find in such *.pc* files into your own `Cflags`,
    `Libs`, and `Libs.private` fields.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The version specification used in the `Requires` and `Requires.private` fields
    matches that of the RPM version specification. You may use `>`, `>=`, `=`, `<=`,
    or `<`. Sadly, these fields only allow one instance of a given library, which
    means you can’t apply both upper and lower bounds on the versions of required
    packages. [Listing 10-2](ch10.xhtml#ch10ex2) provides a contrived example of using
    version ranges.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-2: Specifying version and version ranges in `Requires`*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Requires` field indicates that two libraries are required here: *chooser*
    and *player*. The version of *chooser* must be 1.0.1 or higher, and the version
    of *player* must be less than 3.0.^([2](footnote.xhtml#ch10fn2))'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Conflicts` field merely allows you as the author of a package
    to define packages that conflict with your package, and the format of the field
    is identical to that of `Requires` and `Requires.private`. For this field you
    may provide the same package more than once in order to define specific ranges
    of versions that conflict with your package.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve completed writing your *.pc* file, you can validate it using the
    `--validate` option:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*You can use any *`pkg-config`* options that provide field information on either
    an installed* .pc *file, by using just the base name of the file, or on an uninstalled*
    .pc *file, by specifying the full name of the file, as is done in this example.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: If you have any errors that `pkg-config` can detect, they’ll be displayed. If
    you see nothing, then you know that `pkg-config` can at least parse your file
    properly and that a few basic checks pass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Generating .pc Files with Autoconf
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand the basic structure of a *.pc* file, let’s consider
    how we might use configuration data generated by our configuration scripts to
    generate a *.pc* file. Consider the types of information provided by pkg-config.
    Much of it is path information, and configuration scripts are designed to manage
    all these paths, including install locations for built products.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: For example, the user may specify an installation prefix on the `configure`
    command line. This prefix determines where the package’s include files and libraries
    will end up on their system when they install the package. The *.pc* file had
    better know these locations, and it would be nice of us to provide a build system
    that automatically updates this file to reflect the prefix path the user specified
    on their `configure` command line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating pc Files from pc.in Templates*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To accomplish this, we won’t write *.pc* files. Instead, we’ll write *.pc.in*
    template files for Autoconf and set the value of the `prefix` variable to `@prefix@`
    in these templates. That way, `configure` will replace this reference with the
    actual configured prefix when it converts the *.pc.in* template into the installable
    *.pc* file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We can also set the value of the `Version` field to `@PACKAGE_VERSION@`, which
    is defined by the value you pass to the Autoconf `AC_INIT` macro in *configure.ac*.
    To facilitate an experiment, create a *configure.ac* file in an empty directory,
    as shown in [Listing 10-3](ch10.xhtml#ch10ex3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-3:* configure.ac: *Generating test*.pc *from* test.pc.in'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Now create a *test.pc.in* file in the same directory, like the one shown in
    [Listing 10-4](ch10.xhtml#ch10ex4).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-4:* test.pc.in: *A* .pc *template file*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve specified the `prefix` and `Version` field values at ➊ and ➋ as Autoconf
    substitution variable references.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the file and check the result:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see at ➊ and ➋ in the console output, the Autoconf variable references
    were replaced in the generated *test.pc* file with the values of those Autoconf
    variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating .pc Files with make*'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generating *.pc* files from templates using Autoconf has the disadvantage of
    inhibiting the user’s ability to change their prefix choices when they run `make`.
    This minor issue can be overcome by writing *Makefile.am* rules to generate the
    *.pc* files. Change the *configure.ac* file from the previous experiment, as shown
    in [Listing 10-5](ch10.xhtml#ch10ex5).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-5:* configure.ac: *Changes required to [Listing 10-3](ch10.xhtml#ch10ex3)
    to generate* test.pc *using* `make`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Now add a *Makefile.am* file, as shown in [Listing 10-6](ch10.xhtml#ch10ex6).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-6:* Makefile.am: *Adding* `make` *rules to generate* test.pc'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The key functionality in [Listing 10-6](ch10.xhtml#ch10ex6) is encapsulated
    in the pattern rule that converts *.pc.in* files into *.pc* files using a simple
    `sed` command. The only odd bit in this `sed` command is the use of square brackets
    around the leading at (`@`) sign on the variables to be replaced. Those brackets
    are treated by `sed` as extraneous regular expression syntax, but the effect they
    have on Autoconf is to inhibit it from interpreting the sequence as the opening
    character of a replacement variable. We don’t want Autoconf replacing this variable.
    Rather, we want `sed` to look for the sequence in *test.pc.in*. Another solution
    is to come up with your own format for variables to be replaced, but do note that
    this syntax is fairly common in the Autotools community for this very purpose.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*Pattern rules are specific to GNU *`make`* and are therefore not portable.
    There has been some chatter recently on the Automake mailing list of relaxing
    the restriction requiring the generation of portable *`make`* syntax and simply
    requiring GNU *`make`* because GNU *`make`* has been ported so widely these days.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, I’ve added *test.pc* to the Automake `EXTRA_DIST` variable
    so it will be built when `make dist` or `distclean` is executed, but you can add
    *test.pc* as a prerequisite to any target in your *Makefile.am* files to make
    it available to that stage of the build if required. Let’s try it out:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that I added `prefix=/usr` to the `make` command line; thus, *test.pc*
    was generated with that value in the `prefix` variable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalled .pc Files
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned at the outset of this chapter that pkg-config had the ability to
    handle resolving references to uninstalled libraries and header files also. By
    *uninstalled*, I mean products that have been built but not installed; they’re
    still sitting in another project’s build output directory. Let’s now consider
    how this is done.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, a user would set `PKG_CONFIG_PATH` to point to a directory containing
    a *-uninstalled* variant of a required package’s *.pc* file. By “*-uninstalled*
    variant,” I mean that a *.pc* file named *test.pc* would have a *-uninstalled*
    variant named *test-uninstalled.pc*. The *-uninstalled* variant is not installed
    in a pkg-config database directory but, rather, is still sitting in the project
    source directory for the third-party dependency that the user has built. Here’s
    an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**NOTE**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '*I’m following the Autoconf recommended procedure here of passing environment
    variables as parameters to *`configure`*. Setting the variable in the environment
    or setting it on the same command line before *`configure`* works also, but is
    not recommended because *`configure`* is less aware of variables set in these
    other ways.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Assuming *`$HOME`**/required/pkg* was where the required package was unpacked
    and built, and assuming the same directory held the (possibly generated) *.pc*
    files for that package and that there was a *-uninstalled* variant in that directory,
    that file would be accessed by executions of the `pkg-config` utility that reference
    the required package’s name from within our `configure` script.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you would not want to install the *-uninstalled* variant of any of
    your *.pc* files—they’re designed to be used only in this fashion, from within
    a build directory. Perhaps not quite as obvious is the fact that the *-uninstalled*
    variants of your *.pc* files don’t contain all the same options as their installed
    counterparts. The difference, simply stated, is in the path options. The *-uninstalled*
    variants should contain absolute paths relative to the source location of your
    header files and the build location of your libraries so that when the options
    are passed to consumers’ tools, they’ll be able to find the products (header files
    and libraries) in those paths.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it out. Edit the *configure.ac* file you created from [Listing 10-3](ch10.xhtml#ch10ex3)
    to be like that shown in [Listing 10-7](ch10.xhtml#ch10ex7).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-7:* configure.ac: *Generating the* -uninstalled *variant of* test.pc'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Absolute paths can be derived by using appropriate Autoconf substitution variables,
    like `@abs_top_srcdir@` and `@abs_top_builddir@`, in the manner shown in [Listing
    10-8](ch10.xhtml#ch10ex8).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-8:* test-uninstalled.pc: *A* -uninstalled *variant of* test.pc.in'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the *-uninstalled* variant of the *.pc* file from [Listing 10-4](ch10.xhtml#ch10ex4).
    I’ve removed the `prefix` variable, as it no longer makes sense in this context.
    I’ve replaced the `${prefix}` references with `@abs_top_builddir@` in the `libdir`
    pkg-config variable at ➊ and `@abs_top_srcdir@` in the `includedir` pkg-config
    variable at ➋. Let’s try it out:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may be asking yourself at this point why this is supposed to be so much
    easier than just setting `CFLAGS` (or `CPPFLAGS`) and `LDFLAGS` on the `configure`
    command line. Well, for one thing, it’s easier to remember `PKG_CONFIG_PATH` than
    all of the potentially required individual tool variables. Another reason is the
    options are encapsulated where they’re best understood—within *.pc* files written
    by the required package’s author. Finally, if these options change, you’ll have
    to change your use of individual variables accordingly, but the `PKG_CONFIG_PATH`
    will remain the same. The extra level of indirection afforded by pkg-config hides
    all the details from both you and your power users and contributors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Using pkg-config in configure.ac
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen the way *.pc* files are put together. Now let’s take a look at how
    to consume this functionality in *configure.ac*. As mentioned in the previous
    section, the `--cflags` option provides access to the `Cflags` fields your compiler
    needs in order to compile this package. Let’s try this out with the *libssl.pc*
    file we saw previously. I’ve reproduced the relevant portion of [Listing 10-1](ch10.xhtml#ch10ex1)
    here in [Listing 10-9](ch10.xhtml#ch10ex9).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 10-9:* libssl.pc: *Relevant portion of this* .pc *file*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `--cflags` option against this *.pc* file, we now understand
    that we should see a `-I` compiler command line option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And . . . nothing is printed. Huh, did we do something wrong? The *libssl.pc*
    file shows us that if we mentally expand the variables, we should see something
    like `-I/usr/include`, right? Actually, `pkg-config` is doing exactly what it
    should do—it’s printing *the additional command line options* necessary to find
    the *libssl* header files. We don’t need to tell the compiler about the */usr**/include*
    directory, as this is a standard location and `pkg-config` knows this and omits
    such options automatically.^([3](footnote.xhtml#ch10fn3))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a *.pc* file whose `Cflags` value includes something other than standard
    include locations. Note here that I’m using `pkg-config` itself to find the location
    of its database directory for the *xorg-wacom.pc* file because it’s different
    on different Linux distributions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since */usr/include/xorg* is not a standard include path, a `-I` option for
    that path is displayed.^([4](footnote.xhtml#ch10fn4)) All of this means that you
    can be complete in documenting your package’s requirements in your *.pc* files
    without worrying about cluttering consumer compiler and linker command lines with
    pointless redundant definitions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we use this output? Nothing more difficult than a little shell script,
    as shown in [Listing 10-10](ch10.xhtml#ch10ex10).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 10-10: Using `pkg-config` to populate `CFLAGS` in* configure.ac'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The dollar-parens notation captures the output of this `pkg-config` command
    in the `LIBSSL_CFLAGS` environment variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '*You may, of course, use backticks rather than the dollar-parens notation I
    used in [Listing 10-10](ch10.xhtml#ch10ex10) to accomplish the same goal. The
    backtick format is older and slightly more portable, but it has the drawback of
    not being easily nestable. For example, you cannot do something like *`$(pkg-config
    --cflags $(cat libssl-pc-file.txt))`* with backticks without a lot of escape magic.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The linker options are accessed in a similar manner:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Referring back to the *libssl.pc* file in [Listing 10-1](ch10.xhtml#ch10ex1),
    we can indeed see that the `Libs` line contained `-lssl`. Also, as we just discovered,
    the `-L` option, referring a standard linker location, */usr/lib/x86_64-linux-gnu*,
    was automatically omitted. We can add this to our *configure.ac* file in the manner
    shown in [Listing 10-11](ch10.xhtml#ch10ex11).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-11: Using `pkg-config` to populate `LIBS` in* configure.ac'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tie it all together by populating all required variables for compiling
    *libssl* header files and linking with *libssl*. [Listing 10-12](ch10.xhtml#ch10ex12)
    shows how this might be done.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-12: Using `pkg-config` to access* libssl *in* configure.ac'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Could it be any simpler or any more readable? I doubt it. Let’s look at one
    more example—that of linking statically to *libssl*, which also requires (privately)
    *libcrytpo*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see in this console example at ➊, *libssl* privately requires the
    pkg-config-managed *libcrypto* package, meaning that linking to the *libssl* shared
    library does not require the addition of `-lcrypto` on the linker command line,
    but linking to it statically does require this additional library option. We can
    also see at ➋ that *libssl* privately requires a library that’s not maintained
    by pkg-config, *libdl.so*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '*You may find the contents of your* libssl.pc *and* libcrypto.pc *files are
    somewhat different from mine, depending on your Linux distribution and the version
    of openssl you have installed. Don’t worry about the differences—things will work
    fine on your system with your* .pc *files. The important part of this example
    is to understand the concepts I’m explaining.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Moving down to the *libcrypto.pc* file, we see at ➌ that *libcrypto* also privately
    requires *libdl.so*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The noteworthy item at ➍ is that pkg-config is “smart enough” to understand
    the linker’s library ordering requirements and set `-ldl` on the output line after
    both `-lssl` and `-lcrypto`.^([5](footnote.xhtml#ch10fn5)) We humans have a hard
    enough time doing this stuff manually at times. It’s nice when a tool comes along
    that just manages everything the way it should without making us worry about how
    it’s done. Ultimately, the point I’m trying to make is that pkg-config puts control
    of the options squarely in the hands of the person most likely to understand how
    all these options should be specified and ordered—the maintainer of our dependencies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: pkg-config Autoconf Macros
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned at the outset of this chapter, pkg-config also ships a set of
    Autoconf extension macros in a file called *pkg.m4* that’s installed into the
    */usr**(/local)/share/aclocal* directory, which is where `autoconf` looks for
    *.m4* files containing the Autoconf standard macros that you can use in your *configure.ac*
    files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Why didn’t I use these in my examples? Well, there are a couple of reasons why
    I tend to avoid these macros, one obvious and the other more subtle—nefarious
    even. The obvious reason is how easy it is to use the `pkg-config` utility directly
    in shell script in *configure.ac*. Why would you try to wrap that in an M4 macro?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: As for the second reason, recall from previous discussions that the input to
    `autoconf` is a data stream containing the contents of your *configure.ac* file,
    along with all of the macro definitions required to allow M4 to expand all macro
    invocations into shell script. These macro definitions become part of the input
    stream because `autoconf` reads all of the *.m4* files in the */usr**(/local)/share/aclocal*
    directory first, before reading your *configure.ac* file. In other words, there
    is no indication to `autoconf` that a required *.m4* file is missing. It simply
    expects all macro definitions required by *configure.ac* to be found in the *.m4*
    files in the installation paths’ *aclocal* directory. As a result, `autoconf`
    cannot tell you if a macro definition in the input stream is not present. It simply
    fails to realize that `PKG_CHECK_MODULES` is a macro and, therefore, does not
    expand it to valid shell script. All of this happens when you run `autoconf` (or
    `autoreconf`). When you then try to run `configure`, it fails with messages that
    are so far removed from the actual problem that you couldn’t possibly know just
    from reading them what they mean.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: A picture is worth a thousand words, so let’s try a quick experiment. Create
    a *configure.ac* file in an empty directory, as shown in [Listing 10-13](ch10.xhtml#ch10ex13).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-13: A* configure.ac *file with an unknown* macro *expansion*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute `autoconf`, followed by `./configure`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how you get no error while `autoconf` is converting *configure.ac* into
    *configure*. This makes complete sense because `m4`, being a text-based macro
    processor, doesn’t try to interpret anything in the data stream except for known
    macros. Everything else is passed directly though to the output stream, as if
    it were actual shell script.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: When we ran `configure`, we got a cryptic error about unexpected end-of-file
    (at line 1675\. . . from a two-line *configure.ac* file). What’s really happening
    here is that you unintentionally started defining a shell function called `AN_UNDEFINED_MACRO`
    but didn’t supply a body in curly braces for the function. The shell thought this
    was not cool and told you about it in its usual succinct manner.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Had we left the parentheses off of `AN_UNDEFINED_MACRO`, the shell would have
    been a bit more informational:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At least this time, the shell told us the name of the problematic item, giving
    us the opportunity to go looking for it in *configure.ac* and perhaps figure out
    what’s wrong.^([6](footnote.xhtml#ch10fn6))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The point is, this is exactly what happens when you *think* you’re using a pkg-config
    macro but *pkg.m4* was not found by `autoconf` while it was looking through the
    usual macro directories. Not very enlightening. In my humble opinion, you’re much
    better off just skipping the hundreds of lines of nontransparent macro code and
    using `pkg-config` directly in your *configure.ac* file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons why `autoconf` might not find your installed *pkg.m4* file are
    enlightening, however. One common reason is that you installed the *pkg-config*
    package (or it was automatically installed when the OS was installed) from your
    distro’s package repository, using `yum` or `apt`. But you downloaded, built,
    and installed Autoconf from the GNU website because your distro’s version of Autoconf
    is four revisions behind and you need the latest. Where did pkg-config’s installation
    process install *pkg.m4*? (Hint: */usr/share/aclocal*.) Where is `autoconf` getting
    its macro files from? (Hint: */usr/*local*/share/aclocal*.) You can, of course,
    easily remedy this problem by copying */usr/share/aclocal/pkg.m4* into */usr/local/share/aclocal*,
    and once you’ve hit this problem one or two times, you’ll never be caught by it
    again. But your power users and contributors will have to go through the same
    process—or you could just tell them all to buy this book and read [Chapter 10](ch10.xhtml).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve discussed the benefits of using Autoconf with pkg-config,
    how to generate *.pc* files from Autoconf templates, how to use `pkg-config` from
    *configure.ac* files, and various nuances of pkg-config features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You can read *somewhat* more about the proper use of the *pkg-config* package
    on the official pkg-config website at *[https://www.freedesktop.org/wiki/Software/pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config)*.
    Dan Nicholson has written a concise and easy-to-follow tutorial on using pkg-config
    on his personal page at [freedesktop.org](http://freedesktop.org) (*[http://people.freedesktop.org/~dbn/pkg-config-guide.html](http://people.freedesktop.org/~dbn/pkg-config-guide.html)*).
    This page can also be accessed via links on the pkg-config website.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The *pkg-config* man page has a bit more information about the proper use of
    `pkg-config`, but, honestly, there isn’t much more out there, other than blog
    entries written by enterprising individuals. Thankfully, there really isn’t very
    much more to figure out about pkg-config. It’s well written and well documented
    (as far as software goes), with a few minor exceptions, which I’ve tried to cover
    here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
