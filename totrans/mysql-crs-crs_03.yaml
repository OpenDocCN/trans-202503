- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Databases and Tables
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll use MySQL Workbench to view and create databases in
    MySQL. Then you’ll learn how to create tables to store data in those databases.
    You’ll define the name of the table and its columns and specify the type of data
    that the columns can contain. Once you’ve practiced these basics, you’ll improve
    your tables using two helpful MySQL features, constraints and indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQL Workbench
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned in [Chapter 1](c01.xhtml), MySQL Workbench is a visual tool you
    can use to enter and run SQL commands and view their results. Here, we’ll walk
    through the basics of how to use MySQL Workbench to view databases.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll start by opening MySQL Workbench by double-clicking its icon. The tool
    looks like [Figure 2-1](#figure2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: Showing databases with MySQL Workbench'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-right panel, enter the `show databases;` command. Make sure to include
    the semicolon, which indicates the end of the statement. Then click the lightning
    bolt icon, highlighted in [Figure 2-1](#figure2-1), to execute the command. The
    results, a list of available MySQL databases, appear in the Result Grid panel
    (your results will look different from mine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some databases in this list are system databases that were created automatically
    when MySQL was installed—such as `information_schema`, `mysql`, and `performance_schema`—and
    others are databases I’ve created. Any databases you create should appear in this
    list.
  prefs: []
  type: TYPE_NORMAL
- en: You can also browse databases by using the Navigator panel on the left. Click
    the **Schemas** tab at the bottom of the panel to show a list of databases, and
    click the right arrow (▶) to investigate the contents of your databases. Note
    that, by default, the Navigator panel doesn’t show the system databases that were
    automatically created when MySQL was installed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to view the list of databases in MySQL, it’s time to
    try creating your own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new database, you use the `create database` command along with
    a name for the database you want to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Your database’s name should describe the type of data stored there. In this
    example, the database called `circus` might contain tables for data on clowns,
    tightrope walkers, and trapeze acts. The `finance` database might have tables
    for accounts receivable, income, and cash flow. Tables of data on bands, songs,
    and albums might go in the `music` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a database, use the `drop database` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These commands remove the three databases you just created, any tables in those
    databases, and all of the data in those tables.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you haven’t actually created any tables yet. You’ll do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, you’ll create a new table to hold global population data and
    specify what type of data the table can contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, you create a database called `land` using the `create database` command
    you saw earlier. On the next line, the `use` command tells MySQL to use the `land`
    database for the SQL statements that follow it. This ensures that your new table
    will be created in the `land` database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use the `create table` command followed by a descriptive name for
    the table, `continent`. Within parentheses, you create three columns in the `continent`
    table—`continent_id`, `continent_name`, and `population`—and for each column you
    choose a MySQL data type that controls the type of data allowed in that column.
    Let’s go over this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: You define the `continent_id` column as an `int` so that it will accept integer
    (numeric) data. Each continent will have its own distinct ID number in this column
    (1, 2, 3, and so on). Then, you define the `continent_name` column as a `varchar(20)`
    to accept character data up to 20 characters long. Finally, you define the `population`
    as a `bigint` to accept big integers, as the population of an entire continent
    can be quite a large number.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this `create table` statement, MySQL creates an empty table. The
    table has a table name and its columns are defined, but it doesn’t have any rows
    yet. You can add, delete, and modify the rows in the table whenever you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to add a row with data that doesn’t match one of the column’s data
    types, however, MySQL will reject the entire row. For example, because the `continent_id`
    column was defined as an `int`, MySQL won’t allow that column to store values
    like `Continent #1` or `A` because those values contain letters. MySQL won’t allow
    you to store a value like `The Continent of Atlantis` in the `continent_name`
    column either, since that value has more than 20 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create your own database tables, MySQL allows you to put *constraints*,
    or rules, on the data they contain. Once you define constraints, MySQL will enforce
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints help maintain *data integrity*; that is, they help keep the data
    in your database accurate and consistent. For example, you might want to add a
    constraint to the `continent` table so that there can’t be two rows in the table
    with the same value in a particular column.
  prefs: []
  type: TYPE_NORMAL
- en: The constraints available in MySQL are `primary key`, `foreign key`, `not null`,
    `unique`, `check`, and `default`.
  prefs: []
  type: TYPE_NORMAL
- en: Primary Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Identifying the primary key in a table is an essential part of database design.
    A primary key consists of a column, or more than one column, and uniquely identifies
    the rows in a table. When you create a database table, you need to determine which
    column(s) should make up the primary key, because that information will help you
    retrieve the data later. If you combine data from multiple tables, you’ll need
    to know how many rows to expect from each table and how to join the tables. You
    don’t want duplicate or missing rows in your result sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this `customer` table with the columns `customer_id`, `first_name`,
    `last_name`, and `address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To decide what the primary key for the table should be, you need to identify
    which column(s) uniquely identifies the rows in the table. For this table, the
    primary key should be `customer_id`, because every `customer_id` corresponds to
    only one row in the table.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how many rows might be added to the table in the future, there will
    never be two rows with the same `customer_id`. This can’t be said of any other
    columns. Multiple people can have the same first name, last name, or address.
  prefs: []
  type: TYPE_NORMAL
- en: A primary key can be composed of more than one column, but even the combination
    of the `first_name`, `last_name`, and `address` columns isn’t guaranteed to uniquely
    identify the rows. For example, Bob Smith at 12 Dreary Lane might live with his
    son of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To designate the `customer_id` column as the primary key, use the `primary
    key` syntax when you create the `customer` table, as shown in [Listing 2-1](#listing2-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: Creating a primary key'
  prefs: []
  type: TYPE_NORMAL
- en: Here you define `customer_id` as a column that accepts integer values and as
    the primary key for the table.
  prefs: []
  type: TYPE_NORMAL
- en: Making `customer_id` the primary key benefits you in three ways. First, it prevents
    duplicate customer IDs from being inserted into the table. If someone using your
    database tries to add `customer_id` `3` when that ID already exists, MySQL will
    give an error message and not insert the row.
  prefs: []
  type: TYPE_NORMAL
- en: Second, making `customer_id` the primary key prevents users from adding a null
    value (that is, a missing or unknown value) for the `customer_id` column. When
    you define a column as the primary key, it’s designated as a special column whose
    values cannot be null. (You’ll learn more about null values later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Those two benefits fall under the category of data integrity. Once you define
    this primary key, you can be assured that all rows in the table will have a unique
    `customer_id`, and that no `customer_id` will be null. MySQL will enforce this
    constraint, which will help keep the data in your database of a high quality.
  prefs: []
  type: TYPE_NORMAL
- en: The third advantage to creating a primary key is that it causes MySQL to create
    an index. An index will help speed up the performance of SQL queries that select
    from the table. We’ll look at indexes more in the “Indexes” section later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If a table has no obvious primary key, it often makes sense to add a new column
    that can serve as the primary key (like the `customer_id` column shown here).
    For performance reasons, it’s best to keep the primary key values as short as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at a primary key that consists of more than one column, which
    is known as a *composite key*. The `high_temperature` table shown in [Listing
    2-2](#listing2-2) stores cities and their highest temperature by year.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Creating multiple primary key columns'
  prefs: []
  type: TYPE_NORMAL
- en: For this table, the primary key should consist of both the `city` and `year`
    columns, because there should be only one row in the table with the same city
    and year. For example, there’s currently a row for Death Valley for the year 2021
    with a high temperature of 128, so when you define `city` and `year` as the primary
    key for this table, MySQL will prevent users from adding a second row for Death
    Valley for the year 2021.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make `city` and `year` the primary key for this table, use MySQL’s `primary
    key` syntax with both column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `city` column is defined to hold up to 50 characters, and the `year` and
    `high_temperature` columns are defined to hold an integer. The primary key is
    then defined to be both the `city` and `year` columns.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL doesn’t require you to define a primary key for the tables you create,
    but you should for the data integrity and performance benefits cited earlier.
    If you can’t figure out what the primary key should be for a new table, that probably
    means you need to rethink your table design.
  prefs: []
  type: TYPE_NORMAL
- en: Every table can have at most one primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A foreign key is a column (or columns) in a table that matches the table to
    the primary key column(s) of another table. Defining a foreign key establishes
    a relationship between two tables so that you will be able to retrieve one result
    set containing data from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw in [Listing 2-1](#listing2-1) that you can create the primary key in
    the `customer` table using the `primary key` syntax. You’ll use similar syntax
    to create the foreign key in this `complaint` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, first you create the `complaint` table, define its columns
    and their data types, and specify `complaint_id` as the primary key. Then, the
    `foreign key` syntax allows you to define the `customer_id` column as a foreign
    key. With the `references` syntax, you specify that the `customer_id` column of
    the `complaint` table references the `customer_id` column of the `customer` table
    (you’ll learn what this means in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `customer` table again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the data for the `complaint` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The foreign key allows you to see which customer `customer_id 3` in the `complaint`
    table is referring to in the `customer` table; in this case, `customer_id 3` references
    Karen Bellyacher. This arrangement, illustrated in [Figure 2-2](#figure2-2), allows
    you to track which customers made which complaints.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Primary keys and foreign keys'
  prefs: []
  type: TYPE_NORMAL
- en: In the `customer` table, the `customer_id` column has been defined as the primary
    key (labeled PK). In the `complaint` table, the `customer_id` column has been
    defined as a foreign key (FK) because it will be used to join the `complaint`
    table to the `customer` table.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s where things get interesting. Because you defined the foreign key, MySQL
    won’t allow you to add a new row in the `complaint` table unless it is for a valid
    customer—that is, unless there is a `customer_id` row in the `customer` table
    that correlates with a `customer_id` in the `complaint` table. If you try to add
    a row in the `complaint` table for `customer_id` `4`, for example, MySQL will
    give an error. It doesn’t make sense to have a row in the `complaint` table for
    a customer that doesn’t exist, so MySQL prevents the row from being added in order
    to maintain data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Also, now that you’ve defined the foreign key, MySQL will not allow you to delete
    `customer_id 3` from the `customer` table. Deleting this ID would leave a row
    in the `complaint` table for `customer_id 3`, which would no longer correspond
    to any row in the `customer` table. Restricting data deletion is part of referential
    integrity.
  prefs: []
  type: TYPE_NORMAL
- en: There can be only one primary key per table, but a table can have more than
    one foreign key (see [Figure 2-3](#figure2-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A table can have only one primary key, but it can have multiple
    foreign keys.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-3](#figure2-3) shows an example of a table named `dog` that has three
    foreign keys, each pointing to the primary key of a different table. In the `dog`
    table, `owner_id` is a foreign key used to refer to the `owner` table, `breed_id`
    is a foreign key used to refer to the `breed` table, and `veterinarian_id` is
    a foreign key used to refer to the `veterinarian` table.'
  prefs: []
  type: TYPE_NORMAL
- en: As with primary keys, when you create a foreign key, MySQL will automatically
    create an index that will speed up the access to the table. More on that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: not null
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A null value represents an empty or undefined value. It is not the same as zero,
    an empty character string, or a space character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing null values in a column can be appropriate in some cases, but other
    times, permitting the absence of crucial information could result in the database
    missing data that is needed. Take a look at this table named `contact` that contains
    contact information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `phone` column for `contact_id 3` is `null` because Bill Bashful
    doesn’t own a phone. It is reasonable that the `contact` table would allow null
    values for the `phone` column, as a phone number might not be available or applicable
    for a contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `name` column should not allow null values. It would
    be better not to allow the following row to be added to the `contact` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There isn’t much point in saving information about a contact unless you know
    their name, so you can add a `not null` constraint to the `name` column to prevent
    this situation from occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `contact` table like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using the `not null` syntax when you define the `name` column prevents a value
    of `null` from being stored there and maintains data integrity. If you try to
    add a row with a null name, MySQL will display an error message and the row will
    be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: For columns defined as the table’s primary key, such as the `contact_id` column
    in this example, specifying `not null` isn’t necessary. MySQL prevents null values
    for primary key columns automatically.
  prefs: []
  type: TYPE_NORMAL
- en: unique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want to prevent duplicate values in a column, you can add a `unique`
    constraint to the column definition. Let’s return to the `contact` table from
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, you prevent duplicate email addresses from being entered by using the
    `unique` syntax on the `email_address` column. Now MySQL will no longer allow
    two contacts in the table to have the same email address.
  prefs: []
  type: TYPE_NORMAL
- en: check
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a `check` constraint to make sure that a column contains certain
    values or a certain range of values. For example, let’s revisit the `high_temperature`
    table from [Listing 2-2](#listing2-2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you add a `check` constraint to the `year` column to make sure
    that any year entered into the table is between 1880 and 2200\. Accurate temperature
    tracking wasn’t available until 1880, and your database probably won’t be in use
    after the year 2200\. Trying to add a year that is outside of that range would
    most likely be an error, so the constraint will prevent that from occurring.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve also added a `check` constraint to the `high_temperature` column to limit
    temperature values to less than 200 degrees, because a temperature higher than
    that would most likely be a data error.
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, you can add a `default` constraint to a column so that if a value
    isn’t supplied, a default value will be used. Take a look at the following `job`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you add a `default` constraint to the `shift` column, which
    stores data on work schedules. The default shift is `9-5`, meaning that if a row
    doesn’t include any data for the shift column, `9-5` will be written to the column.
    If a value for `shift` is provided, the default won’t be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen how different constraints can help you improve and maintain the
    integrity of the data in your tables. Let’s turn now to another MySQL feature
    that also offers performance benefits to your tables: indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL lets you create indexes on your tables to speed up the process of retrieving
    data; in some cases, such as in tables with defined primary or foreign keys, MySQL
    will create indexes automatically. Just as an index in the back of a book can
    help you find information without needing to scan each page, indexes help MySQL
    find data in your tables without having to read every row.
  prefs: []
  type: TYPE_NORMAL
- en: Say you create a `product` table like so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to make the process of retrieving information about suppliers
    more efficient. Here’s the syntax to create an index that will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you create an index, called `product_supplier_index`, on the
    `supplier_id` column of the `product` table. Now, when users retrieve data from
    the `product` table using the `supplier_id` column, the index should make that
    retrieval quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Once you create an index, you won’t need to reference it by name—MySQL will
    use it behind the scenes. The new index won’t change anything about the way you
    use the table; it will just speed up access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Although adding indexes can significantly improve performance, it wouldn’t make
    sense to index every column. Maintaining indexes has a performance cost, and creating
    indexes that don’t get used can actually decrease performance.
  prefs: []
  type: TYPE_NORMAL
- en: When you create tables, MySQL automatically creates most of the indexes that
    you’ll need. You don’t need to create indexes for columns that have been defined
    as primary keys, as foreign keys, or with `unique` constraints, because MySQL
    automatically indexes those columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how we would create the `dog` table from [Figure 2-3](#figure2-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary key for the table is `dog_id`, and the foreign keys are `owner_id`,
    `breed_id`, and `veterinarian_id`. Note that you haven’t created any indexes with
    the `create index` command. MySQL has automatically created indexes, however,
    from the columns labeled as the primary key and the foreign keys. You can confirm
    this using the `show indexes` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The results are shown in [Figure 2-4](#figure2-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: Indexes automatically created by MySQL for the `dog` table'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the `Column_name` column that MySQL automatically created all
    of the indexes that you need for this table.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping and Altering Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To *drop* a table, which removes the table and all of its data, use the `drop
    table` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here you tell MySQL to drop the `product` table you created in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: To make changes to a table, use the `alter table` command. You can add columns,
    drop columns, change a column’s data type, rename columns, rename the table, add
    or remove constraints, and make other changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try altering the `customer` table from [Listing 2-1](#listing2-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you alter the `customer` table in four ways: you add a column named `zip`
    that stores zip codes, remove the `address` column, rename the `zip` column to
    `zip_code` to make it more descriptive, and change the table name from `customer`
    to `valued_customer`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you saw how to use MySQL Workbench to run commands and view
    databases. You created your own database tables and learned how to optimize them
    using indexes and adding constraints.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the beginning of Part II of the book, you’ll learn about
    retrieving data from MySQL tables using SQL, displaying your data in an ordered
    way, formatting SQL statements, and using comments in SQL.
  prefs: []
  type: TYPE_NORMAL
