["```\n   #ifndef LOADER_H\n   #define LOADER_H\n\n   #include <stdint.h>\n   #include <string>\n   #include <vector>\n\n   class Binary;\n   class Section;\n   class Symbol;\n\n➊ class Symbol {\n   public:\n     enum SymbolType {\n       SYM_TYPE_UKN = 0,\n       SYM_TYPE_FUNC = 1\n     };\n\n     Symbol() : type(SYM_TYPE_UKN), name(), addr(0) {}\n\n     SymbolType type;\n     std::string name;\n     uint64_t    addr;\n   };\n\n➋ class Section {\n   public:\n     enum SectionType {\n       SEC_TYPE_NONE = 0,\n       SEC_TYPE_CODE = 1,\n       SEC_TYPE_DATA = 2\n     };\n\n     Section() : binary(NULL), type(SEC_TYPE_NONE),\n                 vma(0), size(0), bytes(NULL) {}\n\n     bool contains(uint64_t addr) { return (addr >= vma) && (addr-vma < size); }\n\n     Binary         *binary;\n     std::string     name;\n     SectionType     type;\n     uint64_t        vma;\n     uint64_t        size;\n     uint8_t         *bytes;\n   };\n\n➌ class Binary {\n   public:\n     enum BinaryType {\n       BIN_TYPE_AUTO = 0,\n       BIN_TYPE_ELF  = 1,\n       BIN_TYPE_PE   = 2\n     };\n     enum BinaryArch {\n       ARCH_NONE = 0,\n       ARCH_X86 = 1\n     };\n\n     Binary() : type(BIN_TYPE_AUTO), arch(ARCH_NONE), bits(0), entry(0) {}\n\n     Section *get_text_section()\n       { for(auto &s : sections) if(s.name == \".text\") return &s; return NULL; }\n\n     std::string            filename;\n     BinaryType             type;\n     std::string            type_str;\n     BinaryArch             arch;\n     std::string            arch_str;\n     unsigned               bits;\n     uint64_t               entry;\n     std::vector<Section>   sections;\n     std::vector<Symbol>    symbols;\n   };\n\n➍ int load_binary(std::string &fname, Binary *bin, Binary::BinaryType type);\n➎ void unload_binary(Binary *bin);\n\n #endif /* LOADER_H */\n```", "```\n#include <bfd.h>\n#include \"loader.h\"\n```", "```\n  int\n➊ load_binary(std::string &fname, Binary *bin, Binary::BinaryType type)\n  {\n    return ➋load_binary_bfd(fname, bin, type);\n  }\n\n  void\n➌ unload_binary(Binary *bin)\n  {\n    size_t i;\n    Section *sec;\n\n➍ for(i = 0; i < bin->sections.size(); i++) {\n     sec = &bin->sections[i];\n     if(sec->bytes) {\n➎      free(sec->bytes);\n     }\n    }\n   }\n```", "```\n   static bfd*\n   open_bfd(std::string &fname)\n   {\n     static int bfd_inited = 0;\n     bfd *bfd_h;\n\n     if(!bfd_inited) {\n➊      bfd_init();\n        bfd_inited = 1;\n     }\n\n➋   bfd_h = bfd_openr(fname.c_str(), NULL);\n     if(!bfd_h) {\n       fprintf(stderr, \"failed to open binary '%s' (%s)\\n\",\n               fname.c_str(), ➌bfd_errmsg(bfd_get_error()));\n       return NULL;\n     }\n➍   if(!bfd_check_format(bfd_h, bfd_object)) {\n       fprintf(stderr, \"file '%s' does not look like an executable (%s)\\n\",\n               fname.c_str(), bfd_errmsg(bfd_get_error()));\n       return NULL;\n     }\n\n     /* Some versions of bfd_check_format pessimistically set a wrong_format\n     * error before detecting the format and then neglect to unset it once\n     * the format has been detected. We unset it manually to prevent problems.\n     */\n➎  bfd_set_error(bfd_error_no_error);\n\n➏  if(bfd_get_flavour(bfd_h) == bfd_target_unknown_flavour) {\n      fprintf(stderr, \"unrecognized format for binary '%s' (%s)\\n\",\n             fname.c_str(), bfd_errmsg(bfd_get_error()));\n      return NULL;\n    }\n\n    return bfd_h;\n  }\n```", "```\n   static int\n   load_binary_bfd(std::string &fname, Binary *bin, Binary::BinaryType type)\n   {\n     int ret;\n     bfd *bfd_h;\n     const bfd_arch_info_type *bfd_info;\n\n     bfd_h = NULL;\n➊   bfd_h = open_bfd(fname);\n     if(!bfd_h) {\n       goto fail;\n     }\n\n     bin->filename = std::string(fname);\n➋   bin->entry    = bfd_get_start_address(bfd_h);\n\n➌   bin->type_str = std::string(bfd_h->xvec->name);\n➍   switch(bfd_h->xvec->flavour) {\n     case bfd_target_elf_flavour:\n       bin->type = Binary::BIN_TYPE_ELF;\n       break;\n    case bfd_target_coff_flavour:\n      bin->type = Binary::BIN_TYPE_PE;\n      break;\n    case bfd_target_unknown_flavour:\n    default:\n      fprintf(stderr, \"unsupported binary type (%s)\\n\", bfd_h->xvec->name);\n      goto fail;\n    }\n\n➎     bfd_info = bfd_get_arch_info(bfd_h);\n➏     bin->arch_str = std::string(bfd_info->printable_name);\n➐     switch(bfd_info->mach) {\n      case bfd_mach_i386_i386:\n        bin->arch = Binary::ARCH_X86;\n        bin->bits = 32;\n        break;\n      case bfd_mach_x86_64:\n        bin->arch = Binary::ARCH_X86;\n        bin->bits = 64;\n        break;\n      default:\n        fprintf(stderr, \"unsupported architecture (%s)\\n\",\n                bfd_info->printable_name);\n        goto fail;\n      }\n\n      /* Symbol handling is best-effort only (they may not even be present) */\n➑    load_symbols_bfd(bfd_h, bin);\n➒    load_dynsym_bfd(bfd_h, bin);\n\n      if(load_sections_bfd(bfd_h, bin) < 0) goto fail;\n\n      ret = 0;\n      goto cleanup;\n\n    fail:\n      ret = -1;\n\n    cleanup:\n➓    if(bfd_h) bfd_close(bfd_h);\n\n      return ret;\n   }\n```", "```\n   static int\n   load_symbols_bfd(bfd *bfd_h, Binary *bin)\n   {\n     int ret;\n     long n, nsyms, i;\n➊   asymbol **bfd_symtab;\n     Symbol *sym;\n\n     bfd_symtab = NULL;\n\n➋    n = bfd_get_symtab_upper_bound(bfd_h);\n     if(n < 0) {\n       fprintf(stderr, \"failed to read symtab (%s)\\n\",\n               bfd_errmsg(bfd_get_error()));\n       goto fail;\n     } else if(n) {\n➌      bfd_symtab = (asymbol**)malloc(n);\n       if(!bfd_symtab) {\n         fprintf(stderr, \"out of memory\\n\");\n        goto fail;\n       }\n➍     nsyms = bfd_canonicalize_symtab(bfd_h, bfd_symtab);\n       if(nsyms < 0) {\n         fprintf(stderr, \"failed to read symtab (%s)\\n\",\n                bfd_errmsg(bfd_get_error()));\n         goto fail;\n       }\n➎     for(i = 0; i < nsyms; i++) {\n➏       if(bfd_symtab[i]->flags & BSF_FUNCTION) {\n           bin->symbols.push_back(Symbol());\n           sym = &bin->symbols.back();\n➐         sym->type = Symbol::SYM_TYPE_FUNC;\n➑         sym->name = std::string(bfd_symtab[i]->name);\n➒         sym->addr = bfd_asymbol_value(bfd_symtab[i]);\n         }\n       }\n     }\n     ret = 0;\n     goto cleanup;\n\n   fail:\n     ret = -1;\n\n   cleanup:\n➓   if(bfd_symtab) free(bfd_symtab);\n\n     return ret;\n\n  }\n```", "```\n   static int\n   load_dynsym_bfd(bfd *bfd_h, Binary *bin)\n   {\n     int ret;\n     long n, nsyms, i;\n➊   asymbol **bfd_dynsym;\n     Symbol *sym;\n\n     bfd_dynsym = NULL;\n\n➋   n = bfd_get_dynamic_symtab_upper_bound(bfd_h);\n     if(n < 0) {\n       fprintf(stderr, \"failed to read dynamic symtab (%s)\\n\",\n               bfd_errmsg(bfd_get_error()));\n       goto fail;\n     } else if(n) {\n       bfd_dynsym = (asymbol**)malloc(n);\n       if(!bfd_dynsym) {\n         fprintf(stderr, \"out of memory\\n\");\n         goto fail;\n      }\n➌    nsyms = bfd_canonicalize_dynamic_symtab(bfd_h, bfd_dynsym);\n      if(nsyms < 0) {\n        fprintf(stderr, \"failed to read dynamic symtab (%s)\\n\",\n                bfd_errmsg(bfd_get_error()));\n       goto fail;\n     }\n     for(i = 0; i < nsyms; i++) {\n       if(bfd_dynsym[i]->flags & BSF_FUNCTION) {\n         bin->symbols.push_back(Symbol());\n         sym = &bin->symbols.back();\n         sym->type = Symbol::SYM_TYPE_FUNC;\n         sym->name = std::string(bfd_dynsym[i]->name);\n         sym->addr = bfd_asymbol_value(bfd_dynsym[i]);\n       }\n      }\n     }\n\n     ret = 0;\n     goto cleanup;\n\n   fail:\n     ret = -1;\n\n   cleanup:\n     if(bfd_dynsym) free(bfd_dynsym);\n\n     return ret;\n   }\n```", "```\n  static int\n  load_sections_bfd(bfd *bfd_h, Binary *bin)\n  {\n    int bfd_flags;\n    uint64_t vma, size;\n    const char *secname;\n➊  asection* bfd_sec;\n    Section *sec;\n    Section::SectionType sectype;\n\n➋  for(bfd_sec = bfd_h->sections; bfd_sec; bfd_sec = bfd_sec->next) {\n➌    bfd_flags = bfd_get_section_flags(bfd_h, bfd_sec);\n\n      sectype = Section::SEC_TYPE_NONE;\n➍    if(bfd_flags & SEC_CODE) {\n        sectype = Section::SEC_TYPE_CODE;\n      } else if(bfd_flags & SEC_DATA) {\n        sectype = Section::SEC_TYPE_DATA;\n      } else {\n        continue;\n      }\n➎    vma     = bfd_section_vma(bfd_h, bfd_sec);\n➏    size    = bfd_section_size(bfd_h, bfd_sec);\n➐    secname = bfd_section_name(bfd_h, bfd_sec);\n     if(!secname) secname = \"<unnamed>\";\n\n➑    bin->sections.push_back(Section());\n      sec = &bin->sections.back();\n\n      sec->binary = bin;\n      sec->name   = std::string(secname);\n      sec->type   = sectype;\n      sec->vma    = vma;\n      sec->size   = size;\n➒    sec->bytes  = (uint8_t*)malloc(size);\n      if(!sec->bytes) {\n        fprintf(stderr, \"out of memory\\n\");\n        return -1;\n     }\n\n➓   if(!bfd_get_section_contents(bfd_h, bfd_sec, sec->bytes, 0, size)) {\n       fprintf(stderr, \"failed to read section '%s' (%s)\\n\",\n              secname, bfd_errmsg(bfd_get_error()));\n       return -1;\n     }\n   }\n\n   return 0;\n }\n```", "```\n     #include <stdio.h>\n     #include <stdint.h>\n     #include <string>\n     #include \"../inc/loader.h\"\n\n     int\n     main(int argc, char *argv[])\n     {\n       size_t i;\n       Binary bin;\n       Section *sec;\n       Symbol *sym;\n       std::string fname;\n\n       if(argc < 2) {\n         printf(\"Usage: %s <binary>\\n\", argv[0]);\n         return 1;\n     }\n\n     fname.assign(argv[1]);\n➊   if(load_binary(fname, &bin, Binary::BIN_TYPE_AUTO) < 0) {\n       return 1;\n     }\n\n➋   printf(\"loaded binary '%s' %s/%s (%u bits) entry@0x%016jx\\n\",\n           bin.filename.c_str(),\n           bin.type_str.c_str(), bin.arch_str.c_str(),\n           bin.bits, bin.entry);\n\n➌   for(i = 0; i < bin.sections.size(); i++) {\n       sec = &bin.sections[i];\n       printf(\" 0x%016jx %-8ju %-20s %s\\n\",\n              sec->vma, sec->size, sec->name.c_str(),\n              sec->type == Section::SEC_TYPE_CODE ? \"CODE\" : \"DATA\");\n     }\n\n➍   if(bin.symbols.size() > 0) {\n       printf(\"scanned symbol tables\\n\");\n       for(i = 0; i < bin.symbols.size(); i++) {\n         sym = &bin.symbols[i];\n         printf(\" %-40s 0x%016jx %s\\n\",\n                sym->name.c_str(), sym->addr,\n                (sym->type & Symbol::SYM_TYPE_FUNC) ? \"FUNC\" : \"\");\n       }\n     }\n\n➎   unload_binary(&bin);\n\n     return 0;\n    }\n```", "```\n$ loader_demo /bin/ls\n\nloaded binary '/bin/ls' elf64-x86-64/i386:x86-64 (64 bits) entry@0x4049a0\n  0x0000000000400238 28     .interp                DATA\n  0x0000000000400254 32     .note.ABI-tag          DATA\n  0x0000000000400274 36     .note.gnu.build-id     DATA\n  0x0000000000400298 192    .gnu.hash              DATA\n  0x0000000000400358 3288   .dynsym                DATA\n  0x0000000000401030 1500   .dynstr                DATA\n  0x000000000040160c 274    .gnu.version           DATA\n  0x0000000000401720 112    .gnu.version_r         DATA\n  0x0000000000401790 168    .rela.dyn              DATA\n  0x0000000000401838 2688   .rela.plt              DATA\n  0x00000000004022b8 26     .init                  CODE\n  0x00000000004022e0 1808   .plt                   CODE\n  0x00000000004029f0 8      .plt.got               CODE\n  0x0000000000402a00 70281  .text                  CODE\n  0x0000000000413c8c 9      .fini                  CODE\n  0x0000000000413ca0 27060  .rodata                DATA\n  0x000000000041a654 2060   .eh_frame_hdr          DATA\n  0x000000000041ae60 11396  .eh_frame              DATA\n  0x000000000061de00 8      .init_array            DATA\n  0x000000000061de08 8      .fini_array            DATA\n  0x000000000061de10 8      .jcr                   DATA\n  0x000000000061de18 480    .dynamic               DATA\n  0x000000000061dff8 8      .got                   DATA\n  0x000000000061e000 920    .got.plt               DATA\n  0x000000000061e3a0 608    .data                  DATA\nscanned symbol tables\n...\n  _fini                     0x0000000000413c8c     FUNC\n  _init                     0x00000000004022b8     FUNC\n  free                      0x0000000000402340     FUNC\n  _obstack_memory_used      0x0000000000412960     FUNC\n  _obstack_begin            0x0000000000412780     FUNC\n  _obstack_free             0x00000000004128f0     FUNC\n  localtime_r               0x00000000004023a0     FUNC\n  _obstack_allocated_p      0x00000000004128c0     FUNC\n  _obstack_begin_1          0x00000000004127a0     FUNC\n  _obstack_newchunk         0x00000000004127c0     FUNC\n  malloc                    0x0000000000402790     FUNC\n```"]