- en: 9 Drag Race Timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Project 4](ch04.xhtml#ch04), you built a reaction timer to measure how fast
    you can hit a button. In this project, you’ll build on the techniques you learned
    there to make a race timer for a Hot Wheels-inspired race track (see [Figure 9-1](ch09.xhtml#ch09fig01)).
    We’ll show you how to display the finish time on a small, portable LCD screen
    so that you can detach your project from your computer. We’ll also show you how
    to hack this project to add a second track and indicator lamps (LEDs) to show
    which car has won. Are you ready?
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-1:** The completed Drag Race Timer'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**MATERIALS TO GATHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the parts used in this project will be familiar to you already (see
    [Figures 9-2](ch09.xhtml#ch09fig02) and [9-3](ch09.xhtml#ch09fig03)). We’ll introduce
    only one new part: the 16 × 2 character LCD that you’ll use to display your race
    time directly, rather than displaying it in the Serial Monitor on your computer
    screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In “[Going Further](ch09.xhtml#ch09lev1sec9)” on page [273](ch09.xhtml#page_273),
    we’ll show you how to modify your Drag Race Timer so you can race two cars and
    display the winning time. The standard SparkFun Inventor’s Kit includes one photoresistor
    (SEN-09088), but you’ll need two for this final hack. Thankfully, the photoresistor
    is a pretty inexpensive part, so you could either buy another one or partner with
    a friend who has an Inventor’s Kit to build the two-player version.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Parts**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: • One SparkFun RedBoard (DEV-13975), Arduino Uno (DEV-11021), or any other Arduino-compatible
    board
  prefs: []
  type: TYPE_NORMAL
- en: • One USB Mini-B cable (CAB-11301 or your board’s USB cable)
  prefs: []
  type: TYPE_NORMAL
- en: • One solderless breadboard (PRT-12002)
  prefs: []
  type: TYPE_NORMAL
- en: • One 10 kΩ resistor, or two if you want to build the two-player version (COM-08374,
    or COM-11508 for a pack of 20)
  prefs: []
  type: TYPE_NORMAL
- en: • One photoresistor (SEN-09088), or two* if you want to build the two-player
    version
  prefs: []
  type: TYPE_NORMAL
- en: • One push button (COM-10302)
  prefs: []
  type: TYPE_NORMAL
- en: • One 10 kΩ potentiometer (COM-09806)
  prefs: []
  type: TYPE_NORMAL
- en: • One 16 × 2 character LCD (LCD-00255)
  prefs: []
  type: TYPE_NORMAL
- en: • One submicro size servo motor (ROB-09065)
  prefs: []
  type: TYPE_NORMAL
- en: • Male-to-male jumper wires (PRT-11026)
  prefs: []
  type: TYPE_NORMAL
- en: • Male-to-female jumper wires (PRT-09140*)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The parts marked with an asterisk (*) do not come with the standard SparkFun
    Inventor’s Kit but are available in the separate add-on kit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-2:** Components for the Drag Race Timer'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Other Materials and Tools**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: • Craft knife
  prefs: []
  type: TYPE_NORMAL
- en: • Metal ruler
  prefs: []
  type: TYPE_NORMAL
- en: • Needle-nose pliers
  prefs: []
  type: TYPE_NORMAL
- en: • Wire cutters
  prefs: []
  type: TYPE_NORMAL
- en: • Masking tape
  prefs: []
  type: TYPE_NORMAL
- en: • Glue (hot glue gun or craft glue)
  prefs: []
  type: TYPE_NORMAL
- en: • Cardboard (about 8.5 × 11 inches), a small cardboard box, or thick cardstock
  prefs: []
  type: TYPE_NORMAL
- en: • Bamboo skewer
  prefs: []
  type: TYPE_NORMAL
- en: • Enclosure template (see [Figure 9-15](ch09.xhtml#ch09fig15) on page [266](ch09.xhtml#page_266))
  prefs: []
  type: TYPE_NORMAL
- en: • Hot Wheels or other small toy cars to race (not shown)
  prefs: []
  type: TYPE_NORMAL
- en: • (Optional) Toy car race track (not shown)
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-3:** Recommended tools and materials'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous projects, we’ve used the Serial Monitor to display information sent
    from the Arduino on your computer. In this project, we’ll show you how to add
    an LCD directly to your project, a skill well worth learning. The LCD requires
    a lot of wires, but don’t worry— we’ll take it one step at a time. After you’ve
    mastered the use of this part, you can go back and add it to some of your past
    projects to make them fully portable!
  prefs: []
  type: TYPE_NORMAL
- en: '**NEW COMPONENT: THE 16 × 2 CHARACTER LCD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*LCD* is short for *liquid crystal display*. Invented over 40 years ago, liquid
    crystal technology is used in digital watches, alarm clocks, projectors, televisions,
    computer monitors, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: The LCD you’ll use in this project is a simple *monochromatic* display, meaning
    it displays only one color. Beneath the screen of the display is a layer of liquid
    crystal. This is a unique chemical that, when a small electric current is applied
    to it, changes from transparent to opaque. Combined with a backlight or a reflective
    mirror, liquid crystal is used to build very simple displays. Light comes through
    or is blocked depending on which areas of the liquid crystal electricity is applied
    to—which means you can make shapes if you can control the current.
  prefs: []
  type: TYPE_NORMAL
- en: The 16 × 2 character LCD displays up to 32 characters of information, each of
    which is broken down into a 5 × 8 pixel matrix. Each individual pixel can be made
    either opaque or transparent depending on the applied electric current, controlled
    by the Arduino. The letter *A*, for example, will display on the LCD screen when
    the yellow pixels in [Figure 9-4](ch09.xhtml#ch09fig04) are made opaque.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-4:** The uppercase letter *A* represented on a 5 × 8 pixel matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are 40 individual pixels in a single character, each controlled by the
    Arduino, meaning there are 1,280 different control lines! Thankfully, the LCD
    used in this project has a special parallel interface LCD driver IC by Hitachi
    called the HD44780\. This chip allows you to display almost any character on the
    screen using just six control lines from the Arduino. [Figure 9-5](ch09.xhtml#ch09fig05)
    shows the pins on an LCD.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-5:** A simple 16 × 2 character LCD'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The LCD can use up to eight pins for data (d0–d7), but the way we are going
    to use the LCD, it only uses four. These are labeled d4–d7.*'
  prefs: []
  type: TYPE_NORMAL
- en: The LCD has a total of 16 pins, but this project uses only pins 1–6 and 11–16\.
    The pins are numbered 1 through 16 from left to right (with the pins at the top
    of the screen). [Table 9-1](ch09.xhtml#ch09tab01) describes each of the pins on
    the LCD. In some datasheets you might see a line over a label, as with the ![Image](../images/251fig01.jpg)
    label on pin 5\. This line indicates that the feature is an *active low*, which
    means the pin is activated at low voltage. So, in this case, when you want to
    write to the LCD, pin 5 needs to be set to `LOW`. We’ll discuss this more in “[Connect
    the Data and Control Wiring](ch09.xhtml#ch09lev2sec5)” on page [255](ch09.xhtml#page_255).
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 9-1:** Pin descriptions for 16 × 2 character LCD'
  prefs: []
  type: TYPE_NORMAL
- en: '| **PIN** | **DESCRIPTION** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Ground (GND) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | VDD power for the LCD (5 V) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Contrast adjust (0–5 V) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Register select (RS) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | ![Image](../images/252fig01.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Enable |'
  prefs: []
  type: TYPE_TB
- en: '| 7–10 | Data lines d0–d3 (not used) |'
  prefs: []
  type: TYPE_TB
- en: '| 11–14 | Data lines d4–d7 (data transferred in 4 bits at a time) |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | Backlight power (5 V) |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | Backlight ground (GND) |'
  prefs: []
  type: TYPE_TB
- en: Rather than having to control each of the 40 pixels for each character separately,
    the HD44780 driver chip interprets data sent over by the Arduino using four data
    lines and two control lines and converts this into the character to display. To
    further simplify the interface, the Arduino community has written an LCD library
    for writing code to the LCD. We’ll look at that in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**DRAG RACE TIMER OPERATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start wiring the electronics, let’s discuss how the sketch will function.
    We designed this race timer so that when we push a button the servo moves up,
    opening the starting gate that allows the car to roll down the track. At the same
    time, the Arduino records the starting time and waits to see when the car reaches
    the photoresistor at the bottom of the track, which uses the same light-sensor
    circuit used in the Night-Light in [Project 5](ch05.xhtml#ch05). You’ll embed
    the light sensor in the center of the track so that when the car passes over it,
    it will create a shadow that the Arduino can detect. When the Arduino detects
    the shadow, it will record the stopping time and calculate the total time as the
    stopping time minus the starting time. If this seems similar to the Reaction Timer
    from [Project 4](ch04.xhtml#ch04), that’s because it is!
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILD THE LCD CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll start by building the LCD circuit. The LCD has 16 pins in total, but
    you’ll use just 12 of them. [Figure 9-6](ch09.xhtml#ch09fig06) shows the schematic
    for the LCD wiring.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-6:** Schematic diagram of LCD wiring'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With 16 pins, the LCD will take up 16 rows on the breadboard, so you’ll have
    to be careful about positioning with this project. You’ll mount the LCD in the
    first 16 rows on the right side of the breadboard. Be sure to connect the power
    and ground from the Arduino to the power and ground rails on the left side of
    the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the pins on the LCD are not labeled. As we walk you through wiring
    it up, we’ll refer to the pins on the LCD in order, starting with pin 1 at the
    bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '**Power the LCD**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The LCD has two separate power supplies for the backlight and for the control
    logic. You’ll need to wire these separately.
  prefs: []
  type: TYPE_NORMAL
- en: Connect pin 1 of the LCD to GND and pin 2 of the LCD to 5 V using the power
    rails on the breadboard. This provides power for the LCD’s control circuitry and
    the HD44780 LCD driver chip. Next, connect pin 15 on the LCD to 5 V and pin 16
    on the LCD to GND, again using the power rails. These two connections power the
    LCD’s built-in backlight (see [Figure 9-7](ch09.xhtml#ch09fig07)).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-7:** Connect the power for the LCD and the backlight.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Control the Contrast**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can adjust the contrast on the LCD screen. To do so, you control the voltage
    on pin 3 of the LCD using a simple voltage divider circuit with a potentiometer,
    similar to what you did for the Balance Beam in [Project 6](ch06.xhtml#ch06).
    Recall that a potentiometer is the same thing as a variable resistor: it has three
    pins, and as you turn the knob the resistance between the center pin and either
    of the end pins changes. If you connect the top and bottom pins of the potentiometer
    to 5 V and GND, you have a variable voltage divider where the voltage on the center
    pin will vary between 5 V and GND depending on how far you turn the knob (see
    [Figure 9-8](ch09.xhtml#ch09fig08)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-8:** Potentiometer schematic connected up as a variable voltage
    divider'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Add the potentiometer to the breadboard just below the LCD. Connect the outside
    pins of the potentiometer to 5 V and GND, and connect the center pin to pin 3
    on the LCD for the contrast control.
  prefs: []
  type: TYPE_NORMAL
- en: Now all you need to do is add the data and control wiring for the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: '**Connect the Data and Control Wiring**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You need seven more wires to connect to the LCD, including four data lines and
    three control lines. Pin 5 on the LCD is the read/write functionality that allows
    the Arduino to read from and write data to the display. You’re only going to use
    this read/write connection to send data to the LCD, or write to the device, so
    you can connect this to ground, known as “tying the pin low.” If you look back
    at [Table 9-1](ch09.xhtml#ch09tab01), you’ll notice that the ![Image](../images/251fig01.jpg)
    label has a line over *Write*. As we mentioned earlier, this notation is often
    used in datasheets and documentation to indicate that a low signal will activate
    this feature. A low input is equivalent to ground, so add a wire to connect pin
    5 of the LCD to GND, as shown in [Figure 9-9](ch09.xhtml#ch09fig09).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-9:** Connect pin 5 of the LCD to GND for the ![Image](../images/255fig01.jpg)
    control.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final six wires will connect the LCD to the Arduino. Pins 11–14 on the LCD
    are the four data lines the Arduino will use to send information to the LCD. Connect
    these to the Arduino pins 10, 11, 12, and 13, as shown in [Figure 9-10](ch09.xhtml#ch09fig10).
    The wires should go straight across from the Arduino board to the LCD without
    crossing.
  prefs: []
  type: TYPE_NORMAL
- en: The last two connections are Enable at pin 6 and Register Select at pin 4\.
    The Enable pin is used to signal the data transfer to the LCD, and the Register
    Select pin determines whether the data represents a character to display or an
    instruction, like clearing the screen or moving the cursor; this gives you greater
    control over what’s displayed on the screen. Connect pin 9 on the Arduino to pin
    6 on the LCD, and pin 8 on the Arduino to pin 4 on the LCD, as shown in [Figure
    9-10](ch09.xhtml#ch09fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-10:** Final wiring of the LCD circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Table 9-2](ch09.xhtml#ch09tab02) shows the LCD screen connections to help
    you make sure you have everything connected correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 9-2:** LCD pin connections'
  prefs: []
  type: TYPE_NORMAL
- en: '| **LCD PIN** | **CONNECTION** |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | Arduino pin 13 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Arduino pin 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Arduino pin 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Arduino pin 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Arduino pin 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Arduino pin 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Middle pin of potentiometer |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | GND |'
  prefs: []
  type: TYPE_TB
- en: '**Test the LCD**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you wire up more of the circuit, test it to make sure it’s working as
    expected so far. Connect your Arduino to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you apply power, the backlight should turn on. Try turning the potentiometer
    knob. Even with nothing displayed on the LCD, you should see the contrast of the
    screen change as you twist, from all dark at its lowest to 32 brightly lit rectangles
    at its highest.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see this, double-check the wiring. Make sure that all of the power
    connections to the LCD match [Table 9-2](ch09.xhtml#ch09tab02).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the LCD working, copy the code from [Listing 9-1](ch09.xhtml#ch09ex01)
    into Arduino and upload it to your device. This simple example should display
    the text *SparkFun Arduino* on the first line and a running counter on the second
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 9-1:** Test code to display text and a running `millis()` counter
    to the LCD'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at what’s going on in this example. First, it includes the
    *LiquidCrystal.h* library ➊ created by the Arduino community to simplify the six
    different control and data lines. This will make it easier for you to send instructions
    to the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, this code creates an object named `lcd` that uses the LiquidCrystal library
    ➋. Notice that this time when you create the object, you pass it a set of parameters
    that correspond with the LCD pins: the Register Select, Enable, and four data
    pins. This is where you configure which pin controls each function on the LCD.
    In some documentation, you may see this command as `LiquidCrystal lcd(RS, Enable,
    d4, d5, d6, d7)`.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we don’t use four of the LCD pins. This LCD is able
    to transfer data on either four or eight data lines. According to the datasheet
    on the LCD, when you use four data lines, you use the top four pins on the LCD—the
    pins labeled d4, d5, d6, and d7\. While it takes the Arduino twice as long to
    transfer data to the LCD this way, this helps to keep the circuit as simple as
    possible, and remember, the Arduino operates with a 16 MHz clock. That’s really
    fast!
  prefs: []
  type: TYPE_NORMAL
- en: The LiquidCrystal library has around 20 different commands that simplify control
    of this LCD. In this example, we’ll show you a few basic commands that allow you
    to configure the screen size, clear the screen, display information, and move
    the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: The `setup()` part of the sketch has a few instructions that will run just once
    when the Arduino starts up. The first of these is `lcd.begin(16, 2);` ➌, which
    sets up the size of the LCD as a 16 × 2 character LCD, allowing the library to
    correctly wrap text and move from one line to the next.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction, `lcd.clear();` ➍, allows you to clear the screen before
    providing new text to display. It also resets the position of the cursor to the
    first character on the first line of the screen. Without this, the LCD would retain
    the last thing displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the command `lcd.print("SparkFun Arduino");` ➎ displays the text *SparkFun
    Arduino* on the LCD. Because the `lcd.clear()` instruction just cleared the screen,
    this text will appear on the first line of the display. This string of text is
    exactly 16 characters long and should fill the entire first line of the LCD. This
    command is similar to `Serial.print()`, but with `lcd.print()` you don’t need
    to be connected to a computer or have the Serial Monitor open to see text and
    information from your device.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` refreshes the screen with new information each time it repeats.
    First it moves the cursor to the second line of the LCD using `lcd.setCursor(0,
    1);` ➏ so it doesn’t overwrite the *SparkFun Arduino* text on the first line.
    The two numbers used in the `setCursor()` method indicate the position of the
    character (0) and the row (1). As is common in a lot of programming environments,
    Arduino counts starting with an index of 0, not 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The LiquidCrystal library only works with character LCD displays. Graphic
    LCD screens are also available, but they use a different library called OpenGLCD,
    which allows you to display graphics such as lines, rectangles, and circles as
    well as text.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the sketch prints a counter ➐ using another `lcd.print()` instruction.
    This counter uses the `millis()` function, which reports the number of milliseconds
    since the Arduino was powered on. Dividing this value by 1,000 shows a counter
    in seconds. We will use a similar technique for the race timer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, can you figure out how to change the text to display your name on the first
    line? How about changing the time display to show the time elapsed in minutes
    instead of seconds? Play around with the code example until you’re comfortable
    with displaying data to the LCD. With just six GPIO pins from your Arduino, you
    can add an LCD readout to any project!
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates the most commonly used instructions in the Arduino
    LiquidCrystal library, but if you want to check out the other commands that you
    can use, see *[https://www.arduino.cc/en/Reference/LiquidCrystal/](https://www.arduino.cc/en/Reference/LiquidCrystal/).*
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the LCD circuit working, it’s time to add the button, servo,
    and light-sensor circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADD THE REST OF THE ELECTRONICS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Drag Race Timer will use a few parts that you’ve already put together in
    previous projects: a push button to start the race, a servo to control the starting
    gate for the car, and a photo resistor to detect when the car reaches the end
    of the track. [Figure 9-11](ch09.xhtml#ch09fig11) shows schematic diagrams of
    these three additional components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-11:** Schematic diagrams for additional components in the Drag Race
    Timer'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Place a push button on the breadboard so that two legs are on either side of
    the center divide, and connect two of the legs on one side to pin 5 on the Arduino
    and GND. The parts will fill up most of the breadboard, so pay close attention
    to the rows on the breadboard and how the components are connected. To save space,
    this project uses the push button without the external pull-up resistor used in
    [Project 4](ch04.xhtml#ch04) with the Reaction Timer. Instead, we’ll enable a
    pull-up resistor in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, connect the servo motor that will open the starting gate. Using three
    male-to-male jumper wires, connect the signal wire (either yellow or white) to
    pin 4 on the Arduino, the red wire to the 5 V rail, and the black wire to the
    GND rail.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add the light-sensor circuit with a voltage divider circuit. Connect
    one end of a photoresistor to the 5 V power rail and the other end to the GND
    power rail, via a 10 kΩ pull-down resistor placed directly in the power rail.
    Connect the row that has both the photoresistor and the 10 kΩ pull-up resistor
    to pin A0 on the Arduino. This circuit should look similar to the circuit you
    used in the Night-Light in [Project 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of components in this circuit, so take your time and double-check
    your wiring against the diagram in [Figure 9-12](ch09.xhtml#ch09fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-12:** Complete electronics for the Drag Race Timer, including a
    starting button and gate'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PROGRAM THE DRAG RACE TIMER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s put it all together. Start a new sketch, and enter the code from [Listing
    9-2](ch09.xhtml#ch09ex02) or download it from *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*.
    This example will bring together several concepts and ideas we’ve used separately
    in past projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 9-2:** Drag Race Timer sketch'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at how all this works. First, the sketch includes two libraries
    using the `#include` directive ➊, *LiquidCrystal.h* and *Servo.h*. Next, it initializes
    a `LiquidCrystal` object named `lcd`, similar to [Listing 9-1](ch09.xhtml#ch09ex01),
    and a `Servo` object named `startingGate` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the sketch declares a set of constants for the pin connections used for
    the button, servo, and photoresistor circuits ➌. This means that, as you make
    changes and modifications, if you need to move a wire to a different pin on the
    Arduino, you’ll only have to change a single number in the code. The last constant,
    a threshold value named `darkThreshold`, is used to set the light level to detect
    when the car is blocking the light sensor. Here it’s set to `500`, roughly in
    the middle of the range of 0–1023, but you may need to adjust this value to suit
    the environment of your own room.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sketch declares a few variables ➍. The `finishSensor1` variable is
    used to store the raw value of the photoresistor sensor. The next variable, `finishFlag`,
    is a *state variable*, which is used to keep track of what state the sketch is
    in. The `finishFlag` variable is initialized to `false` and is used to indicate
    when the race is over (like the flag waved at the finish line to mark the winner
    of a Formula One race). We’ll set it later in the code based on the input value
    from the sensor. The next three variables are used to calculate the race time
    using the built-in `millis()` timer in Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `setup()` part of the code sets up the button pin to use an internal
    pull-up resistor that’s built into the Arduino by declaring the pin mode as an
    `INPUT_PULLUP` ➎. This trick removes the need for the external pull-up resistor
    used in [Project 4](ch04.xhtml#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sketch initializes the servo motor and sets its default position to
    `0`. This will be the position of the starting gate when it’s down.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then displays a little information to the LCD ➏ to let the user know
    how to start the race. These few lines of code set up the LCD, clear the screen,
    and display two lines of text. Be careful that your text is limited to 16 characters
    per line; any more than 16, and your characters will run off the screen to the
    right. The code then waits for a button press using the blocking `while()` loop
    technique ➐ used in the Reaction Timer; this blocks the sketch from proceeding
    until the button is pressed. When the button is pressed, `digitalRead(buttonPin)`
    will read `LOW` and the code will move the servo to the up position and set the
    `startTime` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the `loop()`, the sketch reads the light sensor and stores its current reading
    to the variable `finishSensor1` ➑. The sensor will be embedded at the end of the
    ramp. The car will roll over it as it crosses the finish line, covering the sensor
    and blocking most of the light. Similar to the Night-Light sketch in [Project
    5](ch05.xhtml#ch05), the sketch will compare the value of the sensor to the `darkThreshold`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Your sensor needs to be in a decently lit area so that the contrast between
    the sensor being lit and being shaded is great enough to cause that drop in voltage.
    Be aware that overhead lights can create a false detection if your body casts
    a shadow over the sensor. If you want to make sure that the sensor works well,
    get a small desk lamp and set it over the sensor.*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in the time it takes the car to pass the sensor, the `loop()`
    may repeat several times. Because we only want to look for the first moment the
    car crosses the finish line, the sketch uses a compound `if()` statement ➒ to
    capture the moment when the `finishFlag` variable is `false` *and* the finish
    sensor is blocked (that is, its value is less than `darkThreshold`). The `&&`
    indicates a logical AND (see “[Compound Logic Operators](ch09.xhtml#ch09sb02)”
    on page [264](ch09.xhtml#page_264)). Pay careful attention to the number of parentheses
    used in the `if()` statement—they indicate order of operation and how the logic
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Now, inside the `if()` statement, the `finishFlag` state variable switches to
    `true`. Because the `finishFlag` state variable is now set to `true`, the compound
    `if()` statement will only catch the first moment the car crosses the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then records the stopping time and calculates the elapsed race time.
    Finally, the sketch prints the race time to the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: The `raceTime` variable is declared as a `float` (floating-point variable) so
    it can store numbers with decimals. By default, the `lcd.print()` method will
    display two decimal places of precision for a floating-point value, but you can
    add a second parameter to the `lcd.print()` method to specify more or less. At
    ➓, the sketch calculates the number of seconds elapsed by dividing the millisecond
    count by 1,000\. The extra `3` in the instruction `lcd.print(raceTime / 1000,
    3);` tells Arduino to display three values past the decimal point, so the time
    will be accurate to the millisecond. Don’t forget the last two curly brackets
    in the code. Double-check to make sure that your code matches [Listing 9-2](ch09.xhtml#ch09ex02),
    and upload the sketch to your device.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND LOGIC OPERATORS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 4, we introduced simple logical comparison operators to compare
    two values. Recall that logic comparisons or expressions can only be either true
    or false. In programming, there are times when you need to compare multiple conditions
    together; for example, when you need to run some code only when a variable is
    false AND a sensor value is less than the threshold: `((finishFlag == false) &&
    (finishSensor1 < darkThreshold))`. Here, notice that the logic comparisons are
    grouped together in parentheses on either side of the compound AND (`&&`).'
  prefs: []
  type: TYPE_NORMAL
- en: A combination of two or more logic comparisons is known as a *compound logic
    expression*. Expressions are *evaluated* (or read) from left to right. To keep
    everything together and observe the correct order of operations, it’s a good idea
    to use parentheses to separate out the individual expressions. The two main operators
    used to combine logic expressions are AND and OR, which are described in the following
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **SYMBOL** | **COMPOUND OPERATOR** | **DESCRIPTION** |'
  prefs: []
  type: TYPE_TB
- en: '| `(*expression A*) && (*expression B*)` | AND | Both `*expression A*` and
    `*expression B*` must be `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| (`*expression A*) &#124;&#124; (*expression B*)` | OR | Either `*expression
    A*` or `*expression B*` must be `true`. |'
  prefs: []
  type: TYPE_TB
- en: '**A QUICK TEST**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have everything wired up correctly and the code uploaded successfully,
    you’ll hear the servo motor move to the 0 degree position and see a message displayed
    on the LCD, as shown in [Figure 9-13](ch09.xhtml#ch09fig13). If the text is garbled
    or otherwise incorrect, double-check the wiring of the LCD, push button, and light
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-13:** LCD display text at the start of the race'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Push the button and see what happens. The servo motor should move, and the display
    should change to the message “Go!” Now, cover the photoresistor with your finger.
    The LCD should display the time elapsed since you pressed the button and covered
    the photo-resistor ([Figure 9-14](ch09.xhtml#ch09fig14)).
  prefs: []
  type: TYPE_NORMAL
- en: With the electronics all working properly, it’s time to build the starting gate
    and track. If the sensor is not behaving as expected, try changing the `darkThreshold`
    value. If it’s too sensitive or triggering immediately, reduce the value of `darkThreshold`.
    If it’s not reacting when you cover up the sensor, try increasing the value. After
    you’ve made these changes, reupload your code and test it again.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-14:** LCD display with time elapsed'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BUILD THE DRAG RACE TRACK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Drag Race Track includes a starting tower with a rotating gate that controls
    the release of the car onto the track. For the track, you can either use a section
    of a toy car race track or build your own from cardstock. The template for the
    tower is shown in [Figure 9-15](ch09.xhtml#ch09fig15). You can download a PDF
    of this template from *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-15:** Template of cardboard cutout pieces for starting gate (not
    full size)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Build the Starting Tower**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Carefully cut the template out from a sheet of cardboard (see [Figure 9-16](ch09.xhtml#ch09fig16)).
    The template has an opening for mounting the servo on one side and a hole on the
    other to mount the bamboo skewer axle for the starting gate. The other pieces
    are the support beams and the starting gate.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-16:** Trace the template and carefully cut out the pieces using
    a sharp craft knife.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the pieces cut out, first mount the servo in the opening, labeled in [Figure
    9-15](ch09.xhtml#ch09fig15). Insert the servo from the outside of the support
    beam so that the servo horn faces in toward the car. You can use the small screws
    included with the servo, or a small amount of glue, to secure the servo in place
    as shown in [Figure 9-17](ch09.xhtml#ch09fig17). Don’t attach the servo horn just
    yet. You’ll attach that to the starting gate in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-17:** Securing the servo using hot glue'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, glue the two support beams in place. The lower support beam will insert
    into the slots cut into each of the side pieces. The top support beam should fit
    right into the notch on the top of each side piece. Use a small dab of glue to
    secure each of these pieces in place. When you’re done, you should have a starting
    support tower like the one in [Figure 9-18](ch09.xhtml#ch09fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-18:** Adding the support beams'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Assemble the Starting Gate**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To build the starting gate, you’ll need a piece of cardboard that is 2.5 × 1
    inches and a short length of bamboo skewer or thin coffee stirring rod. This will
    serve as an axle for the starting gate. To start, add a small bead of glue to
    the edge of the starting gate piece, and glue the servo horn on so that the hub
    hangs just off the edge, as shown in [Figure 9-19](ch09.xhtml#ch09fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-19:** Gluing the servo horn onto the edge of the starting gate'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cut down the bamboo skewer to 3.5 inches. Place a line of glue along the edge,
    and line the axle up with the hub of the servo horn, as shown in [Figure 9-20](ch09.xhtml#ch09fig20).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-20:** Gluing the axle to the starting gate'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plug in your Arduino and push the reset button to reset the position of the
    servo. Remember that the code will start off with the servo in the 0 degree position;
    this will be the down position, where the starting gate is holding the car in
    place. To place the starting gate into the support tower, first insert the axle
    into the hole on the side piece opposite of the servo, as shown in [Figure 9-21](ch09.xhtml#ch09fig21).
    Keep in mind that when the gate opens, it will rotate clockwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-21:** Inserting the axle into the side piece for the starting gate'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The finished starting tower with the gate is shown in [Figure 9-22](ch09.xhtml#ch09fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-22:** Completed starting tower'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you need a track. You can use a standard Hot Wheels track, which will fit
    on the lower support, or build your own track. If you want to use a Hot Wheels
    track, skip ahead to “[Add the Photoresistor](ch09.xhtml#ch09lev2sec10)” on page
    [270](ch09.xhtml#page_270).
  prefs: []
  type: TYPE_NORMAL
- en: '**Build Your Own Track**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To build your own track, you’ll need at least one sheet of cardstock, cut down
    to 3.5 × 11 inches. You can make several lengths of track and tape them together
    for a longer track, but for our example, we’ll just use a single track.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll fold two side rails on the track. On each side, measure and mark a line
    that is a quarter inch from the edge. Now, fold along the lines so that you have
    a quarter-inch lip on each side of your track. (It’s often helpful to use a metal
    ruler or the edge of a table to make a nice straight fold in cardstock.) The lip
    will keep your car from flying off the track and also adds a small amount of structural
    integrity. Your track should look similar to the one pictured in [Figure 9-23](ch09.xhtml#ch09fig23).
  prefs: []
  type: TYPE_NORMAL
- en: Now, using a small handheld hole punch, make a hole about a half inch from the
    end of your track for your photoresistor. If you don’t have a hole punch, a craft
    knife or sharp pencil will also work. Just be careful when cutting through the
    paper, and always use a cutting mat when using a knife. The hole needs to be just
    large enough for the head of the photoresistor to fit inside.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-23:** Completed track with two sides folded up'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Add the Photoresistor**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whether you’re using a homemade track or a standard toy track, the next step
    is to add the photoresistor at the bottom of the ramp. The photoresistor will
    be your finish-line sensor. (There is a small hole at the end of a standard Hot
    Wheels track, slightly smaller than the diameter of the photoresistor sensor.
    Thankfully, the plastic track is flexible enough that you can simply press the
    head of the photo-resistor through this hole.)
  prefs: []
  type: TYPE_NORMAL
- en: Remove the photoresistor from the breadboard and bend the legs at a right angle
    along the head so that it looks like [Figure 9-24](ch09.xhtml#ch09fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-24:** Bend the head of the photoresistor at a right angle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Insert the head of the photoresistor through the hole in your track. Make sure
    that the photoresistor does not stick out too much, or your car will catch on
    it; the car should be able to roll over the sensor without interference. With
    the legs bent at right angles, you should be able to tape them down securely to
    the bottom side of the track, as shown in [Figure 9-25](ch09.xhtml#ch09fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-25:** Securing the photo resistor to the race track'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reconnect the photoresistor to your breadboard using a pair of male-to-female
    jumper wires. If you extended the track too far and can’t reach the breadboard,
    add more male-to-female jumpers to extend your wires as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**FEEL THE NEED FOR SPEED? CALCULATING AVERAGE SPEED**'
  prefs: []
  type: TYPE_NORMAL
- en: With this project you can accurately measure how long it takes the car to roll
    down the ramp and cross the finish line, but you don’t know how *fast* the car
    is moving—or do you?
  prefs: []
  type: TYPE_NORMAL
- en: Well, you have the total time it takes for the car to reach the bottom of the
    track, and you know the length of the track. With these two pieces of information,
    you can *estimate* how fast the car is moving. We describe this as an estimate
    because it’s really an average speed, as opposed to the exact speed of your car
    when it meets the sensor at the bottom of the ramp. If you watch as the car rolls
    down, you’ll see that it starts at the top of the ramp unmoving, then moves slowly,
    and then continues to speed up as it goes down the track.
  prefs: []
  type: TYPE_NORMAL
- en: Average speed is defined as distance traveled per unit of time. So, to find
    the average speed, you need to measure the length of the track and divide this
    value by the time elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/272fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our track measures about 8.5 inches from the starting gate to the finish-line
    sensor, and in our last test we had a time of 0.581 seconds. If we divide these
    two numbers, we get an average speed of 14.6 inches per second.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/272fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that this is the *average* speed of the car. For our simple setup with
    a straight ramp, this is roughly how fast the car is moving at the middle of the
    ramp, and since it wasn’t moving at the top of the ramp, this means it was moving
    at twice this speed at the bottom of the ramp. How fast is your car moving?
  prefs: []
  type: TYPE_NORMAL
- en: '**Test and Troubleshoot**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, rest the end of your race track without the photoresistor on the starting
    tower so that the ramp extends past the tower by about the length of your toy
    car (see [Figure 9-26](ch09.xhtml#ch09fig26)). This will be the starting position.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-26:** Finished Drag Race Timer with car ready to launch'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you haven’t already done so, plug the Arduino back into your computer or
    into a power source. Push the reset button to make sure that the sketch starts
    over, and find your favorite Matchbox or Hot Wheels car and set it behind the
    starting gate. Push the starting button and watch your car go!
  prefs: []
  type: TYPE_NORMAL
- en: How long did it take to reach the bottom? On our track, our toy cars took just
    over 0.5 seconds. Try a few different cars, or invite some friends over to see
    whose car is the fastest. If you tape a few pennies to your car, does it go faster?
    Experiment and see how different things affect the drag race time of your car.
  prefs: []
  type: TYPE_NORMAL
- en: '**GOING FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, we introduced you to using the LCD to display information directly
    from your Arduino sketch. Here are a few ideas of how you can take what you’ve
    done in this project further.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hack**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Racing against yourself is only so much fun. Let’s look at how to add a second
    track and have two cars race against each other. (See [Figure 9-27](ch09.xhtml#ch09fig27).)
    For this hack, you’ll need an extra photoresistor, which isn’t included in the
    standard SparkFun Inventor’s Kit. Find a friend who also has a kit, buy one separately,
    or find one in the additional parts kit for this book.
  prefs: []
  type: TYPE_NORMAL
- en: First you need to create a separate finish-line sensor circuit. We were able
    to sneak in one more photoresistor and a pull-down resistor circuit near the bottom
    of the breadboard, as shown in [Figure 9-28](ch09.xhtml#ch09fig28). Connect the
    second photoresistor circuit to pin 2 on the Arduino through a 10 kΩ pull-down
    resistor, and connect the other leg to the 5 V power rail.
  prefs: []
  type: TYPE_NORMAL
- en: Place the photoresistor in the second track, and add male-to-female jumper wires
    to connect this to your circuit on the breadboard. Set your second track next
    to the first one on the starting tower. Now, it’s time to upload some new code
    that will use both sensors. You only need to add a few extra lines to allow for
    the two cars to race. Download the *P9_TwoCarDragRaceTimer.ino* file from *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*
    and open it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the additions to this code. First, the code adds a new
    constant and variable for the second photoresistor finishline sensor, `finishSensor2Pin`
    and `finishSensor2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it checks which sensor was crossed first using a compound `if()` statement.
    If car #1 crosses first, `finishSensor1` will be `0` and `finishSensor2` will
    still be `1`. Inside this `if()` statement, instructions display the winning information
    to the LCD and set the state variable, `finishFlag`, to `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `else-if()` statement checks whether car #2 crosses the finish line first;
    in this case, `finishSensor2` will be `0` and `finishSensor1` will still be `1`.
    In the unlikely event that both cars do actually cross the line at the same time,
    this code does nothing. See if you can figure out how to add a draw feature in
    the event of a tie.'
  prefs: []
  type: TYPE_NORMAL
- en: The code is full of comments to help explain more. Now, upload the code to your
    board and race! Whose car is fastest?
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 9-27:** Drag Race Timer with two race tracks'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 9-28:** Adding a second photo-resistor for racing two cars at the
    same time'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig9_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Modify**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve seen how to use the LCD circuit, try going back and adding an
    LCD to one of the projects you’ve already built. In any of the projects where
    you used the Serial Monitor to display information, like the Reaction Timer from
    [Project 4](ch04.xhtml#ch04) or the Tiny Desktop Greenhouse in [Project 7](ch07.xhtml#ch07),
    you can replace the Serial Monitor with the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to check the wiring and the pin configuration used; you’ll need
    six GPIO pins from your Arduino to control the LCD. If you want to see an example
    of the Reaction Timer project that uses the LCD, take a look at the tutorial we
    created on our InventorSpace at *[https://invent.sparkfun.com/cwists/preview/1145-sik-lcd-reaction-timer/](https://invent.sparkfun.com/cwists/preview/1145-sik-lcd-reaction-timer/)*.
  prefs: []
  type: TYPE_NORMAL
