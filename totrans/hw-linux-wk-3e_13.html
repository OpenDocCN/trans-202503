<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="335" id="Page_335"/>13</span><br/>
<span class="ChapterTitle">User Environments</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This book’s primary focus is on the parts of the Linux system that normally underlie server processes and interactive user sessions. But eventually, the system and the user have to meet somewhere. Startup files play an important role at this point, because they set defaults for the shell and other interactive programs. They determine how the system behaves when a user logs in.</p>
<p> Most users don’t pay close attention to their startup files, touching them only when they want to add something for convenience, such as an alias. Over time, the files become cluttered with unnecessary environment variables and tests that can lead to annoying (or quite serious) problems. </p>
<p><span epub:type="pagebreak" title="336" id="Page_336"/>If you’ve had your Linux machine for a while, you might have noticed that your home directory accumulates a bafflingly large array of startup files over time. These are sometimes called <em>dot files</em> because they nearly always start with a dot (<em>.</em>), excluding them from the default display of <code>ls</code> and most file managers. Many of these are automatically created when you first run a program, and you’ll never need to change them. This chapter primarily covers shell startup files, which are the ones you’re most likely to modify or rewrite from scratch. Let’s first look at how much care you need to take when working on these files.</p>
<h2 id="h1-500402c13-0001">	13.1	Guidelines for Creating Startup Files</h2>
<p class="BodyFirst">When designing startup files, keep the user in mind. If you’re the only user on a machine, you don’t have much to worry about, because any errors affect only you and they’re easy enough to fix. However, if you’re creating startup files meant to be the defaults for all new users on a machine or network, or if you think that someone might copy your files for use on a different machine, this process becomes considerably more critical. If you make an error in a startup file and distribute it to 10 users, you might end up fixing this error 10 times. </p>
<p>Keep two essential goals in mind when creating startup files for other users: </p>
<ol class="none">
<li><span class="RunInHead">Simplicity</span>  Keep the number of startup files small, and keep the files as short and simple as possible so that they’re easy to modify but hard to break. Each item in a startup file is just one more thing that can break. </li>
<li><span class="RunInHead">Readability</span>  Use extensive comments in files so that the users get a good picture of what each part of a file does.</li>
</ol>
<h2 id="h1-500402c13-0002">	13.2	When to Alter Startup Files</h2>
<p class="BodyFirst">Before making a change to a startup file, ask yourself whether you really should be making it. Here are some good reasons for changing startup files:</p>
<ul>
<li>You want to change the default prompt.</li>
<li>You need to accommodate some critical locally installed software. (Consider using wrapper scripts first, though.)</li>
<li>Your existing startup files are broken.</li>
</ul>
<p>If everything in your Linux distribution works, be careful. Sometimes the default startup files interact with other files in <em>/etc</em>.</p>
<p>That said, you probably wouldn’t be reading this chapter if you weren’t interested in changing the defaults, so let’s examine what’s important.</p>
<h2 id="h1-500402c13-0003"><span epub:type="pagebreak" title="337" id="Page_337"/>	13.3	Shell Startup File Elements</h2>
<p class="BodyFirst">What goes into a shell startup file? Some things might seem obvious, such as the command path and a prompt setting. But what exactly <em>should</em> be in the path, and what does a reasonable prompt look like? And how much is too much to put in a startup file? </p>
<p>This section discusses the essentials of a shell startup file—from the command path, prompt, and aliases through the permissions mask. </p>
<h3 id="h2-500402c13-0001">13.3.1	 The Command Path</h3>
<p class="BodyFirst">The most important part of any shell startup file is the command path. The path should cover the directories that contain every application of interest to a regular user. At the very least, the path should contain these components, in order: </p>
<pre><code>/usr/local/bin
/usr/bin
/bin</code></pre>
<p>This order ensures that you can override standard default programs with site-specific variants located in <em>/usr/local</em>.</p>
<p>Most Linux distributions install executables for nearly all packaged user software in <em>/usr/bin</em>. Some are occasional differences that have crept in over the years, such as putting games in <em>/usr/games</em> and graphical applications in a separate location, so check your system’s defaults first. And make sure that every general-use program on the system is available through one of the directories just listed. If not, your system is probably getting out of control. Don’t change the default path in your user environment to accommodate every new software installation directory. A cheap way to accommodate separate installation directories is to use symbolic links in <em>/usr/local/bin</em>.</p>
<p>Many users create a <em>bin</em> directory of their own to store shell scripts and programs, so you may want to add this to the front of the path: </p>
<pre><code>$HOME/bin</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A newer convention is to place binaries in <em>$HOME/.local/bin</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If you’re interested in systems utilities (such as <code>sysctl</code>, <code>fdisk</code>, and <code>lsmod</code>), add the <em>sbin</em> directories to your path: </p>
<pre><code>/usr/local/sbin
/usr/sbin
/sbin</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="338" id="Page_338"/>Adding a Dot to the Path</h2>
<p class="BoxBodyFirst">There is one small but controversial command path component to discuss: the dot. Placing a dot (<code>.</code>) in your path allows you to run programs in the current directory without using <code>./</code> in front of the program name. This may seem convenient when writing scripts or compiling programs, but it’s a bad idea for two reasons: </p>
<ul>
<li>It can be a security problem. You should <em>never</em> put a dot at the <em>front</em> of the path. As just one example of what might happen, an attacker could put a Trojan horse named <code>ls</code> in an archive distributed on the internet. Even if the dot is placed at the end of the path, you’d still be vulnerable to an attacker anticipating typos such as <code>sl</code> or <code>ks</code>. </li>
<li>It is inconsistent and can be confusing. A dot in a path can mean that a command’s behavior will change according to the current directory. </li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c13-0002">13.3.2	 The Manual Page Path</h3>
<p class="BodyFirst">The traditional manual page path was determined by the <code>MANPATH</code> environment variable, but you shouldn’t set it because doing so overrides the system defaults in <em>/etc/manpath.config</em>. </p>
<h3 id="h2-500402c13-0003">13.3.3	 The Prompt</h3>
<p class="BodyFirst">Experienced users tend to avoid long, complicated, useless prompts. In comparison, many administrators and distributions drag everything into a default prompt. Even many shell default prompts are cluttered or otherwise mostly useless. For example, the default <code>bash</code> prompt contains the shell name and version number. Your choice should reflect your users’ needs; place the current working directory, hostname, and username in the prompt if it really helps. </p>
<p>Above all, avoid characters that mean something significant to the shell, such as these: </p>
<pre><code>{ } = &amp; &lt; &gt;</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Take extra care to avoid the <var>&gt;</var> character, which can cause erratic, empty files to appear in your current directory if you accidentally copy and paste a section of your shell window (<var>&gt;</var> redirects output to a file). </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>This simple prompt setting for <code>bash</code> ends with the customary <code>$</code> (the traditional <code>csh</code> prompt ends with <code>%</code>): </p>
<pre><code>PS1='\u\$ '</code></pre>
<p><span epub:type="pagebreak" title="339" id="Page_339"/>The <code>\u</code> is an expression that the shell evaluates to the current username (see the PROMPTING section of the bash(1) manual page). Other popular expressions include:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">\h</code></span>  The hostname (the short form, without domain names).</li>
<li><span class="RunInHead"><code class="bold">\!</code></span>  The history number.</li>
<li><span class="RunInHead"><code class="bold">\w</code></span>  The current directory. Because this can become long, you can limit the display to just the final component by using <code>\W</code> instead.</li>
<li><span class="RunInHead"><code class="bold">\$</code></span>  <code>$</code> if running as a user account; <code>#</code> if root.</li>
</ol>
<h3 id="h2-500402c13-0004">13.3.4	 Aliases</h3>
<p class="BodyFirst">Among the stickier points of contemporary user environments is the role of <em>aliases</em>, a shell feature that substitutes one string for another before executing a command. Aliases can be efficient shortcuts that save some typing. However, they have several drawbacks: </p>
<ul>
<li>It can be tricky to manipulate arguments. </li>
<li>They are confusing; a shell’s built-in <code>which</code> command can tell you if something is an alias, but it won’t tell you where it was defined. </li>
<li>They are frowned upon in subshells and noninteractive shells; they aren’t passed onto child shells. </li>
</ul>
<p>One classic mistake when defining an alias is to add extra arguments to an existing command—for example, aliasing <code>ls</code> to <code>ls -F</code>. At best, this can make it difficult to remove the <code>-F</code> argument when you don’t want it. At worst, it can have severe consequences for the user who does not understand that they’re not using the default arguments.</p>
<p>Given these disadvantages, you should probably avoid aliases whenever possible; it’s easier to write a shell function or an entirely new shell script. A computer can start and execute shells so quickly that the difference between an alias and an entirely new command should be unnoticeable. </p>
<p>That said, aliases do come in handy when you wish to alter a part of the shell’s environment. You can’t change an environment variable with a shell script, because scripts run as subshells. (But you can instead define shell functions to perform this task.)</p>
<h3 id="h2-500402c13-0005">13.3.5	 The Permissions Mask</h3>
<p class="BodyFirst">As described in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, a shell’s built-in <code>umask</code> (permissions mask) facility sets your default permissions. Include the <code>umask</code> command in one of your startup files to make certain that any program you run creates files with your desired permissions. There are two reasonable choices: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">077</code></span>  This mask is the most restrictive permissions mask; it doesn’t give any other users access to new files and directories. This is often appropriate on a multi-user system where you don’t want other users to look at any of your files. However, when set as the default, this mask <span epub:type="pagebreak" title="340" id="Page_340"/>can sometimes lead to problems when your users want to share files but don’t understand how to set permissions correctly. (Inexperienced users have a tendency to set files to a world-writable mode.)</li>
<li><span class="RunInHead"><code class="bold">022</code></span>  This mask gives other users read access to new files and directories. This can be a good choice on a single-user system because many daemons that run as pseudo-users won’t be able to see files and directories created with the more restrictive <code>077</code> umask. </li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Certain applications (especially mail programs) override the umask, changing it to <var>077</var> because they feel that their files are the business of no one but the file owner. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c13-0004">	13.4	Startup File Order and Examples</h2>
<p class="BodyFirst">Now that you know what to put into shell startup files, it’s time to see some specific examples. Surprisingly, one of the most difficult and confusing parts of creating startup files is determining which of several possible startup files to use. This section covers the two most popular Unix shells: <code>bash</code> and <code>tcsh</code>. </p>
<h3 id="h2-500402c13-0006">13.4.1	 The bash Shell</h3>
<p class="BodyFirst">In <code>bash</code>, you can choose from the startup filenames <em>.bash_profile</em>, <em>.profile</em>, <em>.bash_login</em>, and <em>.bashrc</em>. Which one is appropriate for your command path, manual page path, prompt, aliases, and permissions mask? The answer is that you should have a <em>.bashrc</em> file accompanied by a <em>.bash_profile</em> symbolic link pointing to <em>.bashrc </em>because there are a few different kinds of <code>bash</code> shell instance types.</p>
<p>The two main shell instance types are interactive and noninteractive, but we’re interested only in interactive shells, because noninteractive shells (such as those that run shell scripts) usually don’t read any startup files. Interactive shells are those you use to run commands from a terminal, such as the ones you’ve seen in this book, and they can be classified as <em>login</em> or <em>non-login</em>.</p>
<h4 id="h3-500402c13-0001">Login Shells</h4>
<p class="BodyFirst">Traditionally, a login shell is what you get when you first log in to a system with the terminal using a program such as <em>/bin/login</em>. Logging in remotely with SSH also gives you a login shell. The basic idea is that the login shell is an initial shell. You can tell if a shell is a login shell by running <code>echo $0</code>; if the first character is a <code>-</code>, the shell’s a login shell.</p>
<p>When <code>bash</code> runs as a login shell, it runs <em>/etc/profile</em>. Then it looks for a user’s <em>.bash_profile</em>, <em>.bash_login</em>, and <em>.profile</em> files, running only the first one that it sees.</p>
<p>As strange as it sounds, it’s possible to run a noninteractive shell as a login shell to force it to run startup files. To do so, start the shell with the <code>-l</code> or <code>--login</code> option.</p>
<h4 id="h3-500402c13-0002"><span epub:type="pagebreak" title="341" id="Page_341"/>Non-Login Shells </h4>
<p class="BodyFirst">A non-login shell is an additional shell that you run after you log in. It’s simply any interactive shell that’s not a login shell. Windowing system terminal programs (<code>xterm</code>, GNOME Terminal, and so on) start non-login shells unless you specifically ask for a login shell.</p>
<p>Upon starting up as a non-login shell, <code>bash</code> runs <em>/etc/bash.bashrc</em> and then runs the user’s <em>.bashrc</em>. </p>
<h4 id="h3-500402c13-0003">The Consequences of Two Kinds of Shells</h4>
<p class="BodyFirst">The reasoning behind the two different startup files is that in the old days, users logged in through a traditional terminal with a login shell, and then started non-login subshells with windowing systems or the <code>screen</code> program. For the non-login subshells, it was deemed a waste to repeatedly set the user environment and run a bunch of programs that had already been run. With login shells, you could run fancy startup commands in a file such as <em>.bash_profile</em>, leaving only aliases and other “lightweight” things to your <em>.bashrc</em>. </p>
<p>Nowadays, most desktop users log in through a graphical display manager (you’ll learn more about these in the next chapter). Most of these start with one noninteractive login shell in order to preserve the login versus non-login model. When they do not, you need to set up your entire environment (path, manual path, and so on) in your <em>.bashrc</em>, or you’ll never see any of your environment in your terminal window shells. However, you <em>also</em> need a <em>.bash_profile</em> if you ever want to log in on the console or remotely, because those login shells don’t ever bother with <em>.bashrc</em>. </p>
<h4 id="h3-500402c13-0004">Example .bashrc </h4>
<p class="BodyFirst">In order to satisfy both non-login and login shells, how would you create a <em>.bashrc</em> that can also be used as your <em>.bash_profile</em>? Here’s one very elementary (yet perfectly sufficient) example: </p>
<pre><code># Command path.
PATH=/usr/local/bin:/usr/bin:/bin:/usr/games
PATH=$HOME/bin:$PATH

# PS1 is the regular prompt. 
# Substitutions include:
# \u username \h hostname \w current directory
# \! history number \s shell name \$ $ if regular user
PS1='\u\$ '

# EDITOR and VISUAL determine the editor that programs such as less
# and mail clients invoke when asked to edit a file.
EDITOR=vi
VISUAL=vi

# PAGER is the default text file viewer for programs such as man.
PAGER=less

# These are some handy options for less.
<span epub:type="pagebreak" title="342" id="Page_342"/># A different style is LESS=FRX
# (F=quit at end, R=show raw characters, X=don't use alt screen)
LESS=meiX

# You must export environment variables.
export PATH EDITOR VISUAL PAGER LESS

# By default, give other users read-only access to most new files.
umask 022</code></pre>
<p>In this startup file, the path has <code>$HOME/bin</code> at the front so that executables there take precedence over the system versions. If you need the system executables, add <code>/sbin</code> and <code>/usr/sbin</code>.</p>
<p>As described earlier, you can share this <em>.bashrc</em> file with <em>.bash_profile</em> via a symbolic link, or you can make the relationship even clearer by creating <em>.bash_profile</em> as this one-liner: </p>
<pre><code>. $HOME/.bashrc</code></pre>
<h4 id="h3-500402c13-0005">Checking for Login and Interactive Shells</h4>
<p class="BodyFirst">With a <em>.bashrc</em> matching your <em>.bash_profile</em>, you don’t normally run extra commands for login shells. However, if you want to define different actions for login and non-login shells, you can add the following test to your <em>.bashrc</em>, which checks the shell’s <code>$-</code> variable for an <code>i</code> character: </p>
<pre><code>case $- in
 *i*) # interactive commands go here
<var>    command</var>
<var>    --snip--</var>
    ;;
 *)   # non-interactive commands go here
    <var>command</var>
    --<var>snip</var>--
    ;;
esac</code></pre>
<h3 id="h2-500402c13-0007">13.4.2	 The tcsh Shell</h3>
<p class="BodyFirst">The standard <code>csh</code> on virtually all Linux systems is <code>tcsh</code>, an enhanced C shell that popularized features such as command-line editing and multimode filename and command completion. Even if you don’t use <code>tcsh</code> as the default new user shell (<code>bash</code> should be the default), you should still provide <code>tcsh</code> startup files in case your users happen to come across <code>tcsh</code>. </p>
<p>You don’t have to worry about the difference between login shells and non-login shells in <code>tcsh</code>. Upon startup, <code>tcsh</code> looks for a <em>.tcshrc</em> file. Failing this, it looks for the <code>csh</code> shell’s <em>.cshrc</em> startup file. The reason for this order is that you can use the <em>.tcshrc</em> file for <code>tcsh</code> extensions that don’t work in <code>csh</code>. You should probably stick to using the traditional <em>.cshrc</em> instead of <em>.tcshrc</em>; it’s highly unlikely that anyone will ever use your startup files with <code>csh</code>. And if a user actually does come across <code>csh</code> on some other system, your <em>.cshrc</em> will work.</p>
<h4 id="h3-500402c13-0006"><span epub:type="pagebreak" title="343" id="Page_343"/>Example .cshrc </h4>
<p class="BodyFirst">Here is a sample <em>.cshrc</em> file: </p>
<pre><code># Command path.
setenv PATH $HOME/bin:/usr/local/bin:/usr/bin:/bin

# EDITOR and VISUAL determine the editor that programs such as less
# and mail clients invoke when asked to edit a file.
setenv EDITOR vi
setenv VISUAL vi

# PAGER is the default text file viewer for programs such as man.
setenv PAGER less

# These are some handy options for less.
setenv LESS meiX

# By default, give other users read-only access to most new files.
umask 022

# Customize the prompt.
# Substitutions include:
# %n username %m hostname %/ current directory
# %h history number %l current terminal %% %
set prompt="%m%% "</code></pre>
<h2 id="h1-500402c13-0005">	13.5	Default User Settings</h2>
<p class="BodyFirst">The best way to write startup files and choose defaults for new users is to experiment with a new test user on the system. Create the test user with an empty home directory and refrain from copying your own startup files to the test user’s directory. Write the new startup files from scratch. </p>
<p>When you think you have a working setup, log in as the new test user in all possible ways (on the console, remotely, and so on). Make sure that you test as many things as possible, including the windowing system operation and manual pages. When you’re happy with the test user, create a second test user, copying the startup files from the first test user. If everything still works, you now have a new set of startup files that you can distribute to new users. </p>
<p>This section outlines reasonable defaults for new users. </p>
<h3 id="h2-500402c13-0008">13.5.1	 Shell Defaults</h3>
<p class="BodyFirst">The default shell for any new user on a Linux system should be <code>bash</code> because:</p>
<ul>
<li>Users interact with the same shell that they use to write shell scripts. (For many reasons, which I won’t expand upon here, <code>csh</code> is a notoriously bad scripting tool—don’t even think about it.) </li>
<li><code>bash</code> is the default on Linux distributions. </li>
<li><span epub:type="pagebreak" title="344" id="Page_344"/><code>bash</code> uses the GNU readline library to accept input, and therefore its interface is identical to that of many other tools. </li>
<li><code>bash</code> gives you fine, easy-to-understand control over I/O redirection and file handles. </li>
</ul>
<p>However, many seasoned Unix wizards use a shell such as <code>csh</code> or <code>tcsh</code> simply because it’s what they’re most familiar with, and they can’t bear to switch. Of course, you can choose any shell you like, but choose <code>bash</code> if you don’t have any preference, and use <code>bash</code> as the default shell for any new user on the system. (Users can change their shell with the <code>chsh</code> command to suit their individual preference.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	There are plenty of other shells out there (<var>rc</var>, <var>ksh</var>, <var>zsh</var>, <var>es</var>, and so on). Some are not appropriate as beginner shells, but <var>zsh</var> and <var>fish</var> are sometimes popular with new users looking for an alternative shell. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c13-0009">13.5.2	 Editor</h3>
<p class="BodyFirst">On traditional systems, the default editor is <code>vi</code> or <code>emacs</code>. These are the only editors virtually guaranteed to exist (or at least be available) on nearly any Unix system, which means they’ll cause the least trouble in the long run for a new user. However, Linux distributions often configure <code>nano</code> to be the default editor, because it’s easier for beginners to use.</p>
<p>As with shell startup files, avoid large default editor startup files. A little <code>set</code> <code>showmatch</code> in the <em>.exrc</em> startup file (to have <code>vi</code> show matching parentheses) never hurt anyone, but steer clear of anything that significantly changes the editor’s behavior or appearance, such as the <code>showmode</code> feature, auto-indentation, and wrap margins. </p>
<h3 id="h2-500402c13-0010">13.5.3	 Pager</h3>
<p class="BodyFirst">The pager is a program, such as <code>less</code>, that shows text one page at a time. It’s perfectly reasonable to set the default <code>PAGER</code> environment variable to <code>less</code>. </p>
<h2 id="h1-500402c13-0006">	13.6	Startup File Pitfalls</h2>
<p class="BodyFirst">Avoid these pitfalls in startup files: </p>
<ul>
<li>Don’t put any kind of graphical command in a shell startup file. Not all shells run in graphical environments. </li>
<li>Don’t set the <code>DISPLAY</code> environment variable in a shell startup file. We haven’t looked at graphical environments yet, but this can cause your graphical session to misbehave. </li>
<li>Don’t set the terminal type in a shell startup file. </li>
<li>Don’t skimp on descriptive comments in default startup files. </li>
<li>Don’t run commands in a startup file that print to the standard output. </li>
<li>Never set <code>LD_LIBRARY_PATH</code> in a shell startup file (see <span class="xref" itemid="xref_target_Section 15.1.3">Section 15.1.3</span>).</li>
</ul>
<h2 id="h1-500402c13-0007"><span epub:type="pagebreak" title="345" id="Page_345"/>	13.7	Further Startup Topics</h2>
<p class="BodyFirst">Because this book deals only with the underlying Linux system, we won’t cover windowing environment startup files. This is a large issue indeed, because the display manager that logs you in to a modern Linux system has its own set of startup files, such as <em>.xsession</em>, <em>.xinitrc</em>, and the endless combinations of GNOME- and KDE-related items.</p>
<p>The windowing choices may seem bewildering, and there is no one common way to start a windowing environment in Linux. The next chapter describes some of the many possibilities. However, when you determine what your system does, you might get a little carried away with the files that relate to your graphical environment. That’s fine, but don’t carry it over to new users. The same tenet of keeping things simple in shell startup files works wonders for GUI startup files, too. In fact, you probably don’t need to change your GUI startup files at all.</p>
</section>
</body></html>