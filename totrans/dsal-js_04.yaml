- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 3 ABSTRACT DATA TYPES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An *abstract data type (ADT)* is defined by the *operations* it supports and
    the *behavior* it provides. Throughout this book, we’ll study data structures
    insofar as they allow the implementation of specific ADTs; in a very practical
    sense, you could say that an ADT specifies needs and requirements in general.
    This book won’t study data structures just for the sake of it; we’ll always see
    them in the context of an ADT and the operations we need the data structure (and
    associated algorithms) to support. In this chapter, you’ll learn more about what
    ADTs are and how to implement them in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: An ADT may be implemented in many ways, possibly with varying performance (a
    topic we’ll discuss in the next chapter) by using alternative data structures
    and algorithms. For example, you could implement a set with an array, or with
    a list, or with a tree, but the performance won’t be the same in all cases. An
    actual implementation (meaning some data structure plus the algorithms that work
    with it) may be called a *concrete data type (CDT)*, but you won’t see that term
    here.
  prefs: []
  type: TYPE_NORMAL
- en: How a data type is implemented is not abstract; it’s a concrete aspect that
    affects the developer. The definition of a data type requires no coding, but the
    implementation certainly does. Let’s first review some basic concepts about data
    types, abstraction, and operations, and then we’ll move to defining ADTs in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What are data types, and how do we work with them? Can they be defined abstractly,
    or must we always resort to actual implementations? What can we do with data types,
    what operations do they provide, and what effects do they have? Before starting
    with ADTs, let’s take a closer look at some basic software concepts that motivate
    the focus for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programming languages originally included only a few built-in data types, such
    as characters, strings, booleans, and numbers (either integer or floating point),
    and developers couldn’t add any new ones; the given options were all they had
    to work with. After concepts like *classes* were added to programming languages,
    developers were able to add new, more complex data types. A data type in general
    (both those provided by the language and any you create) is defined by the set
    of possible values it may represent and the operations that can be performed on
    it; for example, it’s possible to concatenate two strings, perform logical operations
    with booleans, do arithmetic with integer numbers, or compare floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: When using a data type, the details of its internal representation don’t usually
    matter—only what you can do with it and how you can use it to get results. Input
    and output are all that matter. The basic idea of an ADT is specifying the operations
    that can be done, leaving aside the internal aspects. (If languages provide bit
    operations or some low-level features, you might need to learn internal representation
    details, but for most programming tasks, you won’t need to do that.)
  prefs: []
  type: TYPE_NORMAL
- en: Modern languages, JavaScript included, allow users to define their own data
    types. At first, developers had only simple records (such as representing a date
    with three numeric fields for day, month, and year), but now you can go further
    and use classes to hide implementation details, so users need to care only about
    using the newly defined data type and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ADT can also stand for algebraic data type, which is a different concept representing
    a type formed by combining other types.*'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Abstraction'
  prefs: []
  type: TYPE_NORMAL
- en: We have been bandying about the concept of abstraction, so now let’s consider
    more specifically what that term means. Basically, *abstraction* implies hiding
    or omitting details and reaching instead for an overarching higher-level idea.
    When we talk about abstraction, we are purposefully ignoring implementation aspects,
    at least for the time being, to concentrate on our needs, no matter how we’ll
    get around to code solutions for them. For example, do you need to store and retrieve
    strings? A dictionary ADT would be your solution; you’ll see how to implement
    it later, but no matter how you do it, that’s the data type you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software engineering has three similar and related concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation **Designing modules as if they had a “shell” or “capsule” around
    them, so only the module is responsible for handling its data. The idea is to
    wrap together data and the methods that work on that data in a single place for
    a more coherent, cohesive design.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data hiding **Hiding inner details of a module’s implementation from the
    rest of the system, ensuring that they can be changed without affecting any other
    parts of the code. This mechanism ensures that no one can access internal details
    from the outside. In other words, encapsulation brings everything together, and
    data hiding ensures that nobody can mess with internals from “outside.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity **Dividing a system into separate modules that can be designed
    and developed independently from the rest of the system. Using modules correctly
    provides both encapsulation and data hiding.'
  prefs: []
  type: TYPE_NORMAL
- en: An ADT defines only what operations it can perform; it doesn’t go into detail
    about how those operations will be implemented. In other words, with an ADT, you
    describe what you can do “in the abstract” rather than going into concrete detail.
    Let’s consider some different types of operations we can perform on an ADT.
  prefs: []
  type: TYPE_NORMAL
- en: Operations and Mutations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common way to classify data types is by *mutable* versus *immutable* values.
    For example, in JavaScript, objects and arrays are mutable. After creating an
    object or array, you can modify its values without creating a new object or array.
    On the other hand, numbers and strings are immutable; if you apply an operation
    to either of those data types, a new, different, and distinct value is produced.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a new date type (such as an object with three separate integer
    values, like the date example mentioned earlier in this chapter), you could opt
    to provide operations to set the day, month, or year, which would mean that date
    objects are mutable. On the other hand, if those operations returned a new date
    object instead of modifying the existing one, date objects would be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*React Redux developers are well aware of immutability and what it requires.
    If you want to modify the state of a React application that uses Redux, you cannot
    just modify it directly; you must generate a new state with whatever changes you
    want. Redux assumes that you manage your state data in an immutable way. (We’ll
    discuss immutability further in [Chapter 18](chapter18.xhtml).)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the categories of operations that apply to an ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creators **Functions that produce a new object of the given type, possibly
    taking some values as arguments. Using the date ADT example, a creator could build
    a new date out of day, month, and year values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observers **Functions that take objects of a given type and produce some
    values of a different type. For the date ADT, a getMonth() operation might produce
    the month as an integer, or an isSunday() predicate could determine whether the
    given date falls on a Sunday.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Producers **Functions that take an object of a given type, and possibly some
    extra arguments, and produce a new object of the given type. With the date ADT,
    you could have a function that added an integer number of days to a date, producing
    a new date.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutators **Functions that directly modify an object of a given type. A setMonth()
    method could modify an object (change its month) instead of producing a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: With an immutable data type, only the first three types of operations apply;
    for mutable data types, mutators also apply.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an ADT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a situation where you want to implement a *bag* or *multiset*, which
    is a container like a set, but it allows for repeated elements. (Sets cannot have
    repeated elements by definition.) We’ll also add an extra operation (“greatest”)
    to make it more interesting. [Table 3-1](chapter3.xhtml#tab3-1) provides an example
    of how ADTs are described throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: Operations on Bags'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → bag | Create a new bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | bag → boolean | Given a bag, determine whether it’s empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Add | bag × value → bag | Given a new value, add it to the bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | bag × value → bag | Given a value, remove it from the bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Find | bag × value → boolean | Given a value, check whether it exists in
    the bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Greatest | bag → value &#124; undefined | Given a bag, find the greatest
    value in it. |'
  prefs: []
  type: TYPE_TB
- en: Ignore the middle column for now and focus on the other two. The Operation column
    names each operation that is provided, and the Description column provides a simple
    explanation of what the operation is supposed to achieve. You want to be able
    to create a new (empty) bag and also test whether the bag is empty. You need to
    be able to add new values to the bag and remove previously entered values from
    it, and both of those operations will change the bag’s contents. Finally, you
    want to be able to find whether a given value is in the bag and also determine
    the greatest value in the bag.
  prefs: []
  type: TYPE_NORMAL
- en: You could also have a column specifying the type of the operation— creator,
    observer, producer, and so on—but that’s usually understood from the operation’s
    description and not explicitly included.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the operation’s Signature, the middle column in [Table 3-1](chapter3.xhtml#tab3-1)?
    Unless using TypeScript or Flow (as mentioned in [Chapter 1](chapter1.xhtml)),
    JavaScript doesn’t let developers specify types for functions and variables, but
    adding that information (even if only in comments or a table like this one) helps
    users better understand what the function expects and returns.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a function’s parameters and the returned result is called a *signature*,
    and it’s based on a *type system* called *Hindley-Milner*. You start with the
    types of the function’s parameters, in order, separated by ×, followed by an arrow,
    and then the types of the function’s results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider some examples. [Table 3-1](chapter3.xhtml#tab3-1) shows that
    the create() function doesn’t take any parameters and returns a bag-type result.
    Similarly, add() takes two parameters, a bag and a value, and it returns a bag
    as a result. Finally, the greatest() function takes a bag parameter and returns
    either a value or undefined.
  prefs: []
  type: TYPE_NORMAL
- en: The complete Hindley-Milner system includes several more details, such as constraints
    on the types, generic types, undetermined number of parameters, class methods,
    and so on, but for our needs, the definitions shown in [Table 3-1](chapter3.xhtml#tab3-1)
    will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ADTs Using Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use a class to start implementing a bag ADT. The objects will have two
    attributes: count, which counts how many elements are in the bag, and data, which
    is an object with a key for each element and a value that represents how many
    times that key appears in the bag. Keep in mind, we’re not looking for an especially
    performant way to implement a bag (we’ll get to that in [Chapter 11](chapter11.xhtml)).
    For now, we’re just looking at an example of using classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you add the strings HOME, SWEET, and HOME to a bag, the object
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The count attribute has a value of 3 to reflect that three strings were added
    to the bag. The data part includes a HOME attribute with a value of 2 (since HOME
    was added twice) and a SWEET attribute with a value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-1](#Lis3-1) shows the complete Bag class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: A possible implementation for the bag ADT'
  prefs: []
  type: TYPE_NORMAL
- en: A new object is initialized with a zero count and an empty set of values ❶.
    You can tell whether the object is empty by checking whether the count is zero
    ❷. To see whether the bag contains a given key ❸, check whether it appears in
    the data object with the in operator. Finding the greatest key ❹ is not hard because
    of JavaScript’s functionality. You first get an array with all the keys in data
    (all the values that were added to the bag), and after sorting it, you pop() its
    last element, which will be the greatest key in the bag.
  prefs: []
  type: TYPE_NORMAL
- en: To add a key to the bag, increment the count by 1 ❺ and then check whether the
    key is already in the bag ❻; if it is, increment its count; if it isn’t, add it
    with a count of 1.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a key from the bag, first verify that the key actually is in the bag
    ❼. If it isn’t, don’t do anything at all. If you find the key, decrement the count
    ❽ and then see how many times the key appears in the bag ❾. If its count is greater
    than 1, decrement it by 1\. If it’s exactly 1, just remove the key from the data
    object.
  prefs: []
  type: TYPE_NORMAL
- en: How can you use this object? Taking a few words from the song “Home, Sweet Home”
    (the original song from 1823, not the newer one by Mötley Crüe), you can do something
    like the code shown in [Listing 3-2](#Lis3-2) that adds part of the lyrics to
    the bag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: A test for the bag implementation'
  prefs: []
  type: TYPE_NORMAL
- en: The newly created bag is empty ❶, as expected. You can add several keys to it
    ❷, and the bag will obviously no longer be empty ❸. (See question 3.1 for a more
    compact way of chaining similar operations.) The find operation ❹ works as expected;
    "YES" isn’t in the bag, but "NO" is. Finally, the greatest key in the bag is "THERE'S"
    ❺, but after removing it ❻, "SWEET" is the new greatest value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ADTs Using Functions (Mutable Version)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve created a concrete implementation of an ADT, how would it change
    if you were using functions instead of classes? [Listing 3-3](#Lis3-3) uses the
    same representation based on an object with count and data attributes. The differences
    essentially will be syntactical, like passing the bag object as an argument to
    a function, instead of referring to it as this in a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: An alternative (mutable) implementation of the bag ADT'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in [Listing 3-3](#Lis3-3) is similar to [Listing 3-1](#Lis3-1) that
    used classes. The newBag() function returns an object with the count and data
    fields, like the constructor in the Bag class did. For the other five functions
    (isEmpty, find, greatest, add, and remove), there are only two differences in
    comparison with the classes-based code: you access the object using the bag parameters
    instead of using this, and you expressly return bag at the end of the add() and
    remove() mutator methods. In this case, however, you don’t really need to do this,
    because you are actually modifying the bag parameter, which was passed by reference
    to the functions. (That’s the standard way JavaScript passes objects as arguments.)
    However, if you were to implement this ADT in some other way that didn’t use an
    object, returning the new concrete data type would be mandatory. Since you don’t
    want external dependencies on internal aspects of an implementation, the simplest
    (and safest) way to work is by always returning the new updated object, whatever
    its type.'
  prefs: []
  type: TYPE_NORMAL
- en: The code to use this ADT implementation, shown in [Listing 3-4](#Lis3-4), is
    quite similar to the class-based version in [Listing 3-2](#Lis3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: A test for the mutable implementation of bags'
  prefs: []
  type: TYPE_NORMAL
- en: The simple differences are in object creation ❶, testing whether the bag is
    empty ❷, adding ❸ and removing ❻ elements, getting the greatest value ❹, and finding
    whether a value is in the bag ❺. Instead of writing b.something(...), you would
    write something(b, . . .).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ADTs Using Functions (Immutable Version)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, let’s consider an immutable implementation of our ADT. (In [Chapter
    18](chapter18.xhtml), we’ll see immutable data structures in more detail, with
    several more cases.) There’s no particular reason here for immutability, other
    than wanting to work in a more functional way and avoiding side effects, as described
    in [Chapter 2](chapter2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, as you want to develop an immutable bag, you may not modify
    the bag object directly, so you need to change the implementation of the mutator
    methods; the rest will stay the same. The solution just requires creating and
    returning a new object if the bag needs any changes. To add a new value, use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since adding a new value to a bag can never fail, you always need to produce
    a new object, so you actually do that ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a value from a bag, first check whether the value to remove is in
    it before proceeding to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As before, start by checking whether the value is in the bag ❶; if it is ❷,
    create a new object, which you’ll return.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the code modifications are minimal, but with more complex data
    structures (as we’ll see later in this book), creating a new copy of an existing
    structure may not be so easy or quick, and you’ll need to do extra processing
    or structuring.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of abstract data types, which you’ll
    see in the rest of the book when analyzing the pros and cons of competing data
    structures and algorithms. Defining an ADT is the first step when deciding what
    structure should be used and how algorithms should be implemented. Understanding
    the concept of ADTs will help you get the best possible performance for your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll study a complementary concept: How can we compare
    concrete implementations of ADTs, or in other words, how can we tell whether one
    algorithm is actually better or worse than another? We’ll also introduce analysis
    of algorithms and concepts related to classes of performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**3.1  Chaining Calls**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the Bag methods so you can chain additions in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also be able to chain removals and other operations, such as the
    following, that would remove two values and then test whether the bag becomes
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**3.2  Arrays, Not Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement the bag ADT using arrays instead of objects? You could represent
    the bag with an ordered array to make the greatest() function implementation really
    speedy. Of course, add() should take care of maintaining the order of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3  Extra Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: Only a few extra operations for a bag were described in this chapter, but for
    some applications, you might need added or changed operations; can you think of
    any?
  prefs: []
  type: TYPE_NORMAL
- en: '**3.4  Wrong Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: When defining an ADT, how could you specify error results, such as possibly
    throwing an exception or returning some kind of special value?
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5  Ready, Set ...**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed a bag, but in later chapters, we’ll work with
    sets, which don’t allow repeated values. Can you think ahead and whip up an appropriate
    ADT?
  prefs: []
  type: TYPE_NORMAL
