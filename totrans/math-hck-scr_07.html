<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch07"><span epub:type="pagebreak" id="page_129"/><span class="color2"><strong>7</strong></span></h2>&#13;
<h2 class="h2-hd"><strong>Experiments in Counting</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent"><em>Combinatorics</em> is a branch of mathematics that’s often called <em>the art of counting</em>. The “art” is in coming up with a way to organize a counting problem so that the objects being counted can be generated elegantly.</p>&#13;
<p class="indent">Combinatorics has many important applications. In computer science, for example, combinatorial algorithms are good for tasks such as sorting and searching through data. In telecommunications, combinatorics provides error-correcting codes and network protocols for efficient data transmission. In genetics, it’s used to analyze and model genes to understand heredity and genetic variation.</p>&#13;
<p class="indent">This chapter explores two classic examples from the world of combinatorics: Catalan numbers and partitions. For each example, we’ll develop a strategy for listing every instance of a pattern that satisfies a certain set of rules. Then, we’ll look for a recurrence formula to count all the instances without having to actually list them all.</p>&#13;
<h3 class="h3a" id="ch07lev1">What Are Counting Problems?</h3>&#13;
<p class="noindent">In some counting problems, there’s a parameter indicating a measure of size or quantity: say, the counting number <em>n</em>. We want to know how many ways there are to use <em>n</em> to generate distinct objects. A classic <span epub:type="pagebreak" id="page_130"/>example is figuring out how many ways there are to arrange <em>n</em> items. Each unique ordering of items is considered to be a different object. (The answer is <em>n</em> factorial, as we saw in <a href="ch05.xhtml#ch05">Chapter 5</a>.)</p>&#13;
<p class="indent">In other counting problems, there’s a single object determined by the parameter <em>n</em>, and we want to measure some aspect of that object. For example, we considered square numbers when we discussed sequences in <a href="ch04.xhtml#ch04">Chapter 4</a>. There, the object associated with <em>n</em> was a square of side length <em>n</em>, which can be built with <em>n</em><sup>2</sup> 1×1 subsquares. The sequence of squares is determined by considering how many points there are for <em>n</em> = 1, 2, 3, and so on.</p>&#13;
<p class="indent">I like to think of the parameter in a counting problem as a knob you can turn to get different results. The Fibonacci numbers in <a href="ch04.xhtml#ch04">Chapter 4</a>, for instance, started out as an answer to a counting problem about how many rabbits there will be after <em>n</em> generations, given some constraints about how the rabbits reproduce. Turn the knob to <em>n</em> = 6 generations and you get 8, the answer for the sixth generation. Turn the knob to <em>n</em> = 7 generations and you get 13.</p>&#13;
<p class="indent">Many counting problems are solved with a sequence, and once we have a sequence, we can look for patterns. We might be interested in the rate of growth of the sequence, divisibility properties, or connections with other sequences. There’s a famous project that collects information about integer sequences and puts them in order, like a dictionary: the On-Line Encyclopedia of Integer Sequences<sup>®</sup> (OEIS<sup>®</sup>). It started off in the 1960s as a database stored on punched cards and maintained by Neil Sloane of AT&amp;T Bell Labs. It’s grown considerably over the years and now lives at <em><a href="https://oeis.org">https://oeis.org</a></em>. The OEIS welcomes contributions of new sequences from the public, so if you come up with an interesting sequence that nobody’s thought of before, you can submit it!</p>&#13;
<h3 class="h3" id="ch07lev2">Climbing Mountains with Catalan Numbers</h3>&#13;
<p class="noindent">The <em>Catalan numbers</em> are a sequence of numbers that arise in various counting problems, including the one we’ll look at here. Suppose you want to build a jagged path of up and down steps, like charting a path over the mountains in a mountain range. You start at ground level and move one step forward at a time, stepping either up or down. At the end, you finish back at ground level. The only restriction is that the mountain range must not dip below ground level at any point. How many different patterns of up and down steps—that is, how many unique mountain ranges—can you create?</p>&#13;
<p class="indent">More and more mountain ranges are possible as the number of steps grows, but there are some important limits that stem from the central constraint. Because you have to stay above ground level, the very first step you take has to be up, not down. What’s more, there always have to be at least as many up steps as down steps that have been taken so far. Otherwise, if you go down more than up, you’ll end up below ground level. For example, if we write an up step as ↗ and a down step as ↘, then something like ↗↘↘↗↗↘ wouldn’t work. Spread it out in two dimensions to see why not:</p>&#13;
<div class="imagec"><img src="../images/pg150_Image_179.jpg" alt="Image" width="182" height="71"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_131"/>The mountain range dips below the starting position after the first up-down, so it isn’t allowed. On the other hand, the step sequence ↗↗↘↘↗↘ is allowed. It spreads out as follows:</p>&#13;
<div class="imagec"><img src="../images/pg151_Image_180.jpg" alt="Image" width="183" height="74"/></div>&#13;
<p class="indent">Essentially, to end up back at ground level, the steps have to occur in pairs: for every up, there eventually has to be a corresponding down. So we can use <em>n</em> to represent just the number of up steps, and we can say that the Catalan number <em>C</em>(<em>n</em>) is the total number of acceptable paths that can be made with <em>n</em> up steps. The same <em>n</em> also represents the number of down steps, for a total of 2<em>n</em> steps in each path.</p>&#13;
<p class="indent">In all, there are five acceptable paths that can be built with <em>n</em> = 3 up steps and <em>n</em> = 3 down steps. In other words, <em>C</em>(3) = 5. One of those paths is the ↗↗↘↘↗↘ pattern I just showed. Can you find the others? It isn’t too hard to think through all the possible combinations with a low <em>n</em> value like 3, but as <em>n</em> increases, it becomes more important to have a systematic method for keeping track of all the paths. The beauty of finding the right method is what makes combinatorics the <em>art</em> of counting.</p>&#13;
<p class="indent">Something that worked for the Fibonacci numbers in <a href="ch04.xhtml#ch04">Chapter 4</a> was finding a <em>recurrence</em>, a formula that let us build new numbers in the sequence from old ones. In that case, all we had to do was add the two previous numbers together to get the next number. With Catalan numbers, we might try fitting together old paths that we’ve already generated to form new, longer paths, but we’ll need to go back further than two terms in the sequence to find them all. In fact, we’ll have to look at every shorter path we’ve already generated.</p>&#13;
<p class="indent">We can build a new path with <em>n</em> up arrows by first picking any two numbers that add up to <em>n</em> – 1. Let’s call them <em>a</em> and <em>b</em>. If <em>n</em> were 3, for example, we could choose <em>a</em> = 1 and <em>b</em> = 1, or <em>a</em> = 0 and <em>b</em> = 2, or <em>a</em> = 2 and <em>b</em> = 0, since those all add up to 3 – 1 = 2. For the old paths, we know there’s only one path for <em>a</em> or <em>b</em> = 0. It’s an empty path with zero up steps and zero down steps, where we don’t go anywhere. Likewise, there’s just one path with one up arrow (for <em>a</em> or <em>b</em> = 1): ↗↘. There are two paths with two up arrows (for <em>a</em> or <em>b</em> = 2): ↗↗↘↘ and ↗↘↗↘.</p>&#13;
<p class="indent">The recipe for building new paths is to start with an up arrow (<span class="red">↗</span>), followed by any previously created path with <em>a</em> up arrows. Then, we add a down arrow (<span class="red">↘</span>), followed by any previously created path with <em>b</em> up arrows. That gives us a total of <em>n</em> up arrows: the first up arrow followed by the <em>n</em> – 1 up arrows in the two paths with <em>a</em> and <em>b</em> up arrows. The first up arrow and the constraints on the previously generated paths guarantee that the number of down arrows never exceeds the number of up arrows, which would put us below ground level.</p>&#13;
<p class="indent">Let’s use this recipe to create every possible path for <em>n</em> = 3. For <em>a</em> = 1 and <em>b</em> = 1, we build just one path: <span class="red">↗</span> ↗↘ <span class="red">↘</span> ↗ ↘. For <em>a</em> = 0 and <em>b</em> = 2, there are two cases: <span class="red">↗</span><span class="red">↘</span>↗↗↘↘ and <span class="red">↗</span><span class="red">↘</span>↗↘↗↘. For <em>a</em> = 2 and <em>b</em> = 0, there are also two cases: <span class="red">↗</span>↗↗↘↘<span class="red">↘</span> and <span class="red">↗</span>↗↘↗↘<span class="red">↘</span>. And that’s it. Those are the five possible paths with <em>n</em> = 3 up steps.</p>&#13;
<p class="indent">Notice how when <em>a</em> = 0, each newly generated path is just <span class="red">↗↘</span> followed by an older path with <em>b</em> up steps. Meanwhile, when <em>b</em> = 0, the new path is just an old path <span epub:type="pagebreak" id="page_132"/>with <em>a</em> up steps jacked up so there’s an extra <span class="red">↗</span> at the beginning and an extra <span class="red">↘</span> at the end.</p>&#13;
<p class="indent">Every acceptable path with <em>n</em> up steps can be generated using this simple recipe, as long as we consider every possible combination of values for <em>a</em> and <em>b</em>. For <em>n</em> = 4, for example, we would need all the values of <em>a</em> and <em>b</em> that add up to 3: 0 + 3, 1 + 2, 2 + 1, and 3 + 0.</p>&#13;
<h4 class="h4" id="ch07lev3">Project 28: Navigating Catalan Paths</h4>&#13;
<p class="noindent">In this project we’ll write a Scratch program to build new Catalan paths using the approach we just discussed. First, we need to classify paths by how many up steps they have, so we define a block (shown in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>) that counts all the up steps in a sequence.</p>&#13;
<div class="image"><img id="ch7fig1" src="../images/pg152_Image_181.jpg" alt="Image" width="498" height="507"/></div>&#13;
<p class="figcap"><em>Figure 7-1: How many up steps?</em></p>&#13;
<div class="image"><img id="ch7fig2" src="../images/pg152_Image_182.jpg" alt="Image" width="345" height="459"/></div>&#13;
<p class="figcap"><em>Figure 7-2: Listing all the paths</em></p>&#13;
<p class="indent">This block assumes that each path is expressed as a string, with a forward slash character (<span class="literal">/</span>) to represent a step up and a backslash character (<span class="literal">\</span>) to represent a step down. The block scans the string character by character. Each time it finds a forward slash <span class="ent">❶</span>, it increases the <span class="literal">upcount</span> variable by <span class="literal">1</span>.</p>&#13;
<p class="indent">We can now build a list called <span class="literal">Catalan</span> containing all the acceptable paths up to a desired number of up steps. We start with a path of length 0 and then repeatedly apply the recurrence to get longer and longer new paths. The main program in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a> just asks the user how far to go and then calls the custom <span class="literal">Iterate</span> block <span class="ent">❶</span> the right number of times.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_133"/>The real work is in the <span class="literal">Iterate</span> block, shown in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>, which performs the recurrence.</p>&#13;
<div class="image"><img id="ch7fig3" src="../images/pg153_Image_183.jpg" alt="Image" width="709" height="1254"/></div>&#13;
<p class="figcap"><em>Figure 7-3: Making new paths from old paths</em></p>&#13;
<p class="indent">We use two nested loops to look at all pairs of paths that have been generated so far. Each path in the pair is classified by its number of up steps. For example, <span class="literal">Upcount item loop1 of Catalan</span> gives us the <span class="literal">upcount</span> of the first path in the pair <span class="ent">❶</span>. Every time we find two paths that together have the correct number of up steps <span class="ent">➋</span>, we combine them with an extra up and down step <span class="ent">➌</span> (notice the extra space after <span epub:type="pagebreak" id="page_134"/>the <span class="literal">/</span> and <span class="literal">\</span> characters, which makes the spacing of the output nicer) and add the resulting new path to <span class="literal">Catalan</span>. The code is written so the condition for building a new Catalan path is <span class="literal">a + b = desired size - 1</span>. That way, when we add the extra up step and down step, we get a path with <span class="literal">desired size</span> up steps.</p>&#13;
<h5 class="h5" id="ch07lev4">The Results</h5>&#13;
<p class="noindent">As usual, the output is constrained by the Scratch stage, but you can scroll to see more output or export the <span class="literal">Catalan</span> list as a text file to see the complete contents. <a href="ch07.xhtml#ch7fig4">Figure 7-4</a> shows the top of the list.</p>&#13;
<div class="image"><img id="ch7fig4" src="../images/pg154_Image_184.jpg" alt="Image" width="529" height="434"/></div>&#13;
<p class="figcap"><em>Figure 7-4: Catalan paths for</em> n <em>= 0, 1, 2, and 3</em></p>&#13;
<p class="indent">The first item shows the initial empty path, which grows into a path of ↗↘ when the recurrence is applied the first time. The figure includes the output through <em>n</em> = 3, showing the five acceptable paths with three up steps (list items 5 through 9). <a href="ch07.xhtml#ch7fig5">Figure 7-5</a> shows the next few paths in exported text format, corresponding to <em>n</em> = 4.</p>&#13;
<div class="image"><img id="ch7fig5" src="../images/pg154_Image_185.jpg" alt="Image" width="398" height="486"/></div>&#13;
<p class="figcap"><em>Figure 7-5: Catalan paths for</em> n <em>= 4</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/>Scratch’s list length limit of 200,000 means that this program works only up to <em>n</em> = 11, when 58,786 new paths are generated and added to the list containing the 23,714 shorter paths for values of <em>n</em> from 0 to 10. There are too many paths for <em>n</em> = 12 to complete the list any further. Worse, the double loop in the <span class="literal">Iterate</span> block takes a long time to complete. Since every pair of paths is screened to see if they join to satisfy the Catalan condition, there are as many pairs of paths to test as the square of the length of the list so far. There’s a definite lag by the time we get to <em>n</em> = 10 or 11.</p>&#13;
<p class="indent">Still, by counting up the items in the list with a given number of steps, we can begin to see the sequence of Catalan numbers using this program. Starting with <em>C</em>(0) = <em>C</em>(1) = 1, the next several values in the sequence are 2, 5, 14, 42, 132, 429, 1,430, 4,862, 16,796, and 58,786.</p>&#13;
<h5 class="h5" id="ch07lev5">Hacking the Code</h5>&#13;
<p class="noindent">If we want to know only the Catalan numbers themselves—that is, how many unique paths there are for each value of <em>n</em>—we don’t have to go through the trouble of actually constructing all the paths. Instead, we can calculate the numbers directly using a recurrence based on the same combinatorial insight that helped us generate new paths. To find <em>C</em>(<em>n</em>), we first need to find all the pairs of values <em>a</em> and <em>b</em> such that <em>a</em> + <em>b</em> = <em>n</em> – 1. Then, for each pair, we can look up the corresponding Catalan numbers and multiply them together: <em>C</em>(<em>a</em>) ⋅ <em>C</em>(<em>b</em>). Finally, we add all those products up to get <em>C</em>(<em>n</em>).</p>&#13;
<p class="indent">For example, say we want to find <em>C</em>(5). Since 5 – 1 = 4, we first need to find all the pairs of numbers that add up to 4. They are 0 + 4, 1 + 3, 2 + 2, 3 + 1, and 4 + 0. Notice how the first value in each pair is counting up from 0 to <em>n</em> – 1, while the second value is counting down. Next, we need the Catalan numbers corresponding to the values in these pairs. Assuming we’ve been using this recurrence to calculate all the Catalan numbers starting from <em>C</em>(0), we should know them already: <em>C</em>(0) = 1, <em>C</em>(1) = 1, <em>C</em>(2) = 2, <em>C</em>(3) = 5, and <em>C</em>(4) = 14. We can then multiply each pair of Catalan numbers and add the results together to get <em>C</em>(5):</p>&#13;
<div class="imagec"><img src="../images/pg155_Image_186.jpg" alt="Image" width="741" height="143"/></div>&#13;
<p class="indent">A short way to write this recurrence formula is to use summation notation, where a <em>Σ</em> symbol (the uppercase Greek letter sigma) indicates an addition of one term for each value of the index <em>i</em> from the smallest value of <em>i</em> = 0 (indicated below the <em>Σ</em>) to the largest value of <em>i</em> = <em>n</em> – 1 (indicated above the <em>Σ</em>):</p>&#13;
<div class="imagec"><img src="../images/pg155_Image_187.jpg" alt="Image" width="295" height="83"/></div>&#13;
<p class="noindent">Here, <em>i</em> is equivalent to <em>a</em>, and <em>n</em> – 1 – <em>i</em> is equivalent to <em>b</em>. This makes sense; if <em>a</em> + <em>b</em> = <em>n</em> – 1, then <em>b</em> = <em>n</em> – 1 – <em>a</em>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig6">Figure 7-6</a> shows some code to have Scratch calculate and list as many Catalan numbers as we want.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_136"/><img id="ch7fig6" src="../images/pg156_Image_188.jpg" alt="Image" width="457" height="572"/></div>&#13;
<p class="figcap"><em>Figure 7-6: Making a list of Catalan numbers</em></p>&#13;
<p class="indent">We name the list <span class="literal">C(n)</span> and start by adding <span class="literal">1</span> to it for <em>C</em>(0) = 1. It would be much better, though, if the list indices matched the indices of the sequence entries, with index <span class="literal">1</span> holding <em>C</em>(1), index <span class="literal">2</span> holding <em>C</em>(2), and so on. To make this happen, we delete the first item from the list at the end of the program <span class="ent">❶</span>.</p>&#13;
<p class="indent">As in the original Catalan program, the actual work is done in an <span class="literal">Iterate</span> block, which we can call as many times as we want. <a href="ch07.xhtml#ch7fig7">Figure 7-7</a> shows the block definition.</p>&#13;
<div class="image"><img id="ch7fig7" src="../images/pg156_Image_189.jpg" alt="Image" width="609" height="675"/></div>&#13;
<p class="figcap"><em>Figure 7-7: Applying the recurrence</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>Inside a <span class="literal">repeat</span> loop, we look up pairs of Catalan numbers, with the value of the variable <span class="literal">a</span> starting at <span class="literal">i(1)</span> and increasing up to <span class="literal">size</span> while the value of the variable <span class="literal">b</span> starts at <span class="literal">size</span> and decreases, to account for all pairs in the recurrence. Notice how the definition of <span class="literal">b</span> makes it count backward <span class="ent">❶</span>. We multiply each pair of values and add them to the running total being kept in the <span class="literal">sum</span> variable, which is added to the list at the end of the block.</p>&#13;
<p class="indent">With the recurrence, Scratch is able to calculate the values of <em>C</em>(<em>n</em>) quite quickly, and the limiting value of the program is determined by flintmax instead of the maximum list length. The results are accurate until flintmax is exceeded, which happens after <em>n</em> = 30. The value Scratch calculates for <em>C</em>(31) is off by 1. We don’t exceed Scratch’s floating-point maximum and start getting answers of <span class="literal">Infinity</span>, however, until we hit <em>n</em> = 520.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>7.1</strong></span><span class="space"/>Here’s another recurrence for Catalan numbers:</p>&#13;
<div class="imagec"><img class="inline" src="../images/pg157_Image_190.jpg" alt="Image" width="280" height="55"/></div>&#13;
<p class="noindent-s">After starting with <em>C</em>(0) = 1, this formula applies to all values of <em>n</em> greater than 0. Program this alternative Catalan recurrence in Scratch.</p>&#13;
<p class="indentib"><span class="blue"><strong>7.2</strong></span><span class="space"/>Write a program to make Scratch draw the up-down mountains when you provide a path from a row of the <span class="literal">Catalan</span> list.</p>&#13;
<p class="indentib"><span class="blue"><strong>7.3</strong></span><span class="space"/>There’s a relationship between the Catalan numbers and the central binomial coefficients in Pascal’s triangle, which are entries of the form <em>C</em>(2<em>n</em>, <em>n</em>). Calculate some central binomial coefficients using the program from <a href="ch05.xhtml#ch05lev7">Project 19</a> (<a href="ch05.xhtml#ch5fig7">Figure 5-7</a>), and see if you can find another formula for calculating Catalan numbers.</p>&#13;
<p class="indentib"><span class="blue"><strong>7.4</strong></span><span class="space"/>Another counting problem where Catalan numbers arise involves specifying the order of multiplication by nesting parentheses. Think about how you might multiply four numbers <em>a, b, c</em>, and <em>d</em> by changing how they’re grouped via parentheses, instead of changing the order of the factors. For example, ((<em>ab</em>)<em>c</em>)<em>d</em> would first multiply <em>a</em> and <em>b</em>, then multiply the result of that calculation (the <em>partial product</em>) by <em>c</em>, and finally multiply that by <em>d</em>. On the other hand, (<em>ab</em>)(<em>cd</em>) first multiplies <em>a</em> and <em>b</em>, then multiplies <em>c</em> and <em>d</em>, and finally multiplies together the two partial products. There are three more ways to group four numbers. Find them. Then, change the program for generating Catalan paths so it shows all the ways the parentheses could be grouped.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev6"><span epub:type="pagebreak" id="page_138"/>Breaking Down Numbers with Addition</h3>&#13;
<p class="noindent">Many of the questions we’ve explored about numbers in earlier chapters have been about multiplication. For example, the prime numbers are multiplicative building blocks of the positive integers, and the fundamental theorem of arithmetic says there’s only one way to write a number as a product of primes (ignoring the order of the factors, that is). But what about addition? What are some ways we can write a number as the sum of other numbers?</p>&#13;
<p class="indent">For starters, we might focus on the number 1 and note that every positive integer can be written uniquely as a sum of 1s: 2 = 1 + 1, 3 = 1 + 1 + 1, and so on. We could also impose a different restriction and require that each <em>summand</em> (a number being added) be used at most once. Then, there’s a unique representation for every positive integer if we think in base 2. That is, every positive integer can be uniquely expressed as a sum of distinct powers of 2. (We explored binary representations in <a href="ch01.xhtml#ch01">Chapter 1</a>.) For example, the only way to get 5 without reusing the same power of 2 is 2<sup>2</sup> + 2<sup>0</sup>, or 4 + 1. As soon as we allow a larger set of possible summands than the powers of 2, however, we lose uniqueness. If we permit 3 as a summand along with the powers of 2, for instance, we can get 5 using 1 + 4 or 2 + 3.</p>&#13;
<h4 class="h4o" id="ch07lev7">Compositions: Order Does Matter</h4>&#13;
<p class="noindent">Another decision to make is whether order should matter. Do we count 1 + 2 and 2 + 1 as different representations of 3? If we decide they should be considered different, then there’s an easy way to find the number of possible representations of a given number <em>n</em> as a sum (also called the <em>compositions</em> of <em>n</em>). First, write <em>n</em> = 1 + 1 + . . . + 1. Then, look at each plus sign and make a choice: either keep it or omit it and combine the numbers on each side of it. For example, say <em>n</em> = 3. We could take 3 = 1 + 1 + 1 and decide to get rid of either the first plus sign, making 3 = 1 1 + 1 → 2 + 1, or the second plus sign, making 3 = 1 + 1 1 → 1 + 2. We can also keep both plus signs and get 1 + 1 + 1, or get rid of both and get the single summand 3.</p>&#13;
<p class="indent">We’ve found four compositions of 3, and that’s all there are. To see why, and to develop a general formula for the number of compositions of <em>n</em>, think about the process of going from 1 + 1 + 1 + . . . + 1 to a composition of <em>n</em>. A string of <em>n</em> 1s have <em>n</em> – 1 plus signs between them. For each plus sign, we have a binary choice to make: keep it or drop it. That means there are <em>n</em> – 1 independent binary decisions, which works out to 2<sup><em>n</em>– 1</sup> ways to combine the decisions and make a composition of <em>n</em>. The four compositions of 3 that we identified are “drop, keep,” “keep, drop,” “keep, keep,” and “drop, drop.”</p>&#13;
<h4 class="h4o" id="ch07lev8">Partitions: Order Doesn’t Matter</h4>&#13;
<p class="noindent">A more interesting situation, and one that doesn’t have an answer with such an easy formula, is if we decide that the order of summands <em>doesn’t</em> matter—for example, that 1 + 2 and 2 + 1 should be treated as the same representation of 3. Such a representation, where we ignore the order, is called a <em>partition</em> of <em>n</em> rather than a composition.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_139"/>If the order of summands doesn’t matter, we might as well put the summands in increasing (or rather, nondecreasing) order so we can keep track of all the partitions in a more systematic way. We can then think of a partition as a special kind of composition whose terms are nondecreasing. For example, the three partitions of 3 are 1 + 1 + 1, 1 + 2, and 3.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I say</em> nondecreasing <em>rather than</em> increasing <em>because it wouldn’t really be fair to think of the 1s in 1 + 1 + 1 as being in increasing order. The important thing is that the value of each summand isn’t less than the previous one.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s call <em>P</em>(<em>n</em>) the function that counts the number of partitions of <em>n</em>. Make sure you agree that <em>P</em>(1) = 1 (there’s only one partition of 1: 1 = 1) and that <em>P</em>(2) = 2 (2 = 1 + 1, 2 = 2). We’ve already determined that there are three partitions of 3, so <em>P</em>(3) = 3. You might think you see a pattern, but the number of partitions of <em>n</em> starts to grow more quickly from here on: <em>P</em>(4) = 5, <em>P</em>(5) = 7, and by the time we get to 12 we have <em>P</em>(12) = 77.</p>&#13;
<h4 class="h4" id="ch07lev9">Project 29: A Partition Expedition</h4>&#13;
<p class="noindent">Let’s develop a Scratch program to find all the partitions for a given value of <em>n</em>. We’ll store the results in a <span class="literal">partitions</span> list, with each partition represented as a string of numbers separated by plus signs without any spaces in between, such as <span class="literal">1+1+2</span>. Our strategy will be to start at <em>n</em> = 1 and work our way up to the desired value of <em>n</em>, replacing the contents of <span class="literal">partitions</span> with the current <em>n</em>’s partitions every step of the way. This means we need a way to use a list of all the partitions of <em>n</em> to find all the partitions of <em>n</em> + 1.</p>&#13;
<p class="indent">Some partitions of <em>n</em> + 1 are available by adding a summand of 1 to the start of each partition of <em>n</em>. This is just a matter of joining <span class="literal">1+</span> to each item in the <span class="literal">partitions</span> list. <a href="ch07.xhtml#ch7fig8">Figure 7-8</a> shows a custom block to do that.</p>&#13;
<div class="image"><img id="ch7fig8" src="../images/pg159_Image_191.jpg" alt="Image" width="820" height="379"/></div>&#13;
<p class="figcap"><em>Figure 7-8: Building new partitions from old partitions</em></p>&#13;
<p class="indent">This block simply cycles through the <span class="literal">partitions</span> list, taking one item at a time, adding <span class="literal">1+</span> to the beginning of it, and storing the result back in the same position in the list.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>The remaining partitions of <em>n</em> + 1 can be built by looking back at the partitions of <em>n</em> – 1 and adding a new first term of 2, looking back at the partitions of <em>n</em> – 2 and adding a new first term of 3, and so on. This step is a little trickier since, because of the nondecreasing order rule, not every newly created partition will be acceptable. For example, the only partitions of <em>n</em> – 1 that can have a 2 added to them are the ones that had a smallest term of at least 2 to begin with. If there’s a 1 in the partition, putting a 2 in front breaks the order. Similarly, when adding a 3 to a partition of <em>n</em> – 2, the original partition can’t begin with a 1 or a 2.</p>&#13;
<p class="indent">Another complication is that the <span class="literal">partitions</span> list in our program holds only the partitions of <em>n</em>, which are modified to become the partitions of <em>n</em> + 1. We don’t actually have a record of the earlier partitions of <em>n</em> – 1, <em>n</em> – 2, and so on to look back at. There’s a workaround, though: once we’ve taken all the partitions of <em>n</em> and added a 1 at the beginning to make partitions of <em>n</em> + 1, we can look at each new partition and combine all the 1s. If there are two 1s, this will have the same effect as adding a 2 to the partitions of <em>n</em> – 1. Similarly, if there are three, it will be equivalent to adding a 3 to partitions of <em>n</em> – 2, and so on.</p>&#13;
<p class="indent">To see why this works, consider the case of going from <em>n</em> = 5 to <em>n</em> + 1 = 6. One partition of 5 is 1 + 2 + 2, and adding an extra 1 to it gives us 1 + 1 + 2 + 2, a partition of 6. If we combine those 1s into a 2, we get 2 + 2 + 2, another partition of 6. This is the equivalent of looking back at the partitions of <em>n</em> – 1 = 4, finding the partition 2 + 2, and adding a 2 in front of it. Likewise, another partition of 5 is 1 + 1 + 3. Adding an extra 1 gives us 1 + 1 + 1 + 3 = 6. If we combine those 1s into a 3, we get 3 + 3, the same as if we’d looked back at the partitions of <em>n</em> – 2 = 3, found the partition 3 (any number is a valid partition of itself), and added a 3 in front of it.</p>&#13;
<p class="indent">Implementing this process in code takes a few steps. First, we need to copy the contents of <span class="literal">partitions</span> (the partitions of <em>n</em> + 1 that we got by adding an initial term of 1 to the old partitions of <em>n</em>) into a new list so we don’t overwrite them. The block in <a href="ch07.xhtml#ch7fig9">Figure 7-9</a> does this, placing the copy in a list called <span class="literal">dup</span>.</p>&#13;
<div class="image"><img id="ch7fig9" src="../images/pg160_Image_192.jpg" alt="Image" width="458" height="397"/></div>&#13;
<p class="figcap"><em>Figure 7-9: Copying the list of partitions to a duplicate list</em></p>&#13;
<p class="indent">Next, we need a way to count how many 1s there are at the start of a given partition. The block in <a href="ch07.xhtml#ch7fig10">Figure 7-10</a> handles this task.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_141"/><img id="ch7fig10" src="../images/pg161_Image_193.jpg" alt="Image" width="621" height="781"/></div>&#13;
<p class="figcap"><em>Figure 7-10: Counting the number of 1s in a partition</em></p>&#13;
<p class="indent">Remember, we’re assuming that each partition is a string of numbers separated by plus signs, but we don’t know how many digits each number contains. So this <span class="literal">How many 1s</span> block looks at the string two characters at a time and checks if the first character (<span class="literal">m</span>) is a 1 and the second (<span class="literal">n</span>) is a plus sign. The <span class="literal">repeat until</span> loop keeps incrementing <span class="literal">1count</span> until this is no longer the case. Checking for the plus sign as well as the 1 prevents a string like <span class="literal">1+10</span> from being counted as two 1s. Notice also that we temporarily add an extra plus sign to the end of the string at the start of the block. Without this, the final 1 in a string of all 1s (like <span class="literal">1+1+1</span>) wouldn’t be counted.</p>&#13;
<div class="image"><img id="ch7fig11" src="../images/pg161_Image_194.jpg" alt="Image" width="555" height="475"/></div>&#13;
<p class="figcap"><em>Figure 7-11: Combining the 1s into a larger number</em></p>&#13;
<p class="indent">Once we have the number of 1s in the <span class="literal">1count</span> variable, we can replace all those 1s with the value in <span class="literal">1count</span>. The block in <a href="ch07.xhtml#ch7fig11">Figure 7-11</a> makes the replacement. This block also makes the initial call to the <span class="literal">How many 1s</span> block.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_142"/>In this block, we build up the new partition in the <span class="literal">temp</span> variable. We start by setting <span class="literal">temp</span> to <span class="literal">1count</span>. Then, we use the index variable <span class="literal">k</span> to copy the rest of the original partition string into <span class="literal">temp</span>, starting from character <span class="literal">2 * 1count</span>, which is the plus sign after the last 1. If the original partition consisted entirely of 1s, the <span class="literal">k &gt; length of partition</span> test for the <span class="literal">repeat until</span> loop will fail immediately, so the new partition will just be the value of <span class="literal">1count</span>.</p>&#13;
<p class="indent">Now comes the real work: we need to decide if the string we’ve created by replacing some initial 1s with a single larger number qualifies as a proper partition and should be added to the <span class="literal">partitions</span> list. There are two things that matter here. First, the first term can’t be a 1. If it is, it’s already been counted. (This will be the case if the original partition had only a single 1, in which case the <span class="literal">Replace 1s</span> block will have left it unchanged.) Second, the string of numbers must be in nondecreasing order. We know the original partition was in nondecreasing order, and all we’ve done is combine all the 1s into a larger number, so the only way this condition can fail is if the new first term is bigger than the second term. There’s also the possibility that the partition consists of a single term. This should be considered proper as well. The block in <a href="ch07.xhtml#ch7fig12">Figure 7-12</a> tests for all of these cases.</p>&#13;
<p class="indent">This block is designed to set the <span class="literal">proper</span> variable to a Boolean value, <span class="literal">true</span> or <span class="literal">false</span>, depending on whether the string <span class="literal">p</span> represents a proper partition. We start with a <span class="literal">repeat until</span> loop that extracts the first number into the <span class="literal">first</span> variable <span class="ent">❶</span>. The loop continues until the index variable <span class="literal">i</span> encounters a plus sign or goes beyond the length of the string. We need this loop because the number may have multiple digits. At this point, if <span class="literal">i</span> has exceeded the length of the whole string <span class="ent">➋</span>, we know the partition contains a single term, so we set <span class="literal">proper</span> to <span class="literal">true</span>.</p>&#13;
<p class="indent">If we haven’t reached the end of the string, we use another <span class="literal">repeat until</span> loop to extract the second number into the <span class="literal">second</span> variable <span class="ent">➌</span>. (Again, it could have multiple digits.) We then perform our two main checks again: if <span class="literal">first</span> is greater than <span class="literal">second</span> or if <span class="literal">first</span> is <span class="literal">1</span> <span class="ent">➍</span>, we set <span class="literal">proper</span> to <span class="literal">false</span>. Otherwise, we have a valid partition, so we set <span class="literal">proper</span> to <span class="literal">true</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_143"/><img id="ch7fig12" src="../images/pg163_Image_195.jpg" alt="Image" width="858" height="1387"/></div>&#13;
<p class="figcap"><em>Figure 7-12: Verifying whether the new string still qualifies as a partition</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>With all the blocks we’ve defined so far, we can now define a main <span class="literal">Iterate</span> block that coordinates the process of building the next batch of partitions from the previous batch. <a href="ch07.xhtml#ch7fig13">Figure 7-13</a> shows how.</p>&#13;
<div class="image"><img id="ch7fig13" src="../images/pg164_Image_196.jpg" alt="Image" width="537" height="968"/></div>&#13;
<p class="figcap"><em>Figure 7-13: Growing the list of partitions from</em> n <em>to</em> n <em>+ 1</em></p>&#13;
<p class="indent">This block almost reads like a verbal description of the algorithm. First, we add 1 to every existing partition and make a copy of the <span class="literal">partitions</span> list. Next, we take each partition in the copy and combine all its 1s into a single summand. We then evaluate the results, adding only the proper ones to the <span class="literal">partitions</span> list.</p>&#13;
<p class="indent">During the evaluation phase, notice that we use the counter <span class="literal">j</span> to move backward through the <span class="literal">dup</span> list <span class="ent">❶</span>. A quirk of the algorithm is that because of the way partitions are added to this list, the results end up being generated from highest number first to lowest number first. For example, 1 + 1 + 1 + 1 = 4 initially comes before 1 + 1 + 2 = 4, but after these are transformed into 4 and 2 + 2, the 4 is listed first. Evaluating the list in reverse puts the results back into ascending order.</p>&#13;
<p class="indent">Now that we have all the pieces in place, we just need the green flag code in <a href="ch07.xhtml#ch7fig14">Figure 7-14</a> to set the program in motion.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_145"/><img id="ch7fig14" src="../images/pg165_Image_197.jpg" alt="Image" width="471" height="524"/></div>&#13;
<p class="figcap"><em>Figure 7-14: Generating a list of partitions</em></p>&#13;
<p class="indent">This stack prompts for a number and iterates enough times to get the partitions of that number. We start off the <span class="literal">partitions</span> list with just a <span class="literal">1</span>, the only viable partition of 1 itself.</p>&#13;
<h5 class="h5" id="ch07lev10">The Results</h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch7fig15">Figure 7-15</a> shows the output of a sample run of the program: a list of all 11 partitions of the number 6.</p>&#13;
<div class="image"><img id="ch7fig15" src="../images/pg165_Image_198.jpg" alt="Image" width="469" height="577"/></div>&#13;
<p class="figcap"><em>Figure 7-15: Partitions of 6</em></p>&#13;
<p class="indent">As usual, to see the whole list for larger values of <em>n</em>, you’ll need to either scroll down or export the list to a text file.</p>&#13;
<h5 class="h5" id="ch07lev11"><span epub:type="pagebreak" id="page_146"/>Hacking the Code</h5>&#13;
<p class="noindent">We can calculate <em>P</em>(<em>n</em>), the number of partitions of <em>n</em>, by having Scratch list them all and then seeing how long the list is. This works as long as the list can hold all of the partitions. Scratch’s limit on list length means this program works for values of <em>n</em> up to 49, which has 173,525 partitions. (On my nine-year-old computer, it takes less than two minutes to find them all.) For higher values of <em>n</em>, we can use a recurrence formula to calculate <em>P</em>(<em>n</em>) directly, without having to list all the partitions. It turns out that the recurrence represents <em>P</em>(<em>n</em>) as a combination of earlier terms that are spaced out in an interesting way. The relation is:</p>&#13;
<div class="imagec"><img src="../images/pg166_Image_199.jpg" alt="Image" width="321" height="184"/></div>&#13;
<p class="indent">The sequence 1, 5, 12, 22, . . . , running down the left column, is the sequence of pentagonal numbers from <a href="ch04.xhtml#ch04">Chapter 4</a>, given as follows:</p>&#13;
<div class="imagec"><img src="../images/pg166_Image_200.jpg" alt="Image" width="299" height="57"/></div>&#13;
<p class="noindent">The related sequence 2, 7, 15, 26, . . . , running down the right column, is calculated like this:</p>&#13;
<div class="imagec"><img src="../images/pg166_Image_201.jpg" alt="Image" width="305" height="59"/></div>&#13;
<p class="noindent">The second sequence could also be written as follows to see a different kind of symmetry:</p>&#13;
<div class="imagec"><img src="../images/pg166_Image_202.jpg" alt="Image" width="339" height="56"/></div>&#13;
<p class="indent">Take a look back at <a href="ch04.xhtml#ch4fig14">Figure 4-14</a> in <a href="ch04.xhtml#ch04lev9">Project 16</a> on <a href="ch04.xhtml#page_71">page 71</a> to see both of these sequences highlighted in the visualization of the pentagonal numbers.</p>&#13;
<p class="indent">We can program this recurrence in Scratch to take the calculation of values of <em>P</em>(<em>n</em>) much further. First, we need the custom blocks in <a href="ch07.xhtml#ch7fig16">Figure 7-16</a> to calculate values for the two sequences just described, given a certain value of <em>k</em>.</p>&#13;
<div class="image"><img id="ch7fig16" src="../images/pg166_Image_203.jpg" alt="Image" width="525" height="401"/></div>&#13;
<p class="figcap"><em>Figure 7-16: Formulas for calculating pentagonal numbers</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>Next, <a href="ch07.xhtml#ch7fig17">Figure 7-17</a> shows an <span class="literal">Initialize</span> block that sets up <span class="literal">Partitions</span>, a list for storing the results.</p>&#13;
<div class="image"><img id="ch7fig17" src="../images/pg167_Image_204.jpg" alt="Image" width="499" height="372"/></div>&#13;
<p class="figcap"><em>Figure 7-17: Initializing the recurrence</em></p>&#13;
<p class="indent">We ask how many values of <em>P</em>(<em>n</em>) to calculate and seed the list with the first two values, <em>P</em>(0) = 1 and <em>P</em>(1) = 1. We then set <span class="literal">n</span> to <span class="literal">3</span> to start calculating at the third term of the sequence, the value for <em>P</em>(2).</p>&#13;
<p class="indent">The main program stack, shown in <a href="ch07.xhtml#ch7fig18">Figure 7-18</a>, calls <span class="literal">Initialize</span> and then uses a <span class="literal">repeat</span> loop to calculate the desired number of values of <em>P</em>(<em>n</em>).</p>&#13;
<div class="image"><img id="ch7fig18" src="../images/pg167_Image_205.jpg" alt="Image" width="336" height="763"/></div>&#13;
<p class="figcap"><em>Figure 7-18: Implementing the recurrence for the partition function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/>We start each new <em>P</em>(<em>n</em>) value at <span class="literal">0</span> and use two custom blocks, <span class="literal">loop1</span> and <span class="literal">loop2</span>, to calculate the actual value using the recurrence formula, starting from <em>k</em> = 1. Once the <span class="literal">repeat</span> loop is over, we remove the first item, representing <em>P</em>(0), from the <span class="literal">Partitions</span> list so the index numbers match the values of <em>n</em> <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig19">Figure 7-19</a> shows the definitions of <span class="literal">loop1</span> and <span class="literal">loop2</span>.</p>&#13;
<div class="image"><img id="ch7fig19" src="../images/pg168_Image_206.jpg" alt="Image" width="825" height="1185"/></div>&#13;
<p class="figcap"><em>Figure 7-19: Loops to calculate pentagonal numbers</em></p>&#13;
<p class="indent">In <span class="literal">loop1</span>, we look up earlier values from the <span class="literal">Partitions</span> list according to the left column of the recurrence rule—that is, <em>P</em>(<em>n</em> – 1), <em>P</em>(<em>n</em> – 5), <em>P</em>(<em>n</em> – 12), and so on—using the <span class="literal">p1</span> block to calculate the necessary pentagonal numbers. Each value is stored in the variable <span class="literal">i</span> and then added to the latest value in <span class="literal">Partitions</span>. Since the terms <span epub:type="pagebreak" id="page_149"/>in the recurrence alternate between addition and subtraction, we use the <span class="literal">sign</span> variable <span class="ent">➋</span> to keep track of which operation is needed. It started as <span class="literal">1</span> (addition) before <span class="literal">loop1</span> was called in <a href="ch07.xhtml#ch7fig18">Figure 7-18</a>, and for each new term we multiply it by <span class="literal">-1</span> to switch from addition to subtraction or vice versa <span class="ent">➌</span>. We continue looking up terms until the next pentagonal number (<span class="literal">p1</span>) is greater than the current value of <span class="literal">n</span> <span class="ent">❶</span>.</p>&#13;
<p class="indent">The <span class="literal">loop2</span> block follows the same logic, but it uses <span class="literal">p2</span> to calculate terms from the right column of the recurrence rule: <em>P</em>(<em>n</em> – 2), <em>P</em>(<em>n</em> – 7), <em>P</em>(<em>n</em> – 15), and so on.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig20">Figure 7-20</a> shows some sample output from this program.</p>&#13;
<div class="image"><img id="ch7fig20" src="../images/pg169_Image_207.jpg" alt="Image" width="779" height="625"/></div>&#13;
<p class="figcap"><em>Figure 7-20: The first few values of</em> P<em>(</em>n<em>), and some later ones</em></p>&#13;
<p class="indent">This approach rapidly produces correct values for <em>P</em>(<em>n</em>) through <em>n</em> = 298, until the numbers being combined in the recurrence exceed flintmax. As <em>n</em> continues to grow, the limitations of floating-point arithmetic make the calculated values of <em>P</em>(<em>n</em>) unreliable, oscillating wildly through incorrect values and even some negative numbers before the floating-point limit is reached and we get <span class="literal">Infinity</span>.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>7.5</strong></span><span class="space"/>We can come up with interesting counting problems for partitions by putting extra conditions on the summands. Write a Boolean block that <span epub:type="pagebreak" id="page_150"/>screens partitions and returns <span class="literal">true</span> if every summand is an odd number. Apply the block to the list of partitions generated for a given value of <em>n</em> using the code in <a href="ch07.xhtml#ch7fig14">Figure 7-14</a> and see how many have this property. For example, the partitions of 5 with all odd summands would be 1 + 1 + 1 + 1 + 1, 1 + 1 + 3, and 5 itself.</p>&#13;
<p class="indentib"><span class="blue"><strong>7.6</strong></span><span class="space"/>Write another Boolean block to check if all the parts of a partition are distinct. For example, the partitions of 5 with all distinct parts would be 1 + 4, 2 + 3, and 5 itself. The partition 1 + 2 + 2, among others, wouldn’t count, since it has a repeated part. Compare the number of partitions of <em>n</em> with distinct parts with the number of partitions of <em>n</em> with all odd parts.</p>&#13;
<p class="indentib"><span class="blue"><strong>7.7</strong></span><span class="space"/>The Indian mathematician Srinivasa Ramanujan noticed that <em>P</em>(<em>n</em>) is divisible by 5 whenever <em>n</em> ends in 4 or 9. Verify that fact from a list of <em>P</em>(<em>n</em>) values. Remember that you can export a Scratch list as a text file to view it more easily. See if you can find other patterns for values of <em>P</em>(<em>n</em>) that are divisible by 7 and 11.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev12">Conclusion</h3>&#13;
<p class="noindent">We’ve seen in earlier chapters that Scratch is good for calculating numbers and processing text. Now we know it’s also good for making patterns. Sometimes the first step in counting how many ways a pattern can occur is just making a list of what’s possible—one more job for Scratch Cat! Then, with the right formula or recurrence, we can count the occurrences of a pattern without actually having to list them all.</p>&#13;
</div>
</div>
</body></html>