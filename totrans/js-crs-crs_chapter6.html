<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch6" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch6">
<span class="CN"><span aria-label=" Page 93. " epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CLASSES</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2"><i>Classes</i> are a powerful programming tool for generating multiple objects with shared characteristics and behaviors. They’re a core part of <i>object-oriented programming</i>, a style of coding that revolves around creating objects that contain both data and functions for manipulating that data. In an object-oriented multiplayer game, for example, you might represent each player as an object of a <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class, and each enemy as an object of an <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class. The classes would establish what kind of data a player or enemy should have and would include functions to make the player or enemy do things, like move around or attack.</p>
<p class="TX"><span aria-label=" Page 94. " epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/>In this chapter, you’ll learn how to create JavaScript classes, and how to use those classes to create individual objects. You’ll also learn how to leverage <i>inheritance</i> to share behavior between different classes. Using classes and object-oriented programming in this way gives your code structure and can make it easier to read, write, and understand, especially if your program involves lots of entities with common behaviors.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-32"/><samp class="SANS_Futura_Std_Bold_B_11">Creating Classes and Instances</samp></h3>
<p class="TNI1">A <i>class</i> is like template for making standardized objects. In <a href="chapter3.xhtml">Chapter 3</a> we discussed how an object is a compound data type consisting of key-value pairs, and you saw how to create objects by manually writing out object literals. Classes automate that process, allowing you to instead create objects using a syntax similar to calling a function.</p>
<p class="TX">A class lays out two main things:</p>
<div class="top">
<p class="NL">  1.  What properties each object of that class should have. (Remember that <i>property</i> is another term for a key-value pair in an object.)</p>
<p class="NL">  2.  What functions the object should have access to. (When they’re defined and called as part of a class, functions are called <i>methods</i>.)</p>
</div>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class in a game, for example, might include properties such as the player’s name, health level, position in the environment, and so on. It might have methods for moving, firing a weapon, picking up an item, and more. The class could be used to create multiple different players.</p>
<section aria-labelledby="sec2" epub:type="division">
<aside aria-label="box-19" class="box" id="sec2">
<h4 class="BH" id="box-19"><samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS VS. METHODS</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">It’s easy to confuse functions with methods, since they’re both pieces of code that accomplish a task. The difference is that a method is always associated with an object, whereas a function stands alone. In <a href="chapter5.xhtml">Chapter 5</a>, we practiced writing custom, standalone functions that weren’t associated with particular objects. Meanwhile, we’ve already looked at some methods in <a href="chapter2.xhtml">Chapters 2</a> and</samp> <samp class="SANS_Futura_Std_Book_11"><a href="chapter3.xhtml">3</a></samp><samp class="SANS_Futura_Std_Book_11">—</samp><samp class="SANS_Futura_Std_Book_11">for example, the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">slice</span> <samp class="SANS_Futura_Std_Book_11">method associated with strings and the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">push</span> <samp class="SANS_Futura_Std_Book_11">method associated with arrays. For our purposes, you can think of strings and arrays as specialized types of objects.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Methods are defined on objects, but more importantly, they’re</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">called</samp> <samp class="SANS_Futura_Std_Book_11">on objects using dot notation. The object on the left of the dot is sometimes called the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">receiver</samp><samp class="SANS_Futura_Std_Book_11">, because it receives the method call. For example, when you call</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">myArray.push(2)</span><samp class="SANS_Futura_Std_Book_11">, the receiver is</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">myArray</span><samp class="SANS_Futura_Std_Book_11">. Internally, methods are able to access and modify their receiver using the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> <samp class="SANS_Futura_Std_Book_11">keyword, as you’ll see later in this chapter. By contrast, functions aren’t called using dot notation, so they don’t have a receiver object.</samp></p>
</aside>
<p class="TX"><span aria-label=" Page 95. " epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>Objects created from a class are known as <i>instances</i> of that class. Each player’s character in the game would be an instance of the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class, for example. Each instance fills in the generic template of the class with its own details. A specific <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> instance would have its own name, health level, and position, distinct from those of other <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> instances. All instances can use the class’s methods, however.</p>
<p class="TX">To see how this works, we’ll create a simple <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class for a hypothetical 2D game. For now, we’ll just give the player a position, defined by a set of x- and y-coordinates, and a method for moving that changes those coordinates. Enter the following in the JavaScript console to declare the class:</p>

<pre><code><b>class Player {</b>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <b>constructor(startX, startY) {</b>
<b>    this.x = startX;</b>
<b>    this.y = startY;</b>
<b>  }</b>
  
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> <b>move(dx, dy) {</b>
<b>    this.x +=</b><b> dx;</b>
<b>    this.y += dy;</b>
<b>  }</b>
<b>}</b>
</code></pre>
<p class="TX">We start with the <span class="SANS_TheSansMonoCd_W5Regular_11">class</span> keyword to indicate we’re declaring a new class, followed by the class’s name, <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span>. It’s customary for class names to start with an uppercase letter. Next comes the class body, enclosed in braces, just like a function body. Inside the body we define two methods, <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Declaring a class method is like declaring a function, but we don’t use the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword.</p>
<p class="TX">If a class has a method called <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span>, as our <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class does, that method will be called automatically anytime you create an instance of the class. The constructor performs any necessary setup for the object being created, including receiving any parameters that define the instance and laying out what properties the object should have. In this case, our <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class’s constructor takes in two parameters, <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">startY</span>, and assigns them to the new instance’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties, which together keep track of the player’s position in the 2D game. The <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> keyword refers to the current instance being created, so <span class="SANS_TheSansMonoCd_W5Regular_11">this.x = startX</span> means “take the value of <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span> and assign it to the new <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> property.” Notice that we’re using the same dot notation we’ve used elsewhere to access the properties of an object; the only difference here is that <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> serves as a placeholder for the new object’s name.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method updates the player’s position by changing the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties based on the provided <span class="SANS_TheSansMonoCd_W5Regular_11">dx</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">dy</span> parameters. The <i>d</i> in <span class="SANS_TheSansMonoCd_W5Regular_11">dx</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">dy</span> is short for the Greek letter <i>delta</i>, which often refers to the amount something changes, as in “change in the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> value” and “change in the <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> value.”</p>
<p class="TX">Now that we’ve declared the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class, we can make instances of it. For example:</p>

<pre><code><b>let player1 = new Player(0, 0);</b></code></pre>
<p class="TX"><span aria-label=" Page 96. " epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>We create a new instance of the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class using the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword followed by the class name. After the class name, we write a set of parentheses, much as we would when calling a function. The parentheses contain any arguments that need to be passed to the class’s <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method.</p>
<p class="TX">When you create a new instance of a class with <span class="SANS_TheSansMonoCd_W5Regular_11">new</span>, some magic happens. First, a new, empty object is created. Then a hidden link from this object to the class is created, which is how JavaScript is able to tell which class created the object and what methods the object should therefore have access to. Next, the class’s <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method is called automatically. Inside the constructor, the new object being created is available via the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">this</span>, allowing you to set properties on the object. Any arguments you provide in the parentheses after the class name are passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method’s parameters. After the <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method has been called, the new object is returned.</p>
<p class="TX">In our example, when we enter <span class="SANS_TheSansMonoCd_W5Regular_11">let player1 = new Player(0, 0);</span>, JavaScript creates a new object and gives it a hidden link to the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class. It then calls the class’s <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method, passing the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to the constructor’s <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">startY</span> parameters. The constructor takes these parameters and uses <span class="SANS_TheSansMonoCd_W5Regular_11">this.x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">this.y</span> to set the new object’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. Finally, the new object is returned and assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">player1</span> variable.</p>
<p class="TX">We can now interact with the new object. Here, for example, we look up its position, tell it to move, then look up its position again to confirm the <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method worked:</p>

<pre><code><b>player1.x;</b>
0
<b>player1.y;</b>
0
<b>player1.move(3, 4);</b>
<b>player1.x;</b>
3
<b>player1.y;</b>
4
</code></pre>
<p class="TX">We access the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties using <span class="SANS_TheSansMonoCd_W5Regular_11">player1.x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">player1.y</span>, respectively. They both show the value <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, since that’s what we passed to the constructor. Next, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method, which we defined in the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class. Because instances have a hidden link to the class that created them, they’re able to call methods defined on that class. We use dot notation to call the method, just like calling the built-in methods associated with strings or arrays.</p>
<p class="TX">When you call a method on an object, the <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> keyword inside the method definition is set to the current object (the receiver). When we call <span class="SANS_TheSansMonoCd_W5Regular_11">player1.move(3, 4)</span>, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> inside the body of the <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method is bound to the <span class="SANS_TheSansMonoCd_W5Regular_11">player1</span> object. That’s how one method is able to be shared by multiple objects: <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> becomes whatever object is receiving the method call at any given time.</p>
<p class="TX"><span aria-label=" Page 97. " epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method updates the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties by adding <span class="SANS_TheSansMonoCd_W5Regular_11">dx</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">dy</span> to their current values. For example, when we call <span class="SANS_TheSansMonoCd_W5Regular_11">player1.move(3, 4)</span> we’re setting <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">0 + 3</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">0 + 4</span>. When we again look up the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties, we can see that this worked: <span class="SANS_TheSansMonoCd_W5Regular_11">player1.x</span> has become <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">player1.y</span> has become <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>. If we then made another call to <span class="SANS_TheSansMonoCd_W5Regular_11">move</span>, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">player1.move(2, 2)</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> would become <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> would become <span class="SANS_TheSansMonoCd_W5Regular_11">6</span>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<aside aria-label="box-20" class="box" id="sec3">
<h4 class="BH" id="box-20"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  6-1.</samp><samp class="SANS_Futura_Std_Book_11">  Create a new instance of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> <samp class="SANS_Futura_Std_Book_11">called</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player2</span><samp class="SANS_Futura_Std_Book_11">. Try calling</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> <samp class="SANS_Futura_Std_Book_11">with different values on</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player1</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player2</span><samp class="SANS_Futura_Std_Book_11">. You’ll see that each object has its own</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> <samp class="SANS_Futura_Std_Book_11">properties, but that both objects have access to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> <samp class="SANS_Futura_Std_Book_11">method.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-33"/><samp class="SANS_Futura_Std_Bold_B_11">Inheritance</samp></h3>
<p class="TNI1"><i>Inheritance</i> is a mechanism in object-oriented programming for defining relationships between different classes. Just as a child inherits genes from its parents, a “child” class inherits properties and methods from a “parent” class, taking on the parent’s properties and methods. This is useful when you have multiple classes that should share a general set of behaviors, in addition to each class having some unique behaviors of its own. You can define the general behaviors as part of a parent class, also called a <i>superclass</i>. Then you can define the child classes, also called <i>subclasses</i>, to inherit these behaviors and augment them with other, specialized behaviors. This saves you from having to repeat the general code when you define each subclass.</p>
<p class="TX">To illustrate, in our 2D game, human-controlled players and computer-controlled enemies probably have a lot in common. They both need <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties representing their position, for example, and they both need a <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method to change their position. However, they also have some differences. Perhaps enemies have the ability to attack a player if the player comes too close, but not the other way around—the goal of the game is for players to avoid, not kill, the enemies.</p>
<p class="TX">We can use inheritance to realize this scheme with minimal code. We’ll create a new class called <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> representing <i>any</i> participant in the game. It will hold the general code both players and enemies should have, such as the <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method. We’ll then define <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> as subclasses of <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>. They’ll each inherit the general code from the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> superclass, while also adding their own code particular to just players or enemies.</p>
<p class="TX">First, here’s the definition of the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> class. It’s mostly a copy of our previous <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class, but with a new name. We’re also adding another <span aria-label=" Page 98. " epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/>method, called <span class="SANS_TheSansMonoCd_W5Regular_11">distanceTo</span>, that calculates the distance between two participants in the game:</p>

<pre><code><b>class Actor {</b>
<b>  constructor(startX, startY) {</b>
<b>    this.x = startX;</b>
<b>    this.y = startY;</b>
<b>  }</b>
  
<b>  move(dx, dy) {</b>
<b>    this.x += dx;</b>
<b>    this.y += dy;</b>
<b>  }</b>

<b>  distanceTo(otherActor) {</b>
<b>    let dx = otherActor.x - this.x;</b>
<b>    let dy = otherActor.y - this.y;</b>
<b>    return Math.hypot(dx, dy);</b>
<b>  }</b>
<b>}</b>
</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">distanceTo</span> method takes another <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> (or any object with an x- and y-coordinate) as a parameter and returns the distance to that object. It’s quite common for objects to be passed to other objects’ methods in this way. The distance is determined by calculating the horizontal distance (<span class="SANS_TheSansMonoCd_W5Regular_11">otherActor.x - this.x</span>) and the vertical distance (<span class="SANS_TheSansMonoCd_W5Regular_11">otherActor.y - this.y</span>), and then using the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">Math.hypot</span> method to find the length of the hypotenuse of the triangle formed by the two distances. This is the standard mathematical technique, based on the Pythagorean theorem, for finding the distance between two points on a 2D plane.</p>
<p class="TX">Although it’s technically possible to create an instance of the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> class, it’s not really meant to be instantiated. Classes like <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> that are just meant to be extended by subclasses are sometimes known as <i>abstract classes</i>, because they represent an abstract concept, like a generic entity in a game. Meanwhile, classes that are meant to be instantiated, such as the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> classes we’ll define momentarily, are sometimes known as <i>concrete classes</i>, because they represent something solid, such as actual players or enemies.</p>
<p class="TX">Next, we’ll redefine the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class to inherit from <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>. We’ll add a new property specific to players called <span class="SANS_TheSansMonoCd_W5Regular_11">hp</span> (for <i>hit points</i>), representing the player’s health level—the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class doesn’t need this property, since only players, not enemies, can be attacked:</p>

<pre><code><b>class Player extends Actor {</b>
<b>  constructor(startX, startY) {</b>
<b>    super(startX, startY);</b>
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <b>this.hp = 100;</b>
<b>  }</b>
<b>}</b>
</code></pre>
<p class="TX">This time we declare the class with the <span class="SANS_TheSansMonoCd_W5Regular_11">extends</span> keyword to establish <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> as a subclass of <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>. We have to write only the class’s <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> <span aria-label=" Page 99. " epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/>method, since it inherits the <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">distanceTo</span> methods from <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>. The constructor takes <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">startY</span> parameters, just as before.</p>
<p class="TX">The first thing we do in the constructor is call <span class="SANS_TheSansMonoCd_W5Regular_11">super(startX, startY)</span>. Inside a subclass’s constructor method, the <span class="SANS_TheSansMonoCd_W5Regular_11">super</span> keyword refers to the constructor from the superclass—in this case, the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> class’s constructor. As a result, when we create a new instance of <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> constructor is called automatically, which in turn calls the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> constructor (via <span class="SANS_TheSansMonoCd_W5Regular_11">super</span>). We pass <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">startY</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> constructor, which uses these values to set the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> properties. Then, back in the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class’s constructor, we set the new <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> instance’s <span class="SANS_TheSansMonoCd_W5Regular_11">hp</span> property to <span class="SANS_TheSansMonoCd_W5Regular_11">100</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This way each new player will start with 100 hit points (full health).</p>
<p class="TX">Next, we’ll create our <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class. It, too, will inherit from the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> class, extending it with an <span class="SANS_TheSansMonoCd_W5Regular_11">attack</span> method for attacking players (the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class doesn’t need this method, since only enemies can attack):</p>

<pre><code><b>class Enemy extends Actor {</b>
<b>  attack(player) {</b>
<b>    if (this.distanceTo(player) &lt; 4) {</b>
<b>      player.hp -= 10;</b>
<b>      return true;</b>
<b>    } else {</b>
<b>      return false;</b>
<b>    }</b>
<b>  }</b>
<b>}</b>
</code></pre>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class to extend <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>, just like the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> class. Unlike with <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span>, however, the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class doesn’t have any extra properties (such as <span class="SANS_TheSansMonoCd_W5Regular_11">hp</span>) that need to be set in the constructor. As such, the class doesn’t have its own <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method. When a subclass doesn’t define a constructor, its parent class’s constructor is called automatically when a new instance of the subclass is created. Thus, new <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> instances will still be given an initial position thanks to the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> superclass’s <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method, but we don’t need to show this explicitly in the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class declaration.</p>
<p class="TX">Without a constructor, the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class’s only unique method is <span class="SANS_TheSansMonoCd_W5Regular_11">attack</span>. It takes in a <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> object as a parameter and checks the distance to that object, using the <span class="SANS_TheSansMonoCd_W5Regular_11">distanceTo</span> method inherited from the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> class. (Notice that we call the method using <span class="SANS_TheSansMonoCd_W5Regular_11">this.distanceTo</span>, again using the <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> keyword to reference the current instance of the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> class.) If the distance is less than <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>, the enemy can attack, reducing the player’s <span class="SANS_TheSansMonoCd_W5Regular_11">hp</span> value by <span class="SANS_TheSansMonoCd_W5Regular_11">10</span>. We return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> to indicate that this was a successful attack. If the attack fails because the player is too far away, we return <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> instead.</p>
<p class="TX">Now that we have our <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> classes, we can see how they interact. Let’s create an instance of each class, move them around, and have the enemy attack the player:</p>

<pre><code><b>let player = new Player(1, 2);</b>
<b>let enemy = new Enemy(3, 4);</b>
<b>player.hp;</b>
<span aria-label=" Page 100. " epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/>100
<b>enemy.distanceTo(player);</b>
2.8284271247461903
<b>enemy.attack(player);</b>
true
<b>player.hp;</b>
90
<b>player.move(5, 5);</b>
<b>enemy.attack(player);</b>
false
<b>player.hp;</b>
90
</code></pre>
<p class="TX">First we create an instance of each class, at the positions (1, 2) and (3, 4). The <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> object starts out at full health, as <span class="SANS_TheSansMonoCd_W5Regular_11">player.hp</span> demonstrates. The two objects are about 2.8 units apart, which we confirm by calling <span class="SANS_TheSansMonoCd_W5Regular_11">enemy .distanceTo(player)</span>. At this point, the enemy is close enough to successfully attack the player, so we call its <span class="SANS_TheSansMonoCd_W5Regular_11">attack</span> method using <span class="SANS_TheSansMonoCd_W5Regular_11">enemy.attack(player)</span>. The method returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, indicating a hit, and checking <span class="SANS_TheSansMonoCd_W5Regular_11">player.hp</span> shows the attack has reduced the player’s health to <span class="SANS_TheSansMonoCd_W5Regular_11">90</span>. Next, we move the player by <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> units in the x and y directions. The move puts the player out of range of the enemy, so the enemy’s second attack is unsuccessful, returning <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>. A last check of <span class="SANS_TheSansMonoCd_W5Regular_11">player.hp</span> shows the player’s health remains at <span class="SANS_TheSansMonoCd_W5Regular_11">90</span>.</p>
<p class="TX">Notice in this code that we’ve called the <span class="SANS_TheSansMonoCd_W5Regular_11">distanceTo</span> method on an <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> object and the <span class="SANS_TheSansMonoCd_W5Regular_11">move</span> method on a <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> object. These were both methods defined on the <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> class, but they’re available on the <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> classes as well, proving the subclasses successfully inherited from their superclass. We can also verify this using the <span class="SANS_TheSansMonoCd_W5Regular_11">instanceof</span> keyword, which tests whether an object is an instance of a particular class. Here, for example, we try it out with the <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> object:</p>

<pre><code><b>player instanceof Player;</b>
true
<b>player instanceof Actor;</b>
true
<b>player instanceof Enemy;</b>
false
</code></pre>
<p class="TX">As you may expect, <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> is an instance of <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span>. What might be surprising is that <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> is also an instance of <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>. When a subclass like <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> inherits from a superclass like <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>, instances of the subclass are also considered to be instances of the superclass. On the other hand, <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> is not an instance of <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span>, even though the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> classes share a common superclass.</p>
<p class="TX">In this example, we’ve used a single level of inheritance: an <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> superclass with <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> subclasses. A more sophisticated game might use multiple levels of inheritance to create different subtypes of players and enemies. For example, there might be <span class="SANS_TheSansMonoCd_W5Regular_11">Witch</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Elf</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Centaur</span> classes, all subclasses of <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> (which in turn is a subclass of <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>). These subclasses would share some common abilities, defined on the <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> superclass (as <span aria-label=" Page 101. " epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/>well as any methods defined on <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span>), while also having their own specialized abilities defined on the individual subclasses. Likewise, <span class="SANS_TheSansMonoCd_W5Regular_11">Enemy</span> might have subclasses such as <span class="SANS_TheSansMonoCd_W5Regular_11">Troll</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Demon</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Harpy</span>.</p>
<section aria-labelledby="sec5" epub:type="division">
<aside aria-label="box-21" class="box" id="sec5">
<h4 class="BH" id="box-21"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  6-2.</samp><samp class="SANS_Futura_Std_Book_11">  Create a new class called</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Follower</span> <samp class="SANS_Futura_Std_Book_11">that extends from</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Actor</span> <samp class="SANS_Futura_Std_Book_11">and takes three constructor parameters:</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span><samp class="SANS_Futura_Std_Book_11">,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">startY</span><samp class="SANS_Futura_Std_Book_11">, and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player</span><samp class="SANS_Futura_Std_Book_11">. Pass the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">startX</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">startY</span> <samp class="SANS_Futura_Std_Book_11">parameters to the superclass’s constructor, as we did in the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> <samp class="SANS_Futura_Std_Book_11">class, and save the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> <samp class="SANS_Futura_Std_Book_11">parameter as a property on the object, as we did with the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> <samp class="SANS_Futura_Std_Book_11">class’s</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">hp</span> <samp class="SANS_Futura_Std_Book_11">property. Assume that in this game, a follower can’t be attacked, so it doesn’t need hit points, and it also can’t attack. What it can do is follow the player assigned to its</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> <samp class="SANS_Futura_Std_Book_11">property. To do this, create a</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">follow</span> <samp class="SANS_Futura_Std_Book_11">method that updates the follower’s x- and y-coordinates to match those of its</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">player</span> <samp class="SANS_Futura_Std_Book_11">property.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  6-3.</samp><samp class="SANS_Futura_Std_Book_11">  Create instances of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Player</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Follower</span><samp class="SANS_Futura_Std_Book_11">. Try moving the player, then calling the follower’s</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">follow</span> <samp class="SANS_Futura_Std_Book_11">method to confirm it works.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-34"/><samp class="SANS_Futura_Std_Bold_B_11">Prototype-Based Inheritance</samp></h3>
<p class="TNI1">When JavaScript was first created, there were no classes, but it was still possible to share behaviors between objects using <i>prototype-based inheritance</i>. This older system, which still works today alongside the class system, relies on two mechanisms:</p>
<div class="top">
<p class="NL">  1.  A <i>constructor</i> function that creates and returns new objects. In this context, a constructor is just a regular, standalone function (not a function defined within a class), but it’s called using the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword.</p>
<p class="NL">  2.  A <i>prototype</i>, an example object that the constructor uses as a model for the objects it creates. The newly created objects inherit methods and properties from the prototype object.</p>
</div>
<p class="TX">JavaScript was one of the only mainstream languages to use prototype-based inheritance rather than classes. Recognizing this, the committee that develops the language eventually decided to add support for classes, in order to make JavaScript more palatable to newcomers with a background in other modern programming languages. When they added classes, however, they built the new feature on top of the existing support for prototype-based inheritance. In other words, JavaScript’s class-based inheritance is essentially an alternative syntax for prototype-based inheritance. (This is sometimes known as <i>syntactic sugar</i>, because it makes the syntax more palatable.)</p>
<p class="TX">If you’re comfortable using classes, it isn’t essential that you learn about prototype-based inheritance. However, since classes are a relatively new JavaScript feature, it’s still common to encounter prototype-based inheritance in older code, so it’s worth being able to recognize how it works. <span aria-label=" Page 102. " epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/>Exploring prototype-based inheritance also illuminates some of JavaScript’s inner workings, including the significance of the mysterious <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property you’ve been seeing in the Chrome console. Even if you don’t end up programming with prototype-based inheritance, understanding some of these underlying details can make it easier to use classes.</p>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Constructors and Prototypes</samp></h4>
<p class="TNI1">As I mentioned, prototype-based inheritance involves a constructor function that creates instances of objects, and a prototype object that the instances inherit methods and properties from. This works because JavaScript creates links between the constructor, the prototype, and the new instance being created. Let’s take a look at this in action. We’ll create a new constructor function called <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span>, and add a method called <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> to its prototype. This will allow us to create <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> objects that have access to the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method:</p>

<pre><code><b>function Cat(name) {</b>
<b>  this.name = name;</b>
<b>}</b>
<b>Cat.prototype.sayHello = function () {</b>
<b>  console.log(`Miaow! My name is</b> <b>${this.name}.`);</b>
<b>};</b>
</code></pre>
<p class="TX">We first create a constructor function called <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> with a <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter. Constructor functions, like class names, usually start with a capital letter. The constructor’s body uses <span class="SANS_TheSansMonoCd_W5Regular_11">this.name = name</span> to set the new object’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property to the value of the provided <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter. As with classes, the <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> keyword in a constructor refers to the object being produced.</p>
<p class="TX">When the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor function is created, it’s automatically given a property called <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span>. It might sound weird that functions can have properties, but a JavaScript function is actually a kind of object; the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> function can have a <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> property just like a <span class="SANS_TheSansMonoCd_W5Regular_11">person</span> object can have <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">age</span> properties. This property is accessible as <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>, using the same dot notation we’d use to access a property of any other object.</p>
<p class="TX">The value of <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span> is itself an object, the prototype that <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> instances should be modeled after. By adding methods to this prototype object, we can control what methods any <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> instances will inherit. In this case, we use <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype.sayHello</span> to add a <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method to the prototype. The method logs a greeting that includes the value of <span class="SANS_TheSansMonoCd_W5Regular_11">this.name</span> to the console. When <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> is called as a method on a particular instance, <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> in the method definition refers to that instance—just as it would in a method defined on a class—so <span class="SANS_TheSansMonoCd_W5Regular_11">this.name</span> refers to the value of the instance’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>Notice that Cat.prototype.sayHello chains multiple dot notations together: Cat .prototype refers to the object stored in the Cat function’s prototype property, and .sayHello refers to the sayHello property of that object. That property doesn’t exist yet, so here we’re adding it to the object and setting its value to a function expression.</i></p>
<p class="TX"><span aria-label=" Page 103. " epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>We’ve created a <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor and added a method to its prototype. Now let’s use the constructor to create a new instance that will inherit from the prototype:</p>

<pre><code><b>let kiki =</b><b> new Cat("Kiki");</b>
<b>kiki.sayHello();</b>
Miaow! My name is Kiki.
undefined
</code></pre>
<p class="BodyContinued">Here we create a new object from the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor by calling it with the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword, passing <span class="SANS_TheSansMonoCd_W5Regular_11">"Kiki"</span> as an argument for the constructor’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter. We store the resulting object in the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> variable. Notice that if we’d declared <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> as a class rather than a constructor function, the syntax for creating an object would be exactly the same: <span class="SANS_TheSansMonoCd_W5Regular_11">new Cat("Kiki")</span>. The only difference is whether we’re thinking of <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> as the name of a function or the name of a class.</p>
<p class="TX">Next, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method on the new instance. Because <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> was created using the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor, it has a hidden link to <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>, which JavaScript uses to locate the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> definition. Since <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> was called as a method on the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object, the <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> keyword in <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> is set to <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span>.</p>
<p class="TX">Although I’m calling the link between instance and prototype “hidden,” the Chrome console lets you inspect it via the special <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property. Let’s see what we can find out about <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span>. Enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">kiki;</span> into the console and click the arrow at the side to inspect it:</p>

<pre><code><b>kiki;</b>
<span class="code_MenuArrow"></span><span class="TheSansMonoCd_W5Regular_Italic_I_11">Cat {name: 'Kiki'}</span>
  name: "Kiki"
  <span class="code_MenuArrow"></span>[[Prototype]]: Object
</code></pre>
<p class="TX">The first line of the output tells us that <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> was created with the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor. Next, we see that <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> has a <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">"Kiki"</span> (this was assigned when the constructor was called). We also see that <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> has a <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property whose value is an object. This is the “hidden” link I’ve been talking about to the prototype that this instance inherited from. It’s the same object referenced by <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span> (the <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> property of the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor function). Click the arrow to expand <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> and see what’s inside:</p>

<pre><code><span class="code_MenuArrow"></span><var>Cat {name: 'Kiki'}</var>
  name: "Kiki"
  <span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>    </b><span class="code_MenuArrow"></span>sayHello: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f ()</span>
<b>    </b><span class="code_MenuArrow"></span>constructor: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f Cat(name)</span>
 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <span class="code_MenuArrow"></span>[[Prototype]]: Object
</code></pre>
<p class="TX">We can see that the prototype object has three properties. The first, <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span>, has a value that’s a function, as the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">f ()</span> indicates. This is the <span aria-label=" Page 104. " epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/><span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method we added to the prototype. The second, <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span>, refers to the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor function. This cements the link between the constructor function and the prototype the constructor uses to create new instances. Finally, the prototype itself has its own <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which we’ll explore shortly.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing Constructors and Classes</samp></h4>
<p class="TNI1">In prototype-based inheritance, the chain of references from an instance to its prototype and a prototype to its constructor is how JavaScript knows where to find the methods and properties for that instance. It turns out classes use these same techniques. To demonstrate, let’s create a <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> class that mirrors the functionality of our <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor:</p>

<pre><code><b>class Dog {</b>
<b>  constructor(name) {</b>
<b>    this.name = name;</b>
<b>  }</b>

<b>  sayHello() {</b>
<b>    console.log(`Woof! My name is</b> <b>${this.name}.`);</b>
<b>  }</b>
<b>}</b>
</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> method here is equivalent to the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor function, and the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method is equivalent to <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype.sayHello</span>. Now let’s make a <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> instance and compare it to the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> instance by expanding the <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> properties:</p>

<pre><code><b>let felix = new Dog("Felix");</b>
<b>felix;</b>
<span class="code_MenuArrow"></span><span class="TheSansMonoCd_W5Regular_Italic_I_11">Dog {name: 'Felix'}</span>
  name: "Felix"
  <span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>    </b><span class="code_MenuArrow"></span>constructor: <span class="TheSansMonoCd_W5Regular_Italic_I_11">class Dog</span>
<b>    </b><span class="code_MenuArrow"></span>sayHello: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f sayHello()</span>
<b>    </b><span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>kiki;</b>
<span class="code_MenuArrow"></span><span class="TheSansMonoCd_W5Regular_Italic_I_11">Cat {name: 'Kiki'}</span>
  name: "Kiki"
  <span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>    </b><span class="code_MenuArrow"></span>sayHello: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f ()</span>
<b>    </b><span class="code_MenuArrow"></span>constructor: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f Cat(name)</span>
<b>    </b><span class="code_MenuArrow"></span>[[Prototype]]: Object
</code></pre>
<p class="TX">As you can see, in both cases the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method is found via the <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> link. There are just some minor differences. For example, with <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> the constructor points at a function, whereas for <span class="SANS_TheSansMonoCd_W5Regular_11">felix</span> it points at a class. Also, the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">felix</span> has a name, whereas for <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> it doesn’t (because we defined <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> using an anonymous function).</p>
<p class="TX"><span aria-label=" Page 105. " epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>Note that if you want to access an object’s <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property directly in code, it’s available through the name <span class="SANS_TheSansMonoCd_W5Regular_11">__proto__</span>:</p>

<pre><code><b>kiki.__proto__;</b>
<span class="code_MenuArrow"></span><var>{sayHello: f, constructor: f}</var>
</code></pre>
<p class="BodyContinued">Even though the property is technically called <span class="SANS_TheSansMonoCd_W5Regular_11">__proto__</span>, we’ll continue to call it the <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property, as that’s how it shows up in the Chrome console.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-48"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Object.prototype</samp></h4>
<p class="TNI1">Any object that isn’t created with an explicit constructor function is instead implicitly created with JavaScript’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span> constructor function. The prototype this constructor references, available as <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>, contains basic methods that all objects should inherit. This prototype object marks the end of the line in the chain of prototype references. All objects eventually trace their origin back to <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>.</p>
<p class="TX">For example, while our <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object was created with the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor, its prototype, <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>, was never explicitly created with a constructor. Instead, JavaScript implicitly created this object using the <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span> constructor, so its prototype is <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>. This is what the inner <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property within our view of <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> in the previous code listing is telling us. We can expand that inner <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property to examine <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>:</p>

<pre><code><span class="code_MenuArrow"></span><var>Cat {name: 'Kiki'}</var>
  name: "Kiki"
  <span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>    </b><span class="code_MenuArrow"></span>sayHello: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f ()</span>
<b>    </b><span class="code_MenuArrow"></span>constructor: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f Cat(name)</span>
<b>    </b><span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>   </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span><b> </b><span class="code_MenuArrow"></span>constructor: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f Object()</span>
<b>      </b><span class="code_MenuArrow"></span>hasOwnProperty: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f hasOwnProperty()</span>
<b>      </b><span class="code_MenuArrow"></span>isPrototypeOf: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f isPrototypeOf()</span>
<b>      </b><span class="code_MenuArrow"></span>propertyIsEnumerable: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f propertyIsEnumerable()</span>
<b>      </b><span class="code_MenuArrow"></span>toLocaleString: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f toLocaleString()</span>
<b>      </b><span class="code_MenuArrow"></span>toString: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f toString()</span>
<b>      </b><var>--snip--</var>
</code></pre>
<p class="TX">Notably, this inner prototype object has a <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> property whose value is the <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span> function <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, showing that it’s the <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> property of JavaScript’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span> constructor. The remaining properties correspond to the many default methods that all objects inherit. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">hasOwnProperty</span> is a method that checks if an object has a property defined on itself, rather than on its prototype, and <span class="SANS_TheSansMonoCd_W5Regular_11">toString</span> is a method that returns a string representation of the object.</p>
<p class="TX">When you create an object with an object literal, you aren’t creating it with an explicit constructor function, so it, too, is created implicitly with the <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span> constructor and gets <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span> for its prototype. When we were inspecting objects in the console in <a href="chapter3.xhtml">Chapter 3</a> and saw they had a <span aria-label=" Page 106. " epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/><span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property, that’s what we were seeing. Let’s take another look at one now:</p>

<pre><code><b>let person = {name: "Nick", age: 39};</b>
<b>person;</b>
<span class="code_MenuArrow"></span><span class="TheSansMonoCd_W5Regular_Italic_I_11">{name: 'Nick', age: 39}</span>
  age: 39
  name: "Nick"
  <span class="code_MenuArrow"></span>[[Prototype]]: Object
<b>    </b><span class="code_MenuArrow"></span>constructor: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f Object()</span>
<b>    </b><span class="code_MenuArrow"></span>hasOwnProperty: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f hasOwnProperty()</span>
<b>    </b><span class="code_MenuArrow"></span>isPrototypeOf: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f isPrototypeOf()</span>
<b>    </b><span class="code_MenuArrow"></span>propertyIsEnumerable: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f propertyIsEnumerable()</span>
<b>    </b><span class="code_MenuArrow"></span>toLocaleString: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f toLocaleString()</span>
<b>    </b><span class="code_MenuArrow"></span>toString: <span class="TheSansMonoCd_W5Regular_Italic_I_11">f toString()</span>
<b>    </b><var>--snip--</var>
</code></pre>
<p class="TX">Here we declare a basic <span class="SANS_TheSansMonoCd_W5Regular_11">person</span> object using an object literal, meaning it’s created behind the scenes with the default <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span> constructor. Inspecting the object in the console, we can see that the contents of its <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property are exactly the same as the innermost <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> of the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object. Both objects trace their roots to <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> indirectly through its own prototype (<span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>) and <span class="SANS_TheSansMonoCd_W5Regular_11">person</span> directly.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Walking the Prototype Chain</samp></h4>
<p class="TNI1">When you ask for a property or method from an object, JavaScript first looks on the object itself. If it can’t find the property there, it looks on the object’s prototype. If JavaScript still can’t find the property, it then checks the prototype’s prototype, and so on, until it hits <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>. This process is known as <i>walking the prototype chain</i>. Let’s look up some properties and methods that will walk the prototype chain of our <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object:</p>

<pre><code><b>kiki.name;</b> 
'Kiki'
<b>kiki.sayHello();</b> 
Miaow! My name is Kiki.
undefined
<b>kiki.hasOwnProperty("name");</b> 
true
<b>kiki.madeUpMethodName();</b> 
<span class="code_MenuArrow"></span>Uncaught TypeError: kiki.madeUpMethodName is not a function
<b>    </b>at &lt;anonymous&gt;:1:6
</code></pre>
<p class="TX">First, we access the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property, which is set directly on <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> itself. Second, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method, which is found on the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object’s prototype. To call this method, JavaScript first checks on <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> and then, not finding it, checks on its prototype. Third, we call <span class="SANS_TheSansMonoCd_W5Regular_11">hasOwnProperty</span>, a method from <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>, which is the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object’s prototype’s prototype. (The method returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, since the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property is set directly on <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span>.) Finally, we call <span class="SANS_TheSansMonoCd_W5Regular_11">madeUpMethodName</span>, a nonexistent method. After walking the entire <span aria-label=" Page 107. " epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>prototype chain, from <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span>, JavaScript determines that the method can’t be found and throws an error.</p>
<p class="TX"><a href="chapter6.xhtml#fig6-1">Figure 6-1</a> shows a visual representation of the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object’s prototype chain and the associated constructor functions, <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span>.</p>
<figure class="IMG"><img alt="" class="img1" id="fig6-1" src="../images/Figure_6-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The prototype chain for kiki</samp></p></figcaption>
</figure>
<p class="TX">Each box in the diagram represents an object, with the object’s name as a heading. The left column of each box shows the names of the object’s properties, and the right column shows the values of those properties. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property has a value of <span class="SANS_TheSansMonoCd_W5Regular_11">"Kiki"</span>, and the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat .prototype</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> property is a function, denoted by <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">f ()</span> (remember that a method is just a function that’s a property of an object).</p>
<p class="TX">Some of the property values point at, or refer to, other objects. For example, all constructor functions have a <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> field that points to the object that will be used as the prototype for instances created with that constructor. Thus, the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor’s <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> field points to <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>. Likewise, objects have a link to their prototype through their <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property of <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> links to <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>, since <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> was created with the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor. All prototype objects have a <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> field that links back to the constructor they belong to. As you can see, the <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> field for <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span> connects back to <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span>, and the <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> field for <span class="SANS_TheSansMonoCd_W5Regular_11">Object.prototype</span> connects to <span class="SANS_TheSansMonoCd_W5Regular_11">Object</span>. Instances like <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> don’t have a <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> field defined directly on them. Instead, the constructor is looked up on the instance’s prototype by walking the prototype chain.</p>
<p class="TX">As we saw in the <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> example, classes use the same prototype mechanism under the hood, so this technique of walking the prototype chain is also how properties and methods are looked up on instances of classes.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding a Method</samp></h4>
<p class="TNI1">Understanding how JavaScript walks the prototype chain to locate an object’s methods is important because it allows us to <i>override</i> the definition of a method that an object would otherwise inherit from its prototype. This technique is useful when we want an object to inherit most of its behavior from a prototype, but we want to give it some unique behavior as well. When you call a method, JavaScript uses the first definition it finds for that <span aria-label=" Page 108. " epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>method as it walks the prototype chain, so if we define a method directly on an object, and that method has the same name as a method defined on the object’s prototype, the method on the object itself takes precedence.</p>
<p class="TX">For example, say you want a new <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> object that says hello in a different way from the method defined on <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span>. You could set a separate <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method directly on that new cat, like so:</p>

<pre><code><b>let moona = new Cat("Moona");</b>
<b>moona.sayHello = function () {</b>
<b>  console.log(`HELLO!!! I'M</b> <b>${this.name.toUpperCase()}!`);</b>
<b>};</b>
<b>moona.sayHello();</b>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> HELLO!!! I'M MOONA!
<b>kiki.sayHello();</b>
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> Miaow! My name is Kiki.
</code></pre>
<p class="BodyContinued">Here, we define a new instance with the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> constructor and name it <span class="SANS_TheSansMonoCd_W5Regular_11">moona</span>. Then we define a <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">moona</span> itself that logs a greeting in all caps. When we then call <span class="SANS_TheSansMonoCd_W5Regular_11">moona.sayHello()</span>, we can see in the output that the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> definition set directly on <span class="SANS_TheSansMonoCd_W5Regular_11">moona</span> takes precedence over the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> definition on <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This is also known as <i>shadowing</i>, because the local method casts a kind of shadow over the prototype’s method. Notice, however, that the original <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">Cat.prototype</span> remains intact, as you can see from the output when we call it on <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<aside aria-label="box-22" class="box" id="sec12">
<h4 class="BH" id="box-22"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  6-4.</samp><samp class="SANS_Futura_Std_Book_11">  You can override a method on an instance of a class, just as you can on an instance created through prototype-based inheritance. Try creating a new instance of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> <samp class="SANS_Futura_Std_Book_11">called</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">yappy</span><samp class="SANS_Futura_Std_Book_11">, and modify its</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> <samp class="SANS_Futura_Std_Book_11">method to make it sound more yappy than other</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> <samp class="SANS_Futura_Std_Book_11">instances.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  6-5.</samp><samp class="SANS_Futura_Std_Book_11">  Inspect the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">moona</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">yappy</span> <samp class="SANS_Futura_Std_Book_11">instances in the console. You should see that their</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> <samp class="SANS_Futura_Std_Book_11">methods are defined directly on the instances, whereas the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">kiki</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">felix</span> <samp class="SANS_Futura_Std_Book_11">instances have it defined on their respective prototypes.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-35"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter you learned about classes, which help you organize your code by sharing functionality between multiple objects. You learned how to create classes, how to use them to create instances, and how to extend classes by creating a hierarchy of subclasses and superclasses. You also learned about prototype-based inheritance, JavaScript’s original system for allowing objects to inherit properties and methods. You explored how prototype-based inheritance compares to the newer class system, and you saw how to trace an object’s chain of inheritance through the <span class="SANS_TheSansMonoCd_W5Regular_11">[[Prototype]]</span> property in the console.</p>
</section>
</section>
</body>
</html>