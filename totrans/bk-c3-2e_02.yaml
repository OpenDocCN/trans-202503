- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MEDIA QUERIES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Back when the World Wide Web was something you only accessed via a browser on
    your desktop or laptop, writing CSS was fairly straightforward. Although you had
    to consider cross-browser and cross-platform issues, at least you knew with reasonable
    certainty that everyone was using fundamentally similar devices to view your website.
    Over the last few years, however, we’ve seen an explosion of new devices for accessing
    the Web—from game consoles to mobile devices such as smartphones and tablets.
    Presenting your content to everybody in the same way no longer makes sense when
    they could be viewing your website on a widescreen desktop monitor or a narrow
    handheld screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS has had a way to serve different styles to different media types for quite
    some time, using the `media` attribute of the `link` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But this approach has a number of flaws—not least of which is that using it
    is like wielding a pretty blunt instrument when the screen in question can be
    between 3.5 inches and 32 inches in size. The list of types is too broad, and
    many aren’t supported by the devices they’re aimed at—for example, I don’t know
    of a single web-enabled television that responds to the `tv` type. Unsurprisingly,
    given this, the W3C has begun to deprecate the use of media types.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS3 solution to this problem is to use *media queries*, defined in the
    Media Queries Module (*[http://www.w3.org/TR/css3-mediaqueries/](http://www.w3.org/TR/css3-mediaqueries/)*).
    These queries extend the media types by providing a query syntax that lets you
    serve far more specific styles to your user’s device, giving users a tailored
    experience. This description may sound quite dry, but this feature is actually
    one of the most revolutionary in the entire CSS3 specification. Media queries
    give you the freedom to make websites that are truly device- independent, offering
    your users the best possible experience no matter how they choose to visit your
    site.
  prefs: []
  type: TYPE_NORMAL
- en: The Media Queries Module has W3C Recommendation status, so it is considered
    a standard. The module is already well implemented in all major browsers, including
    Internet Explorer from version 9.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Advantages of Media Queries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a quick demonstration of the power and flexibility of media queries, I’ll
    show an example of how websites can be optimized for mobile browsers without requiring
    a great deal of extra development.
  prefs: []
  type: TYPE_NORMAL
- en: 'People visiting your site on a mobile device may well struggle to use it: The
    text may appear too small, and zooming in means a lot of scrolling to find navigational
    elements; those navigational elements may involve drop-down functionality that
    is triggered by hovering over them, an action that often doesn’t exist on mobile
    devices; large images may take a long time to download over a weak data connection
    and use a substantial portion of a user’s monthly bandwidth allowance. Some sites
    plan for this by providing mobile-friendly versions, but these generally involve
    a lot of development work. A subdomain has to be set up with style sheets and
    HTML templates that differ from the parent site; images have to be resized to
    better fit small screens; and a script has to be created to detect whether a mobile
    browser is being used and to redirect to the mobile site accordingly. This approach
    can cause problems: Your script has to be kept up to date with all mobile browser
    versions, and maintenance often involves duplication to keep both mobile and desktop
    versions in sync.'
  prefs: []
  type: TYPE_NORMAL
- en: Media queries address many of these issues. For a start, they detect devices
    based on their attributes, so no browser-sniffing scripts are required. They allow
    you to target style sheets directly for a device’s capabilities, so if a device
    with a small screen is detected, CSS rules will be tailored to that screen size,
    removing extraneous elements, serving smaller images, and making text clearer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, take a look at the technology website The Next Web (*[http://thenextweb.com/](http://thenextweb.com/)*),
    as shown in [Figure 2-1](ch02.html#ch02fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: The Next Web website viewed in a desktop browser and a mobile
    browser (inset)*'
  prefs: []
  type: TYPE_NORMAL
- en: When viewed in a desktop browser, the site features a long horizontal top navigation,
    related content on the left of the page, and main content laid out in a grid.
    Through the power of media queries, when you view the same site in a narrower
    browser—such as an iPhone would use—the navigation is more compact with sharing
    options hidden away, the related content has been moved off screen, and the main
    content on the page is moved into a single column, which is ideal for scrolling
    down.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Web now appears on more than just desktop and smartphone devices,
    and we really need to be working toward the common goal of websites optimized
    for any device. See “Responsive Web Design” on [page 10](ch02.html#page_10) for
    more on this.
  prefs: []
  type: TYPE_NORMAL
- en: And if you want to see what other people have been doing with media queries,
    you’ll find a great gallery online at *[http://www.mediaqueri.es/](http://www.mediaqueri.es/)*,
    which showcases some of the better examples of what’s possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A media query sets a parameter (or series of parameters) that enables associated
    style rules if the device used to view the page has properties that match that
    parameter. You can use media queries in three ways, all of which match the different
    ways that CSS can be applied to a document. The first is to call an external style
    sheet using the `link` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**RESPONSIVE WEB DESIGN**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2010, Ethan Marcotte wrote an article titled “Responsive Web Design” (*[http://www.alistapart.com/articles/responsive-web-design/](http://www.alistapart.com/articles/responsive-web-design/)*),
    in which he cleverly consolidated contemporary thinking on making websites that
    adapt to the devices used to view them through the power of media queries. Here
    is what he said:'
  prefs: []
  type: TYPE_NORMAL
- en: Now more than ever, we’re designing work meant to be viewed along a gradient
    of different experiences. Responsive web design offers us a way forward, finally
    allowing us to “design for the ebb and flow of things.”
  prefs: []
  type: TYPE_NORMAL
- en: Since then, responsive design has fast become the norm; the majority of developers
    think this way, and more sites every year are launched or relaunched using responsive
    design methods. This sort of design is not without its challenges—designing fluid,
    responsive sites especially has had to be reconsidered, as most design tools are
    simply not up to the job—but we can safely say we’re on the path to creating a
    Web that can be consumed by anyone, anywhere, in a way that’s been carefully considered
    to work with any device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is to call an external style sheet using the `@import` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The third is to use media queries in an embedded style element or in the style
    sheet itself with the extended `@media` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method is the one I’ll use throughout the rest of this chapter, as it’s
    clearer for demonstration purposes. Which method you use largely depends on your
    own preference and the demands of your existing stylesheet structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I’ve introduced the declaration methods, let’s explore the syntax.
    You should already be familiar with the `media` attribute—it declares the media
    types that the styles are applied to, just as in the HTML `link` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The most common media type values are `screen` and `print`, and as with the
    current syntax, you can use a comma-separated list to choose multiple media queries
    (although that’s becoming less necessary as the other media types become deprecated).
    If omitted, the media type defaults to `all`, so if you’re writing rules that
    will apply to all media types you won’t need to specify them in the media query
    constructor; that being the case, these examples are functionally identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To make the code examples in the rest of this book more concise, I’ll omit
    the media type where not essential.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first new attribute for the `@media` rule is `*logic*`. This optional keyword
    can have the value of either `only` or `not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `only` value is mainly useful if you want to hide the rule from older browsers
    that don’t support the syntax; for browsers that do support it, `only` is effectively
    ignored. The `not` value is used to negate the query; you use `not` to apply the
    styles if the parameters you set are *not* met.
  prefs: []
  type: TYPE_NORMAL
- en: If you use `*logic*` or `*media*` in your query, you also need to use the `and`
    operator, as in the previous examples, to combine them with the required `*expression*`
    attribute. This attribute is used to set parameters that offer functionality beyond
    the media type. These parameters are known as *media features*, and they’re critical
    to the power of media queries. That being the case, let’s explore them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Media Features**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Media features* are information about the device that’s being used to display
    the web page: its dimensions, resolution, and so on. This information is used
    to evaluate an `*expression*`, the result of which determines which style rules
    are applied. That `*expression*` could be, for example, “apply these styles only
    on devices that have a screen wider than 480 pixels” or “only on devices that
    are orientated horizontally.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In media queries, most media feature expressions require that a value be supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This value is needed to construct the example expressions I just mentioned.
    In a few cases, however, you can leave out the value and just test the existence
    of the media feature itself against the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Expressions will become clearer as I talk through the different media features
    and explain when values are required or optional.
  prefs: []
  type: TYPE_NORMAL
- en: With the syntax covered, let’s meet some of the more prominent media features.
    The ones I introduce next are the most applicable to color display screens used
    for accessing the Web and are the ones you’re most likely to use on a day-to-day
    basis. Other media features are available, but you’re more likely to use them
    for alternative devices such as TVs or fixed-grid terminals (if they’re supported
    on those devices at all).
  prefs: []
  type: TYPE_NORMAL
- en: '***Width and Height***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `width` media feature describes the width of the rendering viewport of
    the specified media type, which, in practice, usually means the current width
    of the browser (including the scroll bar) for desktop operating systems. The basic
    syntax requires a length value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the rules are applied only to browsers that are set to be exactly
    600px wide, which is probably far too specific. `width` also accepts one of two
    prefixes, `max-` and `min-`, which allows you to test for a minimum or maximum
    width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first query applies the rules in browsers that are no wider than 480px,
    and the second in browsers that are at least 640px wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a practical example. Here, I’ll take advantage of browser window
    sizes by providing a decorative header for wider windows (some rules have been
    left out for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This media query tests for browser viewports that are at least 400px wide and
    applies a background image to the `h1` element when that is the case.
  prefs: []
  type: TYPE_NORMAL
- en: If my browser window is at least 400px wide, I see the image; if I resize it
    to be narrower, only a text header is shown. You can see this example illustrated
    in [Figure 2-2](ch02.html#ch02fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Different style rules applied with the* `*width*` *media feature,
    displayed in a desktop browser and mobile (inset)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `height` media feature works in the same way, except it targets browsers
    based on their height instead of width. The syntax is the same as `width` and
    also permits using `max-` and `min-` prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because of the prevalence of vertical scrolling, however, `height` is used much
    less frequently than `width`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pixel Ratio***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In general, the CSS pixel unit (px) is a measurement of a single pixel on the
    computer screen—if your browser viewport is 1024 pixels wide and you give an element
    a width of 1024px, you expect it to fill the horizontal length of the viewport.
    Many new devices, however, especially smartphones and tablets, have super-high
    resolution screens, which would make an element with a width of 1024 pixels seem
    quite small and hard to read when displayed.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, these newer devices often have a notional CSS pixel, separate
    from the physical pixels of the device, allowing for zooming in and out of the
    content and for high graphical fidelity on the small screen. The ratio of physical
    pixels to CSS pixels is known as the *device pixel ratio (DPR)*. The iPhone 5S,
    for example, has a DPR of 2, which means that one CSS pixel is equal to 4 physical
    pixels—2 horizontally and 2 vertically.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this illustrated in [Figure 2-3](ch02.html#ch02fig3). The example
    on the left shows one CSS pixel on a “normal” screen with a 1:1 pixel ratio. The
    example in the middle shows the same CSS pixel on a screen with a DPR of 2, like
    the iPhone; there are 4 physical pixels in the same space. Finally, the example
    on the right shows how this would appear on a screen with a DPR of 3, like the
    Nexus 5; now there are 9 physical pixels in the space of a single CSS pixel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: A CSS pixel with a 1:1 pixel ratio (left), a DPR of 2 (middle),
    and 3 (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: What that means in practice is that, although the iPhone 5S (for example) has
    a physical resolution of 640×1136, it has a CSS resolution of 320×568—exactly
    half the dimensions, as every CSS pixel is equivalent to two physical pixels,
    both horizontally and vertically (although only when the device is in “mobile
    mode”; see “[Device Width and Height](ch02.html#ch02leve1sec18)” on [page 15](ch02.html#page_15)
    for an explanation of this).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this high DPR makes scalable content—such as text and vector graphics—sharp
    and clear, bitmap images can suffer badly from a loss of quality when viewed on
    high resolution screens. To get around this problem, a new media feature, called
    `resolution`, is available that lets you target devices based on their DPR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `resolution` is a number with a unit of resolution: *dots per
    inch (DPI)*, *dots per centimeter (DPCM)*, or, most pertinently to us, *dots per
    pixel (DPPX)*. The DPPX unit maps to the DPR of the device, so to apply a rule
    to devices that have a DPR value of 1.5, you use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the other media features, you can also detect maximum and minimum pixel
    ratios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This flexibility makes serving higher-resolution background images to browsers
    with higher pixel density easier, as you can see in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first rule (➊) means browsers on devices with a “standard” (or low-resolution)
    pixel ratio will use the standard image (*image-lores.png*), whereas devices with
    a DPR of at least 1.5 will use the high-resolution image (*image-hires.png*) instead
    (➋). Note the use of the unfamiliar `background-size` property here (➌); this
    property should be used with high-resolution images to ensure they aren’t displayed
    larger than the element they are applied to (I introduce `background-size` fully
    in [Chapter 8](ch08.html#ch08)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome, Firefox, and Internet Explorer 10+ all support the `resolution` media
    feature, although IE unfortunately hasn’t implemented the DPPX value; to accommodate
    IE, you should use DPI, multiplying the required DPR by 96 (the DPI value of a
    standard screen). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Safari doesn’t support `resolution`, instead using a proprietary media feature
    called `-webkit-device-pixel-ratio` (along with `max-` and `min-` variants), which
    takes as a value a single, unitless number that is the targeted DPR. So to accommodate
    all modern browsers, use this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `resolution` rule was implemented in the WebKit engine at the end of 2012,
    so I’m disappointed to not see it released in Safari at the time of writing, almost
    two years later. Hopefully this oversight will be rectified in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: '***Device Width and Height***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `width` and `height` media features are related to the dimensions of the
    browser viewport, but that viewport isn’t always as big as the screen it’s displayed
    on. If you need to target the physical screen size rather than the viewport size,
    you can use the `device-width` and `device-height` properties and their related
    `min-` and `max-` variants. You won’t use these too often, but to explain why,
    I need to digress.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, I explained the difference between CSS pixels and
    physical pixels. The `width` media feature is measured in CSS pixels, and `device-width`,
    in physical pixels. To make content readable and “natural sized” on a small screen,
    both dimensions need to match. You do this by adding the *viewport meta tag* into
    the head of the document, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the viewport meta tag with these values is present in the `head` of a page,
    mobile browsers go into “mobile mode,” in which the viewport is sized to ideal
    dimensions for that device. The result is that content is displayed at a more
    appropriate size for the device.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For a more in-depth explanation of mobile viewports and pixels, see Dutch
    developer* *PPK’s “A Pixel Is Not a Pixel Is Not a Pixel”* ([http://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html](http://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: The viewport of a browser on a mobile device tends to be as large as the screen
    itself, so the two are basically equivalent; and on desktop browsers, you will
    most likely want to make your content relative to the width of the viewport rather
    than that of the screen. For these reasons, the `device-width` media feature becomes
    less useful than `width`, and you probably won’t use it too much in practice.
  prefs: []
  type: TYPE_NORMAL
- en: The viewport meta tag is being standardized in CSS as the `@viewport` rule;
    see “[Device Adaptation](ch19.html#ch19leve1sec268)” on [page 252](ch19.html#page_252)
    for a brief walkthrough.
  prefs: []
  type: TYPE_NORMAL
- en: '***Orientation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re less concerned with the actual dimensions of the viewing device but
    want to optimize your pages for either horizontal (like a typical desktop/laptop
    web browser) or vertical (like a mobile phone or ebook reader) viewing, the media
    feature you need is `orientation`. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`*value*` can be one of two keyword options: `landscape` or `portrait`. The
    `landscape` value applies when the width of your browser is greater than its height,
    and the `portrait` value applies when the opposite is true. Although `orientation`
    can certainly be applied to desktop browsers, you’ll find it most useful when
    dealing with handheld devices that the user can easily rotate, such as smartphones
    and tablets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use `orientation` to display a navigation menu horizontally
    or vertically, depending on the visitor’s browser orientation. The code looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `li` elements have a float value of `left`, making them stack
    horizontally across the page. If the same page is viewed in a `portrait` orientation—either
    by resizing the browser to be taller than it is wide or by viewing the page in
    a device with a portrait orientation—the float is removed and the `li` elements
    stack vertically instead. You can see the result in [Figure 2-4](ch02.html#ch02fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: The* `*orientation*` *media feature in use on a mobile browser:*
    `*portrait*` *(left) and* `*landscape*` *(right)*'
  prefs: []
  type: TYPE_NORMAL
- en: As only two values are possible for the `orientation` feature, if you apply
    differentiating rules using one value, then the other tacitly becomes the opposite.
    In this example, I only used the `portrait` value, so, by default, all of the
    rules outside of that function apply to the `landscape` orientation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Aspect Ratio***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also create queries that apply when a certain width-to-height ratio
    is met. Use `aspect-ratio` to test the browser’s aspect ratio or `device-aspect-ratio`
    to test the device’s aspect ratio. Here is the syntax for these two features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `*horizontal*` and `*vertical*` values are positive integers that represent
    the ratio of the width and height (respectively) of the viewing device’s screen,
    so a square display would be 1/1 and a cinematic widescreen display would be 16/9.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some devices—notably the iPhone—always report the aspect ratio of the device
    in portrait orientation, even when being viewed in landscape.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting by aspect ratio is potentially fraught with caveats. For example,
    some device manufacturers define widescreen as 16/9, some as 16/10, and others
    as 15/10\. And a device may not have the exact stated aspect ratio; the iPhone
    5S, for example, claims to have a 16/9 aspect ratio but actually reports as having
    the slightly larger 40/71 ratio (the portrait orientation). Using the `max-` and
    `min-` variations of `aspect-ratio` and `device-aspect-ratio` to apply the rules
    may be preferable. Consider this code in which the rules in the query are applied
    to any element that has an aspect ratio of greater than 16/9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Multiple Media Features**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can chain multiple queries together on the same media type by adding expressions
    with the `and` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax tests that both expressions are matched before applying the selected
    rules. For example, to test for a narrow screen on a device with an aspect ratio
    no greater than 15/10, you use this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a conditional “or” expression by adding extra queries in a
    comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This applies rules when any of the stated cases is true; in the following example,
    the rules are applied to a screen in landscape orientation or to a printed document
    in portrait orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can also, of course, create any combination of these syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile-First Web Development**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The common best-practice method of building websites today uses a method known
    as *mobile-first development*, where we start developing for smaller screens before
    adding larger assets and more complexity for users accessing the site on larger
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason this method was adopted is because of the way that some browsers
    load page assets, such as images, that are included in style sheets. Problems
    arose because some early adopters of media queries would, for example, apply large
    background images to elements and then write rules to hide them from mobile devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: But those background images, despite being hidden, were still downloaded by
    the browser and held in the cache even though they weren’t displayed. This method
    increases the page’s load time and consumes bandwidth allowances—neither of which
    is good for mobile device users without wireless connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mobile-first way to create your pages is to first make a basic style sheet,
    which is applied to all browsers, including mobile, and to then progressively
    add assets and features for users with larger screens, loaded using a media query
    with the `min-width` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This change means the background image in question never gets loaded on devices
    with smaller screens. This approach can be extrapolated to loading entire style
    sheets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the style sheets are separated in this way, some browsers will optimize
    the way the style sheets are loaded; in Chrome, for example, as the file *desktop.css*
    doesn’t apply to devices with a screen width of less than 600px, its loading is
    delayed until after more high-priority assets have been downloaded—a quite useful
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: This mobile-first approach works for the great majority of browsers from the
    past few years; any really old browsers will get the basic style sheet instead,
    which is probably better for them as they won’t be able to cope with the advanced
    features I’ll be teaching you throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Their syntax may be simple, but media queries have the capacity to be extraordinarily
    powerful. With the mobile web explosion of recent years, designers and developers
    are beginning to realize they have the power to tailor their content to the user
    without employing the old techniques of browser sniffing or separate (and completely
    different) mobile versions of their sites.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of the responsive web design movement in the past few years has been
    fueled by the power of media queries, and in just a short space of time, they’ve
    become one of the most powerful tools at a web developer’s disposal. With careful
    consideration and clever use of media queries, you can create websites that scale
    perfectly for users, however they access the Web.
  prefs: []
  type: TYPE_NORMAL
- en: '**Media Queries: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| Media queries | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
