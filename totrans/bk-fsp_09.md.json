["```\n// C#\npublic class PropertyChangedExample\n  : INotifyPropertyChanged\n{\n  public event PropertyChangedEventHandler PropertyChanged;\n\n  private string _myProperty = String.Empty;\n\n  public string MyProperty\n  {\n    get { return _myProperty; }\n    set\n    {\n      _myProperty = value;\n      RaisePropertyChangedEvent(①() => MyProperty);\n    }\n  }\n\n  protected void RaisePropertyChangedEvent<TValue>(\n    ② Expression<Func<TValue>> propertyExpr)\n  {\n   if(PropertyChanged == null) return;\n\n   var memberExpr = ③(MemberExpression)propertyExpr.Body;\n   var ea = new PropertyChangedEventArgs(④ memberExpr.Member.Name);\n\n   PropertyChanged(this, ea);\n  }\n}\n```", "```\n// F#\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\nopen System.ComponentModel\n\ntype PropertyChangedExample() as x =\n  let pce = Event<_, _>()\n  let mutable _myProperty = \"\"\n① let triggerPce =\n    function\n    | ② PropertyGet(_, pi, _) ->\n        let ea = PropertyChangedEventArgs(pi.Name)\n        pce.Trigger(x, ea)\n    | _ -> failwith \"PropertyGet quotation is required\"\n  interface INotifyPropertyChanged with\n    [<CLIEvent>]\n    member x.PropertyChanged = pce.Publish\n  member x.MyProperty with get() = _myProperty\n                      and set(value) = _myProperty <- value\n                                       triggerPce(③ <@@ x.MyProperty @@>)\n```", "```\n> **open Microsoft.FSharp.Quotations**\n**let x, y = 10, 10**\n**let expr = <@ x * y @>;;**\n\nval x : int = 10\nval y : int = 10\nval expr : ① Expr<int> =\n  Call (None, op_Multiply, [PropertyGet (None, x, []), PropertyGet (None, y, [])])\n```", "```\n> **open Microsoft.FSharp.Quotations**\n**let expr = <@ fun a b -> a * b @>;;**\n\nval expr : Expr<(int -> int -> int)> =\n  Lambda (a, Lambda (b, Call (None, op_Multiply, [a, b])))\n```", "```\n> **let expr = <@ let mult x y = x * y**\n                 **mult 10 20 @>;;**\n\nval expr : Quotations.Expr<int> =\n  Let (mult, Lambda (x, Lambda (y, Call (None, op_Multiply, [x, y]))),\n     Application (Application (mult, Value (10)), Value (20)))\n```", "```\ntype Calc =\n  [<ReflectedDefinition>]\n  static member Multiply x y = x * y\n```", "```\n> **let expr =**\n  **typeof<Calc>**\n    **.GetMethod(\"Multiply\")**\n  **|> Expr.TryGetReflectedDefinition;;**\n\nval expr : Expr option =\n  Some Lambda (x, Lambda (y, Call (None, op_Multiply, [x, y])))\n```", "```\nlet operators =\n  System.Type.GetType(\"Microsoft.FSharp.Core.Operators, FSharp.Core\")\n```", "```\nlet multiplyOperator = operators.GetMethod(\"op_Multiply\")\n```", "```\nlet varX, varY =\n  multiplyOperator.GetParameters()\n  |> Array.map (fun p -> Var(p.Name, p.ParameterType))\n  |> (function | [| x; y |] -> x, y\n               | _ -> failwith \"not supported\")\n```", "```\nlet call = Expr.Call(multiplyOperator, [ Expr.Var(varX); Expr.Var(varY) ])\nlet innerLambda = Expr.Lambda(varY, call)\nlet outerLambda = Expr.Lambda(varX, innerLambda)\n```", "```\nval outerLambda : Expr =\n  Lambda (x, Lambda (y, Call (None, op_Multiply, [x, y])))\n```", "```\n<@@ fun x y -> x * y @@>\n```", "```\nlet operators =\n  System.Type.GetType(\"Microsoft.FSharp.Core.Operators, FSharp.Core\")\nlet multiplyOperator = operators.GetMethod(\"op_Multiply\")\nlet varX, varY =\n  multiplyOperator.GetParameters()\n  |> Array.map (fun p -> Var(p.Name, p.ParameterType))\n  |> (function | [| x; y |] -> x, y\n               | _ -> failwith \"not supported\")\n\nlet call = Expr.Call(multiplyOperator, [ Expr.Var(varX); Expr.Var(varY) ])\nlet innerLambda = Expr.Lambda(varY, call)\nlet outerLambda = Expr.Lambda(varX, innerLambda)\n```", "```\nlet numbers = seq { 1..10 }\nlet sum = <@ Seq.sum numbers @>\nlet count = <@ Seq.length numbers @>\n```", "```\nlet avgExpr = <@ %sum / %count @>\n```", "```\nlet avgExpr = <@@ %%sum / %%count @@>\n```", "```\nopen System.Text\nopen Microsoft.FSharp.Quotations.Patterns\nopen Microsoft.FSharp.Quotations.DerivedPatterns\nopen Microsoft.FSharp.Quotations.ExprShape\n\nlet rec showSyntax =\n  function\n  | Int32 v ->\n      sprintf \"%i\" v\n  | Value (v, _) ->\n      sprintf \"%s\" (v.ToString())\n  | SpecificCall <@@ (+) @@> (_, _, exprs) ->\n      let left = showSyntax exprs.Head\n      let right = showSyntax exprs.Tail.Head\n      sprintf \"%s + %s\" left right\n  | SpecificCall <@@ (-) @@> (_, _, exprs) ->\n      let left = showSyntax exprs.Head\n      let right = showSyntax exprs.Tail.Head\n      sprintf \"%s - %s\" left right\n  | Call (opt, mi, exprs) ->\n      let owner = match opt with\n                  | Some expr -> showSyntax expr\n                  | None -> sprintf \"%s\" mi.DeclaringType.Name\n      if exprs.IsEmpty then\n        sprintf \"%s.%s ()\" owner mi.Name\n      else\n        let sb = StringBuilder(showSyntax exprs.Head)\n        exprs.Tail\n        |> List.iter (fun expr ->\n                           sb\n                             .Append(\",\")\n                             .Append(showSyntax expr) |> ignore)\n        sprintf \"%s.%s (%s)\" owner mi.Name (sb.ToString())\n  | ShapeVar var ->\n      sprintf \"%A\" var\n  | ShapeLambda (p, body) ->\n      sprintf \"fun %s -> %s\" p.Name (showSyntax body)\n  | ShapeCombination (o, exprs) ->\n      let sb = StringBuilder()\n      exprs |> List.iter (fun expr -> sb.Append(showSyntax expr) |> ignore)\n      sb.ToString()\n```", "```\n> **showSyntax <@ fun x y -> x + y @>;;**\nval it : string = \"fun x -> fun y -> x + y\"\n> **showSyntax <@ fun x y -> x - y @>;;**\nval it : string = \"fun x -> fun y -> x - y\"\n> **showSyntax <@ 10 * 20 @>;;**\nval it : string = \"Operators.op_Multiply (10,20)\"\n> **showSyntax <@@ System.Math.Max(10, 20) @@>;;**\nval it : string = \"Math.Max (10,20)\"\n```", "```\nmodule Validation =\n  open System\n  open Microsoft.FSharp.Quotations\n  open Microsoft.FSharp.Quotations.Patterns\n\n  type Test<'e> = | Test of ('e -> (string * string) option)\n\n  ① let private add (quote : Expr<'x>) message args validate (xs : Test<'e> list) =\n    let propName, eval =\n      match quote with\n      | PropertyGet (_, p, _) -> p.Name, fun x -> p.GetValue(x, [||])\n      | Value (_, ty) when ty = typeof<'e> -> \"x\", box\n      | _ -> failwith \"Unsupported expression\"\n    let test entity =\n      let value = eval entity\n      if validate (unbox value) then None\n      else Some (propName, String.Format(message, Array.ofList (value :: args)))\n    Test(test) :: xs\n\n  ② let notNull quote =\n    let validator = (fun v -> v <> null)\n    add quote \"Is a required field\" [] validator\n\n  ③ let notEmpty quote =\n    add quote \"Cannot be empty\" [] (String.IsNullOrWhiteSpace >> not)\n\n  ④ let between quote min max =\n    let validator = (fun v -> v >= min && v <= max)\n    add quote \"Must be at least {2} and greater than {1}\" [min; max] validator\n\n  ⑤ let createValidator (f : 'e -> Test<'e> list -> Test<'e> list) =\n    let entries = f Unchecked.defaultof<_> []\n    fun entity -> List.choose (fun (Test test) -> test entity) entries\n```", "```\nopen Validation\ntype TestType = { ObjectValue : obj\n                  StringValue : string\n                  IntValue : int }\n```", "```\nlet validate =\n  createValidator <| fun x -> notNull <@ x.ObjectValue @> >>\n                              notEmpty <@ x.StringValue @> >>\n                              between <@ x.IntValue @> 1 100\n```", "```\n> **{ ObjectValue = obj(); StringValue = \"Sample\"; IntValue = 35 }**\n**|> validate;;**\nval it : (string * string) list = []\n```", "```\n> **{ ObjectValue = null; StringValue = \"\"; IntValue = 1000 }**\n**|> validate;;**\nval it : (string * string) list =\n  [(\"IntValue\", \"Must be at least 100 and greater than 1\");\n   (\"StringValue\", \"Cannot be empty\"); (\"ObjectValue\", \"Is a required field\")]\n```"]