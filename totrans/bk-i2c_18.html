<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_299" title="299"/>14</span><br/>&#13;
<span class="ChapterTitle">The ADS1015 and ADS1115 Analog-to-Digital Converters</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Although digital I/O is probably the most popular form of input/output on embedded computer systems, analog input is also popular. Converting a real-world analog signal (typically a voltage in the range 0 V to 3.3 V or 5 V) to numeric (digital) form allows an application to use real-world continuous measurements rather than the simple on or off from a digital input device. To perform such conversions, you’ll need an ADC.</p>&#13;
<p>Many types of ADCs are available. The vast majority of them convert an input voltage to an <em>n</em>-bit number, though some convert other physical measurements into numeric form. For the most part, real-world sensors produce a voltage output rather than producing a digital number directly. You would use an ADC to convert this voltage level to a digital value. Therefore, to read common sensor outputs, an ADC is a critical item in your toolbox. </p>&#13;
<p><span epub:type="pagebreak" id="Page_300" title="300"/>This chapter discusses two popular ADCs: the ADS1015 and the ADS1115. Both devices convert voltages between 0.0 V and some upper bound (such as 4.095 V) into numeric form: the ADS1015 produces a 12-bit result, and the ADS1115 produces a 16-bit result. The ADS1015 is faster, supporting 3,300 samples per second versus the ADS1115 at 860 samples per second (a classic trade-off of bits for speed). Although other I<sup>2</sup>C ADCs are available, the ADS1<em>x</em>15 devices are popular because Adafruit has created a pair of breakout boards that support these two ICs. The original Adafruit designs were open hardware, and over time, low-cost clones of these boards have appeared on Amazon and other places. These devices are easy to interface to any system that has an I<sup>2</sup>C bus. Adafruit, for example, provides library code for Arduino and Raspberry Pi systems, though it’s easy enough to interface these devices to any RTOS or system. However, the purpose of this book is to teach you how to directly program I<sup>2</sup>C peripherals, so the next section provides the necessary background information on the ADS1<em>x</em>15 so you can program it.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	This chapter typically uses a Teensy 3.2 for testing purposes. The reported timing values may vary from numbers you get if you’re using an Arduino Uno Rev3 or other Arduino-compatible SBC.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-502468c14-0001">	14.1	Analog-to-Digital Converter Specifications</h2>&#13;
<p class="BodyFirst">ADCs have several important specifications that affect their use. <a href="#table14-1" id="tableanchor14-1">Table 14-1</a> lists some of the more common specifications.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-1">Table 14-1</a>: Typical ADC Features</p></figcaption>&#13;
<table border="1" id="table-502468c14-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Feature</b></td>&#13;
<td><b>Units</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Resolution</td>&#13;
<td>Bits</td>&#13;
<td>The size of the integer value produced by the conversion</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Channels</td>&#13;
<td>Integer</td>&#13;
<td>Number of independent converters available on the device</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Polarity</td>&#13;
<td>Unipolar or bipolar</td>&#13;
<td>Determines whether an ADC supports negative voltages (bipolar or differential)<sup class="FootnoteReference"><a href="#c14-footnote-001" id="c14-footnoteref-001">*</a></sup> or only non-negative voltages (unipolar)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Range</td>&#13;
<td>Volts</td>&#13;
<td>Supported voltage range for inputs to the ADC</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Input type</td>&#13;
<td>Differential or single-ended</td>&#13;
<td>Specifies whether the input(s) are differential or single-ended (common ground)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Sample frequency</td>&#13;
<td>Hz</td>&#13;
<td>Number of readings per second the ADC is capable of making (also known as <em>samples per second</em> or <em>sps</em>)</td>&#13;
</tr>&#13;
<tr>&#13;
<td colspan="3">&#13;
<p class="TableFootnote"><sup class="FootnoteReference"><a href="#c14-footnoteref-001" id="c14-footnote-001">*</a></sup>The ADS1<em>x</em>15 devices do not accept actual negative voltages; rather, they accept a differential input where the difference between two positive voltage inputs is negative. See the discussion of differential inputs in section 14.1.5, “Differential vs. Single-Ended Modes,” later in this chapter.</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The following subsections will describe each of these items and discuss the actual ADC1<em>x</em>15 specifications.</p>&#13;
<h3 id="h2-502468c14-0001"><span epub:type="pagebreak" id="Page_301" title="301"/>14.1.1	Analog-to-Digital Converter Resolution</h3>&#13;
<p class="BodyFirst">The resolution of an ADC is the number of bits the ADC produces for a conversion. Low-end ADCs have an 8- or 10-bit resolution (10 bits is typical for the analog pins on a typical Arduino-class SBC), while mid-range ADCs commonly have 12-, 14-, or 16-bit resolution. Higher-end ADCs support 20- or 24-bit resolution. For differential inputs, the ADS1015 device provides a 12-bit resolution, and the ADC1115 provides 16 bits of resolution. For single-ended applications on either device, you lose a bit (see section 14.1.5, “Differential vs. Single-Ended Modes,” for more details on differential versus single-ended mode).</p>&#13;
<p>The resolution determines the smallest difference between two voltages an ADC can detect. For example, in full-scale mode both the ADS1015 and ADS1115 ADCs support voltages in the range of 0 V to 4.095 V. The resolution of the device divides this range by the maximum value. A 12-bit resolution divides the input range into 4,096 steps, so in theory, the ADS1015 is capable of resolving a difference of 0.001 V. The ADS1115, being a 16-bit converter, breaks up the input range into 65,536 steps. In theory, it’s capable of resolving a difference of 0.0000625 V—substantially better. The single-ended inputs have 11-bit and 15-bit resolution, respectively, producing 0.002-V and 0.000125-V steps.</p>&#13;
<p>As a general rule, more is better when it comes to ADC resolution. The higher the resolution, the more accurate the reading will be. However, extra resolution comes at a cost: all other things equal, higher-resolution ADCs are generally more expensive and slower than lower-resolution ADCs. Using a higher-resolution ADC also does not guarantee that you’ll get more precise readings. System noise and other effects may render the extra resolution meaningless in actual applications. For most typical SBC applications, 12 bits are sufficient. The presence of 0.0001 V of noise often completely obliterates the small readings possible with a 16-bit ADC.</p>&#13;
<h3 id="h2-502468c14-0002">14.1.2	Analog-to-Digital Converter Channel Count</h3>&#13;
<p class="BodyFirst">Many ADC devices provide multiple analog inputs. This allows you to connect several analog sources to a single ADC device, thus reducing the count and cost of parts. The ADS1015 and ADS1115 devices, for example, provide four input channels. ADS1013, ADS1113, ADS1014, and ADS1114 devices provide fewer inputs.</p>&#13;
<p>Having multiple input channels does not imply that the device has multiple ADCs on board. Instead, most multichannel ADCs have an analog multiplexer, a switch that connects a single input to the ADC at a time. This is an important distinction: if you have multiple ADCs, they can all convert an input from analog to digital concurrently, but a multiplexer switches between inputs, allowing only one conversion at a time. The ADS1015 and ADS1115 use internal multiplexers to feed a single ADC, so they must perform analog-to-digital conversions for each channel serially.</p>&#13;
<h3 id="h2-502468c14-0003"><span epub:type="pagebreak" id="Page_302" title="302"/>14.1.3	Analog-to-Digital Converter Polarity</h3>&#13;
<p class="BodyFirst">ADCs can be unipolar or bipolar. <em>Unipolar</em> ADCs can convert only non-negative voltages to digital form. This is typical of the ADC found on common SBCs; for example, Arduino-class SBCs typically convert voltages in the range of 0 V to 3.3 V or 5 V. Unipolar ADCs cannot handle negative voltages—in fact, a negative input voltage might damage the device. Bipolar ADCs can handle positive and negative input voltages.</p>&#13;
<p><em>Bipolar</em> ADCs are usually programmable to operate as a bipolar or unipolar device. The reason for operating a bipolar device in unipolar mode is resolution. Being able to handle positive and negative voltages eats up a bit of resolution. For example, if you operate a 16-bit ADC in bipolar mode, you get a 15-bit range for the negative voltages and a 15-bit range for the positive voltages. If you feed the device only positive voltages, you lose a bit of resolution. However, if you program the device for unipolar operation, you get the full 16 bits of resolution, allowing you to resolve smaller positive voltages.</p>&#13;
<p>The ADS1<em>x</em>15 devices aren’t true bipolar ADCs. Pin input voltages must always be positive with respect to ground. See section 14.1.5, “Differential vs. Single-Ended Modes,” for details on how the ADS1<em>x</em>15 handle negative inputs.</p>&#13;
<h3 id="h2-502468c14-0004">14.1.4	Analog-to-Digital Converter Range</h3>&#13;
<p class="BodyFirst"><em>ADC range</em> is the range of minimum and maximum voltages an ADC can handle. For example, a typical Arduino-class ADC will handle a range of 0 V to 3.3 V or 0 V to 5 V. Other common ADCs can handle 3.3 V, 4.095 V, 5 V, or 10 V.</p>&#13;
<p>A given ADC might have two different range specifications. One is the span of voltages over which the ADC will produce distinct readings—for example, 0 V to 5 V. The other range is the maximum permissible voltage the inputs will accept without damaging the device, which might be –0.5 V to 5.5 V for a typical ADC that supports a normal range of 0 V to 5 V. Generally, though, when discussing the range of an ADC, I’m talking about the range of inputs that produce distinct readings. Voltages outside this range but still within the maximum permissible range tend to clip their readings to the minimum or maximum values.</p>&#13;
<p>Unipolar devices almost always have a range from 0 V to some maximum voltage <em>n</em> V. Bipolar devices typically have a range that is ±<em>n </em>V (<em>n</em> is typically some value such as 3.3 V, 5 V, or 10 V).</p>&#13;
<p>The ADS1015 and ADS1115 are unipolar in single-ended mode and bipolar in differential mode (see the next section for a discussion of differential versus single-ended operation). They have a programmable gain stage that limits the range to ±5 V (actually 6.144 V, though the pins are limited to 5-V inputs), ±4.095 V, ±2.047 V, ±1.023 V, ±0.511 V, or ±0.255 V in differential/bipolar mode. For single-ended/unipolar mode, cut the range in half with a minimum voltage of 0 V.</p>&#13;
<h3 id="h2-502468c14-0005"><span epub:type="pagebreak" id="Page_303" title="303"/>14.1.5	Differential vs. Single-Ended Modes </h3>&#13;
<p class="BodyFirst">ADCs commonly operate in one of two modes: differential or single-ended. Single-ended inputs are easier to wire, less complex, and compatible with just about any voltage source. Differential inputs may require special differential driver voltage sources and are therefore more complex to use.</p>&#13;
<p>In <em>single-ended mode</em>, the ADC has a single input with a common ground (for all channels, if the ADC supports multiple input channels). Most Arduino-class analog inputs fall into this category, with the conversion measuring the voltage between the A<em>n</em> analog input pin and the common-to-all-analog-inputs analog ground pin.</p>&#13;
<p>In <em>differential mode</em>, an ADC conversion takes two inputs, generally labeled + and –, and computes the difference between the voltages on those inputs. It then converts this difference to digital form. Differential inputs are generally fed from <em>differential line drivers</em>, which typically put one half of a single-ended voltage on the + output and negative one half of that voltage on the – output. Measuring the voltage between the + and – lines gives you the original input voltage.</p>&#13;
<p>The main advantage to using differential inputs is that they reduce noise induced by the system. A voltage spike (noise) in the system is often summed onto input signal lines, such as the inputs to an ADC. On a single-ended input, that noise spike might produce a temporary increase or decrease of the input voltage, resulting in a momentary deviant reading from the ADC. That noise spike induces the same temporary voltage change on a set of differential inputs. However, the spike produces roughly the same increase or decrease on both of the differential inputs. When the differential input computes the difference between the two inputs, any value added to or subtracted from both differential inputs is eliminated from the conversion because the value added to the + line matches the value added to the – line. This means differential inputs are much less noisy than single-ended inputs, so you should use them whenever possible when working with high-resolution (16-bit or higher) ADCs.</p>&#13;
<p>There are two problems with differential inputs. First, most multichannel ADCs that support differential inputs use one channel for the + input and a second input channel for the – output. Therefore, using differential inputs cuts the number of available ADC channels in half. Differential inputs also require the added expense and complexity of special differential driver circuitry to convert a standard voltage (single-ended input) to differential form. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	It’s technically possible to feed a single-ended input to the + input and connect the – input to Gnd, but if you do so, you’ll lose many of the benefits of using a differential circuit.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The ADS1<em>x</em>15 devices are programmable to operate in single-ended or differential mode. Differential mode uses two input channels for each differential input, so you wind up with two differential inputs per device <span epub:type="pagebreak" id="Page_304" title="304"/>(rather than four single-ended input channels). Nevertheless, if you’re using an ADS1115 with 16-bit precision, you really should operate it in differential mode to take advantage of that extra precision and not swamp the LO bits of the reading in noise.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	The ADS1x15 devices also support three differential inputs where AN0, AN1, and AN2 all share the same (–) input (AN3).</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The ADS1<em>x</em>15 devices do not allow negative voltages on their input pins, which affect their differential performance. If your differential line driver converts the single-ended input voltage to a positive and negative voltage pair, that negative voltage could damage the ADS1<em>x</em>15. Instead, assuming you’re using the range of 0 V to 4.095 V, you must devise a differential driver circuit that puts out 2.047 V on both pins when you want a zero reading. It drives the + pin above 2.047 V and the – pin below 2.047 V for positive readings; for negative readings, it drives the + pin below 2.047 V and the – pin above 2.047 V. The ADS1<em>x</em>15 produces the maximum (positive or negative) reading when 0 V is on one pin and 4.095 V is on the other. If you’re using one of the other voltage ranges on the ADS1<em>x</em>15, then substitute one half the maximum voltage for 2.047 V and the maximum voltage for 4.095 V in this description.</p>&#13;
<p>Also note that a range of 0 V to 4.095 V produces only a 15-bit result (0 V to 32,767 V). Although the ADS1115 allows only positive voltage on its input pins, it is a bipolar device and produces 16-bit signed integer conversions (–32,768 to +32,767). The ADS1115 produces negative outputs when the – input has a higher voltage than the + input. For example, if the + input is at 0 V and the – input is at 4.095 V, then the ADS1115 produces –32,768 for the conversion.</p>&#13;
<h3 id="h2-502468c14-0006">14.1.6	Sample Frequency</h3>&#13;
<p class="BodyFirst">Analog-to-digital conversion is not an instantaneous process. Some ADCs are relatively slow, while others are much speedier (and more expensive). Different ADCs also have different <em>sample frequencies</em>, or readings made per second.</p>&#13;
<p>An ADC’s sample frequency has a direct bearing on its applicability. The ADS1<em>x</em>15 devices are not particularly fast. The ADS1115 is capable of 860 samples per second (sps) at most; the ADS1015 is a little better, at 3,300 sps. The famous <em>Nyquest theorem</em> states that you must be able to sample an analog signal at least twice its highest frequency in order to create a reasonable digital waveform. This means that the ADS1115 is capable of digitizing up to 430-Hz waveforms, while the ADS1015 can capture 1,650-Hz waveforms. These devices definitely won’t allow you to capture digital audio, which requires at least a 40-kHz sample rate for 20-Hz to 20,000-Hz capture. Nevertheless, the ADS1<em>x</em>15 parts are perfectly acceptable for capturing slowly changing signals, like those from human-controlled potentiometers, thermocouples, resistive temperature detectors (RTDs), power supply measurement, light sensing circuitry, and so on.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_305" title="305"/><h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	If you’re interested in capturing digital audio, there are ADCs capable of 50 kHz to 200 kHz (and at 24-bit resolution) specifically intended for this purpose.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>In some respects, the ADS1<em>x</em>115’s slow sample speed isn’t a major problem—the I<sup>2</sup>C bus data transfers provide their own limit on how fast conversions can take place. However, these slow conversion rates can also impact the overall application performance, especially with Arduino single-thread code.</p>&#13;
<h3 id="h2-502468c14-0007">14.1.7	Miscellaneous ADS1<em>x</em>15 Features</h3>&#13;
<p class="BodyFirst">The ADS1<em>x</em>15 devices have the following unique built-in features:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">I<sup>2</sup>C bus speed</span>  The ADS1<em>x</em>15 devices fully support standard speed mode (100 kHz), fast mode (400 kHz), and high-speed mode (up to 3.4 MHz).</li>&#13;
<li><span class="RunInHead">General call support</span>  The ADS1<em>x</em>15 devices support the I<sup>2</sup>C general call-reset command, where the first byte is 00h and the second byte is 06h.</li>&#13;
<li><span class="RunInHead">Programmable gain amplifier</span>  The ADS1<em>x</em>15 devices feature a programmable gain amplifier (PGA), which allows you to set the gain to one of six different levels. The gain is selected by 3 bits in the configuration register using the values appearing in <a href="#table14-5" id="tableanchor14-5">Table 14-5</a> in section 14.3.2.3, “Programmable Gain Amplifier Control Bits.” See section 14.3, “ADS1<em>x</em>15 Analog-to-Digital Converter Registers,” for information about programming the configuration register gain settings. </li>&#13;
<li><span class="RunInHead">Programmable comparator</span>  The ADS1<em>x</em>15 devices provide two 16-bit comparator registers that automatically compare the current conversion against a low threshold value and a high threshold value. When active, the IC will assert the ALRT pin whenever the conversion value is less than the low or higher than the high threshold value (“windowed” mode) or whenever the conversion value is greater than the high threshold value (“traditional” mode).</li>&#13;
<li><span class="RunInHead">Continuous (one-shot) mode</span>  The ADS1<em>x</em>15 devices can be programmed to constantly perform ADC conversions or operate in a <em>one-shot mode</em> where they perform a conversion only in response to a command over the I<sup>2</sup>C bus.</li>&#13;
</ol>&#13;
<h2 id="h1-502468c14-0002">	14.2	Analog Conditioning</h2>&#13;
<p class="BodyFirst">ADC input ranges are often different from the signals you obtain in the real world. A range of 0 V to 5 V is common, both as an input to an ADC and as a single voltage in the real world. However, ADC ranges and input signals don’t often match. The ADS1<em>x</em>15 ADCs are a good example; in their full resolution mode, they support an input range of only 0 V to 4.095 V, something you rarely see in real life.</p>&#13;
<p><span epub:type="pagebreak" id="Page_306" title="306"/>The most common voltage ranges of industrial equipment output are probably 0 V to 5 V, ±5 V, 0 V to 10 V, or ±10 V. While some ADCs, such as the LTC1859 series, support these ranges, you will often need to translate the signal you have to a signal your ADC will accept. This—along with other activities such as converting currents to voltages—is known as <em>analog conditioning</em> (or <em>signal conditioning</em>). </p>&#13;
<p><a href="#figure14-1" id="figureanchor14-1">Figure 14-1</a> shows a schematic for an opamp circuit that provides two functions: signal amplification or reduction, and conversion from single-ended input to differential output. The top half of the figure (opamps at pins 1, 2, and 3, and 5, 6, and 7) is an amplifier circuit that will take a voltage in the range of ±10 V and translate it to some other voltage in the range of ±10 V. Two potentiometers, ZERO and SPAN, control the offset and gain of the amplifier. The ZERO (offset) pot adds a voltage in the range of –10 V to +10 V to the input, while the SPAN (gain) pot adjusts the amplification (gain) from around 0.05 to about 20, with a limit of ±10 V on the output.</p>&#13;
<figure>&#13;
<img alt="" class="" height="658" src="image_fi/502468c14/f14001.png" width="735"/>&#13;
<figcaption><p><a id="figure14-1">Figure 14-1</a>: Amplifier and differential driver for ADS1<em>x</em>115</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_307" title="307"/>The bottom half of the circuit takes the output from the amplification stage and converts it to a differential signal. The top opamp in this differential driver is a noninverting amplifier with a gain of one, which simply outputs its input voltage as the + differential output. The bottom opamp in this circuit is an inverting amplifier, also with a gain of one (0 dB). If the VREF pot is set to 0 V (middle position), this amplifier inverts the input. Therefore, this circuit will produce the positive output from the top half of the circuit on the + output and the negative output from the top half of the circuit on the – output. Overall, this circuit has a gain of two (6 dB) because the difference between the + and – outputs is actually twice the output from the top half of the circuit. Correct for this by reducing the gain in the top amplifier circuit.</p>&#13;
<p>Some comments about the quality of the parts in the <a href="#figure14-1">Figure 14-1</a> circuit are in order, because sticking inexpensive components into this circuit may produce less-than-desirable results.</p>&#13;
<p>First, if you care about long-term stability and lack of drift, you will want to use instrumentation-quality OPA4227 or OPA2227 opamps. These aren’t cheap, but they are very good. If you don’t mind recalibrating the circuit on a regular basis, you can use cheaper (jellybean) LM324 opamps.</p>&#13;
<p>Using high-precision, low-TCR resistors in this circuit will also help to ensure long-term stability and lack of drift. In particular, the 10-kΩ and 1-kΩ resistors should be 0.1 percent 15 PPM/C resistors, which I’ve found for less than $0.50 each in batches of 100 (at the time this was written). The 20-kΩ pots should be 10 percent and 50 PPM/C or less; these are not at all cheap, typically $15 to $20 each. If you don’t mind recalibrating the circuit on a regular basis, you can use cheap resistors and pots—it’s safer to use lower-TCR pots if you need to save money. </p>&#13;
<p>The two 1-kΩ resistors in this circuit are optional. They are there to prevent the gain from going crazy as the SPAN pot approaches one end or the other. Larger values like 4.7 kΩ will make gain adjustments smoother, at the expense of a more limited gain range. If you pick different resistors, make sure they are low-TCR (PPM/C) resistors. The precision isn’t as important because of the pot, but it’s usually going to be 0.1 percent for reasonably priced, low-TCR resistors. </p>&#13;
<p>The circuit’s 27-Ω resistors are also optional and exist just to prevent a complete meltdown if the opamp outputs are shorted. If you decide to install these resistors, use 1-percent, metal-film resistors. The 390-Ω resistor can also be a 1-percent, metal-film resistor; it’s not that important to the circuit. </p>&#13;
<p>Finally, if you are using single-ended inputs on your ADC, you can drop the bottom half of the circuit and feed the output from pin 1 on the OPA4227 directly into the ADC. Of course, given the cost, you should probably substitute an OPA2227 dual opamp in place of the OPA4277 quad opamp if you do this.</p>&#13;
<p>Before using this circuit, you will need to calibrate it. The following steps describe the calibration for an ADS1<em>x</em>15 ADC device. You’ll need to modify this procedure by changing the output voltage the circuit produces <span epub:type="pagebreak" id="Page_308" title="308"/>when using a different ADC. <em>Do not connect this circuit to the ADS1</em>x<em>15 during calibration.</em> Doing so may damage the ADC.</p>&#13;
<ol class="decimal">&#13;
<li value="1">Try to put all the pots in approximately their middle position. The position doesn’t have to be accurate, but you want the pot wipers away from either end of the terminals.</li>&#13;
<li value="2">Put 0 V on the single-ended input and apply power to the circuit (±12 V).</li>&#13;
<li value="3">Measure the voltage on pin 7 of the OPA4277 and adjust the ZERO pot until the output is as close to zero as possible. </li>&#13;
<li value="4">Now, measure the voltage at pin 1 of the OPA4277 and, again, adjust the ZERO pot until the output voltage is as close to zero as possible.</li>&#13;
<li value="5">Change the input voltage to match the maximum voltage you’re going to allow (say, 5 V).</li>&#13;
<li value="6">Measuring the voltage on pin 1 of the OPA4277, adjust the SPAN pot until you get an output as close to 4.095 V as possible. This assumes you will be using an ADS1<em>x</em>15 programmed to accept 0 V to 4.095 V. If using a different ADC or an ADS1<em>x</em>15 programmed for a different range, adjust this number accordingly.</li>&#13;
<li value="7">Repeat steps 4 through 6 until you don’t have to make any changes to the ZERO or SPAN pots. Adjusting one may affect the other, so repeating this process fine-tunes the calibration.</li>&#13;
</ol>&#13;
<p>At this point, you’ve calibrated the amplifier stage. If you’re not using a differential output, you’re done; you can feed pin 1 on the OPA4277 to the ADC input. If you’re using a differential output, further adjustment is necessary. The following steps will warp the calibration of the amplification stage; that’s okay, since calibrating the amplifier in steps 1 through 7 just verifies the circuit is behaving properly before calibrating the differential driver.</p>&#13;
<ol class="decimal">&#13;
<li value="1">Measure the voltage on pin 10 of the OPA4277 and adjust the VREF pot to get the voltage as close to zero as possible.</li>&#13;
<li value="2">Apply 0 V to the single-ended input and measure the + differential output with respect to Gnd. You should see 0 V at this point. Otherwise, adjust the offset using the ZERO pot.</li>&#13;
<li value="3">While still applying 0 V to the single-ended input, measure the – differential output with respect to Gnd. You should see 0 V. Otherwise, adjust the offset using the VREF pot.</li>&#13;
<li value="4">Change the voltage on the single-ended input to the maximum value you expect (say, 5 V) and measure the + differential output with respect to Gnd. You should see 4.095 V at this point. Otherwise, adjust the gain using the SPAN pot.</li>&#13;
<li value="5">Repeat steps 2 through 4 until further adjustments are unnecessary. Ideally you’re seeing –4.095 V, or something very close, on the – differential output at step 11. If there is any major deviation (for example, more than 0.01 V), the 10-kΩ resistors in the differential driver circuit must have problems. </li>&#13;
</ol>&#13;
<p><span epub:type="pagebreak" id="Page_309" title="309"/>At this point, there are a couple of problems with the current calibration: first, it outputs negative voltages, which you cannot apply to an ADS1<em>x</em>15 input. Second, the gain is off by a factor of two. The following steps rectify that.</p>&#13;
<ol class="decimal">&#13;
<li value="1">Set the voltage on the single-ended input to your maximum voltage (for example, 5 V). Measure the voltage between the + and – terminals on the differential outputs; it should be about 8.191 V. Reduce the gain using the SPAN pot until the output voltage is 4.095 V.</li>&#13;
<li value="2">Set the voltage on the single-ended input to 0 V. Measure the voltage between the + differential output and Gnd. Adjust the ZERO pot until it reads +2.047 V.</li>&#13;
<li value="3">Set the voltage on the single-ended input to the maximum expected voltage (for example, 5 V). Measure the voltage between the + differential output and Gnd. Adjust the SPAN pot until the voltage is +4.095 V.</li>&#13;
<li value="4">Repeat steps 2 and 3 until no further adjustments are needed.</li>&#13;
<li value="5">Apply the maximum voltage to the single-ended input. Measure the voltage between the – differential output and ground; it should be somewhere near 0 V. Adjust the VREF pot until it’s as close as possible to 0 V.</li>&#13;
<li value="6">Repeat steps 2 through 5 until no further adjustments are necessary.</li>&#13;
</ol>&#13;
<p>At this point your circuit should be calibrated for use with an ADS1<em>x</em>15 operating in differential mode. You should be able to input ±5 to the single-ended input and, with appropriate software, read –32768 to +32,767 from the device.</p>&#13;
<h2 id="h1-502468c14-0003">	14.3	ADS1<em>x</em>15 Analog-to-Digital Converter Registers</h2>&#13;
<p class="BodyFirst">The ADS1<em>x</em>15 devices have five internal registers: the 8-bit pointer register (write only), the 16-bit conversion register (read only), the 16-bit configuration register (read/write), the 16-bit low threshold register, and the 16-bit high threshold register.</p>&#13;
<p>The LO 2 bits of the pointer register select one of the other four registers (00: conversion, 01: configuration, 10: low threshold, and 11: high threshold). The HO 6 bits of the pointer register value should always be 0. Pointer register selection always occurs after a start condition and an address byte with the LO bit equal to 0 (a write operation). The next byte after the address transmission is the pointer register value (see <a href="#figure14-2" id="figureanchor14-2">Figure 14-2</a>).</p>&#13;
<figure>&#13;
<img alt="" class="" height="55" src="image_fi/502468c14/f14002.png" width="423"/>&#13;
<figcaption><p><a id="figure14-2">Figure 14-2</a>: Pointer register value follows a write command</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_310" title="310"/>When writing to the configuration or threshold registers, you follow the sequence in <a href="#figure14-2">Figure 14-2</a> with the 2-byte value to write to the register specified by the <code>reg</code> bits. The HO byte of the 16-bit value follows the pointer register value, and the LO byte follows, usually with an ending stop condition. See <a href="#figure14-3" id="figureanchor14-3">Figure 14-3</a> for details.</p>&#13;
<figure>&#13;
<img alt="" class="" height="55" src="image_fi/502468c14/f14003.png" width="845"/>&#13;
<figcaption><p><a id="figure14-3">Figure 14-3</a>: Writing a value to a 16-bit register</p></figcaption>&#13;
</figure>&#13;
<p>Reading from a 16-bit register is slightly more complex than writing to the register, as it requires sending 2 address bytes—one with the write command and a pointer register value and one with a read command (with an intervening restart condition). <a href="#figure14-4" id="figureanchor14-4">Figure 14-4</a> shows the sequence needed to read 16 bits from a register. Note that the system must send a restart condition between the register pointer value and the second address, and that the second address has the LO bit set to 1 to indicate a read operation.</p>&#13;
<figure>&#13;
<img alt="" class="" height="104" src="image_fi/502468c14/f14004.png" width="846"/>&#13;
<figcaption><p><a id="figure14-4">Figure 14-4</a>: Reading a 16-bit register</p></figcaption>&#13;
</figure>&#13;
<p>The last 2 bytes of the sequence contain the 16-bit value read from the ADC. This consists of the HO byte followed by the LO byte.</p>&#13;
<h3 id="h2-502468c14-0008">14.3.1	The Conversion Register</h3>&#13;
<p class="BodyFirst">The conversion register (register pointer value 0) is a read-only register that holds the value of the last analog-to-digital conversion. This is a two’s complement signed binary integer in the range of –32768 to +32,767. On the ADS1015 device (which is only a 12-bit ADC), the LO 4 bits of this register always contain 0, meaning the range is actually –32,760 to +32759.</p>&#13;
<p>In continuous mode, the ADS1<em>x</em>15 automatically fills this register with the last conversion it makes. In one-shot mode, the ADS1<em>x</em>15 places the last requested conversion into this register. See section 14.3.2.5, <span class="xref" itemid="xref_target_“Operational Status Bit,”">“Operational Status Bit,”</span> later in this chapter for information about starting a conversion.</p>&#13;
<h3 id="h2-502468c14-0009">14.3.2	The Configuration Register</h3>&#13;
<p class="BodyFirst">Most of the activity required to perform an analog-to-digital conversion takes place in the configuration register (register pointer value 1). <a href="#table14-2" id="tableanchor14-2">Table 14-2</a> catalogs the meanings of the 16 bits in the configuration register.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-2">Table 14-2</a>: Configuration Register Bits<span epub:type="pagebreak" id="Page_311" title="311"/></p></figcaption>&#13;
<table border="1" id="table-502468c14-0002">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Read operation</b></td>&#13;
<td><b>Write operation</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>Read comparator queue state</td>&#13;
<td>00: assert ALRT after 1 conversion<br/>&#13;
01: assert ALRT after 2 conversions<br/>&#13;
10: assert ALRT after 4 conversions<br/>&#13;
11: disable comparator</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td>Read ALRT latch setting</td>&#13;
<td>0: non-latching ALRT; 1: latching ALRT</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td>Read ALRT pin polarity</td>&#13;
<td>0: active low ALRT; 1: active high ALRT</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td>Read comparator mode</td>&#13;
<td>Write mode. 0: traditional; 1: windowed</td>&#13;
</tr>&#13;
<tr>&#13;
<td>5</td>&#13;
<td>Read conversion rate</td>&#13;
<td>Set conversion rate (see details below)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>Read device mode</td>&#13;
<td>Set device mode. 1: one shot; 0: continuous</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>Read PGA setting</td>&#13;
<td>Set PGA value</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>11</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>12</td>&#13;
<td>Read mux selection</td>&#13;
<td>Write mux selection </td>&#13;
</tr>&#13;
<tr>&#13;
<td>13</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>14</td>&#13;
<td>Read input control</td>&#13;
<td>Set input control. 0: differential; 1: single-ended</td>&#13;
</tr>&#13;
<tr>&#13;
<td>15</td>&#13;
<td>0: device is busy doing a conversion; 1: device is ready</td>&#13;
<td>Writing a 1 to this location begins a conversion from power-down mode</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The following subsections go into more detail concerning these register configuration bits.</p>&#13;
<h4 id="h3-502468c14-0001">14.3.2.1	Comparator Control Bits</h4>&#13;
<p class="BodyFirst">Bits 0 through 4 in the configuration register control the operation of the comparator on the ADS1<em>x</em>15. These control whether the comparator is active, and they control the ALRT pin polarity and latch, and the type of comparator.</p>&#13;
<p>Bits 0 and 1 enable and disable the comparator and control the alert logic. If these bits are 0b11 (the default state on power-up/reset), then the comparator circuitry is disabled. If the comparator control bits are 0b00, 0b01, or 0b10, then the comparator will be enabled and assert the ALRT pin when the conversion value exceeds the threshold register range for one reading, two readings, or four readings, respectively. Increasing the number of readings before asserting ALRT helps filter out noise spikes.</p>&#13;
<p>Bit 2 in the configuration register controls the latching mode on the ALRT pin. In the default state (0), the ADS1<em>x</em>15 asserts the ALRT pin only <span epub:type="pagebreak" id="Page_312" title="312"/>while the last conversion exceeds the threshold range. Should the conversion value drop back below the low threshold range, the IC will deassert the ALRT pin. In the latching mode, once a conversion value is outside the threshold range (for the specified number of conversions), the ALRT pin is latched in the asserted condition. To clear the latch, you have to read the conversion register.</p>&#13;
<p>Bit 3 in the configuration register controls the ALRT pin polarity. A 0 in this bit position (default on power-up/reset) sets an active low signal; a 1 in this position sets an active high signal.</p>&#13;
<p>Bit 4 sets the traditional or window (range) comparator mode. In the traditional mode, the ADS1<em>x</em>15 compares the last conversion value against the high threshold register (with hysteresis, deasserting the ALRT pin when the input falls below the low threshold value). In the window (range) mode, it compares the last conversion value against the low and high threshold registers and generates an ALRT if the conversion is outside this range.</p>&#13;
<p>In addition to the comparator control bits, you also control the comparator using the low and high threshold registers. See the discussion of those registers in section 14.3.4, “The Low and High Threshold Registers,” for more details, especially concerning the definition of the ALRT pin as an alert or a ready function.</p>&#13;
<h4 id="h3-502468c14-0002">14.3.2.2	Device Mode Configuration Bit and Conversion Rate</h4>&#13;
<p class="BodyFirst">Bit 8 of the configuration register specifies whether the ADS1<em>x</em>15 operates in “one-shot” conversion mode (1, the default on power-up/reset) or in continuous conversion mode (0). In one-shot mode, the ADC will perform a conversion only in response to a command arriving over the I<sup>2</sup>C bus (writing a 1 to bit 15 of the configuration register). In continuous mode, the ADC begins a new conversion when the current one completes. Bits 5 through 7 determine the sample frequency. The ADS1015 sample frequencies appear in <a href="#table14-3" id="tableanchor14-3">Table 14-3</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-3">Table 14-3</a>: ADS1015 Sample Frequencies</p></figcaption>&#13;
<table border="1" id="table-502468c14-0003">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Configuration bits 5–7</b></td>&#13;
<td><b>Sample frequency</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>000</td>&#13;
<td>128 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>001</td>&#13;
<td>250 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>010</td>&#13;
<td>490 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>011</td>&#13;
<td>920 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>100</td>&#13;
<td>1600 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>101</td>&#13;
<td>2400 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>110</td>&#13;
<td>3300 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>111</td>&#13;
<td>3300 sps</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_313" title="313"/>The ADS1115 sample frequencies appear in <a href="#table14-4" id="tableanchor14-4">Table 14-4</a>. Note that the sample frequencies are different for the two ICs. </p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-4">Table 14-4</a>: ADS1115 Sample Frequencies</p></figcaption>&#13;
<table border="1" id="table-502468c14-0004">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Configuration bits 5–7</b></td>&#13;
<td><b>Sample frequency</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>000</td>&#13;
<td>8 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>001</td>&#13;
<td>16 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>010</td>&#13;
<td>32 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>011</td>&#13;
<td>64 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>100</td>&#13;
<td>128 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>101</td>&#13;
<td>250 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>110</td>&#13;
<td>475 sps</td>&#13;
</tr>&#13;
<tr>&#13;
<td>111</td>&#13;
<td>860 sps</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>If the ALRT pin is programmed as the “ready” signal, then the ADS1<em>x</em>15 will pulse the ALRT (or RDY) pin after each conversion when operating in continuous mode. When operating in one-shot mode, the ADS1<em>x</em>15 will assert the ALRT/RDY pin after the conversion is complete if the COMP_POL bit is set to 0. See section 14.3.3, <span class="xref" itemid="xref_target_“The Low and High Threshold Registers,”">“The Low and High Threshold Registers,”</span> later in this chapter for more on how to set the ALRT pin to act as the alert or ready signal.</p>&#13;
<h4 id="h3-502468c14-0003">14.3.2.3	Programmable Gain Amplifier Control Bits</h4>&#13;
<p class="BodyFirst">Bits 9 through 11 in the configuration register specify the gain to apply to the incoming analog signal. <a href="#table14-5">Table 14-5</a> lists the possible gain values and voltage ranges. </p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-5">Table 14-5</a>: Programmable Gain Amplifier</p></figcaption>&#13;
<table border="1" id="table-502468c14-0005">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Config settings</b></td>&#13;
<td><b>Gain</b></td>&#13;
<td><b>Input voltage range</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>000</td>&#13;
<td>2/3</td>&#13;
<td>±6.144 V</td>&#13;
</tr>&#13;
<tr>&#13;
<td>001</td>&#13;
<td>1</td>&#13;
<td>±4.095 V</td>&#13;
</tr>&#13;
<tr>&#13;
<td>010</td>&#13;
<td>2</td>&#13;
<td>±2.047 V</td>&#13;
</tr>&#13;
<tr>&#13;
<td>011</td>&#13;
<td>4</td>&#13;
<td>±1.023 V</td>&#13;
</tr>&#13;
<tr>&#13;
<td>100</td>&#13;
<td>8</td>&#13;
<td>±0.511 V</td>&#13;
</tr>&#13;
<tr>&#13;
<td>101, 110, 111</td>&#13;
<td>16</td>&#13;
<td>±0.255 V</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>In no case may the voltage ranges in <a href="#table14-5">Table 14-5</a> exceed Vdd. This means that if you select configuration value 0b000, the input voltage is still limited to 5 V (assuming Vdd is 5 V) even though the range is 0 V to 6.144 V. <span epub:type="pagebreak" id="Page_314" title="314"/>In this mode, the maximum value you will read from the conversion registers is about 26,666 rather than 32,767.</p>&#13;
<p>Additionally, voltages on input pins must never drop below 0 V. Negative values are valid for differential mode only when the + input is less than the – input; both inputs must be positive with respect to Gnd.</p>&#13;
<p>Keep in mind, when you look at <a href="#table14-5">Table 14-5</a>, that the voltage ranges are further limited by Vdd, regardless of the PGA setting. For example, if you’re running the ADS1<em>x</em>15 at 3.3 V and you’ve programmed the PGA with 0b001 (±4.095 V), the maximum voltage input will still be 3.3 V. This means that the readings will be in the range of –26399 to +26399, rather than the usual –32768 to +32767. </p>&#13;
<p>You’ll most often program the PGA just once (I most commonly use 0b001, for the ±4.095-V range). However, if you dynamically modify the PGA during operation—for example, to use a different gain setting for each input channel—this may affect the operation of the comparator circuitry. All input channels share the same analog-to-digital converter circuitry. If you set the comparator threshold(s) for one channel and then switch the input multiplexer to a different channel with a different gain, the comparator will trip at different voltages for the two channels. The moral of the story is that it’s generally best to use the same gain settings for all active input channels when working with the comparator circuit.</p>&#13;
<h4 id="h3-502468c14-0004">14.3.2.4	Multiplexer Control Bits</h4>&#13;
<p class="BodyFirst">Bits 12 through 13 in the configuration register select the input, and bit 14 controls differential or single-ended mode. If bit 14 is 0 (default on power-up/reset), the ADC operates in differential mode. If bit 14 is 1, the ADC operates in single-ended mode. </p>&#13;
<p>Bits 12 through 13 select an appropriate input, or pair of inputs, as shown in <a href="#table14-6" id="tableanchor14-6">Table 14-6</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-6">Table 14-6</a>: Input Multiplexer Selection</p></figcaption>&#13;
<table border="1" id="table-502468c14-0006">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Configuration</b><br/>&#13;
<b>bits 12 and 13</b></td>&#13;
<td colspan="2"><b>If bit 14 is 0 (differential mode)</b></td>&#13;
<td><b>If bit 14 is 1 (single-ended mode)</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td/>&#13;
<td><b>+ Terminal</b></td>&#13;
<td><b>– Terminal</b></td>&#13;
<td><b>+ Terminal (– terminal is Gnd)</b></td>&#13;
</tr>&#13;
<tr>&#13;
<td>00</td>&#13;
<td>A0</td>&#13;
<td>A1</td>&#13;
<td>A0</td>&#13;
</tr>&#13;
<tr>&#13;
<td>01</td>&#13;
<td>A0</td>&#13;
<td>A3</td>&#13;
<td>A1</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10</td>&#13;
<td>A1</td>&#13;
<td>A3</td>&#13;
<td>A2</td>&#13;
</tr>&#13;
<tr>&#13;
<td>11</td>&#13;
<td>A2</td>&#13;
<td>A3</td>&#13;
<td>A3</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The peculiar 0b01 and 0b10 settings in differential mode allow you to use up to three differential inputs, if the three inputs (A0, A1, and A2) all <span epub:type="pagebreak" id="Page_315" title="315"/>share the same – terminal. This usually isn’t the case, so differential inputs typically use 0b00 or 0b11 for bits 12 and 13. In single-ended mode (bit 14 = 1), bits 12 and 13 select one of the four single-ended input channels.</p>&#13;
<h4 id="h3-502468c14-0005">14.3.2.5	Operational Status Bit</h4>&#13;
<p class="BodyFirst">When reading the configuration register, bits 0 through 14 reflect the last values written to those bits. Bit 15, however, performs different duties on read and write operations.</p>&#13;
<p>Reading the configuration returns the current <em>ready</em> status in bit 15. If this bit returns 1, the ADS1<em>x</em>15 is not currently performing a conversion, so you can begin a new conversion. If bit 15 returns 0, the ADS1<em>x</em>15 is in the middle of a conversion, and you cannot begin another. Once you begin a conversion in one-shot mode, you can test this bit to determine when that conversion is complete. In continuous mode, you don’t really care, as the conversion register contains the value of the last conversion made.</p>&#13;
<p>To begin a conversion in one-shot mode, write a 1 to bit 15 in the conversion register. Keep in mind that you must also rewrite the other 15 configuration bits when writing to the configuration register. You typically set up a 16-bit value that defines how you want the conversion to proceed and set bit 15 equal to 1 (to begin the conversion). To write to the configuration register without beginning a new conversion, just put a 0 in bit 15.</p>&#13;
<p>Note that you can write a 1 to bit 15 only when operating in one-shot mode, which is also known as <em>power-down</em> mode. If the ADS1<em>x</em>15 is currently operating in continuous mode, you must first put it in one-shot mode by writing a 1 to bit 8. You can then programmatically start new conversions by writing a 1 to bit 15.</p>&#13;
<h3 id="h2-502468c14-0010">14.3.3	The Low and High Threshold Registers</h3>&#13;
<p class="BodyFirst">The ADS1<em>x</em>15 devices provide two 16-bit threshold registers, low (pointer register value is 0b10) and high (0b11). The ADS1115 allows you to write the full 16 bits to these registers. As the ADS1015 ADCs are 12-bit devices, you should always write 0s into the LO 4 bits of these registers.</p>&#13;
<p>When operating as a traditional comparator, the ADS1<em>x</em>15 compares the conversion register against the value in the high threshold register and asserts the ALRT pin if the conversion value is greater than the high threshold. The ADS1<em>x</em>15 uses the low threshold register to determine when to deassert the ALRT signal. When the input conversion value falls below the value in the low threshold, the ADS1<em>x</em>15 deasserts ALRT.</p>&#13;
<p>In window comparator mode (range mode), the ADS1<em>x</em>15 asserts the ALRT pin whenever the conversion value is below the low threshold register value or above the high threshold value. If you want to assert the pin while <span epub:type="pagebreak" id="Page_316" title="316"/>the conversion value is between the two thresholds, you can simply invert the ALRT pin using bit 3 of the configuration register.</p>&#13;
<p>In nonlatching mode (see section 14.3.2.1, “Comparator Control Bits,” earlier in this chapter), the ADS1<em>x</em>15 will automatically assert and deassert the ALRT pin as the conversion value goes in and out of range. In latching mode, once the IC asserts the ALRT pin, that pin stays active until the software reads the conversion register—that is, assuming the conversion value is back within range at that point.</p>&#13;
<p>The threshold registers provide one additional hidden feature: control of the ALRT pin. If the HO bit of the high threshold register is 1 and the HO bit of the low threshold register is 0, then the ADS1<em>x</em>15 outputs the ready condition (configuration register bit 15) on the ALRT pin (which should be called RDY in this configuration). Because the values in the threshold registers are two’s complement signed binary integers, this particular situation means that the value in the high threshold register is less than the value in the low threshold register. This is usually an illegal combination; except for this special case, the value in the high threshold must always be greater than the value in the low threshold register.</p>&#13;
<p>This concludes the discussion of the internal architecture of the ADS1<em>x</em>15 IC. To program it, however, you’ll need some actual hardware you can wire into a circuit containing a controlling CPU. Because of their size, you wouldn’t normally try to hook an ADS1<em>x</em>15 directly onto a breadboard. The next section describes the solution to this problem.</p>&#13;
<h2 id="h1-502468c14-0004">	14.4	The Adafruit ADS1<em>x</em>15 Breakout Boards</h2>&#13;
<p class="BodyFirst">The ADS1<em>x</em>15 ICs are tiny SMDs that are difficult for all but the most experienced of electronic technicians or circuit assembly houses to use. Adafruit solves this issue by putting the IC on a small PCB, a “breakout board” with a set of 0.1-inch headers that make it easy to use this IC as part of some other circuit. </p>&#13;
<p><a href="#figure14-5" id="figureanchor14-5">Figure 14-5</a> shows the Adafruit ADS1115 breakout board. For what it’s worth, the ADS1015 board is identical to the ADS1115 board, except for the silkscreen and the actual IC placed on the board.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	As Adafruit sells breakout boards for the ADS1015 and ADS1115 ADCs, it’s not surprising to find that they also provide library code for Arduino and Raspberry Pi systems. See “For More Information” for links to these libraries.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The ADS1015 and ADS1115 have identical pinouts consisting of 10 holes into which you’d normally solder a 1<span class="NSSymbol">×</span>10 pin header, as described in <a href="#table14-7" id="tableanchor14-7">Table 14-7</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_317" title="317"/><figure>&#13;
<img alt="" class="keyline" height="395" src="image_fi/502468c14/f14005.png" width="672"/>&#13;
<figcaption><p><a id="figure14-5">Figure 14-5</a>: The Adafruit ADS1115 breakout board</p></figcaption>&#13;
</figure>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-7">Table 14-7</a>: Adafruit ADS1<em>x</em>15 Pinout</p></figcaption>&#13;
<table border="1" id="table-502468c14-0007">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Pin (name)</b></td>&#13;
<td><b>Function</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Vdd</td>&#13;
<td>Power supply (2 V to 5 V)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Gnd</td>&#13;
<td>Digital and analog ground</td>&#13;
</tr>&#13;
<tr>&#13;
<td>SCL</td>&#13;
<td>I<sup>2</sup>C clock line</td>&#13;
</tr>&#13;
<tr>&#13;
<td>SDA</td>&#13;
<td>I<sup>2</sup>C data line</td>&#13;
</tr>&#13;
<tr>&#13;
<td>ADDR</td>&#13;
<td>Address selection line</td>&#13;
</tr>&#13;
<tr>&#13;
<td>ALRT</td>&#13;
<td>Alert (comparator out of range) or conversion complete</td>&#13;
</tr>&#13;
<tr>&#13;
<td>A0</td>&#13;
<td>Analog input channel 0 (+ differential input 0)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>A1</td>&#13;
<td>Analog input channel 1 (– differential input 0)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>A2</td>&#13;
<td>Analog input channel 2 (+ differential input 1)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>A3</td>&#13;
<td>Analog input channel 3 (– differential input 1)</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The Vdd, Gnd, SCL, and SDA pins have the usual connections. However, remember that although the power supply can be in the range of 2 V to 5 V, the analog input pins must never exceed Vdd. If you power the ADS1<em>x</em>15 from 3.3 V, the analog inputs are limited to 3.3 V. </p>&#13;
<p>The Adafruit ADS1<em>x</em>15 breakout boards include 10-kΩ pullup resistors on the SCL and SDA lines (to Vdd). While it’s convenient to not have to add the pullups yourself, if you connect a large number of such devices (with their own pullups) to the same I<sup>2</sup>C bus, the parallel resistance might be an issue. You’ll have to desolder the SMD chip resistors from the breakout board if this is the case.</p>&#13;
<p><span epub:type="pagebreak" id="Page_318" title="318"/>The ADDR pin is an input that the ADS1<em>x</em>15 uses to select one of four different I<sup>2</sup>C addresses. Connecting ADDR to Gnd, Vdd, SDA, or SCL specifies the I<sup>2</sup>C address as shown in <a href="#table14-8" id="tableanchor14-8">Table 14-8</a>—a particularly clever way to get four separate addresses from a single address pin. </p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table14-8">Table 14-8</a>: Address Selection on ADS1<em>x</em>15</p></figcaption>&#13;
<table border="1" id="table-502468c14-0008">&#13;
<thead>&#13;
<tr>&#13;
<td><b>ADDR connected to</b></td>&#13;
<td><b>I<sup>2</sup>C address</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Gnd</td>&#13;
<td>0x48</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Vdd</td>&#13;
<td>0x49</td>&#13;
</tr>&#13;
<tr>&#13;
<td>SDA</td>&#13;
<td>0x4A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>SCL</td>&#13;
<td>0x4B</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>Now refer back to <a href="#table14-7">Table 14-7</a>; the ALRT pin serves two purposes on the ADS1<em>x</em>15: when used with the built-in comparator, it can signal when a conversion is out of some programmable range. This pin can also be used to indicate that a conversion is complete—for example, to generate an interrupt, so the CPU doesn’t have to constantly poll the device to see when the conversion is done. The ALRT pin is an open-drain output pin. The Adafruit ADS1<em>x</em>15 breakout boards automatically include a pullup resistor on this line so you can treat the ALRT pin as a standard logic output.</p>&#13;
<p>The A0, A1, A2, and A3 are the single-ended input pins (the other signal connection goes to Gnd). In differential mode 0b000 (configuration register bits 12 through 14 are 0b000), pins A0 and A1 correspond to channel zero + and – inputs, respectively, and pins A2 and A3 correspond to channel 1 + and – inputs. In differential modes 0b001, 0b010, and 0b011 (bits 12 through 14 in the configuration register), there are three differential inputs using pins (A0, A3), (A1, A3), and (A2, A3), with A3 being the common (–) differential signal.</p>&#13;
<h2 id="h1-502468c14-0005">	14.5	An ADS1<em>x</em>15 Programming Example</h2>&#13;
<p class="BodyFirst">Basic ADS1<em>x</em>15 programming consists of writing an appropriate configuration value to the configuration register (including a “start conversion” bit in one-shot mode), waiting for the conversion to complete, and then reading the converted value from the conversion register. In a typical system, that’s all there is to using the ADS1<em>x</em>15. </p>&#13;
<p>As a test, hook up an Adafruit ADS1115 breakout board to an Arduino, as shown in <a href="#figure14-6" id="figureanchor14-6">Figure 14-6</a>. You can also use an ADS1015 if you prefer; the code works with either device, and I provide sample output for both devices later in this section. Note that the ADDR line is wired to Gnd; this sets the I<sup>2</sup>C address to 0x48. Vdd is wired to +5 V on the Arduino. The sample program in this section will read only the A0 input, so connect an appropriate voltage source to the A0 pin (0 V to 4.095 V). For quick tests, I just connected A0 to ground and the 3.3-V supply.</p>&#13;
<span epub:type="pagebreak" id="Page_319" title="319"/><figure>&#13;
<img alt="" class="keyline" height="609" src="image_fi/502468c14/f14006.png" width="574"/>&#13;
<figcaption><p><a id="figure14-6">Figure 14-6</a>: Hooking up an ADS1115 breakout board to an Arduino</p></figcaption>&#13;
</figure>&#13;
<p>The program in <a href="#listing14-1" id="listinganchor14-1">Listing 14-1</a> demonstrates reading input channel A0 and displaying the result in the Arduino serial monitor window.</p>&#13;
<pre><code>// <a href="#listinganchor14-1" id="listing14-1">Listing14-1</a>.ino&#13;
//&#13;
// A simple program that demonstrates&#13;
// ADS1115 programming.&#13;
//&#13;
// This program constantly reads the A0&#13;
// ADC channel and displays its values.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
#define ads1115 (0x48) // Connect ADDR to Gnd&#13;
&#13;
// ADS1x15 registers:&#13;
&#13;
#define conversion  (0)&#13;
#define config      (1)&#13;
#define lowThresh   (2)&#13;
#define highThresh  (3)&#13;
&#13;
<span epub:type="pagebreak" id="Page_320" title="320"/>// Usual Arduino initialization code:&#13;
&#13;
void setup( void )&#13;
{&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Test reading ADS1115" );&#13;
    Wire.begin(); // Initialize I2C library&#13;
&#13;
    adsReset();&#13;
}&#13;
&#13;
// adsReset-&#13;
//&#13;
// Reset the ADS1x115 to a known state:&#13;
&#13;
void adsReset()&#13;
{&#13;
    // Use the I2C General Call with a reset command:&#13;
&#13;
    Wire.beginTransmission( 0 );&#13;
    Wire.write( 6 );&#13;
    Wire.endTransmission();&#13;
}&#13;
&#13;
// adsWrite-&#13;
//&#13;
// Writes a 16-bit value to one&#13;
// of the ADS1x115 registers:&#13;
&#13;
void adsWrite( int adrs, int reg, int value )&#13;
{&#13;
    Wire.beginTransmission( adrs );&#13;
    Wire.write( reg );              // Pointer register value&#13;
&#13;
    // Split the output value into 2 bytes&#13;
    // and write them to the ADS1x15. Note that&#13;
    // this is written immediately after the&#13;
    // pointer register byte.&#13;
&#13;
    Wire.write( (value &lt;&lt; 8) &amp; 0xff );&#13;
    Wire.write( value &amp; 0xff );&#13;
    Wire.endTransmission();&#13;
}&#13;
&#13;
// adsRead-&#13;
//&#13;
// Reads a (signed) 16-bit value from one&#13;
// of the ADS1x15 registers.&#13;
&#13;
int adsRead( int adrs, int reg )&#13;
{&#13;
    unsigned char LOByte;&#13;
    unsigned char HOByte;&#13;
&#13;
<span epub:type="pagebreak" id="Page_321" title="321"/>    Wire.beginTransmission( adrs );&#13;
    Wire.write( reg );              // Pointer register value&#13;
    Wire.endTransmission( false );  // No stop condition&#13;
&#13;
    // Must send a new start condition and address&#13;
    // byte with the LO bit set to 1 in order to&#13;
    // the 2 bytes (Wire.requestFrom does this).&#13;
&#13;
    Wire.requestFrom( adrs, 2 );   // Read two bytes from&#13;
    HOByte = Wire.read();          // the conversion register&#13;
    LOByte = Wire.read();          &#13;
&#13;
    // Convert the 2 bytes read from the conversion&#13;
    // register to a signed integer and return.&#13;
&#13;
    return (int) ((short) (HOByte &lt;&lt; 8) | LOByte);&#13;
}&#13;
&#13;
// wait4Ready-&#13;
//&#13;
// Polls bit 15 of the configuration register ("ready" bit)&#13;
// until it contains a 1 (conversion complete).&#13;
&#13;
void wait4Ready( void )&#13;
{&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> while( (adsRead( ads1115, config ) &amp; 0x8000) == 0 )&#13;
    {&#13;
        // Wait for conversion to complete.&#13;
    }&#13;
}&#13;
&#13;
// Arduino main loop.&#13;
&#13;
void loop( void )&#13;
{&#13;
    uint16_t startConv;&#13;
&#13;
    // Create value to write to the configuration&#13;
    // register that will start a conversion on&#13;
    // single-ended input A0:&#13;
&#13;
    startConv =&#13;
          <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> (1) &lt;&lt; 15       // Start conversion&#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> |   (0b100) &lt;&lt; 12   // A0, single-ended&#13;
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> |   (0b001) &lt;&lt; 9    // PGA = 4.095 V&#13;
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> |   (1) &lt;&lt; 8        // One-shot mode&#13;
      <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> |   (0b111) &lt;&lt; 5    // 860 sps (ADS1115), 3300 (ADS1015)&#13;
        |   (0) &lt;&lt; 4        // Comparator mode (not used)&#13;
        |   (0) &lt;&lt; 3        // Comparator polarity (not used)&#13;
        |   (0) &lt;&lt; 2        // Non-latching (not used)&#13;
      <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> |   (0b11);         // Comparator disabled&#13;
&#13;
    // First, wait until any existing conversion completes:&#13;
&#13;
    wait4Ready();&#13;
&#13;
<span epub:type="pagebreak" id="Page_322" title="322"/>    // Start a conversion:&#13;
&#13;
  <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> adsWrite( ads1115, config, startConv );&#13;
&#13;
    // Wait for it to complete:&#13;
&#13;
  <span aria-label="annotation9" class="CodeAnnotationCode">❾</span> wait4Ready();&#13;
&#13;
    // Read the ADC value:&#13;
&#13;
    int16_t adcValue = adsRead( ads1115, conversion );&#13;
&#13;
    // Display result:&#13;
&#13;
    Serial.print( "ADC: " );&#13;
    Serial.println( adcValue );&#13;
}</code></pre>&#13;
<p>For testing purposes, the simplest code will set up the configuration register as follows:</p>&#13;
<ul>&#13;
<li>Program bits 0 to 4 with 0b00011 (disable the comparator) <span aria-label="annotation7" class="CodeAnnotation">❼</span></li>&#13;
<li>Program bits 5 to 7 with 0b111 (860 sps, though this value is irrelevant) <span aria-label="annotation6" class="CodeAnnotation">❻</span></li>&#13;
<li>Program bit 8 with 1 (one-shot mode) <span aria-label="annotation5" class="CodeAnnotation">❺</span></li>&#13;
<li>Program bits 9 to 11 with 0b001 (PGA = 4.095 V range) <span aria-label="annotation4" class="CodeAnnotation">❹</span></li>&#13;
<li>Program bits 12 to 14 with 0b100 (single-ended, select A0) <span aria-label="annotation3" class="CodeAnnotation">❸</span></li>&#13;
<li>Program bit 15 with 1 (start conversion) <span aria-label="annotation2" class="CodeAnnotation">❷</span></li>&#13;
</ul>&#13;
<p>After writing this value (0xC3E3) to the configuration register <span aria-label="annotation8" class="CodeAnnotation">❽</span>, the ADS1115 will begin converting the voltage appearing on A0 to digital form. The software must wait around 1.2 msec for this conversion to complete before it reads the result from the conversion register. Of course, a software delay of 1.2 msec is completely inappropriate; the right way to wait for the conversion to complete is to test bit 15 of the configuration register (the operational status bit) until it is 1 (<span aria-label="annotation1" class="CodeAnnotation">❶</span> and <span aria-label="annotation9" class="CodeAnnotation">❾</span>).</p>&#13;
<p>When executing the code in <a href="#listing14-1">Listing 14-1</a>, connecting the A0 line to ground should produce output like this:</p>&#13;
<pre><code>ADC: -2&#13;
ADC: 3&#13;
ADC: -1&#13;
ADC: -2&#13;
ADC: -1&#13;
ADC: 1&#13;
ADC: -1&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: -1&#13;
ADC: -1&#13;
<span epub:type="pagebreak" id="Page_323" title="323"/>ADC: 1&#13;
ADC: -2&#13;
ADC: 0&#13;
ADC: -1&#13;
ADC: 0&#13;
ADC: -1</code></pre>&#13;
<p>You can see the tiny amount of noise present during 16-bit conversions (remember, each integer unit represents 0.0000625 V). This particular sequence is very clean indeed, ranging from –2 to +3—a variance of only about 0.00003 V, an artifact of connecting A0 directly to a power supply pin.</p>&#13;
<p>This software also works fine with an Adafruit ADS1015 12-bit ADC breakout board. Here’s some output from that board:</p>&#13;
<pre><code>ADC: 0&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: -16&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: 16&#13;
ADC: 0&#13;
ADC: 0&#13;
ADC: 0</code></pre>&#13;
<p>Although the error looks much greater than with the ADS1<em>x</em>15, it’s actually better. Remember from “The Conversion Register” earlier in this chapter that the LO 4 bits of the conversion register are always 0 and the 12-bit conversion appears in bits 4 through 15, so what you’re seeing in the previous output is an occasional 1-bit error. This is one advantage to using a 12-bit rather than a 16-bit ADC: less noise.</p>&#13;
<h2 id="h1-502468c14-0006">	14.6	Improving Polling Performance</h2>&#13;
<p class="BodyFirst">The program in <a href="#listing14-1">Listing 14-1</a> polled bit 15 of the configuration register until it became 1, indicating the conversion was complete and the ADS1<em>x</em>15 was ready to do another conversion. This might not seem like a big deal, but keep in mind that reading the configuration register requires five I<sup>2</sup>C bus transactions: two to set the pointer register value and three to read the actual conversion register. At 100 kHz, this could take longer than 500 µsec—almost half the time of the conversion! </p>&#13;
<p>Of course, you could reduce time lost to polling by running the ADS1<em>x</em>15 at a higher clock frequency, but not all SBCs or CPUs support this; some, as you’ve seen in this book, don’t even run at a full 100 kHz. Fortunately, if you have a spare input pin on your SBC, there is a much faster solution: program the ALRT pin as a RDY pin and test for conversion complete by reading that pin.</p>&#13;
<p><span epub:type="pagebreak" id="Page_324" title="324"/>To program the ALRT pin as RDY, write a 0 to bit 15 of the low threshold register and a 1 to bit 15 of the high threshold register, turn off comparator latching (write a 0 to bit 2 of the configuration register), set the ALRT polarity to 0 (bit 3 of the configuration register), and enable the comparator. This enables reading the RDY status on the ALRT pin. You may have noticed that the ALRT pin in <a href="#figure14-6">Figure 14-6</a> is wired to the D2 digital I/O pin on the Arduino. The program in <a href="#listing14-1">Listing 14-1</a> ignored pin D2, but the program in <a href="#listing14-2" id="listinganchor14-2">Listing 14-2</a> will use this connection to test for when the conversion is complete.</p>&#13;
<p>The program in <a href="#listing14-2">Listing 14-2</a> is just a minor modification of the program in <a href="#listing14-1">Listing 14-1</a>. As such, I won’t reprint the repeated portions of <a href="#listing14-1">Listing 14-1</a> but will simply highlight the parts of the code that are new. I begin with the usual <code>#define</code> statements at the beginning of the file:</p>&#13;
<pre><code>// <a href="#listinganchor14-2" id="listing14-2">Listing14-2</a>.ino&#13;
//&#13;
// A simple program that demonstrates&#13;
// ADS1115 programming.&#13;
//&#13;
// This program constantly reads the A0&#13;
// ADC channel and displays its values.&#13;
// It reads the ALRT/RDY pin to determine&#13;
// when the conversion is complete (connect&#13;
// ALRT to D2 on Arduino).&#13;
&#13;
  #include &lt;Wire.h&gt;&#13;
  #define ads1115 (0x48) // Connect ADDR to Gnd&#13;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> #define rdy (2)        // RDY is on pin 2</code></pre>&#13;
<p>The main addition to this section is the definition of the <code>rdy</code> pin <span aria-label="annotation1" class="CodeAnnotation">❶</span>. </p>&#13;
<p>Next, I turn to the <code>wait4Ready()</code> function, rewritten from the code in <a href="#listing14-1">Listing 14-1</a>:</p>&#13;
<pre><code>// Listing14-2.ino (cont.)&#13;
//&#13;
// wait4Ready-&#13;
//&#13;
// Polls digital I/O pin 2 to see&#13;
// if the conversion is complete.&#13;
&#13;
void wait4Ready( void )&#13;
{&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> while( digitalRead( rdy ) != 0 )&#13;
    {&#13;
        // Wait for conversion to complete.&#13;
    }&#13;
}</code></pre>&#13;
<p>This <code>wait4Ready()</code> function reads the ready status from digital input pin D2 <span aria-label="annotation2" class="CodeAnnotation">❷</span> rather than reading the configuration register (which is slow) and testing bit 15 of that register.</p>&#13;
<p><span epub:type="pagebreak" id="Page_325" title="325"/>We next turn to the <code>setup()</code> function:</p>&#13;
<pre><code>// Listing14-2.ino (cont.)&#13;
&#13;
void setup( void )&#13;
{&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Test reading ADS1115" );&#13;
    Wire.begin(); // Initialize I2C library&#13;
    pinMode( 2, INPUT );&#13;
&#13;
    // Write a 1 to the HO bit of the&#13;
    // high threshold register and a 0&#13;
    // to the HO bit of the low threshold&#13;
    // register to program the ALRT pin&#13;
    // to behave as the RDY pin.&#13;
&#13;
    adsReset();&#13;
    adsWrite( ads1115, config, 0x43E0 );&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> adsWrite( ads1115, lowThresh, 0x0 );&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> adsWrite( ads1115, highThresh, 0x8000 );&#13;
}</code></pre>&#13;
<p>The <code>setup()</code> function needs to initialize the threshold registers so that the low threshold register has a 0 in its HO bit <span aria-label="annotation3" class="CodeAnnotation">❸</span> and the high threshold register has a 1 in its HO bit <span aria-label="annotation4" class="CodeAnnotation">❹</span>. This code also activates the comparator circuit so it can pass the ready status on to the ALRT pin on the ADS1<em>x</em>15.</p>&#13;
<p>The final change is to the code that writes to the configuration in the main loop:</p>&#13;
<pre><code>// Listing14-2.ino (cont.)&#13;
&#13;
void loop( void )&#13;
{&#13;
    uint16_t startConv;&#13;
&#13;
    // Create value to write to the configuration&#13;
    // register that will start a conversion on&#13;
    // single-ended input A0:&#13;
&#13;
    startConv =&#13;
            (1) &lt;&lt; 15       // Start conversion&#13;
        |   (0b100) &lt;&lt; 12   // A0, single-ended&#13;
        |   (0b001) &lt;&lt; 9    // PGA = 4.095 V&#13;
        |   (1) &lt;&lt; 8        // One-shot mode&#13;
        |   (0b111) &lt;&lt; 5    // 860 sps&#13;
        |   (0) &lt;&lt; 4        // Comparator mode (not used)&#13;
        |   (0) &lt;&lt; 3        // Comparator polarity (used)&#13;
        |   (0) &lt;&lt; 2        // Non-latching (not used)&#13;
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> |   (0b00);         // Comparator enabled</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_326" title="326"/>While the code in <a href="#listing14-1">Listing 14-1</a> disables the comparator on each pass of the loop, the code in <a href="#listing14-2">Listing 14-2</a> needs to keep the comparator enabled <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>&#13;
<p>These changes to <a href="#listing14-1">Listing 14-1</a> produce noticeably faster output. <a href="#figure14-7" id="figureanchor14-7">Figure 14-7</a> shows the output on the ALRT pin (input to the digital I/O D2 pin). When this signal is high, the ADC is busy doing a conversion. When it is low, the ADC is ready to do another conversion. As <a href="#figure14-7">Figure 14-7</a> shows, the conversions take slightly more than 1 msec when using a Teensy 3.2 (remember, the ADS1115, on which this was measured, is capable of about 860 sps). The low portion of the oscilloscope trace is the time spent sending the conversion command to the ADS1115 plus outputting data to the Arduino Serial terminal.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c14/f14007.png" width="416"/>&#13;
<figcaption><p><a id="figure14-7">Figure 14-7</a>: Oscilloscope output from <a href="#listing14-2">Listing 14-2</a></p></figcaption>&#13;
</figure>&#13;
<p>Remember that I ran the code that produced the output in <a href="#figure14-7">Figure 14-7</a> on a 96-MHz Teensy 3.2, not a 16-MHz Arduino Uno Rev3. On an Arduino, the bottom portion of the cycle might be a bit wider.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>Reading More Than One Channel</h2>&#13;
<p class="BoxBodyFirst">The programs up to this point have read data only from a single analog input channel (A0). Reading multiple channels is relatively straightforward: simply modify the value in the multiplexer control bits (12 through 14) in the configuration register that the code writes in the main loop. By sequencing values 0b100 through 0b111, you can read all four channels, one channel per loop execution.</p>&#13;
<p>Of course, there is only one actual ADC on the ADS1<em>x</em>15. The multiplexer control allows you to select a different input on each conversion, but it will take four separate conversions (and therefore, four times as long) to read all four channels. Obviously, this reduces the maximum sampling frequency for each channel by four.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p><span epub:type="pagebreak" id="Page_327" title="327"/>Using the RDY pin is not the only way to improve A/D conversion performance. The next section looks at another way to speed up the sampling rate.</p>&#13;
<h2 id="h1-502468c14-0007">	14.7	Improving Performance Using Continuous Scanning</h2>&#13;
<p class="BodyFirst">In <a href="#figure14-7">Figure 14-7</a>, just a little more than half the execution time is spent doing an analog-to-digital conversion (that is, when the ALRT [RDY] pin is high). Between conversions, there are three activities going on in the main Arduino <code>loop</code> function: writing to the configuration register to start the conversion, reading the conversion value from the ADS1115, and printing the results to the Arduino Serial terminal. Writing the results to the Serial terminal is not a blazing fast process, but writing the configuration register and reading the conversion register require nine I<sup>2</sup>C bus transactions—probably around 900 µsec on a 100-kHz bus. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	The conversion performance would have been worse had the code that produced the output in <a href="#figure14-7">Figure 14-7</a> actually run on a 16-MHz Arduino Uno Rev3 rather than a 96-MHz Teensy 3.2.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Nothing can be done to improve the performance of reading the conversion register—that’s the only way to get data out of the ADS1115. However, you can save the expense of writing the configuration register on each loop (around 400 µsec) by putting the ADS1115 in continuous conversion mode. In this mode, the CPU can request the data from the ADS1115 whenever it wants, without having to check if a conversion is complete; the ADS1115 will always return the value of the last conversion and will automatically update that value as each new conversion takes place. <a href="#listing14-3" id="listinganchor14-3">Listing 14-3</a> provides the code that puts the ADS1115 in continuous conversion mode. Again, I won’t reprint any code shared with the previous two listings.</p>&#13;
<pre><code>// <a href="#listinganchor14-3" id="listing14-3">Listing14-3</a>.ino&#13;
//&#13;
// A simple program that demonstrates&#13;
// ADS1115 programming.&#13;
//&#13;
// This program constantly reads the A0&#13;
// ADC channel and displays its values &#13;
// using continuous conversion mode.&#13;
// It reads the ALRT/RDY pin to determine&#13;
// when a new conversion occurs (so it can&#13;
// output data to the Serial terminal).&#13;
//&#13;
// adsReset-&#13;
//&#13;
// Reset the ADS1x115 to a known state:&#13;
&#13;
void adsReset()&#13;
<span epub:type="pagebreak" id="Page_328" title="328"/>{&#13;
    // Use the I2C General Call with a reset command:&#13;
&#13;
    Wire.beginTransmission( 0 );&#13;
    Wire.write( 6 );&#13;
    Wire.endTransmission();&#13;
}&#13;
&#13;
// wait4Conversion-&#13;
//&#13;
// Polls digital I/O pin 2 to see if the&#13;
// conversion is complete.&#13;
&#13;
void wait4Conversion( void )&#13;
{&#13;
    // Wait for the falling edge that&#13;
    // indicates a conversion has occurred.&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> while( digitalRead( rdy ) == 0 )&#13;
    {&#13;
        // Wait for conversion to complete.&#13;
    }&#13;
&#13;
    // Wait for the rising edge so that&#13;
    // the next loop doesn't mistakenly&#13;
    // think a new conversion occurred.&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> while( digitalRead( rdy ) == 1 )&#13;
    {&#13;
        // Wait for conversion to complete.&#13;
    }&#13;
}</code></pre>&#13;
<p>The <code>wait4Conversion()</code> function in <a href="#listing14-3">Listing 14-3</a> replaces <code>wait4Ready()</code> in the previous two listings. This function waits until the RDY line (digital input D2) goes low <span aria-label="annotation1" class="CodeAnnotation">❶</span>, indicating that a conversion has just completed. The ADS1115 will pulse RDY low for slightly less than 10 µsec and then automatically set it high again. This is plenty long enough for the Arduino (or Teensy, in my case) to detect that the conversion has completed. However, the code also has to wait for this line to go back high <span aria-label="annotation2" class="CodeAnnotation">❷</span> so that the <code>loop</code> function won’t repeat while the signal is still low and think another conversion has completed.</p>&#13;
<pre><code>// Listing14-3.ino (cont.)&#13;
//&#13;
// Usual Arduino initialization code.&#13;
&#13;
void setup( void )&#13;
{&#13;
&#13;
    Serial.begin( 9600 );&#13;
<span epub:type="pagebreak" id="Page_329" title="329"/>    delay( 1000 );&#13;
    Serial.println( "Test reading ADS1115" );&#13;
    Wire.begin(); // Initialize I2C library&#13;
    pinMode( 2, INPUT );&#13;
&#13;
    // Write a 1 to the HO bit of the&#13;
    // high threshold register and a 0&#13;
    // to the HO bit of the low threshold&#13;
    // register to program the ALRT pin&#13;
    // to behave as the RDY pin. Also&#13;
    // put a 0 in bit 8 to turn on the&#13;
    // continuous conversion mode.&#13;
&#13;
    adsReset();&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> adsWrite( ads1115, config, 0x42E0 );&#13;
    adsWrite( ads1115, lowThresh, 0x0 );&#13;
    adsWrite( ads1115, highThresh, 0x8000 );&#13;
}</code></pre>&#13;
<p>The only real modification to the setup function from the previous examples is that it programs bit 8 of the configuration register with 0 <span aria-label="annotation3" class="CodeAnnotation">❸</span>, putting the device in continuous conversion mode:</p>&#13;
<pre><code>// Listing14-3.ino (cont.)&#13;
//&#13;
// Arduino main loop.&#13;
&#13;
void loop( void )&#13;
{&#13;
&#13;
    // Wait for a conversion to complete:&#13;
&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> wait4Conversion();&#13;
&#13;
    // Read the ADC value:&#13;
&#13;
    int16_t adcValue = adsRead( ads1115, conversion );&#13;
&#13;
    // Display result:&#13;
&#13;
    Serial.print( "ADC: " );&#13;
    Serial.println( adcValue );&#13;
}</code></pre>&#13;
<p>In the <code>loop()</code> function, the code to write the configuration register is gone. Because the ADS1115 is operating in continuous mode, there is no longer a need to start a new conversion by writing to the configuration register. The <code>wait4Conversion()</code> function <span aria-label="annotation4" class="CodeAnnotation">❹</span> is very fast (it’s all digital I/O with no I<sup>2</sup>C transactions). This leaves only reading the conversion register to slow down the main loop.</p>&#13;
<p><span epub:type="pagebreak" id="Page_330" title="330"/><a href="#figure14-8" id="figureanchor14-8">Figure 14-8</a> shows the oscilloscope output for the program in <a href="#listing14-3">Listing 14-3</a>. The first thing to note is that the time scale is one half that of the previous figure’s (500 µsec instead of 1 msec). The period for each pulse is just a little more than 1.2 msec (versus about 2 msec in <a href="#figure14-7">Figure 14-7</a>), meaning this code runs almost twice as fast as the code in the previous listings.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c14/f14008.png" width="416"/>&#13;
<figcaption><p><a id="figure14-8">Figure 14-8</a>: Oscilloscope output for <a href="#listing14-3">Listing 14-3</a></p></figcaption>&#13;
</figure>&#13;
<p>The only drawback to using the continuous mode to speed up the application is that you can read from only one ADC channel (ignoring the power-saving aspects of one-shot/power-down mode). To change multiplexer channels, you have to write to the configuration register, which eats up all the time saved by removing that call in the first place.</p>&#13;
<h2 id="h1-502468c14-0008">	14.8	Interrupts and the ADS1<em>x</em>15</h2>&#13;
<p class="BodyFirst">In theory, it’s possible to connect the ALRT (RDY) pin to an interrupt input on the Arduino—D2 is an interrupt pin on the Arduino Uno Rev3, for example. Whenever an interrupt occurs (due to a conversion complete or a comparison out-of-range signal), the interrupt service routine can read the data or process the comparison fault and pass that information along to the main program.</p>&#13;
<p>In practice, however, using interrupts in Arduino code is dubious at best. I<sup>2</sup>C communications, which would have to take place inside the ISR, are extremely slow, and ISRs need to be really fast. Maybe it would work with a high-speed–mode I<sup>2</sup>C clock; you’d have to test that and see.</p>&#13;
<p>On the other hand, if you are using a multithreaded RTOS with good interrupt support (that is, with an interrupt-driven I<sup>2</sup>C library), interrupts become very practical. The ISR would simply signal a thread when a conversion is complete, and that thread could talk to the ADS1115, blocking while I<sup>2</sup>C transmissions (and conversion) are taking place. This would consume little CPU time compared to polling and would allow other threads to run with little performance loss.</p>&#13;
<h2 id="h1-502468c14-0009"><span epub:type="pagebreak" id="Page_331" title="331"/>	14.9	Filtering Noise</h2>&#13;
<p class="BodyFirst">In the real world—as opposed to the simple test circuits I’ve used in this chapter, where I’ve wired an analog input directly to a power supply pin—noise can be a big issue when reading analog signals. Sources of noise include the environment, the circuitry, and the analog sensors themselves. Fortunately, you can digitally filter out some of this noise with some simple software techniques.</p>&#13;
<p>One of the most common such techniques is to take several readings—say, three to nine—and take the median of those values. This scheme picks the middle of a bunch of readings and has the advantage of eliminating outlier values. A slightly more efficient technique is to take several readings and compute the arithmetic mean of those values. This is usually faster than computing the median but has the disadvantage of incorporating outliers into the average. </p>&#13;
<p>However, both median and mean are based on a fixed set of values, while analog readings tend to be a continuous stream. Therefore, the most appropriate solution is to create a <em>windowed average</em>. To do so, maintain a list of the last <em>n</em> readings, where <em>n</em> is the window size, and compute the average based on those values. Each time a new ADC reading comes along, you add it to the window list and throw out the oldest reading from the list.</p>&#13;
<p>In relatively noisy environments, I usually use <em>both</em> techniques to filter out the noise. I keep the last seven or nine readings from the ADC and compute the median of those values. Then I keep the last 4 to 20 median values (depending on the application) and compute the arithmetic mean of those values. For example, if I’m computing the median of 9 values and the arithmetic mean of 10 values, I’m actually averaging a total of 90 ADC readings at any one given time. In the next section, I’ll describe how to do this.</p>&#13;
<p>The price of filtering out noise using averaging is that your results will only slowly reflect any sudden changes in the analog readings. For example, if your input voltage suddenly jumps from 0 V to 5 V, it may take several hundred readings before your average shows a solid 5 V. </p>&#13;
<h3 id="h2-502468c14-0011">14.9.1	Computing Means and Medians</h3>&#13;
<p class="BodyFirst">Computing the arithmetic mean is relatively simple: just sum all the values and divide by the number of values. Choosing a window size that is a power of two can improve performance, as division by <em>n</em> (normally a slow operation) becomes a simple shift-right operation. Normally, the window size is sufficiently small that summing all the elements in the window is no big deal; however, if you have a large number of items, you can save a small amount of time by subtracting the oldest element in the window and then adding in the latest reading.</p>&#13;
<p>The generic algorithm for computing a median is to sort the data and pick the middle element (or take the mean of the middle two elements if there is an even number of elements). The quickselect algorithm does much better (see <a class="LinkURL" href="https://en.wikipedia.org/wiki/Quickselect">https://en.wikipedia.org/wiki/Quickselect</a>). However, for very small <span epub:type="pagebreak" id="Page_332" title="332"/>windows (say, three, seven, or nine elements), a brute-force approach is probably the most efficient. For example, the common way to compute the median of three elements is to use code like the following:</p>&#13;
<pre><code>int medianOfThree( int a, int b, int c )&#13;
{&#13;
    if( (a &gt; b) != (a &gt; c) ) &#13;
        return a;&#13;
    else if( (b &gt; a) != (b &gt; c) )&#13;
        return b;&#13;
    else&#13;
        return c;&#13;
}</code></pre>&#13;
<p>Code like this is often used to create a pivot element for the quicksort algorithm; see “For More Information” for details.</p>&#13;
<p>Here’s a generic function that computes the median of an array of any size (not just three elements) and is faster for certain array sizes. You’ll normally work with a fixed window size in any given application. Simply pull out the code from the appropriate case in this function to get an algorithm that works for your particular window size.</p>&#13;
<pre><code>#include &lt;string.h&gt;&#13;
&#13;
#define ever ;;&#13;
#define breakif(exp) if (exp) break&#13;
&#13;
// Find the median element of an int16_t array.&#13;
//&#13;
// This Quickselect routine is based on the algorithm &#13;
// described in "Numerical recipes in C," Second Edition,&#13;
// Cambridge University Press, 1992, Section 8.5, &#13;
// ISBN 0-521-43108-5.&#13;
//&#13;
// This code was originally written by Nicolas Devillard - 1998&#13;
// Public domain.&#13;
//&#13;
// Code was modified to use macros (straight-line code) for&#13;
// arrays with 9 or fewer elements (an optimization).&#13;
&#13;
#define ELEM_SORT(a,b) { if((a)&gt;(b)) ELEM_SWAP( (a), (b) ); }&#13;
#define ELEM_SWAP(a,b) { register int16_t t=(a);(a)=(b);(b)=t; }&#13;
#define ainReadings_c 32  // Maximum number of readings&#13;
&#13;
int16_t quick_select(int16_t array[ainReadings_c], int n) &#13;
{&#13;
    int low;&#13;
    int high;&#13;
    int median;&#13;
    int middle;&#13;
    int ll;&#13;
    int hh;&#13;
    &#13;
<span epub:type="pagebreak" id="Page_333" title="333"/>    // Make temporary copy here because you will modify array.&#13;
&#13;
    int16_t arr[ainReadings_c]; &#13;
&#13;
    // Macros to handle special cases as fast as possible.&#13;
    &#13;
    switch( n )&#13;
    {&#13;
        case 1:&#13;
            return array[0];&#13;
            &#13;
        case 2:&#13;
&#13;
            // If just two elements, return their &#13;
            // arithmetic mean:&#13;
            &#13;
            return (array[0] + array[1]) / 2;&#13;
            &#13;
        case 3:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            &#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[0], arr[1] );&#13;
            return(arr[1]) ;&#13;
            &#13;
        case 4:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            arr[3] = array[3];&#13;
            &#13;
            ELEM_SORT( arr[0], arr[1] );&#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[0], arr[2] );&#13;
            ELEM_SORT( arr[1], arr[3] );&#13;
            &#13;
            // arr[1] and arr[3] may be out of order, &#13;
            // but it doesn't matter.&#13;
            &#13;
            // Return the mean of the upper and lower medians:&#13;
             &#13;
            return( (arr[1] + arr[2]) / 2 );&#13;
            &#13;
        case 5:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            arr[3] = array[3];&#13;
            arr[4] = array[4];&#13;
            &#13;
            ELEM_SORT( arr[0], arr[1] );&#13;
            ELEM_SORT( arr[3], arr[4] ); &#13;
<span epub:type="pagebreak" id="Page_334" title="334"/>            ELEM_SORT( arr[0], arr[3] );&#13;
            ELEM_SORT( arr[1], arr[4] );&#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[2], arr[3] );&#13;
            ELEM_SORT( arr[1], arr[2] );&#13;
            return( arr[2] );&#13;
             &#13;
        case 6:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            arr[3] = array[3];&#13;
            arr[4] = array[4];&#13;
            arr[5] = array[5];&#13;
            &#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[3], arr[4] );&#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[4], arr[5] );&#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[3], arr[4] );&#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[4], arr[5] );&#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[3], arr[4] );&#13;
            &#13;
            // ELEM_SORT( arr[2], arr[3] ) results in lower&#13;
            // median in  arr[2] and upper median in  arr[3].&#13;
            // "Median" of an even number of elements is the &#13;
            // mean of the two middle elements in this code.&#13;
            &#13;
            return (  arr[2] +  arr[3] ) / 2;&#13;
            &#13;
        case 7:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            arr[3] = array[3];&#13;
            arr[4] = array[4];&#13;
            arr[5] = array[5];&#13;
            arr[6] = array[6];&#13;
            &#13;
            ELEM_SORT( arr[0], arr[5] ); &#13;
            ELEM_SORT( arr[0], arr[3] ); &#13;
            ELEM_SORT( arr[1], arr[6] );&#13;
            ELEM_SORT( arr[2], arr[4] ); &#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[3], arr[5] );&#13;
            ELEM_SORT( arr[2], arr[6] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[3], arr[6] );&#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
<span epub:type="pagebreak" id="Page_335" title="335"/>            ELEM_SORT( arr[1], arr[4] ); &#13;
            ELEM_SORT( arr[1], arr[3] );&#13;
            ELEM_SORT( arr[3], arr[4] ); &#13;
            return ( arr[3] );&#13;
&#13;
        case 8:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            arr[3] = array[3];&#13;
            arr[4] = array[4];&#13;
            arr[5] = array[5];&#13;
            arr[6] = array[6];&#13;
            arr[7] = array[7];&#13;
            &#13;
            // No convenient macro to get the median&#13;
            // of eight elements, so resorted to an&#13;
            // ugly insertion sort here:&#13;
            &#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[6], arr[7] ); &#13;
            ELEM_SORT( arr[1], arr[2] );&#13;
            ELEM_SORT( arr[5], arr[6] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[4], arr[5] );&#13;
            ELEM_SORT( arr[3], arr[4] ); &#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
            ELEM_SORT( arr[2], arr[3] );&#13;
            ELEM_SORT( arr[5], arr[6] ); &#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[6], arr[7] );&#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[5], arr[6] );&#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
            ELEM_SORT( arr[3], arr[4] );&#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[5], arr[6] ); &#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
            ELEM_SORT( arr[3], arr[4] ); &#13;
            ELEM_SORT( arr[2], arr[3] ); &#13;
            return( (arr[3] + arr[4]) / 2);&#13;
&#13;
        case 9:&#13;
            arr[0] = array[0];&#13;
            arr[1] = array[1];&#13;
            arr[2] = array[2];&#13;
            arr[3] = array[3];&#13;
            arr[4] = array[4];&#13;
            arr[5] = array[5];&#13;
<span epub:type="pagebreak" id="Page_336" title="336"/>            arr[6] = array[6];&#13;
            arr[7] = array[7];&#13;
            arr[8] = array[8];&#13;
            &#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
            ELEM_SORT( arr[7], arr[8] );&#13;
            ELEM_SORT( arr[0], arr[1] ); &#13;
            ELEM_SORT( arr[3], arr[4] ); &#13;
            ELEM_SORT( arr[6], arr[7] );&#13;
            ELEM_SORT( arr[1], arr[2] ); &#13;
            ELEM_SORT( arr[4], arr[5] ); &#13;
            ELEM_SORT( arr[7], arr[8] );&#13;
            ELEM_SORT( arr[0], arr[3] ); &#13;
            ELEM_SORT( arr[5], arr[8] ); &#13;
            ELEM_SORT( arr[4], arr[7] );&#13;
            ELEM_SORT( arr[3], arr[6] ); &#13;
            ELEM_SORT( arr[1], arr[4] ); &#13;
            ELEM_SORT( arr[2], arr[5] );&#13;
            ELEM_SORT( arr[4], arr[7] ); &#13;
            ELEM_SORT( arr[4], arr[2] ); &#13;
            ELEM_SORT( arr[6], arr[4] );&#13;
            ELEM_SORT( arr[4], arr[2] ); &#13;
            return( arr[4]) ;&#13;
 &#13;
        // Handle the general case (not one of the above) here:&#13;
            &#13;
        default:&#13;
&#13;
            // The quick_select algorithm modifies the array.&#13;
            // Therefore, you need to make a copy of it prior &#13;
            // to use.&#13;
            &#13;
            memcpy( arr, array, n*sizeof( int16_t ) );&#13;
            low = 0; &#13;
            high = n-1; &#13;
            median = (low + high) / 2;&#13;
            for( ever )&#13;
            {&#13;
                if (high &lt;= low)     // One element only&#13;
                {&#13;
                    return arr[median];&#13;
                } // endif&#13;
&#13;
                if (high == low + 1) // Two elements only&#13;
                {&#13;
                    return (arr[low] + arr[high]) / 2;&#13;
                } // endif&#13;
&#13;
                // Find median of low, middle, and high items;&#13;
                // swap into position (low).&#13;
                &#13;
                middle = (low + high) / 2;&#13;
                if (arr[middle] &gt; arr[high])&#13;
<span epub:type="pagebreak" id="Page_337" title="337"/>                {&#13;
                    ELEM_SWAP(arr[middle], arr[high]);&#13;
                } // endif&#13;
                if (arr[low] &gt; arr[high])&#13;
                {&#13;
                    ELEM_SWAP(arr[low], arr[high])&#13;
                } // endif&#13;
                if (arr[middle] &gt; arr[low])&#13;
                {&#13;
                    ELEM_SWAP(arr[middle], arr[low]);&#13;
                } // endif&#13;
&#13;
                // Swap low item (now in position middle) &#13;
                // into position (low+1).&#13;
                &#13;
                ELEM_SWAP(arr[middle], arr[low+1]) ;&#13;
&#13;
                // Nibble from each end towards middle, &#13;
                // swapping items when stuck.&#13;
                &#13;
                ll = low + 1;&#13;
                hh = high;&#13;
                for( ever )&#13;
                {&#13;
                    do ll++; while (arr[low] &gt; arr[ll]);&#13;
                    do hh--; while (arr[hh]  &gt; arr[low]);&#13;
&#13;
                    breakif (hh &lt; ll);&#13;
&#13;
                    ELEM_SWAP(arr[ll], arr[hh]);&#13;
                } // endfor&#13;
&#13;
                // Swap middle item (in position low) back &#13;
                // into correct position.&#13;
                &#13;
                ELEM_SWAP(arr[low], arr[hh]);&#13;
&#13;
                // Reset active partition.&#13;
                &#13;
                if (hh &lt;= median)&#13;
                {&#13;
                    low = ll;&#13;
                } // endif&#13;
                if (hh &gt;= median)&#13;
                high = hh - 1;&#13;
                &#13;
            } // endfor&#13;
    } // end switch&#13;
} // quick_select&#13;
&#13;
#undef ELEM_SWAP</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_338" title="338"/>Insertion into an already sorted list takes time equal to O(lg <em>n</em>), where <em>n</em> is the number of elements in the list. If you keep a sorted list of the last <em>n</em> readings, you can compute the median more efficiently (though removing the oldest element might be tricky). However, this is a book on I<sup>2</sup>C programming, not algorithm development, so I will leave further optimizations to interested readers.</p>&#13;
<h2 id="h1-502468c14-0010">	14.10	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter covered the programming and use of the ADS1015 and ADS1115 analog-to-digital converters. It began with a discussion of the specifications and features of generic ADCs with some specific features of the ADS1<em>x</em>15 devices to provide an appropriate background for the discussion in this chapter.</p>&#13;
<p>Because most ADCs have a limited range of voltage inputs they can process, you will often need to add additional analog circuity to <em>condition</em> real-world signals, that is, convert the incoming signal to something that is appropriate for the ADC. Because the ADS1<em>x</em>15 ICs are limited to the (somewhat) unusual range of 0 V to 4.095 V (in full-range mode), this chapter provided an opamp circuit that will convert voltages within the range of ±10 V to a range acceptable to the ADS1<em>x</em>15 ICs.</p>&#13;
<p>After discussing analog conditioning, this chapter then did a deep dive into the registers present on the ADS1<em>x</em>15 devices and how to program them via the I<sup>2</sup>C bus. The chapter described all the various bits in the registers and how to initialize and use the ADS1<em>x</em>15.</p>&#13;
<p>Because the ADS1<em>x</em>15 parts are surface-mount devices, they’re a bit difficult to wire onto a typical prototyping breadboard. So this chapter briefly described the Adafruit breakout boards for the ADS1015 and ADS1115 ICs. Adafruit is also kind enough to provide sample library code for Arduino and Raspberry Pi systems, for which this chapter provided links.</p>&#13;
<p>Although you can use the Adafruit libraries to read analog data using the ADS1<em>x</em>15 devices, the goal of this chapter was to teach you how to program the ADS1<em>x</em>15 parts directly. Therefore, this chapter also provided sample programs that program the chips directly and obtain the analog data. It also discussed how to improve the performance of the (rather slow) ADC parts, and it briefly touched on using interrupts with the ADS1<em>x</em>15.</p>&#13;
<p>This chapter concluded by pointing out that ADC inputs tend to have a bit of noise associated with them. It then described a filtering algorithm (using arithmetic mean and median averages) to produce a quieter input.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_339" title="339"/>For More Information</h2>&#13;
<ol class="none">&#13;
<li>ADS1015 datasheet: <a class="LinkURL" href="https://cdn-shop.adafruit.com/datasheets/ads1015.pdf">https://cdn-shop.adafruit.com/datasheets/ads1015.pdf</a></li>&#13;
<li>ADS1115 datasheet: <a class="LinkURL" href="https://cdn-shop.adafruit.com/datasheets/ads1115.pdf">https://cdn-shop.adafruit.com/datasheets/ads1115.pdf</a></li>&#13;
<li>ADS1<em>x</em>15 information on the web: <a class="LinkURL" href="https://thecavepearlproject.org/2020/05/21/using-the-ads1115-in-continuous-mode-for-burst-sampling">https://thecavepearlproject.org/2020/05/21/using-the-ads1115-in-continuous-mode-for-burst-sampling</a></li>&#13;
<li>ADS1<em>x</em>15 Arduino library code:&#13;
<ol class="none sub">&#13;
<li>Adafruit GitHub site: <a class="LinkURL" href="https://github.com/adafruit/Adafruit_ADS1X15">https://github.com/adafruit/Adafruit_ADS1X15</a></li>&#13;
<li>Another GitHub site: <a class="LinkURL" href="https://github.com/addicore/ADS1115">https://github.com/addicore/ADS1115</a></li>&#13;
<li>Adafruit documentation: <a class="LinkURL" href="https://learn.adafruit.com/adafruit-4-channel-adc-breakouts/arduino-code">https://learn.adafruit.com/adafruit-4-channel-adc-breakouts/arduino-code</a></li>&#13;
<li>Original library: <a class="LinkURL" href="https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/ADS1115/ADS1115.cpp">https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/ADS1115/ADS1115.cpp</a></li>&#13;
<li>Python versions: <a class="LinkURL" href="https://github.com/adafruit/Adafruit_CircuitPython_ADS1x15">https://github.com/adafruit/Adafruit_CircuitPython_ADS1x15</a></li>&#13;
</ol>&#13;
</li>&#13;
<li>ADS1<em>x</em>15 Raspberry Pi library code:&#13;
<ol class="none sub">&#13;
<li>University of Cambridge code: <a class="LinkURL" href="http://openlabtools.eng.cam.ac.uk/Resources/Datalog/RPi_ADS1115">http://openlabtools.eng.cam.ac.uk/Resources/Datalog/RPi_ADS1115</a></li>&#13;
<li>Adafruit GitHub site: <a class="LinkURL" href="https://github.com/hallgrimur1471/Adafruit_ADS1X15_RPi">https://github.com/hallgrimur1471/Adafruit_ADS1X15_RPi</a></li>&#13;
</ol>&#13;
</li>&#13;
<li>Adafruit breakout boards:&#13;
<ol class="none sub">&#13;
<li>Adafruit ADS1015: <a class="LinkURL" href="https://www.adafruit.com/product/1083">https://www.adafruit.com/product/1083</a></li>&#13;
<li>Adafruit ADS1115: <a class="LinkURL" href="https://www.adafruit.com/product/1085">https://www.adafruit.com/product/1085</a></li>&#13;
<li>Computing medians: <a class="LinkURL" href="https://rcoh.me/posts/linear-time-median-finding">https://rcoh.me/posts/linear-time-median-finding</a></li>&#13;
<li>More on medians: <a class="LinkURL" href="https://stackoverflow.com/questions/7559608/median-of-three-values-strategy">https://stackoverflow.com/questions/7559608/median-of-three-values-strategy</a></li>&#13;
</ol>&#13;
</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>