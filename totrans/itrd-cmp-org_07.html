<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_127"/><strong><span class="big">7</span><br/>SEQUENTIAL LOGIC CIRCUITS</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz">In the previous chapter, you learned about combinational logic circuits, which are circuits that depend only on their current input. Another way of thinking about this is that combinational logic circuits are instantaneous (except for the time required for the electronics to settle): their output depends only on the input at the time the output is observed. <em>Sequential logic circuits</em>, on the other hand, depend on both the current and past inputs. They have a time history, which can be summarized by the current state of the circuit.</p>&#13;
<p class="indent">Formally, the <em>system state</em> is a description of the system such that the state at time <em>t</em><sub>0</sub> and the inputs from time <em>t</em><sub>0</sub> through time <em>t</em><sub>1</sub> uniquely determines the state at time <em>t</em><sub>1</sub> and the outputs from time <em>t</em><sub>0</sub> through time <em>t</em><sub>1</sub>. In other words, the system state provides a summary of everything that has affected the system. Knowing the state of a system at any given time <em>t</em> tells you everything you need to know to specify the system’s behavior from that time on. How it got into that state is irrelevant.</p>&#13;
<span epub:type="pagebreak" id="page_128"/>&#13;
<p class="indent">The concept of system state is captured in a <em>finite state machine</em>, a mathematical model of computation that exists in any one of a finite number of states. External inputs to a finite state machine cause it to transition from one state to another or to the same state, while possibly producing an output. Sequential logic circuits are used to implement finite state machines. If a sequential logic circuit is designed such that its output depends only on the state it’s in, it’s called a <em>Moore state machine</em>. If the output also depends on the input causing a transition to a state, it’s called a <em>Mealy state machine</em>.</p>&#13;
<p class="indent">In this chapter, you’ll learn how <em>feedback</em> is used in a logic circuit to keep the gates in a particular state over time, thus implementing memory. We’ll use <em>state diagrams</em> to show how inputs cause a sequential logic circuit to transition between states and what the corresponding outputs are. You’ll also learn how sequential logic circuits can be synchronized with a clock to provide reliable results.</p>&#13;
<h3 class="h3" id="ch07lev1sec1"><strong>Latches</strong></h3>&#13;
<p class="noindent">The first sequential logic circuit we’ll look at is a <em>latch</em>, a 1-bit storage device that can be in one of two states, depending on its input. A latch can be constructed by connecting two or more logic gates such that the output from one gate feeds into the input of another gate; this keeps the output of both gates in the same state as long as power is applied. The state of a latch does not depend on time. (The term <em>latch</em> is also used for a multiple-bit storage device that behaves like the 1-bit device described here.)</p>&#13;
<h4 class="h4" id="ch07lev2sec1"><em><strong>SR Latch Using NOR Gates</strong></em></h4>&#13;
<p class="noindent">The most basic latch is the <em>Set–Reset (SR)</em> latch. It has two inputs, <em>S</em> and <em>R</em>, and two states, <em>set</em> and <em>reset</em>. The state is used as the primary output, <em>Q</em>. It’s common to also provide the complemented output, ¬<em>Q</em>. The SR latch is said to be in the set state when the outputs are <em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>. It’s in the reset state when <em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>. <a href="ch07.xhtml#ch7fig1">Figure 7-1</a> shows a simple implementation of an SR latch using NOR gates.</p>&#13;
<div class="image"><img id="ch7fig1" src="../images/pg156_Image_206.jpg" alt="Image" width="201" height="138"/></div>&#13;
<p class="figcap"><em>Figure 7-1: A NOR gate implementation of an SR latch</em></p>&#13;
<p class="indent">The output of each NOR gate is fed into the input of the other. As I describe the behavior of the circuit in this chapter, you’ll see that this feedback is what keeps the latch in one state.</p>&#13;
<span epub:type="pagebreak" id="page_129"/>&#13;
<p class="indent">There are four possible input combinations for an SR latch, as detailed in the following list:</p>&#13;
<p class="noindenta"><em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>,</strong> <em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>: Keep current state</strong></p>&#13;
<p class="noindentina">If the latch is in the set state (<em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>), an input of <em>S</em> = <span class="literal">0</span> and <em>R</em> = <span class="literal">0</span> will cause ¬<em>Q</em>, the output of the upper NOR gate, to yield ¬(<span class="literal">0</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span> and <em>Q</em>, the output of the lower NOR gate, to yield ¬(<span class="literal">0</span> ∨ <span class="literal">0</span>) = <span class="literal">1</span>. Conversely, if the latch is in the reset state (<em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>), then the output of the upper NOR gate yields ¬(<span class="literal">0</span> ∨ <span class="literal">0</span>) = <span class="literal">1</span>, and the lower NOR gate yields ¬(<span class="literal">1</span> ∨ <span class="literal">0</span>) = <span class="literal">0</span>. Thus, the cross-feedback between the two NOR gates maintains the current state of the latch.</p>&#13;
<p class="noindenta"><em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>,</strong> <em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>: Set (</strong><em><strong>Q</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>)</strong></p>&#13;
<p class="noindentina">If the latch is in the reset state, these inputs cause the output of the upper NOR gate to be ¬(<span class="literal">1</span> ∨ <span class="literal">0</span>) = <span class="literal">0</span>, thus changing ¬<em>Q</em> to <span class="literal">0</span>. This is fed back to the input of the lower NOR gate to yield ¬(<span class="literal">0</span> ∨ <span class="literal">0</span>) = <span class="literal">1</span>. The feedback from the output of the lower NOR gate to the input of the upper NOR gate keeps the output of the upper gate at ¬(<span class="literal">1</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span>. The latch has then moved into the set state (<em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>).</p>&#13;
<p class="indent1">If the latch is in the set state, the upper NOR gate yields ¬(<span class="literal">1</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span> and the output of the lower NOR gate is ¬(<span class="literal">0</span> ∨ <span class="literal">0</span>) = <span class="literal">1</span>. The latch thus remains in the set state.</p>&#13;
<p class="noindenta"><em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>,</strong> <em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>: Reset (</strong><em><strong>Q</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>)</strong></p>&#13;
<p class="noindentina">If the latch is in the set state, the lower NOR gate yields ¬(<span class="literal">0</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span>, thus changing <em>Q</em> to be <span class="literal">0</span>. This is fed back to the input of the upper NOR gate to yield ¬(<span class="literal">0</span> ∨ <span class="literal">0</span>) = <span class="literal">1</span>. The feedback from the output of the upper NOR gate to the input of the lower NOR gate keeps the output of the lower gate at ¬(<span class="literal">1</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span>. The latch has then moved into the reset state (<em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>).</p>&#13;
<p class="indent1">If the latch is already in the reset state, the lower NOR gate yields ¬(<span class="literal">1</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span> and the output of the upper NOR gate is ¬(<span class="literal">0</span> ∨ <span class="literal">0</span>) = <span class="literal">1</span>, so the latch remains in the reset state.</p>&#13;
<p class="noindenta"><em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>,</strong> <em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>: Not allowed</strong></p>&#13;
<p class="noindentina">If <em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>, the upper NOR gate yields ¬(<span class="literal">1</span> ∨ <span class="literal">0</span>) = <span class="literal">0</span>. This is fed back to the input of the lower NOR gate to yield ¬(<span class="literal">0</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span>. This would give <em>Q</em> = ¬<em>Q</em>, which is inconsistent with the laws of Boolean algebra.</p>&#13;
<p class="indent1">If <em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>, the lower NOR gate yields ¬(<span class="literal">0</span> ∨ <span class="literal">1</span>) = <span class="literal">0</span>. This is fed back to the input of the upper NOR gate to yield ¬(<span class="literal">1</span> ∨ <span class="literal">0</span>) = <span class="literal">0</span>. This would also give <em>Q</em> = ¬<em>Q</em>, which is inconsistent. Circuits must be designed to prevent this input combination.</p>&#13;
<p class="indenta">To simplify things, we can represent this logic visually. <a href="ch07.xhtml#ch7fig2">Figure 7-2</a> introduces a graphic way to show the behavior of a NOR gate SR latch: the state diagram. In this figure, the current state is shown in the bubbles and the corresponding primary output is below the state. The lines with arrows show the possible transitions between the states and are labeled with the inputs that cause the transition to the next state.</p>&#13;
<span epub:type="pagebreak" id="page_130"/>&#13;
<div class="image"><img id="ch7fig2" src="../images/pg158_Image_207.jpg" alt="Image" width="544" height="125"/></div>&#13;
<p class="figcap"><em>Figure 7-2: A state diagram for a NOR gate SR latch</em></p>&#13;
<p class="indent">The two circles in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a> show the two possible states of the SR latch: set or reset. The labels on the lines show the combination of inputs, <em>SR</em>, that causes each state transition. For example, when the latch is in the reset state, there are two possible inputs, <em>SR</em> = <span class="literal">00</span> and <em>SR</em> = <span class="literal">01</span>, that cause it to remain in that state. The input <em>SR</em> = <span class="literal">10</span> causes it to transition to the set state. Since the output is dependent only on the state—and not on the input—a latch is a Moore state machine.</p>&#13;
<p class="indent">Those familiar with graph theory will recognize that a state diagram is a directed graph: the states are the vertices and the inputs that cause transitions are the edges. Although they are beyond the scope of this book, tools from graph theory can be useful in the design process.</p>&#13;
<p class="indent">As in graph theory, we can also show the same behavior in a tabular form using a <em>state transition table</em>, as shown in <a href="ch07.xhtml#ch7tab1">Table 7-1</a>.</p>&#13;
<p class="tabcap" id="ch7tab1"><strong>Table 7-1:</strong> A NOR Gate SR Latch State Transition Table</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>S</strong></em></th>&#13;
<th class="tab_th"><em><strong>R</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong></em><sub><em><strong>next</strong></em></sub></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">x</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">x</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7tab1">Table 7-1</a>, <em>S</em> and <em>R</em> are the inputs, <em>Q</em> is the output in the current state, and <em>Q<sub>next</sub></em> shows the output in the state that results from the corresponding input. The x in the bottom two rows indicates an impossible condition.</p>&#13;
<p class="indent">Both inputs to a NOR gate SR latch are normally held at <span class="literal">0</span>, which maintains the current state, giving the output <em>Q</em>. Momentarily changing only <em>R</em> to <span class="literal">1</span> causes the state to go to reset, which changes the output to <em>Q</em> = <span class="literal">0</span>, as shown in the <em>Q<sub>next</sub></em> column of the state transition table. Momentarily changing only <em>S</em> to <span class="literal">1</span> causes the state to go to set, giving the output <em>Q</em> = <span class="literal">1</span>.</p>&#13;
<p class="indent">As described earlier, the input combination <em>S</em> = <em>R</em> = <span class="literal">1</span> is not allowed because that would cause an inconsistent state for the SR latch, as indicated in the prohibited rows of the state transition table by an x in the <em>Q<sub>next</sub></em> column.</p>&#13;
<span epub:type="pagebreak" id="page_131"/>&#13;
<h4 class="h4" id="ch07lev2sec2"><em><strong>SR Latch Using NAND Gates</strong></em></h4>&#13;
<p class="noindent">The physics of their construction tends to make NAND gates faster than NOR gates. Let’s start with the equation for the output of a NOR gate:</p>&#13;
<div class="image1"><img src="../images/pg159_Image_208.jpg" alt="Image" width="143" height="21"/></div>&#13;
<p class="indent">From De Morgan’s law, we get the following:</p>&#13;
<div class="image1"><img src="../images/pg159_Image_209.jpg" alt="Image" width="183" height="21"/></div>&#13;
<p class="noindent">This shows that a NAND gate is functionally equivalent to a NOR gate if we complement the two inputs, except that the output is complemented.</p>&#13;
<p class="indent">This leads to the circuit shown in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>, with ¬<em>S</em> and ¬<em>R</em> as the inputs. To emphasize the logical duality of the two designs, NAND and NOR, I have drawn the circuit with the output <em>Q</em> at the top and ¬<em>Q</em> on the bottom.</p>&#13;
<div class="image"><img id="ch7fig3" src="../images/pg159_Image_210.jpg" alt="Image" width="217" height="138"/></div>&#13;
<p class="figcap"><em>Figure 7-3: A NAND gate implementation of an SR latch</em></p>&#13;
<p class="indent">Like the NOR gate SR latch, the NAND gate SR latch is said to be in the set state when the outputs are <em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>; it’s in the reset state when <em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>. There are four possible input combinations:</p>&#13;
<p class="noindenta">¬<em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>,</strong> ¬<em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>: Keep current state</strong></p>&#13;
<p class="noindentina">If the latch is in the set state (<em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>), the upper NAND gate yields ¬(<span class="literal">1</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>, and the lower NAND gate yields ¬(<span class="literal">1</span> ∧ <span class="literal">1</span>) = <span class="literal">0</span>. If <em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>, the latch is in the reset state; the upper NAND gate yields ¬(<span class="literal">1</span> ∧ <span class="literal">1</span>) = <span class="literal">0</span>, and the lower NAND gate yields ¬(<span class="literal">0</span> ∧ <span class="literal">1</span>) = <span class="literal">1</span>. The cross feedback between the two NAND gates maintains the state of the latch.</p>&#13;
<p class="noindenta">¬<em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>,</strong> ¬<em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>: Set (</strong><em><strong>Q</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>)</strong></p>&#13;
<p class="noindentina">If the latch is in the reset state, the upper NAND gate yields ¬(<span class="literal">0</span> ∧ <span class="literal">1</span>) = <span class="literal">1</span>, thus changing <em>Q</em> to be <span class="literal">1</span>. This is fed back to the input of the lower NAND gate to yield ¬(<span class="literal">1</span> ∧ <span class="literal">1</span>) = <span class="literal">0</span>. The feedback from the output of the lower NAND gate to the input of the upper NAND gate keeps the output of the upper gate at ¬(<span class="literal">0</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>. The latch has moved into the set state (<em>Q</em> = <span class="literal">1</span> and ¬<em>Q</em> = <span class="literal">0</span>).</p>&#13;
<p class="indent1">If the latch is already in the set state, then the upper NAND gate yields ¬(<span class="literal">0</span> ∧ <em>mathtt</em>0) = <span class="literal">1</span>, and the output of the lower NAND gate is ¬(<span class="literal">1</span> ∧ <span class="literal">1</span>) = <span class="literal">0</span>. The latch thus remains in the set state.</p>&#13;
<p class="noindenta">¬<em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">1</span><strong>,</strong> ¬<em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>: Reset (</strong><em><strong>Q</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>)</strong></p>&#13;
<p class="noindentina">If the latch is in the set state, the lower NAND gate yields ¬(<span class="literal">1</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>. This is fed back to the input of the upper NAND gate, thereby making <span epub:type="pagebreak" id="page_132"/><em>Q</em> = ¬(<span class="literal">1</span> ∧ <span class="literal">1</span>) = <span class="literal">0</span>. The feedback from the output of the upper NAND gate to the input of the lower NAND gate keeps the output of the lower gate at ¬(<span class="literal">0</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>, so the latch moves into the reset state (<em>Q</em> = <span class="literal">0</span> and ¬<em>Q</em> = <span class="literal">1</span>).</p>&#13;
<p class="indent1">If the latch is already in the reset state, the lower NAND gate yields ¬(<span class="literal">0</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>, and the output of the upper NAND gate is ¬(<span class="literal">1</span> ∧ <span class="literal">1</span>) = <span class="literal">0</span>. The latch remains in the reset state.</p>&#13;
<p class="noindenta">¬<em><strong>S</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>,</strong> ¬<em><strong>R</strong></em> <strong>=</strong> <span class="codestrong">0</span><strong>: Not allowed</strong></p>&#13;
<p class="noindentina">If the latch is in the reset state, the upper NAND gate yields ¬(<span class="literal">0</span> ∧ <span class="literal">1</span>) = <span class="literal">1</span>. This is fed back to the input of the lower NAND gate to yield ¬(<span class="literal">1</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>. This would give <em>Q</em> = ¬<em>Q</em>, which is inconsistent.</p>&#13;
<p class="indent1">If the latch is in the set state, the lower NAND gate yields ¬(<span class="literal">1</span> ∧ <span class="literal">0</span>) = <span class="literal">1</span>. This is fed back to the input of the upper NAND gate to yield ¬(<span class="literal">0</span> ∧ <span class="literal">1</span>) = <span class="literal">1</span>. This would also give <em>Q</em> = ¬<em>Q</em>, which is inconsistent. Circuits must be designed to prevent this input combination.</p>&#13;
<p class="indenta"><a href="ch07.xhtml#ch7fig4">Figure 7-4</a> shows the behavior of a NAND gate SR latch using a state diagram.</p>&#13;
<div class="image"><img id="ch7fig4" src="../images/pg160_Image_211.jpg" alt="Image" width="591" height="130"/></div>&#13;
<p class="figcap"><em>Figure 7-4: A NAND gate SR latch</em></p>&#13;
<p class="indent">Comparing this with the NOR gate SR latch in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>, you can see that they both describe the same behavior. For example, an input of <em>SR</em> = <span class="literal">10</span> to the NOR gate SR latch will place it in the set state, while an input of</p>&#13;
<p class="indent">¬<em>S¬R</em> = <span class="literal">01</span> to the NAND gate SR latch will place it in the set state. I find that I have to think carefully about this when analyzing circuits. An off-by-one error when there are only two choices can cause behavior opposite to what I want.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab2">Table 7-2</a> is a state transition table for a NAND gate SR latch.</p>&#13;
<p class="tabcap" id="ch7tab2"><strong>Table 7-2:</strong> A NAND Gate SR Latch State Transition Table</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>¬</strong></em><strong><em>S</em></strong></th>&#13;
<th class="tab_th"><em><strong>¬</strong></em><strong><em>R</em></strong></th>&#13;
<th class="tab_th"><em><strong>Q</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong><strong><sub>next</sub></strong></em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">x</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">x</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span epub:type="pagebreak" id="page_133"/>&#13;
<p class="indent">Placing <span class="literal">0</span> on both inputs at the same time causes a problem—namely, that the outputs of both NAND gates would become <span class="literal">1</span>. In other words, <em>Q</em> = ¬<em>Q</em> = <span class="literal">1</span>, which is logically impossible. The circuit design must prevent this input combination. The x in the bottom two rows indicates an impossible condition.</p>&#13;
<p class="indent">The SR latch implemented with two NAND gates can be thought of as the complement of the NOR gate SR latch. The state is maintained by holding both ¬<em>S</em> and ¬<em>R</em> at <span class="literal">1</span>. Momentarily changing ¬<em>S</em> to <span class="literal">0</span> causes the state to be set with the output <em>Q</em> = <span class="literal">1</span>, and setting ¬<em>R</em> = <span class="literal">0</span> causes it to be reset with the output <em>Q</em> = <span class="literal">0</span>.</p>&#13;
<p class="indent">Thus far, we have been looking at a single latch. The problem here is that the state of the latch, and its output, will change whenever the input changes. In a computer, it would be interconnected with many other devices, each changing state with new inputs. It takes time for each device to change state and for its output(s) to propagate to the next device(s). The precise timing depends on slight manufacturing differences in the devices, so the results can be unreliable. We need a means for synchronizing the activity to bring some order to the operations. We’ll start by adding an <em>Enable</em> input to the SR latch, which will allow us to control more precisely when the inputs will be allowed to affect the state.</p>&#13;
<h4 class="h4" id="ch07lev2sec3"><em><strong>SR Latch with Enable</strong></em></h4>&#13;
<p class="noindent">We can get better control over the SR latch by adding two NAND gates to provide an <em>Enable</em> input. Connecting the outputs of these two NAND gates to the inputs of a ¬<em>S¬R</em> latch gives us a <em>gated SR latch</em>, as depicted in <a href="ch07.xhtml#ch7fig5">Figure 7-5</a>.</p>&#13;
<div class="image"><img id="ch7fig5" src="../images/pg161_Image_212.jpg" alt="Image" width="384" height="160"/></div>&#13;
<p class="figcap"><em>Figure 7-5: A gated SR latch</em></p>&#13;
<p class="indent">In this circuit, the outputs of both the control NAND gates remain at <span class="literal">1</span> as long as <em>Enable</em> = <span class="literal">0</span>. This sends ¬<em>S</em> = <span class="literal">1</span> and ¬<em>R</em> = <span class="literal">1</span> to the inputs of the ¬<em>S¬R</em> latch portion of this circuit, which causes the state to remain the same. By AND-ing the additional <em>Enable</em> input with the <em>S</em> and <em>R</em> input lines, we can control the time when the state should be changed to the next value.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab3">Table 7-3</a> shows the state behavior of the SR latch with the <em>Enable</em> control.</p>&#13;
<span epub:type="pagebreak" id="page_134"/>&#13;
<p class="tabcap" id="ch7tab3"><strong>Table 7-3:</strong> A Gated SR Latch State Transition Table</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>Enable</strong></em></th>&#13;
<th class="tab_th"><em><strong>S</strong></em></th>&#13;
<th class="tab_th"><em><strong>R</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong><strong><sub>next</sub></strong></em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">—</td>&#13;
<td class="bg1">—</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg">—</td>&#13;
<td class="bg">—</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">x</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">x</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7tab3">Table 7-3</a>, a — indicates that an input does not matter and an x indicates a prohibited result. As explained earlier, the design must prevent input combinations that would produce prohibited results. The state of the latch can follow the <em>S</em> and <em>R</em> inputs only when <em>Enable</em> = <span class="literal">1</span>. Such a device is said to be <em>level-triggered</em>.</p>&#13;
<p class="indent">In the next section, I’ll simplify the gated SR latch and create a latch that takes a single data input, <em>D</em>, with control over when this input will affect the state of the latch.</p>&#13;
<h4 class="h4" id="ch07lev2sec4"><em><strong>The D Latch</strong></em></h4>&#13;
<p class="noindent">A <em>D latch</em> allows us to store the value of 1 bit. We start with the truth table in <a href="ch07.xhtml#ch7tab4">Table 7-4</a>, which includes the rows from <a href="ch07.xhtml#ch7tab3">Table 7-3</a> where <em>Enable</em> = <span class="literal">1</span> and <em>R</em> = ¬<em>S</em>.</p>&#13;
<p class="tabcap" id="ch7tab4"><strong>Table 7-4:</strong> A Truth Table for a D Latch with <em>Enable</em></p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:10%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>Enable</strong></em></th>&#13;
<th class="tab_th"><em><strong>S</strong></em></th>&#13;
<th class="tab_th"><em><strong>R</strong></em></th>&#13;
<th class="tab_th"><em><strong>D</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong></em></th>&#13;
<th class="tab_th"><em><strong>Q</strong><strong><sub>next</sub></strong></em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">—</td>&#13;
<td class="bg1">—</td>&#13;
<td class="bg1">—</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg">—</td>&#13;
<td class="bg">—</td>&#13;
<td class="bg">—</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We’re looking for a design that will have two inputs: one for <em>Enable</em> and the other for <em>D</em> (short for data). We want <em>D</em> = <span class="literal">1</span> to set the state, giving the output <em>Q</em> = <span class="literal">1</span>, and <em>D</em> = <span class="literal">0</span> to reset it, giving the output <em>Q</em> = <span class="literal">0</span>, when the <em>Enable</em> line becomes <span class="literal">1</span>. The value of <em>D</em> should have no effect on the state when <em>Enable</em> = <span class="literal">0</span>.</p>&#13;
<span epub:type="pagebreak" id="page_135"/>&#13;
<p class="indent">We can construct a gated D latch from a gated SR latch by adding a NOT gate, as shown in <a href="ch07.xhtml#ch7fig6">Figure 7-6</a>.</p>&#13;
<div class="image"><img id="ch7fig6" src="../images/pg163_Image_213.jpg" alt="Image" width="482" height="178"/></div>&#13;
<p class="figcap"><em>Figure 7-6: A gated D latch constructed from an SR latch</em></p>&#13;
<p class="indent">The one data input, <em>D</em>, is fed to the <em>S</em> side of the SR latch; the complement of the data value is fed to the <em>R</em> side.</p>&#13;
<p class="indent">Now, we have a circuit that can store 1 bit of data using the <em>D</em> input and can be synchronized with other operations using the <em>Enable</em> input. However, there are some problems with the D latch. The state of a D latch can be affected by the input while the D latch is enabled. Thus, its output can change while the latch is enabled, making it difficult to synchronize reliably with other devices.</p>&#13;
<p class="indent">This scheme does work well when the latch should remain in one state for an extended period. In general, latches work for operations where we want to select a state and leave it for a period of time that is not synchronized with other operations in the computer. An example is an I/O port, where the timing is dependent on the behavior of the device connected to the port. For instance, a running program cannot know when the user will press a key on the keyboard. When a key is pressed, the program may not be ready for the character, so the binary code for the character should be latched at the input port. Once the character code is stored at the input port, the latch will be disabled until the program reads the character code from the latch.</p>&#13;
<p class="indent">Most of the computing operations within the CPU and main memory must be coordinated in time. Connecting many circuits to the same clock signal allows us to synchronize their operations. Let’s consider how we might synchronize a D latch connected in a circuit. We could feed an input to this D latch and enable the latch with a clock signal, but its output can change if the input changes, making its output unreliable during the time it’s enabled. If the output from our D latch is connected to the input of another device, the input to this second device is thus unreliable while our D latch is enabled. To avoid this problem and provide a reliable input, we should disable our D latch once it has settled.</p>&#13;
<p class="indent">It also takes some time, called <em>propagation delay</em>, for the output of our D latch to reach the input of the second device, due to the physics of the connections. So, this second device should be disabled until the input to our D latch is reliable and we have allowed for the propagation delay.</p>&#13;
<span epub:type="pagebreak" id="page_136"/>&#13;
<p class="indent">While the second device is disabled and waiting for a reliable input from our D latch, its output (from the previous clock cycle) is reliable. So, if it’s connected to the input of yet another device, this third device can be enabled. This leads to a scheme where every other device is enabled, while the alternate devices are disabled. After waiting for a period equal to the sum of the longest settling time and propagation delay time of all the devices connected together, the disabled devices are enabled and the enabled devices are disabled. The digital <span class="literal">1</span>s and <span class="literal">0</span>s are propagated through this circuit of devices by means of this alternating enable/disable cycle.</p>&#13;
<p class="indent">As you can probably imagine, coordinating this flipping back and forth between enabled and disabled can be difficult. I’ll give you a solution to this problem in the next section.</p>&#13;
<h3 class="h3" id="ch07lev1sec2"><strong>Flip-Flops</strong></h3>&#13;
<p class="noindent">While a latch could be controlled by the levels of a clock signal, its output would be affected by any changes in its input during the portion of time when the clock signal enables the latch. A <em>flip-flop</em> provides an output at a specific time in the clock cycle, such as when the clock signal transitions from <span class="literal">0</span> to <span class="literal">1</span>. Because the output becomes available at a clock signal transition point, it is said to be <em>edge triggered</em>. After the trigger event, the output of a flip-flop remains throughout the duration of the clock cycle. This provides the reliability needed to connect many flip-flops in a circuit and synchronize their operations with one clock. I’ll start this section with a discussion of clocks, and then we’ll look at a few examples of flip-flops.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The terminology varies. Some people also call latches</em> flip-flops<em>. I will use the term</em> latch <em>to mean a level-triggered device, with no timing considerations, and</em> flip-flop <em>to mean an edge-triggered device controlled by a clock signal.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch07lev2sec5"><em><strong>Clocks</strong></em></h4>&#13;
<p class="noindent">Sequential logic circuits have a time history, summarized in their state. We keep track of time with a <em>clock</em>, a device that provides an electronic <em>clock signal</em>. This is typically a square wave that alternates between the <span class="literal">0</span> and <span class="literal">1</span> levels, as shown in <a href="ch07.xhtml#ch7fig7">Figure 7-7</a>. This signal is used as the enabling/disabling input to devices that need to be synchronized.</p>&#13;
<div class="image"><img id="ch7fig7" src="../images/pg164_Image_214.jpg" alt="Image" width="187" height="56"/></div>&#13;
<p class="figcap"><em>Figure 7-7: A typical clock signal used to synchronize sequential logic circuits</em></p>&#13;
<p class="indent">In order to achieve reliable behavior, most synchronous circuits use edge-triggered devices. The amount of time spent at each level is usually the <span epub:type="pagebreak" id="page_137"/>same, and either the positive-going (<span class="literal">0</span> to <span class="literal">1</span>) or negative-going (<span class="literal">1</span> to <span class="literal">0</span>) edge of a clock signal may be used.</p>&#13;
<p class="indent">The clock frequency must be slow enough that the circuit elements have time to complete their operations before the next clock transition occurs. For example, reliable operation of a latch or flip-flop requires that the input signal be stable for a period of time, called the <em>setup time</em>, before the device is enabled. The input signal must remain stable for another period of time, the <em>hold time</em>, after the start of the enabling signal. In practice, these times can vary with temperature, manufacturing variations, and so forth. Hardware designers need to consult manufacturers’ specifications for the limits of these time values.</p>&#13;
<p class="indent">Let’s look at a few examples of flip-flop circuits that can be controlled by a clock.</p>&#13;
<h4 class="h4" id="ch07lev2sec6"><em><strong>D Flip-Flop</strong></em></h4>&#13;
<p class="noindent">We’ll begin by connecting a clock signal to the <em>Enable</em> input of the gated D latch in <a href="ch07.xhtml#ch7fig6">Figure 7-6</a>. Here, the input affects the output as long as <em>Enable</em> = <span class="literal">1</span>. The problem is that if the input changes while <em>Enable</em> = <span class="literal">1</span>, the output will also change, leading to an unreliable design.</p>&#13;
<p class="indent">One way to isolate the output from input changes is to connect the outputs of our D latch to the inputs of an SR latch in a primary/secondary configuration, as shown in <a href="ch07.xhtml#ch7fig8">Figure 7-8</a>.</p>&#13;
<div class="image"><img id="ch7fig8" src="../images/pg165_Image_215.jpg" alt="Image" width="688" height="233"/></div>&#13;
<p class="figcap"><em>Figure 7-8: A D flip-flop, positive-edge triggering</em></p>&#13;
<p class="indent">The primary portion of the D flip-flop processes the input and provides a reliable input to the secondary portion for final output. The bit we want to store, <span class="literal">0</span> or <span class="literal">1</span>, is fed to the <em>D</em> input of the D latch, and the clock signal is fed to the <em>CLK</em> input. The uncomplemented output of the D latch is fed to the <em>S</em> input, and its complemented output is fed to the <em>R</em> input of the SR latch. The final output of the D flip-flop is the output from the SR latch.</p>&#13;
<p class="indent">I’ll walk you through how this circuit works. The behavior of the primary portion is shown in the truth table for a D latch in <a href="ch07.xhtml#ch7tab4">Table 7-4</a>. The behavior of the secondary portion is shown in the truth table for an SR latch in <a href="ch07.xhtml#ch7tab3">Table 7-3</a>. <a href="ch07.xhtml#ch7fig9">Figure 7-9</a> shows the timing of the key points in our D flip-flop.</p>&#13;
<span epub:type="pagebreak" id="page_138"/>&#13;
<div class="image"><img id="ch7fig9" src="../images/pg166_Image_216.jpg" alt="Image" width="670" height="302"/></div>&#13;
<p class="figcap"><em>Figure 7-9: The timing of a D flip-flop</em></p>&#13;
<p class="indent">The data input, <em>D</em>, in <a href="ch07.xhtml#ch7fig9">Figure 7-9</a> is not in complete synchrony with the clock signal, and its timing is somewhat irregular. This can occur due to propagation delays, interference from other components, temperature gradients in the circuits, and other factors.</p>&#13;
<p class="indent">We’ll start at the point where CLK first goes to <span class="literal">0</span>. This signal is inverted, which enables the D latch. The output of the D latch, <em>S</em>, follows the <em>D</em> input, going from <span class="literal">0</span> to <span class="literal">1</span>. The second inverter in the CLK path to the SR latch disables it, latching the flip-flop output, <em>Q</em>, at the <span class="literal">0</span> level.</p>&#13;
<p class="indent">When the CLK signal goes to <span class="literal">1</span>, the D latch is disabled, which latches its outputs, <em>S</em> and <em>R</em>, at <span class="literal">1</span> and <span class="literal">0</span>. This presents stable inputs to the SR latch during this clock half-cycle. The twice-inverted CLK signal enables the SR latch, which causes the output of the flip-flop, <em>Q</em>, to go to <span class="literal">1</span>.</p>&#13;
<p class="indent">The CLK signal then goes to <span class="literal">0</span>, disabling the SR latch in the secondary portion, which remains latched at the <span class="literal">1</span> level for this clock half-cycle.</p>&#13;
<p class="indent">Thus, the flip-flop introduces a time delay of one-half clock cycle between accepting an input and providing an output, but the output is stable for an entire clock period. The output is available at a precise point in time, the <span class="literal">0</span> to <span class="literal">1</span> transition. This is called <em>positive-edge triggering</em>. If the first NOT gate connected to the CLK signal in <a href="ch07.xhtml#ch7fig8">Figure 7-8</a> were removed, we would have a D flip-flop with <em>negative-edge triggering</em>.</p>&#13;
<p class="indent">Sometimes a flip-flop must be set to a known value before the clocking begins—for example, when a computer is first starting up. These known values are input independently of the clock process; hence, they are <em>asynchronous inputs</em>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig10">Figure 7-10</a> shows a D flip-flop with an <em>asynchronous preset</em> (<em>PR</em>) input added to it.</p>&#13;
<span epub:type="pagebreak" id="page_139"/>&#13;
<div class="image"><img id="ch7fig10" src="../images/pg167_Image_217.jpg" alt="Image" width="686" height="263"/></div>&#13;
<p class="figcap"><em>Figure 7-10: A positive-edge triggering D flip-flop with an asynchronous preset</em></p>&#13;
<p class="indent">When a <span class="literal">1</span> is applied to the <em>PR</em> input, <em>Q</em> becomes <span class="literal">1</span> and ¬<em>Q</em> becomes <span class="literal">0</span>, regardless of what the other inputs are—even CLK. It is also common to have an asynchronous clear input (<em>CLR</em>) that sets the state (and output) to <span class="literal">0</span>.</p>&#13;
<p class="indent">There are more efficient circuits for implementing edge-triggered D flip-flops, but this discussion shows that they can be constructed from ordinary logic gates. They are economical and efficient, so they are widely used in <em>very large scale integration (VLSI)</em> circuits, which are circuits that include billions of transistor gates on a single semiconductor microchip.</p>&#13;
<p class="indent">Rather than draw the implementation details for each D flip-flop, circuit designers use the symbols shown in <a href="ch07.xhtml#ch7fig11">Figure 7-11</a>.</p>&#13;
<div class="image"><img id="ch7fig11" src="../images/pg167_Image_218.jpg" alt="Image" width="376" height="221"/></div>&#13;
<p class="figcap"><em>Figure 7-11: The symbols used for D flip-flops: (a) positive-edge triggering, (b) negative-edge triggering</em></p>&#13;
<p class="indent">The various inputs and outputs are labeled in <a href="ch07.xhtml#ch7fig11">Figure 7-11</a>. Hardware designers typically use <em>Ǭ</em> instead of ¬<em>Q</em>. It’s common to label the flip-flop as <em>Qn</em>, where <em>n</em> = 1, 2, . . . , which is used to identify the flip-flop within the overall circuit. The small circle at the clock input in <a href="ch07.xhtml#ch7fig11">Figure 7-11</a>(b) means that this D flip-flop is triggered by a negative-going clock transition.</p>&#13;
<p class="indent">Now that you’ve seen some logic components that save state, let’s look at the process of designing sequential logic circuits using these components.</p>&#13;
<span epub:type="pagebreak" id="page_140"/>&#13;
<h3 class="h3" id="ch07lev1sec3"><strong>Designing Sequential Logic Circuits</strong></h3>&#13;
<p class="noindent">We’ll consider a general set of steps for designing sequential logic circuits. Design in any field is usually iterative, as you have no doubt learned from your programming experience. You start with a design, analyze it, and then refine the design to make it faster, less expensive, and so on. After you’ve gained some experience, the design process usually requires fewer iterations.</p>&#13;
<p class="indent">The following steps are a good method for building a first working design:</p>&#13;
<ol>&#13;
<li class="noindent">From the plain-language description of the problem, create a state transition table and state diagram showing what the circuit must do. These form the basic technical specifications for the circuit you will be designing.</li>&#13;
<li class="noindent">Choose a binary code for the states and create a binary-coded version of the state table and/or state diagram. For <em>N</em> states, the code will need log<sub>2</sub> <em>N</em> bits. Any code will work, but some codes may lead to simpler combinational logic in the circuit.</li>&#13;
<li class="noindent">Choose a type of flip-flop. This choice is often dictated by the components you have on hand.</li>&#13;
<li class="noindent">Determine the inputs required to each flip-flop to cause each of the required transitions.</li>&#13;
<li class="noindent">Simplify the inputs to each flip-flop. Karnaugh maps or algebraic methods are good tools for the simplification process.</li>&#13;
<li class="noindent">Draw the circuit.</li>&#13;
</ol>&#13;
<p class="indent">Step 5 may cause you to rethink your choice of type of flip-flop. The three steps of flip-flop choice, determining inputs, and simplification may need to be repeated several times to reach a good design. The following two examples illustrate this process. You can think of these as guided “Your Turn” exercises; if you have access to a digital circuit simulator, or the required hardware, I suggest you use those resources to follow along.</p>&#13;
<h4 class="h4" id="ch07lev2sec7"><em><strong>A Counter</strong></em></h4>&#13;
<p class="noindent">We want to design a counter that has an <em>Enable</em> input. When <em>Enable</em> = <span class="literal">1</span>, it increments through the sequence 0, 1, 2, 3, 0, 1, . . . , incrementing with each clock tick. <em>Enable</em> = <span class="literal">0</span> causes the counter to remain in its current state. The output is the sequence number in 2-bit binary. Here are the steps:</p>&#13;
<p class="noindenta"><strong>Step 1: Create a state transition table and state diagram.</strong></p>&#13;
<p class="noindentina">At each clock tick, the counter increments by 1 if <em>Enable</em> = <span class="literal">1</span>. If <em>Enable</em> = <span class="literal">0</span>, it remains in the current state. <a href="ch07.xhtml#ch7fig12">Figure 7-12</a> shows the four states—0, 1, 2, and 3—and the corresponding 2-bit output for each state.</p>&#13;
<span epub:type="pagebreak" id="page_141"/>&#13;
<div class="image"><img id="ch7fig12" src="../images/pg169_Image_219.jpg" alt="Image" width="537" height="217"/></div>&#13;
<p class="figcap"><em>Figure 7-12: A state diagram for a counter that cycles through 0, 1, 2, 3, 0, 1, . . .</em></p>&#13;
<p class="indent1"><a href="ch07.xhtml#ch7tab5">Table 7-5</a> shows the state transition table for this counter.</p>&#13;
<p class="tabcap" id="ch7tab5"><strong>Table 7-5:</strong> A State Transition Table for the Counter</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"/>&#13;
<th class="tab_th"><strong><em>Enable</em></strong> = <span class="codestrong">0</span></th>&#13;
<th class="tab_th"><strong><em>Enable</em></strong> = <span class="codestrong">1</span></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="tab_th"><strong>Current <em><strong>n</strong></em></strong></th>&#13;
<th class="tab_th"><strong>Next <em><strong>n</strong></em></strong></th>&#13;
<th class="tab_th"><strong>Next <em><strong>n</strong></em></strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg">1</td>&#13;
<td class="bg">2</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1">3</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">3</td>&#13;
<td class="bg">3</td>&#13;
<td class="bg">0</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindentin">When <em>Enable</em> = <span class="literal">0</span>, the counter is essentially turned off; when <em>Enable</em> = <span class="literal">1</span>, the counter automatically increments by 1, wrapping around to 0 after it reaches its limit of 3.</p>&#13;
<p class="noindenta"><strong>Step 2: Create a binary-coded version of the state table/state diagram.</strong></p>&#13;
<p class="noindentin">With four states, we need 2 bits. We’ll let <em>n</em> be the state, which we represent with the 2-bit binary number <em>n</em><sub>1</sub><em>n</em><sub>0</sub>. <a href="ch07.xhtml#ch7tab6">Table 7-6</a> shows the behavior.</p>&#13;
<p class="tabcap" id="ch7tab6"><strong>Table 7-6:</strong> A State Transition Table for a 2-Bit Counter</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"/>&#13;
<th class="tab_th" colspan="2"><strong>Current</strong></th>&#13;
<th class="tab_th" colspan="2"><strong>Next</strong></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>Enable</em></strong></th>&#13;
<th class="tab_th"><strong><em>n</em></strong><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>n</strong></em><sub>0</sub></th>&#13;
<th class="tab_th"><em><strong>n</strong></em><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>n</strong></em><sub>0</sub></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span epub:type="pagebreak" id="page_142"/>&#13;
<p class="noindenta"><strong>Step 3: Select a flip-flop.</strong></p>&#13;
<p class="noindentina">We’ll use D flip-flops. After going through the design, we may decide that another flip-flop might work better. We could then come back to this step and go through the remaining steps again. An experienced designer may have some insight into the problem that would suggest starting with another type of flip-flop. Often, any potential savings in cost or power consumption do not justify changing to another type of flip-flop.</p>&#13;
<p class="noindenta"><strong>Step 4: Determine the inputs to the flip-flops.</strong></p>&#13;
<p class="noindentin">We need two flip-flops, one for each bit. A D flip-flop simply stores the value of its input on the next clock cycle, so the inputs that cause each flip-flop to change to the next state are shown under the two “Next” columns in <a href="ch07.xhtml#ch7tab6">Table 7-6</a>.</p>&#13;
<p class="indent1">We can write the Boolean equations that show the logical combinations of the inputs, <em>Enable</em> and the current <em>n</em><sub>1</sub> and <em>n</em><sub>0</sub>, that produce the required inputs. We’ll use <em>E</em> for <em>Enable</em> and <em>D</em><sub>1</sub> and <em>D</em><sub>0</sub> for the inputs to the respective D flip-flops:</p>&#13;
<div class="image1"><img src="../images/pg170_Image_220.jpg" alt="Image" width="460" height="113"/></div>&#13;
<p class="noindenta"><strong>Step 5: Simplify the required inputs.</strong></p>&#13;
<p class="noindentina">We can use Karnaugh maps to find a simpler solution, as shown in <a href="ch07.xhtml#ch7fig13">Figure 7-13</a>.</p>&#13;
<div class="image"><img id="ch7fig13" src="../images/pg170_Image_221.jpg" alt="Image" width="619" height="142"/></div>&#13;
<p class="figcap"><em>Figure 7-13: Karnaugh maps for a 2-bit counter implemented with D flip-flops</em></p>&#13;
<p class="indent1">The Karnaugh maps allow us to simplify the Boolean equations for the input to each flip-flop:</p>&#13;
<div class="image1"><img src="../images/pg170_Image_222.jpg" alt="Image" width="527" height="51"/></div>&#13;
<p class="noindenta"><strong>Step 6: Draw the circuit.</strong></p>&#13;
<p class="noindentina">We’ll use a PLA (introduced in “Programmable Logic Array” on <a href="ch06.xhtml#ch06lev2sec5">page 120</a> in <a href="ch06.xhtml">Chapter 6</a>) to generate the inputs to the two D flip-flops. <a href="ch07.xhtml#ch7fig14">Figure 7-14</a> shows our resulting circuit used to implement this counter.<span epub:type="pagebreak" id="page_143"/></p>&#13;
<div class="image"><img id="ch7fig14" src="../images/pg171_Image_223.jpg" alt="Image" width="655" height="544"/></div>&#13;
<p class="figcap"><em>Figure 7-14: A 2-bit counter implemented with a PLA and two D flip-flops</em></p>&#13;
<p class="indent1"><a href="ch07.xhtml#ch7fig15">Figure 7-15</a> shows the timing of the binary counter when progressing through the sequence 3, 0, 1, 2, 3 (<span class="literal">11, 00, 01, 10, 11</span>).</p>&#13;
<div class="image"><img id="ch7fig15" src="../images/pg171_Image_224.jpg" alt="Image" width="651" height="331"/></div>&#13;
<p class="figcap"><em>Figure 7-15: The timing of a 2-bit counter implemented with D flip-flops</em><span epub:type="pagebreak" id="page_144"/></p>&#13;
<p class="indent1"><em>D<sub>i</sub></em> is the input to the <em>i</em>th D flip-flop, and <em>n<sub>i</sub></em> is its output. Remember that when the <em>i</em>th input, <em>D<sub>i</sub></em>, is applied to its D flip-flop, the output of the flip-flop does not change until the second half of the clock cycle. This can be seen when comparing the trace for the corresponding output, <em>n<sub>i</sub></em>, in the figure.</p>&#13;
<h4 class="h4" id="ch07lev2sec8"><em><strong>A Branch Predictor</strong></em></h4>&#13;
<p class="noindent">For our second example, we’ll design a branch predictor. This example is a bit more complicated than the previous one.</p>&#13;
<p class="indent">Except for very inexpensive microcontrollers, most modern CPUs execute instructions in stages. Each stage consists of hardware that is specialized to perform the operations in that stage. An instruction passes through each stage in an assembly-line fashion. For example, if you were to create an assembly line to manufacture wooden chairs, you could do it in three stages: saw the wood to make the parts for the chair, assemble the parts, and paint the chair. The hardware needed at each stage would be saw, hammer and screwdriver, and paintbrush.</p>&#13;
<p class="indent">The arrangement of specialized hardware in the CPU is called a <em>pipeline</em>. The hardware in the first stage is designed to fetch an instruction from memory, as you’ll see in <a href="ch09.xhtml">Chapter 9</a>. After an instruction is fetched from memory, it passes on to the next stage of the pipeline, where it is decoded. Simultaneously, the first stage of the pipeline fetches the next instruction from memory. The result is that the CPU is working on several instructions at the same time. This provides some parallelism, thus improving execution speed.</p>&#13;
<p class="indent">Almost all programs contain <em>conditional branch points</em>—places where the next instruction to be fetched can be in one of two different memory locations. Unfortunately, there is no way to know which of the two instructions to fetch until the decision-making instruction has moved several stages into the pipeline.</p>&#13;
<p class="indent">To maintain execution speed, as soon as a conditional branch instruction has passed on from the fetch stage, it’s helpful if the CPU can predict where to fetch the next instruction from. Then it can go ahead and do so. If the prediction was wrong, the CPU simply ignores the work it has done on the predicted instruction by flushing out the pipeline and fetching the other instruction, which enters the beginning of the pipeline.</p>&#13;
<p class="indent">In this section, we’ll design a circuit that predicts whether a conditional branch will be taken. The predictor will continue to predict the same outcome, and the branch will be either taken or not taken, until it makes two mistakes in a row.</p>&#13;
<span epub:type="pagebreak" id="page_145"/>&#13;
<p class="indent">Here are the steps we will follow in designing our branch predictor circuit:</p>&#13;
<p class="noindenta"><strong>Step 1: Create a state table and state diagram.</strong></p>&#13;
<p class="noindentina">We’ll use Yes to indicate when the branch is taken and No to indicate when it isn’t. The state diagram in <a href="ch07.xhtml#ch7fig16">Figure 7-16</a> shows the four possible states.</p>&#13;
<div class="image"><img id="ch7fig16" src="../images/pg173_Image_225.jpg" alt="Image" width="414" height="308"/></div>&#13;
<p class="figcap"><em>Figure 7-16: The four possible states for our branch predictor</em></p>&#13;
<p class="indent1">Let’s begin in the No state. Here, the branch was not taken at least the last two times this instruction was executed. The output is to predict that it will also not be taken this time. The input to the circuit is whether the branch has actually been taken when the instruction has completed execution.</p>&#13;
<p class="indent1">The arc labeled Actual = Not Taken in <a href="ch07.xhtml#ch7fig16">Figure 7-16</a> loops back to the No state, with the prediction (the output) that the branch will not be taken the next time the instruction is executed. If the branch is taken, the Actual = Taken arc shows that the circuit moves into the No–Error state to indicate one error in the prediction. But because it must be wrong twice in a row to change our prediction, the circuit is still predicting Don’t Take as the output.</p>&#13;
<p class="indent1">From the No–Error state, if the branch is not taken (the prediction is correct), the circuit returns to the No state. However, if the branch is taken, the circuit predicted incorrectly twice in a row, so the circuit moves to the Yes state and the output is to predict Take.</p>&#13;
<span epub:type="pagebreak" id="page_146"/>&#13;
<p class="indent1">I’ll leave tracing through the remainder of this state diagram as an exercise for you. Once you’re satisfied with how it works, take a look at <a href="ch07.xhtml#ch7tab7">Table 7-7</a>, which provides the technical specifications for our circuit.</p>&#13;
<p class="tabcap" id="ch7tab7"><strong>Table 7-7:</strong> The Branch Predictor State Table</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:10%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"/>&#13;
<th class="tab_th"/>&#13;
<th class="tab_th" colspan="2"><strong>Actual = Not Taken</strong></th>&#13;
<th class="tab_th" colspan="2"><strong>Actual = Taken</strong></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="tab_th"><strong>Current state</strong></th>&#13;
<th class="tab_th"><strong>Prediction</strong></th>&#13;
<th class="tab_th"><strong>Next state</strong></th>&#13;
<th class="tab_th"><strong>Prediction</strong></th>&#13;
<th class="tab_th"><strong>Next state</strong></th>&#13;
<th class="tab_th"><strong>Prediction</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">No</td>&#13;
<td class="bg1">Don’t Take</td>&#13;
<td class="bg1">No</td>&#13;
<td class="bg1">Don’t Take</td>&#13;
<td class="bg1">No–Error</td>&#13;
<td class="bg1">Don’t Take</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">No–Error</td>&#13;
<td class="bg">Don’t Take</td>&#13;
<td class="bg">No</td>&#13;
<td class="bg">Don’t Take</td>&#13;
<td class="bg">Yes</td>&#13;
<td class="bg">Take</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Yes–Error</td>&#13;
<td class="bg1">Take</td>&#13;
<td class="bg1">No</td>&#13;
<td class="bg1">Don’t Take</td>&#13;
<td class="bg1">Yes</td>&#13;
<td class="bg1">Take</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Yes</td>&#13;
<td class="bg">Take</td>&#13;
<td class="bg">Yes–Error</td>&#13;
<td class="bg">Take</td>&#13;
<td class="bg">Yes</td>&#13;
<td class="bg">Take</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent1">When the result of the conditional branch (taken or not taken) is determined in the pipeline, <a href="ch07.xhtml#ch7tab7">Table 7-7</a> shows the next state and the corresponding prediction. This prediction will be used to determine which of the two possible addresses—the address of the next instruction or the address of the branch target—to store for use the next time this instruction is encountered in the program.</p>&#13;
<p class="noindenta"><strong>Step 2: Represent the states.</strong></p>&#13;
<p class="noindentina">For this problem, we’ll choose a binary code for the state, <em>s</em><sub>1</sub><em>s</em><sub>0</sub>, as shown in <a href="ch07.xhtml#ch7tab8">Table 7-8</a>.</p>&#13;
<p class="tabcap" id="ch7tab8"><strong>Table 7-8:</strong> The States of the Branch Predictor</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>State</strong></th>&#13;
<th class="tab_th"><em><strong>s</strong></em><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>s</strong></em><sub>0</sub></th>&#13;
<th class="tab_th"><strong>Prediction</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">No</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">Don’t Take</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">No–Error</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">Don’t Take</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Yes–Error</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">Take</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Yes</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">Take</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent1">The prediction is 1 bit, <em>s</em><sub>1</sub>, which is <span class="literal">0</span> if the prediction is Don’t Take and <span class="literal">1</span> if the prediction is Take.</p>&#13;
<p class="indent1">Letting the input, Actual, be <span class="literal">0</span> when the branch is not taken and <span class="literal">1</span> when it is taken and using the state notation of <a href="ch07.xhtml#ch7tab8">Table 7-8</a>, we get the state transition table shown in <a href="ch07.xhtml#ch7tab9">Table 7-9</a>.</p>&#13;
<span epub:type="pagebreak" id="page_147"/>&#13;
<p class="tabcap" id="ch7tab9"><strong>Table 7-9:</strong> The State Transition Table for the Branch Predictor</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"/>&#13;
<th class="tab_th" colspan="2"><strong>Current</strong></th>&#13;
<th class="tab_th" colspan="2"><strong>Next</strong></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="tab_th"><strong>Actual</strong></th>&#13;
<th class="tab_th"><em><strong>s</strong></em><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>s</strong></em><sub>0</sub></th>&#13;
<th class="tab_th"><em><strong>s</strong></em><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>s</strong></em><sub>0</sub></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent1">When the conditional branch instruction reaches a point in the pipeline where it is determined whether the branch should be taken or not, this information is used as the input, Actual, to the predictor circuit, which transforms the state from Current to Next for the next time this instruction is encountered.</p>&#13;
<p class="noindenta"><strong>Step 3: Select a flip-flop.</strong></p>&#13;
<p class="noindentin">We’ll use D flip-flops again here, with the same caveats as in the previous example.</p>&#13;
<p class="noindenta"><strong>Step 4: Determine the inputs to the flip-flops.</strong></p>&#13;
<p class="noindentin">We need two flip-flops, one for each bit. A D flip-flop simply stores the value of its input on the next clock cycle, so the inputs that cause each flip-flop to change to the next state are shown under the two “Next” columns in <a href="ch07.xhtml#ch7tab9">Table 7-9</a>.</p>&#13;
<p class="indent1">We can write the Boolean equations that show the logical combinations of the three signals, Actual and the Current <em>s</em><sub>1</sub> and <em>s</em><sub>0</sub> that produce the required input to each D flip-flop to cause it to go to the Next <em>s</em><sub>1</sub> and <em>s</em><sub>0</sub>. We’ll use <em>A</em> for Actual and <em>D</em><sub>1</sub> and <em>D</em><sub>0</sub> for the inputs to the respective D flip-flops:</p>&#13;
<div class="image1"><img src="../images/pg175_Image_226.jpg" alt="Image" width="412" height="114"/></div>&#13;
<span epub:type="pagebreak" id="page_148"/>&#13;
<p class="noindenta"><strong>Step 5: Simplify the required inputs.</strong></p>&#13;
<p class="noindentina">We’ll start by using the following Boolean identities:</p>&#13;
<div class="image1"><img src="../images/pg176_Image_227.jpg" alt="Image" width="510" height="113"/></div>&#13;
<p class="noindentin">Our equations become:</p>&#13;
<div class="image1"><img src="../images/pg176_Image_228.jpg" alt="Image" width="379" height="51"/></div>&#13;
<p class="noindenta"><strong>Step 6: Draw the circuit.</strong></p>&#13;
<p class="noindentina">In this circuit, the input is Actual = <span class="literal">0</span> if the branch was not taken the last time and Actual = <span class="literal">1</span> if it was taken. As with our counter, we’ll use a PLA with our two D flip-flops, as shown in <a href="ch07.xhtml#ch7fig17">Figure 7-17</a>.</p>&#13;
<div class="image"><img id="ch7fig17" src="../images/pg176_Image_229.jpg" alt="Image" width="647" height="486"/></div>&#13;
<p class="figcap"><em>Figure 7-17: The branch predictor circuit using a PLA and two D flip-flops</em></p>&#13;
<p class="indent">This example shows the simplest method of branch prediction. More complex methods exist, and there is also ongoing research into branch prediction’s effectiveness. Although it can speed up some algorithms, the <span epub:type="pagebreak" id="page_149"/>additional hardware required for branch prediction consumes more electrical power, which is a concern in battery-powered devices.</p>&#13;
<p class="indent">We used D flip-flops and PLAs in both of these example designs, but as usual, the choice of components depends on multiple factors: cost, availability of components, design tools, design time, power usage, and so forth.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch7exe1">7.1     Redesign the 2-bit counter in <a href="ch07.xhtml#ch7fig14">Figure 7-14</a> to use individual gates instead of a PLA.</p>&#13;
<p class="box-list" id="ch7exe2">7.2     Redesign the branch predictor in <a href="ch07.xhtml#ch7fig17">Figure 7-17</a> to use individual gates instead of a PLA.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec4"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Sequential logic circuits</strong>   These depend on both the current and past inputs. They have a time history, which can be summarized by the current state of the circuit.</p>&#13;
<p class="noindentin"><strong>Latch</strong>   A device that stores 1 bit of data. The ability to change the value of the bit is controlled by the level of an enabling signal; this is called level triggering.</p>&#13;
<p class="noindentin"><strong>Flip-flop</strong>   A device that stores 1 bit of data. The ability to change the value of the bit is controlled by the transition of a clock signal; this is called edge triggering.</p>&#13;
<p class="noindentin"><strong>SR latch</strong>   The state of an SR latch depends on its input and is either set or reset.</p>&#13;
<p class="noindentin"><strong>D flip-flop</strong>   A D flip-flop stores 1 bit of data. By connecting two latches in a primary–secondary configuration, the output is isolated from the input, allowing a flip-flop to be synchronized with a clock signal. The output of a D flip-flop can be changed only once per clock cycle.</p>&#13;
<p class="indenta">You saw two examples of designing sequential logic circuits with D flip-flops and PLAs in this chapter. In the next chapter, you’ll learn about some of the various memory structures used in a computer system.<span epub:type="pagebreak" id="page_150"/></p>&#13;
</div>
</div>
</body></html>