<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_329" title="329"/>14</span><br/>&#13;
<span class="ChapterTitle">Moving to the Cloud</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">In August of 2006, Amazon Web Services (AWS) brought public cloud infrastructure to the mainstream when it introduced its virtual computer, Elastic Compute Cloud (EC2). EC2 removed barriers to providing services over the internet; you no longer needed to purchase servers and software licenses, sign support contracts, rent office space, or hire IT professionals to maintain your infrastructure. Instead, you paid AWS as needed for the use of EC2 instances, allowing you to scale your business while AWS handled the maintenance, redundancy, and standards compliance details for you. In the following years, both Google and Microsoft released public cloud offerings to compete with AWS. Now all three cloud providers offer comprehensive services that cover everything from analytics to storage.</p>&#13;
<p><span epub:type="pagebreak" id="Page_330" title="330"/>The goal of this chapter is to give you an apples-to-apples comparison of Amazon Web Services, Google Cloud, and Microsoft Azure. You’ll create and deploy an application to illustrate the differences in each provider’s tooling, authentication, and deployment experience. Your application will follow the <em>platform-as-a-service (PaaS)</em> model, in which you create the application and deploy it on the cloud provider’s platform. Specifically, you’ll create a function and deploy it to AWS Lambda, Google Cloud Functions, and Microsoft Azure Functions. We’ll stick to the command line as much as possible to keep the comparisons relative and introduce you to each provider’s tooling. </p>&#13;
<p>All three service providers offer a trial period, so you shouldn’t incur any costs. If you’ve exhausted your trial, please keep potential costs in mind as you work through the following sections.</p>&#13;
<p>You’ll create a simple function that retrieves the URL of the latest XKCD comic, or optionally the previous comic. This will demonstrate how to retrieve data from within the function to fulfill the client’s request and persist function state between executions.</p>&#13;
<p>By the end of this chapter, you should feel comfortable writing an application, deploying it, and testing it to leverage the PaaS offerings of AWS, Google Cloud, and Microsoft Azure. You should have a better idea of which provider’s workflow best fits your use case if you choose to make the jump to the cloud.</p>&#13;
<h2 id="h1-500884c14-0001">Laying Some Groundwork</h2>&#13;
<p class="BodyFirst">The XKCD website offers a Real Simple Syndication (RSS) feed at <a class="LinkURL" href="https://xkcd.com/rss.xml">https://xkcd.com/rss.xml</a>. As its file extension indicates, the feed uses XML. You can use Go’s <em>encoding/xml</em> package to parse the feed.</p>&#13;
<p>Before you deploy a function to the cloud that can retrieve the URL of the latest XKCD comic, you need to write some code that will allow you to make sense of the RSS feed. <a href="#listing14-1" id="listinganchor14-1">Listing 14-1</a> creates two types for parsing the feed.</p>&#13;
<pre><code>package feed&#13;
&#13;
import (&#13;
    "context"&#13;
    "encoding/xml"&#13;
    "fmt"&#13;
    "io/ioutil"&#13;
    "net/http"&#13;
)&#13;
&#13;
type Item struct {&#13;
    Title     string `xml:"title"`&#13;
    URL       string `xml:"link"`&#13;
    Published string <span class="CodeAnnotation">1</span>`xml:"pubDate"`&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="Page_331" title="331"/>type RSS struct {&#13;
    Channel struct {&#13;
        Items []Item `xml:"item"`&#13;
    } `xml:"channel"`&#13;
    entityTag <span class="CodeAnnotation">2</span>string&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-1">Listing 14-1</a>: Structure that represents the XKCD RSS feed (<em>feed/rss.go</em>)</p>&#13;
<p>The <code>RSS</code> struct represents the RSS feed, and the <code>Item</code> struct represents each item (comic) in the feed. Like Go’s <em>encoding/json</em> package you used in earlier chapters, its <em>encoding/xml</em> package can use struct tags to map XML tags to their corresponding struct fields. For example, the <code>Published</code> field’s tag <span class="CodeAnnotation">1</span> instructs the <em>encoding/xml</em> package to assign it the item’s <code>pubDate</code> value. </p>&#13;
<p>It’s important to be a good internet neighbor and keep track of the feed’s entity tag <span class="CodeAnnotation">2</span>. Web servers often derive entity tags for content that may not change from one request to another. Clients can track these entity tags and present them with future requests. If the server determines that the requested content has the same entity tag, it can forgo returning the entire payload and return a 304 Not Modified status code so the client knows to use its cached copy instead. You’ll use this value in <a href="#listing14-2" id="listinganchor14-2">Listing 14-2</a> to conditionally update the <code>RSS</code> struct when the feed changes.</p>&#13;
<pre><code><var>--snip--</var>&#13;
func (r RSS) Items() []Item {&#13;
    items := <span class="CodeAnnotation">1</span>make([]Item, len(r.Channel.Items))&#13;
    copy(items, r.Channel.Items)&#13;
&#13;
    return items&#13;
}&#13;
&#13;
func (r *RSS) ParseURL(ctx context.Context, u string) error {&#13;
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, u, nil)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if r.entityTag != "" {&#13;
      <span class="CodeAnnotation">2</span> req.Header.Add("ETag", r.entityTag)&#13;
    }&#13;
&#13;
    resp, err := http.DefaultClient.Do(req)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    switch resp.StatusCode {&#13;
    case <span class="CodeAnnotation">2</span>http.StatusNotModified: // no-op&#13;
    case <span class="CodeAnnotation">3</span>http.StatusOK:&#13;
        b, err := ioutil.ReadAll(resp.Body)&#13;
        if err != nil {&#13;
<span epub:type="pagebreak" id="Page_332" title="332"/>            return err&#13;
        }&#13;
        _ = resp.Body.Close()&#13;
&#13;
        err = xml.Unmarshal(b, r)&#13;
        if err != nil {&#13;
            return err&#13;
        }&#13;
&#13;
        r.entityTag = <span class="CodeAnnotation">4</span>resp.Header.Get("ETag")&#13;
    default:&#13;
        return fmt.Errorf("unexpected status code: %v", resp.StatusCode)&#13;
    }&#13;
&#13;
    return nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-2">Listing 14-2</a>: Methods to parse the XKCD RSS feed and return a slice of items (<em>feed/rss.go</em>)</p>&#13;
<p>There are three things to note here. First, the <code>RSS</code> struct and its methods are not safe for concurrent use. This isn’t a concern for your use case, but it’s best that you’re aware of this fact. Second, the <code>Items</code> method returns a slice of the items in the <code>RSS</code> struct, which is empty until your code calls the <code>ParseURL</code> method to populate the <code>RSS</code> struct. Third, the <code>Items</code> method makes a copy of the <code>Items</code> slice <span class="CodeAnnotation">1</span> and returns the copy to prevent possible corruption of the original <code>Items</code> slice. This is also a bit of overkill for your use case, but it’s best to be aware that you’re returning a reference type that the receiver can modify. If the receiver modifies the copy, it won’t affect your original.</p>&#13;
<p>Parsing the RSS feed is straightforward and should look familiar. The <code>ParseURL</code> method retrieves the RSS feed by using a <code>GET</code> call. If the feed is new, the method reads the XML from the response body and invokes the <code>xml.Unmarshal</code> function to populate the <code>RSS</code> struct with the XML in the server.</p>&#13;
<p>Notice you conditionally set the request’s <code>ETag</code> header <span class="CodeAnnotation">2</span> so the XKCD server can determine whether it needs to send the feed contents or you currently have the latest version. If the server responds with a 304 Not Modified status code, the <code>RSS</code> struct remains unchanged. If you receive a 200 OK <span class="CodeAnnotation">3</span>, you received a new version of the feed and unmarshal the response body’s XML into the <code>RSS</code> struct. If successful, you update the entity tag <span class="CodeAnnotation">4</span>.</p>&#13;
<p>With this logic in place, the <code>RSS</code> struct should update itself only if its entity tag is empty, as it would be on initialization of the struct, or if a new feed is available.</p>&#13;
<p>The last task is to create a <em>go.mod</em> file by using the following commands:</p>&#13;
<pre><code>$ <b>cd feed</b>&#13;
feed$ <b>go mod init github.com/awoodbeck/gnp/ch14/feed</b>&#13;
go: creating new go.mod: module github.com/awoodbeck/gnp/ch14/feed&#13;
feed$ <b>cd -</b></code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_333" title="333"/>These commands initialize a new module named <em>github.com/awoodbeck/gnp/ch14/feed</em>, which will be used by code later in this chapter.</p>&#13;
<h2 id="h1-500884c14-0002">AWS Lambda</h2>&#13;
<p class="BodyFirst"><em>AWS Lambda</em> is a serverless platform that offers first-class support for Go. You can create Go applications, deploy them, and let Lambda handle the implementation details. It will scale your code to meet demand. Before you can get started with Lambda, please make sure you create a trial account at <a class="LinkURL" href="https://aws.amazon.com/">https://aws.amazon.com/</a>.</p>&#13;
<h3 id="h2-500884c14-0001">Installing the AWS Command Line Interface</h3>&#13;
<p class="BodyFirst">AWS offers version 2 of its command line interface (CLI) tools for Windows, macOS, and Linux. You can find detailed instructions for installing them at <a class="LinkURL" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html">https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html</a>.</p>&#13;
<p>Use the following commands to install the AWS CLI tools on Linux:</p>&#13;
<pre><code>$ <b>curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" \</b>&#13;
<b>-o "awscliv2.zip"</b>&#13;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&#13;
                                 Dload  Upload   Total   Spent    Left  Speed&#13;
100 32.3M  100 32.3M    0     0  31.1M      0  0:00:01  0:00:01 --:--:-- 31.1M&#13;
$ <b>unzip -q awscliv2.zip</b>&#13;
$ <b>sudo ./aws/install</b>&#13;
[sudo] password for user:&#13;
You can now run: /usr/local/bin/aws --version&#13;
$ <b>aws --version</b>&#13;
aws-cli/2.0.56 Python/3.7.3 Linux/5.4.0-7642-generic exe/x86_64.pop.20</code></pre>&#13;
<p>Download the AWS CLI version 2 archive. Use <code>curl</code> to download the ZIP file from the command line. Then unzip the archive and use <code>sudo</code> to run the <em>./aws/install</em> executable. Once it’s complete, run <code>aws --version</code> to verify that the AWS binary is in your path and that you’re running version 2.</p>&#13;
<h3 id="h2-500884c14-0002">Configuring the CLI</h3>&#13;
<p class="BodyFirst">Now that you have the AWS CLI installed, you need to configure it with credentials so it can interact with AWS on your account’s behalf. This section walks you through that process. If you get confused, review the AWS CLI configuration quick-start guide at <a class="LinkURL" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html">https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html</a>.</p>&#13;
<p>First, access the AWS Console at <a class="LinkURL" href="https://console.aws.amazon.com">https://console.aws.amazon.com</a>. Log into the AWS Console to access the drop-down menu shown in <a href="#figure14-1" id="figureanchor14-1">Figure 14-1</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_334" title="334"/><figure>&#13;
<img alt="f14001" src="image_fi/500884c14/f14001.png"/>&#13;
<figcaption><p><a id="figure14-1">Figure 14-1</a>: Accessing your AWS account security credentials</p></figcaption>&#13;
</figure>&#13;
<p>Click your account name in the upper-right corner of the AWS Console (<b>Personal</b> in <a href="#figure14-1">Figure 14-1</a>). Then, select <b>My Security Credentials</b> from the drop-down menu. This link should take you to the Your Security Credentials page, shown in <a href="#figure14-2" id="figureanchor14-2">Figure 14-2</a>.</p>&#13;
<figure>&#13;
<img alt="f14002" src="image_fi/500884c14/f14002.png"/>&#13;
<figcaption><p><a id="figure14-2">Figure 14-2</a>: Creating a new access key</p></figcaption>&#13;
</figure>&#13;
<p>Select the <b>Access keys</b> section heading to expand the section. Then click the <b>Create New Access Key</b> button to create credentials to use on the command line. This will display the credentials (<a href="#figure14-3" id="figureanchor14-3">Figure 14-3</a>).</p>&#13;
<figure>&#13;
<img alt="f14003" src="image_fi/500884c14/f14003.png"/>&#13;
<figcaption><p><a id="figure14-3">Figure 14-3</a>: Retrieving the new access Key ID and secret access key</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_335" title="335"/>You’ll need both the access Key ID and secret access key values to authenticate your commands on the command line with AWS. Make sure you download the key file and keep it in a secure place in case you need to retrieve it in the future. For now, you’ll use them to configure your AWS command line interface:</p>&#13;
<pre><code>$ <b>aws configure</b>&#13;
AWS Access Key ID [None]: <b>AIDA1111111111EXAMPLE</b>&#13;
AWS Secret Access Key [None]: <b>YxMCBWETtZjZhW6VpLwPDY5KqH8hsDG45EXAMPLE</b>&#13;
Default region name [None]: <b>us-east-2</b>&#13;
Default output format [None]: <b>yaml</b></code></pre>&#13;
<p>On the command line, invoke the <code>aws configure</code> command. You’ll be prompted to enter the access key ID and secret access key from <a href="#figure14-3">Figure 14-3</a>.</p>&#13;
<p>You can also specify a default region and the default output format. The <em>region</em> is the geographic endpoint for your services. In this example, I’m telling AWS I want my services to use the <code>us-east-2</code> endpoint by default, which is in Ohio. You can find a general list of regional endpoints at <a class="LinkURL" href="https://docs.aws.amazon.com/general/latest/gr/rande.html">https://docs.aws.amazon.com/general/latest/gr/rande.html</a>.</p>&#13;
<h3 id="h2-500884c14-0003">Creating a Role</h3>&#13;
<p class="BodyFirst">Your code requires a specific identity to run in AWS. This identity is called a <em>role</em>. You can have multiple roles under your AWS account and assign various permissions to each role. You can then assign roles to AWS services, which gives services permissions to access your resources without you having to assign credentials (such as your access key ID and secret access key) to each service. In this chapter, you’ll use a role to give AWS Lambda permission to access the Lambda function you’ll write.</p>&#13;
<p>For now, you’ll create just one role and give AWS Lambda permission to assume that role so it can invoke your code. <a href="#listing14-3" id="listinganchor14-3">Listing 14-3</a> details a simple trust policy document that assigns the proper access. The trust policy document outlines a set of permissions, which you’ll assign to a new role.</p>&#13;
<pre><code>{&#13;
  "Version": <span class="CodeAnnotation">1</span>"2012-10-17",&#13;
  "Statement": [&#13;
    {&#13;
      "Effect": <span class="CodeAnnotation">2</span>"Allow",&#13;
      "Principal": {&#13;
        "Service": <span class="CodeAnnotation">3</span>"lambda.amazonaws.com"&#13;
      },&#13;
      "Action": <span class="CodeAnnotation">4</span>"sts:AssumeRole"&#13;
    }&#13;
  ]&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-3">Listing 14-3</a>: Defining a trust policy for your new role (<em>aws/trust-policy.json</em>)</p>&#13;
<p>This trust policy tells AWS that you want to allow <span class="CodeAnnotation">2</span> the Lambda service <span class="CodeAnnotation">3</span> to assume the role <span class="CodeAnnotation">4</span>. The trust policy version <span class="CodeAnnotation">1</span> is the current version of the trust policy language, not an arbitrary date.</p>&#13;
<p><span epub:type="pagebreak" id="Page_336" title="336"/>Next, create the role to which you’ll assign this trust policy:</p>&#13;
<pre><code>$ <b>aws iam create-role --role-name "lambda-xkcd" \</b>&#13;
<b>--assume-role-policy-document file://aws/trust-policy.json</b>&#13;
Role:&#13;
<span class="CodeAnnotation">1</span> Arn: arn:aws:iam::123456789012:role/lambda-xkcd&#13;
<span class="CodeAnnotation">2</span> AssumeRolePolicyDocument:&#13;
    Statement:&#13;
    - Action: sts:AssumeRole&#13;
      Effect: Allow&#13;
      Principal:&#13;
        Service: lambda.amazonaws.com&#13;
    Version: '2012-10-17'&#13;
  CreateDate: '2006-01-02T15:04:05+00:00'&#13;
  Path: /&#13;
  RoleId: AROA1111111111EXAMPLE&#13;
  RoleName: lambda-xkcd</code></pre>&#13;
<p>Create a new role with the AWS Identity and Access Management (IAM) service using the role name <em>lambda-xkcd</em> and the <em>aws/trust-policy.json</em> document you created in <a href="#listing14-3">Listing 14-3</a>. If successful, this creates a new role using your trust policy <span class="CodeAnnotation">2</span>. IAM assigns the role an Amazon Resource Name (ARN). The ARN <span class="CodeAnnotation">1</span> is a unique identifier for this role that you’ll use when invoking your code.</p>&#13;
<h3 id="h2-500884c14-0004">Defining an AWS Lambda Function</h3>&#13;
<p class="BodyFirst">AWS Lambda’s Go library gives you some flexibility when it comes to your Lambda function’s signature. Your function must conform to one of these formats:</p>&#13;
<pre><code>func()&#13;
&#13;
func() error&#13;
&#13;
func(TypeIn) error&#13;
&#13;
func() (TypeOut, error)&#13;
&#13;
func(context.Context) error&#13;
&#13;
func(context.Context, TypeIn) error&#13;
&#13;
func(context.Context) (TypeOut, error)&#13;
&#13;
func(context.Context, TypeIn) (TypeOut, error)</code></pre>&#13;
<p><code>TypeIn</code> and <code>TypeOut</code> correspond to <em>encoding/json</em>-compatible types, in that JSON input sent to your Lambda function will be unmarshaled into <code>TypeIn</code>. Likewise, the <code>TypeOut</code> your function returns will be marshaled to JSON before reaching its destination. You’ll use the last function signature in this section.</p>&#13;
<p><span epub:type="pagebreak" id="Page_337" title="337"/>The function you’ll write should give you a taste for what you can do with serverless environments. It will accept input from the client, retrieve resources over the internet, maintain its state between function calls, and respond to the client. If you’ve read <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, you know that you could write an <code>http.Handler</code> that performs these actions, but AWS Lambda requires a slightly different approach. You won’t work with an <code>http.Request</code> or an <code>http.ResponseWriter</code>. Instead, you’ll use types you create or import from other modules. AWS Lambda handles the decoding and encoding of the data to and from your function for you.</p>&#13;
<p>Let’s get started writing your first bit of serverless code (<a href="#listing14-4" id="listinganchor14-4">Listing 14-4</a>).</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "context"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch14/feed"&#13;
    "github.com/aws/aws-lambda-go/lambda"&#13;
)&#13;
&#13;
var (&#13;
    rssFeed <span class="CodeAnnotation">1</span>feed.RSS&#13;
    feedURL = <span class="CodeAnnotation">2</span>"https://xkcd.com/rss.xml"&#13;
)&#13;
&#13;
type EventRequest struct {&#13;
    Previous bool `json:"previous"`&#13;
}&#13;
&#13;
type EventResponse struct {&#13;
    Title     string `json:"title"`&#13;
    URL       string `json:"url"`&#13;
    Published string `json:"published"`&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-4">Listing 14-4</a>: Creating persistent variables and request and response types (<em>aws/xkcd.go</em>)</p>&#13;
<p>You can specify variables at the package level that will persist between function calls while the function persists in memory. In this example, you define a feed object <span class="CodeAnnotation">1</span> and the URL of the RSS feed <span class="CodeAnnotation">2</span>. Creating and populating a new <code>feed.RSS</code> object involves a bit of overhead. You can avoid that overhead on subsequent function calls if you store the object in a variable at the package level so it lives beyond each function call. This also allows you to take advantage of the entity tag support in <code>feed.RSS</code>.</p>&#13;
<p>The <code>EventRequest</code> and <code>EventResponse</code> types define the format of a client request and the function’s response. AWS Lambda unmarshals the JSON from the client’s HTTP request body into the <code>EventRequest</code> object and marshals the function’s <code>EventResponse</code> to JSON to the HTTP response body before returning it to the client.</p>&#13;
<p><span epub:type="pagebreak" id="Page_338" title="338"/><a href="#listing14-5" id="listinganchor14-5">Listing 14-5</a> defines the <code>main</code> function and begins to define the AWS Lambda-compatible function.</p>&#13;
<pre><code><var>--snip--</var>&#13;
func main() {&#13;
  <span class="CodeAnnotation">1</span> lambda.Start(LatestXKCD)&#13;
}&#13;
&#13;
func LatestXKCD(ctx context.Context, req EventRequest) (&#13;
    EventResponse, error) {&#13;
    resp := <span class="CodeAnnotation">2</span>EventResponse{Title: "xkcd.com", URL: "https://xkcd.com/"}&#13;
&#13;
    if err := <span class="CodeAnnotation">3</span>rssFeed.ParseURL(ctx, feedURL); err != nil {&#13;
        return resp, err&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-5">Listing 14-5</a>: Main function and first part of the Lambda function named LatestXKCD (<em>aws/xkcd.go</em>)</p>&#13;
<p>Hook your function into Lambda by passing it to the <code>lambda.Start</code> method <span class="CodeAnnotation">1</span>. You’re welcome to instantiate dependencies in an <code>init</code> function, or before this statement, if your function requires it.</p>&#13;
<p>The <code>LatestXKCD</code> function accepts a context and an <code>EventRequest</code> and returns an <code>EventResponse</code> and an <code>error</code> interface. It defines a response object <span class="CodeAnnotation">2</span> with default <code>Title</code> and <code>URL</code> values. The function returns the response as is in the event of an error or an empty feed.</p>&#13;
<p>Parsing the feed URL <span class="CodeAnnotation">3</span> from <a href="#listing14-4">Listing 14-4</a> populates the <code>rssFeed</code> object with the latest feed details. <a href="#listing14-6" id="listinganchor14-6">Listing 14-6</a> uses these details to formulate the response.</p>&#13;
<pre><code><var>--snip--</var>&#13;
    switch items := rssFeed.Items(); {&#13;
    case <span class="CodeAnnotation">1</span>req.Previous &amp;&amp; len(items) &gt; 1:&#13;
        resp.Title = items[1].Title&#13;
        resp.URL = items[1].URL&#13;
        resp.Published = items[1].Published&#13;
    case len(items) &gt; 0:&#13;
        resp.Title = items[0].Title&#13;
        resp.URL = items[0].URL&#13;
        resp.Published = items[0].Published&#13;
    }&#13;
&#13;
    return resp, nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-6">Listing 14-6</a>: Populating the response with the feed results (aws/xkcd.go)</p>&#13;
<p>If the client requests the previous XKCD comic <span class="CodeAnnotation">1</span> and there are at least two feed items, the function populates the response with details of the previous XKCD comic. Otherwise, the function populates the response with the most recent XKCD comic details, provided there’s at least one feed item. If neither of those cases is true, the client receives the response with its default values from <a href="#listing14-5">Listing 14-5</a>.</p>&#13;
<h3 id="h2-500884c14-0005"><span epub:type="pagebreak" id="Page_339" title="339"/>Compiling, Packaging, and Deploying Your Function</h3>&#13;
<p class="BodyFirst">AWS Lambda expects you to compile your code and zip the resulting binary before deploying the archive, using the AWS CLI tools. To do this, use the following commands in Linux, macOS, or WSL:</p>&#13;
<pre><code>$ <b>GOOS=linux go build aws/xkcd.go</b>&#13;
$ <b>zip xkcd.zip xkcd</b>&#13;
  adding: xkcd (deflated 50%)&#13;
$ <b>aws lambda create-function --function-name "xkcd" --runtime "go1.x" \</b>&#13;
<b>--handler "xkcd" --role "arn:aws:iam::123456789012:role/lambda-xkcd" \</b>&#13;
<b>--zip-file "fileb://xkcd.zip"</b>&#13;
CodeSha256: M36I7oiS8+S9AryIthcizsjdLDKXMaJKvZvsZzZDNH0=&#13;
CodeSize: 6597490&#13;
Description: ''&#13;
FunctionArn: arn:aws:lambda:us-east-2:123456789012:function:xkcd&#13;
FunctionName: <span class="CodeAnnotation">1</span>xkcd&#13;
Handler: <span class="CodeAnnotation">2</span>xkcd&#13;
LastModified: 2006-01-02T15:04:05.000+0000&#13;
LastUpdateStatus: Successful&#13;
MemorySize: 128&#13;
RevisionId: b094a881-9c49-4b86-86d5-eb4335507eb0&#13;
Role: arn:aws:iam::123456789012:role/lambda-xkcd&#13;
Runtime: go1.x&#13;
State: Active&#13;
Timeout: 3&#13;
TracingConfig:&#13;
  Mode: PassThrough&#13;
Version: $LATEST</code></pre>&#13;
<p>Compile <em>aws/xkcd.go</em> and add the resulting <em>xkcd</em> binary to a ZIP file. Then, use the AWS CLI to create a new function named <code>xkcd</code>, a handler named <code>xkcd</code>, the <code>go1.x</code> runtime, the role ARN you created earlier, and the ZIP file containing the <em>xkcd</em> binary. Notice the <em>fileb://xkcd.zip</em> URL in the command line. This tells the AWS CLI that it can find a binary file (<em>fileb</em>) in the current directory named <em>xkcd.zip</em>.</p>&#13;
<p>If successful, the AWS CLI outputs the details of the new Lambda function: the function name <span class="CodeAnnotation">1</span> in AWS, which you’ll use on the command line to manage your function, and the filename of the binary in the zip file <span class="CodeAnnotation">2</span>.</p>&#13;
<p>Compilation of the binary and packing it is a bit different on Windows. I recommend you do this in PowerShell since you can compress the cross-compiled binary on the command line without the need to install a specific archiver.</p>&#13;
<pre><code>PS C:\Users\User\dev\gnp\ch14&gt; setx GOOS linux&#13;
&#13;
SUCCESS: Specified value was saved.&#13;
PS C:\Users\User\dev\gnp\ch14&gt; \Go\bin\go.exe build -o xkcd .\aws\xkcd.go&#13;
go: downloading github.com/aws/aws-lambda-go v1.19.1&#13;
<var>--snip--</var>&#13;
PS C:\Users\User\dev\gnp\ch14&gt; Compress-Archive xkcd xkcd.zip</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_340" title="340"/>At this point, use the AWS CLI tools to deploy the ZIP file as in the previous listing.</p>&#13;
<p>If you need to update your function code, recompile the binary and archive it again. Then use the following command to update the existing Lambda function:</p>&#13;
<pre><code>$ <b>aws lambda update-function-code --function-name "xkcd" \</b>&#13;
<b>--zip-file "fileb://xkcd.zip"</b></code></pre>&#13;
<p>Since you’re updating an existing function, the only values you need to provide are the names of the function and ZIP file. AWS takes care of the rest.</p>&#13;
<p>As an exercise, update the code to allow the client to request a forced refresh of the XKCD RSS feed. Then, update the function with those changes and move on to the next section to test those changes.</p>&#13;
<h3 id="h2-500884c14-0006">Testing Your AWS Lambda Function</h3>&#13;
<p class="BodyFirst">The AWS CLI tools make it easy to test your Lambda function. You can use them to send a JSON payload and capture the JSON response. Invoke the function by providing the function name and the path to a file in the AWS CLI. The AWS CLI will populate this with the response body:</p>&#13;
<pre><code>$ <b>aws lambda invoke --function-name "xkcd" response.json</b>&#13;
ExecutedVersion: $LATEST&#13;
StatusCode: 200</code></pre>&#13;
<p>If the invocation is successful, you can verify that your function provided the XKCD comic name and URL by reviewing the <em>response.json</em> contents:</p>&#13;
<pre><code>$ <b>cat response.json</b>&#13;
{"title":"Election Screen Time","url":"https://xkcd.com/2371/",&#13;
"published":"Mon, 12 Oct 2020 04:00:00 -0000"}</code></pre>&#13;
<p>You can also invoke the function with a custom request body by adding a few additional command line arguments. You can pass a<code> payload</code> string if you specify its format as <code>raw-in-base64-out</code>. This tells the AWS CLI to take the string you provide and Base64-encode it before assigning it to the request body and passing it along to the function:</p>&#13;
<pre><code>$ <b>aws lambda invoke --cli-binary-format "raw-in-base64-out" \</b>&#13;
<b>--payload '{"previous":true}' --function-name "xkcd" response.json</b>&#13;
ExecutedVersion: $LATEST&#13;
StatusCode: 200&#13;
$ <b>cat response.json</b>&#13;
{"title":"Chemist Eggs","url":"https://xkcd.com/2373/",&#13;
"published":"Fri, 16 Oct 2020 04:00:00 -0000"}</code></pre>&#13;
<h2 id="h1-500884c14-0003"><span epub:type="pagebreak" id="Page_341" title="341"/>Google Cloud Functions</h2>&#13;
<p class="BodyFirst">Like AWS Lambda, Google Cloud Functions allows you to deploy code in a serverless environment, offloading the implementation details to Google. Not surprisingly, Go enjoys first-class support in Cloud Functions.</p>&#13;
<p>You’ll need a Google Cloud account before proceeding with this section. Visit <a class="LinkURL" href="https://cloud.google.com">https://cloud.google.com</a> to get started with a trial account.</p>&#13;
<h3 id="h2-500884c14-0007">Installing the Google Cloud Software Development Kit</h3>&#13;
<p class="BodyFirst">The Google Cloud Software Development Kit (SDK) requires Python 2.7.9 or 3.5+. You’ll need to make sure a suitable version of Python is installed on your operating system before proceeding. You can follow Google’s comprehensive installation guide at <a class="LinkURL" href="https://cloud.google.com/sdk/docs/install/">https://cloud.google.com/sdk/docs/install/</a>, where you’ll find specific installation instructions for Windows, macOS, and various flavors of Linux.</p>&#13;
<p>Here are the generic Linux installation steps:</p>&#13;
<pre><code>$ <b>curl -O </b><b>https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/\</b>&#13;
<b>google-cloud-sdk-319.0.1-linux-x86_64.tar.gz</b>&#13;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&#13;
                                 Dload  Upload   Total   Spent    Left  Speed&#13;
100 81.9M  100 81.9M    0     0  34.1M      0  0:00:02  0:00:02 --:--:-- 34.1M&#13;
$ <b>tar xf google-cloud-sdk-319.0.1-linux-x86_64.tar.gz</b>&#13;
$ <b>./google-cloud-sdk/install.sh</b>&#13;
Welcome to the Google Cloud SDK!&#13;
<var>--snip--</var></code></pre>&#13;
<p>Download the current Google Cloud SDK tarball (the version changes frequently!) and extract it. Then, run the <em>./google-cloud-sdk/install.sh</em> script. The installation process asks you questions that pertain to your environment. I snipped them from the output for brevity.</p>&#13;
<h3 id="h2-500884c14-0008">Initializing the Google Cloud SDK</h3>&#13;
<p class="BodyFirst">You need to authorize the Google Cloud SDK before you’re able to use it to deploy your code. Google makes this process simple compared to AWS. There’s no need to create credentials and then copy and paste them to the command line. Instead, Google Cloud uses your web browser for authentication and authorization.</p>&#13;
<p>The <code>gcloud init</code> command is equivalent to the <code>aws configure</code> command, in that it will walk you through the configuration of your Google Cloud command line environment:</p>&#13;
<pre><code>$ <b>./google-cloud-sdk/bin/gcloud init</b>&#13;
Welcome! This command will take you through the configuration of gcloud.&#13;
<var>--snip--</var>&#13;
Pick cloud project to use:&#13;
<span epub:type="pagebreak" id="Page_342" title="342"/><span class="CodeAnnotationHang">1</span> [1] Create a new project&#13;
Please enter numeric choice or text value (must exactly match list&#13;
item):  <b>1</b>&#13;
&#13;
Enter a Project ID. Note that a Project ID CANNOT be changed later.&#13;
Project IDs must be 6-30 characters (lowercase ASCII, digits, or&#13;
hyphens) in length and start with a lowercase letter. <b>goxkcd</b>&#13;
<var>--snip--</var>&#13;
$ <b>gcloud projects list</b>&#13;
PROJECT_ID                      NAME                   PROJECT_NUMBER&#13;
goxkcd                          goxkcd                 123456789012</code></pre>&#13;
<p>The first step in the process will open a page in your web browser to authenticate your Google Cloud SDK with your Google Cloud account. Your command line output may look a little different from the output here if your Google Cloud account has existing projects. For the purposes of this chapter, elect to create a new project <span class="CodeAnnotation">1</span> and give it a project ID—<code>goxkcd</code> in this example. Your project ID must be unique across Google Cloud. Once you’ve completed this step, you’re ready to interact with Google Cloud from the command line, just as you did with AWS.</p>&#13;
<h3 id="h2-500884c14-0009">Enable Billing and Cloud Functions</h3>&#13;
<p class="BodyFirst">You need to make sure billing is enabled for your project before it can use Cloud Functions. Visit <a href="https://cloud.google.com/billing/docs/how-to/modify-project/">https://cloud.google.com/billing/docs/how-to/modify-project/</a> to learn how to modify the billing details of an existing project. Once enabled, you can then enable your project’s Cloud Functions access. At this point, you can start writing code.</p>&#13;
<h3 id="h2-500884c14-0010">Defining a Cloud Function</h3>&#13;
<p class="BodyFirst">Cloud Functions uses Go’s module support instead of requiring you to write a stand-alone application as you did for AWS Lambda. This simplifies your code a bit since you don’t need to import any libraries specific to Cloud Functions or define a main function as the entry point of execution.</p>&#13;
<p><a href="#listing14-7" id="listinganchor14-7">Listing 14-7</a> provides the initial code for a Cloud Functions–compatible module.</p>&#13;
<pre><code>package gcp&#13;
&#13;
import (&#13;
    "encoding/json"&#13;
    "log"&#13;
    "net/http"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch14/feed"&#13;
)&#13;
&#13;
var (&#13;
    rssFeed feed.RSS&#13;
    feedURL = "https://xkcd.com/rss.xml"&#13;
)&#13;
<span epub:type="pagebreak" id="Page_343" title="343"/>&#13;
type EventRequest struct {&#13;
    Previous bool `json:"previous"`&#13;
}&#13;
&#13;
type EventResponse struct {&#13;
    Title          string `json:"title"`&#13;
    URL            string `json:"url"`&#13;
    Published      string `json:"published"`&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-7">Listing 14-7</a>: Creating persistent variables and request and response types (<em>gcp/xkcd.go</em>)</p>&#13;
<p>The types are identical to the code we wrote for AWS Lambda. Unlike AWS Lambda, Cloud Functions won’t unmarshal the request body into an <code>EventRequest</code> for you. Therefore, you’ll have to handle the unmarshaling and marshaling of the request and response payloads on your own.</p>&#13;
<p>Whereas AWS Lambda accepted a range of function signatures, Cloud Functions uses the familiar <code>net/http</code> handler function signature: <code>func(http.ResponseWriter, *http.Request)</code>, as shown in <a href="#listing14-8" id="listinganchor14-8">Listing 14-8</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
func LatestXKCD(w http.ResponseWriter, r *http.Request) {&#13;
    var req EventRequest&#13;
    resp := EventResponse{Title: "xkcd.com", URL: "https://xkcd.com/"}&#13;
&#13;
    defer <span class="CodeAnnotation">1</span>func() {&#13;
        w.Header().Set("Content-Type", "application/json")&#13;
        out, _ := json.Marshal(&amp;resp)&#13;
        _, _ = w.Write(out)&#13;
    }()&#13;
&#13;
    if err := <span class="CodeAnnotation">2</span>json.NewDecoder(r.Body).Decode(&amp;req); err != nil {&#13;
        log.Printf("decoding request: %v", err)&#13;
        return&#13;
    }&#13;
&#13;
    if err := rssFeed.ParseURL(<span class="CodeAnnotation">3</span>r.Context(), feedURL); err != nil {&#13;
        log.Printf("parsing feed: %v:", err)&#13;
        return&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-8">Listing 14-8</a>: Handling the request and response and optionally updating the RSS feed (<em>gcp/xkcd.go</em>)</p>&#13;
<p>Like the AWS code, this <code>LatestXKCD</code> function refreshes the RSS feed by using the <code>ParseURL</code> method. But unlike the equivalent AWS code, you need to JSON-unmarshal the request body <span class="CodeAnnotation">2</span> and marshal the response to JSON <span class="CodeAnnotation">1</span> before sending it to the client. Even though <code>LatestXKCD</code> doesn’t receive a context in its function parameters, you can use the request’s context <span class="CodeAnnotation">3</span> to cancel the parser if the socket connection with the client terminates before the parser returns.</p>&#13;
<p><a href="#listing14-9" id="listinganchor14-9">Listing 14-9</a> implements the remainder of the <code>LatestXKCD</code> function.</p>&#13;
<span epub:type="pagebreak" id="Page_344" title="344"/><pre><code><var>--snip--</var>&#13;
    switch items := rssFeed.Items(); {&#13;
    case req.Previous &amp;&amp; len(items) &gt; 1:&#13;
        resp.Title = items[1].Title&#13;
        resp.URL = items[1].URL&#13;
        resp.Published = items[1].Published&#13;
    case len(items) &gt; 0:&#13;
        resp.Title = items[0].Title&#13;
        resp.URL = items[0].URL&#13;
        resp.Published = items[0].Published&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-9">Listing 14-9</a>: Populating the response with the feed results (<em>gcp/xkcd.go</em>)</p>&#13;
<p>Like <a href="#listing14-6">Listing 14-6</a>, this code populates the response fields with the appropriate feed item. The deferred function in <a href="#listing14-8">Listing 14-8</a> handles writing the response to the <code>http.ResponseWriter</code>, so there’s nothing further to do here.</p>&#13;
<h3 id="h2-500884c14-0011">Deploying Your Cloud Function</h3>&#13;
<p class="BodyFirst">You need to address one bit of module accounting before you deploy your code; you need to create a <em>go.mod</em> file so Google can find dependencies, because unlike with AWS Lambda, you don’t compile and package the binary yourself. Instead, the code is ultimately compiled on Cloud Functions.</p>&#13;
<p>Use the following commands to create the <em>go.mod</em> file:</p>&#13;
<pre><code>$ <b>cd gcp</b>&#13;
gcp$ <b>go mod init github.com/awoodbeck/gnp/ch14/gcp</b>&#13;
go: creating new go.mod: module github.com/awoodbeck/gnp/ch14/gcp&#13;
gcp$ <b>go mod tidy</b>&#13;
<var>--snip--</var>&#13;
gcp$ <b>cd -</b></code></pre>&#13;
<p>These commands initialize a new module named <em>github.com/awoodbeck/gnp/ch14/gcp</em> and tidy the module requirements in the<em> go.mod</em> file.</p>&#13;
<p>Your module is ready for deployment. Use the <code>gcloud functions deploy</code> command, which accepts your code’s function name, the source location, and the Go runtime version:</p>&#13;
<pre><code>$ <b>gcloud functions deploy LatestXKCD --source ./gcp/ --runtime go113 \</b>&#13;
<b>--trigger-http --allow-unauthenticated</b>&#13;
Deploying function (may take a while - up to 2 minutes)... &#13;
For Cloud Build Stackdriver Logs, visit: &#13;
https://console.cloud.google.com/logs/viewer<var>--snip--</var>&#13;
Deploying function (may take a while - up to 2 minutes)...done.&#13;
availableMemoryMb: 256&#13;
buildId: 5d7fee9b-7468-4b04-badc-81015aa62e59&#13;
entryPoint: <span class="CodeAnnotation">1</span>LatestXKCD&#13;
httpsTrigger:&#13;
  url: <span class="CodeAnnotation">2</span>https://us-central1-goxkcd.cloudfunctions.net/LatestXKCD&#13;
ingressSettings: <span class="CodeAnnotation">3</span>ALLOW_ALL&#13;
<span epub:type="pagebreak" id="Page_345" title="345"/>labels:&#13;
  deployment-tool: cli-gcloud&#13;
name: projects/goxkcd/locations/us-central1/functions/LatestXKCD&#13;
runtime: <span class="CodeAnnotation">4</span>go113&#13;
serviceAccountEmail: goxkcd@appspot.gserviceaccount.com&#13;
sourceUploadUrl: https://storage.googleapis.com/<var>--snip--</var>&#13;
status: ACTIVE&#13;
timeout: 60s&#13;
updateTime: '2006-01-02T15:04:05.000Z'&#13;
versionId: '1'</code></pre>&#13;
<p>The addition of the <code>--trigger-http</code> and <code>--allow-unauthenticated</code> flags tells Google you want to trigger a call to your function by an incoming HTTP request and that no authentication is required for the HTTP endpoint.</p>&#13;
<p>Once created, the SDK output shows the function name <span class="CodeAnnotation">1</span>, the HTTP endpoint <span class="CodeAnnotation">2</span> for your function, the permissions for the endpoint <span class="CodeAnnotation">3</span>, and the Go runtime version <span class="CodeAnnotation">4</span>.</p>&#13;
<p>Although the Cloud Functions deployment workflow is simpler than the AWS Lambda workflow, there’s a limitation: you’re restricted to the Go runtime version that Cloud Functions supports, which may not be the latest version. Therefore, you need to make sure the code you write doesn’t use newer features added since Go 1.13. You don’t have a similar limitation when deploying to AWS Lambda, since you locally compile the binary before deployment.</p>&#13;
<h3 id="h2-500884c14-0012">Testing Your Google Cloud Function</h3>&#13;
<p class="BodyFirst">The Google Cloud SDK doesn’t include a way to invoke your function from the command line, as you did using the AWS CLI. But your function’s HTTP endpoint is publicly accessible, so you can directly send HTTP requests to it.</p>&#13;
<p>Use <code>curl</code> to send HTTP requests to your function’s HTTP endpoint:</p>&#13;
<pre><code>$ <b>curl -X POST -H "Content-Type: application/json" --data '{}' \</b>&#13;
<b>https://us-central1-goxkcd.cloudfunctions.net/LatestXKCD</b>&#13;
{"title":"Chemist Eggs","url":"https://xkcd.com/2373/",&#13;
"published":"Fri, 16 Oct 2020 04:00:00 -0000"}&#13;
$ <b>curl -X POST -H "Content-Type: application/json" \</b>&#13;
<b>--data '{"previous":true}' \</b>&#13;
<b>https://us-central1-goxkcd.cloudfunctions.net/LatestXKCD</b>&#13;
{"title":"Chemist Eggs","url":"https://xkcd.com/2373/",&#13;
"published":"Fri, 16 Oct 2020 04:00:00 -0000"}</code></pre>&#13;
<p>Here, you send <code>POST</code> requests with the <code>Content-Type</code> header indicating that the request body contains JSON. The first request sends an empty object, so you correctly receive the current XKCD comic title and URL. The second request asks for the previous comic, which the function correctly returns in its response.</p>&#13;
<p>Keep in mind that, unlike with AWS, the only security your function’s HTTP endpoint has with the use of the <code>--allow-unauthenticated</code> flag is obscurity, as anyone can send requests to your Google Clouds function. Since you <span epub:type="pagebreak" id="Page_346" title="346"/>aren’t returning sensitive information, the main risk you face is the potential cost you may incur if you neglect to delete or secure your function after you’re done with it.</p>&#13;
<p>Once you’re satisfied that the function works as expected, go ahead and delete it. I’ll sleep better at night if you do. You can remove the function from the command line like this:</p>&#13;
<pre><code>$ <b>gcloud functions delete LatestXKCD</b></code></pre>&#13;
<p>You’ll be prompted to confirm the deletion.</p>&#13;
<h2 id="h1-500884c14-0004">Azure Functions</h2>&#13;
<p class="BodyFirst">Unlike AWS Lambda and Google Cloud Functions, Microsoft Azure Functions doesn’t offer first-class support for Go. But all is not lost. We can define a custom handler that exposes an HTTP server. Azure Functions will proxy requests and responses between clients and your custom handler’s HTTP server. You can read more details about the Azure Functions custom handlers at <a class="LinkURL" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers#http-only-function">https://docs.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers#http-only-function</a>. In addition, your code runs in a Windows environment as opposed to Linux, which is an important distinction when compiling your code for deployment on Azure Functions.</p>&#13;
<p>You’ll need a Microsoft Azure account before proceeding. Visit <a href="https://azure.microsoft.com">https://azure.microsoft.com</a> to create one.</p>&#13;
<h3 id="h2-500884c14-0013">Installing the Azure Command Line Interface</h3>&#13;
<p class="BodyFirst">The Azure CLI has installation packages for Windows, macOS, and several popular Linux distributions. You can find details for your operating system at <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli/</a>.</p>&#13;
<p>The following commands install the Azure CLI on a Debian-compatible Linux system:</p>&#13;
<pre><code>$ <b>curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash</b>&#13;
[sudo] password for user:  &#13;
export DEBIAN_FRONTEND=noninteractive  &#13;
apt-get update&#13;
<var>--snip--</var>&#13;
$ <b>az version</b>&#13;
{&#13;
  "azure-cli": "2.15.0",&#13;
  "azure-cli-core": "2.15.0",&#13;
  "azure-cli-telemetry": "1.0.6",&#13;
  "extensions": {}&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_347" title="347"/>The first command downloads the <code>InstallAzureCLIDeb</code> shell script and pipes it to <code>sudo bash</code>. After authenticating, the script installs an Apt repository, updates Apt, and installs the <em>azure-cli</em> package.</p>&#13;
<p>Once installed, the <code>az version</code> command displays the current Azure CLI component versions.</p>&#13;
<h3 id="h2-500884c14-0014">Configuring the Azure CLI</h3>&#13;
<p class="BodyFirst">Whereas the AWS CLI required you to provide its credentials during configuration, and the Google Cloud SDK opened a web page to authorize itself during configuration, the Azure CLI separates configuration and authentication into separate steps. First, issue the <code>az configure</code> command and follow the instructions for configuring the Azure CLI. Then, run the <code>az login</code> command to authenticate your Azure CLI using your web browser:</p>&#13;
<pre><code>$ <b>az configure</b>&#13;
Welcome to the Azure CLI! This command will guide you through logging in and &#13;
setting some default values.&#13;
&#13;
Your settings can be found at /home/user/.azure/config&#13;
Your current configuration is as follows:&#13;
<var>--snip--</var>&#13;
$ <b>az login</b>&#13;
<span class="CodeAnnotationHang">1</span> You have logged in. Now let us find all the subscriptions to which you have&#13;
access...&#13;
[&#13;
  {&#13;
    "cloudName": "AzureCloud",&#13;
<var>--snip--</var>&#13;
  }&#13;
]</code></pre>&#13;
<p>The Azure CLI supports several configuration options not covered in the <code>az configure</code> process. You can use the Azure CLI to set these values instead of directly editing the <em>$HOME/.azure/config</em> file. For example, you can disable telemetry by setting the <code>core.collect_telemetry</code> variable to <code>off</code>:</p>&#13;
<pre><code>$ <b>az config set core.collect_telemetry=off</b>&#13;
Command group 'config' is experimental and not covered by customer support. Please use with discretion.</code></pre>&#13;
<h3 id="h2-500884c14-0015">Installing Azure Functions Core Tools</h3>&#13;
<p class="BodyFirst">Unlike the other cloud services covered in this chapter, the Azure CLI tools do not directly support Azure Functions. You need to install another set of tools specific to Azure Functions.</p>&#13;
<p>The “Install the Azure Functions Core Tools” section of <a class="LinkURL" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local/">https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local/</a> details the process of installing version 3 of the tools on Windows, macOS, and Linux.</p>&#13;
<h3 id="h2-500884c14-0016"><span epub:type="pagebreak" id="Page_348" title="348"/>Creating a Custom Handler</h3>&#13;
<p class="BodyFirst">You can use the Azure Functions core tools to initialize a new custom handler. Simply run the <code>func init</code> command, setting the <code>--worker-runtime</code> flag to <code>custom</code>:</p>&#13;
<pre><code>$ <b>cd azure</b>&#13;
$ <b>func init --worker-runtime custom</b>&#13;
Writing .gitignore&#13;
Writing host.json&#13;
Writing local.settings.json&#13;
Writing /home/user/dev/gnp/ch14/azure/.vscode/extensions.json</code></pre>&#13;
<p>The core tools then create a few project files, the most relevant to us being the <em>host.json</em> file.</p>&#13;
<p>You need to complete a few more tasks before you start writing code. First, create a subdirectory named after your desired function name in Azure Functions:</p>&#13;
<pre><code>$ <b>mkdir LatestXKCDFunction</b></code></pre>&#13;
<p>This example names the Azure Function <code>LatestXKCDFunction</code> by creating a subdirectory with the same name. This name will be part of your function’s endpoint URL.</p>&#13;
<p>Second, create a file named <em>function.json</em> in the subdirectory with the contents in <a href="#listing14-10" id="listinganchor14-10">Listing 14-10</a>.</p>&#13;
<pre><code>{&#13;
  "bindings": [&#13;
    {&#13;
      "type": <span class="CodeAnnotation">1</span>"httpTrigger",&#13;
      "direction": <span class="CodeAnnotation">2</span>"in",&#13;
      "name": "req",&#13;
    <span class="CodeAnnotation">3</span> "methods": [ "post" ]&#13;
    },&#13;
    {&#13;
      "type": <span class="CodeAnnotation">4</span>"http",&#13;
      "direction": <span class="CodeAnnotation">5</span>"out",&#13;
      "name": "res"&#13;
    }&#13;
  ]&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-10">Listing 14-10</a>: Binds incoming HTTP trigger and outgoing HTTP (<em>azure/LatestXKCDFunction/function.json</em>)</p>&#13;
<p>The Azure Functions Core Tools will use this <em>function.json</em> file to configure Azure Functions to use your custom handler. This JSON instructs Azure Functions to bind an incoming HTTP trigger to your custom handler and expect HTTP output from it. Here, you’re telling Azure Functions that incoming <span class="CodeAnnotation">2</span><code>POST</code> requests <span class="CodeAnnotation">3</span> shall trigger <span class="CodeAnnotation">1</span> your custom handler, and your custom handler returns <span class="CodeAnnotation">4</span> HTTP responses <span class="CodeAnnotation">5</span>.</p>&#13;
<p>Lastly, the generated <em>host.json</em> file needs some tweaking (<a href="#listing14-11" id="listinganchor14-11">Listing 14-11</a>).</p>&#13;
<span epub:type="pagebreak" id="Page_349" title="349"/><pre><code>{&#13;
  "version": "2.0",&#13;
  "logging": {&#13;
    "applicationInsights": {&#13;
      "samplingSettings": {&#13;
        "isEnabled": true,&#13;
        "excludedTypes": "Request"&#13;
      }&#13;
    }&#13;
  },&#13;
  "extensionBundle": {&#13;
    "id": "Microsoft.Azure.Functions.ExtensionBundle",&#13;
    "version": "[1.*, 2.0.0)"&#13;
  },&#13;
  "customHandler": {&#13;
  <span class="CodeAnnotation">1</span> "enableForwardingHttpRequest": true,&#13;
    "description": {&#13;
      "defaultExecutablePath": <span class="CodeAnnotation">2</span>"xkcd.exe",&#13;
      "workingDirectory": "",&#13;
      "arguments": []&#13;
    }&#13;
  }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-11">Listing 14-11</a>: Tweaking the host.json file (<em>azure/host.json</em>)</p>&#13;
<p>Make sure to enable the forwarding of HTTP requests from Azure Functions to your custom handler <span class="CodeAnnotation">1</span>. This instructs Azure Functions to act as a proxy between clients and your custom handler. Also, set the default executable path to the name of your Go binary <span class="CodeAnnotation">2</span>. Since your code will run on Windows, make sure to include the <em>.exe</em> file extension.</p>&#13;
<h3 id="h2-500884c14-0017">Defining a Custom Handler</h3>&#13;
<p class="BodyFirst">Your custom handler needs to instantiate its own HTTP server, but you can leverage code you’ve already written for Google Cloud Functions. <a href="#listing14-12" id="listinganchor14-12">Listing 14-12</a> is the entire custom handler implementation.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "log"&#13;
    "net/http"&#13;
    "os"&#13;
    "time"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch14/gcp"&#13;
)&#13;
&#13;
func main() {&#13;
    port, exists := <span class="CodeAnnotation">1</span>os.LookupEnv("FUNCTIONS_CUSTOMHANDLER_PORT")&#13;
    if !exists {&#13;
        log.Fatal("FUNCTIONS_CUSTOMHANDLER_PORT environment variable not set")&#13;
    }&#13;
<span epub:type="pagebreak" id="Page_350" title="350"/>&#13;
    srv := &amp;http.Server{&#13;
        Addr:              ":" + port,&#13;
        Handler:           http.HandlerFunc(<span class="CodeAnnotation">2</span>gcp.LatestXKCD),&#13;
        IdleTimeout:       time.Minute,&#13;
        ReadHeaderTimeout: 30 * time.Second,&#13;
    }&#13;
&#13;
    log.Printf("Listening on %q ...\n", srv.Addr)&#13;
    log.Fatal(srv.ListenAndServe())&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing14-12">Listing 14-12</a>: Using the Google Cloud Functions code to handle requests (<em>azure/xkcd.go</em>)</p>&#13;
<p>Azure Functions expects your HTTP server to listen to the port number it assigns to the <code>FUNCTIONS_CUSTOMHANDLER_PORT</code> environment variable <span class="CodeAnnotation">1</span>. Since the <code>LatestXKCD</code> function you wrote for Cloud Functions can be cast as an <code>http.HandlerFunc</code>, you can save a bunch of keystrokes by importing its module and using the function as your HTTP server’s handler <span class="CodeAnnotation">2</span>.</p>&#13;
<h3 id="h2-500884c14-0018">Locally Testing the Custom Handler</h3>&#13;
<p class="BodyFirst">The Azure Functions Core Tools allow you to locally test your code before deployment. Let’s walk through the process of building and running the Azure Functions code on your computer. First, change into the directory with your Azure Functions code:</p>&#13;
<pre><code>$ <b>cd azure</b></code></pre>&#13;
<p>Next, build your code, making sure that the resulting binary name matches the one you defined in your host file—<em>xkcd.exe</em>, in this example:</p>&#13;
<pre><code>azure$ <b>go build -o xkcd.exe xkcd.go</b></code></pre>&#13;
<p>Since your code will run locally, you do not need to explicitly compile your binary for Windows. </p>&#13;
<p>Finally, run <code>func start</code>, which will read the <em>host.json</em> file and execute the <em>xkcd.exe</em> binary:</p>&#13;
<pre><code>azure$ <b>func start</b>&#13;
Azure Functions Core Tools (3.0.2931 Commit hash: &#13;
d552c6741a37422684f0efab41d541ebad2b2bd2)&#13;
Function Runtime Version: 3.0.14492.0&#13;
[2020-10-18T16:07:21.857] Worker process started and initialized.&#13;
[2020-10-18T16:07:21.915] 2020/10/18 12:07:21 Listening on <span class="CodeAnnotation">1</span>":44687" ...&#13;
[2020-10-18T16:07:21.915] 2020/10/18 12:07:21 decoding request: EOF&#13;
Hosting environment: Production&#13;
Content root path: /home/user/dev/gnp/ch14/azure&#13;
Now listening on: <span class="CodeAnnotation">2</span>http://0.0.0.0:7071&#13;
Application started. Press Ctrl+C to shut down.&#13;
&#13;
<span epub:type="pagebreak" id="Page_351" title="351"/>Functions:&#13;
&#13;
    LatestXKCDFunction: [POST] <span class="CodeAnnotation">3</span>http://localhost:7071/api/LatestXKCDFunction&#13;
&#13;
For detailed output, run func with –verbose flag.</code></pre>&#13;
<p>Here, the Azure Functions code set the <code>FUNCTIONS_CUSTOMHANDLER_PORT</code> environment variable to 44687 <span class="CodeAnnotation">1</span> before executing the <em>xkcd.exe</em> binary. Azure Functions also exposes an HTTP endpoint on port 7071 <span class="CodeAnnotation">2</span>. Any requests sent to the <em>LatestXKCDFunction</em> endpoint <span class="CodeAnnotation">3</span> are forwarded onto the <em>xkcd.exe</em> HTTP server, and responses are forwarded to the client.</p>&#13;
<p>Now that the <em>LatestXKCDFunction</em> endpoint is active, you can send HTTP requests to it as you did with your Google Cloud Functions code:</p>&#13;
<pre><code>$ <b>curl -X POST -H "Content-Type: application/json" --data '{}' \</b>&#13;
<b>http://localhost:7071/api/LatestXKCDFunction</b>&#13;
{"title":"Chemist Eggs","url":"https://xkcd.com/2373/",&#13;
"published":"Fri, 16 Oct 2020 04:00:00 -0000"}&#13;
$ <b>curl -X POST -H "Content-Type: application/json" –data \ </b>&#13;
<b>'{"previous":true}' http://localhost:7071/api/LatestXKCDFunction</b>&#13;
{"title":"Dialect Quiz","url":"https://xkcd.com/2372/",&#13;
"published":"Wed, 14 Oct 2020 04:00:00 -0000"}</code></pre>&#13;
<p>As with Google Cloud, sending a <code>POST</code> request with empty JSON in the request body causes the custom handler to return the current XKCD comic title and URL. Requesting the previous comic accurately returns the previous comic’s title and URL.</p>&#13;
<h3 id="h2-500884c14-0019">Deploying the Custom Handler</h3>&#13;
<p class="BodyFirst">Since you’re using a custom handler, the deployment process is slightly more complicated than that for Lambda or Cloud Functions. This section walks you through the steps on Linux. You can find the entire process detailed at <a class="LinkURL" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function-azure-cli/">https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function-azure-cli/</a>.</p>&#13;
<p>Start by issuing the <code>az login</code> command to make sure your Azure CLI’s authorization is current:</p>&#13;
<pre><code>$ <b>az login</b>&#13;
You have logged in.</code></pre>&#13;
<p> Next, create a resource group and specify the location you’d like to use. You can get a list of locations using <code>az account list-locations</code>. This example uses <code>NetworkProgrammingWithGo</code> for the resource group name and <code>eastus</code> for the location:</p>&#13;
<pre><code>$ <b>az group create --name NetworkProgrammingWithGo --location eastus</b>&#13;
{&#13;
  "id": "/subscriptions/<var>--snip--</var>/resourceGroups/NetworkProgrammingWithGo",&#13;
  "location": "eastus",&#13;
<span epub:type="pagebreak" id="Page_352" title="352"/>  "managedBy": null,&#13;
  "name": "NetworkProgrammingWithGo",&#13;
  "properties": {&#13;
    "provisioningState": "Succeeded"&#13;
  },&#13;
  "tags": null,&#13;
  "type": "Microsoft.Resources/resourceGroups"&#13;
}</code></pre>&#13;
<p>Then, create a unique storage account, specifying its name, location, the resource group name you just created, and the <code>Standard_LRS</code> SKU:</p>&#13;
<pre><code>$ <b>az storage account create --name npwgstorage --location eastus \</b>&#13;
<b>--resource-group NetworkProgrammingWithGo --sku Standard_LRS</b>&#13;
 - Finished ..&#13;
<var>--snip--</var></code></pre>&#13;
<p>Finally, create a function application with a unique name, making sure to specify you’re using Functions 3.0 and a custom runtime:</p>&#13;
<pre><code>$ <b>az functionapp create --resource-group NetworkProgrammingWithGo \</b>&#13;
<b>--consumption-plan-location eastus --runtime custom \</b>&#13;
<b>--functions-version 3 --storage-account npwgstorage --name latestxkcd</b>&#13;
Application Insights "latestxkcd" was created for this Function App. &#13;
<var>--snip--</var></code></pre>&#13;
<p>At this point, you’re ready to compile your code and deploy it. Since your code will run on Windows, it’s necessary to build your binary for Windows. Then, publish your custom handler.</p>&#13;
<pre><code>$ <b>cd azure</b>&#13;
azure$ <b>GOOS=windows go build -o xkcd.exe xkcd.go</b>&#13;
azure$ <b>func azure functionapp publish latestxkcd --no-build</b>&#13;
Getting site publishing info...&#13;
Creating archive for current directory…&#13;
Skipping build event for functions project (--no-build).&#13;
Uploading 6.12 MB [##########################################################]&#13;
Upload completed successfully.&#13;
Deployment completed successfully.&#13;
Syncing triggers...&#13;
Functions in latestxkcd:&#13;
    LatestXKCDFunction - [httpTrigger]&#13;
        Invoke url: <span class="CodeAnnotation">1</span>https://latestxkcd.azurewebsites.net/api/latestxkcdfunction</code></pre>&#13;
<p>Once the code is deployed, you can send <code>POST</code> requests to your custom handler’s URL <span class="CodeAnnotation">1</span>. The actual URL is a bit longer than this one, and it includes URI parameters relevant to Azure Functions. I’ve snipped it for brevity.</p>&#13;
<h3 id="h2-500884c14-0020"><span epub:type="pagebreak" id="Page_353" title="353"/>Testing the Custom Handler</h3>&#13;
<p class="BodyFirst">Assuming you’re using your custom handler’s full URL, it should return results like those seen here:</p>&#13;
<pre><code>$ <b>curl -X POST -H "Content-Type: application/json" --data '{}' \</b>&#13;
<b>https://latestxkcd.azurewebsites.net/api/latestxkcdfunction?</b><var>--snip--</var>&#13;
{"title":"Chemist Eggs","url":"https://xkcd.com/2373/",&#13;
"published":"Fri, 16 Oct 2020 04:00:00 -0000"}&#13;
$ <b>curl -X POST -H "Content-Type: application/json" \</b>&#13;
<b>--data '{"previous":true}' \</b>&#13;
<b>https://latestxkcd.azurewebsites.net/api/latestxkcdfunction?</b><var>--snip--</var>&#13;
{"title":"Chemist Eggs","url":"https://xkcd.com/2373/",&#13;
"published":"Fri, 16 Oct 2020 04:00:00 -0000"}</code></pre>&#13;
<p>Use<code> curl</code> to query your Azure Functions custom handler. As expected, empty JSON results in the current XKCD comic’s title and URL, whereas a request for the previous comic properly returns the previous comic’s details.</p>&#13;
<h2 id="h1-500884c14-0005">What You’ve Learned</h2>&#13;
<p class="BodyFirst">When you use cloud offerings, you can focus on application development and avoid the costs of acquiring a server infrastructure, software licensing, and the human resources required to maintain it all. This chapter explored Amazon Web Services, Google Cloud, and Microsoft Azure, all of which offer comprehensive solutions that allow you to scale your business and pay as you go. We used AWS Lambda, Google Cloud Functions, and Microsoft Azure Functions, which are all PaaS offerings that allow you to deploy an application while letting the platform handle the implementation details.</p>&#13;
<p>As you saw, developing and deploying an application on the three cloud environments follow the same general process. First, you install the platform’s command line tools. Next, you authorize the command line tools to act on behalf of your account. You then develop your application for the target platform and deploy it. Finally, you make sure your application works as expected.</p>&#13;
<p>Both AWS Lambda and Cloud Functions have first-class support for Go, making the development and deployment workflow easy. Although Azure Functions doesn’t explicitly support Go, you can write a custom handler to use with the service. But despite the small variations in the development, deployment, and testing workflows, all three cloud platforms can generate the same result. Which one you should use comes down to your use case and budget.</p>&#13;
</section>&#13;
</body></html>