- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Splitting Numbers with Prime Factorization**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prime numbers are like the chemical elements of the world of positive integers.
    They’re basic building blocks that can be used to produce other positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: The science of chemistry teaches us that a few substances, the elements, make
    up everything in the world. Atoms of elements combine to make other substances
    called compounds, but an element’s atoms can’t be split apart without losing their
    physical properties. Similarly, we can combine prime numbers (through multiplication)
    to make any composite number we might want, and prime numbers can’t be divided
    any further, since a prime number’s only factors are itself and 1.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore *prime factorization*, the process of identifying
    the prime numbers that can be multiplied together to produce a given composite
    number. We’ll consider how a number can be written as a product of primes and
    examine some of the interesting things we can learn from a number’s prime factors.
  prefs: []
  type: TYPE_NORMAL
- en: The Fundamental Theorem of Arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s an important fact about primes—so important that it’s called the *fundamental
    theorem of arithmetic*—that every composite number has its own unique set of prime
    factors. In this sense, multiplication and addition are quite different. If you
    want to get 16 as an answer by adding smaller numbers, there are lots of ways
    to do it: 2 + 14, 5 + 11, 3 + 13, 5 + 4 + 6 + 1, and so on. But if you want to
    write 16 as a product of prime numbers, the only way is 2 ⋅ 2 ⋅ 2 ⋅ 2\. Likewise,
    the only way to get 20 by multiplying primes is 2 ⋅ 2 ⋅ 5, and the only way to
    get 54,252 is 2 ⋅ 2 ⋅ 3 ⋅ 3 ⋅ 11 ⋅ 137.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these is an example of prime factorization: we’ve identified the unique
    set of prime numbers that we can multiply together to create a certain composite
    number. Once you know the prime factors of a number, you can find out a lot about
    the number’s divisors and how the number relates to other numbers through common
    divisors or multiples. But how do we calculate a number’s prime factors in the
    first place?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 10: Is It a Prime Factor?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Project 6](ch02.xhtml#ch02lev7), we determined if a number was prime by
    dividing it by every integer starting from 2\. We can use a similar trial division
    approach to find the prime factors of a number. All we need to do is keep track
    of the prime factors as they’re revealed during the division process. [Figure
    3-1](ch03.xhtml#ch3fig1) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg62_Image_59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Factoring a number into primes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program works by finding smaller prime factors first. We use two variables:
    `rest`, which starts as the number to factor, and `factor`, which starts as `2`.
    If `rest mod factor` is `0`, we’ve found a prime factor, so we store it in a list
    called `factors`. We then remove that factor from `rest` by dividing `rest` by
    `factor` and storing the result back into `rest` ➋. Next, the loop starts again
    using the new value of `rest`. When `rest mod factor` isn’t `0`, we increase `factor`
    by `1`. Like when we tested for primes in [Project 6](ch02.xhtml#ch02lev7), we
    can stop looking for factors after we reach the square root of `rest` ➊ because
    at that point, `rest` must be either prime or `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `factors` list is shown on the stage, so when the program is finished, all
    the prime factors are displayed (maybe with scrolling, if the list gets too long).
    [Figure 3-2](ch03.xhtml#ch3fig2) shows a sample run of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg63_Image_60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Finding the prime factors of 54,252*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully identified the prime factorization of 54,252 as 2 ⋅ 2 ⋅ 3
    ⋅ 3 ⋅ 11 ⋅ 137\. Scratch automatically numbers the elements of a list, so we can
    see at a glance that 54,252 has exactly six prime factors. Knowing how many prime
    factors a number has will come in handy later on.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice that a prime number can be repeated within a number’s prime factorization.
    We can modify the code in [Figure 3-1](ch03.xhtml#ch3fig1) to represent these
    repeated factors using exponents, since an exponent indicates repeated multiplication.
    For instance, instead of listing the prime factors of 54,252 as {2, 2, 3, 3, 11,
    137}, we could use exponents to write the factorization as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg63_Image_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 3-3](ch03.xhtml#ch3fig3) shows a way to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg64_Image_62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Factorization with exponents*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the program adds two more lists: `primes` keeps track of each
    *unique* prime number in the prime factorization, and `exps` keeps track of how
    many times each unique prime factor occurs (that is, the exponents). The program
    clears all the old values from the lists when it begins ❶. Then, each time a prime
    factor is found, we check if that factor has occurred already ➋. If it has, instead
    of adding it to the `primes` list, we increment the last exponent in the `exps`
    list by `1`. If this factor hasn’t occurred before, we add it to `primes` and
    add a `1` to the end of `exps` to represent that factor’s exponent.'
  prefs: []
  type: TYPE_NORMAL
- en: The lists of unique prime factors and exponents are displayed on the screen
    along with the original list of all the prime factors, including duplicates. [Figure
    3-4](ch03.xhtml#ch3fig4) shows an example with several different prime factors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg65_Image_63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: The output for a factorization with exponents*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the contents of the `primes` and `exps` lists side by side, we can
    interpret the prime factorization of 1,036,728 as 2³ ⋅ 3² ⋅ 7¹ ⋅ 11² ⋅ 17¹. We’ll
    use this modified version of the program for other projects later in this chapter,
    where we’ll want to use the unique prime factors and their exponents to make various
    calculations. For those other programs, we can simply hide the lists from the
    Scratch stage when we don’t want to see them.
  prefs: []
  type: TYPE_NORMAL
- en: Fun with Divisors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve been talking about prime *factors*, but we can also think of them
    as prime *divisors*—the primes that evenly divide a number. Once we format a number’s
    prime factorization as a list of unique primes and their associated exponents,
    as we did in [Figure 3-3](ch03.xhtml#ch3fig3), that list of unique primes is actually
    a list of the number’s prime divisors. And once we know the *prime* divisors of
    a number, we can build a list of *all* the divisors of the number, not just the
    prime ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is to build each divisor by multiplying the prime divisors together
    in different combinations, based on their exponents. For example, the prime factorization
    of 54 is 2¹ ⋅ 3³. This tells us that any divisor of 54 has to be built from zero
    or one factors of 2 (2⁰ or 2¹) and between zero and three factors of 3 (3⁰, 3¹,
    3², or 3³). Two choices for the number of factors of 2 paired up with four choices
    for the number of factors of 3 gives eight ways in all to build a divisor of 54:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg66_Image_64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Zooming out from this example, we can start coming up with rules for counting
    how many divisors a number has. The Greek letter tau (*τ*) is usually used to
    represent the total number of divisors, so *τ*(*n*) refers to the number of divisors
    of the positive integer *n*. To start, here are some special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) Prime numbers have exactly two divisors, so
    *τ*(*p*) = 2 if *p* is prime.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) The only divisor of 1 is 1, so *τ*(1) = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) If *p* is a prime number, the divisors of
    *p*^(*n*), some positive power of *p*, are 1, *p*, *p*², . . . , *p*^(*n*). That
    means *τ*(*p*^(*n*)) = *n* + 1\. Notice that this works for the previous two special
    cases. For the prime number itself, *p* = *p*¹, so *τ*(*p*¹) = 1 + 1, giving us
    two divisors. We can also think of *τ*(1) = 1 as equivalent to *τ*(*p*⁰) = 0 +
    1 = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) If *n* is a product of two different primes,
    *p* and *q*, then the divisors of *n* are 1, *p*, *q*, and *p* ⋅ *q*, so *τ*(*n*)
    = 4\. A number that’s a product of two prime numbers is called a *biprime*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More broadly, how do we determine *τ*(*n*) for any composite number *n*? First,
    we can find the prime factorization of *n* by running *n* through the factorization
    program from [Figure 3-3](ch03.xhtml#ch3fig3). That gives us two lists: a list
    of primes dividing *n* and a list of exponents. For each prime, the exponent tells
    us the largest possible power of the prime that divides *n*, so we can build a
    divisor of *n* using any number of repetitions of that prime from 0 to the exponent.
    Since we’re counting from 0, the total number of possibilities is the exponent
    plus 1\. So, to get *τ*(*n*), all we have to do is add 1 to each prime’s exponent
    and multiply the results together. This is equivalent to building divisors out
    of every possible combination of prime factors with every possible combination
    of exponents.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our example of 54, we know the prime factorization is 2¹ ⋅ 3³,
    so *τ*(54) = (1 + 1) ⋅ (3 + 1) = 8 divisors total. Scratch Cat agrees in [Figure
    3-5](ch03.xhtml#ch3fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg66_Image_65.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: Finding τ(54)*'
  prefs: []
  type: TYPE_NORMAL
- en: But how did Scratch Cat arrive at this conclusion? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 11: Tau Many Divisors?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can calculate *τ*(*n*), the total number of divisors of *n*, by adding some
    code to the end of the prime factorization program with exponents from [Figure
    3-3](ch03.xhtml#ch3fig3). [Figure 3-6](ch03.xhtml#ch3fig6) shows the extra code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg67_Image_66.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: Using the exponents of n’s prime factors to calculate the total
    number of n’s divisors*'
  prefs: []
  type: TYPE_NORMAL
- en: After we create the list of exponents using the code from [Figure 3-3](ch03.xhtml#ch3fig3),
    this extra code works its way through that `exps` list, starting from the beginning,
    and accumulates the total number of divisors in the `divisors` variable. For each
    exponent, we add `1` and then multiply the result by the current value of `divisors`.
    We delete each exponent from the list as we go ➊ so we can always take the first
    item from the list. The `if...else` statement ➋ just makes Scratch Cat’s grammar
    correct, so if the user asks how many divisors the number 1 has (the only positive
    integer with one divisor), the answer is singular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 12: Summing Up to Sigma'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if we want to find the sum of a number’s divisors? The sum of the divisors
    of *n* is represented with the Greek letter sigma as *σ*(*n*). We can use the
    same kind of strategy that worked for counting the number of divisors, where we
    keep track of one prime divisor of *n* and its associated exponent at a time.
    This is an example of *combinatorics*, a branch of mathematics sometimes called
    the *art of counting*, that figures out how often something can happen by analyzing
    simpler cases. We’ll look more closely at combinatorial reasoning in [Chapter
    7](ch07.xhtml#ch07), but for now it’s a useful tool for understanding the arithmetic
    of divisors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to calculate *σ*(*n*), first consider that for a given prime number
    *p*, the only divisors of the *k*th power of that prime are the powers of *p*
    from *p*⁰ = 1 up to *p*^(*k*) itself. For example, the divisors of 3³ = 27 are
    1 (3⁰), 3 (3¹), 9 (3²), and 27 (3³). So, the sum of the divisors of 27 is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg68_Image_67.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an example of a sum of a *geometric sequence*, a sequence of numbers
    where each one after the first is determined by multiplying the previous number
    by a constant value (in this case, 3). There’s a formula for calculating the sum
    (or *geometric series*) of the numbers in such a sequence, *σ*(*p*^(*k*)). In
    the case of adding all the powers of 3 from 3⁰ to 3³, the formula is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg68_Image_68.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the formula involves 3⁴, one exponent higher than we’re looking
    for. More generally, if *p* is a prime divisor and *k* is its exponent, the formula
    for summing all the powers of *p* from 0 to *k* is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg68_Image_69.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find the sum of all the divisors of *n*, all we have to do is apply this
    formula to each prime divisor of *n* and its associated exponent, then multiply
    all the results together. This is essentially the same trick that worked for counting
    the number of divisors: we’re building the divisors one prime factor at a time,
    considering all combinations of prime factors and exponents.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we calculated a number’s prime factors and exponents in the program in
    [Figure 3-3](ch03.xhtml#ch3fig3), we can once again add some code to that program
    to sum the number’s divisors. But first, because the formula hinges on calculating
    powers, we need a way to easily do calculations with exponents. Scratch doesn’t
    have a built-in operator for this, so we’ll have to make our own by defining a
    custom block, as shown in [Figure 3-7](ch03.xhtml#ch3fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg68_Image_70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: A block to calculate positive integer powers*'
  prefs: []
  type: TYPE_NORMAL
- en: This block takes in two values, `base` and `exponent`, and multiplies `base`
    by itself `exponent` number of times, storing the answer in the `result` variable.
    With the help of this block, we can now add the code shown in [Figure 3-8](ch03.xhtml#ch3fig8)
    to the program we created earlier, in [Figure 3-3](ch03.xhtml#ch3fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg69_Image_71.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-8: Using the exponents of* n*’s prime factors to calculate the sum*
    *of* n*’s divisors*'
  prefs: []
  type: TYPE_NORMAL
- en: We pull each prime *p* and its exponent *k* from the `primes` and `exps` lists
    and use our custom `power` block to calculate *p*^(*k* + 1). Then, we plug the
    results into the formula given earlier, keeping track of the total using the `sum`
    variable. When we reach the end of the two lists, we subtract the original number
    from `sum` before reporting the final answer. This gives us the sum of the number’s
    *proper* divisors, excluding the number itself from the total.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both the `primes` and `exps` lists are cleared as the calculation
    proceeds. As with our program counting the number of divisors, it’s easier to
    always grab the first item from each list and then delete that item, making the
    next list element the new element 1, rather than having to keep track of the item
    number within each list.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s always a good idea to test your code as you write it to make sure it does
    what you want. For example, we can test our custom `power` block from [Figure
    3-7](ch03.xhtml#ch3fig7) by checking the box next to the `result` variable so
    its value appears on the stage. We can then drag the block into the programming
    area, enter values for the arguments, and click the block and see if `result`
    shows the correct value. [Figure 3-9](ch03.xhtml#ch3fig9) tests the block by calculating
    flintmax. As we discussed in [Chapter 1](ch01.xhtml#ch01), this is the largest
    integer that Scratch Cat can get to when counting by ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg70_Image_72.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-9: Calculating 2^(53) using the* power *block*'
  prefs: []
  type: TYPE_NORMAL
- en: When I’m programming in Scratch, I debug my code by displaying lots of variables
    on the stage and isolating sections of the code to verify that it behaves as I
    expect. Once the code works, I clean up the stage by hiding the variables that
    don’t need to be seen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1** Remember that 6 is the first perfect number, so called because it’s
    equal to the sum of its proper divisors: 1 + 2 + 3 = 6\. Use the sum of divisors
    code in [Figure 3-8](ch03.xhtml#ch3fig8) to find three other perfect numbers less
    than 10,000.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2** A number *n* can fail to be perfect in two ways: either the sum of
    proper divisors of *n* is less than *n*, in which case *n* is called *deficient*,
    or the sum of proper divisors of *n* is greater than *n*, in which case *n* is
    called *abundant*. Write some Scratch code that reports if a given number is deficient,
    perfect, or abundant. How many of each kind of number are there (up to 10, 100,
    1,000)?'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3** Raising a nonzero number to the 0 power gives an answer of 1\. Check
    the exponent block in [Figure 3-7](ch03.xhtml#ch3fig7) to see if it works for
    an exponent of 0\. If it doesn’t, rewrite the block so it gives the correct result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.4** Negative exponents are calculated using reciprocals: *n^(–k)* = 1/*n*^(*k*).
    Make the exponent block give correct answers for negative exponents.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5** Change the code for *τ* and *σ* so that instead of deleting list elements
    after you access them you use a new counter variable, say `i`, to access each
    of the list elements in order.'
  prefs: []
  type: TYPE_NORMAL
- en: How Prime Factorization Helps Find GCDs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.xhtml#ch02), we explored techniques for finding the greatest
    common divisor (GCD) of two integers *b* and *a*. If we know the prime factorization
    of each integer, we have another option. Say we have the following two prime factorizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_73.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find the GCD of *b* and *a*, the first step is to rewrite their prime factorizations
    to include each prime factor of either number, using exponent 0 if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_74.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we’ve added 7⁰ to the prime factorization of *a* and 5⁰ and 11⁰ to the
    prime factorization of *b*. Next, for each prime factor, we compare *a* and *b*
    and take the minimum exponent. For example, the minimum of 3² and 3³ is 3². The
    GCD of *b* and *a* is the product of the prime factorization using just the minimum
    exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_75.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we’ve already invested the time and effort to factor *b* and *a*, then this
    can be a useful approach. But if we don’t know the factorizations ahead of time,
    it’s more efficient to use Euclid’s algorithm to find the GCD, as we did in [Project
    9](ch02.xhtml#ch02lev14).
  prefs: []
  type: TYPE_NORMAL
- en: A related concept to the GCD is the *least common multiple (LCM)*. The LCM of
    *b* and *a* is the smallest number that’s a multiple of both. For example, the
    LCM of 2 and 3 is 6\. The LCM is useful for adding fractions, since the LCM of
    the two denominators is the common denominator you should convert to before doing
    the addition. In this context, the least common multiple is called the *least
    common denominator (LCD)*. This can be a little confusing if you forget that the
    D in LCD stands for denominator while the D in GCD stands for divisor!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the prime factorizations of *b* and *a*, calculating their LCM is
    quite similar to calculating their GCD. The only difference is that we take the
    *maximum* exponent of each prime factor rather than the minimum. Continuing with
    our example of *b* = 5,292 and *a* = 990, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_76.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we use minimum exponents to find the GCD and maximum exponents to find
    the LCM, a neat hack is that multiplying the GCD and LCM of two numbers *b* and
    *a* is equivalent to multiplying the two numbers themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_77.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By extension, if we’ve calculated GCD(*b*, *a*), we can calculate LCM(*b*,
    *a*) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_78.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.6** Write a custom block that will let you determine whether a given number
    is prime using trial division.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7** Use the block from Challenge 3.6 to write another custom block that
    will tell you the next prime number after a given number. If you wanted to program
    a GCD calculator using a factorization approach based on the program from [Project
    10](ch03.xhtml#ch03lev2) ([Figure 3-3](ch03.xhtml#ch3fig3)), you would need to
    make sure the lists of prime factors of the two numbers both had all the same
    primes, so blocks like these would come in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.8** A Spirograph is a classic toy that lets you draw intricate curves by
    rotating a toothed gear inside a toothed ring. The following picture shows how
    different gear sizes lead to different shapes. Lots of people have made Spirograph
    simulators using Scratch, and you can probably find other versions that run in
    web pages. Write a program to have Scratch Cat use GCD or LCM blocks to predict
    how many “points” a curve will have when a gear with *b* teeth is rotated inside
    a ring with 96 teeth.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg72_Image_79.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Contacting Aliens with Biprimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Biprimes, also sometimes called *semiprimes*, are an intriguing group of numbers.
    As the product of two primes, a biprime by definition has just two prime factors.
    This opens up an interesting possibility: you can use the biprime to combine information
    from each of its prime factors.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a real-life example where biprimes came in handy. In 1974, scientists
    broadcast the Arecibo message out into space from the Arecibo radio telescope
    in Puerto Rico. They wanted the message to include information about human life
    on Earth so that anyone who received it would know we exist and learn something
    about us. But they didn’t want to write the message in English or some other human
    language, since the recipients might not understand it. Instead, the message’s
    authors decided to design it as a series of bits (0s and 1s) meant to be arranged
    in a rectangle, with the 0 bits colored white and the 1 bits colored black, to
    produce a pixelated image. How long should the message be, though, and how would
    the receiver know to arrange the bits into a rectangle of the right size?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re designing such a message. The message has *n* bits. If the rectangle
    has dimensions *a* ⋅ *b*, you’ll need to have *a* and *b* be factors of *n*, such
    that *a* ⋅ *b* = *n*. If *n* were prime, there would be only one factorization,
    1 ⋅ *n* (or *n* ⋅ 1), so the bits would be arranged in a single long row or column—pretty
    useless. But if *n* had lots of factors, there would be lots of possible dimensions
    for the rectangle—not very helpful either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to make *n* a biprime. This way, it has only two significant
    factors (excluding 1 and *n* itself), the two primes that multiply together to
    make *n*, so the dimensions of the rectangle are clear. That’s exactly what the
    Arecibo team did, sending a message of 1,679 bits. Since 1,679 = 73 ⋅ 23, there
    are only two possible ways to organize the bits: 23 rows and 73 columns, or 73
    rows and 23 columns. For the bit string they sent, the first possibility decodes
    as a random arrangement of dots, but the second gives the image shown in [Figure
    3-10](ch03.xhtml#ch3fig10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg73_Image_80.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-10: The Arecibo message*'
  prefs: []
  type: TYPE_NORMAL
- en: The message squeezes in information about counting in binary, the chemistry
    underlying life, the solar system, the size of a typical human, and the telescope
    that sent the message—pretty impressive for just 1,679 1s and 0s. Unfortunately,
    the Arecibo telescope collapsed in 2020, but even though the telescope is gone,
    the message is on its way to the globular cluster Messier 13 and should arrive
    in about 25,000 years.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the information from the Arecibo message, all we need to do is factor
    its length, *n*. We already have a way to do that by trial division, as in [Project
    10](ch03.xhtml#ch03lev2), but this approach can be slow for large numbers—especially
    large biprimes—since we’ll have to go through trial division with all the small
    numbers first. As we’ll see in the next project, knowing that we’re trying to
    factor a biprime gives us a shortcut. We might expect a biprime’s two prime factors
    to be close to the same size, hovering around the square root of *n*. We can start
    looking from there instead of from 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 13: Fermat’s Factorization Feat'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The mathematician Pierre de Fermat realized that there’s a more efficient way
    to factor numbers with two factors close to the same size, such as the biprimes
    we’re interested in here. The technique is based on the formula for the difference
    of squares. Suppose we have the number *n* written as a difference of squares,
    *n* = *a*² – *b*². We can rewrite this as *n* = (*a* – *b*)(*a* + *b*). Viewing
    the formula this way tells us that (*a* – *b*) and (*a* + *b*) must be factors
    of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to find *a* and *b* from *n*. For that, we’ll rewrite the equation
    as *a*² – *n* = *b*², try various choices for *a*, and look for a choice that
    makes the difference *a*² – *n* a perfect square, which we can use to find *b*.
    First, we need to recognize perfect squares, which we do in the custom block in
    [Figure 3-11](ch03.xhtml#ch3fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_81.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-11: Do we have a perfect square?*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a Boolean block, returning a logical value of `true` or `false` depending
    on whether the number passed in is a perfect square. We calculate the square root
    of `number`, use the built-in `floor` function to round the result down to the
    nearest integer ❶, and compare the two. If `number` is a perfect square, its square
    root is already an integer, so the comparison is equal.
  prefs: []
  type: TYPE_NORMAL
- en: Once we can recognize perfect squares, we can start searching for them to identify
    *a* and *b* and, by extension, the factors of *n*. The program in [Figure 3-12](ch03.xhtml#ch3fig12)
    shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg75_Image_82.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-12: Fermat factorization*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by picking a value of *a* just a little smaller than ![Images](../images/pg50_Image_41.jpg)
    ❶. Then, in a loop, we increase *a* by `1` ➌ and check if *a*² – *n* is a perfect
    square. (Decreasing *a* by `1` just before the loop ➋ lets us catch the case where
    *n* happens to be a perfect square itself.) Once we’ve found a value of *b* that
    works, we calculate and display the factors `factor1` (*a* + *b*) and `factor2`
    (*a* – *b*).
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 3-13](ch03.xhtml#ch3fig13) shows the results of a sample run of the
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg75_Image_83.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-13: Factoring 4,398,091,599,977*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that rather than having Scratch Cat say the results, we simply display
    the relevant variables on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It would be interesting to compare the timing of the Fermat factorization approach
    to the trial division approach from [Project 10](ch03.xhtml#ch03lev2). You might
    notice in [Figure 3-13](ch03.xhtml#ch3fig13) that there’s an extra variable showing
    on the screen, called `time`, for that purpose. We embedded a program in a timer
    loop before, in [Project 9](ch02.xhtml#ch02lev14), when we were checking how long
    it took to test for a prime using trial division (see [Figure 2-19](ch02.xhtml#ch2fig19)
    on [page 39](ch02.xhtml#page_39)). This time, we’ll create two simple custom blocks
    to turn Scratch’s internal timer on and off, as shown in [Figure 3-14](ch03.xhtml#ch3fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg76_Image_84.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-14: Timer blocks*'
  prefs: []
  type: TYPE_NORMAL
- en: To time the Fermat factorization program, add the `timer start` block right
    before the third `set` block ➊ in [Figure 3-12](ch03.xhtml#ch3fig12), and add
    the `timer stop` block to the end of the program. As we discussed in [Chapter
    2](ch02.xhtml#ch02), Scratch’s default time unit is seconds, so the time might
    be reported as `0` for small numbers because the actual time interval is too short
    to display after rounding. Running the program repeatedly and dividing the total
    time by the number of runs should give a more accurate result. This hack also
    helps cancel out the effect that other processes running on your computer have
    on the speed of the Scratch program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.9** Add a test to the Fermat factorization code in [Figure 3-12](ch03.xhtml#ch3fig12)
    that checks whether the factors it produces are prime numbers. This will tell
    you if the input number is truly a biprime.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.10** Combine the Fermat factorization code in [Figure 3-12](ch03.xhtml#ch3fig12)
    with the trial division code from [Figure 2-6](ch02.xhtml#ch2fig6) on [page 28](ch02.xhtml#page_28)
    so you can compare how long each method takes to find a factorization.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.11** Scratch’s stage is 480 pixels by 360 pixels. Write a program that
    takes a string of *n = a* ⋅ *b* bits (where *a* is at most 480 and *b* is at most
    360) and displays it on the screen in a rectangle of *a* by *b* pixels, coloring
    in the 1 bits black and the 0 bits white. Try to use the program to recreate the
    Arecibo message.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We asked different questions in this chapter and in [Chapter 2](ch02.xhtml#ch02)
    (“How does a number factor?” and “Is a number prime?”), but we used the same initial
    approach to answer them in both cases: trial division. As we’ve seen, this approach
    is limited by the time we have available for performing the work. In the worst
    case, it takes as many steps as the square root of the number being tested to
    find an answer. For numbers up to flintmax, that isn’t too long, but for numbers
    with hundreds of digits, there isn’t enough time in the universe for trial division
    to work. Other approaches, such as Fermat factorization, can help us find the
    result we’re looking for more quickly, especially when we have a clue about the
    shape of the number, such as whether it’s a biprime. If you can think of a way
    to speed up the arithmetic, Scratch Cat will give you an answer more quickly!'
  prefs: []
  type: TYPE_NORMAL
