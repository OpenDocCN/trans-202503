- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**Splitting Numbers with Prime Factorization**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**通过素因数分解拆分数字**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Prime numbers are like the chemical elements of the world of positive integers.
    They’re basic building blocks that can be used to produce other positive integers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 素数就像正整数世界中的化学元素。它们是基本的构建块，可以用来生成其他正整数。
- en: The science of chemistry teaches us that a few substances, the elements, make
    up everything in the world. Atoms of elements combine to make other substances
    called compounds, but an element’s atoms can’t be split apart without losing their
    physical properties. Similarly, we can combine prime numbers (through multiplication)
    to make any composite number we might want, and prime numbers can’t be divided
    any further, since a prime number’s only factors are itself and 1.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 化学科学教会我们，少数物质——元素，构成了世界上的一切。元素的原子结合形成其他物质，叫做化合物，但元素的原子无法分开，否则会失去其物理属性。类似地，我们可以通过乘法将素数结合起来，生成任何我们想要的合成数，而素数无法再被进一步分解，因为素数的唯一因子就是它本身和1。
- en: In this chapter, we’ll explore *prime factorization*, the process of identifying
    the prime numbers that can be multiplied together to produce a given composite
    number. We’ll consider how a number can be written as a product of primes and
    examine some of the interesting things we can learn from a number’s prime factors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨*素因数分解*，即识别可以相乘得到给定合成数的素数的过程。我们将考虑如何将一个数字写成素数的乘积，并研究从数字的素因子中可以学到的一些有趣的事情。
- en: The Fundamental Theorem of Arithmetic
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术基本定理
- en: 'It’s an important fact about primes—so important that it’s called the *fundamental
    theorem of arithmetic*—that every composite number has its own unique set of prime
    factors. In this sense, multiplication and addition are quite different. If you
    want to get 16 as an answer by adding smaller numbers, there are lots of ways
    to do it: 2 + 14, 5 + 11, 3 + 13, 5 + 4 + 6 + 1, and so on. But if you want to
    write 16 as a product of prime numbers, the only way is 2 ⋅ 2 ⋅ 2 ⋅ 2\. Likewise,
    the only way to get 20 by multiplying primes is 2 ⋅ 2 ⋅ 5, and the only way to
    get 54,252 is 2 ⋅ 2 ⋅ 3 ⋅ 3 ⋅ 11 ⋅ 137.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 素数的一个重要事实——重要到被称为*算术基本定理*——是每个合成数都有自己独特的素因子集合。从这个意义上讲，乘法和加法是完全不同的。如果你想通过加法得到16，方法有很多：2
    + 14、5 + 11、3 + 13、5 + 4 + 6 + 1，等等。但如果你想将16写成素数的乘积，唯一的方法是2 ⋅ 2 ⋅ 2 ⋅ 2。同样，唯一通过素数相乘得到20的方法是2
    ⋅ 2 ⋅ 5，唯一得到54,252的方法是2 ⋅ 2 ⋅ 3 ⋅ 3 ⋅ 11 ⋅ 137。
- en: 'Each of these is an example of prime factorization: we’ve identified the unique
    set of prime numbers that we can multiply together to create a certain composite
    number. Once you know the prime factors of a number, you can find out a lot about
    the number’s divisors and how the number relates to other numbers through common
    divisors or multiples. But how do we calculate a number’s prime factors in the
    first place?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是素因数分解的例子：我们已识别出一组独特的素数，可以将它们相乘得到某个合成数。一旦你知道了一个数字的素因子，你就可以了解该数字的因子，以及它如何通过共同的因子或倍数与其他数字相关联。但我们首先如何计算一个数字的素因子呢？
- en: 'Project 10: Is It a Prime Factor?'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目10：它是素因子吗？
- en: In [Project 6](ch02.xhtml#ch02lev7), we determined if a number was prime by
    dividing it by every integer starting from 2\. We can use a similar trial division
    approach to find the prime factors of a number. All we need to do is keep track
    of the prime factors as they’re revealed during the division process. [Figure
    3-1](ch03.xhtml#ch3fig1) shows how.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章项目](ch02.xhtml#ch02lev7)中，我们通过从2开始逐个整除的方式来判断一个数字是否为素数。我们也可以使用类似的试除法来找出一个数的素因子。我们需要做的就是在除法过程中跟踪已揭示的素因子。[图3-1](ch03.xhtml#ch3fig1)展示了这一过程。
- en: '![Image](../images/pg62_Image_59.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg62_Image_59.jpg)'
- en: '*Figure 3-1: Factoring a number into primes*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：将一个数分解为素数因子*'
- en: 'The program works by finding smaller prime factors first. We use two variables:
    `rest`, which starts as the number to factor, and `factor`, which starts as `2`.
    If `rest mod factor` is `0`, we’ve found a prime factor, so we store it in a list
    called `factors`. We then remove that factor from `rest` by dividing `rest` by
    `factor` and storing the result back into `rest` ➋. Next, the loop starts again
    using the new value of `rest`. When `rest mod factor` isn’t `0`, we increase `factor`
    by `1`. Like when we tested for primes in [Project 6](ch02.xhtml#ch02lev7), we
    can stop looking for factors after we reach the square root of `rest` ➊ because
    at that point, `rest` must be either prime or `1`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序通过首先找到较小的质因子来工作。我们使用两个变量：`rest`，它初始值为待因式分解的数字，以及 `factor`，它初始值为 `2`。如果 `rest
    mod factor` 等于 `0`，则说明我们找到一个质因子，于是我们将其存储在名为 `factors` 的列表中。然后，我们通过将 `rest` 除以
    `factor` 并将结果重新存储到 `rest` 中来去除该因子 ➋。接着，循环使用新的 `rest` 值重新开始。当 `rest mod factor`
    不等于 `0` 时，我们将 `factor` 增加 `1`。就像我们在[项目 6](ch02.xhtml#ch02lev7)中测试质数时一样，当 `rest`
    达到其平方根时，我们可以停止寻找因子 ➊，因为此时 `rest` 要么是质数，要么是 `1`。
- en: The Results
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: The `factors` list is shown on the stage, so when the program is finished, all
    the prime factors are displayed (maybe with scrolling, if the list gets too long).
    [Figure 3-2](ch03.xhtml#ch3fig2) shows a sample run of the program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`factors` 列表会显示在屏幕上，因此当程序完成时，所有的质因子都会被显示出来（如果列表过长，可能会有滚动）。[图 3-2](ch03.xhtml#ch3fig2)展示了该程序的一个示例运行。'
- en: '![Image](../images/pg63_Image_60.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg63_Image_60.jpg)'
- en: '*Figure 3-2: Finding the prime factors of 54,252*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：找到 54,252 的质因子*'
- en: We’ve successfully identified the prime factorization of 54,252 as 2 ⋅ 2 ⋅ 3
    ⋅ 3 ⋅ 11 ⋅ 137\. Scratch automatically numbers the elements of a list, so we can
    see at a glance that 54,252 has exactly six prime factors. Knowing how many prime
    factors a number has will come in handy later on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地识别了 54,252 的质因式分解为 2 ⋅ 2 ⋅ 3 ⋅ 3 ⋅ 11 ⋅ 137。Scratch 会自动为列表中的元素编号，因此我们可以一眼看出
    54,252 有六个质因子。知道一个数有多少个质因子在以后会派上用场。
- en: Hacking the Code
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'Notice that a prime number can be repeated within a number’s prime factorization.
    We can modify the code in [Figure 3-1](ch03.xhtml#ch3fig1) to represent these
    repeated factors using exponents, since an exponent indicates repeated multiplication.
    For instance, instead of listing the prime factors of 54,252 as {2, 2, 3, 3, 11,
    137}, we could use exponents to write the factorization as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，质数在一个数的质因式分解中可以重复出现。我们可以修改[图 3-1](ch03.xhtml#ch3fig1)中的代码，通过指数来表示这些重复的因子，因为指数表示重复的乘法。例如，我们可以使用指数将
    54,252 的质因式分解表示为以下形式，而不是列出 {2, 2, 3, 3, 11, 137}：
- en: '![Image](../images/pg63_Image_61.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg63_Image_61.jpg)'
- en: '[Figure 3-3](ch03.xhtml#ch3fig3) shows a way to do this.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](ch03.xhtml#ch3fig3)展示了一种做法。'
- en: '![Image](../images/pg64_Image_62.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg64_Image_62.jpg)'
- en: '*Figure 3-3: Factorization with exponents*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：带有指数的因式分解*'
- en: 'This version of the program adds two more lists: `primes` keeps track of each
    *unique* prime number in the prime factorization, and `exps` keeps track of how
    many times each unique prime factor occurs (that is, the exponents). The program
    clears all the old values from the lists when it begins ❶. Then, each time a prime
    factor is found, we check if that factor has occurred already ➋. If it has, instead
    of adding it to the `primes` list, we increment the last exponent in the `exps`
    list by `1`. If this factor hasn’t occurred before, we add it to `primes` and
    add a `1` to the end of `exps` to represent that factor’s exponent.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的程序增加了两个列表：`primes` 用于跟踪质因式分解中的每个*唯一*质数，`exps` 用于跟踪每个唯一质因子的出现次数（即指数）。程序开始时会清除列表中的所有旧值
    ❶。然后，每当找到一个质因子时，我们会检查该因子是否已经出现过 ➋。如果出现过，我们就不把它添加到 `primes` 列表，而是将 `exps` 列表中最后一个指数加
    `1`。如果该因子之前没有出现过，我们就将其添加到 `primes` 中，并在 `exps` 的末尾添加 `1` 来表示该因子的指数。
- en: The lists of unique prime factors and exponents are displayed on the screen
    along with the original list of all the prime factors, including duplicates. [Figure
    3-4](ch03.xhtml#ch3fig4) shows an example with several different prime factors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一质因子和指数的列表会与所有质因子的原始列表一起显示在屏幕上，后者包括重复因子。[图 3-4](ch03.xhtml#ch3fig4)展示了一个包含多个不同质因子的示例。
- en: '![Image](../images/pg65_Image_63.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg65_Image_63.jpg)'
- en: '*Figure 3-4: The output for a factorization with exponents*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：带有指数的因式分解输出*'
- en: Looking at the contents of the `primes` and `exps` lists side by side, we can
    interpret the prime factorization of 1,036,728 as 2³ ⋅ 3² ⋅ 7¹ ⋅ 11² ⋅ 17¹. We’ll
    use this modified version of the program for other projects later in this chapter,
    where we’ll want to use the unique prime factors and their exponents to make various
    calculations. For those other programs, we can simply hide the lists from the
    Scratch stage when we don’t want to see them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`primes`和`exps`列表的内容，我们可以将1,036,728的素因数分解解释为2³ ⋅ 3² ⋅ 7¹ ⋅ 11² ⋅ 17¹。我们将在本章后面的其他项目中使用这个修改后的程序，届时我们将利用独特的素因数和它们的指数进行各种计算。对于其他程序，当我们不想看到这些列表时，我们可以简单地将它们从Scratch舞台上隐藏。
- en: Fun with Divisors
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除数的乐趣
- en: So far, we’ve been talking about prime *factors*, but we can also think of them
    as prime *divisors*—the primes that evenly divide a number. Once we format a number’s
    prime factorization as a list of unique primes and their associated exponents,
    as we did in [Figure 3-3](ch03.xhtml#ch3fig3), that list of unique primes is actually
    a list of the number’s prime divisors. And once we know the *prime* divisors of
    a number, we can build a list of *all* the divisors of the number, not just the
    prime ones.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的是素因数，但我们也可以将它们看作素数*除数*——即能整除一个数的素数。当我们将一个数的素因数分解格式化为独特的素数及其相关指数的列表时，如在[图3-3](ch03.xhtml#ch3fig3)中所示，这个独特素数的列表实际上就是该数的素数除数列表。一旦我们知道一个数的*素数*除数，我们就可以构建该数的*所有*除数列表，而不仅仅是素数除数。
- en: 'The trick is to build each divisor by multiplying the prime divisors together
    in different combinations, based on their exponents. For example, the prime factorization
    of 54 is 2¹ ⋅ 3³. This tells us that any divisor of 54 has to be built from zero
    or one factors of 2 (2⁰ or 2¹) and between zero and three factors of 3 (3⁰, 3¹,
    3², or 3³). Two choices for the number of factors of 2 paired up with four choices
    for the number of factors of 3 gives eight ways in all to build a divisor of 54:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是通过根据素数的指数以不同组合的方式将素数除数相乘来构建每一个除数。例如，54的素因数分解是2¹ ⋅ 3³。这告诉我们，54的任何除数必须由零或一个因子的2（2⁰或2¹）和零到三个因子的3（3⁰、3¹、3²或3³）构成。两个选择的2的因子与四个选择的3的因子结合，总共有八种方式构造54的除数：
- en: '![Image](../images/pg66_Image_64.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg66_Image_64.jpg)'
- en: 'Zooming out from this example, we can start coming up with rules for counting
    how many divisors a number has. The Greek letter tau (*τ*) is usually used to
    represent the total number of divisors, so *τ*(*n*) refers to the number of divisors
    of the positive integer *n*. To start, here are some special cases:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子来看，我们可以开始提出一些规则来计算一个数字有多少个除数。希腊字母τ（*τ*）通常用来表示除数的总数，因此*τ*(*n*)表示正整数*n*的除数个数。首先，以下是一些特殊情况：
- en: '![Image](../images/common-1.jpg) Prime numbers have exactly two divisors, so
    *τ*(*p*) = 2 if *p* is prime.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 素数有恰好两个除数，因此如果*p*是素数，则*τ*(*p*) = 2。'
- en: '![Image](../images/common-1.jpg) The only divisor of 1 is 1, so *τ*(1) = 1.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 1的唯一除数是1，因此*τ*(1) = 1。'
- en: '![Image](../images/common-1.jpg) If *p* is a prime number, the divisors of
    *p*^(*n*), some positive power of *p*, are 1, *p*, *p*², . . . , *p*^(*n*). That
    means *τ*(*p*^(*n*)) = *n* + 1\. Notice that this works for the previous two special
    cases. For the prime number itself, *p* = *p*¹, so *τ*(*p*¹) = 1 + 1, giving us
    two divisors. We can also think of *τ*(1) = 1 as equivalent to *τ*(*p*⁰) = 0 +
    1 = 1.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 如果*p*是素数，那么*p*的正整数次幂*p*^(*n*)的除数是1、*p*、*p*²、……、*p*^(*n*)。这意味着*τ*(*p*^(*n*))
    = *n* + 1。注意，这对于前面两个特殊情况也适用。对于素数本身，*p* = *p*¹，因此*τ*(*p*¹) = 1 + 1，给我们两个除数。我们也可以认为*τ*(1)
    = 1等同于*τ*(*p*⁰) = 0 + 1 = 1。'
- en: '![Image](../images/common-1.jpg) If *n* is a product of two different primes,
    *p* and *q*, then the divisors of *n* are 1, *p*, *q*, and *p* ⋅ *q*, so *τ*(*n*)
    = 4\. A number that’s a product of two prime numbers is called a *biprime*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 如果*n*是两个不同素数*p*和*q*的积，那么*n*的除数是1、*p*、*q*和*p*
    ⋅ *q*，所以*τ*(*n*) = 4。一个由两个素数相乘得到的数叫做*biprime*（双素数）。'
- en: 'More broadly, how do we determine *τ*(*n*) for any composite number *n*? First,
    we can find the prime factorization of *n* by running *n* through the factorization
    program from [Figure 3-3](ch03.xhtml#ch3fig3). That gives us two lists: a list
    of primes dividing *n* and a list of exponents. For each prime, the exponent tells
    us the largest possible power of the prime that divides *n*, so we can build a
    divisor of *n* using any number of repetitions of that prime from 0 to the exponent.
    Since we’re counting from 0, the total number of possibilities is the exponent
    plus 1\. So, to get *τ*(*n*), all we have to do is add 1 to each prime’s exponent
    and multiply the results together. This is equivalent to building divisors out
    of every possible combination of prime factors with every possible combination
    of exponents.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，我们如何确定任何合成数*n*的 *τ*(*n*) 呢？首先，我们可以通过运行[图 3-3](ch03.xhtml#ch3fig3)中的因式分解程序来找到
    *n* 的质因数分解。这将给我们两个列表：一个是能整除 *n* 的质数列表，另一个是对应的指数列表。对于每个质数，指数告诉我们能整除 *n* 的该质数的最大可能次方，因此我们可以使用该质数的任意重复次数（从
    0 到指数）来构造 *n* 的因子。由于我们是从 0 开始计数的，所有可能的组合总数是指数加 1。因此，为了得到 *τ*(*n*)，我们所要做的就是将每个质数的指数加
    1，然后将结果相乘。这等同于从每个质因子的所有可能组合和每个指数的所有可能组合中构造因子。
- en: Returning to our example of 54, we know the prime factorization is 2¹ ⋅ 3³,
    so *τ*(54) = (1 + 1) ⋅ (3 + 1) = 8 divisors total. Scratch Cat agrees in [Figure
    3-5](ch03.xhtml#ch3fig5).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们 54 的例子，已知其质因数分解为 2¹ ⋅ 3³，因此 *τ*(54) = (1 + 1) ⋅ (3 + 1) = 共有 8 个因子。Scratch
    Cat 在[图 3-5](ch03.xhtml#ch3fig5)中同意这一结论。
- en: '![Image](../images/pg66_Image_65.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg66_Image_65.jpg)'
- en: '*Figure 3-5: Finding τ(54)*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：计算 τ(54)*'
- en: But how did Scratch Cat arrive at this conclusion? Let’s find out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Scratch Cat 是如何得出这个结论的呢？让我们来看看。
- en: 'Project 11: Tau Many Divisors?'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 11：Tau 多个因子？
- en: We can calculate *τ*(*n*), the total number of divisors of *n*, by adding some
    code to the end of the prime factorization program with exponents from [Figure
    3-3](ch03.xhtml#ch3fig3). [Figure 3-6](ch03.xhtml#ch3fig6) shows the extra code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在质因数分解程序的末尾添加一些代码来计算 *τ*(*n*)，即 *n* 的总因子数量，这些代码使用了[图 3-3](ch03.xhtml#ch3fig3)中的指数。[图
    3-6](ch03.xhtml#ch3fig6)展示了这段额外的代码。
- en: '![Image](../images/pg67_Image_66.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg67_Image_66.jpg)'
- en: '*Figure 3-6: Using the exponents of n’s prime factors to calculate the total
    number of n’s divisors*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-6：使用 *n* 的质因数的指数来计算 *n* 的所有因子总数*'
- en: After we create the list of exponents using the code from [Figure 3-3](ch03.xhtml#ch3fig3),
    this extra code works its way through that `exps` list, starting from the beginning,
    and accumulates the total number of divisors in the `divisors` variable. For each
    exponent, we add `1` and then multiply the result by the current value of `divisors`.
    We delete each exponent from the list as we go ➊ so we can always take the first
    item from the list. The `if...else` statement ➋ just makes Scratch Cat’s grammar
    correct, so if the user asks how many divisors the number 1 has (the only positive
    integer with one divisor), the answer is singular.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用[图 3-3](ch03.xhtml#ch3fig3)中的代码创建指数列表之后，这段额外的代码会从 `exps` 列表的开头开始，逐步处理这个列表，并将所有因子的总数累计到
    `divisors` 变量中。对于每个指数，我们加 1，然后将结果乘以当前 `divisors` 的值。每处理一个指数，我们就从列表中删除它 ➊，这样我们始终可以取出列表中的第一个元素。`if...else`
    语句 ➋ 只是为了让 Scratch Cat 的语法正确，因此，如果用户询问数字 1 的因子数量（1 是唯一只有一个因子的正整数），答案是单数。
- en: 'Project 12: Summing Up to Sigma'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 12：总和到 Sigma
- en: What if we want to find the sum of a number’s divisors? The sum of the divisors
    of *n* is represented with the Greek letter sigma as *σ*(*n*). We can use the
    same kind of strategy that worked for counting the number of divisors, where we
    keep track of one prime divisor of *n* and its associated exponent at a time.
    This is an example of *combinatorics*, a branch of mathematics sometimes called
    the *art of counting*, that figures out how often something can happen by analyzing
    simpler cases. We’ll look more closely at combinatorial reasoning in [Chapter
    7](ch07.xhtml#ch07), but for now it’s a useful tool for understanding the arithmetic
    of divisors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到一个数字的所有因子之和呢？数字*n*的因子之和用希腊字母 sigma 表示，记作 *σ*(*n*)。我们可以使用与计算因子数量相同的策略，在这个过程中我们一次只跟踪一个质因子及其相关的指数。这是*组合数学*的一个例子，组合数学是数学的一个分支，有时被称为*计数的艺术*，它通过分析更简单的情况来计算某事发生的次数。我们将在[第七章](ch07.xhtml#ch07)中更详细地探讨组合推理，但目前来看，它是理解因子算术的一个有用工具。
- en: 'To see how to calculate *σ*(*n*), first consider that for a given prime number
    *p*, the only divisors of the *k*th power of that prime are the powers of *p*
    from *p*⁰ = 1 up to *p*^(*k*) itself. For example, the divisors of 3³ = 27 are
    1 (3⁰), 3 (3¹), 9 (3²), and 27 (3³). So, the sum of the divisors of 27 is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算*σ*(*n*)，首先考虑对于给定的质数*p*，该质数的*k*次方的唯一因子是从*p*⁰ = 1到*p*^(*k*)本身的*p*的各次方。例如，3³
    = 27的因子有1 (3⁰)、3 (3¹)、9 (3²)和27 (3³)。因此，27的因子之和为：
- en: '![Image](../images/pg68_Image_67.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg68_Image_67.jpg)'
- en: 'This is an example of a sum of a *geometric sequence*, a sequence of numbers
    where each one after the first is determined by multiplying the previous number
    by a constant value (in this case, 3). There’s a formula for calculating the sum
    (or *geometric series*) of the numbers in such a sequence, *σ*(*p*^(*k*)). In
    the case of adding all the powers of 3 from 3⁰ to 3³, the formula is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*几何数列*的例子，几何数列是指每个数字（除第一个外）通过将前一个数字乘以一个常数值（在此情况下为3）来确定的序列。对于这种序列中数字的总和（或*几何级数*）有一个计算公式，*σ*(*p*^(*k*)）。在求3⁰到3³的所有幂的和时，公式为：
- en: '![Image](../images/pg68_Image_68.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg68_Image_68.jpg)'
- en: 'Notice that the formula involves 3⁴, one exponent higher than we’re looking
    for. More generally, if *p* is a prime divisor and *k* is its exponent, the formula
    for summing all the powers of *p* from 0 to *k* is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，公式中涉及了3⁴，这是比我们要求的指数高一级的更一般的情况。如果*p*是一个质因子，*k*是它的指数，那么从0到*k*的所有*p*的幂次之和的公式是：
- en: '![Image](../images/pg68_Image_69.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg68_Image_69.jpg)'
- en: 'To find the sum of all the divisors of *n*, all we have to do is apply this
    formula to each prime divisor of *n* and its associated exponent, then multiply
    all the results together. This is essentially the same trick that worked for counting
    the number of divisors: we’re building the divisors one prime factor at a time,
    considering all combinations of prime factors and exponents.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到*n*的所有因子之和，我们需要对每个质因子及其对应的指数应用这个公式，然后将所有结果相乘。这基本上与计算因子个数的方法相同：我们逐个质因子构建因子，考虑质因子和指数的所有组合。
- en: Since we calculated a number’s prime factors and exponents in the program in
    [Figure 3-3](ch03.xhtml#ch3fig3), we can once again add some code to that program
    to sum the number’s divisors. But first, because the formula hinges on calculating
    powers, we need a way to easily do calculations with exponents. Scratch doesn’t
    have a built-in operator for this, so we’ll have to make our own by defining a
    custom block, as shown in [Figure 3-7](ch03.xhtml#ch3fig7).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在[图3-3](ch03.xhtml#ch3fig3)中的程序已经计算了一个数字的质因子和指数，我们可以再次向该程序添加代码来求出该数字的因子之和。但首先，因为公式涉及到计算幂，我们需要一种方法来轻松地进行指数运算。Scratch没有内置的运算符来处理这个问题，所以我们必须通过定义一个自定义模块来实现，如[图3-7](ch03.xhtml#ch3fig7)所示。
- en: '![Image](../images/pg68_Image_70.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg68_Image_70.jpg)'
- en: '*Figure 3-7: A block to calculate positive integer powers*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-7：计算正整数幂的模块*'
- en: This block takes in two values, `base` and `exponent`, and multiplies `base`
    by itself `exponent` number of times, storing the answer in the `result` variable.
    With the help of this block, we can now add the code shown in [Figure 3-8](ch03.xhtml#ch3fig8)
    to the program we created earlier, in [Figure 3-3](ch03.xhtml#ch3fig3).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块接收两个值，`base`和`exponent`，并将`base`与自身相乘`exponent`次，将结果存储在`result`变量中。借助这个模块，我们现在可以将[图3-8](ch03.xhtml#ch3fig8)中显示的代码添加到我们之前创建的程序中，即[图3-3](ch03.xhtml#ch3fig3)。
- en: '![Image](../images/pg69_Image_71.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg69_Image_71.jpg)'
- en: '*Figure 3-8: Using the exponents of* n*’s prime factors to calculate the sum*
    *of* n*’s divisors*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-8：使用*n*的质因子的指数来计算*n*的因子之和*'
- en: We pull each prime *p* and its exponent *k* from the `primes` and `exps` lists
    and use our custom `power` block to calculate *p*^(*k* + 1). Then, we plug the
    results into the formula given earlier, keeping track of the total using the `sum`
    variable. When we reach the end of the two lists, we subtract the original number
    from `sum` before reporting the final answer. This gives us the sum of the number’s
    *proper* divisors, excluding the number itself from the total.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`primes`和`exps`列表中提取每个质数*p*及其指数*k*，并使用我们自定义的`power`模块计算*p*^(*k* + 1)。然后，我们将结果代入前面给出的公式，通过`sum`变量跟踪总和。当我们遍历完两个列表后，在报告最终答案之前，我们会从`sum`中减去原始数字。这样，我们就得到了该数字的*真*因子之和，即排除数字本身的总和。
- en: Notice that both the `primes` and `exps` lists are cleared as the calculation
    proceeds. As with our program counting the number of divisors, it’s easier to
    always grab the first item from each list and then delete that item, making the
    next list element the new element 1, rather than having to keep track of the item
    number within each list.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在计算过程中，`primes` 和 `exps` 列表都会被清空。与我们计算因数数量的程序一样，总是从每个列表中获取第一个项并删除该项，然后使下一个列表元素成为新的第一个元素，而不是一直追踪每个列表中的项编号，这样做更为简单。
- en: Hacking the Code
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: It’s always a good idea to test your code as you write it to make sure it does
    what you want. For example, we can test our custom `power` block from [Figure
    3-7](ch03.xhtml#ch3fig7) by checking the box next to the `result` variable so
    its value appears on the stage. We can then drag the block into the programming
    area, enter values for the arguments, and click the block and see if `result`
    shows the correct value. [Figure 3-9](ch03.xhtml#ch3fig9) tests the block by calculating
    flintmax. As we discussed in [Chapter 1](ch01.xhtml#ch01), this is the largest
    integer that Scratch Cat can get to when counting by ones.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，始终测试代码是一个好主意，以确保它按预期工作。例如，我们可以通过勾选 `result` 变量旁边的框来测试我们自定义的 `power` 块，这样它的值就会出现在舞台上。然后，我们可以将该块拖入编程区域，输入参数值，点击块并查看
    `result` 是否显示正确的值。[图 3-9](ch03.xhtml#ch3fig9)通过计算 flintmax 来测试该块。正如我们在[第1章](ch01.xhtml#ch01)中讨论的那样，这是
    Scratch Cat 在按 1 计数时能得到的最大整数。
- en: '![Image](../images/pg70_Image_72.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg70_Image_72.jpg)'
- en: '*Figure 3-9: Calculating 2^(53) using the* power *block*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-9：使用* 幂 *块计算 2^(53)*'
- en: When I’m programming in Scratch, I debug my code by displaying lots of variables
    on the stage and isolating sections of the code to verify that it behaves as I
    expect. Once the code works, I clean up the stage by hiding the variables that
    don’t need to be seen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 Scratch 中编程时，我通过在舞台上显示大量变量并将代码的各个部分隔离开来调试我的代码，以验证它是否按我预期的方式运行。一旦代码正常工作，我就通过隐藏不需要显示的变量来清理舞台。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**3.1** Remember that 6 is the first perfect number, so called because it’s
    equal to the sum of its proper divisors: 1 + 2 + 3 = 6\. Use the sum of divisors
    code in [Figure 3-8](ch03.xhtml#ch3fig8) to find three other perfect numbers less
    than 10,000.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.1** 记住，6 是第一个完美数，之所以这样称呼是因为它等于其真因数之和：1 + 2 + 3 = 6。使用[图 3-8](ch03.xhtml#ch3fig8)中的因数和代码，找到其他三个小于
    10,000 的完美数。'
- en: '**3.2** A number *n* can fail to be perfect in two ways: either the sum of
    proper divisors of *n* is less than *n*, in which case *n* is called *deficient*,
    or the sum of proper divisors of *n* is greater than *n*, in which case *n* is
    called *abundant*. Write some Scratch code that reports if a given number is deficient,
    perfect, or abundant. How many of each kind of number are there (up to 10, 100,
    1,000)?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.2** 一个数 *n* 可能有两种方式不是完美数：要么 *n* 的所有真因数之和小于 *n*，这种情况下 *n* 被称为 *不足*；要么 *n*
    的所有真因数之和大于 *n*，这种情况下 *n* 被称为 *富余*。编写一些 Scratch 代码来报告给定的数字是不足数、完美数还是富余数。每种类型的数字有多少个（最多到
    10、100、1,000）？'
- en: '**3.3** Raising a nonzero number to the 0 power gives an answer of 1\. Check
    the exponent block in [Figure 3-7](ch03.xhtml#ch3fig7) to see if it works for
    an exponent of 0\. If it doesn’t, rewrite the block so it gives the correct result.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.3** 将一个非零数的 0 次方运算结果为 1。检查[图 3-7](ch03.xhtml#ch3fig7)中的指数块，看看它是否对 0 次方有效。如果无效，请重写该块，使其给出正确的结果。'
- en: '**3.4** Negative exponents are calculated using reciprocals: *n^(–k)* = 1/*n*^(*k*).
    Make the exponent block give correct answers for negative exponents.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.4** 负指数的计算使用倒数：*n^(–k)* = 1/*n*^(*k*)。使指数块在处理负指数时给出正确的答案。'
- en: '**3.5** Change the code for *τ* and *σ* so that instead of deleting list elements
    after you access them you use a new counter variable, say `i`, to access each
    of the list elements in order.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.5** 修改 *τ* 和 *σ* 的代码，这样在访问列表元素后，不再删除它们，而是使用一个新的计数器变量，比如 `i`，按顺序访问每个列表元素。'
- en: How Prime Factorization Helps Find GCDs
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 质因数分解如何帮助找到 GCD
- en: 'In [Chapter 2](ch02.xhtml#ch02), we explored techniques for finding the greatest
    common divisor (GCD) of two integers *b* and *a*. If we know the prime factorization
    of each integer, we have another option. Say we have the following two prime factorizations:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml#ch02)中，我们探讨了计算两个整数 *b* 和 *a* 的最大公约数（GCD）的方法。如果我们知道每个整数的质因数分解，我们还有另一种选择。假设我们有以下两个质因数分解：
- en: '![Image](../images/pg71_Image_73.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_73.jpg)'
- en: 'To find the GCD of *b* and *a*, the first step is to rewrite their prime factorizations
    to include each prime factor of either number, using exponent 0 if necessary:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到*b*和*a*的最大公约数（GCD），第一步是重写它们的质因数分解，确保包括任何一个数字的每个质因数，必要时使用指数0：
- en: '![Image](../images/pg71_Image_74.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_74.jpg)'
- en: 'Here, we’ve added 7⁰ to the prime factorization of *a* and 5⁰ and 11⁰ to the
    prime factorization of *b*. Next, for each prime factor, we compare *a* and *b*
    and take the minimum exponent. For example, the minimum of 3² and 3³ is 3². The
    GCD of *b* and *a* is the product of the prime factorization using just the minimum
    exponents:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将7⁰添加到*a*的质因数分解中，并将5⁰和11⁰添加到*b*的质因数分解中。接下来，对于每个质因数，我们比较*a*和*b*，并取最小指数。例如，3²和3³的最小值是3²。*b*和*a*的GCD是使用最小指数的质因数分解的乘积：
- en: '![Image](../images/pg71_Image_75.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_75.jpg)'
- en: If we’ve already invested the time and effort to factor *b* and *a*, then this
    can be a useful approach. But if we don’t know the factorizations ahead of time,
    it’s more efficient to use Euclid’s algorithm to find the GCD, as we did in [Project
    9](ch02.xhtml#ch02lev14).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经投入时间和精力去分解*b*和*a*的因式，那么这可能是一个有用的方法。但如果我们事先不知道因式分解结果，使用欧几里得算法来求最大公约数（GCD）会更高效，就像我们在[项目9](ch02.xhtml#ch02lev14)中所做的那样。
- en: A related concept to the GCD is the *least common multiple (LCM)*. The LCM of
    *b* and *a* is the smallest number that’s a multiple of both. For example, the
    LCM of 2 and 3 is 6\. The LCM is useful for adding fractions, since the LCM of
    the two denominators is the common denominator you should convert to before doing
    the addition. In this context, the least common multiple is called the *least
    common denominator (LCD)*. This can be a little confusing if you forget that the
    D in LCD stands for denominator while the D in GCD stands for divisor!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与最大公约数（GCD）相关的概念是*最小公倍数（LCM）*。*b*和*a*的LCM是一个既是*b*的倍数又是*a*的倍数的最小数字。例如，2和3的LCM是6。LCM对于加法分数很有用，因为两个分母的LCM是你在进行加法之前应该转换的公分母。在这种情况下，最小公倍数通常被称为*最小公分母（LCD）*。如果你忘记了LCD中的D代表分母，而GCD中的D代表除数，这可能会让人有点困惑！
- en: 'If we have the prime factorizations of *b* and *a*, calculating their LCM is
    quite similar to calculating their GCD. The only difference is that we take the
    *maximum* exponent of each prime factor rather than the minimum. Continuing with
    our example of *b* = 5,292 and *a* = 990, we get:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道*b*和*a*的质因数分解，那么计算它们的LCM与计算GCD非常相似。唯一的区别是，我们取每个质因数的*最大*指数，而不是最小指数。继续以*b*
    = 5,292和*a* = 990为例，我们得到：
- en: '![Image](../images/pg71_Image_76.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_76.jpg)'
- en: 'Since we use minimum exponents to find the GCD and maximum exponents to find
    the LCM, a neat hack is that multiplying the GCD and LCM of two numbers *b* and
    *a* is equivalent to multiplying the two numbers themselves:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用最小指数来求最大公约数（GCD），而使用最大指数来求最小公倍数（LCM），一个巧妙的技巧是，将两个数字*b*和*a*的GCD与LCM相乘，等于将这两个数字相乘：
- en: '![Image](../images/pg71_Image_77.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_77.jpg)'
- en: 'By extension, if we’ve calculated GCD(*b*, *a*), we can calculate LCM(*b*,
    *a*) as:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 推广一下，如果我们已经计算出了GCD(*b*, *a*)，我们可以通过以下公式计算LCM(*b*, *a*)：
- en: '![Image](../images/pg71_Image_78.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_78.jpg)'
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**3.6** Write a custom block that will let you determine whether a given number
    is prime using trial division.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.6** 编写一个自定义模块，使你能够通过试除法确定一个给定的数字是否为素数。'
- en: '**3.7** Use the block from Challenge 3.6 to write another custom block that
    will tell you the next prime number after a given number. If you wanted to program
    a GCD calculator using a factorization approach based on the program from [Project
    10](ch03.xhtml#ch03lev2) ([Figure 3-3](ch03.xhtml#ch3fig3)), you would need to
    make sure the lists of prime factors of the two numbers both had all the same
    primes, so blocks like these would come in handy.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.7** 使用挑战3.6中的模块编写另一个自定义模块，告诉你给定数字之后的下一个素数。如果你想基于[项目10](ch03.xhtml#ch03lev2)中的程序（[图3-3](ch03.xhtml#ch3fig3)）编写一个基于因式分解方法的GCD计算器，你需要确保两个数字的质因数列表都包含相同的素数，因此像这样的模块会很有用。'
- en: '**3.8** A Spirograph is a classic toy that lets you draw intricate curves by
    rotating a toothed gear inside a toothed ring. The following picture shows how
    different gear sizes lead to different shapes. Lots of people have made Spirograph
    simulators using Scratch, and you can probably find other versions that run in
    web pages. Write a program to have Scratch Cat use GCD or LCM blocks to predict
    how many “points” a curve will have when a gear with *b* teeth is rotated inside
    a ring with 96 teeth.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.8** 螺旋画板是一种经典的玩具，通过在带齿环内旋转带齿齿轮，可以画出复杂的曲线。下图展示了不同齿轮大小如何导致不同的形状。很多人已经使用Scratch制作了螺旋画板模拟器，你可能还可以找到其他在网页上运行的版本。写一个程序，让Scratch猫使用最大公约数（GCD）或最小公倍数（LCM）模块，预测当一个带有*b*个齿的齿轮在一个带有96个齿的环内旋转时，曲线会有多少个“点”。'
- en: '![Image](../images/pg72_Image_79.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg72_Image_79.jpg)'
- en: Contacting Aliens with Biprimes
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用双素数联系外星人
- en: 'Biprimes, also sometimes called *semiprimes*, are an intriguing group of numbers.
    As the product of two primes, a biprime by definition has just two prime factors.
    This opens up an interesting possibility: you can use the biprime to combine information
    from each of its prime factors.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 双素数，有时也称为*半素数*，是一类很有趣的数字。作为两个素数的乘积，双素数的定义就是只有两个素因数。这个性质引出了一个有趣的可能性：你可以利用双素数来结合每个素因数的信息。
- en: Here’s a real-life example where biprimes came in handy. In 1974, scientists
    broadcast the Arecibo message out into space from the Arecibo radio telescope
    in Puerto Rico. They wanted the message to include information about human life
    on Earth so that anyone who received it would know we exist and learn something
    about us. But they didn’t want to write the message in English or some other human
    language, since the recipients might not understand it. Instead, the message’s
    authors decided to design it as a series of bits (0s and 1s) meant to be arranged
    in a rectangle, with the 0 bits colored white and the 1 bits colored black, to
    produce a pixelated image. How long should the message be, though, and how would
    the receiver know to arrange the bits into a rectangle of the right size?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个双素数派上用场的实际例子。1974年，科学家们通过位于波多黎各的Arecibo射电望远镜向太空广播了Arecibo消息。他们希望消息能包含有关地球上人类生活的信息，以便任何接收到消息的外星人都知道我们存在并了解我们的一些情况。但他们不想用英语或其他人类语言编写消息，因为接收者可能无法理解。相反，消息的作者决定将其设计为一系列位（0和1），这些位应该排成一个矩形，0位用白色表示，1位用黑色表示，从而形成一个像素化的图像。但是，消息的长度应该是多少呢，接收者又如何知道如何将这些位排列成正确尺寸的矩形呢？
- en: Imagine you’re designing such a message. The message has *n* bits. If the rectangle
    has dimensions *a* ⋅ *b*, you’ll need to have *a* and *b* be factors of *n*, such
    that *a* ⋅ *b* = *n*. If *n* were prime, there would be only one factorization,
    1 ⋅ *n* (or *n* ⋅ 1), so the bits would be arranged in a single long row or column—pretty
    useless. But if *n* had lots of factors, there would be lots of possible dimensions
    for the rectangle—not very helpful either.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在设计这样的消息。该消息有*n*位。如果矩形的尺寸是*a* ⋅ *b*，你需要确保*a*和*b*是*n*的因数，使得*a* ⋅ *b* = *n*。如果*n*是素数，只有一个因式分解，1
    ⋅ *n*（或*n* ⋅ 1），那么这些位就只能排成一行或一列——这几乎没什么用。但如果*n*有很多因数，那么矩形的尺寸就有很多种可能性——这也不是很有帮助。
- en: 'The solution is to make *n* a biprime. This way, it has only two significant
    factors (excluding 1 and *n* itself), the two primes that multiply together to
    make *n*, so the dimensions of the rectangle are clear. That’s exactly what the
    Arecibo team did, sending a message of 1,679 bits. Since 1,679 = 73 ⋅ 23, there
    are only two possible ways to organize the bits: 23 rows and 73 columns, or 73
    rows and 23 columns. For the bit string they sent, the first possibility decodes
    as a random arrangement of dots, but the second gives the image shown in [Figure
    3-10](ch03.xhtml#ch3fig10).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是让*n*成为双素数。这样，它只有两个重要的因数（不包括1和*n*本身），即两个素数，这两个素数相乘得到*n*，因此矩形的维度就很清晰。这正是Arecibo团队所做的，他们发送了1,679位的信息。由于1,679
    = 73 ⋅ 23，所以只有两种可能的方式来组织这些位：23行和73列，或者73行和23列。对于他们发送的位串，第一个可能性解码出来是一个随机排列的点，而第二个则给出了[图3-10](ch03.xhtml#ch3fig10)所示的图像。
- en: '![Image](../images/pg73_Image_80.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg73_Image_80.jpg)'
- en: '*Figure 3-10: The Arecibo message*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-10：Arecibo消息*'
- en: The message squeezes in information about counting in binary, the chemistry
    underlying life, the solar system, the size of a typical human, and the telescope
    that sent the message—pretty impressive for just 1,679 1s and 0s. Unfortunately,
    the Arecibo telescope collapsed in 2020, but even though the telescope is gone,
    the message is on its way to the globular cluster Messier 13 and should arrive
    in about 25,000 years.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该消息包含了关于二进制计数、生命的化学基础、太阳系、典型人类的大小以及发射该消息的望远镜的信息——这些信息在仅仅1679个1和0中压缩得相当紧凑。不幸的是，Arecibo望远镜在2020年倒塌，但即使望远镜已经消失，消息仍在前往球状星团梅西耶13的途中，预计将在大约25,000年后抵达。
- en: To extract the information from the Arecibo message, all we need to do is factor
    its length, *n*. We already have a way to do that by trial division, as in [Project
    10](ch03.xhtml#ch03lev2), but this approach can be slow for large numbers—especially
    large biprimes—since we’ll have to go through trial division with all the small
    numbers first. As we’ll see in the next project, knowing that we’re trying to
    factor a biprime gives us a shortcut. We might expect a biprime’s two prime factors
    to be close to the same size, hovering around the square root of *n*. We can start
    looking from there instead of from 2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Arecibo消息中提取信息，我们需要做的就是因式分解其长度*n*。我们已经有了一种通过试除法来做到这一点的方法，如在[项目10](ch03.xhtml#ch03lev2)中所示，但这种方法对于大数——尤其是大合数——可能会比较慢，因为我们必须先通过所有小数进行试除。正如我们将在下一个项目中看到的，知道我们正在尝试因式分解一个合数，可以给我们提供一个捷径。我们可能会期望合数的两个质因数接近相同的大小，围绕*n*的平方根。因此，我们可以从那里开始查找，而不是从2开始。
- en: 'Project 13: Fermat’s Factorization Feat'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目13：费马因式分解法
- en: The mathematician Pierre de Fermat realized that there’s a more efficient way
    to factor numbers with two factors close to the same size, such as the biprimes
    we’re interested in here. The technique is based on the formula for the difference
    of squares. Suppose we have the number *n* written as a difference of squares,
    *n* = *a*² – *b*². We can rewrite this as *n* = (*a* – *b*)(*a* + *b*). Viewing
    the formula this way tells us that (*a* – *b*) and (*a* + *b*) must be factors
    of *n*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家皮埃尔·德·费马意识到，存在一种更高效的方法来因式分解接近相同大小的两个因数的数字，比如我们这里关注的合数。这个技巧基于平方差公式。假设我们有一个数字*n*，可以写成平方差的形式，即*n*
    = *a*² – *b*²。我们可以将其改写为*n* = (*a* – *b*) (*a* + *b*)。以这种方式查看公式可以告诉我们，(*a* – *b*)和(*a*
    + *b*)一定是*n*的因数。
- en: The trick is to find *a* and *b* from *n*. For that, we’ll rewrite the equation
    as *a*² – *n* = *b*², try various choices for *a*, and look for a choice that
    makes the difference *a*² – *n* a perfect square, which we can use to find *b*.
    First, we need to recognize perfect squares, which we do in the custom block in
    [Figure 3-11](ch03.xhtml#ch3fig11).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是从*n*中找到*a*和*b*。为此，我们将方程重写为*a*² – *n* = *b*²，尝试不同的*a*值，并寻找一种使差值*a*² – *n*成为完全平方数的选择，从而找到*b*。首先，我们需要识别完全平方数，这可以通过[图3-11](ch03.xhtml#ch3fig11)中的自定义块来实现。
- en: '![Image](../images/pg74_Image_81.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg74_Image_81.jpg)'
- en: '*Figure 3-11: Do we have a perfect square?*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-11：我们有完全平方数吗？*'
- en: This is a Boolean block, returning a logical value of `true` or `false` depending
    on whether the number passed in is a perfect square. We calculate the square root
    of `number`, use the built-in `floor` function to round the result down to the
    nearest integer ❶, and compare the two. If `number` is a perfect square, its square
    root is already an integer, so the comparison is equal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔块，根据传入的数字是否是完全平方数返回一个逻辑值`true`或`false`。我们计算`number`的平方根，使用内置的`floor`函数将结果向下取整到最接近的整数❶，然后进行比较。如果`number`是完全平方数，那么它的平方根已经是一个整数，所以比较结果相等。
- en: Once we can recognize perfect squares, we can start searching for them to identify
    *a* and *b* and, by extension, the factors of *n*. The program in [Figure 3-12](ch03.xhtml#ch3fig12)
    shows how.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够识别完全平方数，就可以开始搜索它们以识别*a*和*b*，从而找到*n*的因数。[图3-12](ch03.xhtml#ch3fig12)中的程序演示了这一过程。
- en: '![Image](../images/pg75_Image_82.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg75_Image_82.jpg)'
- en: '*Figure 3-12: Fermat factorization*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-12：费马因式分解*'
- en: We start by picking a value of *a* just a little smaller than ![Images](../images/pg50_Image_41.jpg)
    ❶. Then, in a loop, we increase *a* by `1` ➌ and check if *a*² – *n* is a perfect
    square. (Decreasing *a* by `1` just before the loop ➋ lets us catch the case where
    *n* happens to be a perfect square itself.) Once we’ve found a value of *b* that
    works, we calculate and display the factors `factor1` (*a* + *b*) and `factor2`
    (*a* – *b*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择一个比![Images](../images/pg50_Image_41.jpg) ❶稍小的 *a* 值。然后，在一个循环中，我们将 *a*
    增加 `1` ➌ 并检查 *a*² – *n* 是否是一个完全平方数。（在循环前将 *a* 减少 `1` ➋ 让我们可以捕捉到 *n* 恰好是一个完全平方数的情况。）一旦我们找到一个有效的
    *b* 值，就计算并显示因数 `factor1` (*a* + *b*) 和 `factor2` (*a* – *b*)。
- en: The Results
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 3-13](ch03.xhtml#ch3fig13) shows the results of a sample run of the
    program.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-13](ch03.xhtml#ch3fig13)显示了程序运行的样本结果。'
- en: '![Image](../images/pg75_Image_83.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg75_Image_83.jpg)'
- en: '*Figure 3-13: Factoring 4,398,091,599,977*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-13：因数分解 4,398,091,599,977*'
- en: Notice that rather than having Scratch Cat say the results, we simply display
    the relevant variables on the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有让 Scratch Cat 说出结果，而是直接将相关变量显示在屏幕上。
- en: Hacking the Code
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: It would be interesting to compare the timing of the Fermat factorization approach
    to the trial division approach from [Project 10](ch03.xhtml#ch03lev2). You might
    notice in [Figure 3-13](ch03.xhtml#ch3fig13) that there’s an extra variable showing
    on the screen, called `time`, for that purpose. We embedded a program in a timer
    loop before, in [Project 9](ch02.xhtml#ch02lev14), when we were checking how long
    it took to test for a prime using trial division (see [Figure 2-19](ch02.xhtml#ch2fig19)
    on [page 39](ch02.xhtml#page_39)). This time, we’ll create two simple custom blocks
    to turn Scratch’s internal timer on and off, as shown in [Figure 3-14](ch03.xhtml#ch3fig14).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将费马分解方法的时间与[项目 10](ch03.xhtml#ch03lev2)中的试除法方法进行比较会很有趣。你可能会在[图 3-13](ch03.xhtml#ch3fig13)中注意到，屏幕上显示了一个额外的变量，叫做`time`，它的目的是用于这个对比。我们之前在[项目
    9](ch02.xhtml#ch02lev14)中嵌入了一个程序，放在一个定时器循环中，用来检查使用试除法测试质数所需的时间（请参见[图 2-19](ch02.xhtml#ch2fig19)，位于[第39页](ch02.xhtml#page_39)）。这一次，我们将创建两个简单的自定义模块，用来打开和关闭
    Scratch 的内部定时器，如[图 3-14](ch03.xhtml#ch3fig14)所示。
- en: '![Image](../images/pg76_Image_84.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg76_Image_84.jpg)'
- en: '*Figure 3-14: Timer blocks*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-14：定时器模块*'
- en: To time the Fermat factorization program, add the `timer start` block right
    before the third `set` block ➊ in [Figure 3-12](ch03.xhtml#ch3fig12), and add
    the `timer stop` block to the end of the program. As we discussed in [Chapter
    2](ch02.xhtml#ch02), Scratch’s default time unit is seconds, so the time might
    be reported as `0` for small numbers because the actual time interval is too short
    to display after rounding. Running the program repeatedly and dividing the total
    time by the number of runs should give a more accurate result. This hack also
    helps cancel out the effect that other processes running on your computer have
    on the speed of the Scratch program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计时费马分解程序，将 `timer start` 块添加到[图 3-12](ch03.xhtml#ch3fig12)中第三个 `set` 块之前 ➊，并将
    `timer stop` 块添加到程序的末尾。正如我们在[第 2 章](ch02.xhtml#ch02)中讨论的那样，Scratch 的默认时间单位是秒，因此对于小数字来说，时间可能会报告为
    `0`，因为实际的时间间隔太短，经过四舍五入后无法显示。重复运行程序并将总时间除以运行次数应该能给出更准确的结果。这个技巧还帮助消除了计算机上其他进程对 Scratch
    程序运行速度的影响。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**3.9** Add a test to the Fermat factorization code in [Figure 3-12](ch03.xhtml#ch3fig12)
    that checks whether the factors it produces are prime numbers. This will tell
    you if the input number is truly a biprime.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.9** 在[图 3-12](ch03.xhtml#ch3fig12)中的费马分解代码中添加一个测试，检查它产生的因数是否为质数。这将告诉你输入的数字是否真的是一个双质数。'
- en: '**3.10** Combine the Fermat factorization code in [Figure 3-12](ch03.xhtml#ch3fig12)
    with the trial division code from [Figure 2-6](ch02.xhtml#ch2fig6) on [page 28](ch02.xhtml#page_28)
    so you can compare how long each method takes to find a factorization.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.10** 将[图 3-12](ch03.xhtml#ch3fig12)中的费马分解代码与[图 2-6](ch02.xhtml#ch2fig6)中的试除法代码结合在一起，位于[第28页](ch02.xhtml#page_28)，这样你就可以比较每种方法找到因数的时间。'
- en: '**3.11** Scratch’s stage is 480 pixels by 360 pixels. Write a program that
    takes a string of *n = a* ⋅ *b* bits (where *a* is at most 480 and *b* is at most
    360) and displays it on the screen in a rectangle of *a* by *b* pixels, coloring
    in the 1 bits black and the 0 bits white. Try to use the program to recreate the
    Arecibo message.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.11** Scratch的舞台大小为480像素乘360像素。编写一个程序，接收一个由*n = a* ⋅ *b* 位（其中*a*最多为480，*b*最多为360）组成的字符串，并在屏幕上以*a*乘*b*像素的矩形显示它，将1位显示为黑色，0位显示为白色。尝试使用该程序重现Arecibo信息。'
- en: Conclusion
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'We asked different questions in this chapter and in [Chapter 2](ch02.xhtml#ch02)
    (“How does a number factor?” and “Is a number prime?”), but we used the same initial
    approach to answer them in both cases: trial division. As we’ve seen, this approach
    is limited by the time we have available for performing the work. In the worst
    case, it takes as many steps as the square root of the number being tested to
    find an answer. For numbers up to flintmax, that isn’t too long, but for numbers
    with hundreds of digits, there isn’t enough time in the universe for trial division
    to work. Other approaches, such as Fermat factorization, can help us find the
    result we’re looking for more quickly, especially when we have a clue about the
    shape of the number, such as whether it’s a biprime. If you can think of a way
    to speed up the arithmetic, Scratch Cat will give you an answer more quickly!'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们提出了不同的问题，并在[第二章](ch02.xhtml#ch02)中提出了类似的问题（“一个数字如何分解因子？”和“一个数字是否为质数？”），但我们在两种情况下都使用了相同的初步方法来解答它们：试除法。正如我们所见，这种方法的局限性在于执行工作的时间。在最坏的情况下，找到答案所需的步骤与被测试数字的平方根成正比。对于不超过flintmax的数字，这样的时间并不算长，但对于拥有数百位数字的数字来说，宇宙中的时间也不够试除法来奏效。其他方法，如费马分解法，可以帮助我们更快地找到所需的结果，尤其是当我们对数字的形态有所了解时，例如它是否为双质数。如果你能想到加速计算的方法，Scratch
    Cat将会更快给出答案！
