<html><head></head><body>
<h2 class="h2a" id="ch03"><span epub:type="pagebreak" id="page_37"/><strong><span class="big">3</span></strong><br/><strong>NETWORK PROTOCOL STRUCTURES</strong></h2>&#13;
<p class="noindent_first">The old adage “There is nothing new under the sun” holds true when it comes to the way protocols are structured. Binary and text protocols follow common patterns and structures and, once understood, can easily be applied to any new protocol. This chapter details some of these structures and formalizes the way I’ll represent them throughout the rest of this book.</p>&#13;
<p class="indent">In this chapter, I discuss many of the common types of protocol structures. Each is described in detail along with how it is represented in binary- or text-based protocols. By the end of the chapter, you should be able to easily identify these common types in any unknown protocol you analyze.</p>&#13;
<p class="indent">Once you understand how protocols are structured, you’ll also see patterns of exploitable behavior—ways of attacking the network protocol itself. <a href="../Text/ch10.xhtml#ch10">Chapter 10</a> will provide more detail on finding network protocol issues, but for now we’ll just concern ourselves with structure.</p>&#13;
<h3 class="h3" id="ch00lev1sec49"><span epub:type="pagebreak" id="page_38"/><strong>Binary Protocol Structures</strong></h3>&#13;
<p class="noindent">Binary protocols work at the binary level; the smallest unit of data is a single binary digit. Dealing with single bits is difficult, so we’ll use 8-bit units called <em>octets</em>, commonly called <em>bytes</em>. The octet is the de facto unit of network protocols. Although octets can be broken down into individual bits (for example, to represent a set of flags), we’ll treat all network data in 8-bit units, as shown in <a href="../Text/ch03.xhtml#ch3fig1">Figure 3-1</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig1"/><em>Figure 3-1: Binary data description formats</em></p>&#13;
<p class="indent">When showing individual bits, I’ll use the <em>bit format</em>, which shows bit 7, the <em>most significant bit (MSB)</em>, on the left. Bit 0, or the <em>least significant bit (LSB)</em>, is on the right. (Some architectures, such as PowerPC, define the bit numbering in the opposite direction.)</p>&#13;
<h4 class="h4" id="ch00lev1sec50"><strong><em>Numeric Data</em></strong></h4>&#13;
<p class="noindent">Data values representing numbers are usually at the core of a binary protocol. These values can be integers or decimal values. Numbers can be used to represent the length of data, to identify tag values, or simply to represent a number.</p>&#13;
<p class="indent">In binary, numeric values can be represented in a few different ways, and a protocol’s method of choice depends on the value it’s representing. The following sections describe some of the more common formats.</p>&#13;
<h5 class="h5" id="ch00lev1sec51"><strong>Unsigned Integers</strong></h5>&#13;
<p class="noindent">Unsigned integers are the most obvious representation of a binary number. Each bit has a specific value based on its position, and these values are added together to represent the integer. <a href="../Text/ch03.xhtml#ch3tab1">Table 3-1</a> shows the decimal and hexadecimal values for an 8-bit integer.</p>&#13;
<p class="tabcap"><a id="ch3tab1"/><strong>Table 3-1:</strong> Decimal Bit Values</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Bit</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Decimal value</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Hex value</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x01</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x02</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">4</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x04</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">3</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">8</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x08</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">4</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">16</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x10</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">5</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">32</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x20</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">6</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">64</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x40</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">7</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">128</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0x80</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch00lev1sec52"><span epub:type="pagebreak" id="page_39"/><strong>Signed Integers</strong></h5>&#13;
<p class="noindent">Not all integer values are positive. In some scenarios, negative integers are required—for example, to represent the difference between two integers, you need to take into account that the difference could be negative—and only signed integers can hold negative values. While encoding an unsigned integer seems obvious, the CPU can only work with the same set of bits. Therefore, the CPU requires a way of interpreting the unsigned integer value as signed; the most common signed interpretation is two’s complement. The term <em>two’s complement</em> refers to the way in which the signed integer is represented within a native integer value in the CPU.</p>&#13;
<p class="indent">Conversion between unsigned and signed values in two’s complement is done by taking the bitwise NOT (where a 0 bit is converted to a 1 and 1 is converted to a 0) of the integer and adding 1. For example, <a href="../Text/ch03.xhtml#ch3fig2">Figure 3-2</a> shows the 8-bit integer 123 converted to its two’s complement representation.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig2"/><em>Figure 3-2: The two’s complement representation of 123</em></p>&#13;
<p class="indent">The two’s complement representation has one dangerous security consequence. For example, an 8-bit signed integer has the range –128 to 127, so the magnitude of the minimum is larger than the maximum. If the minimum value is negated, the result is itself; in other words, –(–128) is –128. This can cause calculations to be incorrect in parsed formats, leading to security vulnerabilities. We’ll go into more detail in <a href="../Text/ch10.xhtml#ch10">Chapter 10</a>.</p>&#13;
<h5 class="h5" id="ch00lev1sec53"><strong>Variable-Length Integers</strong></h5>&#13;
<p class="noindent">Efficient transfer of network data has historically been very important. Even though today’s high-speed networks might make efficiency concerns unnecessary, there are still advantages to reducing a protocol’s bandwidth. It can be beneficial to use variable-length integers when the most common integer values being represented are within a very limited range.</p>&#13;
<p class="indent">For example, consider length fields: when sending blocks of data between 0 and 127 bytes in size, you could use a 7-bit variable integer representation. <a href="../Text/ch03.xhtml#ch3fig3">Figure 3-3</a> shows a few different encodings for 32-bit words. At most, five octets are required to represent the entire range. But if your protocol tends to assign values between 0 and 127, it will only use one octet, which saves a considerable amount of space.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_40"/><img alt="image" src="../Images/f03-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig3"/><em>Figure 3-3: Example 7-bit integer encoding</em></p>&#13;
<p class="indent">That said, if you parse more than five octets (or even 32 bits), the resulting integer from the parsing operation will depend on the parsing program. Some programs (including those developed in C) will simply drop any bits beyond a given range, whereas other development environments will generate an overflow error. If not handled correctly, this integer overflow might lead to vulnerabilities, such as buffer overflows, which could cause a smaller than expected memory buffer to be allocated, in turn resulting in memory corruption.</p>&#13;
<h5 class="h5" id="ch00lev1sec54"><strong>Floating-Point Data</strong></h5>&#13;
<p class="noindent">Sometimes, integers aren’t enough to represent the range of decimal values needed for a protocol. For example, a protocol for a multiplayer computer game might require sending the coordinates of players or objects in the game’s virtual world. If this world is large, it would be easy to run up against the limited range of a 32- or even 64-bit fixed-point value.</p>&#13;
<p class="indent">The format of floating-point integers used most often is the <em>IEEE format</em> specified in IEEE Standard for Floating-Point Arithmetic (IEEE 754). Although the standard specifies a number of different binary and even decimal formats for floating-point values, you’re likely to encounter only two: a single-precision binary representation, which is a 32-bit value; and a double-precision, 64-bit value. Each format specifies the position and bit size of the significand and exponent. A sign bit is also specified, indicating whether the value is positive or negative. <a href="../Text/ch03.xhtml#ch3fig4">Figure 3-4</a> shows the general layout of an IEEE floating-point value, and <a href="../Text/ch03.xhtml#ch3tab2">Table 3-2</a> lists the common exponent and significand sizes.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_41"/><img alt="image" src="../Images/f03-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig4"/><em>Figure 3-4: Floating-point representation</em></p>&#13;
<p class="tabcap"><a id="ch3tab2"/><strong>Table 3-2:</strong> Common Float Point Sizes and Ranges</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Bit size</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Exponent bits</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Significand bits</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Value range</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">32</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">8</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">23</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">+/– 3.402823 × 10<sup>38</sup></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">64</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">11</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">52</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">+/– 1.79769313486232 × 10<sup>308</sup></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch00lev1sec55"><strong><em>Booleans</em></strong></h4>&#13;
<p class="noindent">Because Booleans are very important to computers, it’s no surprise to see them reflected in a protocol. Each protocol determines how to represent whether a Boolean value is true or false, but there are some common conventions.</p>&#13;
<p class="indent">The basic way to represent a Boolean is with a single-bit value. A 0 bit means false and a 1 means true. This is certainly space efficient but not necessarily the simplest way to interface with an underlying application. It’s more common to use a single byte for a Boolean value because it’s far easier to manipulate. It’s also common to use zero to represent false and non-zero to represent true.</p>&#13;
<h4 class="h4" id="ch00lev1sec56"><strong><em>Bit Flags</em></strong></h4>&#13;
<p class="noindent">Bit flags are one way to represent specific Boolean states in a protocol. For example, in TCP a set of bit flags is used to determine the current state of a connection. When making a connection, the client sends a packet with the synchronize flag (SYN) set to indicate that the connections should synchronize their timers. The server can then respond with an acknowledgment (ACK) flag to indicate it has received the client request as well as the SYN flag to establish the synchronization with the client. If this handshake used single enumerated values, this dual state would be impossible without a distinct SYN/ACK state.</p>&#13;
<h4 class="h4" id="ch00lev1sec57"><strong><em>Binary Endian</em></strong></h4>&#13;
<p class="noindent">The endianness of data is a very important part of interpreting binary protocols correctly. It comes into play whenever a multi-octet value, such as a 32-bit word, is transferred. The endian is an artifact of how computers store data in memory.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_42"/>Because octets are transmitted sequentially on the network, it’s possible to send the most significant octet of a value as the first part of the transmission, as well as the reverse—send the least significant octet first. The order in which octets are sent determines the endianness of the data. Failure to correctly handle the endian format can lead to subtle bugs in the parsing of protocols.</p>&#13;
<p class="indent">Modern platforms use two main endian formats: big and little. <em>Big endian</em> stores the most significant byte at the lowest address, whereas <em>little endian</em> stores the least significant byte in that location. <a href="../Text/ch03.xhtml#ch3fig5">Figure 3-5</a> shows how the 32-bit integer 0x01020304 is stored in both forms.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig5"/><em>Figure 3-5: Big and little endian word representation</em></p>&#13;
<p class="indent">The endianness of a value is commonly referred to as either <em>network order</em> or <em>host order</em>. Because the Internet RFCs invariably use big endian as the preferred type for all network protocols they specify (unless there are legacy reasons for doing otherwise), big endian is referred as network order. But your computer could be either big or little endian. Processor architectures such as x86 use little endian; others such as SPARC use big endian.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some processor architectures, including SPARC, ARM, and MIPS, may have onboard logic that specifies the endianness at runtime, usually by toggling a processor control flag. When developing network software, make no assumptions about the endianness of the platform you might be running on. The networking API used to build an application will typically contain convenience functions for converting to and from these orders. Other platforms, such as PDP-11, use a <em>middle endian</em> format where 16-bit words are swapped; however, you’re unlikely to ever encounter one in everyday life, so don’t dwell on it.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec58"><strong><em>Text and Human-Readable Data</em></strong></h4>&#13;
<p class="noindent">Along with numeric data, strings are the value type you’ll most commonly encounter, whether they’re being used for passing authentication credentials or resource paths. When inspecting a protocol designed to send only <span epub:type="pagebreak" id="page_43"/>English characters, the text will probably be encoded using ASCII. The original ASCII standard defined a 7-bit character set from 0 to 0x7F, which includes most of the characters needed to represent the English language (shown in <a href="../Text/ch03.xhtml#ch3fig6">Figure 3-6</a>).</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig6"/><em>Figure 3-6: A 7-bit ASCII table</em></p>&#13;
<p class="indent">The ASCII standard was originally developed for text terminals (physical devices with a moving printing head). Control characters were used to send messages to the terminal to move the printing head or to synchronize serial communications between the computer and the terminal. The ASCII character set contains two types of characters: <em>control</em> and <em>printable</em>. Most of the control characters are relics of those devices and are virtually unused. But some still provide information on modern computers, such as CR and LF, which are used to end lines of text.</p>&#13;
<p class="indent">The printable characters are the ones you can see. This set of characters consists of many familiar symbols and alphanumeric characters; however, they won’t be of much use if you want to represent international characters, of which there are thousands. It’s unachievable to represent even a fraction of the possible characters in all the world’s languages in a 7-bit number.</p>&#13;
<p class="indent">Three strategies are commonly employed to counter this limitation: code pages, multibyte character sets, and Unicode. A protocol will either require that you use one of these three ways to represent text, or it will offer an option that an application can select.</p>&#13;
<h5 class="h5" id="ch00lev1sec59"><span epub:type="pagebreak" id="page_44"/><strong>Code Pages</strong></h5>&#13;
<p class="noindent">The simplest way to extend the ASCII character set is by recognizing that if all your data is stored in octets, 128 unused values (from 128 to 255) can be repurposed for storing extra characters. Although 256 values are not enough to store all the characters in every available language, you have many different ways to use the unused range. Which characters are mapped to which values is typically codified in specifications called <em>code pages</em> or <em>character encodings</em>.</p>&#13;
<h5 class="h5" id="ch00lev1sec60"><strong>Multibyte Character Sets</strong></h5>&#13;
<p class="noindent">In languages such as Chinese, Japanese, and Korean (collectively referred to as CJK), you simply can’t come close to representing the entire written language with 256 characters, even if you use all available space. The solution is to use multibyte character sets combined with ASCII to encode these languages. Common encodings are Shift-JIS for Japanese and GB2312 for simplified Chinese.</p>&#13;
<p class="indent"><em>Multibyte character sets</em> allow you to use two or more octets in sequence to encode a desired character, although you’ll rarely see them in use. In fact, if you’re not working with CJK, you probably won’t see them at all. (For the sake of brevity, I won’t discuss multibyte character sets any further; plenty of online resources will aid you in decoding them if required.)</p>&#13;
<h5 class="h5" id="ch00lev1sec61"><strong>Unicode</strong></h5>&#13;
<p class="noindent">The Unicode standard, first standardized in 1991, aims to represent all languages within a unified character set. You might think of Unicode as another multibyte character set. But rather than focusing on a specific language, such as Shift-JIS does with Japanese, it tries to encode all written languages, including some archaic and constructed ones, into a single universal character set.</p>&#13;
<p class="indent">Unicode defines two related concepts: <em>character mapping</em> and <em>character encoding</em>. Character mappings include mappings between a numeric value and a character, as well as many other rules and regulations on how characters are used or combined. Character encodings define the way these numeric values are encoded in the underlying file or network protocol. For analysis purposes, it’s far more important to know how these numeric values are encoded.</p>&#13;
<p class="indent">Each character in Unicode is assigned a <em>code point</em> that represents a unique character. Code points are commonly written in the format <em>U+ABCD</em>, where <em>ABCD</em> is the code point’s hexadecimal value. For the sake of compatibility, the first 128 code points match what is specified in ASCII, and the second 128 code points are taken from ISO/IEC 8859-1. The resulting value is encoded using a specific scheme, sometimes referred to as <em>Universal Character Set (UCS)</em> or <em>Unicode Transformation Format (UTF)</em> encodings. (Subtle differences exist between UCS and UTF formats, <span epub:type="pagebreak" id="page_45"/>but for the sake of identification and manipulation, these differences are unimportant.) <a href="../Text/ch03.xhtml#ch3fig7">Figure 3-7</a> shows a simple example of some different Unicode formats.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig7"/><em>Figure 3-7: The string <span class="literal"><span class="codeitalic">"Hello"</span></span> in different Unicode encodings</em></p>&#13;
<p class="indent">Three common Unicode encodings in use are UTF-16, UTF-32, and UTF-8.</p>&#13;
<p class="noindentt"><strong>UCS-2/UTF-16</strong></p>&#13;
<p class="hang2">UCS-2/UTF-16 is the native format on modern Microsoft Windows platforms, as well as the Java and .NET virtual machines when they are running code. It encodes code points in sequences of 16-bit integers and has little and big endian variants.</p>&#13;
<p class="noindentt"><strong>UCS-4/UTF-32</strong></p>&#13;
<p class="hang2">UCS-4/UTF-32 is a common format used in Unix applications because it’s the default wide-character format in many C/C++ compilers. It encodes code points in sequences of 32-bit integers and has different endian variants.</p>&#13;
<p class="noindentt"><strong>UTF-8</strong></p>&#13;
<p class="hang2">UTF-8 is probably the most common format on Unix. It is also the default input and output format for varying platforms and technologies, such as XML. Rather than having a fixed integer size for code points, it encodes them using a simple variable length value. <a href="../Text/ch03.xhtml#ch3tab3">Table 3-3</a> shows how code points are encoded in UTF-8.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_46"/><a id="ch3tab3"/><strong>Table 3-3:</strong> Encoding Rules for Unicode Code Points in UTF-8</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Bits of code point</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>First code point (U+)</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Last code point (U+)</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Byte 1</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Byte 2</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Byte 3</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Byte 4</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">0–7</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0000</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">007F</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0xxxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"> </p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"> </p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"> </p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">8–11</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0080</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">07FF</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">110xxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"> </p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"> </p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">12–16</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">0800</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">FFFF</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">1110xxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"> </p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">17–21</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10000</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">1FFFFF</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">11110xxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">22–26</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">200000</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">3FFFFFF</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">111110xx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">26–31</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">4000000</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">7FFFFFFF</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">1111110x</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">10xxxxxx</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">UTF-8 has many advantages. For one, its encoding definition ensures that the ASCII character set, code points U+0000 through U+007F, are encoded using single bytes. This scheme makes this format not only ASCII compatible but also space efficient. In addition, UTF-8 is compatible with C/C++ programs that rely on NUL-terminated strings.</p>&#13;
<p class="indent">For all of its benefits, UTF-8 does come at a cost, because languages like Chinese and Japanese consume more space than they do in UTF-16. <a href="../Text/ch03.xhtml#ch3fig8">Figure 3-8</a> shows such a disadvantageous encoding of Chinese characters. But notice that the UTF-8 in this example is still more space efficient than the UTF-32 for the same characters.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig8"/><em>Figure 3-8: The string</em> "<span class="ent">兔子</span>" <em>in different Unicode encodings</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Incorrect or naive character encoding can be a source of subtle security issues, ranging from bypassing filtering mechanisms (say in a requested resource path) to causing buffer overflows. We’ll investigate some of the vulnerabilities associated with character encoding in <a href="../Text/ch10.xhtml#ch10">Chapter 10</a>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec62"><span epub:type="pagebreak" id="page_47"/><strong><em>Variable Binary Length Data</em></strong></h4>&#13;
<p class="noindent">If the protocol developer knows in advance exactly what data must be transmitted, they can ensure that all values within the protocol are of a fixed length. In reality this is quite rare, although even simple authentication credentials would benefit from the ability to specify variable username and password string lengths. Protocols use several strategies to produce variable-length data values: I discuss the most common—terminated data, length-prefixed data, implicit-length data, and padded data—in the following sections.</p>&#13;
<h5 class="h5" id="ch00lev1sec63"><strong>Terminated Data</strong></h5>&#13;
<p class="noindent">You saw an example of variable-length data when variable-length integers were discussed earlier in this chapter. The variable-length integer value was terminated when the octet’s MSB was 0. We can extend the concept of terminating values further to elements like strings or data arrays.</p>&#13;
<p class="indent">A terminated data value has a terminal symbol defined that tells the data parser that the end of the data value has been reached. The terminal symbol is used because it’s unlikely to be present in typical data, ensuring that the value isn’t terminated prematurely. With string data, the terminating value can be a NUL value (represented by 0) or one of the other control characters in the ASCII set.</p>&#13;
<p class="indent">If the terminal symbol chosen occurs during normal data transfer, you need to use a mechanism to escape these symbols. With strings, it’s common to see the terminating character either prefixed with a backslash (<span class="literal">\</span>) or repeated twice to prevent it from being identified as the terminal symbol. This approach is especially useful when a protocol doesn’t know ahead of time how long a value is—for example, if it’s generated dynamically. <a href="../Text/ch03.xhtml#ch3fig9">Figure 3-9</a> shows an example of a string terminated by a NUL value.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-09.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig9"/><em>Figure 3-9: <span class="literal"><span class="codeitalic">"Hello"</span></span> as a NUL-terminated string</em></p>&#13;
<p class="indent">Bounded data is often terminated by a symbol that matches the first character in the variable-length sequence. For example, when using string data, you might find a <em>quoted string</em> sandwiched between quotation marks. The initial double quote tells the parser to look for the matching character to end the data. <a href="../Text/ch03.xhtml#ch3fig10">Figure 3-10</a> shows a string bounded by a pair of double quotes.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_48"/><img alt="image" src="../Images/f03-10.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig10"/><em>Figure 3-10: <span class="literal"><span class="codeitalic">"Hello"</span></span> as a double-quoted bounded string</em></p>&#13;
<h5 class="h5" id="ch00lev1sec64"><strong>Length-Prefixed Data</strong></h5>&#13;
<p class="noindent">If a data value is known in advance, it’s possible to insert its length into the protocol directly. The protocol’s parser can read this value and then read the appropriate number of units (say characters or octets) to extract the original value. This is a very common way to specify variable-length data.</p>&#13;
<p class="indent">The actual size of the <em>length prefix</em> is usually not that important, although it should be reasonably representative of the types of data being transmitted. Most protocols won’t need to specify the full range of a 32-bit integer; however, you’ll often see that size used as a length field, if only because it fits well with most processor architectures and platforms. For example, <a href="../Text/ch03.xhtml#ch3fig11">Figure 3-11</a> shows a string with an 8-bit length prefix.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-11.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig11"/><em>Figure 3-11: <span class="literal"><span class="codeitalic">"Hello"</span></span> as a length-prefixed string</em></p>&#13;
<h5 class="h5" id="ch00lev1sec65"><strong>Implicit-Length Data</strong></h5>&#13;
<p class="noindent">Sometimes the length of the data value is implicit in the values around it. For example, think of a protocol that is sending data back to a client using a connection-oriented protocol such as TCP. Rather than specifying the size of the data up front, the server could close the TCP connection, thus implicitly signifying the end of the data. This is how data is returned in an HTTP version 1.0 response.</p>&#13;
<p class="indent">Another example would be a higher-level protocol or structure that has already specified the length of a set of values. The parser might extract that higher-level structure first and then read the values contained within it. The protocol could use the fact that this structure has a finite length associated with it to implicitly calculate the length of a value in a similar <span epub:type="pagebreak" id="page_49"/>fashion to close the connection (without closing it, of course). For example, <a href="../Text/ch03.xhtml#ch3fig12">Figure 3-12</a> shows a trivial example where a 7-bit variable integer and string are contained within a single block. (Of course, in practice, this can be considerably more complex.)</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-12.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig12"/><em>Figure 3-12: <span class="literal"><span class="codeitalic">"Hello"</span></span> as an implicit-length string</em></p>&#13;
<h5 class="h5" id="ch00lev1sec66"><strong>Padded Data</strong></h5>&#13;
<p class="noindent">Padded data is used when there is a maximum upper bound on the length of a value, such as a 32-octet limit. For the sake of simplicity, rather than prefixing the value with a length or having an explicit terminating value, the protocol could instead send the entire fixed-length string but terminate the value by padding the unused data with a known value. <a href="../Text/ch03.xhtml#ch3fig13">Figure 3-13</a> shows an example.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-13.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig13"/><em>Figure 3-13: <span class="literal"><span class="codeitalic">"Hello"</span></span> as a <span class="literal"><span class="codeitalic">'$'</span></span> padded string</em></p>&#13;
<h3 class="h3" id="ch00lev1sec67"><strong>Dates and Times</strong></h3>&#13;
<p class="noindent">It can be very important for a protocol to get the correct date and time. Both can be used as metadata, such as file modification timestamps in a network file protocol, as well as to determine the expiration of authentication credentials. Failure to correctly implement the timestamp might cause serious security issues. The method of date and time representation depends on usage requirements, the platform the applications are running on, and the protocol’s space requirements. I discuss two common representations, POSIX/Unix Time and Windows FILETIME, in the following sections.</p>&#13;
<h4 class="h4" id="ch00lev1sec68"><span epub:type="pagebreak" id="page_50"/><strong><em>POSIX/Unix Time</em></strong></h4>&#13;
<p class="noindent">Currently, POSIX/Unix time is stored as a 32-bit signed integer value representing the number of seconds that have elapsed since the Unix epoch, which is usually specified as 00:00:00 (UTC), 1 January 1970. Although this isn’t a high-definition timer, it’s sufficient for most scenarios. As a 32-bit integer, this value is limited to 03:14:07 (UTC) 19 January 2038, at which point the representation will overflow. Some modern operating systems now use a 64-bit representation to address this problem.</p>&#13;
<h4 class="h4" id="ch00lev1sec69"><strong><em>Windows FILETIME</em></strong></h4>&#13;
<p class="noindent">The Windows FILETIME is the date and time format used by Microsoft Windows for its filesystem timestamps. As the only format on Windows with simple binary representation, it also appears in a few different protocols.</p>&#13;
<p class="indent">The FILETIME format is a 64-bit unsigned integer. One unit of the integer represents a 100 ns interval. The epoch of the format is 00:00:00 (UTC), 1 January 1601. This gives the FILETIME format a larger range than the POSIX/Unix time format.</p>&#13;
<h3 class="h3" id="ch00lev1sec70"><strong>Tag, Length, Value Pattern</strong></h3>&#13;
<p class="noindent">It’s easy to imagine how one might send unimportant data using simple protocols, but sending more complex and important data takes some explaining. For example, a protocol that can send different types of structures must have a way to represent the bounds of a structure and its type.</p>&#13;
<p class="indent">One way to represent data is with a <em>Tag, Length, Value (TLV) pattern</em>. The Tag value represents the type of data being sent by the protocol, which is commonly a numeric value (usually an enumerated list of possible values). But the Tag can be anything that provides the data structures with a unique pattern. The Length and Value are variable-length values. The order in which the values appear isn’t important; in fact, the Tag might be part of the Value. <a href="../Text/ch03.xhtml#ch3fig14">Figure 3-14</a> show a couple of ways these values could be arranged.</p>&#13;
<p class="indent">The Tag value sent can be used to determine how to further process the data. For example, given two types of Tags, one that indicates the authentication credentials to the application and another that represents a message being transmitted to the parser, we must be able to distinguish between the two types of data. One big advantage to this pattern is that it allows us to extend a protocol without breaking applications that have not been updated to support the updated protocol. Because each structure is sent with an associated Tag and Length, a protocol parser could ignore the structures that it doesn’t understand.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_51"/><img alt="image" src="../Images/f03-14.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig14"/><em>Figure 3-14: Possible TLV arrangements</em></p>&#13;
<h3 class="h3" id="ch00lev1sec71"><strong>Multiplexing and Fragmentation</strong></h3>&#13;
<p class="noindent">Often in computer communication, multiple tasks must happen at once. For example, consider the Microsoft <em>Remote Desktop Protocol (RDP)</em>: a user could be moving the mouse cursor, typing on the keyboard, and transferring files to a remote computer while changes in the display and audio are being transmitted back to the user (see <a href="../Text/ch03.xhtml#ch3fig15">Figure 3-15</a>).</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-15.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig15"/><em>Figure 3-15: Data needs for Remote Desktop Protocol</em></p>&#13;
<p class="indent">This complex data transfer would not result in a very rich experience if display updates had to wait for a 10-minute audio file to finish before updating the display. Of course, a workaround would be opening multiple connections to the remote computer, but those would use more resources. Instead, many protocols use <em>multiplexing</em>, which allows multiple connections to share the same underlying network connection.</p>&#13;
<p class="indent">Multiplexing (shown in <a href="../Text/ch03.xhtml#ch3fig16">Figure 3-16</a>) defines an internal <em>channel</em> mechanism that allows a single connection to host multiple types of traffic by fragmenting large transmissions into smaller chunks. Multiplexing then combines these chunks into a single connection. When analyzing a protocol, you may need to demultiplex these channels to get the original data back out.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_52"/><img alt="image" src="../Images/f03-16.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig16"/><em>Figure 3-16: Multiplexed RDP data</em></p>&#13;
<p class="indent">Unfortunately, some network protocols restrict the type of data that can be transmitted and how large each packet of data can be—a problem commonly encountered when layering protocols. For example, Ethernet defines the maximum size of traffic frames as 1500 octets, and running IP on top of that causes problems because the maximum size of IP packets can be 65536 bytes. <em>Fragmentation</em> is designed to solve this problem: it uses a mechanism that allows the network stack to convert large packets into smaller fragments when the application or OS knows that the entire packet cannot be handled by the next layer.</p>&#13;
<h3 class="h3" id="ch00lev1sec72"><strong>Network Address Information</strong></h3>&#13;
<p class="noindent">The representation of network address information in a protocol usually follows a fairly standard format. Because we’re almost certainly dealing with TCP or UDP protocols, the most common binary representation is the IP address as either a 4- or 16-octet value (for IPv4 or IPv6) along with a 2-octet port. By convention, these values are typically stored as big endian integer values.</p>&#13;
<p class="indent">You might also see hostnames sent instead of raw addresses. Because hostnames are just strings, they follow the patterns used for sending variable-length strings, which was discussed earlier in “<a href="../Text/ch03.xhtml#ch00lev1sec62">Variable Binary Length Data</a>” on <a href="../Text/ch03.xhtml#page_47">page 47</a>. <a href="../Text/ch03.xhtml#ch3fig17">Figure 3-17</a> shows how some of these formats might appear.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_53"/><img alt="image" src="../Images/f03-17.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig17"/><em>Figure 3-17: Network information in binary</em></p>&#13;
<h3 class="h3" id="ch00lev1sec73"><strong>Structured Binary Formats</strong></h3>&#13;
<p class="noindent">Although custom network protocols have a habit of reinventing the wheel, sometimes it makes more sense to repurpose existing designs when describing a new protocol. For example, one common format encountered in binary protocols is <em>Abstract Syntax Notation 1 (ASN.1)</em>. ASN.1 is the basis for protocols such as the Simple Network Management Protocol (SNMP), and it is the encoding mechanism for all manner of cryptographic values, such as X.509 certificates.</p>&#13;
<p class="indent">ASN.1 is standardized by the ISO, IEC, and ITU in the X.680 series. It defines an abstract syntax to represent structured data. Data is represented in the protocol depending on the encoding rules, and numerous encodings exist. But you’re most likely to encounter the <em>Distinguished Encoding Rules (DER)</em>, which is designed to represent ASN.1 structures in a way that cannot be misinterpreted—a useful property for cryptographic protocols. The DER representation is a good example of a TLV protocol.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>Rather than going into great detail about ASN.1 (which would take up a fair amount of this book), I give you <a href="../Text/ch03.xhtml#ch3list1">Listing 3-1</a>, which shows the ASN.1 for X.509 certificates.</p>&#13;
<p class="programs">Certificate  ::=  SEQUENCE  {<br/>     version         [0]  EXPLICIT Version DEFAULT v1,<br/>     serialNumber         CertificateSerialNumber,<br/>     signature            AlgorithmIdentifier,<br/>     issuer               Name,<br/>     validity             Validity,<br/>     subject              Name,<br/>     subjectPublicKeyInfo SubjectPublicKeyInfo,<br/>     issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,<br/>     subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,<br/>     extensions      [3]  EXPLICIT Extensions OPTIONAL<br/>}</p>&#13;
<p class="listing"><a id="ch3list1"/><em>Listing 3-1: ASN.1 representation for X.509 certificates</em></p>&#13;
<p class="indent">This abstract definition of an X.509 certificate can be represented in any of ASN.1’s encoding formats. <a href="../Text/ch03.xhtml#ch3list2">Listing 3-2</a> shows a snippet of the DER encoded form dumped as text using the OpenSSL utility.</p>&#13;
<p class="programs">$ <span class="codestrong">openssl asn1parse -in example.cer</span><br/>    0:d=0  hl=4 l= 539 cons: SEQUENCE<br/>    4:d=1  hl=4 l= 388 cons: SEQUENCE<br/>    8:d=2  hl=2 l=   3 cons: cont [ 0 ]<br/>   10:d=3  hl=2 l=   1 prim: INTEGER         :02<br/>   13:d=2  hl=2 l=  16 prim: INTEGER         :19BB8E9E2F7D60BE48BFE6840B50F7C3<br/>   31:d=2  hl=2 l=  13 cons: SEQUENCE<br/>   33:d=3  hl=2 l=   9 prim: OBJECT          :sha1WithRSAEncryption<br/>   44:d=3  hl=2 l=   0 prim: NULL<br/>   46:d=2  hl=2 l=  17 cons: SEQUENCE<br/>   48:d=3  hl=2 l=  15 cons: SET<br/>   50:d=4  hl=2 l=  13 cons: SEQUENCE<br/>   52:d=5  hl=2 l=   3 prim: OBJECT          :commonName<br/>   57:d=5  hl=2 l=   6 prim: PRINTABLESTRING :democa</p>&#13;
<p class="listing"><a id="ch3list2"/><em>Listing 3-2: A small sample of X.509 certificate</em></p>&#13;
<h3 class="h3" id="ch00lev1sec74"><strong>Text Protocol Structures</strong></h3>&#13;
<p class="noindent">Text protocols are a good choice when the main purpose is to transfer text, which is why mail transfer protocols, instant messaging, and news aggregation protocols are usually text based. Text protocols must have structures similar to binary protocols. The reason is that, although their main content differs, both share the goal of transferring data from one place to another.</p>&#13;
<p class="indent">The following section details some common text protocol structures that you’ll likely encounter in the real world.</p>&#13;
<h4 class="h4" id="ch00lev1sec75"><span epub:type="pagebreak" id="page_55"/><strong><em>Numeric Data</em></strong></h4>&#13;
<p class="noindent">Over the millennia, science and written languages have invented ways to represent numeric values in textual format. Of course, computer protocols don’t need to be human readable, but why go out of your way just to prevent a protocol from being readable (unless your goal is deliberate obfuscation).</p>&#13;
<h5 class="h5" id="ch00lev1sec76"><strong>Integers</strong></h5>&#13;
<p class="noindent">It’s easy to represent integer values using the current character set’s representation of the characters 0 through 9 (or A through F if hexadecimal). In this simple representation, size limitations are no concern, and if a number needs to be larger than a binary word size, you can add digits. Of course, you’d better hope that the protocol parser can handle the extra digits or security issues will inevitably occur.</p>&#13;
<p class="indent">To make a signed number, you add the minus (<span class="literal">–</span>) character to the front of the number; the plus (<span class="literal">+</span>) symbol for positive numbers is implied.</p>&#13;
<h5 class="h5" id="ch00lev1sec77"><strong>Decimal Numbers</strong></h5>&#13;
<p class="noindent">Decimal numbers are usually defined using human-readable forms. For example, you might write a number as 1.234, using the dot character to separate the integer and fractional components of the number; however, you’ll still need to consider the requirement of parsing a value afterward.</p>&#13;
<p class="indent">Binary representations, such as floating point, can’t represent all decimal values precisely with finite precision (just as decimals can’t represent numbers like 1/3). This fact can make some values difficult to represent in text format and can cause security issues, especially when values are compared to one another.</p>&#13;
<h4 class="h4" id="ch00lev1sec78"><strong><em>Text Booleans</em></strong></h4>&#13;
<p class="noindent">Booleans are easy to represent in text protocols. Usually, they’re represented using the words <em>true</em> or <em>false</em>. But just to be difficult, some protocols might require that words be capitalized exactly to be valid. And sometimes integer values will be used instead of words, such as 0 for false and 1 for true, but not very often.</p>&#13;
<h4 class="h4" id="ch00lev1sec79"><strong><em>Dates and Times</em></strong></h4>&#13;
<p class="noindent">At a simple level, it’s easy to encode dates and times: just represent them as they would be written in a human-readable language. As long as all applications agree on the representation, that should suffice.</p>&#13;
<p class="indent">Unfortunately, not everyone can agree on a standard format, so typically many competing date representations are in use. This can be a particularly acute issue in applications such as mail clients, which need to process all manner of international date formats.</p>&#13;
<h4 class="h4" id="ch00lev1sec80"><span epub:type="pagebreak" id="page_56"/><strong><em>Variable-Length Data</em></strong></h4>&#13;
<p class="noindent">All but the most trivial protocols must have a way to separate important text fields so they can be easily interpreted. When a text field is separated out of the original protocol, it’s commonly referred to as a <em>token</em>. Some protocols specify a fixed length for tokens, but it’s far more common to require some type of variable-length data.</p>&#13;
<h5 class="h5" id="ch00lev1sec81"><strong>Delimited Text</strong></h5>&#13;
<p class="noindent">Separating tokens with delimiting characters is a very common way to separate tokens and fields that’s simple to understand and easy to construct and parse. Any character can be used as the delimiter (depending on the type of data being transferred), but whitespace is encountered most in human-readable formats. That said, the delimiter doesn’t have to be whitespace. For example, the Financial Information Exchange (FIX) protocol delimits tokens using the ASCII Start of Header (SOH) character with a value of 1.</p>&#13;
<h5 class="h5" id="ch00lev1sec82"><strong>Terminated Text</strong></h5>&#13;
<p class="noindent">Protocols that specify a way to separate individual tokens must also have a way to define an End of Command condition. If a protocol is broken into separate lines, the lines must be terminated in some way. Most well-known, text-based Internet protocols are <em>line oriented</em>, such as HTTP and IRC; lines typically delimit entire structures, such as the end of a command.</p>&#13;
<p class="indent">What constitutes the end-of-line character? That depends on whom you ask. OS developers usually define the end-of-line character as either the ASCII <em>Line Feed (LF)</em>, which has the value 10; the <em>Carriage Return (CR)</em> with the value 13; or the combination CR LF. Protocols such as HTTP and Simple Mail Transfer Protocol (SMTP) specify CR LF as the official end-of-line combination. However, so many incorrect implementations occur that most parsers will also accept a bare LF as the end-of-line indication.</p>&#13;
<h4 class="h4" id="ch00lev1sec83"><strong><em>Structured Text Formats</em></strong></h4>&#13;
<p class="noindent">As with structured binary formats such ASN.1, there is normally no reason to reinvent the wheel when you want to represent structured data in a text protocol. You might think of structured text formats as delimited text on steroids, and as such, rules must be in place for how values are represented and hierarchies constructed. With this in mind, I’ll describe three formats in common use within real-world text protocols.</p>&#13;
<h5 class="h5" id="ch00lev1sec84"><strong>Multipurpose Internet Mail Extensions</strong></h5>&#13;
<p class="noindent">Originally developed for sending multipart email messages, <em>Multipurpose Internet Mail Extensions (MIME)</em> found its way into a number of protocols, such as HTTP. The specification in RFCs 2045, 2046 and 2047, along with numerous other related RFCs, defines a way of encoding multiple discrete attachments in a single MIME-encoded message.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>MIME messages separate the body parts by defining a common separator line prefixed with two dashes (--). The message is terminated by following this separator with the same two dashes. <a href="../Text/ch03.xhtml#ch3list3">Listing 3-3</a> shows an example of a text message combined with a binary version of the same message.</p>&#13;
<p class="programs">MIME-Version: 1.0<br/>Content-Type: multipart/mixed; boundary=MSG_2934894829<br/><br/>This is a message with multiple parts in MIME format.<br/>--MSG_2934894829<br/>Content-Type: text/plain<br/><br/>Hello World!<br/>--MSG_2934894829<br/>Content-Type: application/octet-stream<br/>Content-Transfer-Encoding: base64<br/><br/>PGh0bWw+Cjxib2R5PgpIZWxsbyBXb3JsZCEKPC9ib2R5Pgo8L2h0bWw+Cg==<br/>--MSG_2934894829--</p>&#13;
<p class="listing"><a id="ch3list3"/><em>Listing 3-3: A simple MIME message</em></p>&#13;
<p class="indent">One of the most common uses of MIME is for Content-Type values, which are usually referred to as <em>MIME types.</em> A MIME type is widely used when serving HTTP content and in operating systems to map an application to a particular content type. Each type consists of the form of the data it represents, such as <em>text</em> or <em>application</em>, in the format of the data. In this case, <span class="literal">plain</span> is unencoded text and <span class="literal">octet-stream</span> is a series of bytes.</p>&#13;
<h5 class="h5" id="ch00lev1sec85"><strong>JavaScript Object Notation</strong></h5>&#13;
<p class="noindent"><em>JavaScript Object Notation (JSON)</em> was designed as a simple representation for a structure based on the object format provided by the JavaScript programming language. It was originally used to transfer data between a web page in a browser and a backend service, such as in Asynchronous JavaScript and XML (AJAX). Currently, it’s commonly used for web service data transfer and all manner of other protocols.</p>&#13;
<p class="indent">The JSON format is simple: a JSON object is enclosed using the braces ({}) ASCII characters. Within these braces are zero or more member entries, each consisting of a key and a value. For example, <a href="../Text/ch03.xhtml#ch3list4">Listing 3-4</a> shows a simple JSON object consisting of an integer index value, "Hello world!" as a string, and an array of strings.</p>&#13;
<p class="programs">{<br/>    "index" : 0,<br/>    "str" : "Hello World!",<br/>    "arr" : [ "A", "B" ]<br/>}</p>&#13;
<p class="listing"><a id="ch3list4"/><em>Listing 3-4: A simple JSON object</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>The JSON format was designed for JavaScript processing, and it can be parsed using the <span class="literal">"eval"</span> function. Unfortunately, using this function comes with a significant security risk; namely, it’s possible to insert arbitrary script code during object creation. Although most modern applications use a parsing library that doesn’t need a connection to JavaScript, it’s worth ensuring that arbitrary JavaScript code is not executed in the context of the application. The reason is that it could lead to potential security issues, such as <em>cross-site scripting (XSS)</em>, a vulnerability where attacker-controlled JavaScript can be executed in the context of another web page, allowing the attacker to access the page’s secure resources.</p>&#13;
<h5 class="h5" id="ch00lev1sec86"><strong>Extensible Markup Language</strong></h5>&#13;
<p class="noindent"><em>Extensible Markup Language (XML)</em> is a markup language for describing a structured document format. Developed by the W3C, it’s derived from Standard Generalized Markup Language (SGML). It has many similarities to HTML, but it aims to be stricter in its definition in order to simplify parsers and create fewer security issues.<sup><a id="ch03nt_01"/><a href="../Text/footnote.xhtml#ch03nt01">1</a></sup></p>&#13;
<p class="indent">At a basic level, XML consists of elements, attributes, and text. <em>Elements</em> are the main structural values. They have a name and can contain child elements or text content. Only one root element is allowed in a single document. <em>Attributes</em> are additional name-value pairs that can be assigned to an element. They take the form of <span class="literal"><span class="codeitalic">name</span>=<span class="codeitalic">"Value"</span></span>. Text content is just that, text. Text is a child of an element or the value component of an attribute.</p>&#13;
<p class="indent"><a href="../Text/ch03.xhtml#ch3list5">Listing 3-5</a> shows a very simple XML document with elements, attributes, and text values.</p>&#13;
<p class="programs">&lt;value index="0"&gt;    &lt;str&gt;Hello World!&lt;/str&gt;<br/>    &lt;arr&gt;&lt;value&gt;A&lt;/value&gt;&lt;value&gt;B&lt;/value&gt;&lt;/arr&gt;<br/>&lt;/value&gt;</p>&#13;
<p class="listing"><a id="ch3list5"/><em>Listing 3-5: A simple XML document</em></p>&#13;
<p class="indent">All XML data is text; no type information is provided for in the XML specification, so the parser must know what the values represent. Certain specifications, such as XML Schema, aim to remedy this type information deficiency but they are not required in order to process XML content. The XML specification defines a list of well-formed criteria that can be used to determine whether an XML document meets a minimal level of structure.</p>&#13;
<p class="indent">XML is used in many different places to define the way information is transmitted in a protocol, such as in Rich Site Summary (RSS). It can also be part of a protocol, as in Extensible Messaging and Presence Protocol (XMPP).</p>&#13;
<h3 class="h3" id="ch00lev1sec87"><span epub:type="pagebreak" id="page_59"/><strong>Encoding Binary Data</strong></h3>&#13;
<p class="noindent">In the early history of computer communication, 8-bit bytes were not the norm. Because most communication was text based and focused on English-speaking countries, it made economic sense to send only 7 bits per byte as required by the ASCII standard. This allowed other bits to provide control for serial link protocols or to improve performance. This history is reflected heavily in some early network protocols, such as the SMTP or Network News Transfer Protocol (NNTP), which assume 7-bit communication channels.</p>&#13;
<p class="indent">But a 7-bit limitation presents a problem if you want to send that amusing picture to your friend via email or you want to write your mail in a non-English character set. To overcome this limitation, developers devised a number of ways to encode binary data as text, each with varying degrees of efficiency or complexity.</p>&#13;
<p class="indent">As it turns out, the ability to convert binary content into text still has its advantages. For example, if you wanted to send binary data in a structured text format, such as JSON or XML, you might need to ensure that delimiters were appropriately escaped. Instead, you can choose an existing encoding format, such as Base64, to send the binary data and it will be easily understood on both sides.</p>&#13;
<p class="indent">Let’s look at some of the more common binary-to-text encoding schemes you’re likely to encounter when inspecting a text protocol.</p>&#13;
<h4 class="h4" id="ch00lev1sec88"><strong><em>Hex Encoding</em></strong></h4>&#13;
<p class="noindent">One of the most naive encoding techniques for binary data is <em>hex encoding</em>. In hex encoding, each octet is split into two 4-bit values that are converted to two text characters denoting the hexadecimal representation. The result is a simple representation of the binary in text form, as shown in <a href="../Text/ch03.xhtml#ch3fig18">Figure 3-18</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-18.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig18"/><em>Figure 3-18: Example hex encoding of binary data</em></p>&#13;
<p class="indent">Although simple, hex encoding is not space efficient because all binary data automatically becomes 100 percent larger than it was originally. But one advantage is that encoding and decoding operations are fast and simple and little can go wrong, which is definitely beneficial from a security perspective.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>HTTP specifies a similar encoding for URLs and some text protocols called <em>percent encoding</em>. Rather than all data being encoded, only nonprintable data is converted to hex, and values are signified by prefixing the value with a % character. If percent encoding was used to encode the value in <a href="../Text/ch03.xhtml#ch3fig18">Figure 3-18</a>, you would get %06%E3%58.</p>&#13;
<h4 class="h4" id="ch00lev1sec89"><strong><em>Base64</em></strong></h4>&#13;
<p class="noindent">To counter the obvious inefficiencies in hex encoding, we can use Base64, an encoding scheme originally developed as part of the MIME specifications. The <em>64</em> in the name refers to the number of characters used to encode the data.</p>&#13;
<p class="indent">The input binary is separated into individual 6-bit values, enough to represent 0 through 63. This value is then used to look up a corresponding character in an encoding table, as shown in <a href="../Text/ch03.xhtml#ch3fig19">Figure 3-19</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f03-19.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig19"/><em>Figure 3-19: Base64 encoding table</em></p>&#13;
<p class="indent">But there’s a problem with this approach: when 8 bits are divided by 6, 2 bits remain. To counter this problem, the input is taken in units of three octets, because dividing 24 bits by 6 bits produces 4 values. Thus, Base64 encodes 3 bytes into 4, representing an increase of only 33 percent, which is significantly better than the increase produced by hex encoding. <a href="../Text/ch03.xhtml#ch3fig20">Figure 3-20</a> shows an example of encoding a three-octet sequence into Base64.</p>&#13;
<p class="indent">But yet another issue is apparent with this strategy. What if you have only one or two octets to encode? Would that not cause the encoding to fail? Base64 gets around this issue by defining a placeholder character, the equal sign (=). If in the encoding process, no valid bits are available to use, the encoder will encode that value as the placeholder. <a href="../Text/ch03.xhtml#ch3fig21">Figure 3-21</a> shows an example of only one octet being encoded. Note that it generates two placeholder characters. If two octets were encoded, Base64 would generate only one.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_61"/><img alt="image" src="../Images/f03-20.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig20"/><em>Figure 3-20: Base64 encoding 3 bytes as 4 characters</em></p>&#13;
<div class="image"><img alt="image" src="../Images/f03-21.jpg"/></div>&#13;
<p class="figcap"><a id="ch3fig21"/><em>Figure 3-21: Base64 encoding 1 byte as 3 characters</em></p>&#13;
<p class="indent">To convert Base64 data back into binary, you simply follow the steps in reverse. But what happens when a non-Base64 character is encountered during the decoding? Well that’s up to the application to decide. We can only hope that it makes a secure decision.</p>&#13;
<h3 class="h3" id="ch00lev1sec90"><span epub:type="pagebreak" id="page_62"/><strong>Final Words</strong></h3>&#13;
<p class="noindent">In this chapter, I defined many ways to represent data values in binary and text protocols and discussed how to represent numeric data, such as integers, in binary. Understanding how octets are transmitted in a protocol is crucial to successfully decoding values. At the same time, it’s also important to identify the many ways that variable-length data values can be represented because they are perhaps the most important structure you will encounter within a network protocol. As you analyze more network protocols, you’ll see the same structures used repeatedly. Being able to quickly identify the structures is key to easily processing unknown protocols.</p>&#13;
<p class="indent">In <a href="../Text/ch04.xhtml#ch04">Chapter 4</a>, we’ll look at a few real-world protocols and dissect them to see how they match up with the descriptions presented in this chapter.</p>&#13;
</body></html>