- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**FROM CODE TO MEMORY: A GENERAL PRIMER**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**从代码到内存：一个通用入门**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: At the lowest level, a game’s code, data, input, and output are complex abstractions
    of erratically changing bytes. Many of these bytes represent variables or machine
    code generated by a compiler that was fed the game’s source code. Some represent
    images, models, and sounds. Others exist only for an instant, posted by the computer’s
    hardware as input and destroyed when the game finishes processing them. The bytes
    that remain inform the player of the game’s internal state. But humans can’t think
    in bytes, so the computer must translate them in a way we can understand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，游戏的代码、数据、输入和输出是不断变化的字节的复杂抽象。许多字节代表由编译器生成的变量或机器代码，该编译器是根据游戏的源代码生成的。有些代表图像、模型和声音。其他的则只存在一瞬间，由计算机硬件作为输入发布，并在游戏完成处理后销毁。剩余的字节则通知玩家游戏的内部状态。但人类无法用字节思考，因此计算机必须以我们能理解的方式将其翻译出来。
- en: There’s a huge disconnect in the opposite direction as well. A computer doesn’t
    actually understand high-level code and visceral game content, so these must be
    translated from the abstract into bytes. Some content—such as images, sounds,
    and text—is stored losslessly, ready to be presented to the player at a microsecond’s
    notice. A game’s code, logic, and variables, on the other hand, are stripped of
    all human readability and compiled down to machine data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，也存在一个巨大的断层。计算机实际上并不理解高级代码和直观的游戏内容，因此这些必须从抽象转换为字节。有些内容——如图像、声音和文本——是无损存储的，准备好在微秒级别向玩家呈现。另一方面，游戏的代码、逻辑和变量则被剥去所有人类可读性，并被编译成机器数据。
- en: By manipulating a game’s data, game hackers obtain humanly improbable advantages
    within the game. To do this, however, they must understand how a developer’s code
    manifests once it has been compiled and executed. Essentially, they must think
    like computers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操控游戏数据，游戏黑客能够在游戏中获得人类难以实现的优势。然而，要做到这一点，他们必须理解开发者的代码在被编译和执行后如何表现。实质上，他们必须像计算机一样思考。
- en: To get you thinking like a computer, this chapter will begin by teaching you
    how numbers, text, simple structures, and unions are represented in memory at
    the byte level. Then you’ll dive deeper to explore how class instances are stored
    in memory and how abstract instances know which virtual functions to call at runtime.
    In the last half of the chapter, you’ll take an x86 assembly language crash course
    that covers syntax, registers, operands, the call stack, arithmetic operations,
    branching operations, function calls, and calling conventions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你像计算机一样思考，本章将从教你数字、文本、简单结构和联合体在字节级别上的内存表示开始。然后，你将深入探索类实例是如何在内存中存储的，以及抽象实例如何在运行时知道该调用哪些虚拟函数。在本章的后半部分，你将参加一门x86汇编语言速成课程，内容包括语法、寄存器、操作数、调用栈、算术运算、分支操作、函数调用和调用约定。
- en: This chapter focuses very heavily on general technical details. There isn’t
    a lot of juicy information that immediately relates to hacking games, but the
    knowledge you gain here will be central in the coming chapters, when we talk about
    topics like programmatically reading and writing memory, injecting code, and manipulating
    control flow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章非常注重一般技术细节。虽然没有很多直接与游戏黑客相关的“精彩”信息，但你在这里获得的知识将在接下来的章节中发挥核心作用，当我们讨论如何通过程序读取和写入内存、注入代码以及操控控制流等主题时。
- en: Since C++ is the de facto standard for both game and bot development, this chapter
    explains the relationships between C++ code and the memory that represents it.
    Most native languages have very similar (sometimes identical) low-level structure
    and behavior, however, so you should be able to apply what you learn here to just
    about any piece of software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++是游戏和机器人开发的事实标准，本章将解释C++代码与代表它的内存之间的关系。大多数本地语言都有非常相似（有时是相同的）低级结构和行为，因此你应该能够将所学的知识应用到几乎任何软件中。
- en: All of the example code in this chapter is in the *GameHackingExamples/Chapter4_CodeToMemory*
    directory of this book’s source files. The included projects can be compiled with
    Visual Studio 2010 but should also work with any other C++ compiler. Download
    them at *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    and compile them if you want to follow along.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例代码都在本书源文件的 *GameHackingExamples/Chapter4_CodeToMemory* 目录中。包含的项目可以用
    Visual Studio 2010 编译，但也应该适用于任何其他 C++ 编译器。如果你想跟着做，可以从 *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    下载并编译它们。
- en: '**How Variables and Other Data Manifest in Memory**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变量和其他数据在内存中的表现**'
- en: Properly manipulating a game’s state can be very hard, and finding the data
    that controls it is not always as easy as clicking Next Scan and hoping Cheat
    Engine won’t fail you. In fact, many hacks must manipulate dozens of related values
    at once. Finding these values and their relationships often requires you to analytically
    identify structures and patterns. Moreover, developing game hacks typically means
    re-creating the original structures within your bot’s code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正确操作游戏的状态可能非常困难，找到控制它的数据并不像点击“下一次扫描”并希望 Cheat Engine 不会失败那样简单。实际上，许多黑客必须同时操作几十个相关的值。找到这些值及其关系通常需要你分析地识别结构和模式。此外，开发游戏黑客通常意味着在你的机器人的代码中重新创建原始结构。
- en: To do these things, you need an in-depth understanding of exactly how variables
    and data are laid out in the game’s memory. Through example code, OllyDbg memory
    dumps, and some tables to tie everything together, this section will teach you
    everything there is to know about how different types of data manifest in memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这些任务，你需要深入了解变量和数据在游戏内存中的布局。通过示例代码、OllyDbg 内存转储和一些表格来将一切联系在一起，本节将教你如何了解不同类型的数据如何在内存中表现。
- en: '***Numeric Data***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数值数据***'
- en: 'Most of the values game hackers need (like the player’s health, mana, location,
    and level) are represented by numeric data types. Because numeric data types are
    also a building block for all other data types, understanding them is extremely
    important. Luckily, they have relatively straightforward representations in memory:
    they are predictably aligned and have a fixed bit width. [Table 4-1](ch04.xhtml#ch4tab1)
    shows the five main numeric data types you’ll find in Windows games, along with
    their sizes and ranges.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏黑客需要的值（比如玩家的血量、魔法值、位置和等级）都由数值数据类型表示。由于数值数据类型也是所有其他数据类型的构建块，理解它们是极其重要的。幸运的是，它们在内存中有相对直接的表示方式：它们是按预测方式对齐的，并且有固定的位宽。[表
    4-1](ch04.xhtml#ch4tab1) 展示了你在 Windows 游戏中会遇到的五种主要数值数据类型，以及它们的大小和范围。
- en: '**Table 4-1:** Numeric Data Types'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 数值数据类型'
- en: '| **Type name(s)** | **Size** | **Signed range** | **Unsigned range** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **类型名称** | **大小** | **有符号范围** | **无符号范围** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `char`, `BYTE` | 8 bits | -128 to 127 | 0 to 255 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `char`, `BYTE` | 8 位 | -128 到 127 | 0 到 255 |'
- en: '| `short`, `WORD`, `wchar_t` | 16 bits | -32,768 to -32,767 | 0 to 65535 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `short`, `WORD`, `wchar_t` | 16 位 | -32,768 到 -32,767 | 0 到 65535 |'
- en: '| `int`, `long`, `DWORD` | 32 bits | -2,147,483,648 to 2,147,483,647 | 0 to
    4,294,967,295 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `int`, `long`, `DWORD` | 32 位 | -2,147,483,648 到 2,147,483,647 | 0 到 4,294,967,295
    |'
- en: '| `long long` | 64 bits | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    | 0 to 18,446,744,073,709,551,615 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 64 位 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
    | 0 到 18,446,744,073,709,551,615 |'
- en: '| `float` | 32 bits | +/-1.17549*10^(-38) to +/-3.40282*10^(38) | N/A |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 32 位 | +/-1.17549*10^(-38) 到 +/-3.40282*10^(38) | 不适用 |'
- en: The sizes of numeric data types can differ between architectures and even compilers.
    Since this book focuses on hacking x86 games on Windows, I’m using type names
    and sizes made standard by Microsoft. With the exception of `float`, the data
    types in [Table 4-1](ch04.xhtml#ch4tab1) are stored with *little-endian ordering*,
    meaning the least significant bytes of an integer are stored in the lowest addresses
    occupied by that integer. For example, [Figure 4-1](ch04.xhtml#ch4fig1) shows
    that `DWORD` 0x0A0B0C0D is represented by the bytes 0x0D 0x0C 0x0B 0x0A.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数值数据类型的大小在不同的架构甚至编译器之间可能会有所不同。由于本书聚焦于在 Windows 上破解 x86 游戏，因此我使用了 Microsoft 标准的类型名称和大小。除了
    `float` 外，[表 4-1](ch04.xhtml#ch4tab1) 中的数据类型采用 *小端序* 存储，这意味着整数的最低有效字节存储在该整数占用的最低地址中。例如，[图
    4-1](ch04.xhtml#ch4fig1) 显示 `DWORD` 0x0A0B0C0D 被字节 0x0D 0x0C 0x0B 0x0A 表示。
- en: '![image](../images/f04-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-01.jpg)'
- en: '*Figure 4-1: Little-endian ordering diagram*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：小端序排列示意图*'
- en: 'The `float` data type can hold mixed numbers, so its representation in memory
    isn’t as simple as that of other data types. For example, if you see 0x0D 0x0C
    0x0B 0x0A in memory and that value is a `float`, you can’t simply convert it to
    0x0A0B0C0D. Instead, `float` values have three components: the *sign* (bit 0),
    *exponent* (bits 1–8), and *mantissa* (bits 9–31).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`数据类型可以存储混合数字，因此它在内存中的表示不像其他数据类型那么简单。例如，如果你在内存中看到0x0D 0x0C 0x0B 0x0A，并且这个值是`float`类型的，你不能简单地将其转换为0x0A0B0C0D。相反，`float`值有三个组成部分：*符号*（位0）、*指数*（位1–8）和*尾数*（位9–31）。'
- en: The sign determines whether the number is negative or positive, the exponent
    determines how many places to move the decimal point (starting before the mantissa),
    and the mantissa holds an approximation of the value. You can retrieve the stored
    value by evaluating the expression *mantissa* × 10^(*n*) (where *n* is the exponent)
    and multiplying the result by –1 if the sign is set.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 符号位决定数字是正数还是负数，指数决定小数点移动多少位（从尾数之前开始），尾数则存储该值的近似值。你可以通过计算表达式*尾数* × 10^(*n*)（其中*n*是指数）来恢复存储的值，如果符号位被设置，则结果乘以-1。
- en: Now let’s look at some numeric data types in memory. [Listing 4-1](ch04.xhtml#ch4exe1)
    initializes nine variables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下内存中的一些数字数据类型。[清单 4-1](ch04.xhtml#ch4exe1)初始化了九个变量。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: Creating variables of numeric data types in C++*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：在C++中创建数字数据类型的变量*'
- en: Starting from the top, this example includes variables of types `char`, `short`,
    `int`, `long long`, and `float`. Four of these are unsigned, and five are signed.
    (In C++, a `float` can’t be unsigned.) Taking into account what you’ve learned
    so far, carefully study the relationship between the code in [Listing 4-1](ch04.xhtml#ch4exe1)
    and the memory dump in [Figure 4-2](ch04.xhtml#ch4fig2). Assume that the variables
    are declared in global scope.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，这个示例包括了`char`、`short`、`int`、`long long`和`float`类型的变量。其中四个是无符号的，五个是有符号的。（在C++中，`float`不能是无符号的。）考虑到你到目前为止学到的内容，请仔细研究[清单
    4-1](ch04.xhtml#ch4exe1)中的代码和[图 4-2](ch04.xhtml#ch4fig2)中的内存转储之间的关系。假设这些变量在全局作用域中声明。
- en: '![image](../images/f04-02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-02.jpg)'
- en: '*Figure 4-2: OllyDbg memory dump of our numeric data*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：OllyDbg的数字数据内存转储*'
- en: You might notice that some values seem arbitrarily spaced out. Since it’s much
    faster for processors to access values residing at addresses that are multiples
    of the address size (which is 32 bits in x86), compilers *pad* values with zeros
    in order to align them on such addresses—hence, padding is also called *alignment*.
    Single-byte values are not padded, since operations that access them perform the
    same regardless of alignment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一些值看起来被随机分隔开。由于处理器访问存储在地址大小倍数位置的值更快（在x86中是32位），因此编译器会用零来填充这些值，以便将它们对齐到这样的地址上——因此，填充也被称为*对齐*。单字节值不会进行填充，因为访问它们的操作无论对齐如何都执行相同。
- en: Keeping this in mind, take a look at [Table 4-2](ch04.xhtml#ch4tab2), which
    provides a sort of memory-to-code crosswalk between the memory dump in [Figure
    4-2](ch04.xhtml#ch4fig2) and the variables declared in [Listing 4-1](ch04.xhtml#ch4exe1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这一点，来看一下[表 4-2](ch04.xhtml#ch4tab2)，它提供了[图 4-2](ch04.xhtml#ch4fig2)中的内存转储和[清单
    4-1](ch04.xhtml#ch4exe1)中声明的变量之间的内存与代码的映射。
- en: '**Table 4-2:** Memory-to-Code Crosswalk for [Listing 4-1](ch04.xhtml#ch4exe1)
    and [Figure 4-2](ch04.xhtml#ch4fig2)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2:** [清单 4-1](ch04.xhtml#ch4exe1)和[图 4-2](ch04.xhtml#ch4fig2)的内存与代码的映射'
- en: '| **Address** | **Size** | **Data** | **Object** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **大小** | **数据** | **对象** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0x00BB3018 | 1 byte | 0xFF | `ubyteValue` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3018 | 1 字节 | 0xFF | `ubyteValue` |'
- en: '| 0x00BB3019 | 1 byte | 0xFE | `byteValue` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3019 | 1 字节 | 0xFE | `byteValue` |'
- en: '| 0x00BB301A | 2 bytes | 0x00 0x00 | Padding before `uwordValue` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB301A | 2 字节 | 0x00 0x00 | `uwordValue`之前的填充 |'
- en: '| 0x00BB301C | 2 bytes | 0x42 0x41 | `uwordValue` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB301C | 2 字节 | 0x42 0x41 | `uwordValue` |'
- en: '| 0x00BB301E | 2 bytes | 0x00 0x00 | Padding before `wordValue` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB301E | 2 字节 | 0x00 0x00 | `wordValue`之前的填充 |'
- en: '| 0x00BB3020 | 2 bytes | 0x44 0x43 | `wordValue` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3020 | 2 字节 | 0x44 0x43 | `wordValue` |'
- en: '| 0x00BB3022 | 2 bytes | 0x00 0x00 | Padding before `udwordValue` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3022 | 2 字节 | 0x00 0x00 | `udwordValue`之前的填充 |'
- en: '| 0x00BB3024 | 4 bytes | 0xEF 0xBE 0xAD 0xDE | `udwordValue` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3024 | 4 字节 | 0xEF 0xBE 0xAD 0xDE | `udwordValue` |'
- en: '| 0x00BB3028 | 4 bytes | 0xEF 0xBE 0xAD 0xDE | `dwordValue` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3028 | 4 字节 | 0xEF 0xBE 0xAD 0xDE | `dwordValue` |'
- en: '| 0x00BB302C | 4 bytes | 0x76 0x37 0xA7 0x44 | `floatValue` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB302C | 4 字节 | 0x76 0x37 0xA7 0x44 | `floatValue` |'
- en: '| 0x00BB3030 | 8 bytes | 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF | `ulongLongValue`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3030 | 8 字节 | 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF | `ulongLongValue`
    |'
- en: '| 0x00BB3038 | 8 bytes | 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF | `LongLongValue`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 0x00BB3038 | 8字节 | 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF | `LongLongValue`
    |'
- en: The Address column lists locations in memory, and the Data column tells you
    exactly what’s stored there. The Object column tells you which variable from [Listing
    4-1](ch04.xhtml#ch4exe1) each piece of data relates to. Notice that `floatValue`
    is placed before `ulongLongValue` in memory, even though it’s the last variable
    declared in [Listing 4-1](ch04.xhtml#ch4exe1). Because these variables are declared
    in global scope, the compiler can place them wherever it wants. This particular
    move is likely a result of either alignment or optimization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 地址列列出了内存中的位置，数据列告诉你存储在这些位置的内容。对象列告诉你每条数据与[清单 4-1](ch04.xhtml#ch4exe1)中哪个变量相关。注意，尽管
    `floatValue` 在[清单 4-1](ch04.xhtml#ch4exe1)中是最后声明的变量，但它被放置在 `ulongLongValue` 之前。这是因为这些变量是在全局范围内声明的，编译器可以将它们放置在任何位置。这个特定的排列很可能是由于对齐或优化的结果。
- en: '***String Data***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串数据***'
- en: Most developers use the term *string* as if it’s synonymous with *text*, but
    text is only the most common use for strings. At a low level, strings are just
    arrays of arbitrary numeric objects that appear linear and unaligned in memory.
    [Listing 4-2](ch04.xhtml#ch4exe2) shows four text string declarations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者将*字符串*一词与*文本*等同起来，但文本只是字符串最常见的应用。低层次上，字符串只是一些看起来线性且未对齐的内存中任意数值对象的数组。[清单
    4-2](ch04.xhtml#ch4exe2)展示了四个文本字符串声明。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-2: Declaring several strings in C++*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-2：在 C++ 中声明多个字符串*'
- en: In the context of text, strings hold character objects (`char` for 8-bit encoding
    or `wchar_t` for 16-bit encoding), and the end of each string is specified by
    a *null terminator*, a character equal to 0x0\. Let’s look at the memory where
    these variables are stored, as shown in the two memory dumps in [Figure 4-3](ch04.xhtml#ch4fig3).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本的上下文中，字符串包含字符对象（`char` 用于 8 位编码，`wchar_t` 用于 16 位编码），每个字符串的结束由*空终止符*指定，该字符等于
    0x0。让我们看看这些变量存储的内存，如[图 4-3](ch04.xhtml#ch4fig3)中的两个内存转储所示。
- en: '![image](../images/f04-03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-03.jpg)'
- en: '*Figure 4-3: In this OllyDbg memory dump of string data, the human-readable
    text in the ASCII column is the text we stored in [Listing 4-2](ch04.xhtml#ch4exe2).*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：在这个 OllyDbg 字符串数据内存转储中，ASCII 列中的人类可读文本是我们在[清单 4-2](ch04.xhtml#ch4exe2)中存储的文本。*'
- en: If you’re not used to reading memory, the OllyDbg dump might be a bit difficult
    to follow at this point. [Table 4-3](ch04.xhtml#ch4tab3) shows a deeper look at
    the correlation between the code in [Listing 4-2](ch04.xhtml#ch4exe2) and the
    memory in [Figure 4-3](ch04.xhtml#ch4fig3).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不习惯阅读内存，OllyDbg 转储可能在这个时候会有点难以跟随。[表 4-3](ch04.xhtml#ch4tab3) 展示了[清单 4-2](ch04.xhtml#ch4exe2)中的代码与[图
    4-3](ch04.xhtml#ch4fig3)中的内存之间的更深层次的关联。
- en: '**Table 4-3:** Memory-to-Code Crosswalk for [Listing 4-2](ch04.xhtml#ch4exe2)
    and [Figure 4-3](ch04.xhtml#ch4fig3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** [清单 4-2](ch04.xhtml#ch4exe2) 和 [图 4-3](ch04.xhtml#ch4fig3) 中的内存与代码映射'
- en: '| **Address** | **Size** | **Data** | **Object** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **大小** | **数据** | **对象** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Pane 1 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 面板 1 |'
- en: '| 0x012420F8 | 32 bytes | 0x6D 0x79 0x5F {...} 0x74 0x65 0x72 | `thinStringP`
    characters |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 0x012420F8 | 32字节 | 0x6D 0x79 0x5F {...} 0x74 0x65 0x72 | `thinStringP`字符
    |'
- en: '| 0x01242118 | 4 bytes | 0x00 0x00 0x00 0x00 | `thinStringP` terminator and
    padding |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 0x01242118 | 4字节 | 0x00 0x00 0x00 0x00 | `thinStringP` 终结符和填充 |'
- en: '| 0x0124211C | 4 bytes | 0x00 0x00 0x00 0x00 | Unrelated data |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 0x0124211C | 4字节 | 0x00 0x00 0x00 0x00 | 无关数据 |'
- en: '| 0x01242120 | 64 bytes | 0x6D 0x00 0x79 {...} 0x00 0x72 0x00 | `wideStringP`
    characters |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 0x01242120 | 64字节 | 0x6D 0x00 0x79 {...} 0x00 0x72 0x00 | `wideStringP`字符
    |'
- en: '| 0x01242160 | 4 bytes | 0x00 0x00 0x00 0x00 | `wideStringP` terminator and
    padding |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 0x01242160 | 4字节 | 0x00 0x00 0x00 0x00 | `wideStringP` 终结符和填充 |'
- en: '| {...} |  |  | Unrelated data |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| {...} |  |  | 无关数据 |'
- en: '| Pane 2 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 面板 2 |'
- en: '| 0x01243040 | 4 bytes | 0xF8 0x20 0x24 0x01 | Pointer to `thinStringP` at
    `0x012420F8` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 0x01243040 | 4字节 | 0xF8 0x20 0x24 0x01 | 指向 `thinStringP` 的指针，位于 `0x012420F8`
    |'
- en: '| 0x01243044 | 30 bytes | 0x6D 0x79 0x5F {...} 0x72 0x61 0x79 | `thinStringA`
    characters |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 0x01243044 | 30字节 | 0x6D 0x79 0x5F {...} 0x72 0x61 0x79 | `thinStringA`字符
    |'
- en: '| 0x01243062 | 10 bytes | 0x00 repeated 10 times | `thinStringA` terminator
    and array fill |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 0x01243062 | 10字节 | 0x00 重复 10 次 | `thinStringA` 终结符和数组填充 |'
- en: '| 0x0124306C | 4 bytes | 0x20 0x21 0x24 0x01 | Pointer to `wideStringP` at
    `0x01242120` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 0x0124306C | 4字节 | 0x20 0x21 0x24 0x01 | 指向 `wideStringP` 的指针，位于 `0x01242120`
    |'
- en: '| 0x01243070 | 60 bytes | 0x6D 0x00 0x79 {...} 0x00 0x79 0x00 | `wideStringA`
    characters |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 0x01243070 | 60字节 | 0x6D 0x00 0x79 {...} 0x00 0x79 0x00 | `wideStringA`字符
    |'
- en: '| 0x012430AC | 20 bytes | 0x00 repeated 10 times | `wideStringA` terminator
    and array fill |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 0x012430AC | 20 字节 | 重复 10 次的 0x00 | `wideStringA` 终止符和数组填充 |'
- en: In [Figure 4-3](ch04.xhtml#ch4fig3), pane 1 shows that the values stored where
    `thinStringP` (address 0x01243040) and `wideStringP` (address 0x0124306C) belong
    in memory are only 4 bytes long and contain no string data. That’s because these
    variables are actually pointers to the first characters of their respective arrays.
    For example, `thinStringP` contains 0x012420F8, and in pane 2 in [Figure 4-3](ch04.xhtml#ch4fig3),
    you can see `"my_thin_terminated_value_pointer"` located at address 0x012420F8.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-3](ch04.xhtml#ch4fig3)中，面板 1 显示了存储在`thinStringP`（地址 0x01243040）和`wideStringP`（地址
    0x0124306C）所在内存位置的数据仅为 4 字节长，并且不包含任何字符串数据。这是因为这些变量实际上是指向各自数组第一个字符的指针。例如，`thinStringP`包含
    0x012420F8，在[图 4-3](ch04.xhtml#ch4fig3)中的面板 2 里，你可以看到位于地址 0x012420F8 的字符串 `"my_thin_terminated_value_pointer"`。
- en: Look at the data between these pointers in pane 1, and you can see the text
    being stored by `thinStringA` and `wideStringA`. Furthermore, notice that `thinStringA`
    and `wideStringA` are padded beyond their null terminators; this is because these
    variables were declared as arrays with length `40`, so they are filled up to 40
    characters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看面板 1 中这些指针之间的数据，你可以看到由`thinStringA`和`wideStringA`存储的文本。此外，注意到`thinStringA`和`wideStringA`在它们的空字符终止符之后被填充了空间；这是因为这些变量被声明为长度为`40`的数组，因此它们被填充到40个字符。
- en: '***Data Structures***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据结构***'
- en: Unlike the data types we have previously discussed, *structures* are containers
    that hold multiple pieces of simple, related data. Game hackers who know how to
    identify structures in memory can mimic those structures in their own code. This
    can greatly reduce the number of addresses they must find, as they need to find
    only the address to the start of the structure, not the address of every individual
    item.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的数据类型不同，*结构体*是包含多个简单相关数据的容器。懂得如何识别内存中结构体的游戏黑客可以在他们自己的代码中模拟这些结构体。这可以大大减少他们必须查找的地址数量，因为他们只需要找到结构体起始地址，而不是每个单独项的地址。
- en: '**NOTE**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This section talks about structures as simple containers that lack member
    functions and contain only simple data. Objects that exceed these limitations
    will be discussed in “[Classes and VF Tables](ch04.xhtml#ch00lev1sec76)” on [page
    74](ch04.xhtml#page_74).*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节讨论了作为简单容器的结构体，它们没有成员函数，仅包含简单数据。超出这些限制的对象将在[“类和虚函数表”](ch04.xhtml#ch00lev1sec76)中讨论，详见[第74页](ch04.xhtml#page_74)。*'
- en: '**Structure Element Order and Alignment**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结构体元素的顺序和对齐**'
- en: Since structures simply represent an assortment of objects, they don’t visibly
    manifest in memory dumps. Instead, a memory dump of a structure shows the objects
    that are contained within that structure. The dump would look much like the others
    I’ve shown in this chapter, but with important differences in both order and alignment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结构体仅仅是多个对象的集合，它们在内存转储中不会直接显示。相反，结构体的内存转储会显示其中包含的对象。这个转储看起来与我在本章中展示的其他转储非常相似，但在顺序和对齐上有重要的区别。
- en: To see these differences, start by taking a look at [Listing 4-3](ch04.xhtml#ch4exe3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这些差异，首先请查看[示例 4-3](ch04.xhtml#ch4exe3)。
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-3: A C++ structure and some code that uses it*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-3：一个 C++ 结构体及其使用的代码*'
- en: This code declares a structure named `MyStruct` and creates a variable named
    `m` that supposedly points to an instance of the structure at address 0\. There’s
    not actually an instance of the structure at address 0, but this trick lets me
    use the ampersand operator (`&`) in the `printf()` call to get the address of
    each member of the structure. Since the structure is located at address 0, the
    address printed for each member is equivalent to its offset from the start of
    the structure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了一个名为`MyStruct`的结构体，并创建了一个名为`m`的变量，假设它指向地址 0 上的该结构体实例。实际上地址 0 上并没有结构体实例，但这个技巧让我可以在`printf()`调用中使用取地址符号（`&`）来获取结构体每个成员的地址。由于结构体位于地址
    0，因此打印的每个成员的地址相当于它相对于结构体起始位置的偏移量。
- en: 'The ultimate purpose of this example is to see exactly how each member is laid
    out in memory, relative to the start of the structure. If you were to run the
    code, you’d see the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的最终目的是精确查看每个成员在内存中的布局，相对于结构体的起始位置。如果你运行这段代码，你会看到以下输出：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the variables in `MyStruct` are ordered exactly as they were
    defined in code. This sequential member layout is a mandatory property of structures.
    Compare this to the example from [Listing 4-1](ch04.xhtml#ch4exe1), when we declared
    an identical set of variables; in the memory dump from [Figure 4-2](ch04.xhtml#ch4fig2),
    the compiler clearly placed some values out of order in memory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`MyStruct` 中的变量是按照代码中定义的顺序排列的。这种顺序排列是结构体的强制属性。与[示例 4-1](ch04.xhtml#ch4exe1)中的例子对比，我们声明了一组相同的变量；在[图
    4-2](ch04.xhtml#ch4fig2)中的内存转储里，编译器明显将一些值放置到了内存中的不正确顺序。
- en: Furthermore, you may have noticed that the members are not aligned like the
    globally scoped variables in [Listing 4-1](ch04.xhtml#ch4exe1); if they were,
    for example, there would be 2 padding bytes before `uwordValue`. This is because
    structure members are aligned on addresses divisible by either the *struct member
    alignment* (a compiler option that accepts 1, 2, 4, 8, or 16 bytes; in this example,
    it’s set to 4) or the size of the member—whichever is smaller. I arranged the
    members of `MyStruct` so that the compiler didn’t need to pad the values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能已经注意到，成员的对齐方式与[示例 4-1](ch04.xhtml#ch4exe1)中的全局作用域变量不同；例如，如果它们对齐的话，在 `uwordValue`
    前面应该有 2 个填充字节。这是因为结构体成员会按照能被*结构体成员对齐*（这是一个编译器选项，接受 1、2、4、8 或 16 字节；在此示例中设置为 4）或成员的大小——取较小者——的地址进行对齐。我安排了
    `MyStruct` 的成员，使得编译器无需填充这些值。
- en: 'If, however, we put a `char` immediately after `ulongLongValue`, the `printf()`
    call would give the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在 `ulongLongValue` 后立即放一个 `char`，`printf()` 调用将会输出以下结果：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, take a look at the original and the modified outputs together:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一起看看原始输出和修改后的输出：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the modified version, the last two values, which are the offsets for `longLongValue`
    and `floatValue` from the start of the structure, have changed. Thanks to the
    struct member alignment, the variable `longLongValue` moves by 4 bytes (1 for
    the `char` value and 3 following it) to ensure it gets placed on an address divisible
    by 4.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的版本中，最后两个值，即 `longLongValue` 和 `floatValue` 从结构体起始位置的偏移量发生了变化。由于结构体成员对齐，变量
    `longLongValue` 移动了 4 字节（1 字节用于 `char` 值，后面跟着 3 字节）以确保它被放置在一个能被 4 整除的地址上。
- en: '**How Structures Work**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结构如何工作**'
- en: 'Understanding structures—how they are aligned and how to mimic them—can be
    very useful. For instance, if you replicate a game’s structures in your own code,
    you can read or write those entire structures from memory in a single operation.
    Consider a game that declares the player’s current and max health like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 理解结构体——它们是如何对齐的以及如何模拟它们——非常有用。例如，如果你在自己的代码中复制了一个游戏的结构体，你可以在一次操作中从内存中读取或写入整个结构体。考虑一个游戏，声明玩家当前的生命值和最大生命值，如下所示：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If an inexperienced game hacker wants to read this information from memory,
    they might write something like this to fetch the health values:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个经验不足的游戏黑客想要从内存中读取这些信息，他们可能会写如下代码来获取生命值：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This game hacker doesn’t realize that seeing these values right next to each
    other in memory could be more than a lucky happenstance, so they’ve used two separate
    variables. But if you came along with your knowledge of structures, you might
    conclude that, since these values are closely related and are adjacent in memory,
    our hacker could have used a structure instead:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏黑客没有意识到，看到这些值在内存中紧挨着彼此可能不仅仅是一个幸运的偶然现象，所以他们使用了两个独立的变量。但如果你带着对结构体的理解来分析，你可能会得出结论：既然这些值密切相关并且在内存中相邻，那么我们的黑客本可以使用一个结构体来代替：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since this code assumes a structure is being used and correctly mimics it, it
    can fetch both health and max health in just one line ➊. We’ll dive deeper into
    how to write your own code to read memory from in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码假设正在使用结构体并正确模拟了它，它只需一行代码就能获取健康值和最大健康值 ➊。我们将在[第六章](ch06.xhtml#ch06)中深入探讨如何编写自己的代码来读取内存。
- en: '***Unions***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***联合体***'
- en: 'Unlike structures, which encapsulate multiple pieces of related data, *unions*
    contain a single piece of data that is exposed through multiple variables. Unions
    follow three rules:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与封装多个相关数据的结构体不同，*联合体*包含通过多个变量暴露的单一数据。联合体遵循三条规则：
- en: • The size of a union in memory is equal to that of its largest member.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: • 联合体在内存中的大小等于其最大成员的大小。
- en: • Members of a union all reference the same memory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: • 联合体的成员都引用相同的内存。
- en: • A union inherits the alignment of its largest member.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: • 联合体继承其最大成员的对齐方式。
- en: 'The `printf()` call in the following code helps illustrate the first two rules:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的`printf()`调用有助于说明前两个规则：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This call to `printf()` outputs the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`printf()`调用输出以下内容：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first rule is illustrated by the `Size` value, which is printed first. Even
    though `dwValue` has three members that occupy a total of 9 bytes, it has a size
    of only 4 bytes. The size result validates the second rule as well, because `dwValue.value`
    and `dwValue.words` both point to address `0x2efda8`, as shown by the values printed
    after the word `Addresses`. The second rule is also validated by the fact that
    `dwValue.words.first` and `dwValue.words.second` contain `0xbeef` and `0xdead`,
    printed after `Values`, which makes sense considering that `dwValue.value` is
    `0xdeadbeef`. The third rule isn’t demonstrated in this example because we don’t
    have enough memory context, but if you were to put this union inside a structure
    and surround it with whatever types you like, it would in fact always align like
    a `DWORD`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则通过`Size`值来说明，该值首先被打印。尽管`dwValue`有三个成员，占用了9个字节，但它的大小仅为4个字节。这个大小结果也验证了第二个规则，因为`dwValue.value`和`dwValue.words`都指向地址`0x2efda8`，这在`Addresses`后面打印的值中得到了显示。第二个规则也得到了验证，因为`dwValue.words.first`和`dwValue.words.second`分别包含`0xbeef`和`0xdead`，这些值在`Values`后面打印出来，考虑到`dwValue.value`为`0xdeadbeef`，这就有意义了。第三个规则在这个示例中没有展示，因为我们没有足够的内存上下文，但如果你将这个联合体放入一个结构体中，并围绕它放置任何你喜欢的类型，它实际上总是会像`DWORD`那样对齐。
- en: '***Classes and VF Tables***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类与VF表***'
- en: Much like structures, *classes* are containers that hold and isolate multiple
    pieces of data, but classes can also contain function definitions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于结构体，*类*是用于容纳和隔离多个数据项的容器，但类还可以包含函数定义。
- en: '**A Simple Class**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个简单的类**'
- en: Classes with normal functions, such as `bar` in [Listing 4-4](ch04.xhtml#ch4exe4),
    conform to the same memory layouts as structures.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 带有普通函数的类，如[清单 4-4](ch04.xhtml#ch4exe4)中的`bar`，遵循与结构体相同的内存布局。
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-4: A C++ class*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：一个C++类*'
- en: 'The `printf()` call in [Listing 4-4](ch04.xhtml#ch4exe4) would output the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-4](ch04.xhtml#ch4exe4)中的`printf()`调用将输出以下内容：'
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even though `bar` has two member functions, this output shows that it spans
    only the 8 bytes needed to hold `bar1` and `bar2`. This is because the `bar` class
    doesn’t include abstractions of those member functions, so the program can call
    them directly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`bar`有两个成员函数，输出仍然显示它仅占用8个字节来保存`bar1`和`bar2`。这是因为`bar`类不包含这些成员函数的抽象，程序可以直接调用它们。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Access levels such as `public`, `private`, and `protected` do not manifest
    in memory. Regardless of these modifiers, members of classes are still ordered
    as they are defined.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*如`public`、`private`和`protected`等访问级别在内存中不会显现。无论这些修饰符如何，类的成员仍然按其定义顺序排列。*'
- en: '**A Class with Virtual Functions**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个带有虚拟函数的类**'
- en: 'In classes that do include abstract functions (often called *virtual* functions),
    the program must know which function to call. Consider the class definitions in
    [Listing 4-5](ch04.xhtml#ch4exe5):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含抽象函数（通常称为*虚拟*函数）的类中，程序必须知道调用哪个函数。请参考[清单 4-5](ch04.xhtml#ch4exe5)中的类定义：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-5: The foo, fooa, and foob classes*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：foo、fooa和foob类*'
- en: 'The class `foo` has three virtual functions: `bar`, `baz`, and `barbaz`. Classes
    `fooa` and `foob` inherit from class `foo` and overload both `bar` and `baz`.
    Since `fooa` and `foob` have a public base class of `foo`, a `foo` pointer can
    point to them, but the program must still call the correct versions of `bar` and
    `baz`. You can see this by executing the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`类有三个虚拟函数：`bar`、`baz`和`barbaz`。`fooa`和`foob`类继承自`foo`类并重载了`bar`和`baz`。由于`fooa`和`foob`有一个公开的基类`foo`，因此一个`foo`指针可以指向它们，但程序仍然必须调用正确版本的`bar`和`baz`。你可以通过执行以下代码来查看这一点：'
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And here is the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output shows that `_testfoo->bar()` invoked `fooa::bar()` even though `_testfoo`
    is a `foo` pointer. The program knew which version of the function to call, because
    the compiler included a *VF (virtual function) table* in the memory of `_testfoo`.
    VF tables are arrays of function addresses that abstract class instances use to
    tell a program where their overloaded functions are located.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，尽管`_testfoo`是一个`foo`指针，`_testfoo->bar()`调用了`fooa::bar()`。程序知道调用哪个版本的函数，因为编译器在`_testfoo`的内存中包含了一个*VF（虚拟函数）表*。VF表是函数地址的数组，抽象类实例使用它来告诉程序它们的重载函数的位置。
- en: '**Class Instances and Virtual Function Tables**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类实例与虚拟函数表**'
- en: 'To understand the relationship between class instances and VF tables, let’s
    inspect a memory dump of the three objects declared in this listing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解类实例与 VF 表之间的关系，我们来检查一下在此清单中声明的三个对象的内存转储：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These objects are of the types defined in [Listing 4-5](ch04.xhtml#ch4exe5).
    You can see them in memory in [Figure 4-4](ch04.xhtml#ch4fig4).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是[清单 4-5](ch04.xhtml#ch4exe5)中定义的类型。您可以在[图 4-4](ch04.xhtml#ch4fig4)中看到它们的内存布局。
- en: '![image](../images/f04-04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f04-04.jpg)'
- en: '*Figure 4-4: OllyDbg memory dump of class data*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：OllyDbg 的类数据内存转储*'
- en: Pane 1 shows that each class instance stores its members just like a structure,
    but it precedes them with a `DWORD` value that points to the class instance’s
    VF table. Pane 2 shows the VF tables for each of our three class instances. The
    memory-to-code crosswalk in [Table 4-4](ch04.xhtml#ch4tab4) shows how these panes
    and the code tie together.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 面板 1 显示每个类实例像结构体一样存储其成员，但它们之前会有一个 `DWORD` 值，指向该类实例的 VF 表。面板 2 显示了我们三个类实例的 VF
    表。[表 4-4](ch04.xhtml#ch4tab4) 中的内存到代码交叉映射展示了这些面板和代码是如何关联的。
- en: '**Table 4-4:** Memory-to-Code Crosswalk for [Listing 4-5](ch04.xhtml#ch4exe5)
    and [Figure 4-4](ch04.xhtml#ch4fig4)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-4：** [清单 4-5](ch04.xhtml#ch4exe5) 和 [图 4-4](ch04.xhtml#ch4fig4) 的内存到代码交叉映射'
- en: '| **Address** | **Size** | **Data** | **Object** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **大小** | **数据** | **对象** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Pane 1 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 面板 1 |'
- en: '| 0x0018FF20 | 4 bytes | 0x004022B0 | Start of `_foo` and pointer to `foo`
    VF table |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 0x0018FF20 | 4 字节 | 0x004022B0 | `_foo` 的开始及指向 `foo` VF 表的指针 |'
- en: '| 0x0018FF24 | 8 bytes | 0xDEADBEEF 0xBABABABA | `_foo.myValue1` and `_foo.myValue2`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 0x0018FF24 | 8 字节 | 0xDEADBEEF 0xBABABABA | `_foo.myValue1` 和 `_foo.myValue2`
    |'
- en: '| 0x0018FF2C | 4 bytes | 0x004022C0 | Start of `_fooa` and pointer to `fooa`
    VF table |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 0x0018FF2C | 4 字节 | 0x004022C0 | `_fooa` 的开始及指向 `fooa` VF 表的指针 |'
- en: '| 0x0018FF30 | 8 bytes | 0xDEADBEEF 0xBABABABA | `_fooa.myValue1` and `_fooa.myValue2`
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 0x0018FF30 | 8 字节 | 0xDEADBEEF 0xBABABABA | `_fooa.myValue1` 和 `_fooa.myValue2`
    |'
- en: '| 0x0018FF38 | 4 bytes | 0x004022D0 | Start of `_foob` and pointer to `foob`
    VF table |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 0x0018FF38 | 4 字节 | 0x004022D0 | `_foob` 的开始及指向 `foob` VF 表的指针 |'
- en: '| 0x0018FF3C | 8 bytes | 0xDEADBEEF 0xBABABABA | `_foob.myValue1` and `_foob.myValue2`
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 0x0018FF3C | 8 字节 | 0xDEADBEEF 0xBABABABA | `_foob.myValue1` 和 `_foob.myValue2`
    |'
- en: '| {...} |  |  | Unrelated data |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| {...} |  |  | 无关数据 |'
- en: '| Pane 2 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 面板 2 |'
- en: '| 0x004022B0 | 4 bytes | 0x00401060 | Start of `foo` VF table; address of `foo::bar`
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022B0 | 4 字节 | 0x00401060 | `foo` VF 表的开始；`foo::bar` 的地址 |'
- en: '| 0x004022B4 | 4 bytes | 0x00401080 | Address of `foo::baz` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022B4 | 4 字节 | 0x00401080 | `foo::baz` 的地址 |'
- en: '| 0x004022B8 | 4 bytes | 0x004010A0 | Address of `foo::barbaz` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022B8 | 4 字节 | 0x004010A0 | `foo::barbaz` 的地址 |'
- en: '| 0x004022BC | 4 bytes | 0x0040243C | Unrelated data |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022BC | 4 字节 | 0x0040243C | 无关数据 |'
- en: '| 0x004022C0 | 4 bytes | 0x004010D0 | Start of `fooa` VF table; address of
    `fooa::bar` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022C0 | 4 字节 | 0x004010D0 | `fooa` VF 表的开始；`fooa::bar` 的地址 |'
- en: '| 0x004022C4 | 4 bytes | 0x004010F0 | Address of `fooa::baz` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022C4 | 4 字节 | 0x004010F0 | `fooa::baz` 的地址 |'
- en: '| 0x004022C8 | 4 bytes | 0x004010A0 | Address of `foo::barbaz` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022C8 | 4 字节 | 0x004010A0 | `foo::barbaz` 的地址 |'
- en: '| 0x004022CC | 4 bytes | 0x004023F0 | Unrelated data |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022CC | 4 字节 | 0x004023F0 | 无关数据 |'
- en: '| 0x004022D0 | 4 bytes | 0x00401130 | Start of `foob` VF table; address of
    `foob::bar` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022D0 | 4 字节 | 0x00401130 | `foob` VF 表的开始；`foob::bar` 的地址 |'
- en: '| 0x004022D4 | 4 bytes | 0x00401150 | Address of `foob::baz` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022D4 | 4 字节 | 0x00401150 | `foob::baz` 的地址 |'
- en: '| 0x004022D8 | 4 bytes | 0x004010A0 | Address of `foo::barbaz` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 0x004022D8 | 4 字节 | 0x004010A0 | `foo::barbaz` 的地址 |'
- en: This crosswalk shows how the VF tables for the code in [Listing 4-5](ch04.xhtml#ch4exe5)
    are laid out in memory. Each VF table is generated by the compiler when the binary
    is made, and the tables remain constant. To save space, instances of the same
    class all point to the same VF table, which is why the VF tables aren’t placed
    inline with the class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交叉表显示了[清单 4-5](ch04.xhtml#ch4exe5)中的代码如何在内存中布局 VF 表。每个 VF 表都是在生成二进制文件时由编译器生成的，这些表是常量。为了节省空间，相同类的实例都会指向相同的
    VF 表，这也是 VF 表没有与类内联的原因。
- en: 'Since we have three VF tables, you might wonder how a class instance knows
    which VF table to use. The compiler places code similar to the following bit of
    assembly in each virtual class constructor:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有三个 VF 表，您可能会想知道类实例如何知道使用哪个 VF 表。编译器会在每个虚拟类构造函数中插入类似以下的汇编代码：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example takes the static address of a VF table (`VFADDR`) and places it
    in memory as the first member of the class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例获取了 VF 表的静态地址（`VFADDR`），并将其作为类的第一个成员放置在内存中。
- en: Now look at addresses 0x004022B0, 0x004022C0, and 0x004022D0 in [Table 4-4](ch04.xhtml#ch4tab4).
    These addresses contain the beginning of the `foo`, `fooa`, and `foob` VF tables.
    Notice that `foo::barbaz` exists in all three VF tables; this is because the function
    is not overloaded by either subclass, meaning instances of each subclass will
    call the original implementation directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看[表4-4](ch04.xhtml#ch4tab4)中的地址0x004022B0、0x004022C0和0x004022D0。这些地址包含了`foo`、`fooa`和`foob`
    VF表的起始位置。请注意，`foo::barbaz`存在于这三个VF表中；这是因为该函数没有被任何子类重载，这意味着每个子类的实例都将直接调用原始实现。
- en: Notice, too, that `foo::myStaticValue` does not appear in this crosswalk. Since
    the value is static, it doesn’t actually need to exist as a part of the `foo`
    class; it’s placed inside this class only for better code organization. In reality,
    it gets treated like a global variable and is placed elsewhere.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`foo::myStaticValue`在这个交叉表中并没有出现。由于该值是静态的，它实际上不需要作为`foo`类的一部分存在；它只是在这个类内部放置，以便更好地组织代码。实际上，它像一个全局变量一样被处理，并且被放置在其他地方。
- en: '**VF TABLES AND CHEAT ENGINE**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**VF表和作弊引擎**'
- en: 'Remember Cheat Engine’s First element of pointerstruct must point to module
    option for pointer scans from [Figure 1-4](ch01.xhtml#ch1fig4) on [page 14](ch01.xhtml#page_14)?
    Now that you’ve read a bit about VF tables, that knowledge should help you understand
    how this option works: it makes Cheat Engine ignore all heap chunks where the
    first member is not a pointer to a valid VF table. It speeds up scans, but it
    works only if every step in a pointer path is part of an abstract class instance.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得作弊引擎的“指针结构的第一个元素必须指向模块选项，以便从[图1-4](ch01.xhtml#ch1fig4)上的[第14页](ch01.xhtml#page_14)进行指针扫描”吗？现在你已经读了一些关于VF表的内容，这些知识应该能帮助你理解这个选项是如何工作的：它使作弊引擎忽略所有堆块，其中第一个成员不是指向有效VF表的指针。它加快了扫描速度，但仅在指针路径中的每一步都是抽象类实例的情况下有效。
- en: The memory tour ends here, but if you have trouble identifying a chunk of data
    in the future, come back to this section for reference. Next, we’ll look at how
    a computer can understand a game’s high-level source code in the first place.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 内存之旅到此为止，但如果将来你在识别一段数据时遇到困难，欢迎回来参考这一节。接下来，我们将探讨计算机是如何理解游戏的高级源代码的。
- en: '**x86 Assembly Crash Course**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**x86汇编速成课程**'
- en: When a program’s source code is compiled into a binary, it is stripped of all
    unnecessary artifacts and translated into *machine code*. This machine code, made
    up of only bytes (command bytes are called *opcodes*, but there are also bytes
    representing operands), gets fed directly to the processor and tells it exactly
    how to behave. Those 1s and 0s flip transistors to control computation, and they
    can be extremely difficult to understand. To make computers a little easier to
    talk to, engineers working with such code use *assembly language*, a shorthand
    that represents raw machine opcodes with abbreviated names (called mnemonics)
    and a simplistic syntax.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序的源代码被编译成二进制时，它会被剥离掉所有不必要的艺术品，并转化为*机器码*。这个机器码只由字节组成（命令字节叫做*操作码*，但也有表示操作数的字节），它直接传递给处理器，告诉它如何精确地执行操作。那些1和0翻转晶体管以控制计算，它们可能非常难以理解。为了让与计算机的交流稍微变得容易一些，处理这类代码的工程师使用*汇编语言*，它是一种简化的语言，通过缩写名称（称为助记符）和简单的语法，来表示原始机器操作码。
- en: Assembly language is important for game hackers to know because many powerful
    hacks can be achieved only through direct manipulation of a game’s assembly code,
    via methods such as NOPing or hooking. In this section, you’ll learn the basics
    of *x86 assembly language*, a specific flavor of assembly made for speaking to
    32-bit processors. Assembly language is very extensive, so for the sake of brevity
    this section talks only about the small subset of assembly concepts that are most
    useful to game hackers.^([1](footnote.xhtml#ch00fn01))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言对于游戏黑客来说非常重要，因为许多强大的黑客技术只能通过直接操控游戏的汇编代码实现，例如使用NOP或钩子等方法。在本节中，你将学习* x86汇编语言*的基础知识，这是一种特定的汇编语言，专为与32位处理器交互而设计。汇编语言非常广泛，因此为了简洁，本节仅讲解对游戏黑客最有用的那一小部分汇编概念。^([1](footnote.xhtml#ch00fn01))
- en: '**NOTE**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Throughout this section, many small snippets of assembly code include comments
    set off by a semicolon (`;`) to describe each instruction in greater detail.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本节中，许多小段汇编代码包含了由分号（`;`）分隔的注释，用来更详细地描述每个指令。*'
- en: '***Command Syntax***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命令语法***'
- en: 'Assembly language is used to describe machine code, so its syntax is pretty
    simplistic. While this syntax makes it very easy for someone to understand individual
    commands (also called *operations*), it also makes understanding complex blocks
    of code very hard. Even algorithms that are easily readable in high-level code
    seem obfuscated when written in assembly. For example, the following snippet of
    pseudocode:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言用于描述机器码，因此其语法相当简单。虽然这种语法使得理解单个命令（也叫*操作*）变得非常容易，但它也使得理解复杂的代码块变得非常困难。即使是用高级语言编写的易读算法，在汇编中看起来也显得晦涩难懂。例如，以下伪代码片段：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: would look like [Listing 4-6](ch04.xhtml#ch4exe6) in x86 assembly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它在x86汇编中看起来像[列表4-6](ch04.xhtml#ch4exe6)。
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 4-6: Some x86 assembly commands*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-6：一些x86汇编命令*'
- en: Therefore, it takes extensive practice to understand even the most trivial functions
    in assembly. Understanding individual commands, however, is very simple, and by
    the end of this section, you’ll know how to parse the commands I just showed you.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解汇编中的即使是最简单的功能也需要大量的练习。然而，理解单个命令是非常简单的，到本节结束时，你将知道如何解析我刚刚给出的命令。
- en: '**Instructions**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指令**'
- en: The first part of an assembly command is called an *instruction*. If you equate
    an assembly command to a terminal command, the instruction is the program to run.
    At the machine code level, instructions are typically the first byte of a command;^([2](footnote.xhtml#ch00fn02))
    there are also some 2-byte instructions, where the first byte is 0x0F. Regardless,
    an instruction tells the processor exactly what to do. In [Listing 4-6](ch04.xhtml#ch4exe6),
    `CMP`, `JG`, `MOV`, and `JMP` are all instructions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编命令的第一部分被称为*指令*。如果你把汇编命令类比为终端命令，那么指令就是要运行的程序。在机器码层面，指令通常是命令的第一个字节；^([2](footnote.xhtml#ch00fn02))
    也有一些2字节的指令，其第一个字节是0x0F。不管怎样，指令告诉处理器要做什么。在[列表4-6](ch04.xhtml#ch4exe6)中，`CMP`、`JG`、`MOV`和`JMP`都是指令。
- en: '**Operand Syntax**'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**操作数语法**'
- en: While some instructions are complete commands, the vast majority are incomplete
    unless followed by *operands*, or parameters. Every command in [Listing 4-6](ch04.xhtml#ch4exe6)
    has at least one operand, like `EBX`, `EAX`, and `label1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些指令是完整的命令，但绝大多数指令如果没有跟随*操作数*或参数，都是不完整的。[列表4-6](ch04.xhtml#ch4exe6)中的每个命令至少有一个操作数，如`EBX`、`EAX`和`label1`。
- en: 'Assembly operands come in three forms:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编操作数有三种形式：
- en: '**Immediate value** An integer value that is declared inline (hexadecimal values
    have a trailing `h`).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**立即数** 是一种内联声明的整数值（十六进制值后跟一个`h`）。'
- en: '**Register** A name that refers to a processor register.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器** 是指处理器寄存器的名称。'
- en: '**Memory offset** An expression, placed in brackets, that represents the memory
    location of a value. The expression can be an immediate value or a register. Alternatively,
    it can be either the sum or difference of a register and immediate value (something
    like `[REG+Ah]` or `[REG-10h]`).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存偏移量** 是一个表达式，放在方括号内，表示某个值的内存位置。该表达式可以是立即数或寄存器。或者，它可以是寄存器和立即数的和或差（类似于`[REG+Ah]`或`[REG-10h]`）。'
- en: 'Each instruction in x86 assembly can have between zero and three operands,
    and commas are used to separate multiple operands. In most cases, instructions
    that require two operands have a *source operand* and a *destination operand*.
    The ordering of these operands is dependent on the assembly syntax. For example,
    [Listing 4-7](ch04.xhtml#ch4exe7) shows a group of pseudocommands written in the
    Intel syntax, which is used by Windows (and, thus, by Windows game hackers):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每条x86汇编指令可以有零到三个操作数，多个操作数用逗号分隔。在大多数情况下，需要两个操作数的指令有一个*源操作数*和一个*目标操作数*。这些操作数的顺序取决于汇编语法。例如，[列表4-7](ch04.xhtml#ch4exe7)展示了一组用Intel语法编写的伪命令，这种语法被Windows（因此也被Windows游戏黑客）使用：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-7: Demonstrating Intel syntax*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-7：演示Intel语法*'
- en: 'In the Intel syntax, the destination operand comes first, followed by the source,
    so at ➊, `R1` is the destination and `[BADFOODh]` is the source. On the other
    hand, compilers like GCC (which can be used to write bots on Windows) use a syntax
    known as AT&T, or UNIX, syntax. This syntax does things a little differently,
    as you can see in the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel语法中，目标操作数首先出现，源操作数紧随其后，因此在➊处，`R1`是目标操作数，`[BADFOODh]`是源操作数。另一方面，像GCC这样的编译器（可以用于在Windows上编写机器人）使用一种被称为AT&T或UNIX语法的语法。这种语法的处理方式略有不同，如下例所示：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is the AT&T version of [Listing 4-7](ch04.xhtml#ch4exe7). AT&T syntax
    not only reverses the operand order but also requires operand prefixing and has
    a different format for memory offset operands.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是[清单4-7](ch04.xhtml#ch4exe7)的AT&T版本。AT&T语法不仅反转了操作数顺序，还要求操作数前缀，并且对于内存偏移量操作数有不同的格式。
- en: '**Assembly Commands**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**汇编命令**'
- en: Once you understand assembly instructions and how to format their operands,
    you can start writing commands. The following code shows an assembly function,
    consisting of some very basic commands, that essentially does nothing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了汇编指令及其操作数的格式，你就可以开始编写命令。以下代码展示了一个汇编函数，由一些非常基础的命令组成，实际上什么也不做。
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two lines, a `PUSH` command and a `MOV` command, set up a stack frame.
    The next line pushes –1 to the stack, which is undone when the stack is set back
    to its original position by the `ADD ESP, 4` command. Following that, the stack
    frame is removed, the return value (stored in `EAX`) is set to `0` with an `XOR`
    instruction, and the function returns.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行，一个`PUSH`命令和一个`MOV`命令，设置了堆栈帧。接下来的一行将-1压入堆栈，这在通过`ADD ESP, 4`命令将堆栈恢复到原始位置时被撤销。之后，堆栈帧被移除，返回值（存储在`EAX`中）通过`XOR`指令被设置为`0`，然后函数返回。
- en: You’ll learn more about stack frames and functions in “[The Call Stack](ch04.xhtml#ch00lev1sec91)”
    on [page 86](ch04.xhtml#page_86) and “[Function Calls](ch04.xhtml#ch00lev1sec98)”
    on [page 94](ch04.xhtml#page_94). For now, turn your attention to the constants
    in the code—namely `EBP`, `ESP`, and `EAX`, which are used frequently in the code
    as operands. These values, among others, are called *processor registers*, and
    understanding them is essential to understanding the stack, function calls, and
    other low-level aspects of assembly code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在“[调用栈](ch04.xhtml#ch00lev1sec91)”（第86页）和“[函数调用](ch04.xhtml#ch00lev1sec98)”（第94页）中了解更多关于堆栈帧和函数的信息。现在，将注意力转向代码中的常量——即经常作为操作数使用的`EBP`、`ESP`和`EAX`。这些值，连同其他值，被称为*处理器寄存器*，理解它们对于理解堆栈、函数调用以及汇编代码的其他低级方面至关重要。
- en: '***Processor Registers***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理器寄存器***'
- en: Unlike high-level programming languages, assembly language does not have user-defined
    variable names. Instead, it accesses data by referencing its memory address. During
    intensive computation, however, it can be extremely costly for the processor to
    constantly deal with the overhead of reading and writing data to RAM. To mitigate
    this high cost, x86 processors provide a small set of temporary variables, called
    processor registers, which are small storage spaces within the processor itself.
    Since accessing these registers requires far less overhead than accessing RAM,
    assembly uses them to describe its internal state, pass volatile data around,
    and store context-sensitive variables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与高级编程语言不同，汇编语言没有用户定义的变量名。相反，它通过引用内存地址来访问数据。然而，在进行大量计算时，处理器不断处理读取和写入RAM数据的开销可能会非常昂贵。为了减轻这种高昂的成本，x86处理器提供了一小组临时变量，称为处理器寄存器，这些寄存器是处理器内部的小存储空间。由于访问这些寄存器的开销远小于访问RAM，因此汇编语言使用它们来描述其内部状态，传递易失性数据并存储上下文相关的变量。
- en: '**General Registers**'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通用寄存器**'
- en: 'When assembly code needs to store or operate on arbitrary data, it uses a subset
    of process registers called *general registers*. These registers are used exclusively
    to store process-specific data, such as a function’s local variables. Each general
    register is 32 bits and thus can be thought of as a `DWORD` variable. General
    registers are also optimized for specific purposes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当汇编代码需要存储或操作任意数据时，它使用一组称为*通用寄存器*的进程寄存器子集。这些寄存器专门用于存储特定于进程的数据，例如函数的局部变量。每个通用寄存器是32位的，因此可以视为一个`DWORD`变量。通用寄存器也经过优化以用于特定目的：
- en: '**EAX, the accumulator** This register is optimized for mathematical computations.
    Some operations, such as multiplication and division, can only occur in EAX.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAX，累加器** 这个寄存器经过优化，专门用于数学运算。有些操作，比如乘法和除法，只能在EAX中进行。'
- en: '**EBX, the base register** This register is used arbitrarily for extra storage.
    Since its 16-bit predecessor, BX, was the only register that operations could
    use to reference memory addresses, EBX was used as a reference to RAM. In x86
    assembly, however, all registers can be address references, leaving EBX without
    a true purpose.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**EBX，基址寄存器** 这个寄存器被任意用于额外存储。由于它的16位前身BX是唯一一个可以用于引用内存地址的寄存器，EBX曾被用作对RAM的引用。然而，在x86汇编中，所有寄存器都可以作为地址引用，使得EBX失去了其真正的用途。'
- en: '**ECX, the counter** This register is optimized to act as the counter variable
    (often called `i` in high-level code) in a loop.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECX，计数器** 这个寄存器被优化用于充当循环中的计数变量（通常在高级代码中称为 `i`）。'
- en: '**EDX, the data register** This register is optimized to act as a helper to
    EAX. In 64-bit computations, for instance, EAX acts as bits 0–31 and EDX acts
    as bits 32–63.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**EDX，数据寄存器** 这个寄存器被优化为 EAX 的辅助寄存器。例如，在 64 位计算中，EAX 作为位 0–31，EDX 作为位 32–63。'
- en: 'These registers also have a set of 8- and 16-bit subregisters that you can
    use to access partial data. Think of every general register as a union, where
    a register name describes the 32-bit member and the subregisters are alternate
    members that allow access to smaller pieces of the register. The following code
    shows what this union might look like for EAX:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器还拥有一组 8 位和 16 位的子寄存器，您可以用它们来访问部分数据。可以把每个通用寄存器看作一个联合体，其中寄存器名称描述的是 32 位成员，而子寄存器则是允许访问寄存器中更小部分的备用成员。以下代码展示了
    EAX 的联合体可能的样子：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, `AX` allows access to the lower `WORD` of `EAX`, while `AL`
    allows access to the lower `BYTE` of `AX` and `AH` to its higher `BYTE`. Every
    general register has this structure, and I outline the other registers’ subregisters
    in [Figure 4-5](ch04.xhtml#ch4fig5).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`AX` 允许访问 `EAX` 的低位 `WORD`，而 `AL` 允许访问 `AX` 的低位 `BYTE`，`AH` 则是高位 `BYTE`。每个通用寄存器都有这样的结构，我在
    [图 4-5](ch04.xhtml#ch4fig5) 中列出了其他寄存器的子寄存器。
- en: '![image](../images/f04-05.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-05.jpg)'
- en: '*Figure 4-5: x86 registers and subregisters*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：x86 寄存器和子寄存器*'
- en: EAX, EBC, ECX, and EDX have higher words, too, but the compiler will almost
    never access them on its own, as it can just use the lower word when it needs
    word-only storage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: EAX、EBC、ECX 和 EDX 也有高位字，但是编译器几乎从不单独访问它们，因为它可以在需要仅存储字时直接使用低位字。
- en: '**Index Registers**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**索引寄存器**'
- en: 'x86 assembly also has four *index registers*, which are used to access data
    streams, reference the call stack, and keep track of local information. Like the
    general registers, index registers are 32 bits, but index registers have more
    strictly defined purposes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: x86 汇编还有四个*索引寄存器*，用于访问数据流、引用调用栈以及跟踪局部信息。与通用寄存器一样，索引寄存器是 32 位的，但索引寄存器有着更为严格的用途：
- en: '**EDI, the destination index** This register is used to index memory targeted
    by write operations. If there are no write operations in a piece of code, the
    compiler can use EDI for arbitrary storage if needed.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**EDI，目标索引** 这个寄存器用于索引目标为写操作的内存。如果代码中没有写操作，编译器可以在需要时将 EDI 用作任意存储。'
- en: '**ESI, the source index** This register is used to index memory targeted by
    read operations. It can also be used arbitrarily.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESI，源索引** 这个寄存器用于索引目标为读取操作的内存。它也可以被任意使用。'
- en: '**ESP, the stack pointer** This register is used to reference the top of the
    call stack. All stack operations directly access this register. You must use ESP
    only when working with the stack, and it must always point to the top of the stack.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESP，栈指针** 这个寄存器用于引用调用栈的顶部。所有栈操作都会直接访问这个寄存器。您必须在处理栈时使用 ESP，且它必须始终指向栈的顶部。'
- en: '**EBP, the stack base pointer** This register marks the bottom of the stack
    frame. Functions use it as a reference to their parameters and local variables.
    Some code may be compiled with an option to omit this behavior, in which case
    EBP can be used arbitrarily.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**EBP，栈基指针** 这个寄存器标记了栈帧的底部。函数使用它来引用它们的参数和局部变量。一些代码可能在编译时选择忽略这种行为，这种情况下 EBP
    可以被任意使用。'
- en: 'Like the general registers, each index register has a 16-bit counterpart: DI,
    SI, SP, and BP, respectively. However, the index registers have no 8-bit subregisters.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用寄存器类似，每个索引寄存器都有一个 16 位的对应寄存器：DI、SI、SP 和 BP，分别对应。然而，索引寄存器没有 8 位的子寄存器。
- en: '**WHY DO SOME X86 REGISTERS HAVE SUBREGISTERS?**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么一些 x86 寄存器有子寄存器？**'
- en: 'There is a historical reason why both general and index registers have 16-bit
    counterparts. The x86 architecture was based on a 16-bit architecture, from which
    it *extended* the registers AX, BX, CX, DX, DI, SI, SP, and BP. Appropriately,
    the extensions retain the same names but are prefixed with an *E*, for “extended.”
    The 16-bit versions remain for backward compatibility. This also explains why
    index registers have no 8-bit abstractions: they are intended to be used as memory-address
    offsets, and there is no practical need to know partial bytes of such values.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通用寄存器和索引寄存器都有 16 位对应版本，背后有一个历史原因。x86 架构基于 16 位架构，随后它*扩展*了寄存器 AX、BX、CX、DX、DI、SI、SP
    和 BP。恰当的，扩展版本保留相同的名称，但在前面加上了 *E*，表示“扩展”。16 位版本保留是为了向后兼容。这也解释了为什么索引寄存器没有 8 位的抽象：它们旨在用作内存地址偏移量，并且没有实际需求去了解这些值的部分字节。
- en: '**The Execution Index Register**'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行索引寄存器**'
- en: 'The Execution Index register, referred to as *EIP*, has a very concrete purpose:
    it points to the address of the code currently being executed by the processor.
    Because it controls the flow of execution, it is directly incremented by the processor
    and is off-limits to assembly code. To modify EIP, assembly code must indirectly
    access it using operations such as `CALL`, `JMP`, and `RETN`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 执行索引寄存器，简称 *EIP*，有一个非常明确的目的：它指向当前由处理器执行的代码的地址。由于它控制执行流程，因此由处理器直接递增，并且不允许汇编代码直接修改。要修改
    EIP，汇编代码必须通过间接操作来访问它，如 `CALL`、`JMP` 和 `RETN`。
- en: '**The EFLAGS Register**'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**EFLAGS 寄存器**'
- en: Unlike high-level code, assembly language doesn’t have binary comparison operators
    like `==`, `>`, and `<`. Instead, it uses the `CMP` command to compare two values,
    storing the resulting information in the EFLAGS register. Then, the code changes
    its control flow using special operations that depend on the value stored in ELFAGS.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与高级语言不同，汇编语言没有像 `==`、`>` 和 `<` 这样的二进制比较运算符。它使用 `CMP` 指令比较两个值，并将结果信息存储在 EFLAGS
    寄存器中。然后，代码通过特殊的操作根据存储在 EFLAGS 中的值改变控制流。
- en: 'While comparison commands are the only user-mode operations that can access
    EFLAGS, they use only this register’s *status* bits: 0, 2, 4, 6, 7, and 11\. Bits
    8–10 act as control flags, bits 12–14 and 16–21 act as system flags, and the remaining
    bits are reserved for the processor. [Table 4-5](ch04.xhtml#ch4tab5) shows the
    type, name, and description of each EFLAGS bit.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比较指令是唯一能够访问 EFLAGS 的用户模式操作，但它们仅使用该寄存器的*状态*位：0、2、4、6、7 和 11。位 8–10 作为控制标志，位
    12–14 和 16–21 作为系统标志，其余位为处理器保留。[表 4-5](ch04.xhtml#ch4tab5) 显示了每个 EFLAGS 位的类型、名称和描述。
- en: '**Table 4-5:** EFLAGS bits'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-5:** EFLAGS 位'
- en: '| **Bit(s)** | **Type** | **Name** | **Description** |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **位(s)** | **类型** | **名称** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | Status | Carry | Set if a carry or borrow was generated from the most
    significant bit during the previous instruction. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 状态 | 进位 | 如果前一条指令的最高有效位产生了进位或借位，则设置。 |'
- en: '| 2 | Status | Parity | Set if the least significant byte resulting from the
    previous instruction has an even number of bits set. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 状态 | 奇偶校验 | 如果前一条指令的结果值的最低有效字节有偶数个位被设置，则设置。 |'
- en: '| 4 | Status | Adjust | Same as the carry flag, but considers the 4 least significant
    bits. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 状态 | 调整 | 与进位标志相同，但考虑最低有效的 4 位。 |'
- en: '| 6 | Status | Zero | Set if the resulting value from the previous instruction
    is equal to 0. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 状态 | 零 | 如果前一条指令的结果值为0，则设置。 |'
- en: '| 7 | Status | Sign | Set if the resulting value from the previous instruction
    has its sign bit (most significant bit) set. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 状态 | 符号 | 如果前一条指令的结果值的符号位（最高有效位）被设置，则设置。 |'
- en: '| 8 | Control | Trap | When set, the processor sends an interrupt to the operating
    system kernel after executing the next operation. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 控制 | 陷阱 | 设置时，处理器在执行下一个操作后向操作系统内核发送一个中断。 |'
- en: '| 9 | Control | Interrupt | When not set, the system ignores maskable interrupts.
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 控制 | 中断 | 如果未设置，系统将忽略可屏蔽中断。 |'
- en: '| 10 | Control | Direction | When set, ESI and EDI are decremented by operations
    that automatically modify them. When not set, they are incremented. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 控制 | 方向 | 设置时，ESI 和 EDI 在自动修改的操作中被递减。未设置时，它们将被递增。 |'
- en: '| 11 | Status | Overflow | Set when a value is overflowed by the previous instruction,
    such as when ADD is performed on a positive value and the result is a negative
    value. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 状态 | 溢出 | 如果前一条指令发生了溢出，例如在对正数执行 ADD 操作后，结果为负数时，则设置。 |'
- en: The EFLAGS register also contains a system bit and a reserved bit, but those
    are irrelevant in user-mode assembly and game hacking, so I’ve omitted them from
    this table. Keep EFLAGS in mind when you’re debugging game code to figure out
    how it works. For example, if you set a breakpoint on a JE (jump if equal) instruction,
    you can look at the EFLAGS 0 bit to see whether the jump will be taken.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: EFLAGS寄存器还包含一个系统位和一个保留位，但这些在用户模式汇编和游戏破解中无关紧要，因此我将它们从本表中省略。在调试游戏代码时，记得留意EFLAGS。例如，如果你在一个JE（相等时跳转）指令上设置断点，可以查看EFLAGS
    0位，判断是否会跳转。
- en: '**Segment Registers**'
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**段寄存器**'
- en: 'Finally, assembly language has a set of 16-bit registers called *segment registers*.
    Unlike other registers, segment registers are not used to store data; they are
    used to locate it. In theory, they point to isolated segments of memory, allowing
    different types of data to be stored in completely separate memory segments. The
    implementation of such segmentation is left up to the operating system. These
    are the x86 segment registers and their intended purposes:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，汇编语言有一组16位寄存器，称为*段寄存器*。与其他寄存器不同，段寄存器不是用来存储数据的；它们用于定位数据。理论上，它们指向内存中的隔离段，使得不同类型的数据可以存储在完全独立的内存段中。这种分段的实现由操作系统来完成。这些是x86段寄存器及其预期用途：
- en: '**CS, the code segment** This register points to the memory that holds an application’s
    code.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**CS，代码段** 该寄存器指向存储应用程序代码的内存。'
- en: '**DS, the data segment** This register points to the memory that holds an application’s
    data.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**DS，数据段** 该寄存器指向存储应用程序数据的内存。'
- en: '**ES, FS, and GS, the extra segments** These registers point to any proprietary
    memory segments used by the operating system.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES、FS和GS，额外段** 这些寄存器指向操作系统使用的任何专有内存段。'
- en: '**SS, the stack segment** This register points to memory that acts as a dedicated
    call stack.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**SS，堆栈段** 该寄存器指向作为专用调用堆栈的内存。'
- en: 'In assembly code, segment registers are used as prefixes to memory offset operands.
    When a segment register isn’t specified, DS is used by default. This means that
    the command `PUSH [EBP]` is effectively the same as `PUSH DS:[EBP]`. But the command
    `PUSH FS:[EBP]` is different: it reads memory from the FS segment, not the DS
    segment.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编代码中，段寄存器作为内存偏移操作数的前缀使用。当没有指定段寄存器时，默认使用DS。这意味着`PUSH [EBP]`命令实际上与`PUSH DS:[EBP]`相同。但`PUSH
    FS:[EBP]`命令则不同：它从FS段读取内存，而不是DS段。
- en: 'If you look closely at the Windows x86 implementation of memory segmentation,
    you might notice that these segment registers were not exactly used as intended.
    To see this in action, you can run the following commands with the OllyDbg command
    line plug-in while OllyDbg is attached to a paused process:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察Windows x86的内存分段实现，可能会注意到这些段寄存器并没有按预期使用。要查看这个实际效果，你可以在OllyDbg附加到一个暂停的进程时，使用OllyDbg命令行插件运行以下命令：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This output tells us three distinct things. First, it shows that there are
    only three segments being used by Windows: FS, CS, and everything else. This is
    demonstrated by DS, SS, GS, and ES being equal. For the same reason, this output
    shows that DS, SS, GS, and ES can all be used interchangeably, as they all point
    to the same memory segments. Lastly, since FS changes depending on the thread,
    this output shows that it is thread dependent. FS is an interesting segment register,
    and it points to certain thread-specific data. In “[Bypassing ASLR in Production](ch06.xhtml#ch00lev1sec132)”
    on [page 128](ch06.xhtml#page_128), we’ll explore how the data in FS can be used
    to bypass ASLR—something most bots will need to do.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出告诉我们三个不同的事实。首先，它显示了Windows只使用了三个段：FS、CS和其他所有段。通过DS、SS、GS和ES相等的方式来证明这一点。出于同样的原因，该输出还显示DS、SS、GS和ES可以互换使用，因为它们指向相同的内存段。最后，由于FS根据线程变化，因此该输出显示它是线程依赖的。FS是一个有趣的段寄存器，它指向特定线程的数据。在《[绕过生产环境中的ASLR](ch06.xhtml#ch00lev1sec132)》一章中的[第128页](ch06.xhtml#page_128)，我们将探讨如何利用FS中的数据来绕过ASLR——这是大多数机器人需要做的事情。
- en: 'In fact, in assembly code generated for Windows by a compiler, you’d only ever
    see three segments used: DS, FS, and SS. Interestingly enough, even though CS
    seems to show a constant offset from DS, it has no real purpose in user-mode code.
    Knowing all of these things, you can further conclude that there are only two
    segments being used by Windows: FS and everything else.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在为 Windows 编译器生成的汇编代码中，你只会看到使用了三个段：DS、FS 和 SS。有趣的是，尽管 CS 似乎显示了与 DS 的常量偏移量，但它在用户模式代码中没有实际用途。了解了这些之后，你可以进一步得出结论，Windows
    实际上只使用了两个段：FS 和其他所有段。
- en: These two segments actually point to different locations in the same memory
    (there’s no simple way to verify this, but it is true), which shows that Windows
    actually doesn’t use memory segments at all. Instead, it uses a flat memory model
    in which segment registers are nearly irrelevant. While all segment registers
    point to the same memory, only FS and CS point to different locations, and CS
    is not used.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个段实际上指向相同内存中的不同位置（虽然没有简单的方法来验证这一点，但它确实是事实），这表明 Windows 实际上根本不使用内存段。相反，它使用了一个平坦的内存模型，其中段寄存器几乎是无关紧要的。虽然所有段寄存器都指向相同的内存，只有
    FS 和 CS 指向不同的位置，而 CS 并未被使用。
- en: In conclusion, there are only three things you need to know about segment registers
    when working with x86 assembly in Windows. First, DS, SS, GS, and ES are interchangeable,
    but for clarity DS should be used to access data and SS should be used to access
    the call stack. Second, CS can be safely forgotten. Third, FS is the only segment
    register with a special purpose; it should be left alone for now.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当你在 Windows 中使用 x86 汇编时，关于段寄存器有三件事是你需要了解的。首先，DS、SS、GS 和 ES 是可以互换的，但为了清晰起见，应该使用
    DS 来访问数据，使用 SS 来访问调用堆栈。第二，CS 可以安全地忽略。第三，FS 是唯一具有特殊用途的段寄存器；目前应该将其保持不变。
- en: '***The Call Stack***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用堆栈***'
- en: Registers are powerful, but unfortunately they come in very limited supply.
    In order for assembly code to effectively store all of its local data, it must
    also use the *call stack*. The stack is used to store many different values, including
    function parameters, return addresses, and some local variables.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器非常强大，但不幸的是它们的数量非常有限。为了使汇编代码有效地存储所有的局部数据，它还必须使用*调用堆栈*。堆栈用于存储许多不同的值，包括函数参数、返回地址和一些局部变量。
- en: Understanding the ins and outs of the call stack will come in handy when you’re
    reverse engineering a game. Moreover, you’ll rely on this knowledge heavily when
    we jump into control flow manipulation in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 理解调用堆栈的运作方式在反向工程游戏时会非常有用。此外，当我们进入[第 8 章](ch08.xhtml#ch08)的控制流操作时，你将会严重依赖这一知识。
- en: '**Structure**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结构**'
- en: 'You can think of the call stack as a *FILO (first-in-last-out)* list of `DWORD`
    values that can be directly accessed and manipulated by assembly code. The term
    *stack* is used because the structure resembles a stack of paper: objects are
    both added to and removed from the top. Data is added to the stack through the
    `PUSH operand` command, and it is removed (and placed in a register) through the
    `POP register` command. [Figure 4-6](ch04.xhtml#ch4fig6) shows how this process
    might look.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将调用堆栈看作一个*FILO（先进后出）*的`DWORD`值列表，这些值可以被汇编代码直接访问和操作。之所以称之为*堆栈*，是因为这种结构类似于一堆纸：物体既可以被添加到堆栈的顶部，也可以从顶部移除。数据通过`PUSH
    操作数`命令添加到堆栈，而通过`POP 寄存器`命令将其移除（并放入寄存器）。[图 4-6](ch04.xhtml#ch4fig6)显示了这一过程的示例。
- en: '![image](../images/f04-06.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-06.jpg)'
- en: '*Figure 4-6: The structure of a stack*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：堆栈的结构*'
- en: In Windows, the stack grows from higher memory addresses to lower ones. It occupies
    a finite block of memory, piling up to address 0x00000000 (the absolute top) from
    address *n* (the absolute bottom). This means that ESP (the pointer to the top
    of the stack) decreases as items are added and increases as items are removed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，堆栈从较高的内存地址增长到较低的内存地址。它占据一块有限的内存区域，从地址 *n*（绝对底部）堆积到地址 0x00000000（绝对顶部）。这意味着
    ESP（堆栈顶部的指针）随着项的添加而减少，随着项的移除而增加。
- en: '**The Stack Frame**'
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆栈帧**'
- en: When an assembly function uses the stack to store data, it references the data
    by creating a *stack frame*. It does so by storing ESP in EBP and then subtracting
    *n* bytes from ESP, effectively opening an *n*-byte gap that is *framed* between
    the registers EBP and ESP. To better understand this, first imagine that the stack
    in [Figure 4-7](ch04.xhtml#ch4fig7) is passed to a function that requires 0x0C
    bytes of local storage space.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个汇编函数使用栈存储数据时，它通过创建一个*栈帧*来引用这些数据。它通过将ESP存储在EBP中，然后从ESP中减去*n*字节，实际上打开了一个*n*字节的间隙，这个间隙被*框定*在EBP和ESP寄存器之间。为了更好地理解这一点，首先想象[图4-7](ch04.xhtml#ch4fig7)中的栈被传递给一个需要0x0C字节本地存储空间的函数。
- en: '![image](../images/f04-07.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-07.jpg)'
- en: '*Figure 4-7: Initial example stack (read from bottom to top)*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：初始示例栈（从下到上阅读）*'
- en: 'In this example, address 0x0000 is the absolute top of the stack. We have unused
    memory from addresses 0x0000 to 0xFF00 – 4, and at the time of the function call,
    0xFF00 is the top of the stack. ESP points to this address. The stack memory after
    0xFF00 is used by preceding functions in the call chain (from 0xFF04 to 0xFFFF).
    When the function is called, the first thing it does is execute the following
    assembly code, which creates a stack frame of 0x0C (12 in decimal) bytes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，地址0x0000是栈的绝对顶部。从地址0x0000到0xFF00 – 4之间有未使用的内存，函数调用时，0xFF00是栈的顶部。ESP指向这个地址。0xFF00之后的栈内存被调用链中之前的函数使用（从0xFF04到0xFFFF）。当函数被调用时，它首先执行以下汇编代码，创建一个0x0C（即12个十进制字节）的栈帧：
- en: '[PRE25]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After this code executes, the stack looks more like the one shown in [Figure
    4-8](ch04.xhtml#ch4fig8). After creating this stack, the function can work with
    the 0x0C bytes it allocated on the stack.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码执行之后，栈的状态更接近于[图4-8](ch04.xhtml#ch4fig8)所示的样子。创建完这个栈后，函数可以使用它在栈上分配的0x0C字节。
- en: 0x0000 is still the absolute top of the stack. We have unused stack memory from
    addresses 0x0000 to 0xFF00 – 20, and the memory at address 0xFF00 – 16 contains
    the final 4 bytes of local storage (referenced by `[EBP-Ch]`). This is also the
    top of the current stack frame, so ESP points here. 0xFF00 – 12 contains the middle
    4 bytes of local storage (referenced by `[EBP-8h]`), and 0xFF00 – 8 contains the
    first 4 bytes of local storage (referenced by `[EBP-4h]`). EBP points to 0xFF00
    – 4, which is the bottom of the current stack frame; this address holds the original
    value of EBP. 0xFF00 is the top of the lower stack frame, and the original ESP
    in [Figure 4-7](ch04.xhtml#ch4fig7) pointed here. Finally, you can still see the
    stack memory from preceding functions in the call chain from 0xFF04 to 0xFFFF.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 0x0000仍然是栈的绝对顶部。从地址0x0000到0xFF00 – 20之间有未使用的栈内存，而地址0xFF00 – 16处的内存包含了本地存储的最后4个字节（由`[EBP-Ch]`引用）。这也是当前栈帧的顶部，因此ESP指向此处。0xFF00
    – 12包含本地存储的中间4个字节（由`[EBP-8h]`引用），0xFF00 – 8包含本地存储的前4个字节（由`[EBP-4h]`引用）。EBP指向0xFF00
    – 4，这是当前栈帧的底部；该地址保存了EBP的原始值。0xFF00是较低栈帧的顶部，原始的ESP在[图4-7](ch04.xhtml#ch4fig7)中指向此处。最后，你仍然可以看到来自调用链中前一个函数的栈内存，从0xFF04到0xFFFF。
- en: '![image](../images/f04-08.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-08.jpg)'
- en: '*Figure 4-8: Example stack with stack frame set up (read from bottom to top)*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-8：设置好栈帧的示例栈（从下到上阅读）*'
- en: 'With the stack in this state, the function is free to use its local data as
    it pleases. If this function called another function, the new function would build
    its own stack frame using the same technique (the stack frames really stack up).
    Once a function finishes using a stack frame, however, it must restore the stack
    to its previous state. In our case, that means making the stack look like it did
    in [Figure 4-7](ch04.xhtml#ch4fig7). When the second function finishes, our first
    function cleans the stack using the following two commands:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈处于这种状态时，函数可以随意使用它的本地数据。如果这个函数调用了另一个函数，新函数将使用相同的技术构建它自己的栈帧（栈帧真的会一个个叠加）。然而，一旦一个函数完成了对栈帧的使用，它必须将栈恢复到先前的状态。在我们的例子中，这意味着栈要恢复到[图4-7](ch04.xhtml#ch4fig7)中的样子。当第二个函数完成时，第一个函数会通过以下两个命令清理栈：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But if you want to change the parameters passed to a function in a game, don’t
    look for them in that function’s stack frame. A function’s parameters are stored
    in the stack frame of the function that called it, and they’re referenced through
    `[EBP+8h]`, `[EBP+Ch]`, and so on. They start at `[EBP+8h]` because `[EBP+4h]`
    stores the function’s return address. (“[Function Calls](ch04.xhtml#ch00lev1sec98)”
    on [page 94](ch04.xhtml#page_94) explains this topic further.)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要修改传递给游戏中某个函数的参数，不要在该函数的栈帧中寻找它们。一个函数的参数存储在调用它的函数的栈帧中，并通过`[EBP+8h]`、`[EBP+Ch]`等进行引用。它们从`[EBP+8h]`开始，因为`[EBP+4h]`存储着函数的返回地址。（“[函数调用](ch04.xhtml#ch00lev1sec98)”在[第94页](ch04.xhtml#page_94)对这个主题进行了进一步的解释。）
- en: '**NOTE**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Code can be compiled with stack frames disabled. When this is the case, you’ll
    notice that functions don’t open with `PUSH EBP` and instead reference everything
    relative to ESP. More often than not, though, stack frames are enabled in compiled
    game code.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码可以在禁用栈帧的情况下编译。当这种情况发生时，你会注意到函数不会以`PUSH EBP`开头，而是相对于ESP引用所有内容。然而，通常情况下，编译后的游戏代码是启用了栈帧的。*'
- en: Now that you have a grasp on the fundamentals of assembly code, let’s explore
    some specifics that will come in handy when hacking games.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了汇编代码的基础知识，接下来让我们探讨一些在破解游戏时会用到的具体技巧。
- en: '***Important x86 Instructions for Game Hacking***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏破解的关键x86指令***'
- en: While assembly language has hundreds of instructions, many well-equipped game
    hackers understand only a small subset of them, which I cover in detail here.
    This subset typically encapsulates all instructions that are used to modify data,
    call functions, compare values, or jump around within code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管汇编语言有数百条指令，许多经验丰富的游戏黑客只了解其中的一小部分，而这些指令是我在这里详细讲解的。这些指令通常包括所有用于修改数据、调用函数、比较值或在代码中跳转的指令。
- en: '**Data Modification**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数据修改**'
- en: 'Data modification often happens over several assembly operations, but the end
    result has to be stored either in memory or in a register, typically with the
    `MOV` instruction. The `MOV` operation takes two operands: a destination and a
    source. [Table 4-6](ch04.xhtml#ch4tab6) shows all possible sets of `MOV` operands
    and the results you can expect from those calls.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 数据修改通常会经过多个汇编操作，但最终结果必须存储在内存或寄存器中，通常通过`MOV`指令来完成。`MOV`操作接受两个操作数：目标和源。[表4-6](ch04.xhtml#ch4tab6)展示了所有可能的`MOV`操作数组合以及你可以期待的结果。
- en: '**Table 4-6:** Operands to the `MOV` Instruction'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-6：** `MOV`指令的操作数'
- en: '| **Instruction syntax** | **Result** |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **指令语法** | **结果** |'
- en: '| --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MOV R1, R2` | Copies `R2`’s value to `R1`. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `MOV R1, R2` | 将`R2`的值复制到`R1`。 |'
- en: '| `MOV R1, [R2]` | Copies the value from the memory referenced by `R2` to `R1`.
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `MOV R1, [R2]` | 将`R2`引用的内存中的值复制到`R1`。 |'
- en: '| `MOV R1, [R2+Ah]` | Copies the value from the memory referenced by `R2+0xA`
    to `R1`. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `MOV R1, [R2+Ah]` | 将`R2+0xA`引用的内存中的值复制到`R1`。 |'
- en: '| `MOV R1, [DEADBEEFh]` | Copies the value from the memory at 0xDEADBEEF to
    `R1`. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `MOV R1, [DEADBEEFh]` | 将内存地址0xDEADBEEF中的值复制到`R1`。 |'
- en: '| `MOV R1, BADF00Dh` | Copies the value 0xBADF00D to `R1`. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `MOV R1, BADF00Dh` | 将值0xBADF00D复制到`R1`。 |'
- en: '| `MOV [R1], R2` | Copies `R2`’s value to the memory referenced by `R1`. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `MOV [R1], R2` | 将`R2`的值复制到`R1`引用的内存中。 |'
- en: '| `MOV [R1], BADF00Dh` | Copies the value 0xBADF00D to the memory referenced
    by `R1`. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `MOV [R1], BADF00Dh` | 将值0xBADF00D复制到`R1`引用的内存中。 |'
- en: '| `MOV [R1+4h], R2` | Copies `R2`’s value to the memory referenced by `R1+0x4`.
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `MOV [R1+4h], R2` | 将`R2`的值复制到`R1+0x4`引用的内存中。 |'
- en: '| `MOV [R1+4h], BADF00Dh` | Copies the value 0xBADF00D to the memory referenced
    by `R1+0x4`. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `MOV [R1+4h], BADF00Dh` | 将值0xBADF00D复制到`R1+0x4`引用的内存中。 |'
- en: '| `MOV [DEADBEEFh], R1` | Copies `R1`’s value to the memory at 0xDEADBEEF.
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `MOV [DEADBEEFh], R1` | 将`R1`的值复制到内存地址0xDEADBEEF。 |'
- en: '| `MOV [DEADBEEFh], BADF00Dh` | Copies the value 0xBADF00D to the memory at
    0xDEADBEEF. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `MOV [DEADBEEFh], BADF00Dh` | 将值0xBADF00D复制到内存地址0xDEADBEEF。 |'
- en: 'The `MOV` instruction can take a lot of operand combinations, but some aren’t
    allowed. First, the destination operand can’t be an immediate value; it must be
    a register or memory address, because immediate values can’t be modified. Second,
    values can’t be directly copied from one memory address to another. Copying a
    value requires two separate operations, like so:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOV`指令可以接受多种操作数组合，但并不是所有组合都被允许。首先，目标操作数不能是立即数；它必须是寄存器或内存地址，因为立即数无法被修改。其次，不能直接将一个内存地址的值复制到另一个内存地址。复制值需要两个独立的操作，如下所示：'
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These instructions copy whatever is stored at EBP+0x10 to the memory at 0xDEADBEEF.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将 EBP+0x10 处存储的内容复制到 0xDEADBEEF 处的内存中。
- en: '**Arithmetic**'
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**算术**'
- en: 'Like many high-level languages, assembly language has two types of arithmetic:
    unary and binary. Unary instructions take a single operand that acts as both a
    destination and a source. This operand can be a register or a memory address.
    [Table 4-7](ch04.xhtml#ch4tab7) shows the common unary arithmetic instructions
    in x86.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多高级语言一样，汇编语言也有两种算术类型：一元和二元。一元指令接受一个操作数，该操作数同时充当目标和源。这个操作数可以是一个寄存器或一个内存地址。[表
    4-7](ch04.xhtml#ch4tab7) 显示了 x86 中常见的一元算术指令。
- en: '**Table 4-7:** Unary Arithmetic Instructions'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-7:** 一元算术指令'
- en: '| **Instruction syntax** | **Result** |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **指令语法** | **结果** |'
- en: '| --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `INC operand` | Adds 1 to the operand value. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `INC 操作数` | 将 1 加到操作数值上。 |'
- en: '| `DEC operand` | Subtracts 1 from the operand value. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `DEC 操作数` | 从操作数值中减去 1。 |'
- en: '| `NOT operand` | Logically negates the operand value (flips all bits). |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `NOT 操作数` | 逻辑上取反操作数的值（翻转所有位）。 |'
- en: '| `NEG operand` | Performs two’s-complement negation (flips all bits and adds
    1; essentially multiplies by -1). |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `NEG 操作数` | 执行二进制补码取反（翻转所有位并加 1；实质上是乘以 -1）。 |'
- en: 'Binary instructions (which make up the majority of x86 arithmetic), on the
    other hand, are syntactically similar to the `MOV` instruction. They require two
    operands and have similar operand limitations. Unlike `MOV`, however, their destination
    operand serves a second purpose: it is also the left-hand value in the calculation.
    For example, the assembly operation `ADD EAX,EBX` equates to `EAX = EAX + EBX`
    or `EAX += EBX` in C++. [Table 4-8](ch04.xhtml#ch4tab8) shows the common x86 binary
    arithmetic instructions.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，二元指令（占据了大多数 x86 算术指令）在语法上与 `MOV` 指令类似。它们需要两个操作数，并且具有相似的操作数限制。然而，与 `MOV`
    不同的是，它们的目标操作数有第二个作用：它也是计算中的左值。例如，汇编操作 `ADD EAX,EBX` 等同于 C++ 中的 `EAX = EAX + EBX`
    或 `EAX += EBX`。[表 4-8](ch04.xhtml#ch4tab8) 显示了常见的 x86 二元算术指令。
- en: '**Table 4-8:** Binary Arithmetic Instructions'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-8:** 二元算术指令'
- en: '| **Instruction syntax** | **Function** | **Operand notes** |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **指令语法** | **功能** | **操作数说明** |'
- en: '| --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ADD destination`, source | `destination` += source |  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `ADD 目标`, 源 | `目标` += 源 |  |'
- en: '| `SUB destination`, source | `destination` -= source |  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `SUB 目标`, 源 | `目标` -= 源 |  |'
- en: '| `AND destination`, source | `destination` &= source |  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `AND 目标`, 源 | `目标` &= 源 |  |'
- en: '| `OR destination`, source | `destination` &#124;= source |  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `OR 目标`, 源 | `目标` &#124;= 源 |  |'
- en: '| `XOR destination`, source | `destination` ^= source |  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `XOR 目标`, 源 | `目标` ^= 源 |  |'
- en: '| `SHL destination`, source | `destination` = destination << source | `source`
    must be CL or an 8-bit immediate value. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `SHL 目标`, 源 | `目标` = 目标 << 源 | `源` 必须是 CL 或 8 位立即数。 |'
- en: '| `SHR destination`, source | `destination` = destination >> source | `source`
    must be CL or an 8-bit immediate value. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `SHR 目标`, 源 | `目标` = 目标 >> 源 | `源` 必须是 CL 或 8 位立即数。 |'
- en: '| `IMUL destination`, source | `destination` *= source | `destination` must
    be a register; source cannot be an immediate value. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `IMUL 目标`, 源 | `目标` *= 源 | `目标` 必须是一个寄存器；源不能是立即数。 |'
- en: Of these arithmetic instructions, `IMUL` is special because you can pass it
    a third operand, in the form of an immediate value. With this prototype, the destination
    operand is no longer involved in the calculation, which instead takes place between
    the remaining operands. For example, the assembly command `IMUL EAX,EBX,4h` equates
    to `EAX = EBX * 0x4` in C++.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些算术指令中，`IMUL` 是特别的，因为你可以传递一个第三个操作数，作为立即数的形式。通过这个原型，目标操作数不再参与计算，计算改由剩余的操作数进行。例如，汇编命令
    `IMUL EAX,EBX,4h` 等价于 C++ 中的 `EAX = EBX * 0x4`。
- en: You can also pass a single operand to `IMUL`.^([3](footnote.xhtml#ch00fn03))
    In this case, the operand acts as the source and can be either a memory address
    or a register. Depending on the size of the source operand, the instruction will
    use different parts of the EAX register for inputs and output, as shown in [Table
    4-9](ch04.xhtml#ch4tab9).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向 `IMUL` 传递一个单一的操作数。^([3](footnote.xhtml#ch00fn03)) 在这种情况下，操作数充当源，可以是一个内存地址或一个寄存器。根据源操作数的大小，该指令会使用
    EAX 寄存器的不同部分作为输入和输出，如 [表 4-9](ch04.xhtml#ch4tab9) 所示。
- en: '**Table 4-9:** Possible `IMUL` Register Operands'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-9:** 可用的 `IMUL` 寄存器操作数'
- en: '| **Source size** | **Input** | **Output** |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **源大小** | **输入** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8 bits | AL | 16 bit, stored in AH:AL (which is AX) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 8 位 | AL | 16 位，存储在 AH:AL（即 AX）中 |'
- en: '| 16 bits | AX | 32 bit, stored in DX:AX (bits 0–15 in AX and bits 16–31 in
    DX) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 16 位 | AX | 32 位，存储在 DX:AX 中（AX中的第0-15位和DX中的第16-31位） |'
- en: '| 32 bits | EAX | 64 bit, stored in EDX:EAX (bits 0–31 in EAX and bits 32–64
    in EDX) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 32 位 | EAX | 64 位，存储在 EDX:EAX 中（EAX中的第0-31位和EDX中的第32-64位） |'
- en: Notice that even though the input is only one register, each output uses two
    registers. That’s because in multiplication, the result generally is larger than
    the inputs.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使输入只有一个寄存器，每个输出也使用了两个寄存器。这是因为在乘法运算中，结果通常会大于输入。
- en: 'Let’s look at an example calculation using `IMUL` with a single 32-bit operand:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用`IMUL`并带有单个32位操作数的计算示例：
- en: '[PRE28]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command behaves like the following pseudocode:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令的行为类似于以下伪代码：
- en: '[PRE29]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, here’s an operation that uses `IMUL` with a single 16-bit operand:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里是一个使用`IMUL`并带有单个16位操作数的操作：
- en: '[PRE30]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And its corresponding pseudocode:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 及其对应的伪代码：
- en: '[PRE31]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, this is an `IMUL` command with a single 8-bit operand:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个带有单个8位操作数的`IMUL`指令：
- en: '[PRE32]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And its corresponding pseudocode:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 及其对应的伪代码：
- en: '[PRE33]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: x86 assembly language has division as well, through the `IDIV` instruction.^([4](footnote.xhtml#ch00fn04))
    The `IDIV` instruction accepts a single source operand and follows register rules
    similar to those for `IMUL`. As [Table 4-10](ch04.xhtml#ch4tab10) shows, `IDIV`
    operations require two inputs and two outputs.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: x86汇编语言也有除法，通过`IDIV`指令实现。^([4](footnote.xhtml#ch00fn04)) `IDIV`指令接受一个单一的源操作数，并遵循类似于`IMUL`的寄存器规则。如[表4-10](ch04.xhtml#ch4tab10)所示，`IDIV`操作需要两个输入和两个输出。
- en: '**Table 4-10:** Possible `IDIV` Register Operands'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-10:** 可能的`IDIV`寄存器操作数'
- en: '| **Source size** | **Input** | **Output** |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **源大小** | **输入** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8 bit | 16 bit, stored in AH:AL (which is AX) | Remainder in AH; quotient
    in AL |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 8 位 | 16 位，存储在 AH:AL（即 AX）中 | 余数存储在 AH；商存储在 AL |'
- en: '| 16 bit | 32 bit, stored in DX:AX | Remainder in DX; quotient in AX |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 16 位 | 32 位，存储在 DX:AX 中 | 余数存储在 DX；商存储在 AX |'
- en: '| 32 bit | 64 bit, stored in EDX:EAX | Remainder in EDX; quotient in EAX |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 32 位 | 64 位，存储在 EDX:EAX 中 | 余数存储在 EDX；商存储在 EAX |'
- en: 'In division, the inputs are generally larger than the output, so here the inputs
    take two registers. Moreover, division operations must store a remainder, which
    gets stored in the first input register. For example, here’s how a 32-bit `IDIV`
    calculation would look:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在除法中，输入通常比输出大，因此这里的输入使用了两个寄存器。此外，除法操作必须存储余数，这个余数会被存储在第一个输入寄存器中。例如，下面是一个32位`IDIV`计算的样子：
- en: '[PRE34]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And here’s some pseudocode that expresses what happens under the hood:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些伪代码，表达了背后的实际操作：
- en: '[PRE35]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These details of `IDIV` and `IMUL` are important to remember, as the behavior
    can otherwise be quite obfuscated when you’re simply looking at the commands.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`IDIV`和`IMUL`的细节很重要，因为如果仅仅看指令，行为可能会变得相当晦涩。
- en: '**Branching**'
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分支**'
- en: After evaluating an expression, programs can decide what to execute next based
    on the result, typically using constructs such as `if()` statements or `switch()`
    statements. These control flow statements don’t exist at the assembly level, however.
    Instead, assembly code uses the EFLAGS register to make decisions and jump operations
    to execute different blocks; this process is called *branching*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估完一个表达式后，程序可以根据结果决定接下来执行什么，通常使用诸如`if()`语句或`switch()`语句等结构。然而，这些控制流语句在汇编级别并不存在。相反，汇编代码使用EFLAGS寄存器来做决策，并通过跳转操作来执行不同的代码块；这一过程称为*分支*。
- en: 'To get the proper value in EFLAGS, assembly code uses one of two instructions:
    `TEST` or `CMP`. Both compare two operands, set the status bits of EFLAGS, and
    then discard any results. `TEST` compares the operands using a logical AND, while
    `CMP` uses signed subtraction to subtract the latter operand from the former.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得正确的EFLAGS值，汇编代码使用以下两条指令之一：`TEST`或`CMP`。这两者都会比较两个操作数，设置EFLAGS的状态位，然后丢弃任何结果。`TEST`通过逻辑与运算来比较操作数，而`CMP`则通过有符号减法将后一个操作数从前一个操作数中减去。
- en: In order to branch properly, the code has a jump command immediately following
    the comparison. Each type of jump instruction accepts a single operand that specifies
    the address of the code to jump to. How a particular jump instruction behaves
    depends on the status bits of EFLAGS. [Table 4-11](ch04.xhtml#ch4tab11) describes
    some x86 jump instructions.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地进行分支，代码在比较操作后会紧接着有一个跳转指令。每种跳转指令接受一个操作数，该操作数指定要跳转到的代码地址。特定跳转指令的行为取决于EFLAGS的状态位。[表4-11](ch04.xhtml#ch4tab11)描述了一些x86跳转指令。
- en: '**Table 4-11:** Common x86 Jump Instructions'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-11：** 常见的x86跳转指令'
- en: '| **Instruction** | **Name** | **Behavior** |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **名称** | **行为** |'
- en: '| --- | --- | --- |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `JMP dest` | Unconditional jump | Jumps to `dest` (sets `EIP` to `dest`).
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `JMP dest` | 无条件跳转 | 跳转到`dest`（将`EIP`设置为`dest`）。 |'
- en: '| `JE dest` | Jump if equal | Jumps if `ZF` (zero flag) is 1. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `JE dest` | 等于跳转 | 当`ZF`（零标志）为1时跳转。 |'
- en: '| `JNE dest` | Jump if not equal | Jumps if `ZF` is 0. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `JNE dest` | 不等跳转 | 当`ZF`为0时跳转。 |'
- en: '| `JG dest` | Jump if greater | Jumps if `ZF` is 0 and `SF` (sign flag) is
    equal to `OF` (overflow flag). |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `JG dest` | 大于跳转 | 当`ZF`为0且`SF`（符号标志）等于`OF`（溢出标志）时跳转。 |'
- en: '| `JGE dest` | Jump if greater or equal | Jumps if `SF` is equal to `OF`. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `JGE dest` | 大于或等于跳转 | 当`SF`等于`OF`时跳转。 |'
- en: '| `JA dest` | Unsigned `JG` | Jumps if `CF` (carry flag) is 0 and `ZF` is 0.
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `JA dest` | 无符号`JG` | 当`CF`（进位标志）为0且`ZF`为0时跳转。 |'
- en: '| `JAE dest` | Unsigned `JGE` | Jumps if `CF` is 0. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `JAE dest` | 无符号`JGE` | 当`CF`为0时跳转。 |'
- en: '| `JL dest` | Jump if less | Jumps if `SF` is not equal to `OF`. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `JL dest` | 小于跳转 | 当`SF`不等于`OF`时跳转。 |'
- en: '| `JLE dest` | Jump if less or equal | Jumps if `ZF` is 1 or `SF` is not equal
    to `OF`. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `JLE dest` | 小于或等于跳转 | 当`ZF`为1或`SF`不等于`OF`时跳转。 |'
- en: '| `JB dest` | Unsigned `JL` | Jumps if `CF` is 1. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `JB dest` | 无符号`JL` | 当`CF`为1时跳转。 |'
- en: '| `JBE dest` | Unsigned `JLE` | Jumps if `CF` is 1 or `ZF` is 1. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `JBE dest` | 无符号`JLE` | 当`CF`为1或`ZF`为1时跳转。 |'
- en: '| `JO dest` | Jump if overflow | Jumps if `OF` is 1. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `JO dest` | 溢出跳转 | 当`OF`为1时跳转。 |'
- en: '| `JNO dest` | Jump if not overflow | Jumps if `OF` is 0. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `JNO dest` | 非溢出跳转 | 当`OF`为0时跳转。 |'
- en: '| `JZ dest` | Jump if zero | Jumps if `ZF` is 1 (identical to `JE`). |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `JZ dest` | 零跳转 | 当`ZF`为1时跳转（与`JE`相同）。 |'
- en: '| `JNZ dest` | Jump if not zero | Jumps if `ZF` is 0 (identical to `JNE`).
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `JNZ dest` | 非零跳转 | 当`ZF`为0时跳转（与`JNE`相同）。 |'
- en: Remembering which flags control which jump instructions can be a pain, but their
    purpose is clearly expressed in their name. A good rule of thumb is that a jump
    preceded by a `CMP` is the same as its corresponding operator. For example, [Table
    4-11](ch04.xhtml#ch4tab11) lists `JE` as “jump if equal,” so when `JE` follows
    a `CMP` operation, it’s the same as the `==` operator. Similarly, `JGE` would
    be `>=`, `JLE` would be `>=`, and so on.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 记住哪些标志控制哪些跳转指令可能很麻烦，但它们的用途通过指令名称已清楚表达。一个好的经验法则是，前面有`CMP`指令的跳转与相应的操作符相同。例如，[表
    4-11](ch04.xhtml#ch4tab11)列出了`JE`为“等于跳转”，因此当`JE`紧跟`CMP`操作时，它与`==`操作符相同。同样，`JGE`对应于`>=`，`JLE`也对应于`>=`，以此类推。
- en: As an example, consider the high-level code shown in [Listing 4-8](ch04.xhtml#ch4exe8).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑在[示例 4-8](ch04.xhtml#ch4exe8)中显示的高级代码。
- en: '[PRE36]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 4-8: A simple conditional statement*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-8：一个简单的条件语句*'
- en: 'This `if()` statement just checks whether `EBX` is greater than `EAX` and sets
    `ECX` based on the result. In assembly, the same statement may look something
    like this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if()`语句只是检查`EBX`是否大于`EAX`，并根据结果设置`ECX`。在汇编语言中，相同的语句可能如下所示：
- en: '[PRE37]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The assembly for the `if()` statement in [Listing 4-8](ch04.xhtml#ch4exe8) begins
    with a `CMP` instruction and branches if `EBX` is greater than `EAX`. If the branch
    is taken, `EIP` is set to the `if` block at ➊ courtesy of the `JG` instruction.
    If the branch is not taken, the code continues executing linearly and hits the
    `else` block immediately after the `JG` instruction. When the `else` block finishes
    executing, an unconditional `JMP` sets `EIP` to `0x7`, skipping over the `if`
    block.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-8](ch04.xhtml#ch4exe8)中的`if()`语句的汇编代码以`CMP`指令开始，并在`EBX`大于`EAX`时进行分支。如果分支被执行，`EIP`会被设置为`if`块中的位置
    ➊，这是通过`JG`指令实现的。如果分支没有被执行，代码将继续按线性顺序执行，并立即跳到`JG`指令后面的`else`块。当`else`块执行完毕后，一个无条件的`JMP`指令将`EIP`设置为`0x7`，跳过`if`块。
- en: '**Function Calls**'
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**函数调用**'
- en: 'In assembly code, functions are isolated blocks of commands executed through
    the `CALL` instruction. The `CALL` instruction, which takes a function address
    as the only operand, pushes a return address onto the stack and sets EIP to its
    operand value. The following pseudocode shows a `CALL` in action, with memory
    addresses on the left in hex:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编代码中，函数是通过`CALL`指令执行的独立命令块。`CALL`指令只接受一个函数地址作为操作数，推送返回地址到栈中，并将`EIP`设置为其操作数值。以下伪代码展示了`CALL`的执行过程，左侧是内存地址的十六进制表示：
- en: '[PRE38]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When `CALL EAX` is executed, the next address is pushed to the stack and `EIP`
    is set to `EAX`, showing that `CALL` is essentially a `PUSH` and `JMP`. The following
    pseudocode underscores this point:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`CALL EAX`时，下一地址被推送到栈中，`EIP`被设置为`EAX`，这表明`CALL`本质上是一个`PUSH`和`JMP`操作。以下伪代码强调了这一点：
- en: '[PRE39]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While there’s an extra address between the `PUSH` instruction and the code
    to execute, the result is the same: before the block of code at `EAX` is executed,
    the address of the code that follows the branch is pushed to the stack. This happens
    so the *callee* (the function being called) knows where to jump to in the *caller*
    (the function doing the call) when it returns.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function without parameters is called, a `CALL` command is all that’s
    necessary. If the callee takes parameters, however, the parameters must first
    be pushed onto the stack in reverse order. The following pseudocode shows how
    a function call with three parameters might look:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the callee is executed, the top of the stack contains a return address
    that points to the code after the call. The first parameter, `0x100`, is below
    the return address on the stack. The second parameter, `0x200`, is below that,
    followed by the third parameter, `0x300`. The callee sets up its stack frame,
    using memory offsets from `EBP` to reference each parameter. Once the callee has
    finished executing, it restores the caller’s stack frame and executes the `RET`
    instruction, which pops the return address off the stack and jumps to it.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Since the parameters are not a part of the callee’s stack frame, they remain
    on the stack after `RET` is executed. If the caller is responsible for cleaning
    the stack, it adds 12 (3 parameters, at 4 bytes each) to ESP immediately after
    `CALL ECX` completes. If the callee is responsible, it cleans up by executing
    `RET 12` instead of `RET`. This responsibility is determined by the callee’s *calling
    convention*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: A function’s calling convention tells the compiler how the assembly code should
    pass parameters, store instance pointers, communicate the return value, and clean
    the stack. Different compilers have different calling conventions, but the ones
    listed in [Table 4-12](ch04.xhtml#ch4tab12) are the only four that a game hacker
    is likely to encounter.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-12:** Calling Conventions to Know for Game Hacking'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive** | **Cleaner** | **Notes** |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| `__cdecl` | caller | Default convention in Visual Studio. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| `__stdcall` | callee | Convention used by Win32 API functions. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| `__fastcall` | callee | First two `DWORD` (or smaller) parameters are passed
    in ECX and EDX. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| `__thiscall` | callee | Used for member functions. The pointer to the class
    instance is passed in ECX. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: The Directive column in [Table 4-12](ch04.xhtml#ch4tab12) gives the name of
    the calling convention, and the Cleaner column tells you whether the caller or
    callee is responsible for cleaning the stack given that directive. In the case
    of these four calling conventions, parameters are always pushed right to left,
    and return values are always stored in EAX. This is a standard, but not a rule;
    it can differ across other calling conventions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My goal in writing this chapter was to help you understand memory and assembly
    in a general sense, before we dig into game-hacking specifics. With your newfound
    ability to think like a computer, you should be adequately armed to start tackling
    more advanced memory forensics tasks. If you’re itching for a peek at how you’ll
    apply all of this to something real, flip to “[Applying Call Hooks to Adobe AIR](ch08.xhtml#ch00lev1sec169)”
    on [page 169](ch08.xhtml#page_169) or “[Applying Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)”
    on [page 175](ch08.xhtml#page_175).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这章的目的是帮助你在深入游戏破解的具体内容之前，先大致了解内存和汇编。通过你刚刚获得的像计算机一样思考的能力，你应该已经具备了足够的能力，开始应对更高级的内存取证任务。如果你迫不及待想要看看如何将这些知识应用到实际中，可以翻到“[将调用钩子应用于Adobe
    AIR](ch08.xhtml#ch00lev1sec169)”[第169页](ch08.xhtml#page_169)或“[将跳转钩子和VF钩子应用于Direct3D](ch08.xhtml#ch00lev1sec174)”[第175页](ch08.xhtml#page_175)。
- en: If you want some hands-on time with memory, compile this chapter’s example code
    and use Cheat Engine or OllyDbg to inspect, tweak, and poke at the memory until
    you’ve got the hang of it. This is important, as the next chapter will build on
    these skills by teaching you advanced memory forensic techniques.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想亲自动手操作内存，可以编译本章的示例代码，使用Cheat Engine或OllyDbg来检查、调整并调试内存，直到你掌握了技巧。这非常重要，因为下一章将通过教授你更高级的内存取证技术，来建立在这些技能之上。
