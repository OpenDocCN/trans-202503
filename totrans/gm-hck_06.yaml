- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FROM CODE TO MEMORY: A GENERAL PRIMER**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the lowest level, a game’s code, data, input, and output are complex abstractions
    of erratically changing bytes. Many of these bytes represent variables or machine
    code generated by a compiler that was fed the game’s source code. Some represent
    images, models, and sounds. Others exist only for an instant, posted by the computer’s
    hardware as input and destroyed when the game finishes processing them. The bytes
    that remain inform the player of the game’s internal state. But humans can’t think
    in bytes, so the computer must translate them in a way we can understand.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a huge disconnect in the opposite direction as well. A computer doesn’t
    actually understand high-level code and visceral game content, so these must be
    translated from the abstract into bytes. Some content—such as images, sounds,
    and text—is stored losslessly, ready to be presented to the player at a microsecond’s
    notice. A game’s code, logic, and variables, on the other hand, are stripped of
    all human readability and compiled down to machine data.
  prefs: []
  type: TYPE_NORMAL
- en: By manipulating a game’s data, game hackers obtain humanly improbable advantages
    within the game. To do this, however, they must understand how a developer’s code
    manifests once it has been compiled and executed. Essentially, they must think
    like computers.
  prefs: []
  type: TYPE_NORMAL
- en: To get you thinking like a computer, this chapter will begin by teaching you
    how numbers, text, simple structures, and unions are represented in memory at
    the byte level. Then you’ll dive deeper to explore how class instances are stored
    in memory and how abstract instances know which virtual functions to call at runtime.
    In the last half of the chapter, you’ll take an x86 assembly language crash course
    that covers syntax, registers, operands, the call stack, arithmetic operations,
    branching operations, function calls, and calling conventions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses very heavily on general technical details. There isn’t
    a lot of juicy information that immediately relates to hacking games, but the
    knowledge you gain here will be central in the coming chapters, when we talk about
    topics like programmatically reading and writing memory, injecting code, and manipulating
    control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Since C++ is the de facto standard for both game and bot development, this chapter
    explains the relationships between C++ code and the memory that represents it.
    Most native languages have very similar (sometimes identical) low-level structure
    and behavior, however, so you should be able to apply what you learn here to just
    about any piece of software.
  prefs: []
  type: TYPE_NORMAL
- en: All of the example code in this chapter is in the *GameHackingExamples/Chapter4_CodeToMemory*
    directory of this book’s source files. The included projects can be compiled with
    Visual Studio 2010 but should also work with any other C++ compiler. Download
    them at *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    and compile them if you want to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Variables and Other Data Manifest in Memory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properly manipulating a game’s state can be very hard, and finding the data
    that controls it is not always as easy as clicking Next Scan and hoping Cheat
    Engine won’t fail you. In fact, many hacks must manipulate dozens of related values
    at once. Finding these values and their relationships often requires you to analytically
    identify structures and patterns. Moreover, developing game hacks typically means
    re-creating the original structures within your bot’s code.
  prefs: []
  type: TYPE_NORMAL
- en: To do these things, you need an in-depth understanding of exactly how variables
    and data are laid out in the game’s memory. Through example code, OllyDbg memory
    dumps, and some tables to tie everything together, this section will teach you
    everything there is to know about how different types of data manifest in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Numeric Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most of the values game hackers need (like the player’s health, mana, location,
    and level) are represented by numeric data types. Because numeric data types are
    also a building block for all other data types, understanding them is extremely
    important. Luckily, they have relatively straightforward representations in memory:
    they are predictably aligned and have a fixed bit width. [Table 4-1](ch04.xhtml#ch4tab1)
    shows the five main numeric data types you’ll find in Windows games, along with
    their sizes and ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Numeric Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type name(s)** | **Size** | **Signed range** | **Unsigned range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `char`, `BYTE` | 8 bits | -128 to 127 | 0 to 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `short`, `WORD`, `wchar_t` | 16 bits | -32,768 to -32,767 | 0 to 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| `int`, `long`, `DWORD` | 32 bits | -2,147,483,648 to 2,147,483,647 | 0 to
    4,294,967,295 |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | 64 bits | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    | 0 to 18,446,744,073,709,551,615 |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 32 bits | +/-1.17549*10^(-38) to +/-3.40282*10^(38) | N/A |'
  prefs: []
  type: TYPE_TB
- en: The sizes of numeric data types can differ between architectures and even compilers.
    Since this book focuses on hacking x86 games on Windows, I’m using type names
    and sizes made standard by Microsoft. With the exception of `float`, the data
    types in [Table 4-1](ch04.xhtml#ch4tab1) are stored with *little-endian ordering*,
    meaning the least significant bytes of an integer are stored in the lowest addresses
    occupied by that integer. For example, [Figure 4-1](ch04.xhtml#ch4fig1) shows
    that `DWORD` 0x0A0B0C0D is represented by the bytes 0x0D 0x0C 0x0B 0x0A.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Little-endian ordering diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `float` data type can hold mixed numbers, so its representation in memory
    isn’t as simple as that of other data types. For example, if you see 0x0D 0x0C
    0x0B 0x0A in memory and that value is a `float`, you can’t simply convert it to
    0x0A0B0C0D. Instead, `float` values have three components: the *sign* (bit 0),
    *exponent* (bits 1–8), and *mantissa* (bits 9–31).'
  prefs: []
  type: TYPE_NORMAL
- en: The sign determines whether the number is negative or positive, the exponent
    determines how many places to move the decimal point (starting before the mantissa),
    and the mantissa holds an approximation of the value. You can retrieve the stored
    value by evaluating the expression *mantissa* × 10^(*n*) (where *n* is the exponent)
    and multiplying the result by –1 if the sign is set.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at some numeric data types in memory. [Listing 4-1](ch04.xhtml#ch4exe1)
    initializes nine variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Creating variables of numeric data types in C++*'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the top, this example includes variables of types `char`, `short`,
    `int`, `long long`, and `float`. Four of these are unsigned, and five are signed.
    (In C++, a `float` can’t be unsigned.) Taking into account what you’ve learned
    so far, carefully study the relationship between the code in [Listing 4-1](ch04.xhtml#ch4exe1)
    and the memory dump in [Figure 4-2](ch04.xhtml#ch4fig2). Assume that the variables
    are declared in global scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: OllyDbg memory dump of our numeric data*'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that some values seem arbitrarily spaced out. Since it’s much
    faster for processors to access values residing at addresses that are multiples
    of the address size (which is 32 bits in x86), compilers *pad* values with zeros
    in order to align them on such addresses—hence, padding is also called *alignment*.
    Single-byte values are not padded, since operations that access them perform the
    same regardless of alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind, take a look at [Table 4-2](ch04.xhtml#ch4tab2), which
    provides a sort of memory-to-code crosswalk between the memory dump in [Figure
    4-2](ch04.xhtml#ch4fig2) and the variables declared in [Listing 4-1](ch04.xhtml#ch4exe1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** Memory-to-Code Crosswalk for [Listing 4-1](ch04.xhtml#ch4exe1)
    and [Figure 4-2](ch04.xhtml#ch4fig2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Size** | **Data** | **Object** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3018 | 1 byte | 0xFF | `ubyteValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3019 | 1 byte | 0xFE | `byteValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB301A | 2 bytes | 0x00 0x00 | Padding before `uwordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB301C | 2 bytes | 0x42 0x41 | `uwordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB301E | 2 bytes | 0x00 0x00 | Padding before `wordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3020 | 2 bytes | 0x44 0x43 | `wordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3022 | 2 bytes | 0x00 0x00 | Padding before `udwordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3024 | 4 bytes | 0xEF 0xBE 0xAD 0xDE | `udwordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3028 | 4 bytes | 0xEF 0xBE 0xAD 0xDE | `dwordValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB302C | 4 bytes | 0x76 0x37 0xA7 0x44 | `floatValue` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3030 | 8 bytes | 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF | `ulongLongValue`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x00BB3038 | 8 bytes | 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF | `LongLongValue`
    |'
  prefs: []
  type: TYPE_TB
- en: The Address column lists locations in memory, and the Data column tells you
    exactly what’s stored there. The Object column tells you which variable from [Listing
    4-1](ch04.xhtml#ch4exe1) each piece of data relates to. Notice that `floatValue`
    is placed before `ulongLongValue` in memory, even though it’s the last variable
    declared in [Listing 4-1](ch04.xhtml#ch4exe1). Because these variables are declared
    in global scope, the compiler can place them wherever it wants. This particular
    move is likely a result of either alignment or optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '***String Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most developers use the term *string* as if it’s synonymous with *text*, but
    text is only the most common use for strings. At a low level, strings are just
    arrays of arbitrary numeric objects that appear linear and unaligned in memory.
    [Listing 4-2](ch04.xhtml#ch4exe2) shows four text string declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: Declaring several strings in C++*'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of text, strings hold character objects (`char` for 8-bit encoding
    or `wchar_t` for 16-bit encoding), and the end of each string is specified by
    a *null terminator*, a character equal to 0x0\. Let’s look at the memory where
    these variables are stored, as shown in the two memory dumps in [Figure 4-3](ch04.xhtml#ch4fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: In this OllyDbg memory dump of string data, the human-readable
    text in the ASCII column is the text we stored in [Listing 4-2](ch04.xhtml#ch4exe2).*'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not used to reading memory, the OllyDbg dump might be a bit difficult
    to follow at this point. [Table 4-3](ch04.xhtml#ch4tab3) shows a deeper look at
    the correlation between the code in [Listing 4-2](ch04.xhtml#ch4exe2) and the
    memory in [Figure 4-3](ch04.xhtml#ch4fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-3:** Memory-to-Code Crosswalk for [Listing 4-2](ch04.xhtml#ch4exe2)
    and [Figure 4-3](ch04.xhtml#ch4fig3)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Size** | **Data** | **Object** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pane 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x012420F8 | 32 bytes | 0x6D 0x79 0x5F {...} 0x74 0x65 0x72 | `thinStringP`
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01242118 | 4 bytes | 0x00 0x00 0x00 0x00 | `thinStringP` terminator and
    padding |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0124211C | 4 bytes | 0x00 0x00 0x00 0x00 | Unrelated data |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01242120 | 64 bytes | 0x6D 0x00 0x79 {...} 0x00 0x72 0x00 | `wideStringP`
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01242160 | 4 bytes | 0x00 0x00 0x00 0x00 | `wideStringP` terminator and
    padding |'
  prefs: []
  type: TYPE_TB
- en: '| {...} |  |  | Unrelated data |'
  prefs: []
  type: TYPE_TB
- en: '| Pane 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01243040 | 4 bytes | 0xF8 0x20 0x24 0x01 | Pointer to `thinStringP` at
    `0x012420F8` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01243044 | 30 bytes | 0x6D 0x79 0x5F {...} 0x72 0x61 0x79 | `thinStringA`
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01243062 | 10 bytes | 0x00 repeated 10 times | `thinStringA` terminator
    and array fill |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0124306C | 4 bytes | 0x20 0x21 0x24 0x01 | Pointer to `wideStringP` at
    `0x01242120` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01243070 | 60 bytes | 0x6D 0x00 0x79 {...} 0x00 0x79 0x00 | `wideStringA`
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| 0x012430AC | 20 bytes | 0x00 repeated 10 times | `wideStringA` terminator
    and array fill |'
  prefs: []
  type: TYPE_TB
- en: In [Figure 4-3](ch04.xhtml#ch4fig3), pane 1 shows that the values stored where
    `thinStringP` (address 0x01243040) and `wideStringP` (address 0x0124306C) belong
    in memory are only 4 bytes long and contain no string data. That’s because these
    variables are actually pointers to the first characters of their respective arrays.
    For example, `thinStringP` contains 0x012420F8, and in pane 2 in [Figure 4-3](ch04.xhtml#ch4fig3),
    you can see `"my_thin_terminated_value_pointer"` located at address 0x012420F8.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the data between these pointers in pane 1, and you can see the text
    being stored by `thinStringA` and `wideStringA`. Furthermore, notice that `thinStringA`
    and `wideStringA` are padded beyond their null terminators; this is because these
    variables were declared as arrays with length `40`, so they are filled up to 40
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '***Data Structures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike the data types we have previously discussed, *structures* are containers
    that hold multiple pieces of simple, related data. Game hackers who know how to
    identify structures in memory can mimic those structures in their own code. This
    can greatly reduce the number of addresses they must find, as they need to find
    only the address to the start of the structure, not the address of every individual
    item.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This section talks about structures as simple containers that lack member
    functions and contain only simple data. Objects that exceed these limitations
    will be discussed in “[Classes and VF Tables](ch04.xhtml#ch00lev1sec76)” on [page
    74](ch04.xhtml#page_74).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure Element Order and Alignment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since structures simply represent an assortment of objects, they don’t visibly
    manifest in memory dumps. Instead, a memory dump of a structure shows the objects
    that are contained within that structure. The dump would look much like the others
    I’ve shown in this chapter, but with important differences in both order and alignment.
  prefs: []
  type: TYPE_NORMAL
- en: To see these differences, start by taking a look at [Listing 4-3](ch04.xhtml#ch4exe3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: A C++ structure and some code that uses it*'
  prefs: []
  type: TYPE_NORMAL
- en: This code declares a structure named `MyStruct` and creates a variable named
    `m` that supposedly points to an instance of the structure at address 0\. There’s
    not actually an instance of the structure at address 0, but this trick lets me
    use the ampersand operator (`&`) in the `printf()` call to get the address of
    each member of the structure. Since the structure is located at address 0, the
    address printed for each member is equivalent to its offset from the start of
    the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ultimate purpose of this example is to see exactly how each member is laid
    out in memory, relative to the start of the structure. If you were to run the
    code, you’d see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the variables in `MyStruct` are ordered exactly as they were
    defined in code. This sequential member layout is a mandatory property of structures.
    Compare this to the example from [Listing 4-1](ch04.xhtml#ch4exe1), when we declared
    an identical set of variables; in the memory dump from [Figure 4-2](ch04.xhtml#ch4fig2),
    the compiler clearly placed some values out of order in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you may have noticed that the members are not aligned like the
    globally scoped variables in [Listing 4-1](ch04.xhtml#ch4exe1); if they were,
    for example, there would be 2 padding bytes before `uwordValue`. This is because
    structure members are aligned on addresses divisible by either the *struct member
    alignment* (a compiler option that accepts 1, 2, 4, 8, or 16 bytes; in this example,
    it’s set to 4) or the size of the member—whichever is smaller. I arranged the
    members of `MyStruct` so that the compiler didn’t need to pad the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, we put a `char` immediately after `ulongLongValue`, the `printf()`
    call would give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, take a look at the original and the modified outputs together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the modified version, the last two values, which are the offsets for `longLongValue`
    and `floatValue` from the start of the structure, have changed. Thanks to the
    struct member alignment, the variable `longLongValue` moves by 4 bytes (1 for
    the `char` value and 3 following it) to ensure it gets placed on an address divisible
    by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Structures Work**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Understanding structures—how they are aligned and how to mimic them—can be
    very useful. For instance, if you replicate a game’s structures in your own code,
    you can read or write those entire structures from memory in a single operation.
    Consider a game that declares the player’s current and max health like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If an inexperienced game hacker wants to read this information from memory,
    they might write something like this to fetch the health values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This game hacker doesn’t realize that seeing these values right next to each
    other in memory could be more than a lucky happenstance, so they’ve used two separate
    variables. But if you came along with your knowledge of structures, you might
    conclude that, since these values are closely related and are adjacent in memory,
    our hacker could have used a structure instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since this code assumes a structure is being used and correctly mimics it, it
    can fetch both health and max health in just one line ➊. We’ll dive deeper into
    how to write your own code to read memory from in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: '***Unions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike structures, which encapsulate multiple pieces of related data, *unions*
    contain a single piece of data that is exposed through multiple variables. Unions
    follow three rules:'
  prefs: []
  type: TYPE_NORMAL
- en: • The size of a union in memory is equal to that of its largest member.
  prefs: []
  type: TYPE_NORMAL
- en: • Members of a union all reference the same memory.
  prefs: []
  type: TYPE_NORMAL
- en: • A union inherits the alignment of its largest member.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printf()` call in the following code helps illustrate the first two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This call to `printf()` outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first rule is illustrated by the `Size` value, which is printed first. Even
    though `dwValue` has three members that occupy a total of 9 bytes, it has a size
    of only 4 bytes. The size result validates the second rule as well, because `dwValue.value`
    and `dwValue.words` both point to address `0x2efda8`, as shown by the values printed
    after the word `Addresses`. The second rule is also validated by the fact that
    `dwValue.words.first` and `dwValue.words.second` contain `0xbeef` and `0xdead`,
    printed after `Values`, which makes sense considering that `dwValue.value` is
    `0xdeadbeef`. The third rule isn’t demonstrated in this example because we don’t
    have enough memory context, but if you were to put this union inside a structure
    and surround it with whatever types you like, it would in fact always align like
    a `DWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Classes and VF Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much like structures, *classes* are containers that hold and isolate multiple
    pieces of data, but classes can also contain function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Simple Class**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Classes with normal functions, such as `bar` in [Listing 4-4](ch04.xhtml#ch4exe4),
    conform to the same memory layouts as structures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: A C++ class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printf()` call in [Listing 4-4](ch04.xhtml#ch4exe4) would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even though `bar` has two member functions, this output shows that it spans
    only the 8 bytes needed to hold `bar1` and `bar2`. This is because the `bar` class
    doesn’t include abstractions of those member functions, so the program can call
    them directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Access levels such as `public`, `private`, and `protected` do not manifest
    in memory. Regardless of these modifiers, members of classes are still ordered
    as they are defined.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Class with Virtual Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In classes that do include abstract functions (often called *virtual* functions),
    the program must know which function to call. Consider the class definitions in
    [Listing 4-5](ch04.xhtml#ch4exe5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: The foo, fooa, and foob classes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `foo` has three virtual functions: `bar`, `baz`, and `barbaz`. Classes
    `fooa` and `foob` inherit from class `foo` and overload both `bar` and `baz`.
    Since `fooa` and `foob` have a public base class of `foo`, a `foo` pointer can
    point to them, but the program must still call the correct versions of `bar` and
    `baz`. You can see this by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that `_testfoo->bar()` invoked `fooa::bar()` even though `_testfoo`
    is a `foo` pointer. The program knew which version of the function to call, because
    the compiler included a *VF (virtual function) table* in the memory of `_testfoo`.
    VF tables are arrays of function addresses that abstract class instances use to
    tell a program where their overloaded functions are located.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Instances and Virtual Function Tables**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To understand the relationship between class instances and VF tables, let’s
    inspect a memory dump of the three objects declared in this listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These objects are of the types defined in [Listing 4-5](ch04.xhtml#ch4exe5).
    You can see them in memory in [Figure 4-4](ch04.xhtml#ch4fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: OllyDbg memory dump of class data*'
  prefs: []
  type: TYPE_NORMAL
- en: Pane 1 shows that each class instance stores its members just like a structure,
    but it precedes them with a `DWORD` value that points to the class instance’s
    VF table. Pane 2 shows the VF tables for each of our three class instances. The
    memory-to-code crosswalk in [Table 4-4](ch04.xhtml#ch4tab4) shows how these panes
    and the code tie together.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-4:** Memory-to-Code Crosswalk for [Listing 4-5](ch04.xhtml#ch4exe5)
    and [Figure 4-4](ch04.xhtml#ch4fig4)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Size** | **Data** | **Object** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pane 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018FF20 | 4 bytes | 0x004022B0 | Start of `_foo` and pointer to `foo`
    VF table |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018FF24 | 8 bytes | 0xDEADBEEF 0xBABABABA | `_foo.myValue1` and `_foo.myValue2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018FF2C | 4 bytes | 0x004022C0 | Start of `_fooa` and pointer to `fooa`
    VF table |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018FF30 | 8 bytes | 0xDEADBEEF 0xBABABABA | `_fooa.myValue1` and `_fooa.myValue2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018FF38 | 4 bytes | 0x004022D0 | Start of `_foob` and pointer to `foob`
    VF table |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018FF3C | 8 bytes | 0xDEADBEEF 0xBABABABA | `_foob.myValue1` and `_foob.myValue2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| {...} |  |  | Unrelated data |'
  prefs: []
  type: TYPE_TB
- en: '| Pane 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022B0 | 4 bytes | 0x00401060 | Start of `foo` VF table; address of `foo::bar`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022B4 | 4 bytes | 0x00401080 | Address of `foo::baz` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022B8 | 4 bytes | 0x004010A0 | Address of `foo::barbaz` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022BC | 4 bytes | 0x0040243C | Unrelated data |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022C0 | 4 bytes | 0x004010D0 | Start of `fooa` VF table; address of
    `fooa::bar` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022C4 | 4 bytes | 0x004010F0 | Address of `fooa::baz` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022C8 | 4 bytes | 0x004010A0 | Address of `foo::barbaz` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022CC | 4 bytes | 0x004023F0 | Unrelated data |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022D0 | 4 bytes | 0x00401130 | Start of `foob` VF table; address of
    `foob::bar` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022D4 | 4 bytes | 0x00401150 | Address of `foob::baz` |'
  prefs: []
  type: TYPE_TB
- en: '| 0x004022D8 | 4 bytes | 0x004010A0 | Address of `foo::barbaz` |'
  prefs: []
  type: TYPE_TB
- en: This crosswalk shows how the VF tables for the code in [Listing 4-5](ch04.xhtml#ch4exe5)
    are laid out in memory. Each VF table is generated by the compiler when the binary
    is made, and the tables remain constant. To save space, instances of the same
    class all point to the same VF table, which is why the VF tables aren’t placed
    inline with the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have three VF tables, you might wonder how a class instance knows
    which VF table to use. The compiler places code similar to the following bit of
    assembly in each virtual class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This example takes the static address of a VF table (`VFADDR`) and places it
    in memory as the first member of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Now look at addresses 0x004022B0, 0x004022C0, and 0x004022D0 in [Table 4-4](ch04.xhtml#ch4tab4).
    These addresses contain the beginning of the `foo`, `fooa`, and `foob` VF tables.
    Notice that `foo::barbaz` exists in all three VF tables; this is because the function
    is not overloaded by either subclass, meaning instances of each subclass will
    call the original implementation directly.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, too, that `foo::myStaticValue` does not appear in this crosswalk. Since
    the value is static, it doesn’t actually need to exist as a part of the `foo`
    class; it’s placed inside this class only for better code organization. In reality,
    it gets treated like a global variable and is placed elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**VF TABLES AND CHEAT ENGINE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember Cheat Engine’s First element of pointerstruct must point to module
    option for pointer scans from [Figure 1-4](ch01.xhtml#ch1fig4) on [page 14](ch01.xhtml#page_14)?
    Now that you’ve read a bit about VF tables, that knowledge should help you understand
    how this option works: it makes Cheat Engine ignore all heap chunks where the
    first member is not a pointer to a valid VF table. It speeds up scans, but it
    works only if every step in a pointer path is part of an abstract class instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The memory tour ends here, but if you have trouble identifying a chunk of data
    in the future, come back to this section for reference. Next, we’ll look at how
    a computer can understand a game’s high-level source code in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '**x86 Assembly Crash Course**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a program’s source code is compiled into a binary, it is stripped of all
    unnecessary artifacts and translated into *machine code*. This machine code, made
    up of only bytes (command bytes are called *opcodes*, but there are also bytes
    representing operands), gets fed directly to the processor and tells it exactly
    how to behave. Those 1s and 0s flip transistors to control computation, and they
    can be extremely difficult to understand. To make computers a little easier to
    talk to, engineers working with such code use *assembly language*, a shorthand
    that represents raw machine opcodes with abbreviated names (called mnemonics)
    and a simplistic syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language is important for game hackers to know because many powerful
    hacks can be achieved only through direct manipulation of a game’s assembly code,
    via methods such as NOPing or hooking. In this section, you’ll learn the basics
    of *x86 assembly language*, a specific flavor of assembly made for speaking to
    32-bit processors. Assembly language is very extensive, so for the sake of brevity
    this section talks only about the small subset of assembly concepts that are most
    useful to game hackers.^([1](footnote.xhtml#ch00fn01))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Throughout this section, many small snippets of assembly code include comments
    set off by a semicolon (`;`) to describe each instruction in greater detail.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Command Syntax***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Assembly language is used to describe machine code, so its syntax is pretty
    simplistic. While this syntax makes it very easy for someone to understand individual
    commands (also called *operations*), it also makes understanding complex blocks
    of code very hard. Even algorithms that are easily readable in high-level code
    seem obfuscated when written in assembly. For example, the following snippet of
    pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: would look like [Listing 4-6](ch04.xhtml#ch4exe6) in x86 assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: Some x86 assembly commands*'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it takes extensive practice to understand even the most trivial functions
    in assembly. Understanding individual commands, however, is very simple, and by
    the end of this section, you’ll know how to parse the commands I just showed you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instructions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first part of an assembly command is called an *instruction*. If you equate
    an assembly command to a terminal command, the instruction is the program to run.
    At the machine code level, instructions are typically the first byte of a command;^([2](footnote.xhtml#ch00fn02))
    there are also some 2-byte instructions, where the first byte is 0x0F. Regardless,
    an instruction tells the processor exactly what to do. In [Listing 4-6](ch04.xhtml#ch4exe6),
    `CMP`, `JG`, `MOV`, and `JMP` are all instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operand Syntax**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While some instructions are complete commands, the vast majority are incomplete
    unless followed by *operands*, or parameters. Every command in [Listing 4-6](ch04.xhtml#ch4exe6)
    has at least one operand, like `EBX`, `EAX`, and `label1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly operands come in three forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immediate value** An integer value that is declared inline (hexadecimal values
    have a trailing `h`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Register** A name that refers to a processor register.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory offset** An expression, placed in brackets, that represents the memory
    location of a value. The expression can be an immediate value or a register. Alternatively,
    it can be either the sum or difference of a register and immediate value (something
    like `[REG+Ah]` or `[REG-10h]`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each instruction in x86 assembly can have between zero and three operands,
    and commas are used to separate multiple operands. In most cases, instructions
    that require two operands have a *source operand* and a *destination operand*.
    The ordering of these operands is dependent on the assembly syntax. For example,
    [Listing 4-7](ch04.xhtml#ch4exe7) shows a group of pseudocommands written in the
    Intel syntax, which is used by Windows (and, thus, by Windows game hackers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: Demonstrating Intel syntax*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Intel syntax, the destination operand comes first, followed by the source,
    so at ➊, `R1` is the destination and `[BADFOODh]` is the source. On the other
    hand, compilers like GCC (which can be used to write bots on Windows) use a syntax
    known as AT&T, or UNIX, syntax. This syntax does things a little differently,
    as you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code is the AT&T version of [Listing 4-7](ch04.xhtml#ch4exe7). AT&T syntax
    not only reverses the operand order but also requires operand prefixing and has
    a different format for memory offset operands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly Commands**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you understand assembly instructions and how to format their operands,
    you can start writing commands. The following code shows an assembly function,
    consisting of some very basic commands, that essentially does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines, a `PUSH` command and a `MOV` command, set up a stack frame.
    The next line pushes –1 to the stack, which is undone when the stack is set back
    to its original position by the `ADD ESP, 4` command. Following that, the stack
    frame is removed, the return value (stored in `EAX`) is set to `0` with an `XOR`
    instruction, and the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about stack frames and functions in “[The Call Stack](ch04.xhtml#ch00lev1sec91)”
    on [page 86](ch04.xhtml#page_86) and “[Function Calls](ch04.xhtml#ch00lev1sec98)”
    on [page 94](ch04.xhtml#page_94). For now, turn your attention to the constants
    in the code—namely `EBP`, `ESP`, and `EAX`, which are used frequently in the code
    as operands. These values, among others, are called *processor registers*, and
    understanding them is essential to understanding the stack, function calls, and
    other low-level aspects of assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Processor Registers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike high-level programming languages, assembly language does not have user-defined
    variable names. Instead, it accesses data by referencing its memory address. During
    intensive computation, however, it can be extremely costly for the processor to
    constantly deal with the overhead of reading and writing data to RAM. To mitigate
    this high cost, x86 processors provide a small set of temporary variables, called
    processor registers, which are small storage spaces within the processor itself.
    Since accessing these registers requires far less overhead than accessing RAM,
    assembly uses them to describe its internal state, pass volatile data around,
    and store context-sensitive variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**General Registers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When assembly code needs to store or operate on arbitrary data, it uses a subset
    of process registers called *general registers*. These registers are used exclusively
    to store process-specific data, such as a function’s local variables. Each general
    register is 32 bits and thus can be thought of as a `DWORD` variable. General
    registers are also optimized for specific purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EAX, the accumulator** This register is optimized for mathematical computations.
    Some operations, such as multiplication and division, can only occur in EAX.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EBX, the base register** This register is used arbitrarily for extra storage.
    Since its 16-bit predecessor, BX, was the only register that operations could
    use to reference memory addresses, EBX was used as a reference to RAM. In x86
    assembly, however, all registers can be address references, leaving EBX without
    a true purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ECX, the counter** This register is optimized to act as the counter variable
    (often called `i` in high-level code) in a loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EDX, the data register** This register is optimized to act as a helper to
    EAX. In 64-bit computations, for instance, EAX acts as bits 0–31 and EDX acts
    as bits 32–63.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These registers also have a set of 8- and 16-bit subregisters that you can
    use to access partial data. Think of every general register as a union, where
    a register name describes the 32-bit member and the subregisters are alternate
    members that allow access to smaller pieces of the register. The following code
    shows what this union might look like for EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `AX` allows access to the lower `WORD` of `EAX`, while `AL`
    allows access to the lower `BYTE` of `AX` and `AH` to its higher `BYTE`. Every
    general register has this structure, and I outline the other registers’ subregisters
    in [Figure 4-5](ch04.xhtml#ch4fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: x86 registers and subregisters*'
  prefs: []
  type: TYPE_NORMAL
- en: EAX, EBC, ECX, and EDX have higher words, too, but the compiler will almost
    never access them on its own, as it can just use the lower word when it needs
    word-only storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Index Registers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'x86 assembly also has four *index registers*, which are used to access data
    streams, reference the call stack, and keep track of local information. Like the
    general registers, index registers are 32 bits, but index registers have more
    strictly defined purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EDI, the destination index** This register is used to index memory targeted
    by write operations. If there are no write operations in a piece of code, the
    compiler can use EDI for arbitrary storage if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ESI, the source index** This register is used to index memory targeted by
    read operations. It can also be used arbitrarily.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ESP, the stack pointer** This register is used to reference the top of the
    call stack. All stack operations directly access this register. You must use ESP
    only when working with the stack, and it must always point to the top of the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EBP, the stack base pointer** This register marks the bottom of the stack
    frame. Functions use it as a reference to their parameters and local variables.
    Some code may be compiled with an option to omit this behavior, in which case
    EBP can be used arbitrarily.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the general registers, each index register has a 16-bit counterpart: DI,
    SI, SP, and BP, respectively. However, the index registers have no 8-bit subregisters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHY DO SOME X86 REGISTERS HAVE SUBREGISTERS?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a historical reason why both general and index registers have 16-bit
    counterparts. The x86 architecture was based on a 16-bit architecture, from which
    it *extended* the registers AX, BX, CX, DX, DI, SI, SP, and BP. Appropriately,
    the extensions retain the same names but are prefixed with an *E*, for “extended.”
    The 16-bit versions remain for backward compatibility. This also explains why
    index registers have no 8-bit abstractions: they are intended to be used as memory-address
    offsets, and there is no practical need to know partial bytes of such values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Execution Index Register**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Execution Index register, referred to as *EIP*, has a very concrete purpose:
    it points to the address of the code currently being executed by the processor.
    Because it controls the flow of execution, it is directly incremented by the processor
    and is off-limits to assembly code. To modify EIP, assembly code must indirectly
    access it using operations such as `CALL`, `JMP`, and `RETN`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The EFLAGS Register**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unlike high-level code, assembly language doesn’t have binary comparison operators
    like `==`, `>`, and `<`. Instead, it uses the `CMP` command to compare two values,
    storing the resulting information in the EFLAGS register. Then, the code changes
    its control flow using special operations that depend on the value stored in ELFAGS.
  prefs: []
  type: TYPE_NORMAL
- en: 'While comparison commands are the only user-mode operations that can access
    EFLAGS, they use only this register’s *status* bits: 0, 2, 4, 6, 7, and 11\. Bits
    8–10 act as control flags, bits 12–14 and 16–21 act as system flags, and the remaining
    bits are reserved for the processor. [Table 4-5](ch04.xhtml#ch4tab5) shows the
    type, name, and description of each EFLAGS bit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-5:** EFLAGS bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Type** | **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Status | Carry | Set if a carry or borrow was generated from the most
    significant bit during the previous instruction. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Status | Parity | Set if the least significant byte resulting from the
    previous instruction has an even number of bits set. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Status | Adjust | Same as the carry flag, but considers the 4 least significant
    bits. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Status | Zero | Set if the resulting value from the previous instruction
    is equal to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Status | Sign | Set if the resulting value from the previous instruction
    has its sign bit (most significant bit) set. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Control | Trap | When set, the processor sends an interrupt to the operating
    system kernel after executing the next operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Control | Interrupt | When not set, the system ignores maskable interrupts.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Control | Direction | When set, ESI and EDI are decremented by operations
    that automatically modify them. When not set, they are incremented. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Status | Overflow | Set when a value is overflowed by the previous instruction,
    such as when ADD is performed on a positive value and the result is a negative
    value. |'
  prefs: []
  type: TYPE_TB
- en: The EFLAGS register also contains a system bit and a reserved bit, but those
    are irrelevant in user-mode assembly and game hacking, so I’ve omitted them from
    this table. Keep EFLAGS in mind when you’re debugging game code to figure out
    how it works. For example, if you set a breakpoint on a JE (jump if equal) instruction,
    you can look at the EFLAGS 0 bit to see whether the jump will be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '**Segment Registers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Finally, assembly language has a set of 16-bit registers called *segment registers*.
    Unlike other registers, segment registers are not used to store data; they are
    used to locate it. In theory, they point to isolated segments of memory, allowing
    different types of data to be stored in completely separate memory segments. The
    implementation of such segmentation is left up to the operating system. These
    are the x86 segment registers and their intended purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CS, the code segment** This register points to the memory that holds an application’s
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DS, the data segment** This register points to the memory that holds an application’s
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ES, FS, and GS, the extra segments** These registers point to any proprietary
    memory segments used by the operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SS, the stack segment** This register points to memory that acts as a dedicated
    call stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In assembly code, segment registers are used as prefixes to memory offset operands.
    When a segment register isn’t specified, DS is used by default. This means that
    the command `PUSH [EBP]` is effectively the same as `PUSH DS:[EBP]`. But the command
    `PUSH FS:[EBP]` is different: it reads memory from the FS segment, not the DS
    segment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely at the Windows x86 implementation of memory segmentation,
    you might notice that these segment registers were not exactly used as intended.
    To see this in action, you can run the following commands with the OllyDbg command
    line plug-in while OllyDbg is attached to a paused process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This output tells us three distinct things. First, it shows that there are
    only three segments being used by Windows: FS, CS, and everything else. This is
    demonstrated by DS, SS, GS, and ES being equal. For the same reason, this output
    shows that DS, SS, GS, and ES can all be used interchangeably, as they all point
    to the same memory segments. Lastly, since FS changes depending on the thread,
    this output shows that it is thread dependent. FS is an interesting segment register,
    and it points to certain thread-specific data. In “[Bypassing ASLR in Production](ch06.xhtml#ch00lev1sec132)”
    on [page 128](ch06.xhtml#page_128), we’ll explore how the data in FS can be used
    to bypass ASLR—something most bots will need to do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, in assembly code generated for Windows by a compiler, you’d only ever
    see three segments used: DS, FS, and SS. Interestingly enough, even though CS
    seems to show a constant offset from DS, it has no real purpose in user-mode code.
    Knowing all of these things, you can further conclude that there are only two
    segments being used by Windows: FS and everything else.'
  prefs: []
  type: TYPE_NORMAL
- en: These two segments actually point to different locations in the same memory
    (there’s no simple way to verify this, but it is true), which shows that Windows
    actually doesn’t use memory segments at all. Instead, it uses a flat memory model
    in which segment registers are nearly irrelevant. While all segment registers
    point to the same memory, only FS and CS point to different locations, and CS
    is not used.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, there are only three things you need to know about segment registers
    when working with x86 assembly in Windows. First, DS, SS, GS, and ES are interchangeable,
    but for clarity DS should be used to access data and SS should be used to access
    the call stack. Second, CS can be safely forgotten. Third, FS is the only segment
    register with a special purpose; it should be left alone for now.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Call Stack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Registers are powerful, but unfortunately they come in very limited supply.
    In order for assembly code to effectively store all of its local data, it must
    also use the *call stack*. The stack is used to store many different values, including
    function parameters, return addresses, and some local variables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ins and outs of the call stack will come in handy when you’re
    reverse engineering a game. Moreover, you’ll rely on this knowledge heavily when
    we jump into control flow manipulation in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can think of the call stack as a *FILO (first-in-last-out)* list of `DWORD`
    values that can be directly accessed and manipulated by assembly code. The term
    *stack* is used because the structure resembles a stack of paper: objects are
    both added to and removed from the top. Data is added to the stack through the
    `PUSH operand` command, and it is removed (and placed in a register) through the
    `POP register` command. [Figure 4-6](ch04.xhtml#ch4fig6) shows how this process
    might look.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: The structure of a stack*'
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, the stack grows from higher memory addresses to lower ones. It occupies
    a finite block of memory, piling up to address 0x00000000 (the absolute top) from
    address *n* (the absolute bottom). This means that ESP (the pointer to the top
    of the stack) decreases as items are added and increases as items are removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Stack Frame**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When an assembly function uses the stack to store data, it references the data
    by creating a *stack frame*. It does so by storing ESP in EBP and then subtracting
    *n* bytes from ESP, effectively opening an *n*-byte gap that is *framed* between
    the registers EBP and ESP. To better understand this, first imagine that the stack
    in [Figure 4-7](ch04.xhtml#ch4fig7) is passed to a function that requires 0x0C
    bytes of local storage space.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Initial example stack (read from bottom to top)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, address 0x0000 is the absolute top of the stack. We have unused
    memory from addresses 0x0000 to 0xFF00 – 4, and at the time of the function call,
    0xFF00 is the top of the stack. ESP points to this address. The stack memory after
    0xFF00 is used by preceding functions in the call chain (from 0xFF04 to 0xFFFF).
    When the function is called, the first thing it does is execute the following
    assembly code, which creates a stack frame of 0x0C (12 in decimal) bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After this code executes, the stack looks more like the one shown in [Figure
    4-8](ch04.xhtml#ch4fig8). After creating this stack, the function can work with
    the 0x0C bytes it allocated on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 0x0000 is still the absolute top of the stack. We have unused stack memory from
    addresses 0x0000 to 0xFF00 – 20, and the memory at address 0xFF00 – 16 contains
    the final 4 bytes of local storage (referenced by `[EBP-Ch]`). This is also the
    top of the current stack frame, so ESP points here. 0xFF00 – 12 contains the middle
    4 bytes of local storage (referenced by `[EBP-8h]`), and 0xFF00 – 8 contains the
    first 4 bytes of local storage (referenced by `[EBP-4h]`). EBP points to 0xFF00
    – 4, which is the bottom of the current stack frame; this address holds the original
    value of EBP. 0xFF00 is the top of the lower stack frame, and the original ESP
    in [Figure 4-7](ch04.xhtml#ch4fig7) pointed here. Finally, you can still see the
    stack memory from preceding functions in the call chain from 0xFF04 to 0xFFFF.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: Example stack with stack frame set up (read from bottom to top)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the stack in this state, the function is free to use its local data as
    it pleases. If this function called another function, the new function would build
    its own stack frame using the same technique (the stack frames really stack up).
    Once a function finishes using a stack frame, however, it must restore the stack
    to its previous state. In our case, that means making the stack look like it did
    in [Figure 4-7](ch04.xhtml#ch4fig7). When the second function finishes, our first
    function cleans the stack using the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: But if you want to change the parameters passed to a function in a game, don’t
    look for them in that function’s stack frame. A function’s parameters are stored
    in the stack frame of the function that called it, and they’re referenced through
    `[EBP+8h]`, `[EBP+Ch]`, and so on. They start at `[EBP+8h]` because `[EBP+4h]`
    stores the function’s return address. (“[Function Calls](ch04.xhtml#ch00lev1sec98)”
    on [page 94](ch04.xhtml#page_94) explains this topic further.)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code can be compiled with stack frames disabled. When this is the case, you’ll
    notice that functions don’t open with `PUSH EBP` and instead reference everything
    relative to ESP. More often than not, though, stack frames are enabled in compiled
    game code.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a grasp on the fundamentals of assembly code, let’s explore
    some specifics that will come in handy when hacking games.
  prefs: []
  type: TYPE_NORMAL
- en: '***Important x86 Instructions for Game Hacking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While assembly language has hundreds of instructions, many well-equipped game
    hackers understand only a small subset of them, which I cover in detail here.
    This subset typically encapsulates all instructions that are used to modify data,
    call functions, compare values, or jump around within code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Modification**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Data modification often happens over several assembly operations, but the end
    result has to be stored either in memory or in a register, typically with the
    `MOV` instruction. The `MOV` operation takes two operands: a destination and a
    source. [Table 4-6](ch04.xhtml#ch4tab6) shows all possible sets of `MOV` operands
    and the results you can expect from those calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-6:** Operands to the `MOV` Instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction syntax** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV R1, R2` | Copies `R2`’s value to `R1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV R1, [R2]` | Copies the value from the memory referenced by `R2` to `R1`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV R1, [R2+Ah]` | Copies the value from the memory referenced by `R2+0xA`
    to `R1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV R1, [DEADBEEFh]` | Copies the value from the memory at 0xDEADBEEF to
    `R1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV R1, BADF00Dh` | Copies the value 0xBADF00D to `R1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV [R1], R2` | Copies `R2`’s value to the memory referenced by `R1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV [R1], BADF00Dh` | Copies the value 0xBADF00D to the memory referenced
    by `R1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV [R1+4h], R2` | Copies `R2`’s value to the memory referenced by `R1+0x4`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV [R1+4h], BADF00Dh` | Copies the value 0xBADF00D to the memory referenced
    by `R1+0x4`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV [DEADBEEFh], R1` | Copies `R1`’s value to the memory at 0xDEADBEEF.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV [DEADBEEFh], BADF00Dh` | Copies the value 0xBADF00D to the memory at
    0xDEADBEEF. |'
  prefs: []
  type: TYPE_TB
- en: 'The `MOV` instruction can take a lot of operand combinations, but some aren’t
    allowed. First, the destination operand can’t be an immediate value; it must be
    a register or memory address, because immediate values can’t be modified. Second,
    values can’t be directly copied from one memory address to another. Copying a
    value requires two separate operations, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These instructions copy whatever is stored at EBP+0x10 to the memory at 0xDEADBEEF.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Like many high-level languages, assembly language has two types of arithmetic:
    unary and binary. Unary instructions take a single operand that acts as both a
    destination and a source. This operand can be a register or a memory address.
    [Table 4-7](ch04.xhtml#ch4tab7) shows the common unary arithmetic instructions
    in x86.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-7:** Unary Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction syntax** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `INC operand` | Adds 1 to the operand value. |'
  prefs: []
  type: TYPE_TB
- en: '| `DEC operand` | Subtracts 1 from the operand value. |'
  prefs: []
  type: TYPE_TB
- en: '| `NOT operand` | Logically negates the operand value (flips all bits). |'
  prefs: []
  type: TYPE_TB
- en: '| `NEG operand` | Performs two’s-complement negation (flips all bits and adds
    1; essentially multiplies by -1). |'
  prefs: []
  type: TYPE_TB
- en: 'Binary instructions (which make up the majority of x86 arithmetic), on the
    other hand, are syntactically similar to the `MOV` instruction. They require two
    operands and have similar operand limitations. Unlike `MOV`, however, their destination
    operand serves a second purpose: it is also the left-hand value in the calculation.
    For example, the assembly operation `ADD EAX,EBX` equates to `EAX = EAX + EBX`
    or `EAX += EBX` in C++. [Table 4-8](ch04.xhtml#ch4tab8) shows the common x86 binary
    arithmetic instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-8:** Binary Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction syntax** | **Function** | **Operand notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ADD destination`, source | `destination` += source |  |'
  prefs: []
  type: TYPE_TB
- en: '| `SUB destination`, source | `destination` -= source |  |'
  prefs: []
  type: TYPE_TB
- en: '| `AND destination`, source | `destination` &= source |  |'
  prefs: []
  type: TYPE_TB
- en: '| `OR destination`, source | `destination` &#124;= source |  |'
  prefs: []
  type: TYPE_TB
- en: '| `XOR destination`, source | `destination` ^= source |  |'
  prefs: []
  type: TYPE_TB
- en: '| `SHL destination`, source | `destination` = destination << source | `source`
    must be CL or an 8-bit immediate value. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHR destination`, source | `destination` = destination >> source | `source`
    must be CL or an 8-bit immediate value. |'
  prefs: []
  type: TYPE_TB
- en: '| `IMUL destination`, source | `destination` *= source | `destination` must
    be a register; source cannot be an immediate value. |'
  prefs: []
  type: TYPE_TB
- en: Of these arithmetic instructions, `IMUL` is special because you can pass it
    a third operand, in the form of an immediate value. With this prototype, the destination
    operand is no longer involved in the calculation, which instead takes place between
    the remaining operands. For example, the assembly command `IMUL EAX,EBX,4h` equates
    to `EAX = EBX * 0x4` in C++.
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass a single operand to `IMUL`.^([3](footnote.xhtml#ch00fn03))
    In this case, the operand acts as the source and can be either a memory address
    or a register. Depending on the size of the source operand, the instruction will
    use different parts of the EAX register for inputs and output, as shown in [Table
    4-9](ch04.xhtml#ch4tab9).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-9:** Possible `IMUL` Register Operands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source size** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8 bits | AL | 16 bit, stored in AH:AL (which is AX) |'
  prefs: []
  type: TYPE_TB
- en: '| 16 bits | AX | 32 bit, stored in DX:AX (bits 0–15 in AX and bits 16–31 in
    DX) |'
  prefs: []
  type: TYPE_TB
- en: '| 32 bits | EAX | 64 bit, stored in EDX:EAX (bits 0–31 in EAX and bits 32–64
    in EDX) |'
  prefs: []
  type: TYPE_TB
- en: Notice that even though the input is only one register, each output uses two
    registers. That’s because in multiplication, the result generally is larger than
    the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example calculation using `IMUL` with a single 32-bit operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command behaves like the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here’s an operation that uses `IMUL` with a single 16-bit operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And its corresponding pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this is an `IMUL` command with a single 8-bit operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And its corresponding pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: x86 assembly language has division as well, through the `IDIV` instruction.^([4](footnote.xhtml#ch00fn04))
    The `IDIV` instruction accepts a single source operand and follows register rules
    similar to those for `IMUL`. As [Table 4-10](ch04.xhtml#ch4tab10) shows, `IDIV`
    operations require two inputs and two outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-10:** Possible `IDIV` Register Operands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source size** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8 bit | 16 bit, stored in AH:AL (which is AX) | Remainder in AH; quotient
    in AL |'
  prefs: []
  type: TYPE_TB
- en: '| 16 bit | 32 bit, stored in DX:AX | Remainder in DX; quotient in AX |'
  prefs: []
  type: TYPE_TB
- en: '| 32 bit | 64 bit, stored in EDX:EAX | Remainder in EDX; quotient in EAX |'
  prefs: []
  type: TYPE_TB
- en: 'In division, the inputs are generally larger than the output, so here the inputs
    take two registers. Moreover, division operations must store a remainder, which
    gets stored in the first input register. For example, here’s how a 32-bit `IDIV`
    calculation would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s some pseudocode that expresses what happens under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These details of `IDIV` and `IMUL` are important to remember, as the behavior
    can otherwise be quite obfuscated when you’re simply looking at the commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Branching**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After evaluating an expression, programs can decide what to execute next based
    on the result, typically using constructs such as `if()` statements or `switch()`
    statements. These control flow statements don’t exist at the assembly level, however.
    Instead, assembly code uses the EFLAGS register to make decisions and jump operations
    to execute different blocks; this process is called *branching*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the proper value in EFLAGS, assembly code uses one of two instructions:
    `TEST` or `CMP`. Both compare two operands, set the status bits of EFLAGS, and
    then discard any results. `TEST` compares the operands using a logical AND, while
    `CMP` uses signed subtraction to subtract the latter operand from the former.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to branch properly, the code has a jump command immediately following
    the comparison. Each type of jump instruction accepts a single operand that specifies
    the address of the code to jump to. How a particular jump instruction behaves
    depends on the status bits of EFLAGS. [Table 4-11](ch04.xhtml#ch4tab11) describes
    some x86 jump instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-11:** Common x86 Jump Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Name** | **Behavior** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `JMP dest` | Unconditional jump | Jumps to `dest` (sets `EIP` to `dest`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JE dest` | Jump if equal | Jumps if `ZF` (zero flag) is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `JNE dest` | Jump if not equal | Jumps if `ZF` is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `JG dest` | Jump if greater | Jumps if `ZF` is 0 and `SF` (sign flag) is
    equal to `OF` (overflow flag). |'
  prefs: []
  type: TYPE_TB
- en: '| `JGE dest` | Jump if greater or equal | Jumps if `SF` is equal to `OF`. |'
  prefs: []
  type: TYPE_TB
- en: '| `JA dest` | Unsigned `JG` | Jumps if `CF` (carry flag) is 0 and `ZF` is 0.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JAE dest` | Unsigned `JGE` | Jumps if `CF` is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `JL dest` | Jump if less | Jumps if `SF` is not equal to `OF`. |'
  prefs: []
  type: TYPE_TB
- en: '| `JLE dest` | Jump if less or equal | Jumps if `ZF` is 1 or `SF` is not equal
    to `OF`. |'
  prefs: []
  type: TYPE_TB
- en: '| `JB dest` | Unsigned `JL` | Jumps if `CF` is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `JBE dest` | Unsigned `JLE` | Jumps if `CF` is 1 or `ZF` is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `JO dest` | Jump if overflow | Jumps if `OF` is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `JNO dest` | Jump if not overflow | Jumps if `OF` is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `JZ dest` | Jump if zero | Jumps if `ZF` is 1 (identical to `JE`). |'
  prefs: []
  type: TYPE_TB
- en: '| `JNZ dest` | Jump if not zero | Jumps if `ZF` is 0 (identical to `JNE`).
    |'
  prefs: []
  type: TYPE_TB
- en: Remembering which flags control which jump instructions can be a pain, but their
    purpose is clearly expressed in their name. A good rule of thumb is that a jump
    preceded by a `CMP` is the same as its corresponding operator. For example, [Table
    4-11](ch04.xhtml#ch4tab11) lists `JE` as “jump if equal,” so when `JE` follows
    a `CMP` operation, it’s the same as the `==` operator. Similarly, `JGE` would
    be `>=`, `JLE` would be `>=`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the high-level code shown in [Listing 4-8](ch04.xhtml#ch4exe8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: A simple conditional statement*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `if()` statement just checks whether `EBX` is greater than `EAX` and sets
    `ECX` based on the result. In assembly, the same statement may look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The assembly for the `if()` statement in [Listing 4-8](ch04.xhtml#ch4exe8) begins
    with a `CMP` instruction and branches if `EBX` is greater than `EAX`. If the branch
    is taken, `EIP` is set to the `if` block at ➊ courtesy of the `JG` instruction.
    If the branch is not taken, the code continues executing linearly and hits the
    `else` block immediately after the `JG` instruction. When the `else` block finishes
    executing, an unconditional `JMP` sets `EIP` to `0x7`, skipping over the `if`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Calls**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In assembly code, functions are isolated blocks of commands executed through
    the `CALL` instruction. The `CALL` instruction, which takes a function address
    as the only operand, pushes a return address onto the stack and sets EIP to its
    operand value. The following pseudocode shows a `CALL` in action, with memory
    addresses on the left in hex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When `CALL EAX` is executed, the next address is pushed to the stack and `EIP`
    is set to `EAX`, showing that `CALL` is essentially a `PUSH` and `JMP`. The following
    pseudocode underscores this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'While there’s an extra address between the `PUSH` instruction and the code
    to execute, the result is the same: before the block of code at `EAX` is executed,
    the address of the code that follows the branch is pushed to the stack. This happens
    so the *callee* (the function being called) knows where to jump to in the *caller*
    (the function doing the call) when it returns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function without parameters is called, a `CALL` command is all that’s
    necessary. If the callee takes parameters, however, the parameters must first
    be pushed onto the stack in reverse order. The following pseudocode shows how
    a function call with three parameters might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the callee is executed, the top of the stack contains a return address
    that points to the code after the call. The first parameter, `0x100`, is below
    the return address on the stack. The second parameter, `0x200`, is below that,
    followed by the third parameter, `0x300`. The callee sets up its stack frame,
    using memory offsets from `EBP` to reference each parameter. Once the callee has
    finished executing, it restores the caller’s stack frame and executes the `RET`
    instruction, which pops the return address off the stack and jumps to it.
  prefs: []
  type: TYPE_NORMAL
- en: Since the parameters are not a part of the callee’s stack frame, they remain
    on the stack after `RET` is executed. If the caller is responsible for cleaning
    the stack, it adds 12 (3 parameters, at 4 bytes each) to ESP immediately after
    `CALL ECX` completes. If the callee is responsible, it cleans up by executing
    `RET 12` instead of `RET`. This responsibility is determined by the callee’s *calling
    convention*.
  prefs: []
  type: TYPE_NORMAL
- en: A function’s calling convention tells the compiler how the assembly code should
    pass parameters, store instance pointers, communicate the return value, and clean
    the stack. Different compilers have different calling conventions, but the ones
    listed in [Table 4-12](ch04.xhtml#ch4tab12) are the only four that a game hacker
    is likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-12:** Calling Conventions to Know for Game Hacking'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive** | **Cleaner** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `__cdecl` | caller | Default convention in Visual Studio. |'
  prefs: []
  type: TYPE_TB
- en: '| `__stdcall` | callee | Convention used by Win32 API functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `__fastcall` | callee | First two `DWORD` (or smaller) parameters are passed
    in ECX and EDX. |'
  prefs: []
  type: TYPE_TB
- en: '| `__thiscall` | callee | Used for member functions. The pointer to the class
    instance is passed in ECX. |'
  prefs: []
  type: TYPE_TB
- en: The Directive column in [Table 4-12](ch04.xhtml#ch4tab12) gives the name of
    the calling convention, and the Cleaner column tells you whether the caller or
    callee is responsible for cleaning the stack given that directive. In the case
    of these four calling conventions, parameters are always pushed right to left,
    and return values are always stored in EAX. This is a standard, but not a rule;
    it can differ across other calling conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My goal in writing this chapter was to help you understand memory and assembly
    in a general sense, before we dig into game-hacking specifics. With your newfound
    ability to think like a computer, you should be adequately armed to start tackling
    more advanced memory forensics tasks. If you’re itching for a peek at how you’ll
    apply all of this to something real, flip to “[Applying Call Hooks to Adobe AIR](ch08.xhtml#ch00lev1sec169)”
    on [page 169](ch08.xhtml#page_169) or “[Applying Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)”
    on [page 175](ch08.xhtml#page_175).
  prefs: []
  type: TYPE_NORMAL
- en: If you want some hands-on time with memory, compile this chapter’s example code
    and use Cheat Engine or OllyDbg to inspect, tweak, and poke at the memory until
    you’ve got the hang of it. This is important, as the next chapter will build on
    these skills by teaching you advanced memory forensic techniques.
  prefs: []
  type: TYPE_NORMAL
