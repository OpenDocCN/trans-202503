- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 19 INHERITANCE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19 继承
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'This chapter covers perhaps the most powerful and important feature of OOP:
    *inheritance*. This is the capability of one or more classes, called *subclasses*,
    to automatically have all the same properties and methods as another class, called
    a *superclass*. Inheritance makes OOP more efficient: you have to define any general,
    shared members only once, in the superclass. Objects of the subclasses inherit
    those properties and methods, and they will also have whatever properties and
    methods are specific to the individual subclasses.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了面向对象编程（OOP）中或许是最强大且最重要的特性：*继承*。继承是指一个或多个类（称为*子类*）能够自动继承另一个类（称为*超类*）的所有属性和方法。继承使得OOP更加高效：你只需要在超类中定义一次任何通用的共享成员。子类的对象将继承这些属性和方法，并且还会有属于各自子类的特有属性和方法。
- en: 'Associated with inheritance is the capability of subclasses to *override* inherited
    methods from their superclass when that general method isn’t appropriate to the
    particular subclass. As we’ll explore in this chapter, you can also have the best
    of both worlds (executing the inherited method *and* adding additional behavior
    through the subclass’s method) by using the parent keyword. Additionally, we’ll
    discuss the third kind of protection PHP offers for methods and properties: protected.
    You’ll learn what distinguishes protected members of a class from public and private
    members, and when to use each visibility designation.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承相关的是子类能够在继承的方法不适合特定子类时，*重写*超类的继承方法。正如本章中所探讨的，你也可以通过使用parent关键字实现两全其美（执行继承的方法*并且*通过子类的方法添加额外的行为）。此外，我们还将讨论PHP提供的第三种方法和属性保护方式：protected。你将了解protected成员与public和private成员的区别，以及何时使用每种可见性修饰符。
- en: Inheritance as Generalization
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承作为泛化
- en: Inheritance simplifies code by identifying and generalizing properties and behaviors
    shared among classes of objects. Consider the properties identified for Car and
    Boat objects shown in [Figure 19-1](#fig19-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 继承通过识别和概括对象类之间共享的属性和行为来简化代码。考虑[图19-1](#fig19-1)中显示的汽车和船舶对象的属性。
- en: '![](../images/figure19-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure19-1.jpg)'
- en: 'Figure 19-1: The Car and Boat classes, with common properties shown in bold'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-1：汽车类和船舶类，具有以粗体显示的共享属性
- en: 'The first three properties of each class are identical: both Car and Boat objects
    have a make and model, a number of passengers, and a top speed. To avoid redundancy,
    we can generalize these common properties (and any associated methods) into a
    superclass, which we’ll name Vehicle. [Figure 19-2](#fig19-2) shows this generalized
    Vehicle class with the three shared properties, as well as the simplified Car
    and Boat classes, each now with just one property of its own.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类的前三个属性都是相同的：汽车和船舶对象都有制造商和型号、乘客数和最高速度。为了避免冗余，我们可以将这些共有的属性（以及任何相关的方法）概括到一个超类中，我们将其命名为车辆（Vehicle）。[图19-2](#fig19-2)展示了这个泛化的车辆类，其中包含三个共享属性，并且简化了的汽车和船舶类，每个类现在只包含一个自己的属性。
- en: '![](../images/figure19-2.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure19-2.jpg)'
- en: 'Figure 19-2: The Vehicle superclass and the Car and Boat subclasses'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-2：车辆超类和汽车、船舶子类
- en: The arrows going from Car and Boat to Vehicle indicate that both Car and Boat
    inherit from Vehicle; that is, Car and Boat are subclasses of the generalized
    Vehicle superclass. Notice that the visibility of the properties (public versus
    private) hasn’t been indicated in the diagram. For now, we’ll implement the classes
    by using simple public properties. Later in the chapter, we’ll refactor the classes
    by using the third visibility setting, protected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从汽车类和船舶类指向车辆类的箭头表示汽车和船舶类都继承自车辆类；也就是说，汽车和船舶是泛化车辆超类的子类。请注意，图中并未标明属性的可见性（public与private）。目前，我们将通过使用简单的公共属性来实现这些类。稍后在本章中，我们将通过使用第三种可见性设置——protected来重构这些类。
- en: Listing 19-1 implements the Vehicle class shown in [Figure 19-2](#fig19-2).
    Start a new project and create *src/Vehicle.php* containing the code in this listing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19-1实现了[图19-2](#fig19-2)中显示的车辆类。开始一个新项目，并创建包含此代码的*src/Vehicle.php*文件。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 19-1: Implementing the Vehicle superclass'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19-1：实现车辆超类
- en: 'We declare the Vehicle class with three public properties: makeModel, numPassengers,
    and topSpeed.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个车辆类（Vehicle），它有三个公共属性：makeModel、numPassengers和topSpeed。
- en: Listing 19-2 implements the Car subclass of Vehicle, which should be created
    in *src/Car.php*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-2 实现了Vehicle类的Car子类，这个类应当创建在*src/Car.php*中。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 19-2: Implementing Car as a subclass of Vehicle'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-2：将Car作为Vehicle的子类实现
- en: We declare that Car should be a subclass of Vehicle simply by adding the extends
    keyword followed by the superclass name at the start of the class declaration.
    Any Car objects we create will automatically inherit all the properties and methods
    from the Vehicle superclass, in addition to having the bodyShape property declared
    directly in the Car class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明Car类应当是Vehicle类的子类，只需在类声明的开头添加extends关键字，后面跟上超类名称。我们创建的任何Car对象将自动继承Vehicle超类的所有属性和方法，同时还会包含在Car类中直接声明的bodyShape属性。
- en: Creating Objects from Subclasses
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从子类创建对象
- en: To verify that our example of inheritance works, we’ll create a Car object and
    set values for its properties—both the one declared directly in Car and the ones
    inherited from Vehicle. Create *public/index.php* containing the code in [Listing
    19-3](#lis19-3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的继承示例是否有效，我们将创建一个Car对象并为其属性设置值——包括在Car类中直接声明的属性以及从Vehicle类继承的属性。创建*public/index.php*并输入[列表
    19-3](#lis19-3)中的代码。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 19-3: Creating a Car object in index.php'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-3：在index.php中创建Car对象
- en: 'We first read in the files declaring the Vehicle and Car classes. It’s imperative
    to read in declarations for *all* the classes the code uses, including inherited
    classes such as Vehicle, even though we won’t be directly creating objects of
    this class. The order we read in the files is important too: for the Car class
    to be able to extend the Vehicle class, we must have read in and executed the
    declaration for the Vehicle class *before* reading in and declaring the Car class.
    Otherwise, we’ll get an error about the Vehicle class not being found.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取声明Vehicle和Car类的文件。必须读取代码所使用的*所有*类的声明，包括像Vehicle这样的继承类，即使我们不会直接创建该类的对象。我们读取文件的顺序也很重要：为了让Car类能够扩展Vehicle类，必须先读取并执行Vehicle类的声明，再读取并声明Car类。否则，会报错提示找不到Vehicle类。
- en: NOTE
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Large projects may require tens, or even hundreds, of class declarations.
    In [Chapter 20](chapter20.xhtml), we’ll look at a way to read in all the class
    declarations in the required sequence with a single statement, using a script
    called an* autoloader*.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*大型项目可能需要几十个，甚至上百个类声明。在[第20章](chapter20.xhtml)中，我们将介绍一种方法，通过使用一个名为*autoloader*的脚本，以单个语句按需要的顺序读取所有类声明。*'
- en: 'Next, we create a new Car object and store a reference to it in the $car1 variable.
    Then we set values for the bodyShape, makeModel, numPassengers, and topSpeed properties.
    The syntax is the same whether the property was declared for the subclass or inherited
    from the superclass: either way, we simply use $car1->propertyName = value. Finally,
    we use var_dump() to output structured information about the $car1 variable and
    the object it refers to in memory. Here’s the result of running the index script
    at the command line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的Car对象，并将其引用存储在$car1变量中。然后，我们为bodyShape、makeModel、numPassengers和topSpeed属性设置值。无论属性是直接在Car类中声明的，还是从Vehicle类继承的，语法都是一样的：无论如何，我们都只是使用$car1->propertyName
    = value。最后，我们使用var_dump()输出关于$car1变量及其在内存中引用的对象的结构化信息。以下是运行命令行中index脚本的结果：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Car object indeed has four properties, and we’ve successfully set all four,
    including the property declared in *Car.php* (bodyShape) and the three properties
    inherited from the Vehicle superclass.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Car对象确实有四个属性，并且我们已经成功设置了这四个属性，包括在*Car.php*中声明的属性（bodyShape）和从Vehicle超类继承的三个属性。
- en: Let’s complete our implementation of the class hierarchy from [Figure 19-2](#fig19-2)
    by declaring the Boat subclass. Create *src/Boat.php* and enter the code in [Listing
    19-4](#lis19-4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过声明Boat子类，完成[图19-2](#fig19-2)中的类层次结构实现。创建*src/Boat.php*并输入[列表 19-4](#lis19-4)中的代码。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 19-4: Implementing the Boat class'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-4：实现Boat类
- en: We declare that Boat should inherit from Vehicle, once again using the extends
    keyword to establish the subclass/superclass relationship. The class has only
    one unique property, countryOfRegistration, but Boat objects will also inherit
    the three public properties of makeModel, numPassengers, and topSpeed from Vehicle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明Boat类应该继承自Vehicle类，再次使用extends关键字来建立子类/父类的关系。这个类只有一个独特的属性countryOfRegistration，但Boat对象也将继承Vehicle类的三个公共属性：makeModel、numPassengers和topSpeed。
- en: Using Multiple Levels of Inheritance
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用多层次的继承
- en: 'Class hierarchies can involve many levels of inheritance: class A could have
    a subclass B, class B could have a subclass C, and so on. In this case, class
    C would inherit methods and properties from both class B, its immediate superclass,
    and from class A, the superclass of its superclass. [Figure 19-3](#fig19-3) illustrates
    how we might use this mechanism to further extend our hierarchy of vehicular classes.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-3: A three-level class hierarchy, with subclasses of subclasses'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The class hierarchy features two subclasses of Boat: MotorBoat and SailBoat.
    All MotorBoat and SailBoat objects will inherit the properties and methods of
    Boat, their superclass. That includes the properties and methods that Boat inherits
    from Vehicle. Meanwhile, MotorBoat objects will also have a special property of
    their own, engineSize, while SailBoat will have a unique numberOfMasts property.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to declare the MotorBoat class, we’d start by writing class
    MotorBoat extends Boat. We don’t need to also mention Vehicle in the MotorBoat
    class declaration; the inheritance from Vehicle is already covered in the *src/Boat.php*
    class-declaration file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Like most object-oriented languages, PHP permits each class to have only a single
    direct superclass. This safeguard prevents ambiguities as to where a property
    or method is being inherited from, but it also adds challenges when it comes to
    designing class hierarchies. For example, since cars and motorboats both have
    engines, it might make sense to create a MotorizedVehicle subclass of Vehicle.
    The Car class would naturally inherit from MotorizedVehicle, but what about MotorBoat?
    Should it inherit from Boat or MotorizedVehicle? It can inherit directly from
    only one or the other. As this example illustrates, once class hierarchies get
    more complex, care must be taken in their design.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Protected Visibility
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the introduction of inheritance, a third visibility keyword, besides public
    and private, becomes relevant: protected. When a method or property is declared
    protected, it becomes accessible to any subclasses that inherit it, but it can’t
    be accessed by code elsewhere in the project. For example, a protected property
    of the Vehicle superclass could be accessed within *Car.php*, since Car inherits
    from Vehicle. By contrast, that protected property couldn’t be accessed within
    the general *index.php* file.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The protected visibility designation is more restrictive than public, since
    public properties and methods can be accessed from anywhere within the project
    code. On the other hand, protected is less restrictive than private. When a method
    or property is private, it’s accessible only within the class itself; not even
    methods of subclasses can directly access private properties and methods from
    their superclass.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the distinction between the three visibility keywords, we’ll refactor
    the Vehicle class. To begin, we’ll update the class to have private properties
    and public accessor methods, as we discussed in [Chapter 18](chapter18.xhtml).
    Then we’ll add the protected designation into the mix. [Listing 19-5](#lis19-5)
    shows the first changes to *src/Vehicle.php*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 19-5: Revising the Vehicle class to have private properties and public
    accessor methods'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We declare all three class properties as private rather than public. This means
    they can’t be set directly. Instead, we’ve declared public getter and setter methods
    for each property ❶.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We now need to update the index script to use the setter methods to set values
    for the Car object. Modify *public/index.php* to match the code in [Listing 19-6](#lis19-6).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 19-6: Updating index.php to set inherited properties via setter methods'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We can still directly access the bodyShape property declared in the Car class
    ❶, since it’s still set as public. However, we now need to use the setter methods
    to assign values to the three inherited properties, makeModel, numPassengers,
    and topSpeed, since these properties are now declared as private in the Vehicle
    superclass. The Car object inherits the accessor methods from Vehicle, just as
    it inherits the properties themselves. Thanks to the accessor methods, var_dump()
    will work as before.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Using public setter methods to update private properties within *index.php*
    makes sense; this is exactly what we did in [Chapter 18](chapter18.xhtml). But
    what if we want to use one of the properties inherited from Vehicle as part of
    a method declared in the Car class? Let’s try this and see what happens. We’ll
    add a new getMakeModelShape() method to Car that returns a string summary of some
    of the object’s properties. Update *src/Car.php* to match the code in [Listing
    19-7](#lis19-7).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 19-7: Trying to access private superclass properties from a subclass'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: We declare the new getMakeModelShape() method in the Car class. This method
    attempts to insert the values of the makeModel and bodyShape properties into a
    string. To see whether this method works, we’ll invoke it in our index script.
    Update *public/index.php* as shown in [Listing 19-8](#lis19-8).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 19-8: Testing the getMakeModelShape() method in index.php'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve replaced the var_dump() function call with a print statement invoking
    the getMakeModelShape() method of our $car1 object reference. However, if you
    now run the index script, you’ll get an Undefined property warning, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Statements in our Car class methods have no access to inherited private properties,
    so the PHP engine simply can’t find a makeModel property when it executes getMakeModelShape().
    Notice, however, that the warning message is followed by the text , Sedan. This
    indicates that the index script continued executing despite the issue. Indeed,
    after continuing from its undefined property warning, the PHP engine had no problem
    with the $this->bodyShape portion of the getMakeModelShape() method, since bodyShape
    is a property defined directly on the Car class itself.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Car 类方法中的语句无法访问继承的私有属性，因此 PHP 引擎在执行 getMakeModelShape() 时无法找到 makeModel
    属性。然而，注意到警告信息后面跟着文本 "Sedan"。这表明，即使出现问题，索引脚本仍然继续执行。实际上，在从未定义的属性警告继续执行后，PHP 引擎对
    getMakeModelShape() 方法中的 $this->bodyShape 部分没有任何问题，因为 bodyShape 是直接在 Car 类本身定义的属性。
- en: One way for us to access the value of an inherited property could be to use
    the public getter method to access the makeModel property, but in some situations
    it’s best not to offer public getter or setter methods for a property. A better
    solution when you want to give methods of a subclass direct access to a property
    or method inherited from its superclass, without making that property or method
    public, is to give the property or method protected visibility. For that, update
    the Vehicle class as shown in [Listing 19-9](#lis19-9).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问继承属性值的一种方式是使用公共 getter 方法访问 makeModel 属性，但在某些情况下，最好不要为属性提供公共的 getter 或 setter
    方法。当你希望让子类的方法直接访问从父类继承的属性或方法，而又不想让该属性或方法公开时，最佳的解决方案是将该属性或方法设为受保护可见性。为此，更新 Vehicle
    类，如 [清单 19-9](#lis19-9) 所示。
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 19-9: Using protected visibility for makeModel in the Vehicle class'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 19-9：在 Vehicle 类中使用受保护可见性来访问 makeModel
- en: 'We now declare the Vehicle property makeModel to have protected visibility
    ❶, which means it can be accessed directly by statements in the Car subclass.
    Re-execute the index script and you’ll see the make, model, and shape string output
    with no warnings: Ford Mustang, Sedan.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将 Vehicle 属性 makeModel 的可见性声明为受保护 ❶，这意味着它可以被 Car 子类中的语句直接访问。重新执行索引脚本，你将看到没有警告的
    make、model 和 shape 字符串输出：Ford Mustang，Sedan。
- en: '[Figure 19-4](#fig19-4) shows the UML diagram for our three classes, updated
    to indicate the visibility of each class property and method.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-4](#fig19-4) 显示了我们三个类的 UML 图，更新后指示了每个类属性和方法的可见性。'
- en: '![](../images/figure19-4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure19-4.jpg)'
- en: 'Figure 19-4: An updated UML diagram showing the visibility settings for the
    class hierarchy'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-4：显示类层次结构中可见性设置的更新 UML 图
- en: Within the Vehicle class, the hash mark (#) indicates the protected visibility
    of the makeModel property, while the other two properties are shown as private
    with minus signs. All properties and methods for classes Car and Boat are public
    and so indicated with plus signs. The *«get/set»* annotations in the diagram indicate
    public getter and setter accessor methods for all three properties of the Vehicle
    class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vehicle 类中，井号（#）表示 makeModel 属性的受保护可见性，而其他两个属性则以负号表示为私有。Car 和 Boat 类的所有属性和方法都是公开的，因此用加号表示。图中的
    *«get/set»* 注释表示 Vehicle 类所有三个属性的公共 getter 和 setter 访问方法。
- en: This example demonstrates the distinction between private and protected. To
    illustrate the difference between the public and protected visibility of properties,
    let’s modify the *public/index.php* script to try to directly set the value of
    the makeModel property. Update the index script to match [Listing 19-10](#lis19-10).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了私有和受保护可见性之间的区别。为了说明公共和受保护可见性属性之间的差异，让我们修改 *public/index.php* 脚本，尝试直接设置
    makeModel 属性的值。更新索引脚本以匹配 [清单 19-10](#lis19-10)。
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 19-10: Illustrating the difference between public and protected visibility'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 19-10：展示公共和受保护可见性之间的区别
- en: 'We set the value of the public bodyShape property to ''Sedan'' as before. Then
    we attempt to directly change the value stored in the makeModel property of $car1
    to the string ''Ford Mustang''. Execute this script and you’ll get a fatal error,
    as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像以前一样将公共 bodyShape 属性的值设置为 'Sedan'。然后，我们尝试直接将 $car1 中的 makeModel 属性的值更改为字符串
    'Ford Mustang'。执行这个脚本时，你将遇到致命错误，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The makeModel property has protected visibility, so it can’t be accessed from
    our index script. Only subclasses of Vehicle can access the property directly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: makeModel 属性具有受保护可见性，因此无法从我们的索引脚本中访问。只有 Vehicle 的子类才能直接访问该属性。
- en: Abstract Classes
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类
- en: An *abstract class* is one that will never be used to create objects. Instead,
    abstract classes are commonly declared so their members (properties and methods)
    can be inherited by subclasses. The Vehicle class, for example, is an abstract
    class. We’ll never want to create a Vehicle object; we declared the class only
    to generalize common properties and methods from the Car and Boat classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Another use of abstract classes is to declare static members, properties, or
    methods that relate to the class as a whole rather than to individual objects.
    We’ll explore static members in [Chapter 25](chapter25.xhtml).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: It’s good practice to be as specific as possible about how a class and its members
    will be used. For that reason, if you know a class is abstract, it’s best to include
    the abstract keyword when you’re declaring it. This keyword ensures that no object
    of the class can be created without triggering an error. To demonstrate, we’ll
    add the abstract keyword to our Vehicle class declaration. Update *src/Vehicle.php*
    as shown in [Listing 19-11](#lis19-11).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 19-11: Declaring Vehicle as an abstract class'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: We declare that Vehicle is an abstract class by adding abstract immediately
    before the class keyword. If you run the index script again after making this
    change, you’ll see no difference in the behavior of the program. However, if you
    now attempt to create a Vehicle object, as shown in [Listing 19-12](#lis19-12),
    a fatal error will occur. Update *public/index.php* to match the listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 19-12: Attempting to create an object of the abstract Vehicle class'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'We attempt to create an object of the Vehicle class and store a reference to
    the created object in the $vehicle1 variable ❶. Here’s what happens if you try
    to run this index script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A fatal error occurs, with the message Cannot instantiate abstract class. This
    is exactly what we want: by declaring the Vehicle class to be abstract, we’ve
    guaranteed that no Vehicle objects can be created.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Inherited Methods
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, you might want to change the way an inherited method behaves
    on a subclass, as compared to the way it’s defined in the superclass. This is
    called *overriding* the method, and you do it by defining the method directly
    on the subclass and giving it the same name as the method inherited from the superclass.
    PHP gives precedence to properties and methods defined lower in the class hierarchy,
    so it will execute the method definition from the subclass rather than the one
    from the superclass.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate with a superclass that declares a __toString() method, then
    a subclass that overrides this declaration with its own __toString() implementation.
    [Figure 19-5](#fig19-5) shows the UML diagram for the two classes we’ll use to
    investigate how to override inherited methods, with notes to indicate how each
    __toString() method should behave. We’ll be creating a general Food class and
    a Dessert subclass of Food.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-5.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-5: The Dessert subclass overrides the __toString() method inherited
    from Food.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-5：Dessert子类重写了从Food继承的__toString()方法。
- en: The Food class has a __toString() method that generates a string in the form
    "(FOOD) foodname", such as "(FOOD) apple". Meanwhile, the Dessert subclass overrides
    this behavior with its own __toString() method that generates a string in the
    form "I am a Dessert named foodname", such as "I am a Dessert named strawberry
    cheesecake".
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Food类有一个__toString()方法，它生成类似"(FOOD) foodname"的字符串，例如"(FOOD) apple"。与此同时，Dessert子类通过自己的__toString()方法覆盖了这一行为，生成类似“我是一种名为foodname的甜点”的字符串，例如“我是一种名为草莓芝士蛋糕的甜点”。
- en: First, we’ll declare the Food class. Create a new project, then create *src/Food.php*
    containing the code in [Listing 19-13](#lis19-13).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明Food类。创建一个新项目，然后创建*src/Food.php*，并将[Listing 19-13](#lis19-13)中的代码填入其中。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 19-13: The Food class'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 19-13：Food类
- en: We declare the Food class with one string property, name, that has protected
    visibility so all subclasses can directly access it. The class has a constructor
    to initialize the name property when each new object is created, as well as the
    __toString() method shown in [Figure 19-5](#fig19-5).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明Food类，并给它一个名为name的字符串属性，该属性具有保护可见性，以便所有子类可以直接访问它。该类有一个构造函数，用于在创建每个新对象时初始化name属性，并且包含如[图19-5](#fig19-5)所示的__toString()方法。
- en: Let’s now declare Dessert as a subclass of Food. Create *src/Dessert.php* and
    enter the contents of [Listing 19-14](#lis19-14).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将Dessert声明为Food的子类。创建*src/Dessert.php*并输入[Listing 19-14](#lis19-14)中的内容。
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 19-14: The Dessert class, with its own __toString() method'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 19-14：Dessert类，包含自己的__toString()方法
- en: We declare that Dessert is a subclass of (extends) Food and give it its own
    __toString() method, as illustrated in [Figure 19-5](#fig19-5). Since PHP prioritizes
    methods declared lower in the class hierarchy, this __toString() method will override
    the __toString() method defined for the Food superclass. Notice that we’ve introduced
    a local $message variable in the Dessert class’s __toString() method. This variable
    may seem unnecessary now, but we’ll return to this example and add to the message
    later in the chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明Dessert是Food的一个子类（继承自Food），并为其提供自己的__toString()方法，如[图19-5](#fig19-5)所示。由于PHP优先使用类层级中较低位置声明的方法，因此这个__toString()方法将覆盖为Food父类定义的__toString()方法。请注意，我们在Dessert类的__toString()方法中引入了一个局部变量$message。这个变量现在看似不必要，但我们将在本章稍后回到这个示例，并将其添加到消息中。
- en: Test these classes by creating the *public/index.php* script that is shown in
    [Listing 19-15](#lis19-15). This script creates two objects, one Food object and
    one Dessert object, and prints out each, which will result in the objects’ __toString()
    methods being invoked.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建*public/index.php*脚本来测试这些类，该脚本在[Listing 19-15](#lis19-15)中有展示。这个脚本创建了两个对象，一个Food对象和一个Dessert对象，并打印出每个对象的内容，这将导致对象的__toString()方法被调用。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 19-15: Creating and printing Food and Dessert objects in index.php'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 19-15：在index.php中创建并打印Food和Dessert对象
- en: 'We read in and execute the class declarations for Food and Dessert, starting
    with the superclass. Then we create and print an object of each class, which will
    invoke the objects’ __toString() methods ❶. Here’s the browser output of running
    the web server and requesting a page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取并执行Food和Dessert类的声明，从父类开始。然后我们创建并打印每个类的对象，这将触发对象的__toString()方法❶。以下是运行Web服务器并请求页面后的浏览器输出：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the Dessert object outputs I am a Dessert named strawberry cheesecake,
    demonstrating that it successfully overrode the __toString() method inherited
    from Food with its own definition of this method. Overriding one method doesn’t
    disrupt the subclass’s inheritance of any other methods or properties from its
    superclass, however. In this case, the Dessert object still successfully inherited
    the name property and __construct() method from Food.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Dessert对象输出“我是一种名为草莓芝士蛋糕的甜点”，这表明它成功地重写了从Food继承的__toString()方法，并用自己的方法定义来替代。重写一个方法并不会打乱子类继承父类的其他方法或属性。然而，在这个例子中，Dessert对象依然成功地继承了Food中的name属性和__construct()方法。
- en: Augmenting Inherited Behavior
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展继承行为
- en: 'Sometimes, rather than completely replace (override) an inherited method, you
    might want to *augment* the inherited method with additional behavior specific
    to the subclass. PHP provides the keyword parent for this purpose: it allows you
    to reference a superclass’s method or property from within a subclass declaration
    file. To illustrate, we’ll modify the __toString() method of the Dessert subclass.
    It will now generate a string by using the __toString() method from the parent
    Food class, then add a special message specific to Dessert objects. Update *src/Dessert.php*
    as shown in [Listing 19-16](#lis19-16).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能并不希望完全替换（覆盖）继承的方法，而是想要*增强*继承的方法，加入特定于子类的附加行为。PHP提供了关键字parent来实现这一点：它允许你在子类声明文件中引用父类的方法或属性。为了说明这一点，我们将修改Dessert子类的__toString()方法。它将通过使用父类Food的__toString()方法生成一个字符串，然后添加一个特定于Dessert对象的特殊消息。请按照[Listing
    19-16](#lis19-16)中的示例更新*src/Dessert.php*。
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 19-16: The updated __toString() method of the Dessert subclass'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 19-16：Dessert子类更新后的__toString()方法
- en: We invoke the __toString() method of the superclass (Food), storing the result
    into the $message variable. To access the superclass method, we use the keyword
    parent, then the double-colon *scope-resolution operator* (::), then the name
    of the method. Next, we use string concatenation to append " I am a Dessert!"
    to the end of the message. All this happens within the definition of the Dessert
    class’s __toString() method, meaning we’re still technically overriding the __toString()
    method from the superclass. It’s just that we’re using parent to access the method
    definition from the superclass as we override it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了父类（Food）的__toString()方法，并将结果存储到$message变量中。要访问父类方法，我们使用关键字parent，然后是双冒号*作用域解析操作符*（::），接着是方法名。接下来，我们使用字符串拼接将“
    I am a Dessert!”添加到消息的末尾。所有这些都发生在Dessert类的__toString()方法的定义中，这意味着我们仍然在技术上覆盖了父类的__toString()方法。只是我们通过parent来访问父类的方法定义，同时进行覆盖。
- en: 'Visit the index web page now and you should see the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问索引网页，你应该能看到如下内容：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The string returned by the Dessert object is a combination of the string "(FOOD)
    strawberry cheesecake" generated by the Food class’s __toString() method, plus
    the Dessert object–specific "I am a Dessert!" message added to the end.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Dessert对象返回的字符串是由Food类的__toString()方法生成的字符串“(FOOD)草莓芝士蛋糕”，加上Dessert对象特有的“ I
    am a Dessert!”消息拼接而成的。
- en: 'Instead of using parent:: to access a method from a superclass, you can explicitly
    refer to the superclass by name, such as Food:: in our example. This is most useful
    in multilevel class hierarchies (for example, D is a subclass of C is a subclass
    of B is a subclass of A), where you may wish to reference an inherited class higher
    up in the hierarchy rather than the direct parent. In this case, naming the class
    explicitly is the only option, since the parent keyword always refers to the direct
    parent class.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过显式地按名称引用父类，而不是使用parent::来访问父类的方法，例如在我们的例子中是Food::。在多层次的类层级结构中（例如，D是C的子类，C是B的子类，B是A的子类），这非常有用，你可能希望引用层级结构中更高处的继承类，而不是直接的父类。在这种情况下，显式命名类是唯一的选择，因为parent关键字总是指向直接的父类。
- en: One common reason to augment a method rather than fully override it is to create
    a constructor tailored to a subclass. If the subclass has all the properties of
    the superclass plus some of its own, it’s efficient to create a constructor that
    starts by using parent::__construct() to invoke the superclass’s constructor and
    finishes by setting the properties specific to the subclass. This way, you get
    to reuse any validation or other important logic in the superclass constructor
    method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 增强方法而不是完全覆盖方法的一个常见原因是创建一个适用于子类的构造函数。如果子类拥有父类的所有属性加上它自己的一些属性，那么创建一个构造函数，首先使用parent::__construct()调用父类的构造函数，然后再设置特定于子类的属性，这样就很高效。这样，你可以重用父类构造方法中的任何验证或其他重要逻辑。
- en: NOTE
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Constructors are exempt from the method signature rules of the LSP. It’s okay
    if the parameter lists of the subclass and superclass constructors aren’t compatible,
    as when the subclass constructor has extra, mandatory parameters.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数不受LSP方法签名规则的约束。如果子类和父类构造函数的参数列表不兼容，也没关系，就像子类构造函数有额外的强制性参数一样。*'
- en: To demonstrate how to augment a constructor, we’ll add a new calories property
    to Dessert objects. Then we’ll create a constructor for Dessert objects that augments
    the Food constructor by setting calories as well as name. Update the *src/Dessert.php*
    file to match the code in [Listing 19-17](#lis19-17).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 19-17: Adding an augmented constructor to the Dessert class'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the new calories property and make it private (since we don’t have
    any subclasses of Dessert for this project). Then we declare a constructor method
    that takes in two parameters, the name and calories for the new Dessert object
    to be created ❶. Within the method definition, we use parent:: to invoke the constructor
    method for the Food superclass, setting the name property in the process. Then
    we finish the Dessert constructor by setting the calories property for the object.
    We use the setter method setCalories(), which we declare next ❷. Finally, we update
    the __toString() method to also output the value of the calories property for
    the object so we’ll know the code is working.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We now need to add a value for the calories property in our index script when
    we create a Dessert object. Update *public/index.php* to match the code in [Listing
    19-18](#lis19-18).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 19-18: Adding a calories argument to the index script'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a Dessert object with two arguments corresponding to the name and
    calories properties. Here’s the result of visiting the web page:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second message demonstrates that both Dessert object properties were successfully
    set by the class’s constructor method, which augments that of its superclass.
    Also, it shows that we successfully augmented the __toString() method of the Dessert
    subclass with a call to its parent superclass __toString() method.  ### Preventing
    Subclassing and Overriding'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In certain situations, you might never want to allow a subclass to be created
    from a class you declare. In this case, declare the class with the final keyword,
    which prevents other classes from extending (subclassing) the class. The keyword
    goes at the very start of the class declaration (for example, final class Dessert).
    You can also add the final keyword to the declaration of an individual method
    to prevent the method from being overridden by a subclass.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of final, especially for whole classes, is the subject of heated debate
    in the OOP community. It’s wise to declare classes or methods as final only if
    you have a good justification for doing so. For example, if you have an API library,
    you might declare a class as final to prevent anyone from subclassing it, since
    you don’t want to allow or encourage programmers to expect different behaviors
    besides those declared in the API. The final declaration also helps prevent code
    from breaking between versions and across updates: when a class is final, changes
    to the class’s internal implementation (private methods and properties) won’t
    have any unintended consequences outside the class.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class final
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create an example of a final class and see how an error occurs if we try
    to declare a subclass of it. Start a new project and create *src/Product.php*
    as shown in [Listing 19-19](#lis19-19).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 19-19: The Product class, declared as final'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Product class, designating it as final ❶. This simple class has
    properties for a stock keeping unit (SKU) number and a text description, which
    are set in the class’s constructor ❷. It also has a getter method for each property.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll attempt to extend Product by declaring a subclass. Create *src/MyProduct.php*
    containing the code in [Listing 19-20](#lis19-20).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 19-20: The MyProduct subclass of Product'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We declare that MyProduct is a subclass of Product, while leaving its body blank.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Now create a *public/index.php* script that reads in the two class declarations,
    as shown in [Listing 19-21](#lis19-21).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 19-21: An index script reading the Product and MyProduct declarations'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need any more than these two require_once statements to demonstrate
    that classes declared final can’t be extended. Execute the index script and you
    should see this: Fatal error: Class MyProduct may not inherit from final class
    Product.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Method final
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Declaring specific methods final prevents them from being overridden while still
    allowing the class to have subclasses. Among other applications, this technique
    ensures that a method has consistent validation logic at all levels of the class
    hierarchy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s modify our Product class, removing its overall final declaration
    and adding a new method to set the skuId property. The method will have validation
    to ensure that the SKU number is greater than 0\. We’ll declare this method final,
    so no subclass can replace it with a method that doesn’t contain the validation
    logic. Update the Product class declaration as shown in [Listing 19-22](#lis19-22).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 19-22: Adding a final method to the Product class'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We remove the final keyword from the overall class declaration, allowing this
    class to be extended, and we change the visibility of the skuId property to protected
    so it can be used in subclass methods. Then we add a new final setter method for
    the skuId property that confirms the desired value is greater than 0.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Now update the MyProduct class to match the contents of [Listing 19-23](#lis19-23),
    where we attempt to override the setSkuId() method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 19-23: Overriding the setSkuId() method in MyProduct'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'We attempt to declare a setSkuId() method directly on the MyProduct class ❶,
    without the greater-than-zero validation check. This isn’t permitted, since the
    setSkuId() method in the Product superclass has been declared final. If you run
    the index script again, you should see another fatal error noting that the Product
    class’s setSkuId() method can’t be overridden.  ### Summary'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored several OOP features, most notably inheritance
    between classes. We also covered the related topics of protected visibility, which
    enables access to inherited properties and methods by subclasses, as well as method
    overriding and the invocation of inherited method behavior with the parent keyword.
    Finally, we looked at how to restrict the usage of classes and methods through
    the abstract and final keywords.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Implement the Jam class diagrammed in [Figure 19-6](#fig19-6).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-6.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-6: The Jam class and its $food1 object'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Write an index script to create the $food1 object of the Jam class shown in
    the diagram. Use a print statement to invoke the object’s __toString() method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Make a copy of your project from Exercise 1\. Create two new classes,
    Spread and Honey, and simplify the Jam class as shown in [Figure 19-7](#fig19-7).
    Note the visibility of the properties for the Spread class: # for protected and
    + for public.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-7.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-7: The Jam and Honey subclasses inheriting from Spread'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Update your index script to create and print one Jam object and one Honey object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: You may wish to simplify your string-creation code by creating a private
    helper method manukaString() that returns the string (Manuka) or (NOT Manuka)
    depending on the value of the isManuka property.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Examine the Car and Van classes in [Figure 19-8](#fig19-8) and plan out
    an abstract superclass to hold the common members of both classes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-8.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-8: The Car and Van classes'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Declare your superclass, as well as the Car and Van classes. Then write an index
    script that creates one Car and one Van object and uses print statements to invoke
    their __toString() methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Test out the use of the final keyword to prevent subclasses. Make a copy
    of your project from Exercise 2 and replace the abstract keyword with the final
    keyword at the beginning of your Spread class declaration. Run your index script,
    and the Jam and Honey class declarations should trigger a fatal error.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
