- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 19 INHERITANCE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter covers perhaps the most powerful and important feature of OOP:
    *inheritance*. This is the capability of one or more classes, called *subclasses*,
    to automatically have all the same properties and methods as another class, called
    a *superclass*. Inheritance makes OOP more efficient: you have to define any general,
    shared members only once, in the superclass. Objects of the subclasses inherit
    those properties and methods, and they will also have whatever properties and
    methods are specific to the individual subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Associated with inheritance is the capability of subclasses to *override* inherited
    methods from their superclass when that general method isn’t appropriate to the
    particular subclass. As we’ll explore in this chapter, you can also have the best
    of both worlds (executing the inherited method *and* adding additional behavior
    through the subclass’s method) by using the parent keyword. Additionally, we’ll
    discuss the third kind of protection PHP offers for methods and properties: protected.
    You’ll learn what distinguishes protected members of a class from public and private
    members, and when to use each visibility designation.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance as Generalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance simplifies code by identifying and generalizing properties and behaviors
    shared among classes of objects. Consider the properties identified for Car and
    Boat objects shown in [Figure 19-1](#fig19-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-1: The Car and Boat classes, with common properties shown in bold'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three properties of each class are identical: both Car and Boat objects
    have a make and model, a number of passengers, and a top speed. To avoid redundancy,
    we can generalize these common properties (and any associated methods) into a
    superclass, which we’ll name Vehicle. [Figure 19-2](#fig19-2) shows this generalized
    Vehicle class with the three shared properties, as well as the simplified Car
    and Boat classes, each now with just one property of its own.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-2: The Vehicle superclass and the Car and Boat subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: The arrows going from Car and Boat to Vehicle indicate that both Car and Boat
    inherit from Vehicle; that is, Car and Boat are subclasses of the generalized
    Vehicle superclass. Notice that the visibility of the properties (public versus
    private) hasn’t been indicated in the diagram. For now, we’ll implement the classes
    by using simple public properties. Later in the chapter, we’ll refactor the classes
    by using the third visibility setting, protected.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-1 implements the Vehicle class shown in [Figure 19-2](#fig19-2).
    Start a new project and create *src/Vehicle.php* containing the code in this listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-1: Implementing the Vehicle superclass'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the Vehicle class with three public properties: makeModel, numPassengers,
    and topSpeed.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 19-2 implements the Car subclass of Vehicle, which should be created
    in *src/Car.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-2: Implementing Car as a subclass of Vehicle'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that Car should be a subclass of Vehicle simply by adding the extends
    keyword followed by the superclass name at the start of the class declaration.
    Any Car objects we create will automatically inherit all the properties and methods
    from the Vehicle superclass, in addition to having the bodyShape property declared
    directly in the Car class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Objects from Subclasses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To verify that our example of inheritance works, we’ll create a Car object and
    set values for its properties—both the one declared directly in Car and the ones
    inherited from Vehicle. Create *public/index.php* containing the code in [Listing
    19-3](#lis19-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-3: Creating a Car object in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first read in the files declaring the Vehicle and Car classes. It’s imperative
    to read in declarations for *all* the classes the code uses, including inherited
    classes such as Vehicle, even though we won’t be directly creating objects of
    this class. The order we read in the files is important too: for the Car class
    to be able to extend the Vehicle class, we must have read in and executed the
    declaration for the Vehicle class *before* reading in and declaring the Car class.
    Otherwise, we’ll get an error about the Vehicle class not being found.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Large projects may require tens, or even hundreds, of class declarations.
    In [Chapter 20](chapter20.xhtml), we’ll look at a way to read in all the class
    declarations in the required sequence with a single statement, using a script
    called an* autoloader*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a new Car object and store a reference to it in the $car1 variable.
    Then we set values for the bodyShape, makeModel, numPassengers, and topSpeed properties.
    The syntax is the same whether the property was declared for the subclass or inherited
    from the superclass: either way, we simply use $car1->propertyName = value. Finally,
    we use var_dump() to output structured information about the $car1 variable and
    the object it refers to in memory. Here’s the result of running the index script
    at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Car object indeed has four properties, and we’ve successfully set all four,
    including the property declared in *Car.php* (bodyShape) and the three properties
    inherited from the Vehicle superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s complete our implementation of the class hierarchy from [Figure 19-2](#fig19-2)
    by declaring the Boat subclass. Create *src/Boat.php* and enter the code in [Listing
    19-4](#lis19-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-4: Implementing the Boat class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that Boat should inherit from Vehicle, once again using the extends
    keyword to establish the subclass/superclass relationship. The class has only
    one unique property, countryOfRegistration, but Boat objects will also inherit
    the three public properties of makeModel, numPassengers, and topSpeed from Vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple Levels of Inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Class hierarchies can involve many levels of inheritance: class A could have
    a subclass B, class B could have a subclass C, and so on. In this case, class
    C would inherit methods and properties from both class B, its immediate superclass,
    and from class A, the superclass of its superclass. [Figure 19-3](#fig19-3) illustrates
    how we might use this mechanism to further extend our hierarchy of vehicular classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-3: A three-level class hierarchy, with subclasses of subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class hierarchy features two subclasses of Boat: MotorBoat and SailBoat.
    All MotorBoat and SailBoat objects will inherit the properties and methods of
    Boat, their superclass. That includes the properties and methods that Boat inherits
    from Vehicle. Meanwhile, MotorBoat objects will also have a special property of
    their own, engineSize, while SailBoat will have a unique numberOfMasts property.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to declare the MotorBoat class, we’d start by writing class
    MotorBoat extends Boat. We don’t need to also mention Vehicle in the MotorBoat
    class declaration; the inheritance from Vehicle is already covered in the *src/Boat.php*
    class-declaration file.
  prefs: []
  type: TYPE_NORMAL
- en: Like most object-oriented languages, PHP permits each class to have only a single
    direct superclass. This safeguard prevents ambiguities as to where a property
    or method is being inherited from, but it also adds challenges when it comes to
    designing class hierarchies. For example, since cars and motorboats both have
    engines, it might make sense to create a MotorizedVehicle subclass of Vehicle.
    The Car class would naturally inherit from MotorizedVehicle, but what about MotorBoat?
    Should it inherit from Boat or MotorizedVehicle? It can inherit directly from
    only one or the other. As this example illustrates, once class hierarchies get
    more complex, care must be taken in their design.
  prefs: []
  type: TYPE_NORMAL
- en: Protected Visibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the introduction of inheritance, a third visibility keyword, besides public
    and private, becomes relevant: protected. When a method or property is declared
    protected, it becomes accessible to any subclasses that inherit it, but it can’t
    be accessed by code elsewhere in the project. For example, a protected property
    of the Vehicle superclass could be accessed within *Car.php*, since Car inherits
    from Vehicle. By contrast, that protected property couldn’t be accessed within
    the general *index.php* file.'
  prefs: []
  type: TYPE_NORMAL
- en: The protected visibility designation is more restrictive than public, since
    public properties and methods can be accessed from anywhere within the project
    code. On the other hand, protected is less restrictive than private. When a method
    or property is private, it’s accessible only within the class itself; not even
    methods of subclasses can directly access private properties and methods from
    their superclass.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the distinction between the three visibility keywords, we’ll refactor
    the Vehicle class. To begin, we’ll update the class to have private properties
    and public accessor methods, as we discussed in [Chapter 18](chapter18.xhtml).
    Then we’ll add the protected designation into the mix. [Listing 19-5](#lis19-5)
    shows the first changes to *src/Vehicle.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-5: Revising the Vehicle class to have private properties and public
    accessor methods'
  prefs: []
  type: TYPE_NORMAL
- en: We declare all three class properties as private rather than public. This means
    they can’t be set directly. Instead, we’ve declared public getter and setter methods
    for each property ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to update the index script to use the setter methods to set values
    for the Car object. Modify *public/index.php* to match the code in [Listing 19-6](#lis19-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-6: Updating index.php to set inherited properties via setter methods'
  prefs: []
  type: TYPE_NORMAL
- en: We can still directly access the bodyShape property declared in the Car class
    ❶, since it’s still set as public. However, we now need to use the setter methods
    to assign values to the three inherited properties, makeModel, numPassengers,
    and topSpeed, since these properties are now declared as private in the Vehicle
    superclass. The Car object inherits the accessor methods from Vehicle, just as
    it inherits the properties themselves. Thanks to the accessor methods, var_dump()
    will work as before.
  prefs: []
  type: TYPE_NORMAL
- en: Using public setter methods to update private properties within *index.php*
    makes sense; this is exactly what we did in [Chapter 18](chapter18.xhtml). But
    what if we want to use one of the properties inherited from Vehicle as part of
    a method declared in the Car class? Let’s try this and see what happens. We’ll
    add a new getMakeModelShape() method to Car that returns a string summary of some
    of the object’s properties. Update *src/Car.php* to match the code in [Listing
    19-7](#lis19-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-7: Trying to access private superclass properties from a subclass'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the new getMakeModelShape() method in the Car class. This method
    attempts to insert the values of the makeModel and bodyShape properties into a
    string. To see whether this method works, we’ll invoke it in our index script.
    Update *public/index.php* as shown in [Listing 19-8](#lis19-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-8: Testing the getMakeModelShape() method in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve replaced the var_dump() function call with a print statement invoking
    the getMakeModelShape() method of our $car1 object reference. However, if you
    now run the index script, you’ll get an Undefined property warning, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Statements in our Car class methods have no access to inherited private properties,
    so the PHP engine simply can’t find a makeModel property when it executes getMakeModelShape().
    Notice, however, that the warning message is followed by the text , Sedan. This
    indicates that the index script continued executing despite the issue. Indeed,
    after continuing from its undefined property warning, the PHP engine had no problem
    with the $this->bodyShape portion of the getMakeModelShape() method, since bodyShape
    is a property defined directly on the Car class itself.
  prefs: []
  type: TYPE_NORMAL
- en: One way for us to access the value of an inherited property could be to use
    the public getter method to access the makeModel property, but in some situations
    it’s best not to offer public getter or setter methods for a property. A better
    solution when you want to give methods of a subclass direct access to a property
    or method inherited from its superclass, without making that property or method
    public, is to give the property or method protected visibility. For that, update
    the Vehicle class as shown in [Listing 19-9](#lis19-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-9: Using protected visibility for makeModel in the Vehicle class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now declare the Vehicle property makeModel to have protected visibility
    ❶, which means it can be accessed directly by statements in the Car subclass.
    Re-execute the index script and you’ll see the make, model, and shape string output
    with no warnings: Ford Mustang, Sedan.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-4](#fig19-4) shows the UML diagram for our three classes, updated
    to indicate the visibility of each class property and method.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-4: An updated UML diagram showing the visibility settings for the
    class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Within the Vehicle class, the hash mark (#) indicates the protected visibility
    of the makeModel property, while the other two properties are shown as private
    with minus signs. All properties and methods for classes Car and Boat are public
    and so indicated with plus signs. The *«get/set»* annotations in the diagram indicate
    public getter and setter accessor methods for all three properties of the Vehicle
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates the distinction between private and protected. To
    illustrate the difference between the public and protected visibility of properties,
    let’s modify the *public/index.php* script to try to directly set the value of
    the makeModel property. Update the index script to match [Listing 19-10](#lis19-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-10: Illustrating the difference between public and protected visibility'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the value of the public bodyShape property to ''Sedan'' as before. Then
    we attempt to directly change the value stored in the makeModel property of $car1
    to the string ''Ford Mustang''. Execute this script and you’ll get a fatal error,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The makeModel property has protected visibility, so it can’t be accessed from
    our index script. Only subclasses of Vehicle can access the property directly.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *abstract class* is one that will never be used to create objects. Instead,
    abstract classes are commonly declared so their members (properties and methods)
    can be inherited by subclasses. The Vehicle class, for example, is an abstract
    class. We’ll never want to create a Vehicle object; we declared the class only
    to generalize common properties and methods from the Car and Boat classes.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of abstract classes is to declare static members, properties, or
    methods that relate to the class as a whole rather than to individual objects.
    We’ll explore static members in [Chapter 25](chapter25.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: It’s good practice to be as specific as possible about how a class and its members
    will be used. For that reason, if you know a class is abstract, it’s best to include
    the abstract keyword when you’re declaring it. This keyword ensures that no object
    of the class can be created without triggering an error. To demonstrate, we’ll
    add the abstract keyword to our Vehicle class declaration. Update *src/Vehicle.php*
    as shown in [Listing 19-11](#lis19-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-11: Declaring Vehicle as an abstract class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that Vehicle is an abstract class by adding abstract immediately
    before the class keyword. If you run the index script again after making this
    change, you’ll see no difference in the behavior of the program. However, if you
    now attempt to create a Vehicle object, as shown in [Listing 19-12](#lis19-12),
    a fatal error will occur. Update *public/index.php* to match the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-12: Attempting to create an object of the abstract Vehicle class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We attempt to create an object of the Vehicle class and store a reference to
    the created object in the $vehicle1 variable ❶. Here’s what happens if you try
    to run this index script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A fatal error occurs, with the message Cannot instantiate abstract class. This
    is exactly what we want: by declaring the Vehicle class to be abstract, we’ve
    guaranteed that no Vehicle objects can be created.'
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Inherited Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, you might want to change the way an inherited method behaves
    on a subclass, as compared to the way it’s defined in the superclass. This is
    called *overriding* the method, and you do it by defining the method directly
    on the subclass and giving it the same name as the method inherited from the superclass.
    PHP gives precedence to properties and methods defined lower in the class hierarchy,
    so it will execute the method definition from the subclass rather than the one
    from the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate with a superclass that declares a __toString() method, then
    a subclass that overrides this declaration with its own __toString() implementation.
    [Figure 19-5](#fig19-5) shows the UML diagram for the two classes we’ll use to
    investigate how to override inherited methods, with notes to indicate how each
    __toString() method should behave. We’ll be creating a general Food class and
    a Dessert subclass of Food.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-5: The Dessert subclass overrides the __toString() method inherited
    from Food.'
  prefs: []
  type: TYPE_NORMAL
- en: The Food class has a __toString() method that generates a string in the form
    "(FOOD) foodname", such as "(FOOD) apple". Meanwhile, the Dessert subclass overrides
    this behavior with its own __toString() method that generates a string in the
    form "I am a Dessert named foodname", such as "I am a Dessert named strawberry
    cheesecake".
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll declare the Food class. Create a new project, then create *src/Food.php*
    containing the code in [Listing 19-13](#lis19-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-13: The Food class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Food class with one string property, name, that has protected
    visibility so all subclasses can directly access it. The class has a constructor
    to initialize the name property when each new object is created, as well as the
    __toString() method shown in [Figure 19-5](#fig19-5).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now declare Dessert as a subclass of Food. Create *src/Dessert.php* and
    enter the contents of [Listing 19-14](#lis19-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-14: The Dessert class, with its own __toString() method'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that Dessert is a subclass of (extends) Food and give it its own
    __toString() method, as illustrated in [Figure 19-5](#fig19-5). Since PHP prioritizes
    methods declared lower in the class hierarchy, this __toString() method will override
    the __toString() method defined for the Food superclass. Notice that we’ve introduced
    a local $message variable in the Dessert class’s __toString() method. This variable
    may seem unnecessary now, but we’ll return to this example and add to the message
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Test these classes by creating the *public/index.php* script that is shown in
    [Listing 19-15](#lis19-15). This script creates two objects, one Food object and
    one Dessert object, and prints out each, which will result in the objects’ __toString()
    methods being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-15: Creating and printing Food and Dessert objects in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We read in and execute the class declarations for Food and Dessert, starting
    with the superclass. Then we create and print an object of each class, which will
    invoke the objects’ __toString() methods ❶. Here’s the browser output of running
    the web server and requesting a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the Dessert object outputs I am a Dessert named strawberry cheesecake,
    demonstrating that it successfully overrode the __toString() method inherited
    from Food with its own definition of this method. Overriding one method doesn’t
    disrupt the subclass’s inheritance of any other methods or properties from its
    superclass, however. In this case, the Dessert object still successfully inherited
    the name property and __construct() method from Food.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting Inherited Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, rather than completely replace (override) an inherited method, you
    might want to *augment* the inherited method with additional behavior specific
    to the subclass. PHP provides the keyword parent for this purpose: it allows you
    to reference a superclass’s method or property from within a subclass declaration
    file. To illustrate, we’ll modify the __toString() method of the Dessert subclass.
    It will now generate a string by using the __toString() method from the parent
    Food class, then add a special message specific to Dessert objects. Update *src/Dessert.php*
    as shown in [Listing 19-16](#lis19-16).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-16: The updated __toString() method of the Dessert subclass'
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the __toString() method of the superclass (Food), storing the result
    into the $message variable. To access the superclass method, we use the keyword
    parent, then the double-colon *scope-resolution operator* (::), then the name
    of the method. Next, we use string concatenation to append " I am a Dessert!"
    to the end of the message. All this happens within the definition of the Dessert
    class’s __toString() method, meaning we’re still technically overriding the __toString()
    method from the superclass. It’s just that we’re using parent to access the method
    definition from the superclass as we override it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the index web page now and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The string returned by the Dessert object is a combination of the string "(FOOD)
    strawberry cheesecake" generated by the Food class’s __toString() method, plus
    the Dessert object–specific "I am a Dessert!" message added to the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using parent:: to access a method from a superclass, you can explicitly
    refer to the superclass by name, such as Food:: in our example. This is most useful
    in multilevel class hierarchies (for example, D is a subclass of C is a subclass
    of B is a subclass of A), where you may wish to reference an inherited class higher
    up in the hierarchy rather than the direct parent. In this case, naming the class
    explicitly is the only option, since the parent keyword always refers to the direct
    parent class.'
  prefs: []
  type: TYPE_NORMAL
- en: One common reason to augment a method rather than fully override it is to create
    a constructor tailored to a subclass. If the subclass has all the properties of
    the superclass plus some of its own, it’s efficient to create a constructor that
    starts by using parent::__construct() to invoke the superclass’s constructor and
    finishes by setting the properties specific to the subclass. This way, you get
    to reuse any validation or other important logic in the superclass constructor
    method.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Constructors are exempt from the method signature rules of the LSP. It’s okay
    if the parameter lists of the subclass and superclass constructors aren’t compatible,
    as when the subclass constructor has extra, mandatory parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to augment a constructor, we’ll add a new calories property
    to Dessert objects. Then we’ll create a constructor for Dessert objects that augments
    the Food constructor by setting calories as well as name. Update the *src/Dessert.php*
    file to match the code in [Listing 19-17](#lis19-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-17: Adding an augmented constructor to the Dessert class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the new calories property and make it private (since we don’t have
    any subclasses of Dessert for this project). Then we declare a constructor method
    that takes in two parameters, the name and calories for the new Dessert object
    to be created ❶. Within the method definition, we use parent:: to invoke the constructor
    method for the Food superclass, setting the name property in the process. Then
    we finish the Dessert constructor by setting the calories property for the object.
    We use the setter method setCalories(), which we declare next ❷. Finally, we update
    the __toString() method to also output the value of the calories property for
    the object so we’ll know the code is working.'
  prefs: []
  type: TYPE_NORMAL
- en: We now need to add a value for the calories property in our index script when
    we create a Dessert object. Update *public/index.php* to match the code in [Listing
    19-18](#lis19-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-18: Adding a calories argument to the index script'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a Dessert object with two arguments corresponding to the name and
    calories properties. Here’s the result of visiting the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second message demonstrates that both Dessert object properties were successfully
    set by the class’s constructor method, which augments that of its superclass.
    Also, it shows that we successfully augmented the __toString() method of the Dessert
    subclass with a call to its parent superclass __toString() method.  ### Preventing
    Subclassing and Overriding'
  prefs: []
  type: TYPE_NORMAL
- en: In certain situations, you might never want to allow a subclass to be created
    from a class you declare. In this case, declare the class with the final keyword,
    which prevents other classes from extending (subclassing) the class. The keyword
    goes at the very start of the class declaration (for example, final class Dessert).
    You can also add the final keyword to the declaration of an individual method
    to prevent the method from being overridden by a subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of final, especially for whole classes, is the subject of heated debate
    in the OOP community. It’s wise to declare classes or methods as final only if
    you have a good justification for doing so. For example, if you have an API library,
    you might declare a class as final to prevent anyone from subclassing it, since
    you don’t want to allow or encourage programmers to expect different behaviors
    besides those declared in the API. The final declaration also helps prevent code
    from breaking between versions and across updates: when a class is final, changes
    to the class’s internal implementation (private methods and properties) won’t
    have any unintended consequences outside the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class final
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create an example of a final class and see how an error occurs if we try
    to declare a subclass of it. Start a new project and create *src/Product.php*
    as shown in [Listing 19-19](#lis19-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-19: The Product class, declared as final'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Product class, designating it as final ❶. This simple class has
    properties for a stock keeping unit (SKU) number and a text description, which
    are set in the class’s constructor ❷. It also has a getter method for each property.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll attempt to extend Product by declaring a subclass. Create *src/MyProduct.php*
    containing the code in [Listing 19-20](#lis19-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-20: The MyProduct subclass of Product'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that MyProduct is a subclass of Product, while leaving its body blank.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a *public/index.php* script that reads in the two class declarations,
    as shown in [Listing 19-21](#lis19-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-21: An index script reading the Product and MyProduct declarations'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need any more than these two require_once statements to demonstrate
    that classes declared final can’t be extended. Execute the index script and you
    should see this: Fatal error: Class MyProduct may not inherit from final class
    Product.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Method final
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Declaring specific methods final prevents them from being overridden while still
    allowing the class to have subclasses. Among other applications, this technique
    ensures that a method has consistent validation logic at all levels of the class
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s modify our Product class, removing its overall final declaration
    and adding a new method to set the skuId property. The method will have validation
    to ensure that the SKU number is greater than 0\. We’ll declare this method final,
    so no subclass can replace it with a method that doesn’t contain the validation
    logic. Update the Product class declaration as shown in [Listing 19-22](#lis19-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-22: Adding a final method to the Product class'
  prefs: []
  type: TYPE_NORMAL
- en: We remove the final keyword from the overall class declaration, allowing this
    class to be extended, and we change the visibility of the skuId property to protected
    so it can be used in subclass methods. Then we add a new final setter method for
    the skuId property that confirms the desired value is greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Now update the MyProduct class to match the contents of [Listing 19-23](#lis19-23),
    where we attempt to override the setSkuId() method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-23: Overriding the setSkuId() method in MyProduct'
  prefs: []
  type: TYPE_NORMAL
- en: 'We attempt to declare a setSkuId() method directly on the MyProduct class ❶,
    without the greater-than-zero validation check. This isn’t permitted, since the
    setSkuId() method in the Product superclass has been declared final. If you run
    the index script again, you should see another fatal error noting that the Product
    class’s setSkuId() method can’t be overridden.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored several OOP features, most notably inheritance
    between classes. We also covered the related topics of protected visibility, which
    enables access to inherited properties and methods by subclasses, as well as method
    overriding and the invocation of inherited method behavior with the parent keyword.
    Finally, we looked at how to restrict the usage of classes and methods through
    the abstract and final keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Implement the Jam class diagrammed in [Figure 19-6](#fig19-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-6: The Jam class and its $food1 object'
  prefs: []
  type: TYPE_NORMAL
- en: Write an index script to create the $food1 object of the Jam class shown in
    the diagram. Use a print statement to invoke the object’s __toString() method.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Make a copy of your project from Exercise 1\. Create two new classes,
    Spread and Honey, and simplify the Jam class as shown in [Figure 19-7](#fig19-7).
    Note the visibility of the properties for the Spread class: # for protected and
    + for public.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-7: The Jam and Honey subclasses inheriting from Spread'
  prefs: []
  type: TYPE_NORMAL
- en: Update your index script to create and print one Jam object and one Honey object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: You may wish to simplify your string-creation code by creating a private
    helper method manukaString() that returns the string (Manuka) or (NOT Manuka)
    depending on the value of the isManuka property.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Examine the Car and Van classes in [Figure 19-8](#fig19-8) and plan out
    an abstract superclass to hold the common members of both classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure19-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19-8: The Car and Van classes'
  prefs: []
  type: TYPE_NORMAL
- en: Declare your superclass, as well as the Car and Van classes. Then write an index
    script that creates one Car and one Van object and uses print statements to invoke
    their __toString() methods.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Test out the use of the final keyword to prevent subclasses. Make a copy
    of your project from Exercise 2 and replace the abstract keyword with the final
    keyword at the beginning of your Spread class declaration. Run your index script,
    and the Jam and Honey class declarations should trigger a fatal error.
  prefs: []
  type: TYPE_NORMAL
