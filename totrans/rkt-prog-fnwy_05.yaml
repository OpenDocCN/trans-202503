- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GUI: GETTING USERS INTERESTED'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: GUI (pronounced gooey) stands for graphical user interface. This is just a fancy
    term for any program that has graphical elements as opposed to just being text-based.
    Graphical elements can consist of static images or drawings, as we explored in
    the previous chapter, or interactive elements like buttons and menus. Aside from
    just graphical elements, GUIs introduce the *event* paradigm—events trigger actions.
    An event can be anything from a key press or mouse click to a timer going off.
    Racket not only supports building mini-applications, but also stand-alone executables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll bring our old friend the cycloid to life with an animation,
    learn some new (card) tricks, and make the Tower of Hanoi more than just an intellectual
    exercise.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GUIs
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Racket GUI programming makes use of the *racket/gui/base* library, which can
    be imported with the `(require racket/gui/base)` statement. Alternatively, you
    may use the language switch `#lang racket/gui`, which includes both the base Racket
    libraries and the GUI library. Here’s a little code snippet that does nothing
    more than create and display a window frame 300 by 200 pixels.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should note that the frame size is the size of the exterior window and includes
    the size of the title bar and any window borders. The frame interior will be somewhat
    smaller.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The code below shows something a bit more exciting that demonstrates the basic
    idea of how to respond to an event.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `message%` object ➊ creates a label with the text “Hi, there!” (`message%`
    objects are a bit more powerful than you might expect; they can also contain a
    bitmap as the label). GUI objects must normally specify the parent frame that
    they are contained in ➋. We’ve also defined the `auto-resize` parameter so that
    the message control will expand if the text is larger than it was initialized
    with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a `button%` object ➌ and make it a child of the `main-frame`
    window. Buttons can respond to being clicked on with the mouse. This is handled
    with a `callback` option ➍. This takes a function (in this case a lambda expression)
    that accepts two parameters. When the button is clicked, the window event processor
    will pass the callback function a pointer to the button object and an event object
    that contains information about the event (we don’t use them here; we just need
    to know that the button was clicked). In our case, we send the `msg` object a
    command for it to set its label to a new value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch5fig1) shows how the thing will look (depending on
    your operating system, it may be slightly different).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Simple GUI application*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try our hand at a bit of animation. We’ll begin simply, by just moving
    a little red circle across the screen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we create a `canvas%` object within the `frame%` object. This
    is the same canvas object we explored in the previous chapter, so all the drawing
    commands we saw previously are available. The `canvas` object supports a `paint-callback`
    event ➊. This event is triggered whenever the canvas needs to be repainted (note
    that a drawing context, `dc`, is provided to the callback function). By default
    it’s triggered when the canvas is first displayed, but we force it to be refreshed
    by using a `timer%` object ➋. The canvas object draws the ball at `(loc-x, loc-y)`,
    so our timer will update the `loc-x` value every time it’s called. The timer responds
    to an event called `notify-callback` ➌. When this event is triggered, it forces
    the canvas to refresh itself by sending it a `refresh-now` message ➎. The timer
    callback also increments the `loc-x` variable ➍. This entire process is kicked
    off with the last line of code. We send the timer object a message to start triggering
    itself every 50 milliseconds ➏.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们在`frame%`对象中创建了一个`canvas%`对象。这是我们在上一章中探讨过的相同画布对象，因此之前看到的所有绘图命令都可用。`canvas`对象支持一个`paint-callback`事件➊。每当画布需要重新绘制时，都会触发此事件（注意，回调函数会提供一个绘图上下文`dc`）。默认情况下，当画布首次显示时会触发该事件，但我们通过使用`timer%`对象➋强制其刷新。画布对象会在`(loc-x,
    loc-y)`处绘制小球，因此我们的定时器会在每次调用时更新`loc-x`值。定时器会响应一个名为`notify-callback`的事件➌。当该事件触发时，它会通过发送`refresh-now`消息➎强制画布刷新。定时器回调还会递增`loc-x`变量➍。整个过程由最后一行代码启动。我们向定时器对象发送消息，使其每50毫秒触发一次➏。
- en: We didn’t use it here, but the timer can also be stopped by sending it a `stop`
    message. The `timer%` object also supports a `just-once?` option, if the timer
    only needs to be triggered a single time. This can also be specified with the
    `start` message. For example calling the following code would cause the timer
    to stop and then to be triggered a single time after waiting one second.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有使用它，但定时器也可以通过向其发送`stop`消息来停止。`timer%`对象还支持`just-once?`选项，如果定时器只需要触发一次。也可以通过`start`消息来指定。例如，调用以下代码会使定时器停止，并在等待一秒钟后触发一次。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we wanted the ball to bounce back and forth, we could revise `timer` as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望小球来回弹跳，可以按如下方式修改`timer`：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time we define the variable `delta`, which is either positive or negative
    depending on which direction the ball is moving. We also add a `cond` statement
    to detect when the ball has reached one of the edges of the canvas and change
    the direction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们定义了变量`delta`，它的值根据小球的运动方向可以是正值或负值。我们还添加了一个`cond`语句，用于检测小球是否到达画布的某个边缘，并改变其运动方向。
- en: Animating a Cycloid
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化摆线
- en: In the last chapter, we saw how to plot the cycloid curve, which is generated
    by a point on the perimeter of a circle as it rolls without slipping on a straight
    line. In this section, we’ll produce an animation so that we can see this motion
    in action. The end result will be an animation of a rolling circle with a point
    on the circle tracing out the cycloid as it moves along. A snapshot of the animation
    is shown in [Figure 5-2](ch05.xhtml#ch5fig2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了如何绘制摆线曲线，这条曲线是由一个在圆周上移动的点生成的，该点在没有滑动的情况下沿着直线滚动。在这一节中，我们将制作一个动画，以便我们可以看到这一运动的实际效果。最终结果将是一个滚动的圆形动画，圆周上的点在其运动过程中描绘出摆线。动画的快照见[图
    5-2](ch05.xhtml#ch5fig2)。
- en: '![Image](../images/05fig02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig02.jpg)'
- en: '*Figure 5-2: Animated cycloid*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：动画摆线*'
- en: 'We once again avail ourselves of the `infix` package to make it easier to enter
    algebraic expressions. We’ll also use the *plot* library that we used before:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`infix`包来简化代数表达式的输入。我们还将使用之前用过的*plot*库：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next we see that the `cycloid` function is unchanged from the one we used before.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到`cycloid`函数与之前使用的版本相同。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again `r` is the radius of the circle used to define the cycloid. The `angle`
    variable is used to define the rotation angle at any point in the animation. The
    `circle` function will be used to create a parametric plot of the actual circle
    we’re rotating (shown in green in the figure).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，`r`是用来定义摆线的圆的半径。`angle`变量用于定义动画中任意时刻的旋转角度。`circle`函数将用来创建我们正在旋转的实际圆的参数图（图中以绿色显示）。
- en: To create the blue line segment that runs from the center of the circle to the
    edge as well as the red end points of the line, we’ll use the following two functions.
    The parameter `t` is the rotation angle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There should be no surprises here: *x* and *y* end-point values are computed
    using basic trigonometry (see the solution to the cycloid problem in the previous
    chapter). We also examined using `lines` and `points` in the previous chapter.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get to the actual plot routine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to plot within the GUI, we must use a special version of `plot` called
    `plot/dc` since this time we want the output to go to the drawing context. Note
    the difference between `plot` and `plot/dc` ➍. Here we specify the drawing context,
    the *x* and *y* location for the plot, and the plot width and height. The other
    parameters are the same as for `plot`. The bulk of this code specifies the specific
    objects we want to plot. Of note are: the cycloid itself ➊, the line connecting
    the circle center to edge ➋, and the line end points ➌. The code `(plot-decorations?
    #f)`, at the beginning of the listing, turns off some of the axis info so that
    we have a cleaner plot.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually generate the animation, we make some minor changes to the window
    code we saw earlier:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Specifially, we update the rotation angle ➋ on each timer tick, and reset the
    angle to zero ➌ when the circle rotation reaches 2*π* degrees. The plot actually
    gets produced with `cycloid-plot dc` ➊.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Having completed a couple of warm-up exercises to familiarize ourselves with
    some basic GUI functionality, let’s take a look at something a bit more ambitious—something
    we can dazzle our friends with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Pick a Card
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s perform a little magic with our computer. In this trick, we deal out a
    5-by-5 matrix of cards in some random order, face up. The participant mentally
    picks one of the cards and indicates which row the card resides in. The cards
    are then reshuffled and dealt out again in a 5-by-5 matrix. The subject is again
    asked to pick the row that the card appears on. The selected card is then revealed
    with great fanfare. Our Racket version of the game is shown in [Figure 5-3](ch05.xhtml#ch5fig3).
    The card images used here are available under the GPL^([1](footnote.xhtml#ch05foot_1))
    thanks to Chris Aguilar.^([2](footnote.xhtml#ch05foot_2))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0125-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Pick-a-card trick*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear that if the cards were properly shuffled and re-dealt, it would be
    impossible to select the proper card without some possibility of error. Like all
    tricks, this one involves a bit of deception. The mechanism behind this trick
    is actually quite simple. In the following diagram, we indicate each card by a
    letter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0125-02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Suppose the `N` is selected in row 2, column 3\. We can randomly swap the columns
    without affecting the selected row. After doing this, we may end up with something
    that looks like the following.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0126-01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: We now have something that looks quite different, but we still have the `N`
    in row 2 (but now in column 1). In an essential step that further adds to the
    illusion, we transpose the rows and columns (by transpose, we mean the rows become
    columns and the columns become rows—that is, row 1 becomes column 1, row 2 becomes
    column 2, and so on). Doing so results in the following arrangement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0126-03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: The resulting matrix now looks nothing like the original, but notice that the
    `N` is now in column 2 instead of row 2\. Once the subject indicates row 1 as
    the proper row (which was originally column 1), we immediately have the location
    (row 1, column 2—originally row 2). Since we transposed rows and columns, the
    player is unknowingly revealing the row and column the card resides in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Swapping rows and columns and transposing rows with columns is standard fare
    in the mathematical discipline of *linear algebra*. We’ll make use of the Racket
    *matrix* library, which provides the functionality that we need. Given this, our
    code begins with the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `define` expressions are used to keep track of the program state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The card bitmaps will be kept in a vector called `card-deck`. The root names
    of the card images being used are stored in another vector, called `card-names`.
    The following code reads the card images in from a subfolder called `Card PNGs`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we’ve used `build-path` to construct an operating system–agnostic
    pathname.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll want to be able to shuffle the cards, the following code will place
    the `card-deck` in a random order:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `card-deck` vector is just a linear list of the card bitmaps. To be able
    to present them in the arrangement to be shown on the display, we define a Racket
    `display-matrix` that holds the indexes into the `card-deck` vector. We also create
    `get-card`, which enables us to access any bitmap given the row and column it
    resides in.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, we’ve explained the basic mechanism behind the trick and defined
    some data structures to hold the puzzle objects (the cards and their images).
    In the next section, we’ll exploit Racket’s layout mechanism to generate an attractive
    tableau.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '***GUI Layout***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve used buttons, the message control, and the canvas control before, but
    we displayed them in the default order, which just stacks one on top of the other.
    In this case we need something a bit more sophisticated. Racket provides two layout
    controls that are sufficient for our purposes: `horizontal-panel%` and `vertical-panel%`.
    The `vertical-panel%` control allows us to stack controls vertically, as shown
    on the left side of [Figure 5-3](ch05.xhtml#ch5fig3). In the code below, we use
    the `horizontal-panel%` to house the `vertical-panel%` and the canvas used to
    draw the card faces.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of the code for `canvas` should be familiar, but the section starting with
    `when` ➊ uses a state variable called `show-card` that’s set to true when it’s
    time to reveal the selected card (via a red border around the card).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Controls***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want a message control to be shown in the upper left portion of the application
    to act as a prompt to the user. Let’s add the code to do that now. Begin with
    the following code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To dress up our buttons, we need an image of an arrow. Rather than go out and
    try to find a bitmap of an arrow, it’s a simple matter to construct one on the
    fly, as we do here via a sequence of `path` statements to generate a polygon in
    the shape of an arrow:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s a slightly more concise way to write this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have our arrow, we also need buttons to select the card row. We’ll
    use the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note we’ve used the card height to adjust the button margins so that they line
    up properly with the row of card images.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '***Control Logic***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve specified the basic GUI components, we move on to the control
    logic where we make the puzzle interactive. The logic to swap the columns of the
    `display-matrix` is given in the following `swap-cols` function. It takes two
    column numbers and swaps the columns of `display-matrix` as required. We’re going
    to say a few words about how this works, but if you’re not familiar with linear
    algebra, you may want to take this function as a black box that works as expected
    and skim over the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***Linear Algebra Zone***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you will recall from linear algebra, there are three elementary matrix operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Interchange two rows (or columns).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply each element in a row (or column) by a number.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply a row (or column) by a number and add the result to another row (or
    column).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these operations can be performed by matrix multiplication. For our purposes
    we only need to implement the ability to interchange columns, but if *M* and *R*
    are matrices such that *RM* = *M*[*r*], where certain rows of *M* are swapped,
    then *MR* = *M*[*c*] produces a matrix with the corresponding columns swapped.
    As an example we define *M* and *R* as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0131-01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Then we can swap the first two rows or first two columns of *M* as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Racket supplies a matrix multiplication operator, `matrix*`, but unfortunately
    does not provide built-in row or column swapping operations, so we must create
    our own. The following `make-swap` function takes two row numbers and returns
    a matrix with the corresponding matrix rows swapped. We employ this in conjunction
    with the Racket-supplied matrix multiplication operator in the `swap-cols` function
    given above. Since `swap-matrix` is the second argument in the multiplication,
    it performs a column swap instead of a row swap.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function `build-matrix` is defined in the Racket *matrix* library. It constructs
    a new matrix by populating it with elements computed by `swap-func`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '***Wrapping Up the GUI***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the user makes their first row selection, the following code runs:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may be wondering why the first thing it does is set `selected-col` with
    the selected row `r`. The reason is that the selected row will become the selected
    column after the built-in `matrix-transpose` is executed ➌. We perform a series
    of column swaps to jumble up the displayed equation without affecting the row
    order ➊ ➋).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The second time the user makes a row selection, the `show-selection` function
    runs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function sets the `show-card` variable and triggers the canvas to refresh
    and reveal the selected card.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the entire process, we have the `restart` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s see what happens when a user clicks on a button. Way back when we created
    the arrow buttons, we assigned them a callback function called `select-row` along
    with the appropriate row number. Depending on the state variables `selected-row`
    and `selected-col`, the function will perform different actions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `selected-col` is less than zero (meaning this is the first selection), it
    runs `first-row-selection`. If `selected-row` is less than zero (meaning this
    is the second selection), it runs `show-selection` to reveal the selected card.
    If neither of these are true (meaning both selections have been made), it prompts
    the user to reset the program by pressing the Play Again button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Our card trick application has exercised much of Racket’s GUI capabilities,
    but there’s nothing quite like seeing objects flying around the screen. In the
    next section, we’ll convert our command line version of the Tower of Hanoi into
    an interactive animated puzzle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Control Tower
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back in [Chapter 3](ch03.xhtml), we looked at a simple function that solved
    the Tower of Hanoi puzzle. The function returned a list that contained the moves
    required to solve the puzzle. This is of course not a very satisfying way to visualize
    how the solution progresses. In this section we’ll remedy that omission by animating
    the solution and learn a bit more about Racket widgets in the process. Widgets
    are graphical objects used to provide input to an application (such as buttons,
    text boxes, and pick lists) or display information (such as progress bars and
    labels).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The code to solve the puzzle (`hanoi`) is repeated below. It still does exactly
    what we need. Recall that it returns a list of moves, each of which is a list
    containing the peg to move from and the peg to move to. It can be placed anywhere
    after the `#lang racket/gui` command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The program we’ll build in the following sections will accommodate from 1 to
    10 disks. [Figure 5-4](ch05.xhtml#ch5fig4) illustrates some basic parameters we’ll
    be using in the rest of this section. As shown, each peg will be assigned a number
    from 0 to 2\. Each position on a peg also has a designated value. These values
    will be used as parameters to various functions to control the source and target
    location of the disks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Tower of Hanoi parameters*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4: 汉诺塔参数*'
- en: '***Setting Up***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置***'
- en: We’ll begin with some useful constants.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些有用的常量开始。
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To enable scalability, we define the constant `UNIT` as a basic unit of measure
    (in pixels). By basing all the other measurements on this value, we can scale
    the entire interface by changing this one number. Constants `PEG-X` and `PEG-Y`
    are the location of the first peg. Constant `PEG-DIST` is the distance between
    pegs and `START-Y` is the *y* location of a disk in the bottommost position (position
    1). Constant `RADIUS` is used to curve the ends of the disks and pegs. And constant
    `ANIMATION-INTERVAL` defines the time in milliseconds between animation updates,
    and `MOVE-DIST` defines how far a disk moves on each animation update. These last
    two parameters may need to be adjusted depending on the performance characteristics
    of the computer the code runs on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现可扩展性，我们将常量`UNIT`定义为基本的度量单位（以像素为单位）。通过将所有其他测量值基于这个值，我们可以通过更改这个数字来缩放整个界面。常量`PEG-X`和`PEG-Y`是第一个柱子的位置。常量`PEG-DIST`是柱子之间的距离，`START-Y`是盘子在最底部位置（位置
    1）时的*y*坐标。常量`RADIUS`用于弯曲盘子和柱子的两端。常量`ANIMATION-INTERVAL`定义了动画更新之间的毫秒时间间隔，`MOVE-DIST`定义了每次动画更新时盘子移动的距离。这两个最后的参数可能需要根据运行代码的计算机的性能特点进行调整。
- en: Here are the main window elements. There should be no surprises here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主窗口元素，应该没有什么令人惊讶的地方。
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll examine `update-canvas` in greater detail later.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地查看`update-canvas`。
- en: The following defines are for variables that will be updated during the progress
    of the animation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义的是一些变量，这些变量将在动画过程中进行更新。
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `peg-disks` variable is a three-element vector that’s used to represent
    the three pegs. Each element of the vector will be populated with a list of numbers
    that represent the disks that reside on the respective pegs. Most of the other
    variables are fairly descriptive of their purpose, but we’ll provide more detail
    as we progress through the section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`peg-disks`变量是一个三元素向量，用于表示三个柱子。向量的每个元素将包含一个数字列表，表示分别位于各个柱子上的盘子。其他大多数变量的名称能较好地描述它们的用途，但我们将在本节中进一步详细说明。'
- en: To give you an idea of what we’re building, [Figure 5-5](ch05.xhtml#ch5fig5)
    is a snapshot of the final application with a disk movement in progress.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解我们正在构建的内容，[图 5-5](ch05.xhtml#ch5fig5)是最终应用程序的快照，展示了一个盘子正在移动的过程。
- en: '![Image](../images/05fig05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig05.jpg)'
- en: '*Figure 5-5: Tower of Hanoi GUI*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5: 汉诺塔 GUI*'
- en: In the next section, we’ll describe the interface widgets that we’ll use within
    the GUI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将描述将在 GUI 中使用的界面小部件。
- en: '***Row 1 Widgets***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第 1 行小部件***'
- en: The first row of controls (shown immediately below the canvas in [Figure 5-5](ch05.xhtml#ch5fig5))
    is housed in the horizontal panel `control-panel1`. We’ll describe each in the
    order they’re added to the panel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行控件（显示在[图 5-5](ch05.xhtml#ch5fig5)画布下方）被放置在水平面板`control-panel1`中。我们将按添加到面板的顺序描述它们。
- en: First, there’s a basic button control that has a callback function that calls
    `reset` (provided the animation isn’t already in progress), which restores everything
    back to the start state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个基本的按钮控件，它具有一个回调函数，该函数在动画尚未开始的情况下调用`reset`，将一切恢复到初始状态。
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next we have a `text-field%` widget. This is a basic text entry box. We use
    it to allow the user to specify the number of disks to use for the animation (via
    `init-value`, which is used to initialize a number of other controls as well).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`text-field%`小部件。这是一个基本的文本输入框，用来让用户指定动画中使用的盘子数量（通过`init-value`，它还用于初始化其他一些控件）。
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Following the text box, we have a handy slider control. The slider provides
    an alternative method to select the number of disks. The callback function will
    update the text box containing the disk count based on the position of the slider.
    This is done by getting the value of the slider and sending it to the text box
    widget. The purpose of the remaining parameters should be fairly self-evident.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本框之后，我们有一个方便的滑块控件。滑块提供了选择盘子数量的另一种方法。回调函数将根据滑块的位置更新文本框中的盘子数量。通过获取滑块的值并将其发送到文本框小部件来完成此操作。其余参数的用途应该是显而易见的。
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The final element of the first row is a progress bar. Here we’re using a Racket
    `gauge%` widget. To update this control, it just needs to be sent a number indicating
    the value to show (the number must be within the specified range).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***Row 2 Widgets***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second row of controls is housed in the horizontal panel `control-panel2`.
    First up is a button that allows the user to step through the solution of the
    puzzle one move at a time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The state variable `in-motion` is used to flag whether an animation is currently
    in progress. If so, this variable is checked to ensure that the action isn’t re-triggered
    before the step is complete. The `move-list` variable contains the list of moves
    provided by the solver, `hanoi`. If the list is empty, the solution has already
    been generated; in that case, the program is automatically reset. The variable
    `mode` can have one of three values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ’`stopped`. Waiting on user input.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: ’`step`. Performing a single step.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: ’`solve`. Solution animation in progress.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Then `init-next-step` sets up all the state variables to perform the next step
    of the solution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Next we have the button that triggers the full-blown solution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The callback for this button is similar to the one for the step button, but
    this time we also check to see whether the user has changed the number of disks
    ➊ , in which case the program is reset to reflect the new number of disks before
    the animation is run. It also sets the `mode` variable to ’`solve`. (If you’re
    bothered by the fact that `(object:button . . . )` prints out in the DrRacket
    window when this is executed, you can wrap this in a `void` form.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The next button is quite simple: it sets `mode` to ’`step`. The mode is checked
    at the end of each step, so this will automatically cause the animation to stop.
    It can be resumed by pressing either the Solve or the Step button.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The last control in the panel is a standard `message%` widget. It’s used to
    display the current state of the program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***Getting in Position***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s look at a couple of functions that determine how to position the disks
    on the canvas. Each disk has a number from 1 to `MAX-DISKS` that determines the
    size of the disk. The `disk-x` function is passed the disk number and the number
    of the peg the disk resides on; it then returns the x-coordinate of the disk.
    The `disk-y` function is passed the disk position on a peg (see [Figure 5-4](ch05.xhtml#ch5fig4))
    and returns the y-coordinate.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A disk is actually just a rounded rectangle. We’re going to add a little bling
    to our disks by including a gradient. This will make our disks look a little more
    disk-like. If you look closely at [Figure 5-5](ch05.xhtml#ch5fig5), you’ll notice
    that the disks are not a flat color, but give the appearance of being cylindrical.
    To this end we define a function `make-gradient`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function returns a Racket `linear-gradient%` object that can be applied
    to a brush. The `start` and `stop` parameters are the screen *x* locations where
    the gradient is to start and end. Variable `c1` is the color at the ends of the
    gradient, and `c2` is the color in the center of the gradient. Linear gradients
    work by defining a line segment whose end points are given by (*x*[0], *y*[0])
    and (*x*[1], *y*[1]). The colors are applied perpendicularly along the line. That’s
    why for our purposes we can just set the *y* values to 0\. The colors are varied
    along the line by defining a list of *stop* positions. Each position defines the
    position along the line to apply a color. The position is a number between 0 and
    1, where 0 is the color at the start of the line and 1 is the color at the end
    of the line; any number between 0 and 1 would designate a color at some point
    along the line.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To actually draw a disk, we use the following `draw-disk` function. We pass
    this function a drawing context, a disk number, a peg number, and a position on
    the peg.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Inside we compute the width of the disk and the x-and y-coordinates. We then
    create a brush using our `make-gradient` function to create a linear gradient
    with which we draw a rounded rectangle to represent a disk.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The following functions draw the disks. The `draw-peg-disks` draws all the disks
    on a single peg. It’s passed a drawing context, a peg number, and a list containing
    the disks that need to be drawn. The `draw-disks` function calls `draw-peg-disks`
    once for each peg.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we have `draw-base`, which draws the base with the pegs (notice the pegs
    also use a linear gradient).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The actual drawing process originates with `update-canvas` as given here. Aside
    from calling `draw-base` and `draw-disks` as described above, it checks to see
    if there’s currently a disk in motion (determined by `current-disk` being greater
    than zero). If this is the case, it also renders the disk being animated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***Controlling the Animation***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re now going to look at a couple of functions used to initialize the state
    variables at two key points in the process: at the start of the solution, and
    before each step. The first is called `reset`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code above begins by assigning the requested number of disks to the variable
    `num-disks` via a call to `validate-disks` ➊ (`validate-disks` ➏ ensures that
    the user has entered a proper number of disks; if not, it reverts back to the
    previous valid entry). Following this, a list of moves is generated based on the
    requested number of disks ➋. Next, we initialize the `peg-disks` vector with the
    disks on each peg ➌ ➍. The `init-next-step` function ➎ works by extracting the
    next move from the move list to determine the source and destination pegs, target
    locations, and parameters for the disk to be moved.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We finally arrive at the `move-disk` code responsible for the main animation
    update process. It processes a single move step in three phases: the target disk
    moving up and off the source peg, the disk moving left or right toward the destination
    peg, and the disk moving down to its final resting place. In the code below, `update-progress`
    is used to update the progress bar. It’s called by `move-disk` at the end of each
    step ➎.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Before `move-disk` is called, the target disk source and destination parameters
    would all have been established by a call to `init-next-step`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The code for vertical movement starts ➊, and the current y-coordinate for the
    disk is updated. A check is then made to see whether the disk is at its target
    location. If the disk is at its target location and was moving up, a new x-coordinate
    target and travel delta for the disk are set. If the disk was moving down, the
    destination peg is updated by adding the animated disk to the list ➋. If the animation
    is in ’`step` mode, the animation timer is turned off and state variables are
    set to indicate the step is complete. Otherwise, the animation is in ’`solve`
    mode, so a check is made to see if any moves remain. If any moves remain, `init-next-step`
    is called; otherwise, the timer is stopped.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The check for horizontal movement is made at ➌. The x-coordinate of the disk
    is updated with a subsequent check to see whether the disk is at its target location
    ➍. If so, it sets up the state variables so that the next time `move-disk` is
    triggered, the disk begins to move down. At the end of every step, the progress
    meter and canvas are updated ➎ ➏.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '***Wrapping Things Up***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The remaining items needed to get things going are given below. First, we define
    `timer` with a callback to `move-disk`. Next, `reset` is called to initialize
    all the state variables. And finally, we show the main window.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In addition to a nice little application to explore various facets of the Tower
    of Hanoi puzzle, in the process of building this application, we’ve utilized a
    significant number (but not all) of the widgets provided by the DrRacket environment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we began with a couple of simple GUI applications and built
    up to a fairly full-featured application where we were exposed to a number of
    the elements needed to build a robust application. Later in the book, we’ll see
    how to bundle this functionality into a stand-alone application that can be run
    independent of the DrRacket environment. But, next up, we’ll be exploring how
    to access and analyze data in its various incarnations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
