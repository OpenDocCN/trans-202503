- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GUI: GETTING USERS INTERESTED'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GUI (pronounced gooey) stands for graphical user interface. This is just a fancy
    term for any program that has graphical elements as opposed to just being text-based.
    Graphical elements can consist of static images or drawings, as we explored in
    the previous chapter, or interactive elements like buttons and menus. Aside from
    just graphical elements, GUIs introduce the *event* paradigm—events trigger actions.
    An event can be anything from a key press or mouse click to a timer going off.
    Racket not only supports building mini-applications, but also stand-alone executables.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll bring our old friend the cycloid to life with an animation,
    learn some new (card) tricks, and make the Tower of Hanoi more than just an intellectual
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GUIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Racket GUI programming makes use of the *racket/gui/base* library, which can
    be imported with the `(require racket/gui/base)` statement. Alternatively, you
    may use the language switch `#lang racket/gui`, which includes both the base Racket
    libraries and the GUI library. Here’s a little code snippet that does nothing
    more than create and display a window frame 300 by 200 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should note that the frame size is the size of the exterior window and includes
    the size of the title bar and any window borders. The frame interior will be somewhat
    smaller.
  prefs: []
  type: TYPE_NORMAL
- en: The code below shows something a bit more exciting that demonstrates the basic
    idea of how to respond to an event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `message%` object ➊ creates a label with the text “Hi, there!” (`message%`
    objects are a bit more powerful than you might expect; they can also contain a
    bitmap as the label). GUI objects must normally specify the parent frame that
    they are contained in ➋. We’ve also defined the `auto-resize` parameter so that
    the message control will expand if the text is larger than it was initialized
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a `button%` object ➌ and make it a child of the `main-frame`
    window. Buttons can respond to being clicked on with the mouse. This is handled
    with a `callback` option ➍. This takes a function (in this case a lambda expression)
    that accepts two parameters. When the button is clicked, the window event processor
    will pass the callback function a pointer to the button object and an event object
    that contains information about the event (we don’t use them here; we just need
    to know that the button was clicked). In our case, we send the `msg` object a
    command for it to set its label to a new value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch5fig1) shows how the thing will look (depending on
    your operating system, it may be slightly different).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Simple GUI application*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try our hand at a bit of animation. We’ll begin simply, by just moving
    a little red circle across the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we create a `canvas%` object within the `frame%` object. This
    is the same canvas object we explored in the previous chapter, so all the drawing
    commands we saw previously are available. The `canvas` object supports a `paint-callback`
    event ➊. This event is triggered whenever the canvas needs to be repainted (note
    that a drawing context, `dc`, is provided to the callback function). By default
    it’s triggered when the canvas is first displayed, but we force it to be refreshed
    by using a `timer%` object ➋. The canvas object draws the ball at `(loc-x, loc-y)`,
    so our timer will update the `loc-x` value every time it’s called. The timer responds
    to an event called `notify-callback` ➌. When this event is triggered, it forces
    the canvas to refresh itself by sending it a `refresh-now` message ➎. The timer
    callback also increments the `loc-x` variable ➍. This entire process is kicked
    off with the last line of code. We send the timer object a message to start triggering
    itself every 50 milliseconds ➏.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t use it here, but the timer can also be stopped by sending it a `stop`
    message. The `timer%` object also supports a `just-once?` option, if the timer
    only needs to be triggered a single time. This can also be specified with the
    `start` message. For example calling the following code would cause the timer
    to stop and then to be triggered a single time after waiting one second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted the ball to bounce back and forth, we could revise `timer` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time we define the variable `delta`, which is either positive or negative
    depending on which direction the ball is moving. We also add a `cond` statement
    to detect when the ball has reached one of the edges of the canvas and change
    the direction.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a Cycloid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last chapter, we saw how to plot the cycloid curve, which is generated
    by a point on the perimeter of a circle as it rolls without slipping on a straight
    line. In this section, we’ll produce an animation so that we can see this motion
    in action. The end result will be an animation of a rolling circle with a point
    on the circle tracing out the cycloid as it moves along. A snapshot of the animation
    is shown in [Figure 5-2](ch05.xhtml#ch5fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Animated cycloid*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We once again avail ourselves of the `infix` package to make it easier to enter
    algebraic expressions. We’ll also use the *plot* library that we used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next we see that the `cycloid` function is unchanged from the one we used before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again `r` is the radius of the circle used to define the cycloid. The `angle`
    variable is used to define the rotation angle at any point in the animation. The
    `circle` function will be used to create a parametric plot of the actual circle
    we’re rotating (shown in green in the figure).
  prefs: []
  type: TYPE_NORMAL
- en: To create the blue line segment that runs from the center of the circle to the
    edge as well as the red end points of the line, we’ll use the following two functions.
    The parameter `t` is the rotation angle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no surprises here: *x* and *y* end-point values are computed
    using basic trigonometry (see the solution to the cycloid problem in the previous
    chapter). We also examined using `lines` and `points` in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get to the actual plot routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to plot within the GUI, we must use a special version of `plot` called
    `plot/dc` since this time we want the output to go to the drawing context. Note
    the difference between `plot` and `plot/dc` ➍. Here we specify the drawing context,
    the *x* and *y* location for the plot, and the plot width and height. The other
    parameters are the same as for `plot`. The bulk of this code specifies the specific
    objects we want to plot. Of note are: the cycloid itself ➊, the line connecting
    the circle center to edge ➋, and the line end points ➌. The code `(plot-decorations?
    #f)`, at the beginning of the listing, turns off some of the axis info so that
    we have a cleaner plot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually generate the animation, we make some minor changes to the window
    code we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Specifially, we update the rotation angle ➋ on each timer tick, and reset the
    angle to zero ➌ when the circle rotation reaches 2*π* degrees. The plot actually
    gets produced with `cycloid-plot dc` ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed a couple of warm-up exercises to familiarize ourselves with
    some basic GUI functionality, let’s take a look at something a bit more ambitious—something
    we can dazzle our friends with.
  prefs: []
  type: TYPE_NORMAL
- en: Pick a Card
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s perform a little magic with our computer. In this trick, we deal out a
    5-by-5 matrix of cards in some random order, face up. The participant mentally
    picks one of the cards and indicates which row the card resides in. The cards
    are then reshuffled and dealt out again in a 5-by-5 matrix. The subject is again
    asked to pick the row that the card appears on. The selected card is then revealed
    with great fanfare. Our Racket version of the game is shown in [Figure 5-3](ch05.xhtml#ch5fig3).
    The card images used here are available under the GPL^([1](footnote.xhtml#ch05foot_1))
    thanks to Chris Aguilar.^([2](footnote.xhtml#ch05foot_2))
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0125-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Pick-a-card trick*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear that if the cards were properly shuffled and re-dealt, it would be
    impossible to select the proper card without some possibility of error. Like all
    tricks, this one involves a bit of deception. The mechanism behind this trick
    is actually quite simple. In the following diagram, we indicate each card by a
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0125-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose the `N` is selected in row 2, column 3\. We can randomly swap the columns
    without affecting the selected row. After doing this, we may end up with something
    that looks like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0126-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have something that looks quite different, but we still have the `N`
    in row 2 (but now in column 1). In an essential step that further adds to the
    illusion, we transpose the rows and columns (by transpose, we mean the rows become
    columns and the columns become rows—that is, row 1 becomes column 1, row 2 becomes
    column 2, and so on). Doing so results in the following arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0126-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting matrix now looks nothing like the original, but notice that the
    `N` is now in column 2 instead of row 2\. Once the subject indicates row 1 as
    the proper row (which was originally column 1), we immediately have the location
    (row 1, column 2—originally row 2). Since we transposed rows and columns, the
    player is unknowingly revealing the row and column the card resides in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swapping rows and columns and transposing rows with columns is standard fare
    in the mathematical discipline of *linear algebra*. We’ll make use of the Racket
    *matrix* library, which provides the functionality that we need. Given this, our
    code begins with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `define` expressions are used to keep track of the program state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The card bitmaps will be kept in a vector called `card-deck`. The root names
    of the card images being used are stored in another vector, called `card-names`.
    The following code reads the card images in from a subfolder called `Card PNGs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’ve used `build-path` to construct an operating system–agnostic
    pathname.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll want to be able to shuffle the cards, the following code will place
    the `card-deck` in a random order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `card-deck` vector is just a linear list of the card bitmaps. To be able
    to present them in the arrangement to be shown on the display, we define a Racket
    `display-matrix` that holds the indexes into the `card-deck` vector. We also create
    `get-card`, which enables us to access any bitmap given the row and column it
    resides in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve explained the basic mechanism behind the trick and defined
    some data structures to hold the puzzle objects (the cards and their images).
    In the next section, we’ll exploit Racket’s layout mechanism to generate an attractive
    tableau.
  prefs: []
  type: TYPE_NORMAL
- en: '***GUI Layout***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve used buttons, the message control, and the canvas control before, but
    we displayed them in the default order, which just stacks one on top of the other.
    In this case we need something a bit more sophisticated. Racket provides two layout
    controls that are sufficient for our purposes: `horizontal-panel%` and `vertical-panel%`.
    The `vertical-panel%` control allows us to stack controls vertically, as shown
    on the left side of [Figure 5-3](ch05.xhtml#ch5fig3). In the code below, we use
    the `horizontal-panel%` to house the `vertical-panel%` and the canvas used to
    draw the card faces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code for `canvas` should be familiar, but the section starting with
    `when` ➊ uses a state variable called `show-card` that’s set to true when it’s
    time to reveal the selected card (via a red border around the card).
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Controls***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want a message control to be shown in the upper left portion of the application
    to act as a prompt to the user. Let’s add the code to do that now. Begin with
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To dress up our buttons, we need an image of an arrow. Rather than go out and
    try to find a bitmap of an arrow, it’s a simple matter to construct one on the
    fly, as we do here via a sequence of `path` statements to generate a polygon in
    the shape of an arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a slightly more concise way to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our arrow, we also need buttons to select the card row. We’ll
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note we’ve used the card height to adjust the button margins so that they line
    up properly with the row of card images.
  prefs: []
  type: TYPE_NORMAL
- en: '***Control Logic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve specified the basic GUI components, we move on to the control
    logic where we make the puzzle interactive. The logic to swap the columns of the
    `display-matrix` is given in the following `swap-cols` function. It takes two
    column numbers and swaps the columns of `display-matrix` as required. We’re going
    to say a few words about how this works, but if you’re not familiar with linear
    algebra, you may want to take this function as a black box that works as expected
    and skim over the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '***Linear Algebra Zone***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you will recall from linear algebra, there are three elementary matrix operations.
  prefs: []
  type: TYPE_NORMAL
- en: Interchange two rows (or columns).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply each element in a row (or column) by a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply a row (or column) by a number and add the result to another row (or
    column).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these operations can be performed by matrix multiplication. For our purposes
    we only need to implement the ability to interchange columns, but if *M* and *R*
    are matrices such that *RM* = *M*[*r*], where certain rows of *M* are swapped,
    then *MR* = *M*[*c*] produces a matrix with the corresponding columns swapped.
    As an example we define *M* and *R* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0131-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can swap the first two rows or first two columns of *M* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Racket supplies a matrix multiplication operator, `matrix*`, but unfortunately
    does not provide built-in row or column swapping operations, so we must create
    our own. The following `make-swap` function takes two row numbers and returns
    a matrix with the corresponding matrix rows swapped. We employ this in conjunction
    with the Racket-supplied matrix multiplication operator in the `swap-cols` function
    given above. Since `swap-matrix` is the second argument in the multiplication,
    it performs a column swap instead of a row swap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The function `build-matrix` is defined in the Racket *matrix* library. It constructs
    a new matrix by populating it with elements computed by `swap-func`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Wrapping Up the GUI***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the user makes their first row selection, the following code runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why the first thing it does is set `selected-col` with
    the selected row `r`. The reason is that the selected row will become the selected
    column after the built-in `matrix-transpose` is executed ➌. We perform a series
    of column swaps to jumble up the displayed equation without affecting the row
    order ➊ ➋).
  prefs: []
  type: TYPE_NORMAL
- en: The second time the user makes a row selection, the `show-selection` function
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function sets the `show-card` variable and triggers the canvas to refresh
    and reveal the selected card.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the entire process, we have the `restart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what happens when a user clicks on a button. Way back when we created
    the arrow buttons, we assigned them a callback function called `select-row` along
    with the appropriate row number. Depending on the state variables `selected-row`
    and `selected-col`, the function will perform different actions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If `selected-col` is less than zero (meaning this is the first selection), it
    runs `first-row-selection`. If `selected-row` is less than zero (meaning this
    is the second selection), it runs `show-selection` to reveal the selected card.
    If neither of these are true (meaning both selections have been made), it prompts
    the user to reset the program by pressing the Play Again button.
  prefs: []
  type: TYPE_NORMAL
- en: Our card trick application has exercised much of Racket’s GUI capabilities,
    but there’s nothing quite like seeing objects flying around the screen. In the
    next section, we’ll convert our command line version of the Tower of Hanoi into
    an interactive animated puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Control Tower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back in [Chapter 3](ch03.xhtml), we looked at a simple function that solved
    the Tower of Hanoi puzzle. The function returned a list that contained the moves
    required to solve the puzzle. This is of course not a very satisfying way to visualize
    how the solution progresses. In this section we’ll remedy that omission by animating
    the solution and learn a bit more about Racket widgets in the process. Widgets
    are graphical objects used to provide input to an application (such as buttons,
    text boxes, and pick lists) or display information (such as progress bars and
    labels).
  prefs: []
  type: TYPE_NORMAL
- en: The code to solve the puzzle (`hanoi`) is repeated below. It still does exactly
    what we need. Recall that it returns a list of moves, each of which is a list
    containing the peg to move from and the peg to move to. It can be placed anywhere
    after the `#lang racket/gui` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The program we’ll build in the following sections will accommodate from 1 to
    10 disks. [Figure 5-4](ch05.xhtml#ch5fig4) illustrates some basic parameters we’ll
    be using in the rest of this section. As shown, each peg will be assigned a number
    from 0 to 2\. Each position on a peg also has a designated value. These values
    will be used as parameters to various functions to control the source and target
    location of the disks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Tower of Hanoi parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll begin with some useful constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To enable scalability, we define the constant `UNIT` as a basic unit of measure
    (in pixels). By basing all the other measurements on this value, we can scale
    the entire interface by changing this one number. Constants `PEG-X` and `PEG-Y`
    are the location of the first peg. Constant `PEG-DIST` is the distance between
    pegs and `START-Y` is the *y* location of a disk in the bottommost position (position
    1). Constant `RADIUS` is used to curve the ends of the disks and pegs. And constant
    `ANIMATION-INTERVAL` defines the time in milliseconds between animation updates,
    and `MOVE-DIST` defines how far a disk moves on each animation update. These last
    two parameters may need to be adjusted depending on the performance characteristics
    of the computer the code runs on.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the main window elements. There should be no surprises here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We’ll examine `update-canvas` in greater detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The following defines are for variables that will be updated during the progress
    of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `peg-disks` variable is a three-element vector that’s used to represent
    the three pegs. Each element of the vector will be populated with a list of numbers
    that represent the disks that reside on the respective pegs. Most of the other
    variables are fairly descriptive of their purpose, but we’ll provide more detail
    as we progress through the section.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea of what we’re building, [Figure 5-5](ch05.xhtml#ch5fig5)
    is a snapshot of the final application with a disk movement in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: Tower of Hanoi GUI*'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll describe the interface widgets that we’ll use within
    the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '***Row 1 Widgets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first row of controls (shown immediately below the canvas in [Figure 5-5](ch05.xhtml#ch5fig5))
    is housed in the horizontal panel `control-panel1`. We’ll describe each in the
    order they’re added to the panel.
  prefs: []
  type: TYPE_NORMAL
- en: First, there’s a basic button control that has a callback function that calls
    `reset` (provided the animation isn’t already in progress), which restores everything
    back to the start state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next we have a `text-field%` widget. This is a basic text entry box. We use
    it to allow the user to specify the number of disks to use for the animation (via
    `init-value`, which is used to initialize a number of other controls as well).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Following the text box, we have a handy slider control. The slider provides
    an alternative method to select the number of disks. The callback function will
    update the text box containing the disk count based on the position of the slider.
    This is done by getting the value of the slider and sending it to the text box
    widget. The purpose of the remaining parameters should be fairly self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The final element of the first row is a progress bar. Here we’re using a Racket
    `gauge%` widget. To update this control, it just needs to be sent a number indicating
    the value to show (the number must be within the specified range).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '***Row 2 Widgets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second row of controls is housed in the horizontal panel `control-panel2`.
    First up is a button that allows the user to step through the solution of the
    puzzle one move at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The state variable `in-motion` is used to flag whether an animation is currently
    in progress. If so, this variable is checked to ensure that the action isn’t re-triggered
    before the step is complete. The `move-list` variable contains the list of moves
    provided by the solver, `hanoi`. If the list is empty, the solution has already
    been generated; in that case, the program is automatically reset. The variable
    `mode` can have one of three values:'
  prefs: []
  type: TYPE_NORMAL
- en: ’`stopped`. Waiting on user input.
  prefs: []
  type: TYPE_NORMAL
- en: ’`step`. Performing a single step.
  prefs: []
  type: TYPE_NORMAL
- en: ’`solve`. Solution animation in progress.
  prefs: []
  type: TYPE_NORMAL
- en: Then `init-next-step` sets up all the state variables to perform the next step
    of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have the button that triggers the full-blown solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The callback for this button is similar to the one for the step button, but
    this time we also check to see whether the user has changed the number of disks
    ➊ , in which case the program is reset to reflect the new number of disks before
    the animation is run. It also sets the `mode` variable to ’`solve`. (If you’re
    bothered by the fact that `(object:button . . . )` prints out in the DrRacket
    window when this is executed, you can wrap this in a `void` form.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The next button is quite simple: it sets `mode` to ’`step`. The mode is checked
    at the end of each step, so this will automatically cause the animation to stop.
    It can be resumed by pressing either the Solve or the Step button.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The last control in the panel is a standard `message%` widget. It’s used to
    display the current state of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '***Getting in Position***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s look at a couple of functions that determine how to position the disks
    on the canvas. Each disk has a number from 1 to `MAX-DISKS` that determines the
    size of the disk. The `disk-x` function is passed the disk number and the number
    of the peg the disk resides on; it then returns the x-coordinate of the disk.
    The `disk-y` function is passed the disk position on a peg (see [Figure 5-4](ch05.xhtml#ch5fig4))
    and returns the y-coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A disk is actually just a rounded rectangle. We’re going to add a little bling
    to our disks by including a gradient. This will make our disks look a little more
    disk-like. If you look closely at [Figure 5-5](ch05.xhtml#ch5fig5), you’ll notice
    that the disks are not a flat color, but give the appearance of being cylindrical.
    To this end we define a function `make-gradient`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a Racket `linear-gradient%` object that can be applied
    to a brush. The `start` and `stop` parameters are the screen *x* locations where
    the gradient is to start and end. Variable `c1` is the color at the ends of the
    gradient, and `c2` is the color in the center of the gradient. Linear gradients
    work by defining a line segment whose end points are given by (*x*[0], *y*[0])
    and (*x*[1], *y*[1]). The colors are applied perpendicularly along the line. That’s
    why for our purposes we can just set the *y* values to 0\. The colors are varied
    along the line by defining a list of *stop* positions. Each position defines the
    position along the line to apply a color. The position is a number between 0 and
    1, where 0 is the color at the start of the line and 1 is the color at the end
    of the line; any number between 0 and 1 would designate a color at some point
    along the line.
  prefs: []
  type: TYPE_NORMAL
- en: To actually draw a disk, we use the following `draw-disk` function. We pass
    this function a drawing context, a disk number, a peg number, and a position on
    the peg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Inside we compute the width of the disk and the x-and y-coordinates. We then
    create a brush using our `make-gradient` function to create a linear gradient
    with which we draw a rounded rectangle to represent a disk.
  prefs: []
  type: TYPE_NORMAL
- en: The following functions draw the disks. The `draw-peg-disks` draws all the disks
    on a single peg. It’s passed a drawing context, a peg number, and a list containing
    the disks that need to be drawn. The `draw-disks` function calls `draw-peg-disks`
    once for each peg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here we have `draw-base`, which draws the base with the pegs (notice the pegs
    also use a linear gradient).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The actual drawing process originates with `update-canvas` as given here. Aside
    from calling `draw-base` and `draw-disks` as described above, it checks to see
    if there’s currently a disk in motion (determined by `current-disk` being greater
    than zero). If this is the case, it also renders the disk being animated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '***Controlling the Animation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re now going to look at a couple of functions used to initialize the state
    variables at two key points in the process: at the start of the solution, and
    before each step. The first is called `reset`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The code above begins by assigning the requested number of disks to the variable
    `num-disks` via a call to `validate-disks` ➊ (`validate-disks` ➏ ensures that
    the user has entered a proper number of disks; if not, it reverts back to the
    previous valid entry). Following this, a list of moves is generated based on the
    requested number of disks ➋. Next, we initialize the `peg-disks` vector with the
    disks on each peg ➌ ➍. The `init-next-step` function ➎ works by extracting the
    next move from the move list to determine the source and destination pegs, target
    locations, and parameters for the disk to be moved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finally arrive at the `move-disk` code responsible for the main animation
    update process. It processes a single move step in three phases: the target disk
    moving up and off the source peg, the disk moving left or right toward the destination
    peg, and the disk moving down to its final resting place. In the code below, `update-progress`
    is used to update the progress bar. It’s called by `move-disk` at the end of each
    step ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Before `move-disk` is called, the target disk source and destination parameters
    would all have been established by a call to `init-next-step`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for vertical movement starts ➊, and the current y-coordinate for the
    disk is updated. A check is then made to see whether the disk is at its target
    location. If the disk is at its target location and was moving up, a new x-coordinate
    target and travel delta for the disk are set. If the disk was moving down, the
    destination peg is updated by adding the animated disk to the list ➋. If the animation
    is in ’`step` mode, the animation timer is turned off and state variables are
    set to indicate the step is complete. Otherwise, the animation is in ’`solve`
    mode, so a check is made to see if any moves remain. If any moves remain, `init-next-step`
    is called; otherwise, the timer is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: The check for horizontal movement is made at ➌. The x-coordinate of the disk
    is updated with a subsequent check to see whether the disk is at its target location
    ➍. If so, it sets up the state variables so that the next time `move-disk` is
    triggered, the disk begins to move down. At the end of every step, the progress
    meter and canvas are updated ➎ ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '***Wrapping Things Up***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The remaining items needed to get things going are given below. First, we define
    `timer` with a callback to `move-disk`. Next, `reset` is called to initialize
    all the state variables. And finally, we show the main window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In addition to a nice little application to explore various facets of the Tower
    of Hanoi puzzle, in the process of building this application, we’ve utilized a
    significant number (but not all) of the widgets provided by the DrRacket environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we began with a couple of simple GUI applications and built
    up to a fairly full-featured application where we were exposed to a number of
    the elements needed to build a robust application. Later in the book, we’ll see
    how to bundle this functionality into a stand-alone application that can be run
    independent of the DrRacket environment. But, next up, we’ll be exploring how
    to access and analyze data in its various incarnations.
  prefs: []
  type: TYPE_NORMAL
