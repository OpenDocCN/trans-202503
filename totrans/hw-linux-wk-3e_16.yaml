- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Compiling Software from C Source Code
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Most nonproprietary third-party Unix software packages come as source code that
    you can build and install. One reason for this is that Unix (and Linux itself)
    has so many different flavors and architectures, it would be difficult to distribute
    binary packages for all possible platform combinations. The other reason, which
    is at least as important, is that widespread source code distribution throughout
    the Unix community encourages users to contribute bug fixes and new features to
    software, giving meaning to the term *open sour**ce*.
  prefs: []
  type: TYPE_NORMAL
- en: You can get nearly everything you see on a Linux system as source code—from
    the kernel and C library to the web browsers. It’s even possible to update and
    augment your entire system by (re-)installing parts of your system from the source
    code. However, you probably *shouldn’t* update your machine by installing *everything*
    from source code, unless you really enjoy the process or have some other reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux distributions typically provide easy ways to update core parts of the
    system, such as the programs in */bin*, and one particularly important property
    of distributions is that they usually fix security problems very quickly. But
    don’t expect your distribution to provide everything for you. Here are some reasons
    why you might want to install certain packages yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: To control configuration options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To install the software anywhere you like. You can even install several different
    versions of the same package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To control the version that you install. Distributions don’t always stay up
    to date with the latest versions of all packages, particularly add-ons to software
    packages (such as Python libraries).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better understand how a package works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1 Software Build Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many programming environments exist on Linux, from traditional C to interpreted
    scripting languages such as Python. Each typically has at least one distinct system
    for building and installing packages in addition to the tools that a Linux distribution
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to look at compiling and installing C source code in this chapter
    with only one of these build systems—the configuration scripts generated from
    the GNU autotools suite. This system is generally considered stable, and many
    of the basic Linux utilities use it. Because it’s based on existing tools such
    as `make`, after you see it in action, you’ll be able to transfer your knowledge
    to other build systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing a package from C source code usually involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unpack the source code archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make` or another build command to build the programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make install` or a distribution-specific install command to install the
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 16.2 Unpacking C Source Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A package’s source code distribution usually comes as a *.tar.gz*, *.tar.bz2*,
    or *.tar.xz* file, and you should unpack the file as described in Section 2.18.
    Before you unpack, though, verify the contents of the archive with `tar tvf` or
    `tar ztvf`, because some packages don’t create their own subdirectories in the
    directory where you extract the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output like this means that the package is probably okay to unpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you might find that not all files are in a common directory (like
    *package-1.23* in the preceding example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Extracting an archive like this one can leave a big mess in your current directory.
    To avoid that, create a new directory and `cd` there before extracting the contents
    of the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, beware of packages that contain files with absolute pathnames like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You likely won’t come across anything like this, but if you do, remove the archive
    from your system. It probably contains a Trojan horse or some other malicious
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve extracted the contents of a source archive and have a bunch of files
    in front of you, try to get a feel for the package. In particular, look for the
    files named something like *README* and *INSTALL*. Always look at any *README*
    files first because they often contain a description of the package, a short manual,
    installation hints, and other useful information. Many packages also come with
    *INSTALL* files containing instructions on how to compile and install the package.
    Pay particular attention to special compiler options and definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to *README* and *INSTALL* files, you’ll find other package files
    that roughly fall into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Files relating to the `make` system, such as *Makefile*, *Makefile.in*, *configure*,
    and *CMakeLists.txt*. Some very old packages come with a Makefile that you might
    need to modify, but most use a configuration utility, such as GNU autoconf or
    CMake. They come with a script or configuration file (such as *configure* or *CMakeLists.txt*)
    to help generate a Makefile from *Makefile.in* based on your system settings and
    configuration options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code files ending in *.c*, *.h*, or *.cc*. C source code files may appear
    just about anywhere in a package directory. C++ source code files usually have
    *.cc*, *.C*, or *.cxx* suffixes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object files ending in *.o* or binaries. Normally, there aren’t any object files
    in source code distributions, but you might find some in rare cases when the package
    maintainer is not permitted to release certain source code and you need to do
    something special in order to use the object files. In most cases, object (or
    binary executable) files in a source distribution mean that the package wasn’t
    put together well, so you should run `make clean` to make sure that you get a
    fresh compile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3 GNU Autoconf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though C source code is usually fairly portable, differences on each platform
    make it impossible to compile most packages with a single Makefile. Early solutions
    to this problem were to provide individual Makefiles for every operating system
    or to provide a Makefile that was easy to modify. This approach evolved into scripts
    that generate Makefiles based on an analysis of the system used to build the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU autoconf is a popular system for automatic Makefile generation. Packages
    using this system come with files named *configure*, *Makefile.in*, and *config.h.in*.
    The *.in* files are templates; the idea is to run the `configure` script in order
    to discover the characteristics of your system, and then make substitutions in
    the *.in* files to create the real build files. For the end user, it’s easy; to
    generate a Makefile from *Makefile.in*, run `configure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should get a lot of diagnostic output as the script checks your system for
    prerequisites. If all goes well, `configure` creates one or more Makefiles and
    a *config.h* file, as well as a cache file (*config.cache*), so that it doesn’t
    need to run certain tests again.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can run `make` to compile the package. A successful `configure` step
    doesn’t necessarily mean that the `make` step will work, but the chances are pretty
    good. (See Section 16.6 for tips on troubleshooting failed configures and compiles.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get some firsthand experience with the process.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.1  An Autoconf Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before discussing how you can change the behavior of autoconf, let’s look at
    a simple example so that you know what to expect. You’ll install the GNU coreutils
    package in your own home directory (to make sure that you don’t mess up your system).
    Get the package from [http://ftp.gnu.org/gnu/coreutils/](http://ftp.gnu.org/gnu/coreutils/)
    (the latest version is usually the best), unpack it, change to its directory,
    and configure it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, try to run one of the executables you just created, such as *./src/ls*,
    and try running `make check` to run a series of tests on the package. (This might
    take a while, but it’s interesting to see.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you’re ready to install the package. Do a dry run with `make -n` first
    to see what `make install` does without actually doing the install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse through the output, and if nothing seems strange (such as the package
    installing anywhere other than your *mycoreutils* directory), do the install for
    real:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a subdirectory named *mycoreutils* in your home directory
    that contains *bin*, *share*, and other subdirectories. Check out some of the
    programs in *bin* (you just built many of the basic tools that you learned about
    in Chapter 2). Finally, because you configured the *mycoreutils* directory to
    be independent of the rest of your system, you can remove it completely without
    worrying about causing damage.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.2  Installation Using a Packaging Tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On most distributions, it’s possible to install new software as a package that
    you can maintain later with your distribution’s packaging tools. Debian-based
    distributions, such as Ubuntu, are perhaps the easiest; rather than running a
    plain `make install`, you install the package with the `checkinstall` utility,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Running this command shows the settings pertaining to the package that you’re
    about to build, and gives you the opportunity to change them. When you proceed
    with the installation, `checkinstall` keeps track of all of the files to be installed
    on the system and puts them into a *.deb* file. You can then use `dpkg` to install
    (and remove) the new package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RPM package is a little more involved, because you must first create
    a directory tree for your package(s). You can do this with the `rpmdev-setuptree`
    command; when complete, you can use the `rpmbuild` utility to work through the
    rest of the steps. It’s best to follow an online tutorial for this process.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.3  configure Script Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve just seen one of the most useful options for the `configure` script:
    using `--prefix` to specify the installation directory. By default, the `install`
    target from an autoconf-generated Makefile uses a *prefix* of */usr/local*—that
    is, binary programs go in */usr/local/bin*, libraries go in */usr/local/lib*,
    and so on. You will often want to change that prefix like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Most versions of `configure` have a `--help` option that lists other configuration
    options. Unfortunately, the list is usually so long that it’s sometimes hard to
    figure out what might be important, so here are some essential options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--bindir=``directory` Installs executables in `directory`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--sbindir=``directory` Installs system executables in `directory`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--libdir=``directory` Installs libraries in `directory`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--disable-shared` Prevents the package from building shared libraries. Depending
    on the library, this can save hassles later on (see Section 15.1.3).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--with-``package``=``directory` Tells `configure` that `package` is in `directory`.
    This is handy when a necessary library is in a nonstandard location. Unfortunately,
    not all `configure` scripts recognize this type of option, and it can be difficult
    to determine the exact syntax.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 16.3.4  Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can influence `configure` with environment variables that the `configure`
    script puts into `make` variables. The most important ones are `CPPFLAGS`, `CFLAGS`,
    and `LDFLAGS`. But be aware that `configure` can be very picky about environment
    variables. For example, you should normally use `CPPFLAGS` instead of `CFLAGS`
    for header file directories, because `configure` often runs the preprocessor independently
    of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `bash`, the easiest way to send an environment variable to `configure` is
    by placing the variable assignment in front of .`/configure` on the command line.
    For example, to define a `DEBUG` macro for the preprocessor, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass a variable as an option to `configure`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Environment variables are especially handy when `configure` doesn’t know where
    to look for third-party include files and libraries. For example, to make the
    preprocessor search in `include_dir`, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in Section 15.2.6, to make the linker look in `lib_dir`, use this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If `lib_dir` has shared libraries (see Section 15.1.3), the previous command
    probably won’t set the runtime dynamic linker path. In that case, use the `-rpath`
    linker option in addition to `-L`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful when setting variables. A small slip can trip up the compiler and
    cause `configure` to fail. For example, say you forget the `-` in `-I`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Digging through the *config.log* generated from this failed attempt yields
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 16.3.5  Autoconf Targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you get `configure` working, you’ll find that the Makefile it generates
    has a number of useful targets in addition to the standard `all` and `install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make clean` As described in Chapter 15, this removes all object files, executables,
    and libraries.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make distclean` This is similar to `make clean` except it removes all automatically
    generated files, including Makefiles, *config.h*, *config.log*, and so on. The
    idea is that the source tree should look like a newly unpacked distribution after
    running `make distclean`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make check` Some packages come with a battery of tests to verify that the
    compiled programs work properly; the command `make check` runs those tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make install-strip` This is like `make install` except it strips the symbol
    table and other debugging information from executables and libraries when installing.
    Stripped binaries require much less space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 16.3.6  Autoconf Logfiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If something goes wrong during the configure process and the cause isn’t obvious,
    you can examine *config.log* to find the problem. Unfortunately, *config.log*
    is often a gigantic file, which can make it difficult to locate the exact source
    of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: The general approach in this situation is to go to the very end of *config.log*
    (for example, by typing a capital G in `less`) and then page back up until you
    see the problem. However, there’s still a lot of stuff at the end because `configure`
    dumps its entire environment there, including output variables, cache variables,
    and other definitions. So, rather than going to the end and paging up, go to the
    end and search backward for a string, such as `for more details` or some other
    fragment of text near the end of the failed `configure` output. (Remember, you
    can initiate a reverse search in `less` with the `?` command.) There’s a good
    chance the error will be right above what your search finds.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.7  pkg-config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The multitude of third-party libraries on a system means that keeping all of
    them in a common location can be messy. However, installing each with a separate
    prefix can lead to problems with building packages that require those third-party
    libraries. For example, if you want to compile OpenSSH, you need the OpenSSL library.
    How do you tell the OpenSSH configuration process the location of the OpenSSL
    libraries and which ones are required?
  prefs: []
  type: TYPE_NORMAL
- en: 'Many libraries now use the `pkg-config` program not only to advertise the locations
    of their include files and libraries but also to specify the exact flags you need
    to compile and link a program. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to find the libraries required for a popular compression library,
    you can run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all libraries that `pkg-config` knows about, including a brief description
    of each, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How pkg-config Works
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you look behind the scenes, you’ll find that `pkg-config` finds package
    information by reading configuration files that end with *.pc*. For example, here’s
    *openssl.pc* for the OpenSSL socket library, as seen on an Ubuntu system (located
    in */usr/lib/x86_64-linux-gnu/pkgconfig*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can change this file, for example, by adding `-Wl,-rpath=${libdir}` to the
    library flags to set a runtime library search path. However, the bigger question
    is how `pkg-config` finds the *.pc* files in the first place. By default, `pkg-config`
    looks in the *lib/pkgconfig* directory of its installation prefix. For example,
    a `pkg-config` installed with a */usr/local* prefix looks in */usr/local/lib/pkgconfig*.
  prefs: []
  type: TYPE_NORMAL
- en: How to Install pkg-config Files in Nonstandard Locations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, by default, `pkg-config` doesn’t read any *.pc* files outside
    its installation prefix. This means that a *.pc* file that’s in a nonstandard
    location, such as */opt/openssl/lib/pkgconfig/openssl.pc*, will be out of the
    reach of any stock `pkg-config` installation. There are two basic ways to make
    *.pc* files available outside the `pkg-config` installation prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: Make symbolic links (or copies) from the actual *.pc* files to the central *pkgconfig*
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set your `PKG_CONFIG_PATH` environment variable to include any extra *pkgconfig*
    directories. This strategy does not work well on a systemwide basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4 Installation Practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knowing *how* to build and install software is good, but knowing *when* and
    *where* to install your own packages is even more useful. Linux distributions
    try to cram in as much software as possible at installation, so you should always
    check whether it would be better to install a package yourself instead. Here are
    the advantages of doing installs on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: You can customize package defaults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When installing a package, you often get a clearer picture of how to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You control the release that you run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier to back up a custom package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier to distribute self-installed packages across a network (as long
    as the architecture is consistent and the installation location is relatively
    isolated).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: If the package you want to install is already installed on your system, you
    might overwrite important files, causing problems. Avoid this by using the */usr/local*
    install prefix, described shortly. Even if the package isn’t installed on your
    system, you should check to see if the distribution has a package available. If
    it does, you need to remember this in case you accidentally install the distribution
    package later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom packages do not automatically upgrade themselves. Distributions keep
    most packages up to date without requiring much work from you. This is a particular
    concern for packages that interact with the network, because you want to ensure
    that you always have the latest security updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don’t actually use the package, you’re wasting your time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a potential for misconfiguring packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s not much point in installing packages such as those in the coreutils
    package you built earlier in the chapter (`ls`, `cat`, and so on) unless you’re
    building a very custom system. On the other hand, if you have a vital interest
    in network servers such as Apache, the best way to get complete control is to
    install the servers yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.1  Where to Install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default prefix in GNU autoconf and many other packages is */usr/local*,
    the traditional directory for locally installed software. Operating system upgrades
    ignore */usr/local*, so you won’t lose anything installed there during an operating
    system upgrade, and for small local software installations, */usr/local* is fine.
    The only problem is that if you have a lot of custom software installed, this
    can turn into a terrible mess. Thousands of odd little files can make their way
    into the */usr/local* hierarchy, and you may have no idea where the files came
    from.
  prefs: []
  type: TYPE_NORMAL
- en: If things really start to get unruly, you should create your own packages as
    described in Section 16.3.2.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Applying a Patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most changes to software source code are available as branches of the developer’s
    online version of the source code (such as a Git repository). However, every now
    and then, you might get a *patch* that you need to apply against source code to
    fix bugs or add features. You may also see the term *diff* used as a synonym for
    patch, because the `diff` program produces the patch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beginning of a patch looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Patches usually contain alterations to more than one file. Search the patch
    for three dashes in a row (`---`) to see the files that have alterations and always
    look at the beginning of a patch to determine the required working directory.
    Notice that the preceding example refers to *src/file.c*. Therefore, you should
    change to the directory that contains *src* before applying the patch, *not* to
    the *src* directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the patch, run the `patch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, `patch` exits without a fuss, leaving you with an
    updated set of files. However, `patch` might ask you this question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This usually means you’re not in the correct directory, but it could also indicate
    that your source code doesn’t match the source code in the patch. In this case,
    you’re probably out of luck. Even if you could identify some of the files to patch,
    others would not be properly updated, leaving you with source code that you could
    not compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you might come across a patch that refers to a package version
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a slightly different version number (or you just renamed the directory),
    you can tell `patch` to strip leading path components. For example, say you were
    in the directory that contains *src* (as before). To tell `patch` to ignore the
    *package-3.42/* part of the path (that is, strip one leading path component),
    use `-p1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 16.6 Troubleshooting Compiles and Installations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you understand the difference between compiler errors, compiler warnings,
    linker errors, and shared library problems as described in Chapter 15, you shouldn’t
    have too much trouble fixing many of the glitches that arise when you’re building
    software. This section covers some common problems. Although you’re unlikely to
    run into any of these issues when building using autoconf, it never hurts to know
    what they look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before covering specifics, make sure that you can read certain kinds of `make`
    output. It’s important to know the difference between an error and an ignored
    error. The following is a real error that you need to investigate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, some Makefiles suspect that an error condition might occur but know
    that these errors are harmless. You can usually disregard any messages like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, GNU `make` often calls itself many times in large packages, with
    each instance of `make` in the error message marked with `[``N``]`, where `N`
    is a number. You can often quickly find the error by looking at the `make` error
    that comes *directly* after the compiler error message. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines here give you the information you need. The trouble centers
    around *file.c*, located in */home/src/package-5.0/src*. Unfortunately, there’s
    so much extra output that it can be difficult to spot the important details. Learning
    how to filter out the subsequent `make` errors goes a long way toward helping
    you dig out the real cause.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6.1  Specific Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some common build errors that you might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiler error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Explanation and fix**'
  prefs: []
  type: TYPE_NORMAL
- en: The programmer made an erroneous redeclaration of `item` on line 22 of *src.c*.
    You can usually fix this by removing the offending line (with a comment, an `#ifdef`,
    or whatever works).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiler error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Explanation and fix**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer forgot a critical header file. The manual pages are the best
    way to find the missing header file. First, look at the offending line (in this
    case, line 37 in *src.c*). It’s probably a variable declaration like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Search forward for `v1` in the program for its use around a function call.
    For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run `man 2 time` or `man 3 time` to look for system and library calls named
    `time()`. In this case, the section 2 manual page has what you need:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that `time()` requires *time.h*. Place `#include <time.h>` at the
    beginning of *src.c* and try again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiler (preprocessor) error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Explanation and fix**'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler ran the C preprocessor on *src.c* but could not find the *pkg.h*
    include file. The source code likely depends on a library that you need to install,
    or you may just need to provide the compiler with the nonstandard include path.
    Usually, you’ll just need to add a `-I` include path option to the C preprocessor
    flags (`CPPFLAGS`). (Keep in mind that you might also need a `-L` linker flag
    to go along with the include files.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it doesn’t look as though you’re missing a library, there’s an outside chance
    you’re attempting a compile for an operating system that this source code does
    not support. Check the Makefile and *README* files for details about platforms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you’re running a Debian-based distribution, try the `apt-file` command on
    the header filename:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This might find the development package that you need. For distributions that
    use `yum`, you can try this instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make` error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Explanation and fix**'
  prefs: []
  type: TYPE_NORMAL
- en: To build the package, you need `prog` on your system. If `prog` is something
    like `cc`, `gcc`, or `ld`, you don’t have the development utilities installed
    on your system. On the other hand, if you think `prog` is already installed on
    your system, try altering the Makefile to specify the full pathname of `prog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In rare cases with poorly configured source code, `make` builds `prog` and then
    uses `prog` immediately, assuming that the current directory (`.`) is in your
    command path. If your `$PATH` does not include the current directory, you can
    edit the Makefile and change `prog` to `./``prog`. Alternatively, you could append
    `.` to your path temporarily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 16.7 Looking Forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve touched only on the basics of building software. After you get the hang
    of your own builds, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to use build systems other than autoconf, such as CMake and SCons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up builds for your own software. If you’re writing your own software, you
    want to choose a build system and learn to use it. For GNU autoconf packaging,
    *Autotools*, 2nd edition, by John Calcote (No Starch Press, 2019) can help you
    out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the Linux kernel. The kernel’s build system is completely different
    from that of other tools. It has its own configuration system tailored to customizing
    your own kernel and modules. The procedure is straightforward, though, and if
    you understand how the bootloader works, you won’t have any trouble with it. However,
    you should be careful when doing so; make sure that you always keep your old kernel
    handy in case you can’t boot with a new one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore distribution-specific source packages. Linux distributions maintain
    their own versions of software source code as special source packages. Sometimes
    you can find useful patches that expand functionality or fix problems in otherwise
    unmaintained packages. The source package management systems include tools for
    automatic builds, such as Debian’s `debuild` and the RPM-based `mock`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building software is often a stepping stone to learning about programming and
    software development. The tools you’ve seen in this chapter and the previous chapter
    take the mystery out of where your system software came from. It’s not difficult
    to take the next steps of looking inside the source code, making changes, and
    creating your own software.
  prefs: []
  type: TYPE_NORMAL
