- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Introduction to Compiling Software from C Source Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C 源代码编译软件的简介
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Most nonproprietary third-party Unix software packages come as source code that
    you can build and install. One reason for this is that Unix (and Linux itself)
    has so many different flavors and architectures, it would be difficult to distribute
    binary packages for all possible platform combinations. The other reason, which
    is at least as important, is that widespread source code distribution throughout
    the Unix community encourages users to contribute bug fixes and new features to
    software, giving meaning to the term *open sour**ce*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数非专有的第三方 Unix 软件包以源代码形式提供，允许你构建和安装。这样做的一个原因是，Unix（以及 Linux 本身）有太多不同的版本和架构，难以为所有可能的平台组合分发二进制软件包。另一个至少同样重要的原因是，Unix
    社区广泛分发源代码，鼓励用户为软件贡献错误修复和新功能，这也赋予了 *开源* 这个词意义。
- en: You can get nearly everything you see on a Linux system as source code—from
    the kernel and C library to the web browsers. It’s even possible to update and
    augment your entire system by (re-)installing parts of your system from the source
    code. However, you probably *shouldn’t* update your machine by installing *everything*
    from source code, unless you really enjoy the process or have some other reason.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过源代码获取 Linux 系统上几乎所有看到的内容——从内核和 C 库到网页浏览器。实际上，你甚至可以通过（重新）安装系统的一部分源代码来更新和增强你的整个系统。然而，除非你非常喜欢这个过程或者有其他原因，否则你可能*不应该*通过从源代码安装*所有*内容来更新你的机器。
- en: 'Linux distributions typically provide easy ways to update core parts of the
    system, such as the programs in */bin*, and one particularly important property
    of distributions is that they usually fix security problems very quickly. But
    don’t expect your distribution to provide everything for you. Here are some reasons
    why you might want to install certain packages yourself:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 发行版通常提供方便的方式来更新系统的核心部分，如 */bin* 中的程序，而发行版的一个特别重要的特点是它们通常能非常快速地修复安全问题。但不要指望你的发行版会为你提供所有内容。以下是你可能需要自己安装某些软件包的几个原因：
- en: To control configuration options.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制配置选项。
- en: To install the software anywhere you like. You can even install several different
    versions of the same package.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将软件安装到你喜欢的任何位置。你甚至可以安装同一个软件包的多个不同版本。
- en: To control the version that you install. Distributions don’t always stay up
    to date with the latest versions of all packages, particularly add-ons to software
    packages (such as Python libraries).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制你安装的版本。不同的发行版并不总是与所有软件包的最新版本保持同步，尤其是软件包的附加组件（例如 Python 库）。
- en: To better understand how a package works.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地理解某个软件包是如何工作的。
- en: 16.1 Software Build Systems
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 软件构建系统
- en: Many programming environments exist on Linux, from traditional C to interpreted
    scripting languages such as Python. Each typically has at least one distinct system
    for building and installing packages in addition to the tools that a Linux distribution
    provides.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上有许多编程环境，从传统的 C 语言到解释型脚本语言如 Python。每种环境通常都有至少一个独特的系统用于构建和安装软件包，除此之外还有
    Linux 发行版提供的工具。
- en: We’re going to look at compiling and installing C source code in this chapter
    with only one of these build systems—the configuration scripts generated from
    the GNU autotools suite. This system is generally considered stable, and many
    of the basic Linux utilities use it. Because it’s based on existing tools such
    as `make`, after you see it in action, you’ll be able to transfer your knowledge
    to other build systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍如何使用其中一个构建系统——由 GNU autotools 套件生成的配置脚本，来编译和安装 C 源代码。这个系统通常被认为是稳定的，许多基本的
    Linux 工具都使用它。由于它是基于现有工具（如 `make`）构建的，因此当你看到它的实际操作后，你将能够将你的知识转移到其他构建系统上。
- en: 'Installing a package from C source code usually involves the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C 源代码安装软件包通常涉及以下步骤：
- en: Unpack the source code archive.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压源代码归档。
- en: Configure the package.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置软件包。
- en: Run `make` or another build command to build the programs.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `make` 或其他构建命令来构建程序。
- en: Run `make install` or a distribution-specific install command to install the
    package.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `make install` 或发行版特定的安装命令来安装软件包。
- en: 16.2 Unpacking C Source Packages
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 解压 C 源代码包
- en: A package’s source code distribution usually comes as a *.tar.gz*, *.tar.bz2*,
    or *.tar.xz* file, and you should unpack the file as described in Section 2.18.
    Before you unpack, though, verify the contents of the archive with `tar tvf` or
    `tar ztvf`, because some packages don’t create their own subdirectories in the
    directory where you extract the archive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 包的源代码分发通常是作为*.tar.gz*、*.tar.bz2*或*.tar.xz*文件提供的，你应该按照第2.18节中描述的方式解压该文件。然而，在解压之前，使用`tar
    tvf`或`tar ztvf`验证归档的内容，因为有些包不会在解压归档的目录中创建自己的子目录。
- en: 'Output like this means that the package is probably okay to unpack:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的输出意味着该包可能适合解压：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, you might find that not all files are in a common directory (like
    *package-1.23* in the preceding example):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会发现并非所有文件都位于一个公共目录中（就像前面的例子中的*package-1.23*）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Extracting an archive like this one can leave a big mess in your current directory.
    To avoid that, create a new directory and `cd` there before extracting the contents
    of the archive.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解压像这样的归档文件可能会在当前目录中留下很多杂乱的文件。为了避免这种情况，在解压归档内容之前，创建一个新目录并`cd`到该目录。
- en: 'Finally, beware of packages that contain files with absolute pathnames like
    this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意包含绝对路径名的文件包，例如下面这样：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You likely won’t come across anything like this, but if you do, remove the archive
    from your system. It probably contains a Trojan horse or some other malicious
    code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会遇到类似这样的情况，但如果遇到，请从系统中删除该归档文件。它可能包含木马或其他恶意代码。
- en: Once you’ve extracted the contents of a source archive and have a bunch of files
    in front of you, try to get a feel for the package. In particular, look for the
    files named something like *README* and *INSTALL*. Always look at any *README*
    files first because they often contain a description of the package, a short manual,
    installation hints, and other useful information. Many packages also come with
    *INSTALL* files containing instructions on how to compile and install the package.
    Pay particular attention to special compiler options and definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你提取了源归档的内容，并且面前有一堆文件，试着对包的内容有个大致了解。特别是，查找名为*README*和*INSTALL*的文件。始终先查看任何*README*文件，因为它们通常包含包的描述、简短手册、安装提示和其他有用的信息。许多包还附带*INSTALL*文件，包含如何编译和安装该包的说明。特别注意特殊的编译器选项和定义。
- en: 'In addition to *README* and *INSTALL* files, you’ll find other package files
    that roughly fall into three categories:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*README*和*INSTALL*文件，你还会找到其他文件，这些文件大致可以分为三类：
- en: Files relating to the `make` system, such as *Makefile*, *Makefile.in*, *configure*,
    and *CMakeLists.txt*. Some very old packages come with a Makefile that you might
    need to modify, but most use a configuration utility, such as GNU autoconf or
    CMake. They come with a script or configuration file (such as *configure* or *CMakeLists.txt*)
    to help generate a Makefile from *Makefile.in* based on your system settings and
    configuration options.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`make`系统相关的文件，例如*Makefile*、*Makefile.in*、*configure*和*CMakeLists.txt*。一些非常旧的包附带一个Makefile，你可能需要修改它，但大多数包使用配置工具，如GNU
    autoconf或CMake。它们附带一个脚本或配置文件（例如*configure*或*CMakeLists.txt*），帮助你根据系统设置和配置选项从*Makefile.in*生成Makefile。
- en: Source code files ending in *.c*, *.h*, or *.cc*. C source code files may appear
    just about anywhere in a package directory. C++ source code files usually have
    *.cc*, *.C*, or *.cxx* suffixes.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以*.c*、*.h*或*.cc*结尾的源代码文件。C源代码文件可能出现在包目录的任何位置。C++源代码文件通常具有*.cc*、*.C*或*.cxx*后缀。
- en: Object files ending in *.o* or binaries. Normally, there aren’t any object files
    in source code distributions, but you might find some in rare cases when the package
    maintainer is not permitted to release certain source code and you need to do
    something special in order to use the object files. In most cases, object (or
    binary executable) files in a source distribution mean that the package wasn’t
    put together well, so you should run `make clean` to make sure that you get a
    fresh compile.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以*.o*结尾的目标文件或二进制文件。通常，源代码分发包中没有目标文件，但在某些罕见情况下，当包的维护者无法发布某些源代码时，你可能会找到目标文件，这时你需要做一些特别的操作才能使用这些目标文件。在大多数情况下，源代码分发包中的目标文件（或二进制可执行文件）意味着包的组织不够规范，因此你应该运行`make
    clean`，以确保进行一次全新的编译。
- en: 16.3 GNU Autoconf
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 GNU Autoconf
- en: Even though C source code is usually fairly portable, differences on each platform
    make it impossible to compile most packages with a single Makefile. Early solutions
    to this problem were to provide individual Makefiles for every operating system
    or to provide a Makefile that was easy to modify. This approach evolved into scripts
    that generate Makefiles based on an analysis of the system used to build the package.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C源代码通常是相当可移植的，但每个平台的差异使得大多数软件包无法使用单一的Makefile进行编译。对此问题的早期解决方案是为每个操作系统提供单独的Makefile，或者提供一个易于修改的Makefile。这个方法演变成了基于对构建软件包所使用系统的分析，自动生成Makefile的脚本。
- en: 'GNU autoconf is a popular system for automatic Makefile generation. Packages
    using this system come with files named *configure*, *Makefile.in*, and *config.h.in*.
    The *.in* files are templates; the idea is to run the `configure` script in order
    to discover the characteristics of your system, and then make substitutions in
    the *.in* files to create the real build files. For the end user, it’s easy; to
    generate a Makefile from *Makefile.in*, run `configure`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GNU autoconf是一个流行的自动生成Makefile的系统。使用该系统的包会附带名为*configure*、*Makefile.in*和*config.h.in*的文件。*.in*文件是模板；其目的是运行`configure`脚本来发现系统的特性，然后在*.in*文件中进行替换，从而生成真实的构建文件。对最终用户来说，这很简单；只需运行`configure`来从*Makefile.in*生成Makefile：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should get a lot of diagnostic output as the script checks your system for
    prerequisites. If all goes well, `configure` creates one or more Makefiles and
    a *config.h* file, as well as a cache file (*config.cache*), so that it doesn’t
    need to run certain tests again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本检查你的系统是否满足前提条件时，你应该会看到很多诊断输出。如果一切顺利，`configure`将生成一个或多个Makefile和一个*config.h*文件，以及一个缓存文件（*config.cache*），以便它在以后不需要再次运行某些测试。
- en: Now you can run `make` to compile the package. A successful `configure` step
    doesn’t necessarily mean that the `make` step will work, but the chances are pretty
    good. (See Section 16.6 for tips on troubleshooting failed configures and compiles.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行`make`来编译软件包。成功的`configure`步骤并不意味着`make`步骤一定会成功，但成功的几率相当大。（有关解决配置和编译失败的提示，请参见第16.6节。）
- en: Let’s get some firsthand experience with the process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们亲自体验一下这个过程。
- en: 16.3.1  An Autoconf Example
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1  一个Autoconf示例
- en: 'Before discussing how you can change the behavior of autoconf, let’s look at
    a simple example so that you know what to expect. You’ll install the GNU coreutils
    package in your own home directory (to make sure that you don’t mess up your system).
    Get the package from [http://ftp.gnu.org/gnu/coreutils/](http://ftp.gnu.org/gnu/coreutils/)
    (the latest version is usually the best), unpack it, change to its directory,
    and configure it like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何更改autoconf的行为之前，让我们先看一个简单的示例，以便了解你可以期待什么。你将会在自己的主目录中安装GNU coreutils包（以确保不会破坏系统）。从[http://ftp.gnu.org/gnu/coreutils/](http://ftp.gnu.org/gnu/coreutils/)获取该包（最新版本通常是最好的），解压缩它，进入其目录并像下面这样进行配置：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now run `make`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`make`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, try to run one of the executables you just created, such as *./src/ls*,
    and try running `make check` to run a series of tests on the package. (This might
    take a while, but it’s interesting to see.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试运行你刚刚创建的其中一个可执行文件，例如*./src/ls*，并尝试运行`make check`以对软件包进行一系列测试。（这可能需要一些时间，但看看结果还是挺有趣的。）
- en: 'Finally, you’re ready to install the package. Do a dry run with `make -n` first
    to see what `make install` does without actually doing the install:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你准备好安装软件包了。首先使用`make -n`进行干运行，查看`make install`会做什么，而不实际执行安装：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Browse through the output, and if nothing seems strange (such as the package
    installing anywhere other than your *mycoreutils* directory), do the install for
    real:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览输出内容，如果没有什么奇怪的地方（例如软件包安装到*mycoreutils*目录以外的位置），就可以正式安装了：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should now have a subdirectory named *mycoreutils* in your home directory
    that contains *bin*, *share*, and other subdirectories. Check out some of the
    programs in *bin* (you just built many of the basic tools that you learned about
    in Chapter 2). Finally, because you configured the *mycoreutils* directory to
    be independent of the rest of your system, you can remove it completely without
    worrying about causing damage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在你的主目录下拥有一个名为*mycoreutils*的子目录，其中包含*bin*、*share*和其他子目录。查看一下*bin*中的一些程序（你刚刚构建了许多你在第2章学习的基础工具）。最后，由于你已经将*mycoreutils*目录配置为独立于你系统的其他部分，你可以完全删除它，而不必担心会造成损坏。
- en: 16.3.2  Installation Using a Packaging Tool
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2  使用打包工具进行安装
- en: 'On most distributions, it’s possible to install new software as a package that
    you can maintain later with your distribution’s packaging tools. Debian-based
    distributions, such as Ubuntu, are perhaps the easiest; rather than running a
    plain `make install`, you install the package with the `checkinstall` utility,
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数发行版中，可以将新软件安装为一个包，之后可以使用发行版的打包工具进行维护。基于Debian的发行版，如Ubuntu，可能是最容易的；你不是运行简单的`make
    install`，而是使用`checkinstall`工具来安装软件包，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Running this command shows the settings pertaining to the package that you’re
    about to build, and gives you the opportunity to change them. When you proceed
    with the installation, `checkinstall` keeps track of all of the files to be installed
    on the system and puts them into a *.deb* file. You can then use `dpkg` to install
    (and remove) the new package.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将显示与即将构建的包相关的设置，并提供更改它们的机会。安装时，`checkinstall`会跟踪所有要安装到系统上的文件，并将它们放入*.deb*文件中。然后你可以使用`dpkg`安装（或移除）新包。
- en: Creating an RPM package is a little more involved, because you must first create
    a directory tree for your package(s). You can do this with the `rpmdev-setuptree`
    command; when complete, you can use the `rpmbuild` utility to work through the
    rest of the steps. It’s best to follow an online tutorial for this process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建RPM包稍微复杂一些，因为你必须首先为你的包创建一个目录树。你可以使用`rpmdev-setuptree`命令来完成这一步；完成后，你可以使用`rpmbuild`工具继续进行其余的步骤。最好根据在线教程进行此过程。
- en: 16.3.3  configure Script Options
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.3  配置脚本选项
- en: 'You’ve just seen one of the most useful options for the `configure` script:
    using `--prefix` to specify the installation directory. By default, the `install`
    target from an autoconf-generated Makefile uses a *prefix* of */usr/local*—that
    is, binary programs go in */usr/local/bin*, libraries go in */usr/local/lib*,
    and so on. You will often want to change that prefix like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到的是`configure`脚本最有用的选项之一：使用`--prefix`来指定安装目录。默认情况下，自动生成的Makefile中的`install`目标使用*/usr/local*作为*prefix*—即，二进制程序放在*/usr/local/bin*，库文件放在*/usr/local/lib*，以此类推。你通常会想要更改这个前缀，方法如下：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Most versions of `configure` have a `--help` option that lists other configuration
    options. Unfortunately, the list is usually so long that it’s sometimes hard to
    figure out what might be important, so here are some essential options:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数版本的`configure`都有一个`--help`选项，可以列出其他配置选项。不幸的是，列表通常很长，有时很难弄清楚哪些选项可能重要，因此这里列出了一些基本的选项：
- en: '`--bindir=``directory` Installs executables in `directory`.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--bindir=``directory` 将可执行文件安装到`directory`中。'
- en: '`--sbindir=``directory` Installs system executables in `directory`.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--sbindir=``directory` 将系统可执行文件安装到`directory`中。'
- en: '`--libdir=``directory` Installs libraries in `directory`.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--libdir=``directory` 将库安装到`directory`。'
- en: '`--disable-shared` Prevents the package from building shared libraries. Depending
    on the library, this can save hassles later on (see Section 15.1.3).'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--disable-shared` 防止构建共享库。根据库的不同，这可以避免后续出现麻烦（参见第15.1.3节）。'
- en: '`--with-``package``=``directory` Tells `configure` that `package` is in `directory`.
    This is handy when a necessary library is in a nonstandard location. Unfortunately,
    not all `configure` scripts recognize this type of option, and it can be difficult
    to determine the exact syntax.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--with-``package``=``directory` 告诉`configure`，`package`位于`directory`中。当必要的库位于非标准位置时，这个选项非常有用。不幸的是，并非所有的`configure`脚本都支持这种类型的选项，而且确定确切的语法可能很困难。'
- en: 16.3.4  Environment Variables
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.4  环境变量
- en: You can influence `configure` with environment variables that the `configure`
    script puts into `make` variables. The most important ones are `CPPFLAGS`, `CFLAGS`,
    and `LDFLAGS`. But be aware that `configure` can be very picky about environment
    variables. For example, you should normally use `CPPFLAGS` instead of `CFLAGS`
    for header file directories, because `configure` often runs the preprocessor independently
    of the compiler.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过环境变量影响`configure`，因为`configure`脚本会将这些变量传递给`make`。最重要的环境变量包括`CPPFLAGS`、`CFLAGS`和`LDFLAGS`。但需要注意的是，`configure`对环境变量非常挑剔。例如，你通常应该使用`CPPFLAGS`而不是`CFLAGS`来指定头文件目录，因为`configure`经常在独立于编译器的情况下运行预处理器。
- en: 'In `bash`, the easiest way to send an environment variable to `configure` is
    by placing the variable assignment in front of .`/configure` on the command line.
    For example, to define a `DEBUG` macro for the preprocessor, use this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bash`中，发送环境变量给`configure`的最简单方法是将变量赋值放在命令行的`./configure`之前。例如，要为预处理器定义一个`DEBUG`宏，可以使用以下命令：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also pass a variable as an option to `configure`; for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个变量作为选项传递给`configure`；例如：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Environment variables are especially handy when `configure` doesn’t know where
    to look for third-party include files and libraries. For example, to make the
    preprocessor search in `include_dir`, run this command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量在`configure`不知道在哪里查找第三方包含文件和库时特别有用。例如，要让预处理器在`include_dir`中查找，运行以下命令：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As shown in Section 15.2.6, to make the linker look in `lib_dir`, use this
    command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如第15.2.6节所示，要让链接器在`lib_dir`中查找，使用以下命令：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If `lib_dir` has shared libraries (see Section 15.1.3), the previous command
    probably won’t set the runtime dynamic linker path. In that case, use the `-rpath`
    linker option in addition to `-L`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lib_dir`中包含共享库（参见第15.1.3节），上面的命令可能无法设置运行时动态链接器路径。在这种情况下，除了使用`-L`外，还需要使用`-rpath`链接器选项：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Be careful when setting variables. A small slip can trip up the compiler and
    cause `configure` to fail. For example, say you forget the `-` in `-I`, as shown
    here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设置变量时要小心。一个小小的错误可能会让编译器出错，导致`configure`失败。例如，假设你忘记了`-`，如这里所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This yields an error like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下错误：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Digging through the *config.log* generated from this failed attempt yields
    this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个失败的尝试生成的*config.log*中查看，结果如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 16.3.5  Autoconf Targets
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.5  Autoconf目标
- en: 'Once you get `configure` working, you’ll find that the Makefile it generates
    has a number of useful targets in addition to the standard `all` and `install`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你让`configure`正常工作，你会发现它生成的Makefile除了标准的`all`和`install`之外，还有许多有用的目标：
- en: '`make clean` As described in Chapter 15, this removes all object files, executables,
    and libraries.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make clean` 如第15章所述，这个命令会删除所有目标文件、可执行文件和库文件。'
- en: '`make distclean` This is similar to `make clean` except it removes all automatically
    generated files, including Makefiles, *config.h*, *config.log*, and so on. The
    idea is that the source tree should look like a newly unpacked distribution after
    running `make distclean`.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make distclean` 这与`make clean`类似，除了它会删除所有自动生成的文件，包括Makefile、*config.h*、*config.log*等。其目的是让源代码树在运行`make
    distclean`后看起来像是一个刚解压的分发包。'
- en: '`make check` Some packages come with a battery of tests to verify that the
    compiled programs work properly; the command `make check` runs those tests.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make check` 一些软件包附带一系列测试，用于验证编译后的程序是否正常工作；`make check`命令会运行这些测试。'
- en: '`make install-strip` This is like `make install` except it strips the symbol
    table and other debugging information from executables and libraries when installing.
    Stripped binaries require much less space.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make install-strip` 这与`make install`类似，除了它在安装时会去除可执行文件和库中的符号表和其他调试信息。去除调试信息的二进制文件占用更少的空间。'
- en: 16.3.6  Autoconf Logfiles
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.6  Autoconf日志文件
- en: If something goes wrong during the configure process and the cause isn’t obvious,
    you can examine *config.log* to find the problem. Unfortunately, *config.log*
    is often a gigantic file, which can make it difficult to locate the exact source
    of the issue.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在配置过程中出了问题，且原因不明显，你可以查看*config.log*以找到问题所在。不幸的是，*config.log*通常是一个非常大的文件，这会让你很难找到问题的具体源头。
- en: The general approach in this situation is to go to the very end of *config.log*
    (for example, by typing a capital G in `less`) and then page back up until you
    see the problem. However, there’s still a lot of stuff at the end because `configure`
    dumps its entire environment there, including output variables, cache variables,
    and other definitions. So, rather than going to the end and paging up, go to the
    end and search backward for a string, such as `for more details` or some other
    fragment of text near the end of the failed `configure` output. (Remember, you
    can initiate a reverse search in `less` with the `?` command.) There’s a good
    chance the error will be right above what your search finds.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通常的做法是转到*config.log*的最末尾（例如，在`less`中输入大写的G），然后向上翻页，直到你看到问题。然而，日志的末尾依然会有很多内容，因为`configure`会将整个环境输出在那里，包括输出变量、缓存变量和其他定义。因此，最好不要直接向上翻页，而是先到达文件末尾，再向后搜索一个字符串，比如`for
    more details`或其他靠近`configure`失败输出末尾的文本片段。（记住，你可以在`less`中用`?`命令进行反向搜索。）很有可能，错误就在你搜索到的内容上方。
- en: 16.3.7  pkg-config
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.7  pkg-config
- en: The multitude of third-party libraries on a system means that keeping all of
    them in a common location can be messy. However, installing each with a separate
    prefix can lead to problems with building packages that require those third-party
    libraries. For example, if you want to compile OpenSSH, you need the OpenSSL library.
    How do you tell the OpenSSH configuration process the location of the OpenSSL
    libraries and which ones are required?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中大量的第三方库意味着将它们都放在一个公共位置可能会显得杂乱无章。然而，使用单独的前缀安装每个库可能会导致构建需要这些第三方库的包时出现问题。例如，如果你想编译OpenSSH，你需要OpenSSL库。你如何告诉OpenSSH配置过程OpenSSL库的位置以及需要哪些库？
- en: 'Many libraries now use the `pkg-config` program not only to advertise the locations
    of their include files and libraries but also to specify the exact flags you need
    to compile and link a program. The syntax is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多库不仅使用`pkg-config`程序来公开它们的头文件和库的位置，还指定编译和链接程序所需的确切标志。语法如下：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, to find the libraries required for a popular compression library,
    you can run this command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查找流行压缩库所需的库，你可以运行以下命令：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output should look something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To see all libraries that `pkg-config` knows about, including a brief description
    of each, run this command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`pkg-config`知道的所有库，包括每个库的简要描述，请运行以下命令：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How pkg-config Works
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pkg-config如何工作
- en: 'If you look behind the scenes, you’ll find that `pkg-config` finds package
    information by reading configuration files that end with *.pc*. For example, here’s
    *openssl.pc* for the OpenSSL socket library, as seen on an Ubuntu system (located
    in */usr/lib/x86_64-linux-gnu/pkgconfig*):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入了解幕后，你会发现`pkg-config`通过读取以*.pc*结尾的配置文件来查找包信息。例如，这是Ubuntu系统上OpenSSL套接字库的*openssl.pc*文件（位于*/usr/lib/x86_64-linux-gnu/pkgconfig*）：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can change this file, for example, by adding `-Wl,-rpath=${libdir}` to the
    library flags to set a runtime library search path. However, the bigger question
    is how `pkg-config` finds the *.pc* files in the first place. By default, `pkg-config`
    looks in the *lib/pkgconfig* directory of its installation prefix. For example,
    a `pkg-config` installed with a */usr/local* prefix looks in */usr/local/lib/pkgconfig*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改这个文件，例如，通过将`-Wl,-rpath=${libdir}`添加到库标志中，以设置运行时库搜索路径。然而，更大的问题是`pkg-config`最初是如何找到*.pc*文件的。默认情况下，`pkg-config`会在其安装前缀的*lib/pkgconfig*目录中查找。例如，使用*/usr/local*前缀安装的`pkg-config`会在*/usr/local/lib/pkgconfig*目录中查找。
- en: How to Install pkg-config Files in Nonstandard Locations
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何在非标准位置安装pkg-config文件
- en: 'Unfortunately, by default, `pkg-config` doesn’t read any *.pc* files outside
    its installation prefix. This means that a *.pc* file that’s in a nonstandard
    location, such as */opt/openssl/lib/pkgconfig/openssl.pc*, will be out of the
    reach of any stock `pkg-config` installation. There are two basic ways to make
    *.pc* files available outside the `pkg-config` installation prefix:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，默认情况下，`pkg-config`不会读取其安装前缀外的任何*.pc*文件。这意味着位于非标准位置的*.pc*文件，如*/opt/openssl/lib/pkgconfig/openssl.pc*，将无法被任何标准的`pkg-config`安装所访问。有两种基本方法可以使*.pc*文件在`pkg-config`安装前缀外可用：
- en: Make symbolic links (or copies) from the actual *.pc* files to the central *pkgconfig*
    directory.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从实际的*.pc*文件创建符号链接（或复制）到中央*pkgconfig*目录。
- en: Set your `PKG_CONFIG_PATH` environment variable to include any extra *pkgconfig*
    directories. This strategy does not work well on a systemwide basis.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`PKG_CONFIG_PATH`环境变量，将任何额外的*pkgconfig*目录包括在内。该策略在系统范围内效果不佳。
- en: 16.4 Installation Practice
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 安装实践
- en: 'Knowing *how* to build and install software is good, but knowing *when* and
    *where* to install your own packages is even more useful. Linux distributions
    try to cram in as much software as possible at installation, so you should always
    check whether it would be better to install a package yourself instead. Here are
    the advantages of doing installs on your own:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 知道*如何*构建和安装软件是好的，但知道*何时*和*在哪里*安装自己的包更有用。Linux发行版尽量在安装时包含尽可能多的软件，因此你应该始终检查是否自己安装包会更好。自己安装的优点如下：
- en: You can customize package defaults.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以自定义包的默认设置。
- en: When installing a package, you often get a clearer picture of how to use it.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装包时，你通常会更清楚如何使用它。
- en: You control the release that you run.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以控制你运行的版本。
- en: It’s easier to back up a custom package.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份自定义包更容易。
- en: It’s easier to distribute self-installed packages across a network (as long
    as the architecture is consistent and the installation location is relatively
    isolated).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络中分发自安装的包更容易（前提是架构一致且安装位置相对隔离）。
- en: 'Here are the disadvantages:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是缺点：
- en: If the package you want to install is already installed on your system, you
    might overwrite important files, causing problems. Avoid this by using the */usr/local*
    install prefix, described shortly. Even if the package isn’t installed on your
    system, you should check to see if the distribution has a package available. If
    it does, you need to remember this in case you accidentally install the distribution
    package later.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你要安装的包已经安装在系统中，你可能会覆盖重要文件，导致问题。通过使用稍后会介绍的 */usr/local* 安装前缀可以避免这种情况。即使包没有安装在你的系统上，你也应该检查分发包是否可用。如果有，你需要记住这一点，以防你以后不小心安装了分发包。
- en: It takes time.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要时间。
- en: Custom packages do not automatically upgrade themselves. Distributions keep
    most packages up to date without requiring much work from you. This is a particular
    concern for packages that interact with the network, because you want to ensure
    that you always have the latest security updates.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义包不会自动升级。分发包会保持大多数包的最新状态，且不需要你做太多工作。对于与网络交互的包，这是一个特别需要关注的问题，因为你希望确保始终拥有最新的安全更新。
- en: If you don’t actually use the package, you’re wasting your time.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你实际上并不使用这个包，那么你是在浪费时间。
- en: There is a potential for misconfiguring packages.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在错误配置包的潜在风险。
- en: There’s not much point in installing packages such as those in the coreutils
    package you built earlier in the chapter (`ls`, `cat`, and so on) unless you’re
    building a very custom system. On the other hand, if you have a vital interest
    in network servers such as Apache, the best way to get complete control is to
    install the servers yourself.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在构建一个非常自定义的系统，否则安装像本章早些时候构建的 coreutils 包（`ls`、`cat` 等）等包没什么意义。另一方面，如果你对像
    Apache 这样的网络服务器有重要兴趣，最好的方式是自己安装这些服务器，从而获得完全的控制权。
- en: 16.4.1  Where to Install
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.1  安装位置
- en: The default prefix in GNU autoconf and many other packages is */usr/local*,
    the traditional directory for locally installed software. Operating system upgrades
    ignore */usr/local*, so you won’t lose anything installed there during an operating
    system upgrade, and for small local software installations, */usr/local* is fine.
    The only problem is that if you have a lot of custom software installed, this
    can turn into a terrible mess. Thousands of odd little files can make their way
    into the */usr/local* hierarchy, and you may have no idea where the files came
    from.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: GNU autoconf 和许多其他包的默认前缀是 */usr/local*，这是本地安装软件的传统目录。操作系统升级时会忽略 */usr/local*，因此在操作系统升级过程中不会丢失那里安装的任何东西，对于小型本地软件安装，*/usr/local*
    也足够了。唯一的问题是，如果你安装了大量自定义软件，可能会变得一团糟。成千上万的奇怪小文件可能会进入 */usr/local* 目录结构，你可能根本不知道这些文件来自哪里。
- en: If things really start to get unruly, you should create your own packages as
    described in Section 16.3.2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情开始变得难以管理，你应该按照第 16.3.2 节中描述的方法创建你自己的包。
- en: 16.5 Applying a Patch
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 应用补丁
- en: Most changes to software source code are available as branches of the developer’s
    online version of the source code (such as a Git repository). However, every now
    and then, you might get a *patch* that you need to apply against source code to
    fix bugs or add features. You may also see the term *diff* used as a synonym for
    patch, because the `diff` program produces the patch.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件源代码的更改作为开发者在线源代码版本的分支提供（例如 Git 仓库）。然而，偶尔你可能会得到一个需要应用于源代码的 *补丁*，用于修复错误或添加新功能。你也可能会看到
    *diff* 这个术语作为补丁的同义词，因为 `diff` 程序生成补丁。
- en: 'The beginning of a patch looks something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁的开始看起来像这样：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Patches usually contain alterations to more than one file. Search the patch
    for three dashes in a row (`---`) to see the files that have alterations and always
    look at the beginning of a patch to determine the required working directory.
    Notice that the preceding example refers to *src/file.c*. Therefore, you should
    change to the directory that contains *src* before applying the patch, *not* to
    the *src* directory itself.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁通常包含对多个文件的更改。查找补丁中的三个连字符（`---`）以查看哪些文件有更改，并始终查看补丁的开头以确定所需的工作目录。注意，前面的示例提到的是
    *src/file.c*。因此，在应用补丁之前，你应该切换到包含 *src* 的目录，而不是直接切换到 *src* 目录。
- en: 'To apply the patch, run the `patch` command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用补丁，运行`patch`命令：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If everything goes well, `patch` exits without a fuss, leaving you with an
    updated set of files. However, `patch` might ask you this question:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，`patch`会顺利退出，更新一组文件。然而，`patch`可能会问你这个问题：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This usually means you’re not in the correct directory, but it could also indicate
    that your source code doesn’t match the source code in the patch. In this case,
    you’re probably out of luck. Even if you could identify some of the files to patch,
    others would not be properly updated, leaving you with source code that you could
    not compile.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常意味着你不在正确的目录中，但也可能表示你的源代码与补丁中的源代码不匹配。在这种情况下，你可能就没有好运了。即使你能识别出一些文件需要打补丁，其他文件也无法正确更新，最终你将得到无法编译的源代码。
- en: 'In some cases, you might come across a patch that refers to a package version
    like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能会遇到一个补丁，引用了类似这样的包版本：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you have a slightly different version number (or you just renamed the directory),
    you can tell `patch` to strip leading path components. For example, say you were
    in the directory that contains *src* (as before). To tell `patch` to ignore the
    *package-3.42/* part of the path (that is, strip one leading path component),
    use `-p1`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个稍微不同的版本号（或者只是更改了目录名称），你可以告诉`patch`去除路径中的前导部分。例如，假设你在包含*src*的目录中（如前所述）。要告诉`patch`忽略路径中的*package-3.42/*部分（即去除一个前导路径组件），使用`-p1`：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 16.6 Troubleshooting Compiles and Installations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 编译和安装故障排除
- en: If you understand the difference between compiler errors, compiler warnings,
    linker errors, and shared library problems as described in Chapter 15, you shouldn’t
    have too much trouble fixing many of the glitches that arise when you’re building
    software. This section covers some common problems. Although you’re unlikely to
    run into any of these issues when building using autoconf, it never hurts to know
    what they look like.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解编译器错误、编译器警告、链接器错误以及共享库问题的区别（如第15章所述），你就不太会遇到在构建软件时出现的许多故障。此部分涵盖了一些常见问题。虽然在使用autoconf构建时不太可能遇到这些问题，但知道它们的表现方式总是有益的。
- en: 'Before covering specifics, make sure that you can read certain kinds of `make`
    output. It’s important to know the difference between an error and an ignored
    error. The following is a real error that you need to investigate:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论具体细节之前，确保你能读取某些类型的`make`输出。了解错误和被忽略的错误之间的区别非常重要。以下是一个需要调查的真实错误：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, some Makefiles suspect that an error condition might occur but know
    that these errors are harmless. You can usually disregard any messages like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些Makefile知道某些错误条件可能会发生，但它们知道这些错误是无害的。你通常可以忽略类似的消息：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Furthermore, GNU `make` often calls itself many times in large packages, with
    each instance of `make` in the error message marked with `[``N``]`, where `N`
    is a number. You can often quickly find the error by looking at the `make` error
    that comes *directly* after the compiler error message. For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GNU `make`在大型包中通常会多次调用自身，每次`make`实例的错误信息中会标记为`[``N``]`，其中`N`是一个数字。你通常可以通过查看编译器错误信息后*直接*跟随的`make`错误来快速找到问题。例如：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first three lines here give you the information you need. The trouble centers
    around *file.c*, located in */home/src/package-5.0/src*. Unfortunately, there’s
    so much extra output that it can be difficult to spot the important details. Learning
    how to filter out the subsequent `make` errors goes a long way toward helping
    you dig out the real cause.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的前三行提供了你需要的信息。问题集中在*file.c*，它位于*/home/src/package-5.0/src*。不幸的是，输出信息过多，可能很难找到重要的细节。学习如何过滤掉后续的`make`错误对于帮助你找到真正的原因非常有用。
- en: 16.6.1  Specific Errors
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.6.1  具体错误
- en: Here are some common build errors that you might encounter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能遇到的一些常见构建错误。
- en: '**Problem**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: 'Compiler error message:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器错误信息：
- en: '[PRE31]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Explanation and fix**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释和修复**'
- en: The programmer made an erroneous redeclaration of `item` on line 22 of *src.c*.
    You can usually fix this by removing the offending line (with a comment, an `#ifdef`,
    or whatever works).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员在*src.c*的第22行错误地重新声明了`item`。你通常可以通过删除有问题的那一行（添加注释、`#ifdef`，或任何有效的方法）来修复此问题。
- en: '**Problem**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: 'Compiler error message:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器错误信息：
- en: '[PRE32]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Explanation and fix**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释和修复**'
- en: 'The programmer forgot a critical header file. The manual pages are the best
    way to find the missing header file. First, look at the offending line (in this
    case, line 37 in *src.c*). It’s probably a variable declaration like the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员忘记了一个关键的头文件。手册页是查找缺失头文件的最佳方法。首先查看出错的行（在本例中是*src.c*中的第37行）。它可能是如下的变量声明：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Search forward for `v1` in the program for its use around a function call.
    For example:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在程序中向前搜索`v1`，查看它在函数调用中的使用情况。例如：
- en: '[PRE34]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now run `man 2 time` or `man 3 time` to look for system and library calls named
    `time()`. In this case, the section 2 manual page has what you need:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在运行`man 2 time`或`man 3 time`，查找名为`time()`的系统和库调用。在这种情况下，第2节手册页包含你需要的信息：
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This means that `time()` requires *time.h*. Place `#include <time.h>` at the
    beginning of *src.c* and try again.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着`time()`需要`time.h`。在*src.c*的开头添加`#include <time.h>`并重新尝试。
- en: '**Problem**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: 'Compiler (preprocessor) error message:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器（预处理器）错误信息：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Explanation and fix**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释与修复**'
- en: The compiler ran the C preprocessor on *src.c* but could not find the *pkg.h*
    include file. The source code likely depends on a library that you need to install,
    or you may just need to provide the compiler with the nonstandard include path.
    Usually, you’ll just need to add a `-I` include path option to the C preprocessor
    flags (`CPPFLAGS`). (Keep in mind that you might also need a `-L` linker flag
    to go along with the include files.)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器对*src.c*运行了C预处理器，但无法找到*pkg.h*包含文件。源代码可能依赖于你需要安装的库，或者你可能只需要提供给编译器非标准的包含路径。通常，你只需要向C预处理器标志（`CPPFLAGS`）中添加`-I`包含路径选项。（请记住，你可能还需要一个`-L`链接器标志来配合包含文件一起使用。）
- en: If it doesn’t look as though you’re missing a library, there’s an outside chance
    you’re attempting a compile for an operating system that this source code does
    not support. Check the Makefile and *README* files for details about platforms.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果看起来不是缺少库，可能是你正在尝试为一个此源代码不支持的操作系统进行编译。请检查Makefile和*README*文件，了解有关平台的详细信息。
- en: 'If you’re running a Debian-based distribution, try the `apt-file` command on
    the header filename:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是基于Debian的发行版，尝试在头文件名上运行`apt-file`命令：
- en: '[PRE37]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This might find the development package that you need. For distributions that
    use `yum`, you can try this instead:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能找到你需要的开发包。对于使用`yum`的发行版，你可以尝试改为使用以下命令：
- en: '[PRE38]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Problem**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: 'The `make` error message:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make`错误信息：'
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Explanation and fix**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释与修复**'
- en: To build the package, you need `prog` on your system. If `prog` is something
    like `cc`, `gcc`, or `ld`, you don’t have the development utilities installed
    on your system. On the other hand, if you think `prog` is already installed on
    your system, try altering the Makefile to specify the full pathname of `prog`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建该软件包，你的系统中需要安装`prog`。如果`prog`类似于`cc`、`gcc`或`ld`，说明你的系统没有安装开发工具。另一方面，如果你认为`prog`已经安装在系统上，尝试修改Makefile，指定`prog`的完整路径名。
- en: In rare cases with poorly configured source code, `make` builds `prog` and then
    uses `prog` immediately, assuming that the current directory (`.`) is in your
    command path. If your `$PATH` does not include the current directory, you can
    edit the Makefile and change `prog` to `./``prog`. Alternatively, you could append
    `.` to your path temporarily.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在少数情况下，由于源代码配置不当，`make`构建了`prog`后立即使用`prog`，假设当前目录（`.`）在你的命令路径中。如果你的`$PATH`没有包含当前目录，你可以编辑Makefile，将`prog`改为`./prog`。或者，你可以临时将`.`添加到你的路径中。
- en: 16.7 Looking Forward
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.7 展望未来
- en: 'We’ve touched only on the basics of building software. After you get the hang
    of your own builds, try the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅触及了构建软件的基础知识。在你掌握了自己的构建方法后，尝试以下内容：
- en: Learn how to use build systems other than autoconf, such as CMake and SCons.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用除autoconf以外的构建系统，如CMake和SCons。
- en: Set up builds for your own software. If you’re writing your own software, you
    want to choose a build system and learn to use it. For GNU autoconf packaging,
    *Autotools*, 2nd edition, by John Calcote (No Starch Press, 2019) can help you
    out.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的软件设置构建环境。如果你在编写自己的软件，你需要选择一个构建系统并学习如何使用它。关于GNU autoconf打包，John Calcote的《Autotools》第二版（No
    Starch Press, 2019）可以帮助你。
- en: Compile the Linux kernel. The kernel’s build system is completely different
    from that of other tools. It has its own configuration system tailored to customizing
    your own kernel and modules. The procedure is straightforward, though, and if
    you understand how the bootloader works, you won’t have any trouble with it. However,
    you should be careful when doing so; make sure that you always keep your old kernel
    handy in case you can’t boot with a new one.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译Linux内核。内核的构建系统与其他工具的构建系统完全不同。它拥有自己的配置系统，专门用于定制自己的内核和模块。尽管如此，过程相对直接，如果你理解引导加载程序是如何工作的，通常不会遇到任何问题。然而，在进行此操作时要小心；确保始终保留旧的内核，以防新内核无法启动。
- en: Explore distribution-specific source packages. Linux distributions maintain
    their own versions of software source code as special source packages. Sometimes
    you can find useful patches that expand functionality or fix problems in otherwise
    unmaintained packages. The source package management systems include tools for
    automatic builds, such as Debian’s `debuild` and the RPM-based `mock`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索特定发行版的源代码包。Linux发行版维护自己版本的软件源代码，作为特殊的源代码包。有时你可以找到有用的补丁，扩展功能或修复其他未维护包中的问题。源代码包管理系统包括自动构建工具，如Debian的`debuild`和基于RPM的`mock`。
- en: Building software is often a stepping stone to learning about programming and
    software development. The tools you’ve seen in this chapter and the previous chapter
    take the mystery out of where your system software came from. It’s not difficult
    to take the next steps of looking inside the source code, making changes, and
    creating your own software.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件通常是学习编程和软件开发的第一步。你在本章和上一章中看到的工具揭开了系统软件来源的神秘面纱。向前迈出一步，查看源代码、进行修改并创建自己的软件并不困难。
