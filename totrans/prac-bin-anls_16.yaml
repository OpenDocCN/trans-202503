- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: PRACTICAL SYMBOLIC EXECUTION WITH TRITON
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Triton 进行实际符号执行
- en: In [Chapter 12](ch12.xhtml#ch12), you became familiar with the principles of
    symbolic execution. Now let’s build real symbex tools with Triton, a popular open
    source symbolic execution engine. This chapter demonstrates how to build a backward
    slicing tool, increase code coverage, and automatically exploit a vulnerability
    with Triton.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 12 章](ch12.xhtml#ch12) 中，你已经熟悉了符号执行的原理。现在，让我们使用 Triton 这个流行的开源符号执行引擎来构建真实的符号执行工具。本章展示了如何使用
    Triton 构建反向切片工具、增加代码覆盖率，并自动利用漏洞。
- en: There are a handful of symbolic execution engines in existence, and only a few
    of them can operate on binary programs. The best-known binary-level symbex engines
    are Triton, angr,^([1](footnote.xhtml#ch13fn_1)) and S2E.^([2](footnote.xhtml#ch13fn_2))
    KLEE is another well-known symbex engine that operates on LLVM bitcode instead
    of binary code.^([3](footnote.xhtml#ch13fn_3)) I’ll use Triton because it integrates
    easily with Intel Pin and is slightly faster because of its C++ backend. Other
    famous symbex engines include KLEE and S2E, which operate on LLVM bitcode instead
    of binary code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些符号执行引擎，其中只有少数能够在二进制程序上运行。最著名的二进制级符号执行引擎包括 Triton、angr^(［1］(footnote.xhtml#ch13fn_1))
    和 S2E^(［2］(footnote.xhtml#ch13fn_2))。KLEE 是另一个著名的符号执行引擎，它操作的是 LLVM 位码而非二进制代码^(［3］(footnote.xhtml#ch13fn_3))。我将使用
    Triton，因为它能够轻松与 Intel Pin 集成，并且由于其 C++ 后端，速度稍快。其他著名的符号执行引擎包括 KLEE 和 S2E，它们操作的是
    LLVM 位码而非二进制代码。
- en: 13.1 Introduction to Triton
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1 Triton 介绍
- en: Let’s start by taking a more detailed look at Triton’s main features. Triton
    is a free, open source binary analysis library that’s best known for its symbolic
    execution engine. It offers APIs for C/C++ and Python and currently supports the
    x86 and x64 instruction sets. You can download Triton and find documentation at
    *[https://triton.quarkslab.com](https://triton.quarkslab.com)*. I’ve preinstalled
    Triton version 0.6 (build 1364) on the VM in the directory *~/triton*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始更详细地了解 Triton 的主要特点。Triton 是一个免费的开源二进制分析库，以其符号执行引擎而闻名。它提供 C/C++ 和 Python
    的 API，目前支持 x86 和 x64 指令集。你可以在 *[https://triton.quarkslab.com](https://triton.quarkslab.com)*
    下载 Triton 并查阅文档。我已在虚拟机中预安装了 Triton 版本 0.6（构建号 1364），并放在 *~/triton* 目录下。
- en: Triton, like `libdft`, is an experimental tool (there are currently no fully
    mature binary-level symbex engines). That means you may encounter bugs, which
    you can report at *[https://github.com/JonathanSalwan/Triton/](https://github.com/JonathanSalwan/Triton/)*.
    Triton also needs a special, manually written handler for every type of instruction,
    telling the symbex engine about the effects that instruction has on the symbolic
    state. As a result, you may face incorrect results or errors if the program you’re
    analyzing uses instructions not supported by Triton.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Triton 和 `libdft` 一样，都是实验性工具（目前还没有完全成熟的二进制级符号执行引擎）。这意味着你可能会遇到一些错误，可以在 *[https://github.com/JonathanSalwan/Triton/](https://github.com/JonathanSalwan/Triton/)*
    上报告这些问题。Triton 还需要为每种指令类型手动编写专用处理程序，告诉符号执行引擎该指令对符号状态的影响。因此，如果你分析的程序使用了 Triton
    不支持的指令，你可能会遇到错误或不正确的结果。
- en: I’ll use Triton for the practical symbex examples because it’s easy to use,
    is relatively well documented, and is written in C++, which gives it a performance
    advantage over engines written in languages like Python. Moreover, Triton’s concolic
    mode is based on Intel Pin, with which you’re already familiar.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Triton 来进行实际符号执行的示例，因为它易于使用，文档相对完善，并且是用 C++ 编写的，这使得它比用像 Python 这样语言编写的引擎具有性能优势。此外，Triton
    的符号执行模式基于 Intel Pin，而你已经熟悉这个工具。
- en: Triton supports two modes, a *symbolic emulation mode* and a *concolic execution
    mode*, that correspond to the static (SSE) and dynamic (DSE) symbex philosophies.
    In both modes, Triton allows you to concretize part of the state to reduce the
    complexity of the symbolic expressions. Recall that SSE doesn’t really run a program
    but rather emulates it, while concolic execution does run the program and tracks
    symbolic state as metadata. As a result, symbolic emulation mode is slower than
    concolic mode because it must emulate each instruction’s effects on both the symbolic
    and concrete states, whereas concolic mode gets the concrete state “for free.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Triton 支持两种模式，*符号仿真模式*和*符号执行模式*，分别对应静态（SSE）和动态（DSE）符号执行哲学。在这两种模式下，Triton 允许你具体化部分状态，以减少符号表达式的复杂性。回想一下，SSE
    并不真正运行程序，而是模拟它，而符号执行模式则实际运行程序并将符号状态作为元数据进行跟踪。因此，符号仿真模式比符号执行模式要慢，因为它必须模拟每条指令对符号和具体状态的影响，而符号执行模式则“免费”获得具体状态。
- en: Concolic execution mode relies on Intel Pin and must run the analyzed program
    from the start. In contrast, with symbolic emulation you can easily emulate only
    part of a program, such as a single function, rather than the whole program. In
    this chapter, you’ll see practical examples of both symbolic emulation mode and
    concolic mode. For a more complete discussion of the advantages and disadvantages
    of the two approaches, refer to [Chapter 12](ch12.xhtml#ch12).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 共符执行模式依赖于 Intel Pin，并且必须从程序的开始运行分析程序。相比之下，使用符号仿真时，你可以轻松地仅仿真程序的一部分，如单个函数，而不是整个程序。在本章中，你将看到符号仿真模式和共符模式的实际示例。关于这两种方法的优缺点的更完整讨论，请参见[第12章](ch12.xhtml#ch12)。
- en: Triton is foremost an offline symbex engine, in the sense that it explores only
    a single path at a time. But it also features a snapshot mechanism that allows
    you to concolically explore multiple paths without having to completely start
    over every time. Moreover, it incorporates a coarse-grained taint analysis engine
    with one color. While you won’t need these features in this chapter, you can learn
    more about them from Triton’s online documentation and examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Triton 首先是一个离线的符号执行引擎，意味着它一次只能探索一条路径。但它也具备快照机制，允许你无须每次都从头开始，就可以共符地探索多条路径。此外，它还集成了一个粗粒度的污染分析引擎，采用一种颜色。虽然在本章中你不需要这些功能，但你可以通过
    Triton 的在线文档和示例了解更多。
- en: Recent versions of Triton also allow you to plug in a different binary instrumentation
    platform instead of Pin and a different constraint solver of your choice. In this
    chapter, I’ll simply use the defaults, which are Pin and Z3\. The Triton version
    installed on the VM specifically requires Pin version 2.14 (71313), which you’ll
    also find preinstalled in *~/triton/pin -2.14-71313-gcc.4.4.7-linux*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Triton 的最新版本还允许你使用不同的二进制插桩平台代替 Pin，以及选择不同的约束求解器。在本章中，我将使用默认设置，即 Pin 和 Z3\. 虚拟机上安装的
    Triton 版本要求使用 Pin 版本 2.14（71313），你也会发现它已预装在 *~/triton/pin -2.14-71313-gcc.4.4.7-linux*
    中。
- en: 13.2 Maintaining Symbolic State with Abstract Syntax Trees
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2 使用抽象语法树维护符号状态
- en: In both emulation mode and concolic mode, Triton maintains a global set of symbolic
    expressions, a mapping from registers and memory addresses to these symbolic expressions,
    and a list of path constraints, similar to [Figure 12-1](ch12.xhtml#ch12fig1)
    from [Chapter 12](ch12.xhtml#ch12). Triton represents symbolic expressions and
    constraints as *abstract syntax trees (ASTs)*, with one AST per expression or
    constraint. An AST is a tree data structure that depicts the syntactic relationships
    between operations and operands. The AST nodes contain operations and operands
    in Z3’s SMT language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真模式和共符模式下，Triton 维护一个全局的符号表达式集合，将寄存器和内存地址映射到这些符号表达式，并维护一个路径约束列表，类似于[第12-1图](ch12.xhtml#ch12fig1)中的内容。Triton
    将符号表达式和约束表示为*抽象语法树（ASTs）*，每个表达式或约束都有一个 AST。AST 是一种树形数据结构，描述了操作和操作数之间的语法关系。AST
    节点包含 Z3 的 SMT 语言中的操作和操作数。
- en: 'For example, [Figure 13-1](ch13.xhtml#ch13fig1) shows how the AST for the `eax`
    register evolves over the following sequence of three instructions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[第13-1图](ch13.xhtml#ch13fig1)显示了 `eax` 寄存器的 AST 在以下三条指令序列中的演变：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For each instruction, the figure shows two ASTs side by side: a full AST on
    the left and an AST with *references* on the right. Let’s first discuss the left
    side of the figure, and then I’ll explain the ASTs with references.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条指令，图中显示了两个并排的 AST：左侧是完整的 AST，右侧是带有*引用*的 AST。我们首先讨论图的左侧，然后我会解释带有引用的 AST。
- en: Full ASTs
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完整的 AST
- en: The figure assumes that `eax` and `cl` initially map to unbounded symbolic expressions
    corresponding to a 32-bit symbolic value *α*[1] and an 8-bit symbolic value *α*[2],
    respectively. For example, you can see that the initial state for `eax` ➊ is an
    AST rooted at a `bv` (*bitvector*) node, with two child nodes containing the values
    *α*[1] and 32\. This corresponds to an unbounded 32-bit Z3 bitvector, as in `(declare-const
    alpha1 (_ BitVec 32))`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图示假设 `eax` 和 `cl` 最初映射到分别对应于 32 位符号值 *α*[1] 和 8 位符号值 *α*[2] 的无界符号表达式。例如，你可以看到，`eax`
    的初始状态 ➊ 是一个根节点为 `bv`（*位向量*）节点的 AST，该节点有两个子节点，分别包含值 *α*[1] 和 32\. 这对应于一个无界的 32
    位 Z3 位向量，如 `(declare-const alpha1 (_ BitVec 32))`。
- en: The `shr eax,cl` instruction is a logical right shift that uses `eax` and `cl`
    as its operands and stores the result in `eax`. Thus, after this instruction ➋,
    the full AST for `eax` has a `bvlshr` (logical right shift) node as its root,
    with child trees representing the original ASTs for `eax` and `cl`. Note that
    the right child tree, representing `cl`’s contents, is rooted at a `concat` operation
    that prepends 24 zero bits to `cl`’s value. That’s necessary because `cl` is only
    8 bits wide, but you have to widen it to 32 bits (the same width as `eax`) because
    the SMT-LIB 2.0 format that Z3 uses requires that both operands to the `bvlshr`
    have the same bit width.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`shr eax,cl` 指令是一个逻辑右移操作，它使用 `eax` 和 `cl` 作为操作数，并将结果存储在 `eax` 中。因此，在执行此指令 ➋
    后，`eax` 的完整 AST 以 `bvlshr`（逻辑右移）节点作为根节点，子树表示 `eax` 和 `cl` 的原始 AST。请注意，右侧子树表示 `cl`
    的内容，其根节点为 `concat` 操作，该操作将 24 个零位前置到 `cl` 的值中。这是必要的，因为 `cl` 只有 8 位宽，但必须将其扩展为 32
    位（与 `eax` 相同的宽度），因为 Z3 使用的 SMT-LIB 2.0 格式要求 `bvlshr` 的两个操作数具有相同的位宽。'
- en: After the `xor eax,0x1` instruction ➌, the AST for `eax` becomes a `bvxor` node
    with `eax`’s previous AST as the left subtree and a constant bitvector containing
    the value `1` as the right subtree. Similarly, `and eax,0x1` ➍ results in an AST
    rooted at a `bvand` node, again with `eax`’s previous AST as the left subtree
    and a constant bitvector as the right.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `xor eax,0x1` 指令 ➌ 后，`eax` 的 AST 成为一个 `bvxor` 节点，`eax` 的先前 AST 作为左子树，一个包含值
    `1` 的常量位向量作为右子树。类似地，`and eax,0x1` ➍ 会生成一个以 `bvand` 节点为根的 AST，同样，`eax` 的先前 AST
    作为左子树，常量位向量作为右子树。
- en: '![image](Images/f334-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f334-01.jpg)'
- en: '*Figure 13-1: Effect of instructions on register abstract syntax trees*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：指令对寄存器抽象语法树的影响*'
- en: ASTs with References
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 带有引用的 AST
- en: 'You may have noticed that the full ASTs contain lots of redundancy: every time
    an AST depends on a previous one, the entire previous AST becomes a subtree in
    the new one. Large and complex programs have many dependencies between operations,
    so the previous scheme causes unnecessary memory overhead. That’s why Triton represents
    ASTs more compactly, using references, as shown on the right side of [Figure 13-1](ch13.xhtml#ch13fig1).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，完整的 AST 包含了大量的冗余：每当一个 AST 依赖于另一个时，整个前一个 AST 会作为子树出现在新的 AST 中。大型和复杂的程序中操作之间有许多依赖关系，因此之前的方案会导致不必要的内存开销。这就是为什么
    Triton 使用引用更加紧凑地表示 AST，如 [图 13-1](ch13.xhtml#ch13fig1) 右侧所示。
- en: In this scheme, each AST has a name like `ref!1`, `ref!2`, and so on, which
    you can refer to from another AST. This way, instead of having to copy an entire
    previous AST, you can simply refer to it by including a *reference node* in the
    new AST. For example, the right side of [Figure 13-1](ch13.xhtml#ch13fig1) shows
    how the entire left subtree in `eax`’s AST after the `and eax,0x1` instruction
    can be replaced with a single reference node that refers to the previous AST,
    compressing 15 nodes into just 1 node.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方案中，每个 AST 都有一个类似 `ref!1`、`ref!2` 等的名称，你可以在另一个 AST 中引用它。这样，你就不必复制整个先前的 AST，而只需在新
    AST 中包含一个 *引用节点* 来引用它。例如，[图 13-1](ch13.xhtml#ch13fig1) 右侧展示了如何将 `eax` 的 AST 中的整个左子树（在执行
    `and eax,0x1` 指令后）替换为一个引用节点，该节点引用先前的 AST，从而将 15 个节点压缩为 1 个节点。
- en: Triton offers an API function called `unrollAst` that allows you to expand an
    AST with references into a full AST so that you can manually inspect it, manipulate
    it, or pass it to Z3\. Now that you’re familiar with Triton’s basic workings,
    let’s learn how to use `unrollAst` and other Triton functions in practice by taking
    a look at some examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Triton 提供了一个名为 `unrollAst` 的 API 函数，允许你将包含引用的 AST 展开成完整的 AST，以便你可以手动检查、操作它，或将其传递给
    Z3。现在你已经了解了 Triton 的基本工作原理，接下来我们通过一些示例来学习如何在实践中使用 `unrollAst` 和其他 Triton 函数。
- en: 13.3 Backward Slicing with Triton
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3 使用 Triton 进行反向切片
- en: This first example implements backward slicing in Triton’s symbolic emulation
    mode. This example is a generalized version of an example that comes with Triton,
    which you’ll find in *~/triton/pin-2.14-71313-gcc.4.4.7-linux/ source/tools/Triton/src/examples/python/backward_slicing.py*.
    The original Triton tool uses the Python API, but here I’ll use Triton’s C/C++
    API instead. You’ll see an example of a Triton tool written in Python in [Section
    13.5](ch13.xhtml#ch13_5).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例实现了在 Triton 的符号仿真模式下的反向切片。这个示例是 Triton 附带的一个示例的通用版本，原始示例位于 *~/triton/pin-2.14-71313-gcc.4.4.7-linux/
    source/tools/Triton/src/examples/python/backward_slicing.py*。原始的 Triton 工具使用 Python
    API，但在这里我将使用 Triton 的 C/C++ API。你将在 [第 13.5 节](ch13.xhtml#ch13_5) 中看到一个用 Python
    编写的 Triton 工具示例。
- en: Recall that backward slicing is a binary analysis technique that tells you,
    at a certain point in the execution, which previous instructions contributed to
    the value of a given register or memory address. For example, let’s say you want
    to compute the backward slice at address `0x404b1e` with respect to `rcx` in the
    code fragment from */bin/ls* shown in [Listing 13-1](ch13.xhtml#ch13list1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，反向切片是一种二进制分析技术，它告诉你在程序执行的某个时刻，哪些之前的指令对给定寄存器或内存地址的值有所贡献。例如，假设你想要计算`0x404b1e`地址处关于`rcx`寄存器的反向切片，在[清单
    13-1](ch13.xhtml#ch13list1)中显示的来自*/bin/ls*的代码片段。
- en: '*Listing 13-1: Disassembly excerpt from* /bin/ls'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-1: 来自* /bin/ls的反汇编片段'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The backward slice consists of all the instructions that contribute to the
    value of `rcx` at address `0x404b1e` ➊. Thus, the slice should include the instructions
    shown in the following listing:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反向切片包含所有对地址`0x404b1e`处`rcx`寄存器的值有贡献的指令➊。因此，切片应该包括以下清单中显示的指令：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let’s see how to automatically compute backward slices like this with Triton.
    You’ll first learn to build a backward slicing tool and then use it to slice the
    code fragment shown in [Listing 13-1](ch13.xhtml#ch13list1), producing the same
    result as the manual slice you just saw.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Triton自动计算像这样的反向切片。你将首先学习如何构建一个反向切片工具，然后用它来切片[清单 13-1](ch13.xhtml#ch13list1)中显示的代码片段，生成与刚才看到的手动切片相同的结果。
- en: Because Triton expresses symbolic expressions as ASTs that reference each other,
    it’s easy to compute a backward slice for a given expression. [Listing 13-2](ch13.xhtml#ch13list2)
    shows the first part of the implementation of the backward slicing tool. As usual,
    I’ve omitted includes of standard C/C++ header files from the listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Triton将符号表达式表示为相互引用的AST，因此计算给定表达式的反向切片非常容易。[清单 13-2](ch13.xhtml#ch13list2)展示了反向切片工具的实现的第一部分。像往常一样，我省略了标准C/C++头文件的包含。
- en: '*Listing 13-2:* backward_slicing.cc'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-2:* backward_slicing.cc'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To use the tool, you provide it with the filename of the binary to analyze,
    a symbolic configuration file, the entry point address at which to start the analysis,
    the address at which to compute the slice, and the register with respect to which
    to compute the slice, all via command line arguments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该工具，你需要通过命令行参数提供分析的二进制文件名、符号配置文件、开始分析的入口点地址、计算切片的地址以及与之计算切片的寄存器。
- en: I’ll explain the purpose of the symbolic configuration file in a moment. Note
    that here, the entry point address is simply the address of the first instruction
    that the slicing tool will emulate; it doesn’t have to be the same as the binary’s
    entry point. For instance, to slice the example code from [Listing 13-1](ch13.xhtml#ch13list1),
    you use `0x404b00` as the entry point address so that the analysis emulates all
    the instructions shown in the listing up until the slice address.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我会解释符号配置文件的目的。请注意，这里的入口点地址仅仅是切片工具将模拟的第一条指令的地址；它不必与二进制文件的入口点相同。例如，为了切片[清单 13-1](ch13.xhtml#ch13list1)中的示例代码，你可以使用`0x404b00`作为入口点地址，这样分析就会模拟清单中显示的所有指令，直到切片地址为止。
- en: The output of `backward_slicing` is a list of the assembly instructions that
    are in the slice. Now let’s take a more detailed look at how `backward_slicing`
    generates the program slice, starting with a more in-depth discussion of the necessary
    includes and the `main` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`backward_slicing`的输出是切片中的汇编指令列表。现在让我们更详细地看看`backward_slicing`是如何生成程序切片的，从对必要的包含文件和`main`函数的深入讨论开始。'
- en: '*13.3.1 Triton Header Files and Configuring Triton*'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.3.1 Triton头文件和配置Triton*'
- en: 'The first thing you’ll notice in [Listing 13-2](ch13.xhtml#ch13list2) is that
    it includes *../inc/loader.h* ➊ because `backward_slicing` uses the binary loader
    developed in [Chapter 4](ch04.xhtml#ch04). It also includes *triton_util.h* and
    *disasm_util.h*, which provide some utility functions I’ll describe shortly. Finally,
    there are two Triton-specific header files, both with the *.hpp* extension: *triton/api.hpp*
    provides the main Triton C**++** API, while *triton/x86Specifications.hpp* provides
    x86-specific definitions, such as register definitions. Besides including these
    header files, you must link with `-ltriton` to use Triton’s symbolic emulation
    mode.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 13-2](ch13.xhtml#ch13list2)中，你首先会注意到它包含了 *../inc/loader.h* ➊，因为 `backward_slicing`
    使用了在[第 4 章](ch04.xhtml#ch04)中开发的二进制加载器。它还包含了 *triton_util.h* 和 *disasm_util.h*，这两个文件提供了一些我将很快描述的实用函数。最后，有两个
    Triton 特定的头文件，都是 *.hpp* 扩展名：*triton/api.hpp* 提供了主要的 Triton C**++** API，而 *triton/x86Specifications.hpp*
    提供了 x86 特定的定义，比如寄存器定义。除了包含这些头文件，你还必须使用 `-ltriton` 链接，以便使用 Triton 的符号化仿真模式。
- en: The `main` function starts by loading the binary you’re analyzing using the
    `load_binary` function from the binary loader. Then, it configures Triton to the
    architecture of the binary using a function called `set_triton_arch` ➋, defined
    in *backward_slicing.cc*, which I’ll discuss in detail in [Section 13.3.4](ch13.xhtml#ch13_3_4).
    It also calls Triton’s `api.enableMode` function to enable Triton’s `ALIGNED_MEMORY`
    mode, where `api` is an object of type `triton::API`, which is Triton’s main class
    that provides the C++ API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数首先使用二进制加载器中的 `load_binary` 函数加载你正在分析的二进制文件。然后，它使用一个名为 `set_triton_arch`
    ➋ 的函数将 Triton 配置为该二进制文件的架构，该函数定义在 *backward_slicing.cc* 中，我将在[第 13.3.4 节](ch13.xhtml#ch13_3_4)中详细讨论。它还调用
    Triton 的 `api.enableMode` 函数启用 Triton 的 `ALIGNED_MEMORY` 模式，其中 `api` 是类型为 `triton::API`
    的对象，`triton::API` 是 Triton 的主类，提供了 C++ API。'
- en: Recall that symbolic memory accesses can greatly increase the size and complexity
    of the symbolic state because the symbex engine must model all possible outcomes
    of the memory access. Triton’s `ALIGNED_MEMORY` mode is an optimization that reduces
    the symbolic memory explosion by assuming that memory loads and stores access-aligned
    memory addresses. You can safely enable this optimization if you know memory accesses
    are aligned or if the precise memory addresses don’t matter for the analysis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，符号化的内存访问可能会大大增加符号化状态的大小和复杂性，因为 symbex 引擎必须建模所有可能的内存访问结果。Triton 的 `ALIGNED_MEMORY`
    模式是一种优化，它通过假设内存加载和存储访问对齐的内存地址来减少符号化内存爆炸。如果你知道内存访问是对齐的，或者精确的内存地址对分析没有影响，你可以安全地启用此优化。
- en: '*13.3.2 The Symbolic Configuration File*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.3.2 符号化配置文件*'
- en: In most of your symbex tools, you’ll want to make some registers and memory
    addresses symbolic or set them to specific concrete values. Which parts of the
    state you make symbolic and which concrete values you use depend on the application
    you’re analyzing and the paths you want to explore. Thus, if you hardcode the
    decisions on what state to symbolize and concretize, your symbex tool will be
    application specific.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在你大多数的 symbex 工具中，你可能需要将一些寄存器和内存地址设置为符号化，或者将它们设置为特定的具体值。你将哪些状态设置为符号化，哪些使用具体值，取决于你正在分析的应用程序和你想要探索的路径。因此，如果你硬编码了关于符号化和具体化状态的决策，你的
    symbex 工具就会变得是特定于应用的。
- en: 'To prevent that, let’s create a simple *symbolic configuration file* format
    in which you can configure these decisions. There’s a utility function called
    `parse_sym_config`, defined in *triton_util.h*, that you can use to parse symbolic
    configuration files and load them into your symbex tool. The following listing
    shows an example symbolic configuration file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们来创建一个简单的 *符号化配置文件* 格式，在这个文件中你可以配置这些决策。这里有一个名为 `parse_sym_config`
    的实用函数，它定义在 *triton_util.h* 中，你可以用它来解析符号化配置文件并将它们加载到你的 symbex 工具中。以下示例展示了一个符号化配置文件的例子：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the symbolic configuration file format, you denote registers by `%`*name*
    and memory addresses by `@`*address*. You can assign concrete integers to each
    register or memory byte or make them symbolic by assigning the value `$`. For
    example, this configuration file assigns the concrete value `0` to `rax` and then
    makes `rax` symbolic and assigns the value `5` to the byte at memory address `0x1000`.
    Note that `rax` is symbolic but at the same time has a concrete value to drive
    the emulation to the correct path.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号配置文件格式中，你通过 `%`*name* 来表示寄存器，通过 `@`*address* 来表示内存地址。你可以为每个寄存器或内存字节分配具体的整数值，或者通过分配值
    `$` 将其符号化。例如，以下配置文件将具体值 `0` 分配给 `rax`，然后将 `rax` 符号化，并将值 `5` 分配给内存地址 `0x1000` 处的字节。请注意，`rax`
    是符号化的，但同时具有具体值，以推动仿真到正确的路径。
- en: Now let’s get back to [Listing 13-2](ch13.xhtml#ch13list2). After loading the
    binary to analyze and configuring Triton, `backward_slicing` calls `parse_sym_config`
    to parse the symbolic configuration file specified on the command line ➌. This
    function takes the filename of the configuration file as input, followed by two
    parameters that are both references to `std::map` objects in which `parse_sym_config`
    loads the configuration. The first `std::map` maps Triton register names (of an
    `enum` type called `triton::arch::registers_e`) to concrete `uint64_t` values
    containing the register contents, while the second `std::map` maps memory addresses
    to concrete byte values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到[示例 13-2](ch13.xhtml#ch13list2)。加载二进制文件以进行分析并配置Triton后，`backward_slicing`
    调用 `parse_sym_config` 来解析命令行中指定的符号配置文件 ➌。此函数以配置文件的文件名作为输入，然后是两个参数，这两个参数都是指向 `std::map`
    对象的引用，其中 `parse_sym_config` 加载了配置。第一个 `std::map` 将Triton寄存器名称（属于 `triton::arch::registers_e`
    枚举类型）映射到包含寄存器内容的具体 `uint64_t` 值，而第二个 `std::map` 将内存地址映射到具体的字节值。
- en: Actually, `parse_sym_config` takes two more optional parameters to load the
    lists of symbolic registers and memory addresses into. I haven’t used those here
    because to compute slices, you’re interested only in the ASTs that Triton builds,
    and by default Triton builds ASTs even for registers and memory locations that
    you haven’t explicitly made symbolic.^([4](footnote.xhtml#ch13fn_4)) You’ll see
    an example where you do need to explicitly symbolize some parts of the state in
    [Section 13.4](ch13.xhtml#ch13_4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`parse_sym_config` 还接受两个可选参数，用于加载符号寄存器和内存地址的列表。我这里没有使用这些参数，因为为了计算切片，你只关心Triton构建的AST，默认情况下，Triton会为你没有显式指定符号的寄存器和内存位置构建AST。^([4](footnote.xhtml#ch13fn_4))
    你将在[13.4节](ch13.xhtml#ch13_4)看到一个需要显式符号化状态某些部分的例子。
- en: Directly after the call to `parse_sym_config`, the `main` function of `backward
    _slicing` contains two `for` loops. The first loops over the map of just-loaded
    concrete register values and tells Triton to assign these concrete values to its
    internal state. To do that, you call `api.setConcreteRegisterValue`, which takes
    a Triton register and a concrete integer value as input. Triton registers have
    the type `triton::arch::Register`, and you can obtain them from a Triton register
    name (of the `enum` type `triton::arch::registers_e`) using the `api.getRegister`
    function. Each register name has the form `ID_REG_`*name*, where *name* is an
    uppercase register name like `AL`, `EBX`, `RSP`, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着调用 `parse_sym_config` 后，`backward_slicing` 的 `main` 函数包含两个 `for` 循环。第一个循环遍历刚加载的具体寄存器值的映射，并指示Triton将这些具体值分配给其内部状态。为此，你调用
    `api.setConcreteRegisterValue`，该函数接受一个Triton寄存器和一个具体的整数值作为输入。Triton寄存器的类型是 `triton::arch::Register`，你可以通过
    `api.getRegister` 函数从Triton寄存器名称（属于 `triton::arch::registers_e` 枚举类型）中获得它们。每个寄存器名称的形式为
    `ID_REG_`*name*，其中 *name* 是像 `AL`、`EBX`、`RSP` 等的大写寄存器名称。
- en: Similarly, the second `for` loop goes over the map of concrete memory values
    and tells Triton about them using `api.setConcreteMemoryValue`, which takes a
    memory address and a concrete byte value as input.^([5](footnote.xhtml#ch13fn_5))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第二个 `for` 循环遍历具体内存值的映射，并使用 `api.setConcreteMemoryValue` 将这些值告诉Triton，该函数接受一个内存地址和一个具体的字节值作为输入。^([5](footnote.xhtml#ch13fn_5))
- en: '*13.3.3 Emulating Instructions*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.3.3 模拟指令*'
- en: Loading the symbolic configuration file is the last part of the setup code for
    `backward_slicing`. Now, the main emulation loop that emulates instructions from
    the binary begins, starting at the user-specified entry point address and continuing
    until it hits the instruction at which to compute the slice. This sort of emulation
    loop is typical of nearly all symbolic emulation tools you’ll write with Triton.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加载符号配置文件是`backward_slicing`设置代码的最后部分。现在，开始执行主仿真循环，该循环从用户指定的入口点地址开始仿真二进制中的指令，并持续直到到达要计算切片的指令。这种仿真循环是你用Triton编写的几乎所有符号仿真工具的典型特征。
- en: The emulation loop is simply a `while` loop that stops when the slice is complete
    or when it encounters an instruction address outside of the binary’s `.text` section
    ➍. To keep track of the current instruction address, there’s an emulated program
    counter called `pc`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真循环只是一个`while`循环，当切片完成或遇到超出二进制文件`.text`段的指令地址时停止 ➍。为了跟踪当前指令地址，存在一个名为`pc`的仿真程序计数器。
- en: Each iteration of the loop starts by disassembling the current instruction using
    `disasm_one` ➎, another utility function I’ve provided in *disasm_util.h*. It
    uses Capstone to obtain strings containing the instruction’s mnemonic and operands,
    needed in a moment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的每次迭代开始时，使用`disasm_one`➎反汇编当前指令，这也是我在*disasm_util.h*中提供的另一个工具函数。它使用Capstone获取包含指令助记符和操作数的字符串，这些在稍后会用到。
- en: 'Next, `backward_slicing` builds a Triton instruction object of type `triton::
    arch::Instruction` for the current instruction ➏ and uses the `Instruction`’s
    `setOpcode` function to populate it with the instruction opcode bytes taken from
    the binary’s `.text` section. It also sets the `Instruction`’s address to the
    current `pc` using the `setAddress` function.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`backward_slicing`为当前指令➏构建一个类型为`triton::arch::Instruction`的Triton指令对象，并使用`Instruction`的`setOpcode`函数填充从二进制`.text`段中提取的指令操作码字节。它还使用`setAddress`函数将`Instruction`的地址设置为当前`pc`。
- en: After creating a Triton `Instruction` object for the current instruction, the
    emulation loop *processes* the `Instruction` by calling the `api.processing` function
    ➐. Despite its generic name, the `api.processing` function is central to Triton
    symbolic emulation tools because it performs the actual instruction emulation
    and advances Triton’s symbolic and concrete state based on the emulation results.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在为当前指令创建Triton的`Instruction`对象后，仿真循环通过调用`api.processing`函数➐来*处理*该`Instruction`。尽管`api.processing`函数名字通用，但它在Triton符号仿真工具中是核心部分，因为它执行实际的指令仿真，并根据仿真结果推进Triton的符号和具体状态。
- en: After the current instruction is processed, Triton will have built internal
    abstract syntax trees representing the symbolic expressions for register and memory
    states affected by the instruction. Later, you’ll see how to use these symbolic
    expressions to compute the backward slice. To produce a slice that contains x86
    instructions, not symbolic expressions in SMT-LIB 2.0 format, you need to track
    which instruction is associated with each symbolic expression. The `backward_slicing`
    tool achieves that by looping over the list of all symbolic expressions associated
    with the just-processed instruction and decorating each expression with a comment
    that contains the instruction mnemonic and operand strings obtained earlier from
    the `disasm_one` function ➑.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前指令处理后，Triton将构建表示受指令影响的寄存器和内存状态的符号表达式的内部抽象语法树。稍后，你将看到如何使用这些符号表达式计算反向切片。为了生成包含x86指令的切片，而非SMT-LIB
    2.0格式的符号表达式，你需要跟踪每个符号表达式与哪个指令相关联。`backward_slicing`工具通过遍历所有与刚处理的指令相关的符号表达式列表，并用注释装饰每个表达式，注释中包含从`disasm_one`函数➑获取的指令助记符和操作数字符串，从而实现这一点。
- en: 'To access an `Instruction`’s list of symbolic expressions, you can use its
    `symbolicExpressions` member, which is an object of type `std::vector<triton::
    engines::symbolic::SymbolicExpression*>`. The `SymbolicExpression` class provides
    a function called `setComment` that allows you to specify a comment string for
    a symbolic expression.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`Instruction`的符号表达式列表，可以使用它的`symbolicExpressions`成员，它是类型为`std::vector<triton::engines::symbolic::SymbolicExpression*>`的对象。`SymbolicExpression`类提供一个名为`setComment`的函数，允许你为符号表达式指定一个注释字符串。
- en: When the emulation reaches the slice address, `backward_slicing` calls a function
    called `print_slice` that computes and prints the slice and then breaks out of
    the emulation loop ➒. Note that `get_triton_regnum` is another utility function
    from *triton_util.h* that returns the corresponding Triton register identifier
    based on a human-readable register name. Here, it returns the register identifier
    for the register to slice, to pass to `print_slice`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当仿真达到切片地址时，`backward_slicing` 调用一个名为 `print_slice` 的函数，该函数计算并打印切片，然后跳出仿真循环 ➒。注意，`get_triton_regnum`
    是另一个来自 *triton_util.h* 的工具函数，根据人类可读的寄存器名称返回对应的 Triton 寄存器标识符。在这里，它返回要切片的寄存器的标识符，并将其传递给
    `print_slice`。
- en: When you call Triton’s `processing` function, Triton internally updates the
    concrete instruction pointer value to point to the next instruction. At the end
    of each emulation loop iteration, you get this new instruction pointer value using
    the function `api.getConcreteRegisterValue` and assign it to your own program
    counter (called `pc` in this example) that drives the emulation loop ➓. Note that
    for 32-bit x86 programs, you need to fetch the contents of `eip`, while for x64
    programs, the instruction pointer is `rip`. Let’s now take a look at how the `set_triton_arch`
    function mentioned earlier configures the `ip` variable with the identifier of
    the correct instruction pointer register for the emulation loop to use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 Triton 的 `processing` 函数时，Triton 内部会更新具体的指令指针值，以指向下一条指令。在每次仿真循环迭代结束时，你可以通过
    `api.getConcreteRegisterValue` 函数获取这个新的指令指针值，并将其赋值给你自己的程序计数器（在这个例子中叫做 `pc`），以驱动仿真循环
    ➓。请注意，对于 32 位的 x86 程序，你需要获取 `eip` 的内容，而对于 x64 程序，指令指针是 `rip`。现在，让我们看看之前提到的 `set_triton_arch`
    函数如何配置 `ip` 变量，以便为仿真循环使用正确的指令指针寄存器标识符。
- en: '*13.3.4 Setting Triton’s Architecture*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.3.4 设置 Triton 架构*'
- en: The `backward_slicing` tool’s `main` function calls `set_triton_arch` to configure
    Triton with the instruction set of the binary and get the name of the instruction
    pointer register used in that architecture. [Listing 13-3](ch13.xhtml#ch13list3)
    shows how `set_triton_arch` is implemented.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`backward_slicing` 工具的 `main` 函数调用 `set_triton_arch` 来配置 Triton 的二进制指令集，并获取该架构中使用的指令指针寄存器名称。[列表
    13-3](ch13.xhtml#ch13list3) 显示了 `set_triton_arch` 的实现方式。'
- en: '*Listing 13-3:* backward_slicing.cc *(continued)*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-3:* backward_slicing.cc *(续)*'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function takes three parameters: a reference to the `Binary` object returned
    by the binary loader, a reference to the Triton API, and a reference to a `triton::arch::registers_e`
    in which to store the name of the instruction pointer register. If successful,
    `set_triton_arch` returns 0, and if there’s an error, it returns −1.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受三个参数：一个返回自二进制加载器的 `Binary` 对象的引用，一个 Triton API 的引用，以及一个 `triton::arch::registers_e`
    类型的引用，用于存储指令指针寄存器的名称。如果成功，`set_triton_arch` 返回 0；如果出现错误，则返回 −1。
- en: First, `set_triton_arch` ensures that it’s dealing with an x86 binary (either
    32-bit or 64-bit) ➊. If this is not the case, it returns with an error because
    Triton cannot currently deal with architectures other than x86.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`set_triton_arch` 确保它正在处理一个 x86 二进制文件（无论是 32 位还是 64 位） ➊。如果不是这样，它会返回错误，因为
    Triton 当前无法处理除 x86 之外的其他架构。
- en: If there’s no error, `set_triton_arch` checks the bit width of the binary ➋.
    If the binary uses 32-bit x86, it configures Triton in 32-bit x86 mode (`triton::arch::ARCH_X86`)
    ➌ and sets `ID_REG_EIP` as the name of the instruction pointer register ➍. Similarly,
    if it’s an x64 binary, it sets the Triton architecture to `triton::arch::ARCH_X86_64`
    ➎ and sets `ID_REG_RIP` as the instruction pointer ➏. To configure Triton’s architecture,
    you use the `api.setArchitecture` function, which takes the architecture type
    as its only parameter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，`set_triton_arch` 会检查二进制文件的位宽 ➋。如果二进制文件使用的是 32 位 x86，它会将 Triton 配置为 32
    位 x86 模式（`triton::arch::ARCH_X86`） ➌，并将 `ID_REG_EIP` 设置为指令指针寄存器的名称 ➍。类似地，如果是 x64
    二进制文件，它会将 Triton 的架构设置为 `triton::arch::ARCH_X86_64` ➎，并将 `ID_REG_RIP` 设置为指令指针
    ➏。要配置 Triton 的架构，你可以使用 `api.setArchitecture` 函数，它只需要传入架构类型作为参数。
- en: '*13.3.5 Computing the Backward Slice*'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.3.5 计算反向切片*'
- en: To compute and print the actual slice, `backward_slicing` calls the `print_slice`
    function when the emulation hits the address at which to slice. You can see the
    implementation of `print_slice` in [Listing 13-4](ch13.xhtml#ch13list4).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算并打印实际的切片，当仿真到达切片地址时，`backward_slicing` 调用 `print_slice` 函数。你可以在 [列表 13-4](ch13.xhtml#ch13list4)
    中查看 `print_slice` 的实现。
- en: '*Listing 13-4:* backward_slicing.cc *(continued)*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-4:* backward_slicing.cc *(续)*'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Recall that slices are computed with respect to a particular register, as specified
    by the `reg` parameter. To compute the slice, you need the symbolic expression
    associated with that register just after emulating the instruction at the slice
    address. To get this expression, `print_slice` calls `api.getSymbolicRegisters`,
    which returns a map of all registers to their associated symbolic expressions
    and then indexes that map to obtain the expression associated with `reg` ➊. Then
    it obtains the slice of all symbolic expressions that contribute to `reg`’s expression
    using `api.sliceExpressions` ➋, which returns the slice in the form of a `std::map`
    that maps integer expression identifiers to `triton::engines::symbolic::SymbolicExpression*`
    objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，切片是相对于特定寄存器计算的，如 `reg` 参数所指定的。为了计算切片，你需要在模拟切片地址处的指令后，获得与该寄存器相关联的符号表达式。为此，`print_slice`
    调用 `api.getSymbolicRegisters`，该方法返回一个将所有寄存器与其关联的符号表达式映射的映射表，然后通过该映射获取与 `reg` 相关联的表达式
    ➊。接着，它使用 `api.sliceExpressions` 获取所有贡献于 `reg` 表达式的符号表达式的切片 ➋，该方法返回一个以整数表达式标识符为键，`triton::engines::symbolic::SymbolicExpression*`
    对象为值的 `std::map`。
- en: You now have a slice of symbolic expressions, but what you really want is a
    slice of x86 assembly instructions. This is precisely the purpose of the symbolic
    expression comments, which associate each expression with the assembly mnemonic
    and operand strings of the instruction that produced the expression. Thus, to
    print the slice, `print_slice` simply loops over the slice of symbolic expressions,
    gets their comments using `getComment`, and prints the comments to screen ➌. For
    completeness, `print_slice` also disassembles the instruction at which you’re
    computing the slice and prints it to screen as well ➍.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有了一片符号表达式，但你真正需要的是一片 x86 汇编指令。这正是符号表达式注释的目的，它将每个表达式与产生该表达式的指令的汇编助记符和操作数字符串关联起来。因此，`print_slice`
    只需循环遍历符号表达式片段，使用 `getComment` 获取它们的注释，并将注释打印到屏幕上 ➌。为了完整性，`print_slice` 还会反汇编你正在计算切片的指令，并将其也打印到屏幕上
    ➍。
- en: You can try the `backward_slice` program on the VM by running it as shown in
    [Listing 13-5](ch13.xhtml#ch13list5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在虚拟机上运行 `backward_slice` 程序来尝试这个功能，如 [示例 13-5](ch13.xhtml#ch13list5) 中所示。
- en: '*Listing 13-5: Computing the backward slice at* 0x404b1e *with respect to*
    rcx'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-5：计算相对于* rcx *的回溯切片，起始地址为* 0x404b1e'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, I’ve used `backward_slicing` to compute a slice over the code fragment
    from */bin/ls* you saw in [Listing 13-1](ch13.xhtml#ch13list1) ➊. I’ve used an
    empty symbolic configuration file (*empty.map*) and specified `0x404b00`, `0x404b1e`,
    and `rcx` as the entry point address, the slice address, and the register to slice,
    respectively. As you can see, this produces the same output as the manually computed
    slice you saw before ➋.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了 `backward_slicing` 来计算你在 [示例 13-1](ch13.xhtml#ch13list1) 中看到的来自 */bin/ls*
    的代码片段的切片 ➊。我使用了一个空的符号配置文件（*empty.map*），并指定了 `0x404b00`、`0x404b1e` 和 `rcx` 作为入口点地址、切片地址和需要切片的寄存器。正如你所见，这产生了与之前手动计算的切片相同的输出
    ➋。
- en: The reason it’s okay to use an empty symbolic configuration file in this example
    is that the analysis doesn’t rely on any particular registers or memory locations
    being symbolic, and you don’t need any specific concrete values to drive the execution
    since the code fragment you’re analyzing doesn’t contain any branches. Now let’s
    take a look at another example where you’ll need a nonempty symbolic configuration
    to explore multiple paths through the same program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中可以使用空的符号配置文件，是因为分析并不依赖于任何特定的寄存器或内存位置是符号的，并且你不需要任何特定的具体值来驱动执行，因为你正在分析的代码片段没有包含任何分支。现在，让我们来看一个需要非空符号配置的示例，以便在同一个程序中探索多个路径。
- en: 13.4 Using Triton to Increase Code Coverage
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4 使用 Triton 增加代码覆盖率
- en: 'Because the backward slicing example needed only Triton’s ability to track
    symbolic expressions for registers and memory locations, it didn’t use symbolic
    execution’s core strength: reasoning about program properties through constraint
    solving. In this example, you’ll get acquainted with Triton’s constraint-solving
    abilities in the classic symbex use case of *code coverage*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回溯切片示例仅需要 Triton 跟踪寄存器和内存位置的符号表达式的能力，因此它并没有利用符号执行的核心优势：通过约束求解推理程序属性。在这个示例中，你将熟悉
    Triton 在经典的符号执行（symbex）用例——*代码覆盖率*中的约束求解能力。
- en: '[Listing 13-6](ch13.xhtml#ch13list6) shows the first part of the source of
    the `code_coverage` tool. You’ll notice that a lot of the source is the same as
    or similar to that of the previous example. In fact, I’ve omitted the `set_triton_arch`
    function from the listing because it’s exactly the same as in the `backward_slicing`
    tool.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-6](ch13.xhtml#ch13list6)展示了`code_coverage`工具源代码的第一部分。你会注意到，很多源代码和之前的示例是一样的或者相似的。实际上，我已经省略了`set_triton_arch`函数，因为它和`backward_slicing`工具中的完全相同。'
- en: '*Listing 13-6:* code_coverage.cc'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-6:* code_coverage.cc'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To use the `code_coverage` tool, you supply command line arguments specifying
    the binary to analyze, a symbolic configuration file, the entry point address
    for the analysis, and the address of a direct branch instruction. The tool assumes
    that your symbolic configuration file contains concrete inputs that cause the
    branch to take one of the two possible paths (it doesn’t matter which path). It
    then uses the constraint solver to compute a model containing a new set of concrete
    inputs that will cause the branch to go the other way. For the solver to succeed,
    you must take care to symbolize all the registers and memory locations that the
    branch you want to flip depends on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`code_coverage`工具，你需要提供命令行参数，指定要分析的二进制文件、符号化配置文件、分析的入口地址，以及一个直接跳转指令的地址。该工具假设你的符号化配置文件包含具体的输入，能够使得跳转选择两个可能路径中的一个（不管选择哪条路径）。然后，它使用约束求解器计算一个模型，该模型包含一组新的具体输入，能让跳转选择另一条路径。为了使求解器成功工作，你必须小心符号化所有与跳转相关的寄存器和内存位置。
- en: As you can see in the listing, `code_coverage` includes the same utility and
    Triton header files as the previous example. Moreover, the `main` function of
    `code_coverage` is almost identical to the `main` function of `backward_slicing`.
    As in that example, it starts by loading the binary and configuring the Triton
    architecture and then enables the `ALIGNED_MEMORY` optimization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在示例中看到的，`code_coverage`包含与之前示例相同的工具和Triton头文件。此外，`code_coverage`的`main`函数几乎与`backward_slicing`的`main`函数完全相同。和前一个示例一样，它首先加载二进制文件并配置Triton架构，然后启用`ALIGNED_MEMORY`优化。
- en: '*13.4.1 Creating Symbolic Variables*'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.4.1 创建符号变量*'
- en: A difference between this and the previous example is that the code that parses
    the symbolic configuration file passes two optional arguments (`symregs` and `symmem`)
    ➊ to `parse_sym_config`. These are output arguments where `parse _sym_config`
    writes the lists of registers and memory locations to symbolize according to the
    configuration file. In the configuration file, you’ll want to symbolize all registers
    and memory locations that contain user inputs so that the model the constraint
    solver returns will give you a concrete value for each of those user inputs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例的不同之处在于，解析符号化配置文件的代码传递了两个可选参数（`symregs`和`symmem`）➊给`parse_sym_config`。这些是输出参数，`parse_sym_config`根据配置文件将需要符号化的寄存器和内存位置的列表写入到这些参数中。在配置文件中，你需要符号化所有包含用户输入的寄存器和内存位置，这样约束求解器返回的模型就会为每个用户输入提供一个具体的值。
- en: After assigning the concrete values from the configuration file, `main` loops
    over the list of registers to symbolize and symbolizes them using Triton’s `api.convertRegisterToSymbolicVariable`
    function ➋. The same line of code that symbolizes the register immediately sets
    a comment on the just-created symbolic variable, specifying the register’s human-readable
    name. That way, when you later get a model from the constraint solver, you’ll
    know how to map the symbolic variable assignments in the model back onto the real
    registers and memory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在从配置文件分配了具体值之后，`main`循环遍历符号化的寄存器列表，并使用Triton的`api.convertRegisterToSymbolicVariable`函数➋对它们进行符号化。符号化寄存器的同一行代码会立即在刚创建的符号变量上设置注释，指定寄存器的可读名称。这样，当你后来从约束求解器获取模型时，你就能知道如何将模型中的符号变量赋值映射回真实的寄存器和内存。
- en: The loop that symbolizes memory locations is similar. For each memory location
    to symbolize, it builds a `triton::arch::MemoryAccess` object, which specifies
    the address and size (in bytes) of the memory location. In this case, I’ve hardcoded
    the size to 1 byte because the configuration file format allows you to reference
    memory locations only at byte granularity. To symbolize the address specified
    in a `MemoryAccess` object, you use the Triton function `api.convertMemoryToSymbolicVariable`
    ➌. After that, the loop sets a comment mapping the new symbolic variable to a
    human-readable string containing the memory address.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用于符号化内存位置的循环类似。对于每个需要符号化的内存位置，它构建一个 `triton::arch::MemoryAccess` 对象，指定内存位置的地址和大小（以字节为单位）。在此案例中，我已将大小硬编码为
    1 字节，因为配置文件格式只允许按字节粒度引用内存位置。为了符号化 `MemoryAccess` 对象中指定的地址，你使用 Triton 函数 `api.convertMemoryToSymbolicVariable`
    ➌。之后，循环会设置一个注释，将新的符号变量映射到包含内存地址的人类可读字符串。
- en: '*13.4.2 Finding a Model for a New Path*'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*13.4.2 寻找新路径的模型*'
- en: The emulation loop ➍ is the same as in `backward_slicing`, except that this
    time it emulates until `pc` is equal to the address of the branch for which you
    want to find a new set of inputs ➎. To find these new inputs, `code_coverage`
    calls a separate function named `find_new_input`, which is shown in [Listing 13-7](ch13.xhtml#ch13list7).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真循环 ➍ 与 `backward_slicing` 中的相同，只是这次它模拟直到 `pc` 等于你想找到新输入集的分支地址 ➎。为了找到这些新输入，`code_coverage`
    调用一个名为 `find_new_input` 的独立函数，该函数在 [列表 13-7](ch13.xhtml#ch13list7) 中显示。
- en: '*Listing 13-7:* code_coverage.cc *(continued)*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-7:* code_coverage.cc *(续)*'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To find inputs that reach the previously unexplored branch direction, `find_new_input`
    feeds the solver the list of constraints that must be satisfied to reach the desired
    branch and then asks it for a model that satisfies those constraints. Recall that
    Triton represents constraints as abstract syntax trees, so to encode branch constraints,
    you need to build a corresponding AST. That’s why `find_new_input` starts by calling
    `api.getAstContext` to get a reference (called `ast`) to an `AstContext` ➊, which
    is Triton’s builder class for AST formulas.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到到达之前未探索分支方向的输入，`find_new_input` 向求解器提供必须满足的约束列表，以便到达目标分支，然后请求其返回一个满足这些约束条件的模型。回想一下，Triton
    将约束表示为抽象语法树，因此为了编码分支约束，你需要构建相应的 AST。这就是为什么 `find_new_input` 首先调用 `api.getAstContext`
    来获取对 `AstContext` 的引用（称为 `ast`）➊，这是 Triton 用于构建 AST 公式的类。
- en: To store the list of constraints that will model the path leading to the unexplored
    branch direction, `find_new_input` uses a `triton::ast::AbstractNode` object,
    reachable through a pointer called `constraint_list` ➋. `AbstractNode` is Triton’s
    class for representing AST nodes. To initialize `constraint_list`, you set it
    to the formula `ast.equal(ast.bvtrue(), ast.bvtrue())`, meaning the logical tautology
    `true == true`, where each `true` is a bitvector. This is just a way of initializing
    the constraint list to a syntactically valid formula that doesn’t impose any constraints
    and to which you can easily concatenate additional constraints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储将模拟通向未探索分支方向的约束列表，`find_new_input` 使用一个 `triton::ast::AbstractNode` 对象，通过一个名为
    `constraint_list` 的指针来访问 ➋。`AbstractNode` 是 Triton 用来表示 AST 节点的类。为了初始化 `constraint_list`，你将其设置为公式
    `ast.equal(ast.bvtrue(), ast.bvtrue())`，即逻辑上的恒等式 `true == true`，其中每个 `true` 都是一个位向量。这仅仅是一种初始化约束列表的方法，使其成为一个语法上有效的公式，不强加任何约束，并且你可以很容易地向其中连接额外的约束。
- en: Copying and Flipping Branch Constraints
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制和翻转分支约束
- en: Next, `find_new_input` calls `api.getPathConstraints` to get the list of path
    constraints that Triton has accumulated while emulating the code ➌. The list takes
    the form of a `std::vector` of `triton::engines::symbolic::PathConstraint` objects,
    where each `PathConstraint` is associated with one branch instruction. This list
    contains all the constraints that must be satisfied to take the just-emulated
    path. To turn this into a list of constraints for a new path, you copy all the
    constraints except the one for the branch you want to change, which you flip to
    the other branch direction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`find_new_input` 调用 `api.getPathConstraints` 来获取 Triton 在模拟代码 ➌ 时积累的路径约束列表。该列表以
    `std::vector` 类型的 `triton::engines::symbolic::PathConstraint` 对象形式出现，其中每个 `PathConstraint`
    都与一个分支指令相关联。此列表包含必须满足的所有约束条件，以便走到刚才模拟的路径。为了将其转换为新路径的约束列表，你需要复制所有的约束，除了你想要更改的分支的约束，并将其翻转到另一个分支方向。
- en: To implement this, `find_new_input` loops over the list of path constraints
    ➍ and copies or flips each one. Inside each `PathConstraint`, Triton stores one
    or more *branch constraints*, one for each possible branch direction. In the context
    of code coverage, you’re interested only in multiway branches such as conditional
    jumps because single-way branches like direct calls or unconditional jumps don’t
    have any new direction to explore. To determine whether a `PathConstraint` called
    `pc` represents a multiway branch, you call `pc.isMultipleBranches` ➎, which returns
    `true` if the branch is multiway.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为实现此功能，`find_new_input`遍历路径约束列表 ➍ 并复制或翻转每个约束。在每个`PathConstraint`内部，Triton存储一个或多个*分支约束*，每个约束代表一个可能的分支方向。在代码覆盖的背景下，你只对多路分支感兴趣，比如条件跳转，因为单路分支（如直接调用或无条件跳转）没有新的方向可供探索。要确定`PathConstraint`对象`pc`是否代表一个多路分支，可以调用`pc.isMultipleBranches`
    ➎，如果是多路分支，返回`true`。
- en: 'For `PathConstraint` objects that contain multiple branch constraints, `find
    _new_input` gets all the branch constraints by calling `pc.getBranchConstraints`
    and then loops over each constraint in the list ➏. Each constraint is a tuple
    of a Boolean flag, a source and destination address (both `triton::uint64`), and
    an AST encoding the branch constraint. The flag denotes whether the branch direction
    represented by the branch constraint was taken during the emulation. For example,
    consider the following conditional branch:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含多个分支约束的`PathConstraint`对象，`find_new_input`通过调用`pc.getBranchConstraints`获取所有分支约束，然后遍历列表中的每个约束
    ➏。每个约束都是一个元组，包含一个布尔标志、一个源地址和目标地址（均为`triton::uint64`类型），以及一个表示分支约束的AST。该标志表示在仿真过程中，分支约束所表示的分支方向是否被采用。例如，考虑以下条件分支：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When emulating the `jge`, Triton creates a `PathConstraint` object with two
    branch constraints. Let’s assume that the first branch constraint represents the
    *taken* direction of the `jge` (that is, the direction that’s taken if the condition
    holds) and that this is the direction taken during the emulation. That means the
    first branch constraint stored in the `PathConstraint` has a `true` flag (because
    it was taken during the emulation), and the source and destination addresses will
    be `0x4055de` (the address of the `jge`) and `0x4056d8` (the target of the `jge`),
    respectively. The AST for this branch condition will encode the condition `al`
    ≥ `0x25`. The second branch constraint has a `false` flag, representing the branch
    direction that wasn’t taken during emulation. The source and destination addresses
    are `0x4055de` and `0x4055e4` (the fallthrough address of the `jge`), and the
    AST encodes the condition `al` < `0x25` (or more precisely, `not(al` ≥ `0x25)`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真`jge`时，Triton创建一个包含两个分支约束的`PathConstraint`对象。假设第一个分支约束表示`jge`的*采用*方向（即，当条件成立时，所采用的方向），并且这是仿真中采用的方向。这意味着`PathConstraint`中存储的第一个分支约束的标志为`true`（因为它在仿真中被采用），源地址和目标地址分别为`0x4055de`（`jge`的地址）和`0x4056d8`（`jge`的目标地址）。该分支条件的AST将编码条件`al`
    ≥ `0x25`。第二个分支约束的标志为`false`，表示仿真中未采用的分支方向。源地址和目标地址分别为`0x4055de`和`0x4055e4`（`jge`的后续地址），AST编码条件为`al`
    < `0x25`（或者更精确地，`not(al` ≥ `0x25)`）。
- en: Now, for each `PathConstraint`, `find_new_input` copies the branch constraint
    whose flag is `true`, except for the `PathConstraint` associated with the branch
    instruction you want to flip, for which it instead copies the `false` branch constraint,
    thereby inverting that branch decision. To recognize the branch to flip, `find_new_input`
    uses the branch source address. For constraints with a source address unequal
    to the address of the branch to invert ➐, it copies the branch constraint with
    the `true` flag ➑ and appends it to the `constraint_list` using a logical AND,
    implemented with `ast.land`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每个`PathConstraint`，`find_new_input`复制标志为`true`的分支约束，除了与要翻转的分支指令相关联的`PathConstraint`，对于这个分支，它复制标志为`false`的分支约束，从而反转该分支决策。为了识别要翻转的分支，`find_new_input`使用分支的源地址。对于源地址不等于要翻转分支地址的约束
    ➐，它复制标志为`true`的分支约束 ➑ 并使用逻辑与（`ast.land`实现）将其附加到`constraint_list`。
- en: Getting a Model from the Constraint Solver
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从约束求解器获取模型
- en: Finally, `find_new_input` will encounter the `PathConstraint` associated with
    the branch you want to flip. It contains multiple branch constraints whose source
    address is equal to the address of the branch to flip ➒. To clearly show all possible
    branch directions in `code_coverage`’s output, `find_new_input` prints each branch
    condition with a matching source address, regardless of its flag.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: If the flag is `true`, then `find_new_input` *doesn’t* append the branch constraint
    to the `constraint_list` because it corresponds to the branch direction you’ve
    already explored. However, if the flag is `false` ➓, it represents the unexplored
    branch direction, so `find_new_input` appends this branch constraint to the constraint
    list and passes the list to the constraint solver by calling `api.getModel`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The `getModel` function invokes the constraint solver Z3 and asks it for a model
    that satisfies the list of constraints. If a model is found, `getModel` returns
    it as a `std::map` that maps Triton symbolic variable identifiers to `triton::engines::solver::SolverModel`
    objects. The model represents a new set of concrete inputs to the analyzed program
    that will cause the program to take the previously unexplored branch direction.
    If no model is found, the returned map is empty.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Each `SolverModel` object contains the concrete value that the constraint solver
    assigned to the corresponding symbolic variable in the model. The `code_coverage`
    tool reports the model to the user by looping over the map and printing each symbolic
    variable’s ID and comment, which contains the human-readable name of the corresponding
    register or memory location, as well as the concrete value assigned in the model
    (as returned by `SolverModel::getValue`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: To see how to use the output of `code_coverage` in practice, let’s now try it
    on a test program to find and use new inputs to cover a branch of your choice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*13.4.3 Testing the Code Coverage Tool*'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-8](ch13.xhtml#ch13list8) shows a simple test program that you can
    use to try the ability of `code_coverage` to generate inputs that explore a new
    branch direction.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-8:* branch.c'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the `branch` program contains a function called `branch`, which
    takes two integers called `x` and `y` as input. The `branch` function contains
    an outer `if`/`else` branch based on the value of `x` ➊ and a nested `if`/`else`
    branch based on `y` ➋. The function is called by `main` with the `x` and `y` arguments
    being supplied from user input ➌.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first run `branch` with `x = 0` and `y = 0` so that the outer branch takes
    the `if` direction and the nested branch takes the `else` direction. Then you
    can use `code_coverage` to find inputs to flip the nested branch so it takes the
    `if` direction. But first, let’s build the symbolic configuration file needed
    to run `code_coverage`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Building a Symbolic Configuration File
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To use `code_coverage`, you need a symbolic configuration file, and to make
    that, you need to know which registers and memory locations the compiled version
    of `branch` uses. [Listing 13-9](ch13.xhtml#ch13list9) shows the disassembly of
    the `branch` function. Let’s analyze it to find out which registers and memory
    locations `branch` uses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`code_coverage`，你需要一个符号配置文件，而要制作该文件，你需要知道编译后的`branch`函数使用了哪些寄存器和内存位置。[列表
    13-9](ch13.xhtml#ch13list9)展示了`branch`函数的反汇编代码。让我们分析一下它，找出`branch`函数使用的寄存器和内存位置。
- en: '*Listing 13-9: Disassembly excerpt from* ~/code/chapter13/branch'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-9：* 来自~/code/chapter13/branch的反汇编片段'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Ubuntu installation on the VM uses the x64 version of the System V *application
    binary interface (ABI)*, which dictates the *calling convention* used on the system.
    In the System V calling convention for x64 systems, the first and second arguments
    to a function call are stored in the `rdi` and `rsi` registers, respectively.^([6](footnote.xhtml#ch13fn_6))
    In this case, this means you’ll find the `x` parameter of the `branch` function
    in `rdi` and the `y` parameter in `rsi`. Internally, the `branch` function immediately
    moves `x` to the memory location `rbp-0x4` ➊ and `y` to `rbp-0x8` ➋. Then `branch`
    compares the first memory location containing `x` against the value 4 ➌, followed
    by a `jg` at address `0x4005c8`, which implements the outer `if`/`else` branch
    ➍.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机上的Ubuntu安装使用的是x64版本的System V *应用二进制接口（ABI）*，它规定了系统使用的*调用约定*。在x64系统的System
    V调用约定中，函数调用的第一个和第二个参数分别存储在`rdi`和`rsi`寄存器中。^([6](footnote.xhtml#ch13fn_6)) 在这种情况下，这意味着你可以在`rdi`中找到`branch`函数的`x`参数，在`rsi`中找到`y`参数。在内部，`branch`函数立即将`x`值移到内存位置`rbp-0x4`➊，将`y`值移到`rbp-0x8`➋。然后，`branch`将包含`x`的第一个内存位置与值4进行比较➌，接着在地址`0x4005c8`处进行`jg`跳转，实施外部`if`/`else`分支➍。
- en: The `jg`’s target address `0x4005e8` contains the `else` case (`x` ≥ `5`), while
    the fallthrough address `0x4005ca` contains the `if` case. Inside the `if` case
    is the nested `if`/`else` branch, which is implemented as a `cmp` that compares
    `y`’s value to 10 (`0xa`) ➎, followed by a `jne` that jumps to `0x4005dc` if `y`
    ≠ 10 ➏ (the nested `else`) or falls through to `0x4005d0` otherwise (the nested
    `if` case).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`jg`的目标地址`0x4005e8`包含`else`分支（`x` ≥ `5`），而跳转地址`0x4005ca`包含`if`分支。在`if`分支内部是嵌套的`if`/`else`分支，它通过`cmp`指令比较`y`的值与10（`0xa`）➎，接着是一个`jne`指令，如果`y`
    ≠ 10，则跳转到`0x4005dc`➏（即嵌套的`else`分支），否则跳转到`0x4005d0`（即嵌套的`if`分支）。'
- en: Now that you know which registers contain the `x` and `y` inputs and the address
    `0x4005ce` of the nested branch you want to flip, let’s make the symbolic configuration
    file. [Listing 13-10](ch13.xhtml#ch13list10) shows the configuration file to use
    for the test.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了哪些寄存器包含`x`和`y`的输入，以及嵌套分支的地址`0x4005ce`，接下来我们来创建符号配置文件。[列表 13-10](ch13.xhtml#ch13list10)展示了用于测试的配置文件。
- en: '*Listing 13-10:* branch.map'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-10：* branch.map'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The configuration file makes `rdi` (representing `x`) symbolic and assigns it
    the concrete value 0 ➊. It does the same for `rsi`, which contains `y` ➋. Because
    `x` and `y` are both symbolic, when you generate a model for the new inputs, the
    constraint solver will give you concrete values for both `x` and `y`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件将`rdi`（代表`x`）设为符号，并为其分配具体值0➊。它对`rsi`（包含`y`）也做了同样的处理➋。由于`x`和`y`都是符号，当你为新输入生成模型时，约束求解器将为`x`和`y`提供具体的值。
- en: Generating a New Input
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成新输入
- en: 'Recall that the symbolic configuration file assigns the value 0 to both `x`
    and `y`, creating a baseline from which `code_coverage` can generate a new input
    that covers a different path. When you run the `branch` program with these baseline
    inputs, it prints the message `x < 5 && y != 10`, as shown in the following listing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，符号配置文件将`x`和`y`的值都赋为0，这为`code_coverage`生成覆盖不同路径的新输入提供了基准。当你使用这些基准输入运行`branch`程序时，它会打印消息`x
    < 5 && y != 10`，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s now use `code_coverage` to generate new inputs that flip the nested `branch`
    that checks y’s value so that you can use these new inputs to run branch again
    and get the output x < 5 && y == 10 instead. [Listing 13-11](ch13.xhtml#ch13list11)
    shows how to do that.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`code_coverage`生成新的输入，改变检查`y`值的嵌套`branch`，这样你就可以使用这些新输入重新运行`branch`，并得到输出`x
    < 5 && y == 10`。[列表 13-11](ch13.xhtml#ch13list11)展示了如何操作。
- en: '*Listing 13-11: Finding inputs to take the alternative branch at* 0x4005ce'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-11：查找输入以选择备用分支，位于* 0x4005ce'
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You call `code_coverage` giving the `branch` program as input, as well as the
    symbolic configuration file you made (`branch.map`), the start address `0x4005b6`
    of the `branch` function (the entry point for the analysis), and the address `0x4005ce`
    of the nested branch to flip ➊.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用`code_coverage`，将`branch`程序作为输入，以及你制作的符号配置文件（`branch.map`），`branch`函数的起始地址`0x4005b6`（分析的入口点），以及嵌套分支的地址`0x4005ce`来触发翻转
    ➊。
- en: When the emulation hits that branch address, `code_coverage` evaluates and prints
    each of the branch constraints that Triton generated as part of the `PathConstraint`
    associated with the branch. The first constraint is for the branch direction with
    target address `0x4005dc` (the nested `else`), and this direction is taken during
    the emulation because of the concrete input values you specified in the configuration
    file ➋. As `code_coverage` reports, the fallthrough branch direction with destination
    address `0x4005d0` (the nested `if` case) is not taken ➌, so `code_coverage` tries
    to compute new input values that lead to that branch direction ➍.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当仿真程序到达该分支地址时，`code_coverage`会评估并打印Triton作为该分支的`PathConstraint`生成的每个分支约束。第一个约束是针对目标地址`0x4005dc`（嵌套的`else`分支）方向的，该方向在仿真过程中由于你在配置文件中指定的具体输入值而被选中
    ➋。正如`code_coverage`所报告的，指向目标地址`0x4005d0`（嵌套的`if`分支）的顺序分支方向没有被选中 ➌，因此`code_coverage`尝试计算新的输入值，以便引导到该分支方向
    ➍。
- en: Although in general the constraint solving required to find the new input values
    can take a while, it should complete in only a few seconds for constraints as
    simple as this case. Once the solver finds a model, `code_coverage` prints it
    to screen ➎. As you can see, the model assigns the concrete value 0 to `rdi` (`x`)
    and the value `0xa` to `rsi` (`y`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常需要的约束求解可能会花费一些时间，但对于像这种简单的约束，它应该只需要几秒钟就能完成。一旦求解器找到模型，`code_coverage`会将其打印到屏幕上
    ➎。正如你所看到的，模型为`rdi`（`x`）赋值为具体值0，`rsi`（`y`）赋值为`0xa`。
- en: Let’s run the `branch` program with these new inputs to see whether they cause
    the nested branch to flip.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些新输入运行`branch`程序，看看它们是否会导致嵌套分支翻转。
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these new inputs, `branch` prints the output `x < 5 && y == 10`, not the
    message `x < 5 && y != 10` that you got in the previous run of the `branch` program.
    The inputs generated by `code_coverage` successfully flipped the direction of
    the nested branch!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新输入，`branch`输出了`x < 5 && y == 10`，而不是你在之前运行`branch`程序时得到的消息`x < 5 && y !=
    10`。`code_coverage`生成的输入成功翻转了嵌套分支的方向！
- en: 13.5 Automatically Exploiting a Vulnerability
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5 自动利用漏洞
- en: Now let’s look at an example that requires more complex constraint solving than
    the previous example. In this section, you’ll learn to use Triton to automatically
    generate inputs that exploit a vulnerability in a program by hijacking an indirect
    call site and redirecting it to an address of your choice.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个比之前例子更复杂的约束求解示例。在本节中，你将学习如何使用Triton自动生成输入，通过劫持间接调用点并将其重定向到你选择的地址，从而利用程序中的漏洞。
- en: Let’s assume that you already know there’s a vulnerability that allows you to
    control the call site’s target, but you don’t yet know how to exploit it to reach
    the address you want because the target address is computed from the user inputs
    in a nontrivial way. This is a situation you may encounter in real life during
    fuzzing, for example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经知道存在一个漏洞，允许你控制调用点的目标地址，但你还不知道如何利用它来达到你想要的地址，因为目标地址是通过用户输入以非平凡的方式计算出来的。这种情况在实际的模糊测试中可能会遇到，例如。
- en: As you learned in [Chapter 12](ch12.xhtml#ch12), symbolic execution is too computationally
    expensive for a brute-force fuzzing approach that tries to find an exploit for
    every indirect call site in a program. Instead, you can optimize by first fuzzing
    the program in a more traditional way, supplying it with many pseudorandomly generated
    inputs and using taint analysis to determine whether these inputs affect dangerous
    program state, such as indirect call sites. Then, you can use symbolic execution
    to generate exploits only for those call sites that the taint analysis has revealed
    to be potentially controllable. This is the use case I assume in the following
    example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*13.5.1 The Vulnerable Program*'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s take a look at the program to exploit and the vulnerable call site
    it contains. [Listing 13-12](ch13.xhtml#ch13list12) shows the vulnerable program’s
    source file *icall.c*. The *Makefile* compiles the program into a `setuid root`
    binary^([7](footnote.xhtml#ch13fn_7)) called `icall` that contains an indirect
    call site that calls one of several handler functions. This is similar to how
    web servers like `nginx` use function pointers to choose an appropriate handler
    for the data they receive.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-12:* icall.c'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `icall` program revolves around a global `struct`, which is also called
    `icall` ➊. This `struct` contains an array called `icall.functions` that has room
    for two function pointers and a `char` array called `icall.hash` that stores a
    4-byte hash with a terminating `NULL` character. The `main` function initializes
    the first entry in `icall.functions` so that it points to a function called `forward`,
    and initializes the second entry so that it points to `reverse` ➋. Both these
    functions take a hash parameter in the form of a `char*` and print the hash’s
    bytes in forward or reverse order, respectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The `icall` program takes two command line arguments: an integer index and
    a string. The index decides which entry from `icall.functions` will be called,
    while the string serves as input to generate the hash, as you’ll see in a moment.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a secret third command line argument not advertised in the usage
    string. This argument is a password for an admin area that provides a root shell.
    To check the password, `icall` hashes it with the GNU `crypt` function (from *crypt.h*),
    and if the hash is correct, the user is granted access to the root shell ➌. Our
    goal for the exploit is to hijack an indirect call site and redirect it to this
    secret admin area without knowing the password.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If no secret password is supplied ➍, `icall` calls a function named `hash` that
    computes a 4-byte hash over the string supplied by the user and places that hash
    in `icall.hash` ➎. After computing the hash, `icall` parses the index from the
    command line ➏ and uses it to index the `icall.functions` array, indirectly calling
    the handler at that index and passing the just-computed hash as the argument ➐.
    This indirect call is the one I’ll use in the exploit. For diagnostics, `icall`
    prints the address of the function it’s about to invoke, which will be handy later
    when crafting the exploit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the indirect call invokes `forward` or `reverse`, which then prints
    the hash to screen as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, I’ve used `1` as the function index, resulting in a call to the `reverse`
    function, and `foo` as the input string ➊. You can see that the indirect call
    targets address `0x400974` (the start of `reverse`) ➋, and the hash of `foo`,
    printed in reverse, is `0x22295079` ➌.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the indirect call is vulnerable: there’s no verification
    that the user-supplied index stays within the bounds of `icall.functions`, so
    by supplying an out-of-bounds index, the user can coax the `icall` program into
    using data *outside* the `icall.functions` array as the indirect call target!
    As it happens, the `icall.hash` field is adjacent to `icall.functions` in memory,
    so by supplying the out-of-bounds index 2, the user can trick the `icall` program
    into using `icall.hash` as the indirect call target, as you can see in the following
    listing:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the called address corresponds to the hash interpreted as a little-endian
    address ➊! There’s no code at that address, so the program crashes with a segmentation
    fault ➋. However, recall that the user controls not only the index but also the
    string used as the input for the hash. The challenge is to find a string that
    hashes exactly to the address of the secret admin area and then trick the indirect
    call into using that hash as the call target, thereby transferring control to
    the admin area and giving you a root shell without needing to know the password.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: To manually craft an exploit for this vulnerability, you would need to either
    use brute force or reverse engineer the `hash` function to figure out which input
    string provides the desired hash. The great thing about using symbex to generate
    the exploit is that it will automatically solve the `hash` function, allowing
    you to simply treat it as a black box!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '*13.5.2 Finding the Address of the Vulnerable Call Site*'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Automatically building the exploit requires two key pieces of information:
    the address of the vulnerable indirect call site that the exploit should hijack
    and the address of the secret admin area where you want to redirect control. [Listing
    13-13](ch13.xhtml#ch13list13) shows the disassembly of the `main` function from
    the `icall` binary, which contains both these addresses.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-13: Disassembly excerpt from* ~/code/chapter13/icall'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code for the secret admin area starts at address `0x400b3b` ➊, so that’s
    where you’ll want to redirect control. You can tell it’s the admin area by the
    calls to `setgid` ➋ and `setuid` ➌, where `icall` prepares the `root` privileges
    for the shell, and by the call to `execl` ➍ that spawns the shell itself. The
    vulnerable indirect call site to hijack is at address `0x400bef` ➎.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the necessary addresses, let’s build the symbex tool to generate
    the exploit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '*13.5.3 Building the Exploit Generator*'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Briefly put, the tool that generates the exploit works by concolically executing
    the `icall` program, symbolizing all of the command line arguments given by the
    user, with a separate symbolic variable per byte of input. It then tracks this
    symbolic state all the way from the start of the program and through the `hash`
    function until execution finally reaches the indirect call site to exploit. At
    that point, the exploit generator calls the constraint solver and asks it if there’s
    any assignment of concrete values to the symbolic variables that makes the indirect
    call target (stored in `rax`) equal to the address of the secret admin area. If
    such a model exists, the exploit generator prints it to screen, and you can then
    use those values as input to exploit the `icall` program.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Note that in contrast to the earlier examples, this one uses Triton’s concolic
    mode rather than its symbolic emulation mode. The reason is that generating the
    exploit requires tracing the symbolic state through a whole program across multiple
    functions, which is inconvenient and slow in emulation mode. Moreover, concolic
    execution mode makes it easy to experiment with different lengths for the input
    string.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most examples in this book, this one is written in Python because Triton’s
    concolic mode only allows you to use the Python API. Concolic Triton tools are
    Python scripts that you pass to a special Pin tool that provides Triton’s concolic
    engine. Triton provides a wrapper script called `triton` that automatically takes
    care of all the details of calling Pin so that all you have to do is specify which
    Triton tool to use and which program to analyze. You can find the `triton` wrapper
    script in *~/triton/pin-2.14-71313-gcc.4.4.7-linux/ source/tools/Triton/build*,
    and you’ll see an example of how to use it when testing the automatic exploit
    generation tool.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Concolic Execution
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 13-14](ch13.xhtml#ch13list14) shows the first part of the exploit
    generation tool, *exploit _callsite.py*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-14:* exploit_callsite.py'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Concolic Triton tools like *exploit_callsite.py* must import the `triton` and
    `pintool` modules ➊, which provide access to the familiar Triton API and Triton’s
    bindings for interacting with Pin, respectively. Unfortunately, there’s no way
    to pass command line arguments to concolic Triton tools, so I’ve instead hardcoded
    the addresses of the indirect call site you’re exploiting (`taintedCallsite`)
    and the secret admin area (`target`) ➋ to which you want to redirect control.
    The `taintedCallsite` variable gets its name from the assumption that you found
    this call site in a previous taint analysis pass. As an alternative to hardcoded
    arguments, you could also pass arguments via environment variables, for example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Concolic Triton tools maintain the symbex state in a global Triton context,
    which you access by calling `pintool.getTritonContext()` ➌. This returns a `TritonContext`
    object that you can use to access (a subset of) the familiar Triton API functions.
    Here, *exploit_callsite.py* stores a reference to that `TritonContext` in a global
    variable called `Triton` for easy access.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The main logic of *exploit_callsite.py* starts in the function named `main`,
    which is called when the script starts. Just like in the C++ symbolic emulation
    tools you saw earlier, it starts by setting the Triton architecture and enabling
    the `ALIGNED_MEMORY` optimization ➍. Because this tool is tailored toward the
    `icall` binary you’re exploiting, I’ve simply hardcoded the architecture to x86-64
    instead of making it configurable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Next, *exploit_callsite.py* uses Triton’s `pintool` API to set up the starting
    point for the concolic analysis. It tells Triton to start the symbolic analysis
    from the `main` function in the vulnerable `icall` program ➎. That means all of
    `icall`’s initialization code that comes before `main` runs without symbolic analysis,
    and Triton’s analysis kicks in once execution reaches `main`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Note that this assumes that symbols are available; if they aren’t, then Triton
    won’t know where the `main` function is. In that case, you’ll instead have to
    find the address of `main` yourself through disassembly and tell Triton to start
    analysis at that address by calling `pintool.startAnalysisFromAddress` instead
    of `pintool.startAnalysisFromSymbol`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'After configuring the analysis starting point, *exploit_callsite.py* registers
    two callbacks using Triton’s `pintool.insertCall` function. The `pintool.insertCall`
    function takes at least two arguments: a callback function and an *insert point*,
    followed by zero or more optional arguments depending on the type of insert point.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The first installed callback function is named `symbolize_inputs` and uses the
    insert point `INSERT_POINT.ROUTINE_ENTRY` ➏, which means the callback triggers
    when execution reaches the entry point of a given routine. You can specify that
    routine by name in an extra argument to `insertCall`. In the case of `symbolize_inputs`,
    I’ve specified `main` as the routine to install the callback on because the purpose
    of `symbolize_inputs` is to symbolize all of the user inputs given to `icall`’s
    `main` function. When a callback of type `ROUTINE_ENTRY` happens, Triton passes
    the current thread ID as an argument to the callback function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The second callback is named `hook_icall`, and it’s installed on the insert
    point `INSERT_POINT.BEFORE` ➐, meaning that the callback triggers before every
    instruction. The job of `hook_icall` is to check whether execution has reached
    the vulnerable indirect call site and, if so, generate an exploit for it given
    the results of the symbolic analysis. When the callback triggers, Triton provides
    `hook_icall` with an `Instruction` argument representing the details of the instruction
    that’s about to execute so that `hook_icall` can check whether it’s the indirect
    call instruction you want to exploit. [Table 13-1](ch13.xhtml#ch13tab1) shows
    an overview of all the possible insert points Triton supports.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** Triton Insert Points for Callbacks in Concolic Mode'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '| **Insert point** | **Callback moment** | **Arguments** | **Callback arguments**
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `AFTER` | After instruction executes |  | `Instruction` object |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `BEFORE` | Before instruction executes |  | `Instruction` object |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `BEFORE_SYMPROC` | Before symbolic processing |  | `Instruction` object |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `FINI` | End of execution |  |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `ROUTINE_ENTRY` | Routine entry point | Routine name | Thread ID |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `ROUTINE_EXIT` | Routine exit | Routine name | Thread ID |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `IMAGE_LOAD` | New image loaded |  | Image path, base address, size |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| `SIGNALS` | Signal delivery |  | Thread ID, signal ID |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `SYSCALL_ENTRY` | Before syscall |  | Thread ID, syscall descriptor |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `SYSCALL_EXIT` | After syscall |  | Thread ID, syscall descriptor |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: Finally, after completing the prerequisite setup, *exploit_callsite.py* calls
    `pintool.runProgram` to start running the analyzed program ➑. That completes all
    the necessary setup for concolically analyzing the `icall` program, but I haven’t
    yet discussed any of the code responsible for generating the actual exploit. Let’s
    do that now and discuss the callback handler functions `symbolize_inputs` and
    `hook_icall`, which implement the user input symbolization and the call site exploitation,
    respectively.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Symbolizing the User Inputs
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 13-15](ch13.xhtml#ch13list15) shows the implementation of `symbolize_inputs`,
    the handler that’s called when execution reaches the `main` function of the analyzed
    program. In accordance with [Table 13-1](ch13.xhtml#ch13tab1), `symbolize_inputs`
    takes a thread ID parameter because it’s a callback for the `ROUTINE_ENTRY` insert
    point. For the purposes of this example, you don’t need to know the thread ID
    and can simply ignore it. As mentioned previously, `symbolize_inputs` symbolizes
    all the command line arguments given by the user so that the solver can later
    figure out how to manipulate these symbolic variables to craft an exploit.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-15:* exploit_callsite.py *(continued)*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To symbolize the user inputs, `symbolize_inputs` needs access to the argument
    count (`argc`) and argument vector (`argv`) of the analyzed program. Because `symbolize_inputs`
    is called when `main` starts, you can get `argc` and `argv` by reading the `rdi`
    and `rsi` registers, which contain `main`’s first two arguments according to the
    x86-64 System V ABI ➊. To read a register’s current value as it is in the concrete
    execution, you use the `pintool.getCurrentRegisterValue` function, giving the
    register’s ID as input.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining `argc` and `argv`, `symbolize_inputs` loops over all the arguments
    by decrementing `rdi` (`argc`) until no more arguments remain ➋. Recall that in
    C/C++ programs, `argv` is an array of pointers to character strings. To get a
    pointer from `argv`, `symbolize_inputs` reads 8 bytes (`triton.CPUSIZE.QWORD`)
    from the `argv` entry currently indexed by `rdi` using Triton’s `pintool.getCurrentMemoryValue`
    function, which takes an address and size as input ➌, and stores the read pointer
    in `addr`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Next, `symbolize_inputs` reads all of the characters from the string pointed
    to by `addr` in turn, incrementing `addr` until it reads a `NULL` character ➍.
    To read each character, it again uses `getCurrentMemoryValue` ➎, this time without
    a size argument so that it reads the default size of 1 byte. After reading a character,
    `symbolize_inputs` sets that character as the concrete value for that memory address
    in Triton’s global context ➏ and converts the memory address containing the user
    input byte into a symbolic variable ➐, setting a comment on that symbolic variable
    to later remind you to which `argv` index it corresponds. Again, this should be
    familiar from the C++ examples you saw before.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: After `symbolize_inputs` completes, all of the command line arguments given
    by the user will have been converted into separate symbolic variables (one per
    input byte) and set as concrete state in Triton’s global context. Now let’s see
    how *exploit_callsite.py* uses the solver to solve for these symbolic variables
    and find an exploit for the vulnerable call site.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Solving for an Exploit
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 13-16](ch13.xhtml#ch13list16) shows `hook_icall`, the callback that’s
    called just before every instruction.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-16:* exploit_callsite.py *(continued)*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For each instruction, `hook_icall` checks whether it’s the indirect call that
    you want to exploit. It first verifies that this is a control flow instruction
    ➊ and that it has the address of the call site you want to exploit. It then loops
    over all the instruction’s operands ➋ to find the register operand containing
    the call site’s target address ➌. Finally, if all these checks hold up, `hook_icall`
    calls the `exploit_icall` function to compute the exploit itself ➍. [Listing 13-17](ch13.xhtml#ch13list17)
    shows the implementation of `exploit_icall`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-17:* exploit_callsite.py *(continued)*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To compute the exploit for the vulnerable call site, `exploit_icall` starts
    by getting the register ID of the register operand containing the indirect call’s
    target address ➊. It then calls `Triton.getAstFromId` to get the AST containing
    the symbolic expression for this register and calls `Triton.unrollAst` to “unroll”
    it into a fully expanded AST without reference nodes ➋.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `exploit_icall` gets a Triton `AstContext`, which it uses to build the
    AST expression for the solver ➌, just like you saw before in the code coverage
    tool in [Section 13.4](ch13.xhtml#ch13_4). The base constraint to satisfy for
    the exploit is straightforward: you want to find a solution such that the symbolic
    expression for the indirect call’s target register equals the address of the secret
    admin area as stored in the global `target` variable ➍.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Note that the constant `triton.CPUSIZE.QWORD_BIT` represents the size of a machine
    quad word (8 bytes) *in bits* in contrast to `triton.CPUSIZE.QWORD`, which represents
    that same size in bytes. This means that `ast.bv(target, triton.CPUSIZE.QWORD_BIT)`
    builds a 64-bit bitvector containing the address of the secret admin area.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the base constraint for the target register expression, the exploit
    requires some constraints on the form the user inputs can take. To impose these
    constraints, `exploit_icall` loops over all the symbolic variables ➎, checking
    their comments to see whether they represent user input bytes from `argv` ➏. If
    so, `exploit_icall` gets the symbolic variable’s AST expression ➐ and constrains
    it such that the byte must be a printable ASCII character ➑ ( ≥ 32 and ≥ 126).
    It then appends this constraint to the overall list of constraints for the exploit
    ➒.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `exploit_icall` calls `Triton.getModel` to compute an exploit model
    for the set of constraints it just built ➓, and if such a model exists, it prints
    the model to screen so that the user can use it to exploit the `icall` program.
    For each variable in the model, the output shows its Triton ID as well as its
    human-readable comment that says to which `argv` byte the symbolic variable corresponds.
    That way, the user can easily map the model back onto concrete command line arguments.
    Let’s try this by generating an exploit for the `icall` program and using it to
    gain a root shell.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*13.5.4 Getting a Root Shell*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-18](ch13.xhtml#ch13list18) shows how to use *exploit_callsite.py*
    in practice to generate an exploit for the `icall` program.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-18: Trying to find an exploit for* icall *with input length 3*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, you navigate to the main Triton directory on the VM, where you’ll find
    the `triton` wrapper script ➊. Recall that Triton provides this wrapper script
    to automatically handle the required Pin setup for concolic tools. In a nutshell,
    the wrapper script runs the analyzed program (`icall`) in Pin using Triton’s concolic
    library as the Pintool. That library takes your user-defined concolic tool (*exploit_callsite.py*)
    as an argument and takes care of starting the tool.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do to start the analysis is call the `triton` wrapper script
    ➋, passing the name of the *exploit_callsite.py* script ➌ and the name and arguments
    of the program to analyze (`icall` with index 2 and input string `AAA`) ➍. The
    `triton` wrapper script now ensures that `icall` runs with the given arguments
    in Pin under control of the *exploit_callsite.py* script. Note that the input
    string `AAA` is not an exploit but just an arbitrary string to drive the concolic
    execution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The script intercepts `icall`’s `main` function and symbolizes all the user
    input bytes in `argv` ➎. When `icall` reaches the indirect call site, it uses
    the address `0x223c625e` as the target ➏, which is the hash of `AAA`. This is
    a bogus address that would normally lead to a crash, but in this case it doesn’t
    matter because *exploit_callsite.py* computes the exploit model before the indirect
    call ever executes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: When the indirect call is about to execute ➐, *exploit_callsite.py* tries to
    find a model that yields a set of user inputs that hash to the call target `0x400b3b`,
    which is the address of the secret admin area ➑. Note that this step may take
    a while, up to a few minutes depending on your hardware configuration. Unfortunately,
    the solver is unable to find a model, so *exploit_callsite.py* stops without finding
    an exploit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, this doesn’t necessarily mean that no exploit exists. Recall that you’ve
    given the concolic execution of `icall` the input string `AAA` and that *exploit_callsite.py*
    creates a separate symbolic variable for each of the three input bytes in that
    string. As a result, the solver tries to find an exploit model based on a user
    input string of length 3\. Thus, the solver’s inability to find an exploit means
    only that there’s no input string *of length 3* that forms a suitable exploit,
    but you may have more luck for inputs of a different length. Rather than trying
    every possible input length manually, you can automate this process, as shown
    in [Listing 13-19](ch13.xhtml#ch13list19).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-19: Scripting exploit attempts with varying input length*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, I’ve used a `bash for` statement to loop over all integers *i* between
    1 and 100 ➊. In each iteration, the loop creates a string of *i* letter “A” characters
    ➋ and then tries to generate an exploit with this length-*i* string as the user
    input ➌, just like you saw in [Listing 13-18](ch13.xhtml#ch13list18) for length
    3.^([8](footnote.xhtml#ch13fn_8))
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: To reduce clutter in the output, you can use `grep` to display only output lines
    containing the word *SymVar*. This ensures that the output shows only those lines
    printed from successful models and that exploit generation attempts that don’t
    produce a model fail silently.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The exploit loop’s output starts at ➍. It fails to find a model for input lengths
    1 through 3 but succeeds for length 4 ➎ and again for length 5 ➏. I’ve stopped
    execution after that because there’s no need to try more input lengths when you’ve
    already found an exploit.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try the first exploit reported in the output (the one with length 4).
    To translate this output into an exploit string, you concatenate the ASCII characters
    that the solver assigned to the symbolic variables that correspond to `argv[2][0]`
    through `argv[2][3]` since those are the user input bytes used as input for `icall`’s
    hash function. As you can see in [Listing 13-19](ch13.xhtml#ch13list19), the solver
    chose the values `0x24`, `0x2A`, `0x58`, and `0x26` for those bytes, respectively.
    The byte at `argv[2][4]` should be the terminating `NULL` of the user input string,
    but the solver doesn’t know that and so picked the random input byte `0x40` for
    that position, which you can safely ignore.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The bytes assigned to `argv[2][0]` through `argv[2][3]` in the model correspond
    to the ASCII exploit string `$*X&`. Let’s try giving this exploit string as input
    to `icall` in [Listing 13-20](ch13.xhtml#ch13list20).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-20: Exploiting the* icall *program*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To try the exploit, you navigate back to the code directory for this chapter,
    where `icall` is ➊, and then call `icall` with the out-of-bounds index 2 and the
    just-generated exploit string ➋. As you can see, the exploit string hashes exactly
    to `0x400b3b`, the address of the secret admin area ➌. Thanks to the lack of bounds
    checking on the function pointer index given by the user, you successfully trick
    `icall` into calling that address and giving you a root shell ➍. As you can see,
    the command `whoami` prints `root`, verifying that you’ve obtained a root shell.
    You’ve automatically generated an exploit using symbolic execution!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Summary
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use symbolic execution to build tools that
    automatically uncover nontrivial information about binary programs. Symbolic execution
    is one of the most powerful binary analysis techniques, although you have to use
    it with care to minimize scalability issues. As you’ve seen in the automatic exploitation
    example, you can further increase the effectiveness of your symbex tools by combining
    them with other techniques, such as dynamic taint analysis.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve read this book in its entirety, you should now be familiar with a
    variety of binary analysis techniques that you can use for a wide range of goals,
    from hacking and security testing to reverse engineering, malware analysis, and
    debugging. I hope this book has enabled you to work more effectively on your own
    binary analysis projects and that it’s given you a solid basis from which to continue
    learning in the field of binary analysis, perhaps even advancing it through your
    own contributions!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Generating License Keys
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In the code directory for this chapter, you’ll find a program called *license.c*
    that takes as input a serial number and checks whether it’s valid (similar to
    license key checks in commercial software). Make a symbolic execution tool with
    Triton that can generate valid license keys accepted by *license.c*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
