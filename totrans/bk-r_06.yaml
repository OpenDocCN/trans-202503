- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LISTS AND DATA FRAMES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Vectors, matrices, and arrays are efficient and convenient data storage structures
    in R, but they have one distinct limitation: they can store only one type of data.
    In this chapter, you’ll explore two more data structures, lists and data frames,
    which can store multiple types of values at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.1 Lists of Objects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *list* is an incredibly useful data structure. It can be used to group together
    any mix of R structures and objects. A single list could contain a numeric matrix,
    a logical array, a single character string, and a factor object. You can even
    have a list as a component of another list. In this section, you’ll see how to
    create, modify, and access components of these flexible structures.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.1 Definition and Component Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a list is much like creating a vector. You supply the elements that
    you want to include to the `list` function, separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the list `foo`, you’ve stored a 2 × 2 numeric matrix, a logical vector, and
    a character string. These are printed in the order they were supplied to `list`.
    Just as with vectors, you can use the `length` function to check the number of
    components in a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can retrieve components from a list using indexes, which are entered in
    double square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This action is known as a *member reference*. When you’ve retrieved a component
    this way, you can treat it just like a stand-alone object in the workspace; there’s
    nothing special that needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To overwrite a member of `foo`, you use the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose now you want to access the second and third components of `foo` and
    store them as one object. Your first instinct might be to try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But R hasn’t done what you wanted. Instead, it returned the third element of
    the second component. This is because using double square brackets on a list is
    always interpreted with respect to a single member. Fortunately, member referencing
    with the double square brackets is not the only way to access components of a
    list. You can also use single square bracket notation. This is referred to as
    *list slicing*, and it lets you select multiple list items at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result `bar` is itself a list with the two components stored in
    the order in which they were requested.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.2 Naming***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can *name* list components to make the elements more recognizable and easy
    to work with. Just like the information stored about factor levels (as you saw
    in [Section 4.3.1](ch04.xhtml#ch04lev2sec46)), a name is an R *attribute*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding names to the list `foo` from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This has changed how the object is printed to the console. Where earlier it
    printed `[[1]]`, `[[2]]`, and `[[3]]` before each component, now it prints the
    names you specified: `$mymatrix`, `$mylogicals`, and `$mystring`. You can now
    perform member referencing using these names and the dollar operator, rather than
    the double square brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as calling `foo[[1]]`. In fact, even when an object is named,
    you can still use the numeric index to obtain a member.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Subsetting named members also works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This confirms (using the `all` function you saw in [Section 4.1.2](ch04.xhtml#ch04lev2sec38))
    that these two ways of extracting the second column of the matrix in `foo` provide
    an identical result.
  prefs: []
  type: TYPE_NORMAL
- en: To name the components of a list as it’s being created, assign a label to each
    component in the `list` command. Using some components of `foo`, create a new,
    named list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The object `baz` now contains the three named components `tom`, `dick`, and
    `harry`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you want to rename these members, you can simply assign a character vector
    of length 3 to `names(baz)`, the same way you did for `foo` earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When using the* `names` *function, the component names are always provided
    and returned as character strings in double quotes. However, if you’re specifying
    names when a list is created (inside the* `list` *function) or using names to
    extract members with the dollar operator, the names are entered without quotes
    (in other words, they are* not *given as strings).*'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.3 Nesting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted earlier, a member of a list can itself be a list. When nesting lists
    like this, it’s important to keep track of the depth of any member for subsetting
    or extraction later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can add components to any existing list by using the dollar operator
    and a *new* name. Here’s an example using `foo` and `baz` from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve defined a fourth component to the list `baz` called `bobby`. The
    member `bobby` is assigned the entire list `foo`. As you can see by printing the
    new `baz`, there are now three components in `bobby`. Naming and indexes are now
    both layered, and you can use either (or combine them) to retrieve members of
    the inner list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These all instruct R to return the first three elements of the logical vector
    stored as the second component (`[[2]]`, also named `mylogicals`) of the list
    `bobby`, which in turn is the fourth component of the list `baz`. As long as you’re
    aware of what is returned at each layer of a subset, you can continue to subset
    as needed using names and numeric indexes. Consider the third line in this example.
    The first layer of the subset is `baz[[4]]`, which is a list with three components.
    The second layer of subsetting extracts the component `mylogicals` from that list
    by calling `baz[[4]]$mylogicals`. This component represents a vector of length
    4, so the third layer of subsetting retrieves the first three elements of that
    vector with the line `baz[[4]]$mylogicals[1:3]`.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are often used to return output from various R functions. But they can
    quickly become rather large objects in terms of system resources to store. It’s
    generally recommended that when you have only one type of data, you should stick
    to using basic vector, matrix, or array structures to record and store the observations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list that contains, in this order, a sequence of 20 evenly spaced
    numbers between −4 and 4; a 3 × 3 matrix of the logical vector `c(F,T,T,T,F,T,T,F,F)`
    filled column-wise; a character vector with the two strings `"don"` and `"quixote"`;
    and a factor vector containing the observations `c("LOW","MED","LOW","MED","MED","HIGH")`.
    Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract row elements `2` and `1` of columns `2` and `3`, in that order, of the
    logical matrix.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `sub` to overwrite `"quixote"` with `"Quixote"` and `"don"` with `"Don"`
    inside the list. Then, using the newly overwritten list member, concatenate to
    the console screen the following statement exactly:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Obtain all values from the sequence between −4 and 4 that are greater than 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `which`, determine which indexes in the factor vector are assigned the
    `"MED"` level.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new list with the factor vector from (a) as a component named `"facs"`;
    the numeric vector `c(3,2.1,3.3,4,1.5,4.9)` as a component named `"nums"`; and
    a nested list comprised of the first three members of the list from (a) (use list
    slicing to obtain this), named `"oldlist"`. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the elements of `"facs"` that correspond to elements of `"nums"` that
    are greater than or equal to 3.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new member to the list named `"flags"`. This member should be a logical
    vector of length 6, obtained as a twofold repetition of the third column of the
    logical matrix in the `"oldlist"` component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `"flags"` and the logical negation operator `!` to extract the entries of
    `"num"` corresponding to `FALSE`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the character string vector component of `"oldlist"` with the single
    character string `"Don Quixote"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**5.2 Data Frames**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *data frame* is R’s most natural way of presenting a data set with a collection
    of recorded observations for one or more variables. Like lists, data frames have
    no restriction on the data types of the variables; you can store numeric data,
    factor data, and so on. The R data frame can be thought of as a list with some
    extra rules attached. The most important distinction is that in a data frame (unlike
    a list), the members must all be vectors of equal length.
  prefs: []
  type: TYPE_NORMAL
- en: The data frame is one of the most important and frequently used tools in R for
    statistical data analysis. In this section, you’ll look at how to create data
    frames and learn about their general characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.2.1 Construction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a data frame from scratch, use the `data.frame` function. You supply
    your data, grouped by variable, as vectors of the same length—the same way you
    would construct a named list. Consider the following example data set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you’ve constructed a data frame with the first name, age in years, and
    sex of five individuals. The returned object should make it clear why vectors
    passed to `data.frame` must be of equal length: vectors of differing lengths wouldn’t
    make sense in this context. If you pass vectors of unequal length to `data.frame`,
    then R will attempt to recycle any shorter vectors to match the longest, throwing
    your data off and potentially allocating observations to the wrong variable. Notice
    that data frames are printed to the console in rows and columns—they look more
    like a matrix than a named list. This natural spreadsheet style makes it easy
    to read and manipulate data sets. Each row in a data frame is called a *record*,
    and each column is a *variable*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extract portions of the data by specifying row and column index positions
    (much as with a matrix). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you the element at row 2, column 2—the age of Lois. Now extract
    the third, fourth, and fifth elements of the third column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a factor vector with the sex of Meg, Chris, and Stewie. The following
    extracts the entire third and first columns (in that order):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This results in another data frame giving the sex and then the name of each
    person.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the names of the vectors that were passed to `data.frame` to
    access variables even if you don’t know their column index positions, which can
    be useful for large data sets. You use the same dollar operator you used for member-referencing
    named lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can subset this returned vector, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This returns the same thing as the earlier call of `mydata[2,2]`.
  prefs: []
  type: TYPE_NORMAL
- en: You can report the size of a data frame—the number of records and variables—just
    as you’ve seen for the dimensions of a matrix (first shown in [Section 3.1.3](ch03.xhtml#ch03lev2sec26)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `nrow` function retrieves the number of rows (records), `ncol` retrieves
    the number of columns (variables), and `dim` retrieves both.
  prefs: []
  type: TYPE_NORMAL
- en: 'R’s default behavior for character vectors passed to `data.frame` is to convert
    each variable into a factor object. Observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this variable has levels, which shows it’s being treated as a factor.
    But this isn’t what you intended when you defined `mydata` earlier—you explicitly
    defined `sex` to be a factor but left `person` as a vector of character strings.
    To prevent this automatic conversion of character strings to factors when using
    `data.frame`, set the optional argument `stringsAsFactors` to `FALSE` (otherwise,
    it defaults to `TRUE`). Reconstructing `mydata` with this in place looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You now have `person` in the desired, nonfactor form.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.2.2 Adding Data Columns and Combining Data Frames***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you want to add data to an existing data frame. This could be a set of observations
    for a new variable (adding to the number of columns), or it could be more records
    (adding to the number of rows). Once again, you can use some of the functions
    you’ve already seen applied to matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the `rbind` and `cbind` functions from [Section 3.1.2](ch03.xhtml#ch03lev2sec25),
    which let you append rows and columns, respectively. These same functions can
    be used to extend data frames intuitively. For example, suppose you had another
    record to include in `mydata`: the age and sex of another individual, Brian. The
    first step is to create a new data frame that contains Brian’s information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To avoid any confusion, it’s important to make sure the variable names and the
    data types match the data frame you’re planning to add this to. Note that for
    a factor, you can extract the levels of the existing factor variable using `levels`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can simply call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using `rbind`, you combined `mydata` with the new record and overwrote `mydata`
    with the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a variable to a data frame is also quite straightforward. Let’s say
    you’re now given data on the classification of how funny these six individuals
    are, defined as a “degree of funniness.” The degree of funniness can take three
    possible values: `Low`, `Med` (medium), and `High`. Suppose Peter, Lois, and Stewie
    have a high degree of funniness, Chris and Brian have a medium degree of funniness,
    and Meg has a low degree of funniness. In R, you’d have a factor vector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates the basic character vector as `funny`, and the second
    line overwrites `funny` by turning it into a factor. The order of these elements
    must correspond to the records in your data frame. Now, you can simply use `cbind`
    to append this factor vector as a column to the existing `mydata`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `rbind` and `cbind` functions aren’t the only ways to extend a data frame.
    One useful alternative for adding a variable is to use the dollar operator, much
    like adding a new member to a named list, as in [Section 5.1.3](ch05.xhtml#ch05lev2sec51).
    Suppose now you want to add another variable to `mydata` by including a column
    with the age of the individuals in months, not years, calling this new variable
    `age.mon`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new `age.mon` column with the dollar operator and at the same
    time assigns it the vector of ages in years (already stored as `age`) multiplied
    by 12.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.2.3 Logical Record Subsets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Section 4.1.5](ch04.xhtml#ch04lev2sec41), you saw how to use logical flag
    vectors to subset data structures. This is a particularly useful technique with
    data frames, where you’ll often want to examine a subset of entries that meet
    certain criteria. For example, when working with data from a clinical drug trial,
    a researcher might want to examine the results for just male participants and
    compare them to the results for females. Or the researcher might want to look
    at the characteristics of individuals who responded most positively to the drug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue to work with `mydata`. Say you want to examine all records corresponding
    to males. From [Section 4.3.1](ch04.xhtml#ch04lev2sec46), you know that the following
    line will identify the relevant positions in the `sex` factor vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This flags the male records. You can use this with the matrix-like syntax you
    saw in [Section 5.2.1](ch05.xhtml#ch05lev2sec52) to get the male-only subset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This returns data for all variables for only the male participants. You can
    use the same behavior to pick and choose which variables to return in the subset.
    For example, since you know you are selecting the males only, you could omit `sex`
    from the result using a negative numeric index in the column dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t have the column number or if you want to have more control over
    the returned columns, you can use a character vector of variable names instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The logical conditions you use to subset a data frame can be as simple or as
    complicated as you need them to be. The logical flag vector you place in the square
    brackets just has to match the number of records in the data frame. Let’s extract
    from `mydata` the full records for individuals who are more than 10 years old
    OR have a high degree of funniness.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, asking for a subset will yield no records. In this case, R returns
    a data frame with zero rows, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, no records are returned from `mydata` because there are no
    individuals older than 45\. To check whether a subset will contain any records,
    you can use `nrow` on the result—if this is equal to zero, then no records have
    satisfied the specified condition(s).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 5.2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and store this data frame as `dframe` in your R workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| `person` | `sex` | `funny` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Stan` | `M` | `High` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Francine` | `F` | `Med` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Steve` | `M` | `Low` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Roger` | `M` | `High` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Hayley` | `F` | `Med` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Klaus` | `M` | `Med` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The variables `person`, `sex`, and `funny` should be identical in nature to
    the variables in the `mydata` object studied throughout [Section 5.2](ch05.xhtml#ch05lev1sec20).
    That is, `person` should be a character vector, `sex` should be a factor with
    levels `F` and `M`, and `funny` should be a factor with levels `Low`, `Med`, and
    `High`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stan and Francine are 41 years old, Steve is 15, Hayley is 21, and Klaus is
    60\. Roger is extremely old—1,600 years. Append these data as a new numeric column
    variable in `dframe` called `age`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your knowledge of reordering the column variables based on column index
    positions to overwrite `dframe`, bringing it in line with `mydata`. That is, the
    first column should be `person`, the second column `age`, the third column `sex`,
    and the fourth column `funny`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn your attention to `mydata` as it was left after you included the `age.mon`
    variable in [Section 5.2.2](ch05.xhtml#ch05lev2sec53). Create a new version of
    `mydata` called `mydata2` by deleting the `age.mon` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, combine `mydata2` with `dframe`, naming the resulting object `mydataframe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a single line of code that will extract from `mydataframe` just the names
    and ages of any records where the individual is female and has a level of funniness
    equal to `Med` OR `High`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your knowledge of handling character strings in R to extract all records
    from `mydataframe` that correspond to people whose names start with *S*. Hint:
    Recall `substr` from [Section 4.2.4](ch04.xhtml#ch04lev2sec45) (note that `substr`
    can be applied to a vector of multiple character strings).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | Create a list | [Section 5.1.1](ch05.xhtml#ch05lev2sec49), [p. 89](ch05.xhtml#page_89)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[[ ]]` | Unnamed member reference | [Section 5.1.1](ch05.xhtml#ch05lev2sec49),
    [p. 90](ch05.xhtml#page_90) |'
  prefs: []
  type: TYPE_TB
- en: '| `[ ]` | List slicing (multiple members) | [Section 5.1.1](ch05.xhtml#ch05lev2sec49),
    [p. 91](ch05.xhtml#page_91) |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Get named member/variable | [Section 5.1.2](ch05.xhtml#ch05lev2sec50),
    [p. 92](ch05.xhtml#page_92) |'
  prefs: []
  type: TYPE_TB
- en: '| `data.frame` | Create a data frame | [Section 5.2.1](ch05.xhtml#ch05lev2sec52),
    [p. 96](ch05.xhtml#page_96) |'
  prefs: []
  type: TYPE_TB
- en: '| `[ , ]` | Extract data frame row/columns | [Section 5.2.1](ch05.xhtml#ch05lev2sec52),
    [p. 96](ch05.xhtml#page_96) |'
  prefs: []
  type: TYPE_TB
