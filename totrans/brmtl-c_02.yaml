- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Hello World
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Hello World
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'In this chapter, you’ll create and execute your first program, “Hello World.”
    This is about the simplest program you can make and the first program in almost
    all C books. But you’ll go beyond just creating it: you’ll learn what’s actually
    going on behind the scenes during its creation.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将创建并执行第一个程序——“Hello World”。这是几乎所有C语言书籍中最简单的程序，也是你能做的最简单的程序。但你不仅仅是创建它：你将学习在它的创建过程中，幕后究竟发生了什么。
- en: The tools you’ll use are designed to make things quick and easy, which is good
    for regular programming but can be bad for embedded programming. The compiler,
    GCC, is actually a wrapper that runs a whole bunch of other tools. We’ll look
    at what each tool does to get your program from code to execution. In the process,
    you’ll discover that the GCC optimizer has a surprise for us. Although our program
    is very simple, the optimizer will decide to rewrite part of it to make it more
    efficient—*and it won’t tell us about the rewrite!* In fact, we would never know
    about it if we didn’t look under the hood to see what’s going on. (I won’t tell
    you what it will do to us; you’ll have to read the rest of the chapter to find
    that out.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的工具旨在使开发过程快速便捷，这对常规编程有利，但对嵌入式编程可能不太合适。编译器GCC实际上是一个包装器，它运行了许多其他工具。我们将逐一查看每个工具的作用，以便将程序从代码转化为执行。在这个过程中，你会发现GCC的优化器给我们带来了一个惊喜。尽管我们的程序非常简单，但优化器会决定重写其中的一部分，以提高效率——*而且它不会告诉我们重写的内容！*
    事实上，如果我们不查看背后的原理，我们永远也不会知道它在做什么。（我不会告诉你它会对我们做什么；你得继续读下去才能知道。）
- en: Installing GCC
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装GCC
- en: In order to run the program in this chapter, you’ll need to download and install
    the GNU C compiler (GCC) on your system, along with related tools. The instructions
    for doing so vary based on your operating system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本章中运行程序，你需要在系统上下载并安装GNU C编译器（GCC）以及相关工具。具体安装说明根据你的操作系统不同而有所差异。
- en: On Windows, install Minimalist GNU for Windows (MinGW), which can be found at
    [http://www.mingw.org](http://www.mingw.org). See [https://nostarch.com/bare-metal-c](https://nostarch.com/bare-metal-c)
    for detailed instructions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，安装适用于Windows的Minimalist GNU（MinGW），可在[http://www.mingw.org](http://www.mingw.org)找到。详细说明请见[https://nostarch.com/bare-metal-c](https://nostarch.com/bare-metal-c)。
- en: 'On macOS, the GCC compiler is part of the developer packages that can be accessed
    with the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，GCC编译器是开发者包的一部分，可以通过以下命令访问：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select the **Command Line Tools** option for installation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**命令行工具**选项进行安装。
- en: 'Linux installation instructions depend on which distribution you are using.
    For Debian systems such as Ubuntu and Linux Mint, use the following commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux安装说明取决于你使用的发行版。对于Debian系统（如Ubuntu和Linux Mint），使用以下命令：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Red Hat–based systems (such as Fedora or CentOS), use the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Red Hat的系统（如Fedora或CentOS），使用以下命令：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For any other Linux-based system, use the package manager that came with the
    system or search online to find the command needed for installation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他任何基于Linux的系统，请使用随系统附带的软件包管理器，或在线搜索找到安装所需的命令。
- en: After installing the software, open a terminal window and issue the command
    `gcc`. If you get a “no input files” error, you’ve installed successfully.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件后，打开终端窗口并输入命令`gcc`。如果出现“no input files”错误，说明安装成功。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Downloading System Workbench for STM32
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载STM32的System Workbench
- en: System Workbench for STM32 is an IDE we’ll use to write C programs for our embedded
    devices. We won’t use it until Chapter 2, but the download will take some time,
    so I recommend you start it now. By the time you finish reading this chapter,
    the download should be complete.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: System Workbench for STM32是我们将用来为嵌入式设备编写C程序的IDE。我们将在第二章开始使用它，但下载需要一些时间，所以我建议你现在就开始下载。等你读完本章时，下载应该就完成了。
- en: Go to [http://openstm32.org/HomePage](http://openstm32.org/HomePage), locate
    the link for System Workbench for STM32, and click it. Register (it’s free), or
    log in if you have an account, and then follow the links to the installation instructions.
    Install the IDE from the installer and not from Eclipse. When the download starts,
    return here and continue reading.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://openstm32.org/HomePage](http://openstm32.org/HomePage)，找到System Workbench
    for STM32的下载链接并点击它。注册（免费），如果你已有账号，则登录，然后按照链接进入安装说明。通过安装程序而不是Eclipse安装IDE。下载开始后，返回此处继续阅读。
- en: Tools and installation procedures may change over time. If you encounter any
    issues, visit [https://nostarch.com/bare-metal-c](https://nostarch.com/bare-metal-c)
    to check for updated instructions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 工具和安装程序可能会随时间变化。如果遇到任何问题，请访问 [https://nostarch.com/bare-metal-c](https://nostarch.com/bare-metal-c)
    查阅更新的说明。
- en: Our First Program
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个程序
- en: 'Our first program is called *hello.c*. Begin by creating a directory to hold
    this program and jump into it. Navigate to the root directory of your workspace,
    open a command line window, and enter these commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序叫做 *hello.c*。首先创建一个目录来存放这个程序，然后进入该目录。导航到你的工作区根目录，打开命令行窗口，输入以下命令：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using a text editor such as Notepad, Vim, or Gedit, create a file called *hello.c*
    and enter the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本编辑器（如 Notepad、Vim 或 Gedit），创建一个名为 *hello.c* 的文件，并输入以下代码：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ll walk through this program in detail in the following sections. First,
    though, we have to run it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细分析这个程序。但首先，我们需要先运行它。
- en: Compiling the Program
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译程序
- en: The file you just created is known as a *source file*, and it contains code
    in human-readable format. (Yes, really; this is supposed to be human readable.)
    It’s the source of all the other files we are going to produce. The content of
    the file is called *source code*. The computer does not understand source code;
    it only understands *machine code*, a set of instructions in a numeric format.
    So, we need to transform our source code into machine code, a process called *compiling*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建的文件被称为 *源文件*，其中包含人类可读的代码。 (是的，真的是可读的。) 它是我们将要生成的所有其他文件的来源。该文件的内容称为 *源代码*。计算机无法理解源代码；它只能理解
    *机器代码*，一种数字格式的指令集。因此，我们需要将源代码转化为机器代码，这个过程叫做 *编译*。
- en: 'To do this, we execute the following compiler command on macOS or Linux:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们在 macOS 或 Linux 上执行以下编译命令：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On Windows, we execute the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们执行以下命令：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you get no output, just a command prompt, the command was successful. Otherwise,
    you’ll get error messages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有输出，只有命令提示符，那么命令执行成功。否则，你将看到错误信息。
- en: 'This command tells the program *GCC* to *compile* and *link* the program, putting
    the output in a file called *hello* on macOS and Linux or *hello.exe* on Windows.
    We can now run our program using the following command on macOS or Linux:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉程序 *GCC* 去 *编译* 和 *链接* 程序，并将输出放在 macOS 和 Linux 上的 *hello* 文件中，或在 Windows
    上的 *hello.exe* 文件中。现在，我们可以使用以下命令在 macOS 或 Linux 上运行我们的程序：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Windows, run the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，运行以下命令：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Making Mistakes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 犯错
- en: 'Let’s introduce a mistake and see what happens. Change the second line so that
    it looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们故意引入一个错误，看看会发生什么。将第二行改成如下所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let’s try to compile the program:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试编译这个程序：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output tells us that there is a problem in line 2 of the program and that
    the error was discovered at character position 1\. In this case, where the compiler
    was expecting a type, it got something different—namely, the garbage we deliberately
    put in. Fix the program by changing the line back.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们程序第 2 行有问题，错误发生在字符位置 1。此时，编译器原本期望的是一个类型，却得到了不同的东西——也就是我们故意放进去的垃圾。通过将这一行恢复，修复这个程序。
- en: 'Next let’s take something out—specifically, the semicolon on the fourth line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们移除一些东西——特别是第四行的分号：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This gives us a different error message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们带来一个不同的错误信息：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You’ll notice that the compiler pointed to line 5 when issuing the error message.
    That’s because although we made a mistake on line 4, the compiler didn’t detect
    it until it looked at line 5.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，编译器在发出错误信息时指向了第 5 行。这是因为尽管我们在第 4 行犯了错误，但编译器直到查看到第 5 行时才检测到错误。
- en: Sometimes errors on a previous line will not be detected for one or more lines,
    so don’t look just at the line specified by the error; look above it as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时前一行的错误可能不会在一行或多行后被检测到，因此不要只看错误提示指定的行；也要检查它上面的行。
- en: Understanding the Program
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解程序
- en: 'Now let’s go through our program line by line to see what it is doing. Take
    a look at the first line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐行分析程序，看看它在做什么。首先，看看第一行：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In order to build our program, we are using components that come with the compiler—namely,
    the standard input/output (I/O) package. The functions in this package are defined
    in the */usr/include/stdio.h* file. (Windows may use a slightly different directory.)
    Specifically, we use the standard I/O function `printf` later in the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的程序，我们使用了编译器自带的组件——即标准输入/输出（I/O）包。这个包中的函数在*/usr/include/stdio.h*文件中定义。（Windows可能使用稍有不同的目录。）具体来说，我们在程序后面将使用标准I/O函数`printf`。
- en: 'Next, we define the starting point for our program:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义程序的起始点：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The name `main` is special and indicates the main body of the program. All
    programs start at `main`. This is followed by a set of statements enclosed in
    curly brackets:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`这个名字是特殊的，表示程序的主函数。所有程序都从`main`开始。接下来是一组被大括号包围的语句：'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The curly brackets denote the body of `main`. In other words, they’re used to
    group the statements that follow. We indent the statements inside the curly brackets
    by four spaces for readability, but you are free to use other indentation sizes.
    In fact, the C compiler doesn’t care how much whitespace we use. We could have
    used no indentation at all, but no indentation makes the program hard to read,
    so most C programmers indent their code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号表示`main`的主体。换句话说，它们用来将接下来的语句分组。为了提高可读性，我们将大括号内的语句缩进四个空格，但你也可以使用其他缩进方式。实际上，C语言编译器并不在乎我们使用了多少空白字符。我们甚至可以完全不使用缩进，但没有缩进会让程序很难阅读，因此大多数C程序员会对代码进行缩进。
- en: 'Inside the curly brackets is our first executable statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号内是我们第一个可执行语句：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This tells the program to use the standard I/O function `printf` to output a
    string to the standard output location (our terminal). The `\n` is a special character
    in this string. The backslash (`\`) is called the *escape character*. It tells
    C that the following character should be treated as code. In this case, the `n`
    tells C to output a “newline,” which means the next character will be printed
    on a new line. Some of the more common escape characters are shown in [Table 1-1](#table1-1).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉程序使用标准I/O函数`printf`将字符串输出到标准输出位置（我们的终端）。`\n`是这个字符串中的一个特殊字符。反斜杠（`\`）被称为*转义字符*。它告诉C语言接下来的字符应该被当作代码处理。在这种情况下，`n`告诉C语言输出一个“换行符”，这意味着下一个字符将会在新的一行打印。一些常见的转义字符显示在[表1-1](#table1-1)中。
- en: 'Table 1-1: Common Escape Characters'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1：常见的转义字符
- en: '| **Escape character** | **Result** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **转义字符** | **结果** |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\n` | Newline (also known as *line feed*) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行（也叫做*换行符*） |'
- en: '| `\t` | Tab |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |'
- en: '| `\"` | `"` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | `"` |'
- en: '| `\\` | `\` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | `\` |'
- en: '| `\r` | Carriage return |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 |'
- en: 'Finally, the program ends with this statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序以这条语句结束：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This causes the program to stop and exit, returning an exit code of 0 to the
    operating system, which indicates that the program terminated normally. A nonzero
    exit code indicates an error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致程序停止并退出，返回一个退出代码0给操作系统，表示程序正常终止。非零退出代码表示出错。
- en: Adding Comments
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加注释
- en: 'So far we’ve confined ourselves exclusively to writing code. In other words,
    everything we’ve seen is designed to be read by the computer and processed. Programs
    can also contain *comments*, which aren’t seen by the compiler; instead, they’re
    designed to be read by the person viewing the program. Comments commonly begin
    with `/*` and end with `*/`. For example, the following is a comment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直局限于编写代码。换句话说，我们所看到的所有内容都是为了让计算机读取和处理的。程序还可以包含*注释*，这些注释不会被编译器看到；相反，它们是为了被查看程序的人阅读。注释通常以`/*`开始，`*/`结束。例如，下面就是一条注释：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It tells you what the programmer who wrote this thought of the program. Let’s
    put some comments at the beginning of our program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉你写这段程序的程序员是怎么想的。让我们在程序的开头加上一些注释：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another style of comment starts with `//` and goes to the end of the line. As
    you see more programs, you’ll be able to determine for yourself which is better
    to use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种风格的注释以`//`开头，直到行尾结束。当你看到更多的程序时，你会自行判断哪种方式更适合使用。
- en: Always add comments to your code when you write a program, because that’s when
    you know what you are doing. Five minutes later, you might forget. Five days later,
    you *will* forget. For example, I once had to do a complex bitmap transformation
    in order to translate a raster image into a firing command for an inkjet nozzle.
    The transformation involved taking a horizontal raster image, turning the row
    data into column data for the nozzles, and then, since the nozzles were offset,
    shifting the data left to match the nozzle location. I wrote out a page of comments
    describing every factor that affected the firing order. Then I added half a page
    of ASCII art diagramming what I had just described. Only after doing this and
    making sure I understood the problem did I write the code. And because I had to
    organize my thoughts in order to document them, the program worked on the first
    try.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，始终为代码添加注释，因为那时你知道自己在做什么。五分钟后，你可能会忘记。五天后，你*一定*会忘记。例如，我曾经需要做一次复杂的位图转换，将一个光栅图像转换为喷墨喷嘴的喷射命令。这个转换过程涉及将一个横向光栅图像，转化为喷嘴所需的列数据，然后，由于喷嘴有偏移，需要将数据向左移动以匹配喷嘴的位置。我写了一页注释，描述了影响喷射顺序的所有因素。接着，我加了一页半的
    ASCII 艺术，图解我刚刚描述的内容。只有在这样做并确保我理解了问题后，我才开始写代码。而且因为我必须整理思路来记录它们，所以程序第一次就成功了。
- en: When creating the answers to the programming problems presented in this book,
    get in the habit of writing comments. The really good programmers are fanatical
    comment writers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建本书中编程问题的答案时，养成写注释的习惯。真正优秀的程序员都是狂热的注释写作者。
- en: Improving the Program and Build Process
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进程序和构建过程
- en: When it comes to our little “Hello World” program, manually compiling it isn’t
    a problem. But for a program with thousands of modules in it, keeping track of
    what needs to be compiled and what doesn’t can be quite difficult. We need to
    automate the process to be efficient and avoid human error.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的“小小的‘Hello World’程序”，手动编译并不成问题。但对于一个包含数千个模块的程序，跟踪哪些需要编译，哪些不需要编译，会变得相当困难。我们需要自动化这个过程，以提高效率并避免人为错误。
- en: In this section, we’ll tweak our program to improve it and automate the build
    process. Ideally, you should be able to build a program using a single command
    and no parameters, which would indicate you have a consistent and precise build
    process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将调整程序以改进并自动化构建过程。理想情况下，你应该能够通过一个命令和没有任何参数来构建程序，这意味着你有一个一致且精确的构建过程。
- en: The make Program
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`make` 程序'
- en: One problem with our build process is that we have to enter the compilation
    command each time we build the program. This would be tedious for a program with
    several thousand files in it, each of which would need to be compiled. To automate
    the build process, we’ll use the `make` program. It takes as its input a file
    called a makefile, which tells `make` how to build a program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建过程有一个问题，那就是每次构建程序时都需要输入编译命令。对于一个包含数千个文件的程序来说，这将是一个繁琐的工作，每个文件都需要编译。为了自动化构建过程，我们将使用
    `make` 程序。它的输入是一个叫做 makefile 的文件，告诉 `make` 如何构建程序。
- en: 'Create a file called *Makefile* containing the following on macOS or Linux:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 或 Linux 上创建一个名为*Makefile*的文件，内容如下：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On Windows, the makefile should contain the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，makefile 应包含以下内容：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It’s important that the indented lines begin with a tab character. Eight spaces
    won’t work. (Horrible file design, but we’re stuck with it.) The first line defines
    a macro. As a result of this definition, whenever we specify `$(CFLAGS)` in the
    makefile, the `make` program will replace this with `-ggdb -Wall -Wextra`. Next,
    we define the target `all`, which is the default target by convention. When `make`
    is run with no parameters, it tries to build the first one it sees. The definition
    of this target, `all: hello`, tells the `make` program, “When you try to build
    `all`, you need to build `hello`.” The final two lines of the makefile are the
    specification for `hello` (or `hello.exe` on Windows). These tell `make` that
    `hello` is made from *hello.c* by executing the command `gcc $(CFLAGS) -o hello
    hello.c`. This command contains the macro we defined, `$(CFLAGS)`, which expands
    to `-ggdb -Wall -Wextra`. You’ll notice that we added a couple of extra flags
    to our compilation. We’ll discuss those in the next section.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '确保缩进的行以制表符（Tab）开头。八个空格是无效的。（尽管文件设计很糟糕，但我们只能将就。）第一行定义了一个宏。由于这个定义，每当我们在 makefile
    中指定 `$(CFLAGS)` 时，`make` 程序将把它替换为 `-ggdb -Wall -Wextra`。接下来，我们定义了目标 `all`，这是根据约定的默认目标。当没有参数时运行
    `make` 时，它会尝试构建它看到的第一个目标。这个目标的定义 `all: hello` 告诉 `make` 程序：“当你尝试构建 `all` 时，你需要构建
    `hello`。” makefile 的最后两行是针对 `hello`（或者 Windows 上的 `hello.exe`）的说明。这些告诉 `make`，`hello`
    是通过执行命令 `gcc $(CFLAGS) -o hello hello.c` 从 *hello.c* 构建而成的。这个命令包含了我们定义的宏 `$(CFLAGS)`，它展开为
    `-ggdb -Wall -Wextra`。你会注意到，我们为编译添加了几个额外的标志，我们将在下一节讨论这些标志。'
- en: 'Now let’s make the program using the `make` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `make` 命令来构建程序：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, the program ran the commands to build the executable. The `make`
    program is smart. It knows that `hello` is made from *hello.c*, so it will check
    the modification dates of these two files. If`hello` is newer, then it does not
    need to be recompiled, so if you attempt to build the program twice, you’ll get
    the following message:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序运行了构建可执行文件的命令。`make` 程序很聪明。它知道 `hello` 是由 *hello.c* 构建的，因此它会检查这两个文件的修改日期。如果
    `hello` 更新了，就不需要重新编译。因此，如果你尝试两次构建程序，你会看到以下消息：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is not always the correct behavior. If we change the flags in our makefile,
    we’ve changed the compilation process and should rebuild our program. However,
    `make` doesn’t know about this change and won’t rebuild the program unless we
    edit *hello.c* and save the file or delete the output file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是正确的行为。如果我们在 makefile 中更改了标志，那么我们就改变了编译过程，应该重新构建我们的程序。然而，`make` 并不知道这个变化，除非我们编辑并保存
    *hello.c* 文件，或者删除输出文件，否则它不会重新构建程序。
- en: Compiler Flags
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器标志
- en: 'The GCC compiler takes a number of options. In fact, the list of options for
    this compiler exceeds eight pages. Fortunately, we don’t have to worry about them
    all. Let’s take a look at the ones we used for our program:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 编译器有很多选项。实际上，这个编译器的选项列表超过了八页。幸运的是，我们不需要关注所有的选项。我们来看一下我们为程序使用的那些选项：
- en: '`-ggdb` Compiles the program so we can debug it. Mostly, this adds debugging
    information to the output file that allows the debugger to understand what is
    going on.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ggdb` 编译程序以便我们能够调试它。主要是将调试信息添加到输出文件中，允许调试器理解发生了什么。'
- en: '`-Wall` Turns on a set of warnings that will flag correct but questionable
    code. (This book will teach you not to write questionable code.)'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-Wall` 打开一组警告，标记那些正确但值得怀疑的代码。（本书将教你如何避免写出值得怀疑的代码。）'
- en: '`-Wextra` Turns on extra warnings in an effort to make our code more precise.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-Wextra` 打开额外的警告，旨在使我们的代码更加精确。'
- en: '`-o hello` Puts the output of our program in the file *hello*. (This option
    is `-o hello.exe` for Windows users.)'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o hello` 将程序的输出放入文件 *hello* 中。（对于 Windows 用户，这个选项是 `-o hello.exe`。）'
- en: How the Compiler Works Behind the Scenes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器背后的工作原理
- en: 'In order to best make use of the compiler, you need to understand what goes
    on behind the scenes when you run it. That’s because when you’re writing software
    for embedded devices, you’ll often need to circumvent some of the operations the
    compiler performs automatically, which consist of a number of steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地利用编译器，你需要理解在你运行编译器时背后发生了什么。这是因为在你为嵌入式设备编写软件时，你经常需要绕过编译器自动执行的一些操作，这些操作包括几个步骤：
- en: The source code is run through a *preprocessor*, which handles all the lines
    that begin with `#`, called *directives*. In our original source file, this is
    the `#include` statement. Later, you will learn about additional directives.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码会经过一个*预处理器*，它处理所有以`#`开头的行，这些行被称为*指令*。在我们原始的源文件中，这就是`#include`语句。稍后你将学习其他指令。
- en: The compiler proper takes the preprocessed source code and turns it into *assembly
    language* code. C code is supposedly machine-independent and can be compiled and
    run on multiple platforms. Assembly language is machine-dependent and can be run
    on only one type of platform. (Of course, it is still possible to write C code
    that will work on only one machine. C tries to hide the underlying machine from
    you, but it does not prevent you from directly accessing it.)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器本身处理预处理过的源代码，并将其转换成*汇编语言*代码。C语言应该是与机器无关的，可以在多个平台上进行编译和运行。而汇编语言是与机器相关的，只能在一种类型的机器上运行。（当然，也可以编写只能在某台机器上运行的C代码。C语言试图将底层机器隐藏起来，但并不阻止你直接访问它。）
- en: The assembly language file is passed through an *assembler*,which turns it into
    an *object file*. The object file contains just our code. However, the program
    needs additional code to work. In our case, the object file for *hello.c* needs
    a copy of the `printf` function.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编语言文件会传递给*汇编器*，它将其转换成*目标文件*。目标文件仅包含我们的代码。然而，程序需要额外的代码才能工作。在我们的例子中，*hello.c*的目标文件需要包含`printf`函数的副本。
- en: The *linker* takes the object code in the object file and combines (links) it
    with useful code already present on your computer. In this case, it’s `printf`
    and all the code needed to support it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*链接器*将目标文件中的目标代码与计算机上已有的有用代码结合（链接）起来。在这个例子中，它是`printf`以及所有支持它的代码。'
- en: '[Figure 1-1](#figure1-1) illustrates the process. All these steps are hidden
    from you by the `gcc` command.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](#figure1-1)展示了这个过程。所有这些步骤都被`gcc`命令隐藏起来。'
- en: '![f01001](image_fi/501621c01/f01001.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](image_fi/501621c01/f01001.png)'
- en: 'Figure 1-1: The steps needed to produce a program'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：生成程序所需的步骤
- en: You’ll notice that the `gcc` command is acting as both compiler and linker.
    In fact, `gcc` is designed as a sort of executive program. It looks at the arguments
    and decides which other programs it needs to run in order to do its job. This
    might include the preprocessor (`cpp`), the C compiler (`cc1`), the assembler
    (`as`), the linker (`ld`), or other programs as needed. Let’s walk through these
    components in more detail.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，`gcc`命令既充当编译器，也充当链接器。实际上，`gcc`被设计成一种执行程序。它查看参数，并决定需要运行哪些其他程序来完成它的工作。这可能包括预处理器（`cpp`）、C编译器（`cc1`）、汇编器（`as`）、链接器（`ld`）或根据需要的其他程序。让我们更详细地了解这些组件。
- en: The Preprocessor
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预处理器
- en: 'The first program run is the preprocessor, which is a *macro processor* (a
    type of automatic text editor) that handles all the lines that begin with `#`.
    In our program, it processes the `#include` line. We can get the output of the
    preprocessor with this command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个运行的程序是预处理器，它是一个*宏处理器*（一种自动文本编辑器），用于处理所有以`#`开头的行。在我们的程序中，它处理`#include`这一行。我们可以通过以下命令获得预处理器的输出：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output of this command is stored in the *hello.i* file. If we look at this
    file, we see that it’s more than 850 lines long. That’s because the `#include
    <stdio.h>` line causes the entire *stdio.h* file to be copied into our program,
    and because the *stdio.h* file has its own `#include` directives, the files included
    by *stdio.h* get copied in as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出被存储在*hello.i*文件中。如果我们查看这个文件，我们会看到它超过850行。这是因为`#include <stdio.h>`这一行导致整个*stdio.h*文件被复制进我们的程序，并且由于*stdio.h*文件中有自己的`#include`指令，所以*stdio.h*所包含的文件也会被复制进来。
- en: 'We needed *stdio.h* for the `printf` function, and if we look through *hello.i*,
    we find the definition of this function, which is now included in our program:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要*stdio.h*来使用`printf`函数，如果查看*hello.i*，我们可以找到该函数的定义，它现在已经被包含进我们的程序中：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preprocessor also removes all the comments and annotates the text with information
    indicating what file is being processed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器还会移除所有注释，并在文本中注释上正在处理的是哪个文件的信息。
- en: The Compiler
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器
- en: 'Next, the compiler turns the C language code into assembly language. We can
    see what’s generated with this command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编译器将C语言代码转换成汇编语言。我们可以通过以下命令查看生成的内容：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should produce a file that starts with the following lines:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个以以下行开始的文件：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the compiler translated the C string `"Hello World!\n"` to the assembly
    language `.string` command. If you have sharp eyes, you’ll also notice that the
    `\n` is missing. We’ll discover why a little later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译器将 C 字符串 `"Hello World!\n"` 转换为汇编语言中的 `.string` 命令。如果你眼尖的话，你还会注意到 `\n`
    缺失了。稍后我们将揭晓原因。
- en: The Assembler
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇编器
- en: 'The assembly language file goes into the assembler, where it is translated
    into machine code. The `gcc` command has an option (`-Wa`) that lets us pass flags
    to the assembler. Since it’s impossible to understand the machine code unless
    you’re a machine, we will use the following command to ask for an assembly language
    listing that prints the machine code in human-readable format, with the corresponding
    assembly language statements that generated that code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言文件进入汇编器，在那里它被转换成机器代码。`gcc` 命令有一个选项（`-Wa`），让我们可以将标志传递给汇编器。因为除非你是机器，否则无法理解机器代码，所以我们将使用以下命令请求一个汇编语言列表，以人类可读的格式打印机器代码，并显示生成该代码的对应汇编语言语句：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `-Wa` option tells GCC that what follows is to be passed to the assembler.
    The `-a=hello.lst` option tells the assembler to produce a listing called *hello.lst*.
    Let’s take a look at that file. It begins as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Wa` 选项告诉 GCC 后面的内容将传递给汇编器。`-a=hello.lst` 选项告诉汇编器生成一个名为 *hello.lst* 的列表。我们来看一下那个文件，它的开头如下：'
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Assembly language differs on each machine. In this file, you’re looking at x86
    assembly language. It might seem like a confused mess, even in comparison to other
    assembly languages. You probably won’t understand it completely, and that’s okay;
    this chapter should only give you a sense of what assembly language looks like.
    In later chapters, when we get to the ARM processor, you’ll see a much saner and
    easier-to-understand assembly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言在不同机器上有所不同。在这个文件中，你看到的是 x86 汇编语言。与其他汇编语言相比，它可能看起来像一团乱麻。你可能不会完全理解它，这没关系；本章只是让你对汇编语言有一个初步的了解。之后的章节中，当我们讨论
    ARM 处理器时，你会看到更加理智且易于理解的汇编语言。
- en: The first column is a line number from the assembly language file. The second
    column, if present, indicates the address of the data being stored. All computer
    memory slots have a numerical address. In this case, the string `"Hello World!"`
    is being stored at address 0000 relative to the section that is currently being
    used (in this case, a section titled `.rodata`). When we discuss the linker in
    the next section, we’ll see how this relative address is translated into an absolute
    one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是汇编语言文件中的行号。第二列（如果存在）表示存储数据的地址。所有计算机内存插槽都有一个数字地址。在这种情况下，字符串 `"Hello World!"`
    被存储在相对于当前使用的部分（在此例中为 `.rodata` 部分）地址 0000 处。当我们在下一部分讨论链接器时，我们将看到如何将这个相对地址转换为绝对地址。
- en: The next column contains the numerical values to be stored in memory in hexadecimal
    format. Then comes the text of the assembly language code itself. In the file,
    we can see that the `.string` directive tells the assembler to generate the codes
    for a text string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列包含以十六进制格式存储在内存中的数值。接下来是汇编语言代码本身。在文件中，我们可以看到 `.string` 指令告诉汇编器生成文本字符串的代码。
- en: 'Later in the file, we find the code for `main`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的后面，我们找到了 `main` 的代码：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: On line 15, we can see the assembly language instruction `55`, which will be
    stored at location 0 in this section. This instruction corresponds to `pushq %rbp`,
    which does some bookkeeping at the start of the procedure. Also notice that some
    machine instructions are 1 byte long and others as long as 5 bytes. The instruction
    at line 21 is an example of a 5-byte instruction. You can see that this instruction
    is doing something with `.LC0`. If we look at the top of our listing, we see that
    `.LC0` is our string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 15 行，我们可以看到汇编语言指令 `55`，它将被存储在该部分的地址 0 位置。此指令对应 `pushq %rbp`，它在程序开始时做了一些账务处理。同样注意到，一些机器指令只有
    1 字节长，而其他指令则长达 5 字节。第 21 行的指令就是一个 5 字节的指令。你可以看到这条指令正在处理 `.LC0`。如果我们查看列表的顶部，会看到
    `.LC0` 是我们的字符串。
- en: As a C programmer, you’re not expected to fully understand what the assembly
    language does. Complete understanding would require absorbing several thousand
    pages of reference material. But we can, sort of, understand the instruction at
    line 22, which calls the function `puts`. This is where things get interesting.
    Remember that our C program didn’t call `puts`—it called `printf`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems that our code has been optimized behind the scenes. In embedded programming,
    “optimized” can be a dirty word, so it’s important to understand what happened
    here. Essentially, the C compiler looked at the line `printf("Hello World!\n");`
    and decided it was identical to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The truth is that these functions aren’t actually identical: `puts` is a simple,
    efficient function, whereas `printf` is a large, complex one. But the programmer
    isn’t using any of the advanced `printf` features, so the optimizer decided to
    rewrite the code to make it better. As a result, our `printf` call became `puts`
    and the end-of-line character (`\n`) was removed from the string, as the `puts`
    call adds one automatically. When you get especially close to the hardware, little
    things like this can make a big difference, so it’s important to know how to view
    and sort of understand assembly code.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The output of the assembler is an object file containing the code we wrote and
    nothing more. In particular, it does not contain the `puts` function, which we
    need. The `puts` function resides, along with hundreds of other functions, in
    the C standard library (*libc*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The Linker
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our object file and some of the components of *libc* need to be combined to
    make our program. The linker’s job is to take the files needed to make up the
    program, combine them, and assign real memory addresses to each component. As
    we did with the assembler, we can tell the `gcc` command to pass flags to the
    linker using this command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `-Wl` tells GCC to pass the option that follows (`-Map=hello.map`) to the
    linker. The map tells us where the linker put things in memory. (More on this
    later.) We’ve also added the directive `-static`, which changes the executable
    from dynamic to statically linked so that the memory map will look more like what
    we will see with our embedded systems. That way, we can avoid having to discuss
    the complexities of dynamic linking.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Object files such as *hello.o* are relocatable. That is, they can go anywhere
    in memory. It is the job of the linker to decide exactly where in memory they
    go. It is also the linker’s job to go through the libraries used by the program,
    extract any needed object files, and include them in the final program. The linker
    map tells us where things went and what library components were included in our
    program. For example, a typical linker entry might look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember that we didn’t write `puts`, even though it appears in this linker
    entry. As mentioned, it came from the standard C library file (*libc.a*). We can
    see here that the code for this function is located at `0x000000000040fa90`. This
    information could be useful if, say, our program crashed somewhere between `0x40fa90`
    and `0x40fc58`. In that case, we would know that `puts` caused the crash.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We also know that `puts` takes up `0x1c8` bytes (`40fc58–40fa90`). This is 456
    decimal bytes, or a little under .5K. The amount of memory will concern us when
    we start programming our microprocessor, which has limited memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a good idea of every element of a C program and what these
    various pieces do. Most of the time, you can let the compiler take care of these
    details without worrying about what’s going on under the hood. But when you’re
    programming small chips with limited resources, you do need to worry about what’s
    going on inside.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Adding to Your Makefile
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explore the various aspects of the GCC compiler, assembler, and linker on your
    own by amending your makefile to generate all the files described in the previous
    section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As described earlier, the first non-blank line defines a macro that tells `make`
    to replace `$(CFLAGS)` with `-Wall -Wextra -ggdb` everywhere in the rest of the
    file. Next, we define a *target* (an item that needs to be built) named `all`.
    Since this is the first target in the file, it is also the default one, which
    means you can build it simply by entering the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This target is what we call a *phony target*, as it doesn’t result in a file
    named *all*. Instead, every time you execute the `make all` command, `make` will
    check whether it needs to re-create its dependencies. You can see these dependencies
    listed in the makefile after the keyword `all` and the colon. In order to make
    the target `all`, we need to make the targets `hello`, `hello.i`, and `hello.s`.
    The following lines clarify how to make those targets. For example, to make the
    target `hello.i`, we must use the target `hello.c`. If `hello.i` is newer than
    `hello.c`, then `make` will do nothing. If `hello.c` has undergone recent changes
    and `hello.i` is not up to date, `make` will produce `hello.i` using the following
    command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Thus, if you edit `hello.c` and then execute the command `make hello.i`, you’ll
    see `make` do its job:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another target in our makefile, `clean`, removes all the generated files. To
    get rid of the generated files, execute the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: GNU `make` is a very sophisticated program with a manual that is more than 300
    pages long. The good news is you need to deal with only a very small subset of
    its commands in order to be productive.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making a “Hello World” program is one of the simplest things a C programmer
    can do. However, understanding everything that happens behind the scenes to create
    and run that C program is a bit more difficult. Luckily, you don’t have to be
    an expert. But while you don’t need to master every bit of the assembly language
    generated by the program, any embedded programmer should understand enough to
    be able to spot potential problems or unusual behavior, such as `puts` showing
    up in a program that calls `printf`. Paying attention to these details will allow
    us to get the most out of our small machines.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个“Hello World”程序是 C 程序员能做的最简单的事情之一。然而，理解创建和运行这个 C 程序背后发生的一切要复杂一些。幸运的是，你不必成为专家。但尽管你不需要精通程序生成的每一条汇编语言，任何嵌入式程序员都应该理解足够的内容，能够发现潜在的问题或异常行为，比如
    `puts` 出现在调用 `printf` 的程序中。关注这些细节将帮助我们最大限度地利用我们的嵌入式设备。
- en: Questions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Where does the documentation for GNU `make` reside?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GNU `make` 的文档在哪里？
- en: Is C code portable between different types of machines?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C 代码在不同类型的机器之间是可移植的吗？
- en: Is assembly language code portable between different types of machines?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编语言代码在不同类型的机器之间是可移植的吗？
- en: Why does a single statement in assembly language code generate just one machine
    instruction when one statement in C can generate many?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么汇编语言中的一条语句只生成一条机器指令，而 C 语言中的一条语句可能生成多条指令？
