- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 20 MANAGING CLASSES AND NAMESPACES WITH COMPOSER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As your PHP projects grow larger and more complex, you increasingly run the
    risk of encountering a *naming collision*, or having two classes with the same
    name. In this chapter, you’ll learn about *namespaces*, the solution provided
    by object-oriented languages to avoid naming collisions. In addition, you’ll learn
    to use the helpful Composer command line tool, which automates the process of
    loading class- and function-declaration files and simplifies work with namespaces.
    Almost every modern object-oriented PHP project uses Composer, and we’ll use it
    throughout the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that a naming collision would be unlikely; after all, up until
    now we’ve been writing class declarations in PHP files with the same name as the
    class, and we’ve been placing these class declaration files in the project’s *src*
    directory. Since PHP doesn’t allow two files with the same name in the same directory,
    surely we couldn’t end up with two classes of the same name?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, naming collisions can occur in several cases. First, you might try
    to declare a class with the same name as one of the built-in classes of the PHP
    language, such as Error, Directory, or Generator. Second, you might declare two
    classes in different directories (for example, different subdirectories of *src*).
    Third, you might combine your own classes with classes from third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Namespaces* can be thought of as a virtual hierarchy of directories for classes,
    used to prevent class name collisions. Classes are organized within namespaces
    and sub-namespaces, much as computer files are organized within directories and
    subdirectories. Just as you need to state the directory location of a computer
    file on a hard disk, using namespaced classes requires you to specify both the
    name of the class and its namespace to uniquely identify a particular class.'
  prefs: []
  type: TYPE_NORMAL
- en: A backslash character (\) separates namespaces, sub-namespaces (if any), and
    the class name. For example, \MyNamespace\MySubNamespace\MyClass refers to a class
    called MyClass in the sub-namespace MySubNamespace, which is part of the larger
    MyNamespace namespace. Identifying MyClass with a namespace and sub-namespace
    prevents it from colliding with another MyClass class in a different namespace,
    such as \YourNamespace\MyClass. By convention, the first letter of a namespace
    or sub-namespace is capitalized, just like class names. Other letters in the namespace
    or sub-namespace can be capitalized as well.
  prefs: []
  type: TYPE_NORMAL
- en: Classes that are built into the PHP language are considered to be in the *root
    namespace*, which is identified with just a single backslash character. For example,
    you can write \DateTime or \Exception to explicitly refer to PHP’s built-in DateTime
    or Exception classes. So far in this book, we’ve been omitting the backslash before
    built-in class names, since we haven’t been using namespaces when writing our
    own classes. Including the backslash makes it unambiguous that we’re referring
    to a PHP class in the root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples that follow, I’ll use the namespace Mattsmithdev. It’s the namespace
    I use for all the classes I write, along with a sub-namespace for each project
    I work on. You may want to make up your own namespace, such as Supercoder or DublinDevelopers,
    and use it when following these chapters and writing your own classes. We’ll also
    encounter other namespaces in “Adding Third-Party Libraries to a Project” on [page
    390](#pg_390).
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class’s Namespace
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To declare the namespace of a class, use the namespace keyword followed by the
    namespace’s name. This should be the first line of PHP code in the class-declaration
    file. To demonstrate, we’ll declare a class called Shirt and make it part of the
    Mattsmithdev namespace. Start a new project, create a file called *src/Shirt.php*,
    and enter the code from [Listing 20-1](#lis20-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-1: The Shirt class in the Mattsmithdev namespace'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately after the opening PHP tag, we use namespace Mattsmithdev to make
    the class we’re about to declare part of the Mattsmithdev namespace. We follow
    the namespace statement with two blank lines, which is recommended by the PHP
    coding standards. Then we proceed with the class declaration as usual. In this
    case, the Shirt class has a private type property with a default value of 't-shirt',
    as well as public getter and setter methods for this property.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Namespaced Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once a class is declared to be within a namespace, you need to unambiguously
    inform the PHP engine that it’s the class you want to use. You can do this in
    two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first option is to always include the namespace when referencing the class;
    this is called using the *fully qualified name* of the class. For example, to
    create a new Shirt object, you would write new \Mattsmithdev\Shirt(). Let’s try
    that now. Add a *public/index.php* file to your project and enter the code from
    [Listing 20-2](#lis20-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-2: Creating objects of the \Mattsmithdev\Shirt class in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the class-declaration file, we create two objects of the Shirt
    class, using the class’s fully qualified name. Run the project at the command
    line with php public/index.php and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The message indicates that a Shirt object has been successfully created via
    the class’s fully qualified name.
  prefs: []
  type: TYPE_NORMAL
- en: The second way to unambiguously reference a class from a particular namespace
    is to include a use statement before invoking the class. For example, use Mattsmithdev\Shirt
    tells the PHP engine that any subsequent references to the Shirt class are specifically
    to the one in the Mattsmithdev namespace. To see how use statements work, update
    your *public/index.php* file to match [Listing 20-3](#lis20-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-3: Referencing the Shirt class with a use statement in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We include a use statement after reading in the class declaration to ensure
    that Shirt later in the code will refer to Mattsmithdev\Shirt. Notice that we
    don’t include a backslash before the namespace in a use statement. This kind of
    class identifier, without the initial backslash, is called a *qualified name*,
    as opposed to a *fully qualified name* that includes the initial backslash. We
    then create the two Shirt objects simply with new Shirt(), since the PHP engine
    knows which class we’re referencing, thanks to the use statement. Run the index
    script again and you should see that the output hasn’t changed. We’ve still successfully
    created some Shirt objects.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to differentiate between two classes with the same name but different
    namespaces in the same section of code, you can either refer to both with their
    fully qualified names (for example, \Mattsmithdev\Shirt and \OtherNamespace\Shirt)
    or provide a use statement for one of the classes and qualify the other.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Namespaces in Class Declarations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you’re writing code in the class-declaration file for a namespaced class
    (as opposed to in a general script like *index.php*) and you want to refer to
    a class from a different namespace. If you haven’t written a use statement, you
    must use the fully qualified name of the other class, starting with a backslash.
    For example, if you were writing code for a class declared in the Mattsmithdev
    namespace and you wanted to refer to PHP’s built-in DateTime class, you’d have
    to write it as \DateTime to indicate that it’s part of the root namespace. Likewise,
    if you wanted to refer to a third-party class, you’d write a backslash, then the
    third-party namespace, then another backslash, and then the class name, such as
    \MathPHP\Algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Without the initial backslash, PHP will assume you’re referring to a class or
    sub-namespace of the current namespace. For example, in a class in the Mattsmithdev
    namespace, a reference to DateTime() without an initial backslash is assumed to
    be a reference to Mattsmithdev\DateTime, meaning a DateTime class in the Mattsmithdev
    namespace. Similarly, a reference to MathPHP\Algebra without an initial backslash
    is assumed to be a reference to Mattsmithdev\MathPHP\Algebra, meaning MathPHP
    is assumed to be a sub-namespace of Mattsmithdev and Algebra is assumed to be
    a class in that sub-namespace. Writing a fully qualified namespace beginning with
    the backslash ensures that the PHP engine will understand the namespace of the
    class you’re referencing.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you *are* referring to a class or sub-namespace of the
    current namespace, you shouldn’t include a backslash before the class or sub-namespace.
    For example, if you’re working on a class in the Mattsmithdev namespace, Shirt()
    is understood to refer to the Shirt class in the Mattsmithdev namespace, and SubNamespace\Example
    is understood to refer to the class Mattsmithdev\SubNamespace\Example.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a class from another namespace only once, it might make sense
    to just write the class’s fully qualified name, including the initial backslash.
    If you’ll need to refer to the class several times, however, writing a use statement
    for it at the beginning of the class declaration is more efficient. In this case,
    no initial backslash is needed. As you look at and write more PHP code, you’ll
    often see many use statements at the beginning of a class declaration when the
    code uses classes declared in other namespaces, as illustrated in [Listing 20-4](#lis20-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-4: A class declaration with many use statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet is the start of a class declaration from one of my PHP Symfony
    web framework chess projects. It has a whopping 11 use statements, drawing on
    classes from a variety of namespaces and sub-namespaces. The use statements help
    keep them all straight, but if juggling all those classes still seems overwhelming,
    don’t worry: we’re about to discuss a tool for managing all the classes in a project.'
  prefs: []
  type: TYPE_NORMAL
- en: Composer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composer is a command line tool to support object-oriented PHP programming.
    It helps with loading class and function declaration files (your own and those
    from third-party libraries), and it facilitates working with classes from different
    namespaces. It’s an essential, easy-to-use tool for professional web application
    projects. In this section, you’ll set up Composer and learn how to use it to create
    command line aliases, load class-declaration files automatically, and manage a
    project’s third-party dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*SymfonyCasts has a great free video introducing the Composer tool at* [https://symfonycasts.com/screencast/composer](https://symfonycasts.com/screencast/composer)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Testing Composer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Windows, Composer offers a simple installer that can be found at *[https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe)*.
    For macOS, you can install Composer with Homebrew, as discussed in [Appendix A](appendix-a.xhtml).
    For Linux, you need to execute several command line statements to download and
    run the *composer.php* script. You can find details at *[https://getcomposer.org/download/](https://getcomposer.org/download/)*.
    If you’re using Replit to follow along with this book, see [Appendix C](appendix-c.xhtml)
    for how to integrate Composer into your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed Composer, test it by opening a new command line terminal
    application and entering composer. This launches the Composer tool, bringing up
    a nice ASCII art logo, the version number, and a list of the command line options.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the composer.json Configuration File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use the Composer command line tool with a project, you need to create a *composer.json*
    file to house all the information Composer needs to know about the project. (See
    the following “JSON File Format” box for a refresher on this type of file.) For
    example, the *composer.json* file features records of the namespaces and class
    locations for your own code, as well as of the third-party packages that the project
    depends on. In addition, you can declare command line *aliases* in the *composer.json*
    file, shortcuts that can save you from typing long commands at the command line.
    We’ll begin our exploration of the *composer.json* file by declaring a simple
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: The *composer.json* text file must be located at the top level of your PHP project
    directory, not inside a subfolder like *src* or *public*. Continuing with this
    chapter’s project, create *composer.json*, save it at the top level of the project
    directory, and then enter the contents of [Listing 20-5](#lis20-5). This code
    creates an alias called hello that will stand in for the command echo Hello World.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-5: Declaring an alias in the composer.json file'
  prefs: []
  type: TYPE_NORMAL
- en: The content of *composer.json* is always a JSON object and so will always begin
    and end with a pair of curly brackets. Inside the object, we declare a "scripts"
    property with a value that itself is an object. Within the sub-object, we declare
    a property named "hello" (the name of our alias) with a value of "echo Hello,
    world!" (the code that will be replaced by the shortcut alias).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a simple but valid *composer.json* file telling Composer that there’s
    a command line alias named "hello". To see whether this has worked, enter composer
    hello at the terminal. You should see Hello, world! as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we’ve written more characters to declare the alias than we would
    need to write out the echo statement in full at the command line. However, sometimes
    these script aliases can be handy. For example, here’s an alias I use in some
    projects to output a report of how much code in the */src* folder needs fixing
    to match the PHP programming standards (although the alias appears on two lines
    here for space reasons, it would be all one line in the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This alias lets me enter composer reportfixsrc at the command line rather than
    a long PHP command to run a PHP Archive (*.phar*) file with lots of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll soon see, Composer can do a lot more than just keep track of command
    line aliases. For now, we’ve successfully created the *composer.json* file for
    our project, an essential first step in using this powerful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Autoloader
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *autoloader* is a system that automatically retrieves class-declaration files
    whenever they’re needed, so you don’t have to load them all into an *index.php*
    file yourself. Autoloaders become useful as object-oriented PHP projects grow
    in size and complexity, involving many classes in many namespaces. If you had
    to write require_once statements for each class in your *index.php* front controller,
    not only would it be a lot of work, but it would also be easy to miss one or two,
    particularly as the project continues to evolve. This would lead to errors and
    would force you to keep going back to update the list of files to require. An
    autoloader handles the process for you, provided the classes are correctly namespaced
    and correctly located according to the autoloading rules.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful features of the Composer tool is its autoloader. It
    conforms to PSR-4, PHP’s recommended set of rules for autoloading. According to
    PSR-4, you must specify the base directory containing the classes of each namespace.
    For example, you may want to declare that classes in the Mattsmithdev namespace
    can be found in the *src* directory. Further, PSR-4 stipulates that any sub-namespaces
    will be assumed to have corresponding subdirectories within the declared base
    directory of the namespace. For example, the class Mattsmithdev\Trigonometry\Angles.php
    should be located in *src/Trigonometry*, the class Mattsmithdev\Utility\Security.php
    should be located in *src/Utility*, and so on. As long as the subdirectory has
    the same name as the sub-namespace, you don’t need to tell the autoloader where
    to find the sub-namespaced classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the Composer autoloader to work requires three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.   Declare the base directory for each namespace in the project’s *composer
    .json* file.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Tell Composer to create or update its autoloader script.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Add a require_once statement for the autoloader script at the beginning
    of the project’s *public/index.php* front controller. This single require_once
    statement replaces the separate require_once statements for each individual class.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through the process of setting up the Composer autoloader to load
    our Mattsmithdev\Shirt class. First, [Listing 20-6](#lis20-6) shows what to write
    in the *composer.json* file to declare that classes in the Mattsmithdev namespace
    can be found in the *src* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-6: Setting up the autoloader in the composer.json file'
  prefs: []
  type: TYPE_NORMAL
- en: We declare an "autoload" property, whose value is an object. Within that object,
    we declare the "psr-4" property, whose value is another object. It contains a
    "Mattsmithdev\\" property whose value is "src". This tells Composer that class
    files in the Mattsmithdev namespace are located in the *src* directory. Notice
    the two backslash characters (\\) after the namespace. This is a requirement of
    the PSR-4.
  prefs: []
  type: TYPE_NORMAL
- en: For the projects we’ll work on in the next few chapters, the *composer.json*
    files will be essentially the same as [Listing 20-6](#lis20-6). The only potential
    difference from project to project will be the actual namespace(s) and location(s)
    declared within the "psr-4" object.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Composer autoloader has some additional subtleties. If you want to learn
    more, consult the Composer documentation at* [https://getcomposer.org/doc/04-schema.md#psr-4](https://getcomposer.org/doc/04-schema.md#psr-4)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve declared the base directory for the Mattsmithdev namespace in
    the *composer.json* file, we can tell Composer to generate a class autoloader
    for us. Enter the following at the command line for the current project’s working
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new folder in the project called *vendor*, if it doesn’t
    exist already, and generates or updates several files within that folder. This
    *vendor* folder is where Composer keeps its working files for the project. You
    can look inside it, but you shouldn’t change its contents. You can also delete
    the folder and ask Composer to rebuild it anytime, so you can safely omit this
    folder whenever you back up a project.
  prefs: []
  type: TYPE_NORMAL
- en: Inside *vendor*, you should see a *vendor/autoload.php* file as well as a *vendor/composer*
    folder containing several more scripts, including *autoload_psr4.php*, which encodes
    our PSR-4-compliant declaration. This file contains statements to return the location
    (*src/*) of classes in the Mattsmithdev namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve generated the autoloader, we can update the *public/index.php*
    script to require just this one *autoload.php* file, no matter how many classes
    we need to refer to in our project. As long as the base directories for the namespaces
    have been declared in the *composer.json* file and the autoloader has been updated
    with the composer dump-autoload command, then whenever we write a use statement
    for a namespaced class, the PHP engine will load its declaration, ready for our
    code. [Listing 20-7](#lis20-7) shows how to update *index.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-7: Reading the Composer-generated autoloader script into index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We change the require_once statement to read in and execute the Composer-generated
    autoloader script from the *vendor* directory. When you run the project, the output
    will be just as before, but now we’re using the Composer autoloader to automatically
    read in the declaration for the Mattsmithdev\Shirt class from the *src* folder,
    instead of reading it in manually. While this may not seem to make much of a difference
    for our one-class project, the autoloader is a big time-saver for projects with
    many classes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Third-Party Libraries to a Project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another powerful feature of Composer is its capability to add third-party libraries
    to a project and maintain a record of these dependencies in the *composer.json*
    file. Thousands of open source libraries are available, many kept up-to-date by
    multiple experienced software developers; in many cases, a few minutes of searching
    can offer up a ready-made library that does all or most of what you want. Well-maintained
    open source projects have been tested thoroughly and refactored to implement best
    practices, so careful use of third-party libraries can reduce your workload while
    helping to maintain the quality of a software project.
  prefs: []
  type: TYPE_NORMAL
- en: Without Composer’s package-dependency features, you’d have to download the code
    for third-party libraries from websites or Git repositories, copy it to an appropriate
    location such as a *lib* folder, and update the *composer.json* file with the
    namespaces and locations of these library classes. Instead, you can simply tell
    Composer that you need a third-party library in your project, and it will do all
    the hard work for you. It will automatically download the code, create and copy
    the files to an appropriate subdirectory in *vendor*, update the autoloader, and
    record the dependency (and its version) in the *composer.json* file. All you need
    to know is the name of the package you want and the vendor supplying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, we’ll tell Composer to add the math-php package from
    the vendor markrogoyski to our chapter project. This is a great package offering
    many useful mathematics operations. At the command line for the current project’s
    working directory, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This require command triggers Composer to perform a series of actions. First,
    if you check your project’s *vendor* folder, you should see that Composer has
    created a new subfolder matching the package’s vendor name (in this case, *vendor/markrogoyski*).
    Inside, you’ll find a folder for the math-php package, containing all the necessary
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the vendor name (markrogoyski) and package name (math-php)
    are *not* namespaces. They’re simply names that Composer uses to identify and
    locate the third-party scripts to be added to the project. Composer will automatically
    determine the namespaces for all the open source library classes, and so the contents
    of *vendor/composer* will be updated for all these classes that have been added
    to the *vendor* folder. In particular, *autoload_psr4.php* will likely be updated
    with the base directory for the namespaced third-party classes, since most open
    source libraries use the PSR-4 autoloading standard. Meanwhile, you’ll need to
    read the package’s documentation to find out the namespaces of the third-party
    classes so you can reference them correctly in your code.
  prefs: []
  type: TYPE_NORMAL
- en: The require command also prompts Composer to update the *composer .json* file
    with information about the markrogoyski/math-php package. If you check the file,
    you should now see something like [Listing 20-8](#lis20-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-8: The composer.json file’s record of the math-php library dependency'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the "autoload" property we wrote earlier, the main object in
    *composer.json* now has a "require" property that Composer automatically generated.
    Its value is an object with entries for all the packages required for the project.
    In this case, there’s an entry of "markrogoyski/math-php". Its value, "^2.10",
    indicates the acceptable versions of the package. The caret symbol (^) means we’re
    happy to use newer versions with the same main version number (2.10.1, 2.11, 2.2,
    and so on) but not version 3.*x* or later, since that might break backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Now that Composer has integrated the markrogoyski/math-php package into our
    project, we can try using it. Specifically, we’ll draw on the package’s Average
    class to compute the average of a series of numbers. Update the contents of *public/index.php*
    with the code in [Listing 20-9](#lis20-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 20-9: Calculating the average of an array of integers'
  prefs: []
  type: TYPE_NORMAL
- en: We start with a use statement telling the PHP engine that Average refers to
    the namespaced class MathPHP\Statistics\Average. Notice that the namespace for
    this class is different from the vendor and package name we used earlier in the
    require statement to Composer. Then we declare a $numbers array and use the built-in
    implode() function to create a string version of it for user-friendly output.
    Next, we invoke the mean() method from the Average class, storing the result in
    $mean. We then print out the list of numbers and the calculated mean value.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve invoked the mean() method without actually having to create
    an object of the Average class. This is because mean() is a *static method*. We’ll
    explore this OOP concept in detail in [Chapter 25](chapter25.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Where to Find PHP Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be wondering how the Composer tool knew where to go on the internet
    to download the markrogoyski/math-php package files for our project. The answer
    is Packagist (*[https://packagist.org](https://packagist.org)*), a website for
    publishing open source PHP packages. Vendors can register with the site (I’m mattsmithdev
    on Packagist, for example) and then publish PHP packages for anyone to install
    via Composer.
  prefs: []
  type: TYPE_NORMAL
- en: When publishing a package, the vendor must provide information including the
    GitHub (or other repository) location of the package’s publicly downloadable files.
    For example, the Packagist page for the markrogoyski/math-php package lists a
    GitHub address of *[https://github.com/markrogoyski/math-php](https://github.com/markrogoyski/math-php)*.
    This is where Composer goes to get the package files. Each page on Packagist also
    lists the exact require command you need in order to make Composer add that package
    to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned to unambiguously differentiate between classes
    of the same name by using namespaces. You also learned to use the powerful Composer
    command line tool to support object-oriented PHP programming. The time spent learning
    how to maintain the *composer.json* file and how to use Composer to autoload classes
    and incorporate third-party libraries into your projects will save you countless
    hours of tedious manual work.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Start a new project and create a Composer script alias for a command to
    display the message Hello name, replacing name with your name. Then use Composer
    to execute your command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Declare a script alias in *composer.json*, then run it at the command
    line with composer alias.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Start a new project and create a *src/Product.php* file declaring a Product
    class with the private properties $id, $description, and $price, and public getters
    and setters for each property. Declare the class to be in the Mattsmithdev namespace.
    Add a *composer.json* file to the root folder of your project, declaring that
    classes in the Mattsmithdev namespace can be found in the *src* directory. Then
    use Composer to generate an autoloader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a *public/index.php* file that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Reads in and executes the Composer autoloader in *vendor/ autoload.php*
  prefs: []
  type: TYPE_NORMAL
- en: b.   Creates a new Product object, $p1, with an id of 7, a description of 'hammer',
    and a price of 9.99
  prefs: []
  type: TYPE_NORMAL
- en: c.   Uses var_dump() to output the details of $p1
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run your code, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 3.   Go to the Packagist website at *[https://packagist.org](https://packagist.org)*
    and search for the mattsmithdev/faker-small-english package. Look at the documentation,
    then use Composer to require the mattsmithdev/faker-small-english package for
    a new project. Write a *public/index.php* file that loops 10 times to display
    10 random names from a FakerSmallEnglish object.
  prefs: []
  type: TYPE_NORMAL
