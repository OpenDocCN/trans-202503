- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 20 MANAGING CLASSES AND NAMESPACES WITH COMPOSER
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20 使用 Composer 管理类和命名空间
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: As your PHP projects grow larger and more complex, you increasingly run the
    risk of encountering a *naming collision*, or having two classes with the same
    name. In this chapter, you’ll learn about *namespaces*, the solution provided
    by object-oriented languages to avoid naming collisions. In addition, you’ll learn
    to use the helpful Composer command line tool, which automates the process of
    loading class- and function-declaration files and simplifies work with namespaces.
    Almost every modern object-oriented PHP project uses Composer, and we’ll use it
    throughout the remainder of the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的 PHP 项目变得越来越大且复杂，你越来越有可能遇到 *命名冲突* 的问题，或者出现两个同名的类。在本章中，你将了解 *命名空间*，这是一种面向对象语言提供的解决方案，用于避免命名冲突。此外，你还将学习如何使用有用的
    Composer 命令行工具，它能够自动加载类和函数声明文件，并简化与命名空间的工作。几乎每个现代的面向对象 PHP 项目都会使用 Composer，我们将在本书的其余部分中使用它。
- en: You might think that a naming collision would be unlikely; after all, up until
    now we’ve been writing class declarations in PHP files with the same name as the
    class, and we’ve been placing these class declaration files in the project’s *src*
    directory. Since PHP doesn’t allow two files with the same name in the same directory,
    surely we couldn’t end up with two classes of the same name?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为命名冲突不太可能发生；毕竟，直到现在，我们一直在 PHP 文件中编写与类名相同的类声明，并将这些类声明文件放置在项目的 *src* 目录中。由于
    PHP 不允许在同一目录中有两个同名的文件，难道我们不会遇到两个同名的类吗？
- en: In fact, naming collisions can occur in several cases. First, you might try
    to declare a class with the same name as one of the built-in classes of the PHP
    language, such as Error, Directory, or Generator. Second, you might declare two
    classes in different directories (for example, different subdirectories of *src*).
    Third, you might combine your own classes with classes from third-party libraries.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，命名冲突可能在几种情况下发生。首先，你可能会尝试声明一个与 PHP 语言的内置类同名的类，例如 Error、Directory 或 Generator。其次，你可能会在不同的目录中声明两个同名的类（例如，在
    *src* 的不同子目录中）。第三，你可能会将自己的类与第三方库的类混合在一起。
- en: Namespaces
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: '*Namespaces* can be thought of as a virtual hierarchy of directories for classes,
    used to prevent class name collisions. Classes are organized within namespaces
    and sub-namespaces, much as computer files are organized within directories and
    subdirectories. Just as you need to state the directory location of a computer
    file on a hard disk, using namespaced classes requires you to specify both the
    name of the class and its namespace to uniquely identify a particular class.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间* 可以看作是一个虚拟的目录层级结构，用于存放类，以避免类名冲突。类被组织在命名空间和子命名空间中，就像计算机文件被组织在目录和子目录中一样。就像你需要指定计算机文件在硬盘上的目录位置一样，使用命名空间的类也需要同时指定类名和命名空间，以唯一标识某个类。'
- en: A backslash character (\) separates namespaces, sub-namespaces (if any), and
    the class name. For example, \MyNamespace\MySubNamespace\MyClass refers to a class
    called MyClass in the sub-namespace MySubNamespace, which is part of the larger
    MyNamespace namespace. Identifying MyClass with a namespace and sub-namespace
    prevents it from colliding with another MyClass class in a different namespace,
    such as \YourNamespace\MyClass. By convention, the first letter of a namespace
    or sub-namespace is capitalized, just like class names. Other letters in the namespace
    or sub-namespace can be capitalized as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠字符（\）用于分隔命名空间、子命名空间（如果有的话）和类名。例如，\MyNamespace\MySubNamespace\MyClass 指的是一个名为
    MyClass 的类，它位于 MySubNamespace 子命名空间中，而 MySubNamespace 是更大命名空间 MyNamespace 的一部分。通过命名空间和子命名空间来标识
    MyClass，可以避免与其他命名空间中名为 MyClass 的类发生冲突，例如 \YourNamespace\MyClass。根据约定，命名空间或子命名空间的首字母大写，类似于类名。命名空间或子命名空间中的其他字母也可以大写。
- en: Classes that are built into the PHP language are considered to be in the *root
    namespace*, which is identified with just a single backslash character. For example,
    you can write \DateTime or \Exception to explicitly refer to PHP’s built-in DateTime
    or Exception classes. So far in this book, we’ve been omitting the backslash before
    built-in class names, since we haven’t been using namespaces when writing our
    own classes. Including the backslash makes it unambiguous that we’re referring
    to a PHP class in the root namespace.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 语言内建的类被认为是位于*根命名空间*，它只由一个反斜杠字符标识。例如，你可以写 \DateTime 或 \Exception 来明确引用 PHP
    内建的 DateTime 或 Exception 类。在本书至今的章节中，我们省略了内建类名称前的反斜杠，因为我们在编写自己的类时并未使用命名空间。包含反斜杠使得我们明确表示是在引用根命名空间中的
    PHP 类。
- en: In the examples that follow, I’ll use the namespace Mattsmithdev. It’s the namespace
    I use for all the classes I write, along with a sub-namespace for each project
    I work on. You may want to make up your own namespace, such as Supercoder or DublinDevelopers,
    and use it when following these chapters and writing your own classes. We’ll also
    encounter other namespaces in “Adding Third-Party Libraries to a Project” on [page
    390](#pg_390).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我将使用 Mattsmithdev 命名空间。这是我为我编写的所有类所使用的命名空间，每个我工作过的项目都有一个子命名空间。你可能想为自己创建一个命名空间，例如
    Supercoder 或 DublinDevelopers，并在跟随本书的章节时使用它并编写自己的类。我们还将在“将第三方库添加到项目中”一章中遇到其他命名空间，见
    [第 390 页](#pg_390)。
- en: Declaring a Class’s Namespace
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明类的命名空间
- en: To declare the namespace of a class, use the namespace keyword followed by the
    namespace’s name. This should be the first line of PHP code in the class-declaration
    file. To demonstrate, we’ll declare a class called Shirt and make it part of the
    Mattsmithdev namespace. Start a new project, create a file called *src/Shirt.php*,
    and enter the code from [Listing 20-1](#lis20-1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明类的命名空间，使用 namespace 关键字后跟命名空间的名称。这应该是类声明文件中的第一行 PHP 代码。为了演示，我们将声明一个名为 Shirt
    的类，并将其归属于 Mattsmithdev 命名空间。开始一个新项目，创建一个名为 *src/Shirt.php* 的文件，并输入 [列表 20-1](#lis20-1)
    中的代码。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 20-1: The Shirt class in the Mattsmithdev namespace'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20-1：Mattsmithdev 命名空间中的 Shirt 类
- en: Immediately after the opening PHP tag, we use namespace Mattsmithdev to make
    the class we’re about to declare part of the Mattsmithdev namespace. We follow
    the namespace statement with two blank lines, which is recommended by the PHP
    coding standards. Then we proceed with the class declaration as usual. In this
    case, the Shirt class has a private type property with a default value of 't-shirt',
    as well as public getter and setter methods for this property.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 标签的开头，我们使用 namespace Mattsmithdev 来将我们接下来要声明的类包含到 Mattsmithdev 命名空间中。我们在命名空间声明后加上两行空白行，这是
    PHP 编码规范推荐的做法。然后，我们照常进行类声明。在这个例子中，Shirt 类有一个名为 type 的私有属性，默认值为 't-shirt'，并且有该属性的公共
    getter 和 setter 方法。
- en: Using a Namespaced Class
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用命名空间类
- en: Once a class is declared to be within a namespace, you need to unambiguously
    inform the PHP engine that it’s the class you want to use. You can do this in
    two ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类声明属于一个命名空间，你需要明确告诉 PHP 引擎这是你想要使用的类。你可以通过两种方式来做到这一点。
- en: The first option is to always include the namespace when referencing the class;
    this is called using the *fully qualified name* of the class. For example, to
    create a new Shirt object, you would write new \Mattsmithdev\Shirt(). Let’s try
    that now. Add a *public/index.php* file to your project and enter the code from
    [Listing 20-2](#lis20-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是始终在引用类时包含命名空间；这被称为使用类的*完全限定名称*。例如，要创建一个新的 Shirt 对象，你可以写 new \Mattsmithdev\Shirt()。现在让我们尝试一下。将
    *public/index.php* 文件添加到你的项目中，并输入 [列表 20-2](#lis20-2) 中的代码。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 20-2: Creating objects of the \Mattsmithdev\Shirt class in index.php'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20-2：在 index.php 中创建 \Mattsmithdev\Shirt 类的对象
- en: 'After reading in the class-declaration file, we create two objects of the Shirt
    class, using the class’s fully qualified name. Run the project at the command
    line with php public/index.php and you should see the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取类声明文件之后，我们创建了两个 Shirt 类的对象，使用该类的完全限定名称。通过命令行运行项目，使用 php public/index.php，你应该看到以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The message indicates that a Shirt object has been successfully created via
    the class’s fully qualified name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 消息指示通过类的完全限定名称成功创建了一个 Shirt 对象。
- en: The second way to unambiguously reference a class from a particular namespace
    is to include a use statement before invoking the class. For example, use Mattsmithdev\Shirt
    tells the PHP engine that any subsequent references to the Shirt class are specifically
    to the one in the Mattsmithdev namespace. To see how use statements work, update
    your *public/index.php* file to match [Listing 20-3](#lis20-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 引用特定命名空间中的类的第二种方式是，在调用类之前包含一个`use`语句。例如，`use Mattsmithdev\Shirt` 告诉 PHP 引擎，任何后续对
    Shirt 类的引用都是专门指向 Mattsmithdev 命名空间中的那个类。要查看 `use` 语句如何工作，请更新你的*public/index.php*
    文件以匹配 [Listing 20-3](#lis20-3)。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 20-3: Referencing the Shirt class with a use statement in index.php'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 20-3: 在 index.php 中使用 `use` 语句引用 Shirt 类'
- en: We include a use statement after reading in the class declaration to ensure
    that Shirt later in the code will refer to Mattsmithdev\Shirt. Notice that we
    don’t include a backslash before the namespace in a use statement. This kind of
    class identifier, without the initial backslash, is called a *qualified name*,
    as opposed to a *fully qualified name* that includes the initial backslash. We
    then create the two Shirt objects simply with new Shirt(), since the PHP engine
    knows which class we’re referencing, thanks to the use statement. Run the index
    script again and you should see that the output hasn’t changed. We’ve still successfully
    created some Shirt objects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在读取类声明后包含一个 `use` 语句，以确保代码中后续的 Shirt 引用指向 Mattsmithdev\Shirt。请注意，在 `use` 语句中我们不包括命名空间前的反斜杠。这种类标识符，没有初始反斜杠，称为*限定名*，与包含初始反斜杠的*完全限定名*相对。然后我们可以简单地使用
    `new Shirt()` 来创建两个 Shirt 对象，因为得益于 `use` 语句，PHP 引擎知道我们正在引用哪个类。重新运行 index 脚本，你应该会看到输出没有变化。我们仍然成功地创建了一些
    Shirt 对象。
- en: If you need to differentiate between two classes with the same name but different
    namespaces in the same section of code, you can either refer to both with their
    fully qualified names (for example, \Mattsmithdev\Shirt and \OtherNamespace\Shirt)
    or provide a use statement for one of the classes and qualify the other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在同一段代码中区分两个同名但属于不同命名空间的类，你可以通过它们的完全限定名来引用它们（例如，\Mattsmithdev\Shirt 和 \OtherNamespace\Shirt），或者为其中一个类提供
    `use` 语句，并对另一个类进行限定。
- en: Referencing Namespaces in Class Declarations
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在类声明中引用命名空间
- en: Say you’re writing code in the class-declaration file for a namespaced class
    (as opposed to in a general script like *index.php*) and you want to refer to
    a class from a different namespace. If you haven’t written a use statement, you
    must use the fully qualified name of the other class, starting with a backslash.
    For example, if you were writing code for a class declared in the Mattsmithdev
    namespace and you wanted to refer to PHP’s built-in DateTime class, you’d have
    to write it as \DateTime to indicate that it’s part of the root namespace. Likewise,
    if you wanted to refer to a third-party class, you’d write a backslash, then the
    third-party namespace, then another backslash, and then the class name, such as
    \MathPHP\Algebra.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为一个命名空间类编写类声明文件（而不是像*index.php* 这样的通用脚本），并且你想引用来自其他命名空间的类。如果你没有写 `use`
    语句，你必须使用另一个类的完全限定名，从反斜杠开始。例如，如果你正在为一个在 Mattsmithdev 命名空间中声明的类编写代码，并且你想引用 PHP 内置的
    DateTime 类，你必须写成 `\DateTime` 来表明它属于根命名空间。同样，如果你想引用一个第三方类，你需要写一个反斜杠，然后是第三方命名空间，再一个反斜杠，最后是类名，例如
    `\MathPHP\Algebra`。
- en: Without the initial backslash, PHP will assume you’re referring to a class or
    sub-namespace of the current namespace. For example, in a class in the Mattsmithdev
    namespace, a reference to DateTime() without an initial backslash is assumed to
    be a reference to Mattsmithdev\DateTime, meaning a DateTime class in the Mattsmithdev
    namespace. Similarly, a reference to MathPHP\Algebra without an initial backslash
    is assumed to be a reference to Mattsmithdev\MathPHP\Algebra, meaning MathPHP
    is assumed to be a sub-namespace of Mattsmithdev and Algebra is assumed to be
    a class in that sub-namespace. Writing a fully qualified namespace beginning with
    the backslash ensures that the PHP engine will understand the namespace of the
    class you’re referencing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you *are* referring to a class or sub-namespace of the
    current namespace, you shouldn’t include a backslash before the class or sub-namespace.
    For example, if you’re working on a class in the Mattsmithdev namespace, Shirt()
    is understood to refer to the Shirt class in the Mattsmithdev namespace, and SubNamespace\Example
    is understood to refer to the class Mattsmithdev\SubNamespace\Example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a class from another namespace only once, it might make sense
    to just write the class’s fully qualified name, including the initial backslash.
    If you’ll need to refer to the class several times, however, writing a use statement
    for it at the beginning of the class declaration is more efficient. In this case,
    no initial backslash is needed. As you look at and write more PHP code, you’ll
    often see many use statements at the beginning of a class declaration when the
    code uses classes declared in other namespaces, as illustrated in [Listing 20-4](#lis20-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 20-4: A class declaration with many use statements'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet is the start of a class declaration from one of my PHP Symfony
    web framework chess projects. It has a whopping 11 use statements, drawing on
    classes from a variety of namespaces and sub-namespaces. The use statements help
    keep them all straight, but if juggling all those classes still seems overwhelming,
    don’t worry: we’re about to discuss a tool for managing all the classes in a project.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Composer
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composer is a command line tool to support object-oriented PHP programming.
    It helps with loading class and function declaration files (your own and those
    from third-party libraries), and it facilitates working with classes from different
    namespaces. It’s an essential, easy-to-use tool for professional web application
    projects. In this section, you’ll set up Composer and learn how to use it to create
    command line aliases, load class-declaration files automatically, and manage a
    project’s third-party dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*SymfonyCasts has a great free video introducing the Composer tool at* [https://symfonycasts.com/screencast/composer](https://symfonycasts.com/screencast/composer)*.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Testing Composer
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Windows, Composer offers a simple installer that can be found at *[https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe)*.
    For macOS, you can install Composer with Homebrew, as discussed in [Appendix A](appendix-a.xhtml).
    For Linux, you need to execute several command line statements to download and
    run the *composer.php* script. You can find details at *[https://getcomposer.org/download/](https://getcomposer.org/download/)*.
    If you’re using Replit to follow along with this book, see [Appendix C](appendix-c.xhtml)
    for how to integrate Composer into your projects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，Composer 提供了一个简单的安装程序，可以在 *[https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe)*
    上找到。对于 macOS，你可以使用 Homebrew 安装 Composer，如 [附录 A](appendix-a.xhtml) 中所述。对于 Linux，你需要执行几个命令行语句来下载并运行
    *composer.php* 脚本。你可以在 *[https://getcomposer.org/download/](https://getcomposer.org/download/)*
    上找到详细信息。如果你使用 Replit 跟随本书内容，请参见 [附录 C](appendix-c.xhtml)，了解如何将 Composer 集成到你的项目中。
- en: Once you’ve installed Composer, test it by opening a new command line terminal
    application and entering composer. This launches the Composer tool, bringing up
    a nice ASCII art logo, the version number, and a list of the command line options.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Composer 后，通过打开一个新的命令行终端应用程序并输入 composer 来测试它。这将启动 Composer 工具，显示一个漂亮的 ASCII
    艺术标志、版本号以及命令行选项的列表。
- en: Creating the composer.json Configuration File
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 composer.json 配置文件
- en: To use the Composer command line tool with a project, you need to create a *composer.json*
    file to house all the information Composer needs to know about the project. (See
    the following “JSON File Format” box for a refresher on this type of file.) For
    example, the *composer.json* file features records of the namespaces and class
    locations for your own code, as well as of the third-party packages that the project
    depends on. In addition, you can declare command line *aliases* in the *composer.json*
    file, shortcuts that can save you from typing long commands at the command line.
    We’ll begin our exploration of the *composer.json* file by declaring a simple
    alias.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中使用 Composer 命令行工具，你需要创建一个 *composer.json* 文件，用于存放 Composer 所需的所有项目信息。（关于这种文件格式的回顾，请参见下面的“JSON
    文件格式”框。）例如，*composer.json* 文件记录了你自己代码的命名空间和类的位置，以及项目所依赖的第三方包。此外，你还可以在 *composer.json*
    文件中声明命令行 *别名*，这些快捷方式可以避免你在命令行输入冗长的命令。我们将从声明一个简单的别名开始探索 *composer.json* 文件。
- en: The *composer.json* text file must be located at the top level of your PHP project
    directory, not inside a subfolder like *src* or *public*. Continuing with this
    chapter’s project, create *composer.json*, save it at the top level of the project
    directory, and then enter the contents of [Listing 20-5](#lis20-5). This code
    creates an alias called hello that will stand in for the command echo Hello World.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*composer.json* 文本文件必须位于 PHP 项目目录的顶层，而不是像 *src* 或 *public* 这样的子文件夹内。继续本章的项目，创建
    *composer.json* 文件，将其保存在项目目录的顶层，然后输入 [Listing 20-5](#lis20-5) 中的内容。该代码创建了一个名为
    hello 的别名，用于代替命令 `echo Hello World`。'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 20-5: Declaring an alias in the composer.json file'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 20-5: 在 composer.json 文件中声明一个别名'
- en: The content of *composer.json* is always a JSON object and so will always begin
    and end with a pair of curly brackets. Inside the object, we declare a "scripts"
    property with a value that itself is an object. Within the sub-object, we declare
    a property named "hello" (the name of our alias) with a value of "echo Hello,
    world!" (the code that will be replaced by the shortcut alias).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*composer.json* 的内容始终是一个 JSON 对象，因此它总是以一对大括号开始和结束。在对象内部，我们声明了一个名为 "scripts"
    的属性，其值本身是一个对象。在该子对象中，我们声明了一个名为 "hello"（即我们的别名）的属性，值为 "echo Hello, world!"（将被快捷方式别名替换的代码）。'
- en: 'We now have a simple but valid *composer.json* file telling Composer that there’s
    a command line alias named "hello". To see whether this has worked, enter composer
    hello at the terminal. You should see Hello, world! as a result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个简单但有效的 *composer.json* 文件，告诉 Composer 有一个名为 "hello" 的命令行别名。要查看是否有效，请在终端输入
    composer hello。你应该看到 "Hello, world!" 作为结果：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, we’ve written more characters to declare the alias than we would
    need to write out the echo statement in full at the command line. However, sometimes
    these script aliases can be handy. For example, here’s an alias I use in some
    projects to output a report of how much code in the */src* folder needs fixing
    to match the PHP programming standards (although the alias appears on two lines
    here for space reasons, it would be all one line in the file):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们写了更多的字符来声明别名，比在命令行中完整地写出 echo 语句还要多。然而，有时候这些脚本别名是很有用的。例如，下面是我在一些项目中使用的一个别名，用来输出报告，显示
    *src* 文件夹中有多少代码需要修复，以符合 PHP 编程标准（尽管由于空间原因，别名在这里显示为两行，但在文件中会是单行）：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This alias lets me enter composer reportfixsrc at the command line rather than
    a long PHP command to run a PHP Archive (*.phar*) file with lots of parameters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个别名让我在命令行输入 composer reportfixsrc，而不是输入一个长的 PHP 命令来运行一个带有多个参数的 PHP 归档（*.phar*）文件。
- en: As you’ll soon see, Composer can do a lot more than just keep track of command
    line aliases. For now, we’ve successfully created the *composer.json* file for
    our project, an essential first step in using this powerful tool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快会看到的，Composer 能做的不仅仅是跟踪命令行别名。目前，我们已经成功为我们的项目创建了 *composer.json* 文件，这是使用这个强大工具的必要第一步。
- en: Creating an Autoloader
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建自动加载器
- en: An *autoloader* is a system that automatically retrieves class-declaration files
    whenever they’re needed, so you don’t have to load them all into an *index.php*
    file yourself. Autoloaders become useful as object-oriented PHP projects grow
    in size and complexity, involving many classes in many namespaces. If you had
    to write require_once statements for each class in your *index.php* front controller,
    not only would it be a lot of work, but it would also be easy to miss one or two,
    particularly as the project continues to evolve. This would lead to errors and
    would force you to keep going back to update the list of files to require. An
    autoloader handles the process for you, provided the classes are correctly namespaced
    and correctly located according to the autoloading rules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动加载器* 是一种系统，它会在需要时自动获取类声明文件，这样你就不需要自己将它们都加载到 *index.php* 文件中。随着面向对象 PHP 项目的规模和复杂性不断增长，涉及许多命名空间中的类，自动加载器变得非常有用。如果你必须在
    *index.php* 前端控制器中为每个类写 require_once 语句，不仅会非常繁琐，而且很容易漏掉一个或两个，特别是当项目不断发展时。这会导致错误，并迫使你不断返回更新需要加载的文件列表。而自动加载器会为你处理这个过程，只要类是正确命名空间并按照自动加载规则正确定位的。'
- en: One of the most powerful features of the Composer tool is its autoloader. It
    conforms to PSR-4, PHP’s recommended set of rules for autoloading. According to
    PSR-4, you must specify the base directory containing the classes of each namespace.
    For example, you may want to declare that classes in the Mattsmithdev namespace
    can be found in the *src* directory. Further, PSR-4 stipulates that any sub-namespaces
    will be assumed to have corresponding subdirectories within the declared base
    directory of the namespace. For example, the class Mattsmithdev\Trigonometry\Angles.php
    should be located in *src/Trigonometry*, the class Mattsmithdev\Utility\Security.php
    should be located in *src/Utility*, and so on. As long as the subdirectory has
    the same name as the sub-namespace, you don’t need to tell the autoloader where
    to find the sub-namespaced classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 工具最强大的功能之一就是其自动加载器。它符合 PSR-4，这是 PHP 推荐的自动加载规则集。根据 PSR-4，你必须指定包含每个命名空间类的基础目录。例如，你可能想声明
    Mattsmithdev 命名空间中的类可以在*src*目录中找到。此外，PSR-4 规定，任何子命名空间将被认为在声明的命名空间基础目录中有相应的子目录。例如，类
    Mattsmithdev\Trigonometry\Angles.php 应位于 *src/Trigonometry* 目录下，类 Mattsmithdev\Utility\Security.php
    应位于 *src/Utility* 目录下，依此类推。只要子目录的名称与子命名空间相同，你就不需要告诉自动加载器去哪里找到这些子命名空间的类。
- en: 'Getting the Composer autoloader to work requires three steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Composer 的自动加载器工作，需要三个步骤：
- en: 1.   Declare the base directory for each namespace in the project’s *composer
    .json* file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   在项目的 *composer.json* 文件中声明每个命名空间的基础目录。
- en: 2.   Tell Composer to create or update its autoloader script.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   告诉 Composer 创建或更新其自动加载器脚本。
- en: 3.   Add a require_once statement for the autoloader script at the beginning
    of the project’s *public/index.php* front controller. This single require_once
    statement replaces the separate require_once statements for each individual class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   在项目的 *public/index.php* 前端控制器的开头添加一个 require_once 语句来引入自动加载器脚本。这个单一的 require_once
    语句替代了为每个单独类所写的多个 require_once 语句。
- en: We’ll walk through the process of setting up the Composer autoloader to load
    our Mattsmithdev\Shirt class. First, [Listing 20-6](#lis20-6) shows what to write
    in the *composer.json* file to declare that classes in the Mattsmithdev namespace
    can be found in the *src* directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何设置 Composer 自动加载器以加载我们的 Mattsmithdev\Shirt 类。首先，[列表 20-6](#lis20-6)展示了在
    *composer.json* 文件中需要写入的内容，用于声明 Mattsmithdev 命名空间中的类可以在 *src* 目录中找到。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 20-6: Setting up the autoloader in the composer.json file'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20-6：在 composer.json 文件中设置自动加载器
- en: We declare an "autoload" property, whose value is an object. Within that object,
    we declare the "psr-4" property, whose value is another object. It contains a
    "Mattsmithdev\\" property whose value is "src". This tells Composer that class
    files in the Mattsmithdev namespace are located in the *src* directory. Notice
    the two backslash characters (\\) after the namespace. This is a requirement of
    the PSR-4.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个“autoload”属性，它的值是一个对象。在这个对象中，我们声明“psr-4”属性，它的值是另一个对象。它包含一个“Mattsmithdev\\"
    属性，值为 "src"。这告诉 Composer，Mattsmithdev 命名空间中的类文件位于 *src* 目录中。注意命名空间后面的两个反斜杠字符 (\\)。这是
    PSR-4 的要求。
- en: For the projects we’ll work on in the next few chapters, the *composer.json*
    files will be essentially the same as [Listing 20-6](#lis20-6). The only potential
    difference from project to project will be the actual namespace(s) and location(s)
    declared within the "psr-4" object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在接下来的章节中将要处理的项目，*composer.json* 文件将基本与 [列表 20-6](#lis20-6) 相同。每个项目之间唯一可能的不同是“psr-4”对象中声明的实际命名空间和位置。
- en: NOTE
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Composer autoloader has some additional subtleties. If you want to learn
    more, consult the Composer documentation at* [https://getcomposer.org/doc/04-schema.md#psr-4](https://getcomposer.org/doc/04-schema.md#psr-4)*.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Composer 自动加载器有一些额外的细节。如果你想了解更多，请参考 Composer 文档* [https://getcomposer.org/doc/04-schema.md#psr-4](https://getcomposer.org/doc/04-schema.md#psr-4)*。*'
- en: 'Now that we’ve declared the base directory for the Mattsmithdev namespace in
    the *composer.json* file, we can tell Composer to generate a class autoloader
    for us. Enter the following at the command line for the current project’s working
    directory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 *composer.json* 文件中声明了 Mattsmithdev 命名空间的基础目录，我们可以告诉 Composer 为我们生成类的自动加载器。在当前项目的工作目录下输入以下命令：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command creates a new folder in the project called *vendor*, if it doesn’t
    exist already, and generates or updates several files within that folder. This
    *vendor* folder is where Composer keeps its working files for the project. You
    can look inside it, but you shouldn’t change its contents. You can also delete
    the folder and ask Composer to rebuild it anytime, so you can safely omit this
    folder whenever you back up a project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在项目中创建一个名为 *vendor* 的新文件夹（如果它还不存在的话），并在该文件夹内生成或更新多个文件。这个 *vendor* 文件夹是 Composer
    用来存储项目工作文件的地方。你可以查看其内容，但不应更改其中的内容。你也可以随时删除这个文件夹并让 Composer 重新生成它，所以在备份项目时可以安全地省略这个文件夹。
- en: Inside *vendor*, you should see a *vendor/autoload.php* file as well as a *vendor/composer*
    folder containing several more scripts, including *autoload_psr4.php*, which encodes
    our PSR-4-compliant declaration. This file contains statements to return the location
    (*src/*) of classes in the Mattsmithdev namespace.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *vendor* 目录中，你应该能看到一个 *vendor/autoload.php* 文件，以及一个包含多个脚本的 *vendor/composer*
    文件夹，其中包括 *autoload_psr4.php*，它编码了我们的 PSR-4 合规声明。这个文件包含返回 Mattsmithdev 命名空间类的位置（*src/*）的语句。
- en: Now that we’ve generated the autoloader, we can update the *public/index.php*
    script to require just this one *autoload.php* file, no matter how many classes
    we need to refer to in our project. As long as the base directories for the namespaces
    have been declared in the *composer.json* file and the autoloader has been updated
    with the composer dump-autoload command, then whenever we write a use statement
    for a namespaced class, the PHP engine will load its declaration, ready for our
    code. [Listing 20-7](#lis20-7) shows how to update *index.php*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了自动加载器，我们可以更新 *public/index.php* 脚本，仅引用这个 *autoload.php* 文件，无论我们在项目中需要引用多少个类。只要在
    *composer.json* 文件中声明了命名空间的基础目录，并且通过 composer dump-autoload 命令更新了自动加载器，那么每当我们编写命名空间类的
    use 语句时，PHP 引擎将加载其声明，准备供我们的代码使用。[列表 20-7](#lis20-7) 展示了如何更新 *index.php*。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 20-7: Reading the Composer-generated autoloader script into index.php'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20-7：将 Composer 生成的自动加载脚本加载到 index.php 中
- en: We change the require_once statement to read in and execute the Composer-generated
    autoloader script from the *vendor* directory. When you run the project, the output
    will be just as before, but now we’re using the Composer autoloader to automatically
    read in the declaration for the Mattsmithdev\Shirt class from the *src* folder,
    instead of reading it in manually. While this may not seem to make much of a difference
    for our one-class project, the autoloader is a big time-saver for projects with
    many classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `require_once` 语句更改为从 *vendor* 目录中读取并执行 Composer 生成的自动加载器脚本。当你运行项目时，输出将与之前一样，但现在我们使用
    Composer 自动加载器来自动读取 *src* 文件夹中 Mattsmithdev\Shirt 类的声明，而不是手动读取它。虽然对于我们这个单类项目来说，似乎差别不大，但对于包含多个类的项目，自动加载器可以节省大量时间。
- en: Adding Third-Party Libraries to a Project
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将第三方库添加到项目中
- en: Another powerful feature of Composer is its capability to add third-party libraries
    to a project and maintain a record of these dependencies in the *composer.json*
    file. Thousands of open source libraries are available, many kept up-to-date by
    multiple experienced software developers; in many cases, a few minutes of searching
    can offer up a ready-made library that does all or most of what you want. Well-maintained
    open source projects have been tested thoroughly and refactored to implement best
    practices, so careful use of third-party libraries can reduce your workload while
    helping to maintain the quality of a software project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 另一个强大的功能是能够将第三方库添加到项目中，并在 *composer.json* 文件中维护这些依赖关系的记录。成千上万的开源库可供使用，许多由经验丰富的软件开发者保持最新；在许多情况下，几分钟的搜索就能找到一个现成的库，能够完成你所需要的全部或大部分功能。维护良好的开源项目经过了充分的测试，并进行了重构以实现最佳实践，因此，合理使用第三方库可以减少你的工作量，同时帮助保持软件项目的质量。
- en: Without Composer’s package-dependency features, you’d have to download the code
    for third-party libraries from websites or Git repositories, copy it to an appropriate
    location such as a *lib* folder, and update the *composer.json* file with the
    namespaces and locations of these library classes. Instead, you can simply tell
    Composer that you need a third-party library in your project, and it will do all
    the hard work for you. It will automatically download the code, create and copy
    the files to an appropriate subdirectory in *vendor*, update the autoloader, and
    record the dependency (and its version) in the *composer.json* file. All you need
    to know is the name of the package you want and the vendor supplying it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 Composer 的包依赖功能，你需要从网站或 Git 仓库下载第三方库的代码，将其复制到适当的位置，比如 *lib* 文件夹，并更新 *composer.json*
    文件，记录这些库类的命名空间和位置。相反，你只需告诉 Composer 你需要在项目中使用某个第三方库，它将为你完成所有繁重的工作。它会自动下载代码，将文件创建并复制到
    *vendor* 下的适当子目录中，更新自动加载器，并在 *composer.json* 文件中记录依赖关系（及其版本）。你只需要知道你需要的包名和供应商。
- en: 'To see how this works, we’ll tell Composer to add the math-php package from
    the vendor markrogoyski to our chapter project. This is a great package offering
    many useful mathematics operations. At the command line for the current project’s
    working directory, enter the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这如何工作，我们将告诉 Composer 将来自供应商 markrogoyski 的 math-php 包添加到我们的章节项目中。这是一个提供许多有用数学运算的优秀包。在当前项目工作目录的命令行中，输入以下内容：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This require command triggers Composer to perform a series of actions. First,
    if you check your project’s *vendor* folder, you should see that Composer has
    created a new subfolder matching the package’s vendor name (in this case, *vendor/markrogoyski*).
    Inside, you’ll find a folder for the math-php package, containing all the necessary
    code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `require` 命令触发了 Composer 执行一系列操作。首先，如果你检查项目的 *vendor* 文件夹，你应该会看到 Composer
    创建了一个新的子文件夹，名称与包的供应商名称匹配（在这个例子中是 *vendor/markrogoyski*）。在里面，你会找到一个 math-php 包的文件夹，包含所有必要的代码。
- en: Keep in mind that the vendor name (markrogoyski) and package name (math-php)
    are *not* namespaces. They’re simply names that Composer uses to identify and
    locate the third-party scripts to be added to the project. Composer will automatically
    determine the namespaces for all the open source library classes, and so the contents
    of *vendor/composer* will be updated for all these classes that have been added
    to the *vendor* folder. In particular, *autoload_psr4.php* will likely be updated
    with the base directory for the namespaced third-party classes, since most open
    source libraries use the PSR-4 autoloading standard. Meanwhile, you’ll need to
    read the package’s documentation to find out the namespaces of the third-party
    classes so you can reference them correctly in your code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，供应商名称（markrogoyski）和包名称（math-php）*不是*命名空间。它们只是 Composer 用来标识和定位要添加到项目中的第三方脚本的名称。Composer
    会自动确定所有开源库类的命名空间，因此 *vendor/composer* 的内容会更新，包含所有已添加到 *vendor* 文件夹中的这些类。特别地，*autoload_psr4.php*
    很可能会更新为命名空间第三方类的基本目录，因为大多数开源库使用 PSR-4 自动加载标准。同时，你需要阅读包的文档，了解第三方类的命名空间，以便在代码中正确引用它们。
- en: The require command also prompts Composer to update the *composer .json* file
    with information about the markrogoyski/math-php package. If you check the file,
    you should now see something like [Listing 20-8](#lis20-8).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 命令还会提示 Composer 更新 *composer.json* 文件，添加有关 markrogoyski/math-php
    包的信息。如果你查看该文件，现在应该能看到类似于[清单 20-8](#lis20-8)的内容。'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 20-8: The composer.json file’s record of the math-php library dependency'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 20-8：composer.json 文件中记录的 math-php 库依赖
- en: In addition to the "autoload" property we wrote earlier, the main object in
    *composer.json* now has a "require" property that Composer automatically generated.
    Its value is an object with entries for all the packages required for the project.
    In this case, there’s an entry of "markrogoyski/math-php". Its value, "^2.10",
    indicates the acceptable versions of the package. The caret symbol (^) means we’re
    happy to use newer versions with the same main version number (2.10.1, 2.11, 2.2,
    and so on) but not version 3.*x* or later, since that might break backward compatibility.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前写的 "autoload" 属性外，*composer.json* 中的主对象现在还有一个 "require" 属性，这是 Composer
    自动生成的。它的值是一个对象，列出了项目所需的所有包。在这种情况下，有一个 "markrogoyski/math-php" 条目。它的值 "^2.10" 表示包的可接受版本。插入符号（^）意味着我们愿意使用具有相同主版本号的新版本（例如
    2.10.1、2.11、2.2 等），但不使用版本 3.*x* 或更高版本，因为那可能会破坏向后兼容性。
- en: Now that Composer has integrated the markrogoyski/math-php package into our
    project, we can try using it. Specifically, we’ll draw on the package’s Average
    class to compute the average of a series of numbers. Update the contents of *public/index.php*
    with the code in [Listing 20-9](#lis20-9).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Composer 已经将 markrogoyski/math-php 包集成到我们的项目中，我们可以尝试使用它。具体来说，我们将使用该包的 Average
    类来计算一系列数字的平均值。请更新 *public/index.php* 的内容，使用[清单 20-9](#lis20-9)中的代码。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 20-9: Calculating the average of an array of integers'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 20-9：计算一组整数的平均值
- en: We start with a use statement telling the PHP engine that Average refers to
    the namespaced class MathPHP\Statistics\Average. Notice that the namespace for
    this class is different from the vendor and package name we used earlier in the
    require statement to Composer. Then we declare a $numbers array and use the built-in
    implode() function to create a string version of it for user-friendly output.
    Next, we invoke the mean() method from the Average class, storing the result in
    $mean. We then print out the list of numbers and the calculated mean value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过 `use` 语句告诉 PHP 引擎，Average 是指命名空间为 MathPHP\Statistics\Average 的类。注意，这个类的命名空间与我们之前在
    `require` 语句中为 Composer 使用的供应商和包名称不同。接下来，我们声明一个 `$numbers` 数组，并使用内置的 `implode()`
    函数将其转换为字符串，以便用户友好的输出。然后，我们调用 Average 类中的 `mean()` 方法，将结果存储在 `$mean` 中。接着，我们打印出数字列表和计算出的平均值。
- en: Notice that we’ve invoked the mean() method without actually having to create
    an object of the Average class. This is because mean() is a *static method*. We’ll
    explore this OOP concept in detail in [Chapter 25](chapter25.xhtml).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们调用了 `mean()` 方法，而不需要实际创建 Average 类的对象。这是因为 `mean()` 是一个 *静态方法*。我们将在[第
    25 章](chapter25.xhtml)中详细探讨这一面向对象的概念。
- en: Where to Find PHP Libraries
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在哪里可以找到 PHP 库
- en: You may be wondering how the Composer tool knew where to go on the internet
    to download the markrogoyski/math-php package files for our project. The answer
    is Packagist (*[https://packagist.org](https://packagist.org)*), a website for
    publishing open source PHP packages. Vendors can register with the site (I’m mattsmithdev
    on Packagist, for example) and then publish PHP packages for anyone to install
    via Composer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道Composer工具是如何知道在哪里下载markrogoyski/math-php包文件以供我们的项目使用的。答案是Packagist (*[https://packagist.org](https://packagist.org)*)，这是一个用于发布开源PHP包的网站。供应商可以在该网站上注册（例如，我在Packagist上的用户名是mattsmithdev），然后发布PHP包，供任何人通过Composer安装。
- en: When publishing a package, the vendor must provide information including the
    GitHub (or other repository) location of the package’s publicly downloadable files.
    For example, the Packagist page for the markrogoyski/math-php package lists a
    GitHub address of *[https://github.com/markrogoyski/math-php](https://github.com/markrogoyski/math-php)*.
    This is where Composer goes to get the package files. Each page on Packagist also
    lists the exact require command you need in order to make Composer add that package
    to your project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布包时，供应商必须提供包括包的公开可下载文件的GitHub（或其他仓库）位置。例如，markrogoyski/math-php包的Packagist页面列出了一个GitHub地址*
    [https://github.com/markrogoyski/math-php](https://github.com/markrogoyski/math-php)*。这就是Composer去下载包文件的位置。Packagist的每个页面还列出了您需要的确切require命令，以便Composer将该包添加到您的项目中。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to unambiguously differentiate between classes
    of the same name by using namespaces. You also learned to use the powerful Composer
    command line tool to support object-oriented PHP programming. The time spent learning
    how to maintain the *composer.json* file and how to use Composer to autoload classes
    and incorporate third-party libraries into your projects will save you countless
    hours of tedious manual work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何通过使用命名空间清晰地区分同名类。您还学习了如何使用强大的Composer命令行工具支持面向对象的PHP编程。学习如何维护*composer.json*文件，以及如何使用Composer自动加载类并将第三方库集成到项目中，将为您节省无数小时的繁琐手动工作。
- en: Exercises
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Start a new project and create a Composer script alias for a command to
    display the message Hello name, replacing name with your name. Then use Composer
    to execute your command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   开始一个新项目，并为一个命令创建Composer脚本别名，显示消息Hello name，将name替换为您的名字。然后使用Composer执行该命令。
- en: 'Hint: Declare a script alias in *composer.json*, then run it at the command
    line with composer alias.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在*composer.json*中声明一个脚本别名，然后使用composer别名在命令行中运行它。
- en: 2.   Start a new project and create a *src/Product.php* file declaring a Product
    class with the private properties $id, $description, and $price, and public getters
    and setters for each property. Declare the class to be in the Mattsmithdev namespace.
    Add a *composer.json* file to the root folder of your project, declaring that
    classes in the Mattsmithdev namespace can be found in the *src* directory. Then
    use Composer to generate an autoloader.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   开始一个新项目，并创建一个*src/Product.php*文件，声明一个Product类，包含私有属性$id、$description和$price，以及每个属性的公有getter和setter方法。声明该类位于Mattsmithdev命名空间下。将一个*composer.json*文件添加到项目的根文件夹，声明Mattsmithdev命名空间中的类可以在*src*目录中找到。然后使用Composer生成自动加载器。
- en: 'Write a *public/index.php* file that does the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个*public/index.php*文件，执行以下操作：
- en: a.   Reads in and executes the Composer autoloader in *vendor/ autoload.php*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: a.   读取并执行*vendor/autoload.php*中的Composer自动加载器
- en: b.   Creates a new Product object, $p1, with an id of 7, a description of 'hammer',
    and a price of 9.99
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: b.   创建一个新的Product对象$p1，id为7，描述为'hammer'，价格为9.99
- en: c.   Uses var_dump() to output the details of $p1
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: c.   使用var_dump()输出$p1的详细信息
- en: 'When you run your code, you should see something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，您应该看到类似以下内容：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 3.   Go to the Packagist website at *[https://packagist.org](https://packagist.org)*
    and search for the mattsmithdev/faker-small-english package. Look at the documentation,
    then use Composer to require the mattsmithdev/faker-small-english package for
    a new project. Write a *public/index.php* file that loops 10 times to display
    10 random names from a FakerSmallEnglish object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   访问Packagist网站，打开* [https://packagist.org](https://packagist.org)*并搜索mattsmithdev/faker-small-english包。查看文档，然后使用Composer为新项目要求mattsmithdev/faker-small-english包。编写一个*public/index.php*文件，循环10次，从FakerSmallEnglish对象中显示10个随机名字。
