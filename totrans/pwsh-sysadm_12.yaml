- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: PARSING STRUCTURED DATA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 解析结构化数据
- en: '![Images](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/common.jpg)'
- en: With ingrained support for any .NET object, and just about every shell method
    you can think of, PowerShell is able to read, update, and remove data from numerous
    sources. If you’re lucky enough to have your data stored in some kind of structured
    way, working with that data is even easier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 内置支持任何 .NET 对象，以及几乎所有你能想到的 shell 方法，因此它能够读取、更新和删除来自多个数据源的数据。如果你的数据以某种结构化的方式存储，处理这些数据会变得更加简单。
- en: In this chapter, we’ll focus on a few common forms of structured data including
    CSV, Microsoft Excel spreadsheets, and JSON. You’ll learn how to manage each kind
    of data by using both native PowerShell cmdlets and .NET objects. By the end of
    the chapter, you should be a data-wrangling pro, able to use PowerShell to manage
    all sorts of structured data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注几种常见的结构化数据形式，包括 CSV、Microsoft Excel 电子表格和 JSON。你将学习如何使用 PowerShell
    的本机 cmdlet 和 .NET 对象来管理每种数据类型。到本章结束时，你应该成为一个数据处理高手，能够使用 PowerShell 管理各种结构化数据。
- en: CSV Files
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSV 文件
- en: 'One of the easiest, most common ways to store data is to use a CSV file. A
    *CSV file* is a simple text file representing a table. Each item in the table
    is separated by a shared, predetermined symbol known as a *delimiter* (commas
    are the most common delimiter). Every CSV file shares the same basic structure:
    the first row in the CSV is the header row, containing all the headers for the
    table’s columns; the following rows contain all of the table’s contents.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据的最简单、最常见方式之一就是使用 CSV 文件。*CSV 文件*是一个简单的文本文件，表示一个表格。表格中的每一项由一个共享的、预定的符号（称为*分隔符*）分隔开来（逗号是最常见的分隔符）。每个
    CSV 文件都具有相同的基本结构：CSV 文件的第一行是标题行，包含表格列的所有标题；随后的行包含表格的所有内容。
- en: 'In this section, you’ll primarily be working with a couple of CSV cmdlets:
    `Import-Csv` and `Export-Csv`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将主要使用两个 CSV cmdlet：`Import-Csv` 和 `Export-Csv`。
- en: Reading CSV Files
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取 CSV 文件
- en: Of all the CSV processing tasks PowerShell is equipped to do, the most common
    is almost certainly reading. Given how simple and effective the CSV structure
    is, it should be no surprise that CSV files are used by companies and applications
    throughout the tech world—hence the popularity of the `Import-Csv` PowerShell
    command.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 能够执行的所有 CSV 处理任务中，最常见的任务几乎肯定是读取。鉴于 CSV 结构的简单性和有效性，CSV 文件在科技界的公司和应用程序中被广泛使用，因此
    `Import-Csv` PowerShell 命令也非常流行。
- en: 'But what exactly does it mean to *read* a CSV file? Though a CSV has all the
    information you want, you can’t just import it directly into your program; usually,
    you have to read through the file and convert it into usable data. This process
    is known as *parsing*. The `Import-Csv` command parses the CSV file: reading it
    in, and then transforming the data into PowerShell objects. I will go into the
    uses of `Import-Csv` in a moment, but first, it’s worth taking a dive under the
    hood to see what `Import-Csv` is doing.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟什么是*读取* CSV 文件呢？虽然 CSV 文件包含了你需要的所有信息，但你不能直接将其导入到程序中；通常，你需要读取文件并将其转换为可用的数据。这个过程被称为*解析*。`Import-Csv`
    命令解析 CSV 文件：读取它，并将数据转换为 PowerShell 对象。我稍后会详细介绍 `Import-Csv` 的使用方法，但首先，值得深入了解 `Import-Csv`
    的底层操作。
- en: Let’s start with a simple spreadsheet containing a few employees at a fictional
    company, shown in [Figure 10-1](ch10.xhtml#ch10fig1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含几位员工的简单电子表格开始，数据来自一个虚构公司的[图 10-1](ch10.xhtml#ch10fig1)。
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig01.jpg)'
- en: '*Figure 10-1: Employee CSV file*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：员工 CSV 文件*'
- en: '[Figure 10-1](ch10.xhtml#ch10fig1) is an Excel screenshot, but you can easily
    see what the data looks like as a plaintext CSV file. For our sample CSV file,
    you’ll be working with *Employees.csv*, which can be found in this chapter’s resources;
    see [Listing 10-1](ch10.xhtml#ch10list1).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](ch10.xhtml#ch10fig1) 是一个 Excel 截图，但你可以轻松地看到数据作为纯文本 CSV 文件的样子。对于我们的示例
    CSV 文件，你将使用*Employees.csv*，它可以在本章的资源中找到；请参见[清单 10-1](ch10.xhtml#ch10list1)。'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Reading a CSV file with Get-Content*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：使用 Get-Content 读取 CSV 文件*'
- en: Here, you’re using the `Get-Content` command to query our text file (CSV). `Get-Content`
    is the PowerShell command to use for reading plaintext files of any kind.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 `Get-Content` 命令来查询我们的文本文件（CSV）。`Get-Content` 是 PowerShell 中用于读取任何类型纯文本文件的命令。
- en: You can see that this is a typical CSV file with a header row and multiple data
    rows separated into columns by a comma delimiter. Notice that you can read the
    file by using the `Get-Content` cmdlet. Since a CSV file is a text file, `Get-Content`
    works just fine for reading it (this is actually the first step that happens with
    `Import-Csv`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这是一个典型的CSV文件，包含一个头行和多个数据行，数据行通过逗号分隔成列。请注意，你可以通过使用`Get-Content` cmdlet来读取该文件。由于CSV文件是一个文本文件，`Get-Content`能够很好地读取它（这实际上是`Import-Csv`执行的第一步）。
- en: 'But also notice how `Get-Content` returns the information: as a simple string.
    This is what happens when you use the `Raw` parameter. Otherwise, `Get-Content`
    returns an array of strings, with each element representing a row in the CSV file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但也要注意`Get-Content`返回的信息：它是一个简单的字符串。这就是使用`Raw`参数时发生的情况。否则，`Get-Content`会返回一个字符串数组，每个元素代表CSV文件中的一行：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Though the `Get-Content` command can read in the data, the command doesn’t *understand*
    a CSV file’s schema. `Get-Content` has no idea that the table has a header row
    or data rows, and it doesn’t know what to do with the delimiter. It just takes
    in the content and spits it back out. That’s why we have `Import-Csv`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Get-Content`命令可以读取数据，但该命令并不*理解*CSV文件的结构。`Get-Content`不知道表格有头行或数据行，也不知道该如何处理分隔符。它只是获取内容然后输出。正因如此，我们才有了`Import-Csv`。
- en: Using Import-Csv to Process Data
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Import-Csv处理数据
- en: To see how `Import-Csv` works, compare the output in [Listing 10-1](ch10.xhtml#ch10list1)
    with the output from `Import-Csv` in [Listing 10-2](ch10.xhtml#ch10list2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`Import-Csv`的工作原理，可以将[Listing 10-1](ch10.xhtml#ch10list1)中的输出与[Listing 10-2](ch10.xhtml#ch10list2)中的`Import-Csv`输出进行对比。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-2: Using Import-Csv*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-2: 使用Import-Csv*'
- en: The first thing you’ll probably notice is that the headers are now separated
    from the data entries by a line. This means that `Import-Csv` reads the file,
    treats the top row as a header row, and knows to separate it from the rest of
    the file. You also may notice that there are no more commas—when a command reads
    and *understands* a CSV file, it knows that the delimiter is used to separate
    items in the table and shouldn’t show up in the table itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先可能会注意到的是，标题与数据项之间现在由一条线分开。这意味着`Import-Csv`读取文件时，把顶部的行当作头行，并知道要将其与文件的其他部分分开。你还可能会注意到，没有更多的逗号——当一个命令读取并*理解*CSV文件时，它知道分隔符用于分隔表格中的项，不应该出现在表格中。
- en: 'But what happens if the code has a stray delimiter? Try putting a comma in
    the middle of *Adam* in *Employees.csv* and run the code. What happens? Now everything
    in the Adam row is shifted over: *am* is the new Last Name, *Bertram* the new
    Department, and *IT* the new Manager. `Import-Csv` is smart enough to understand
    a CSV’s format, but not smart enough to understand its content—that’s where you
    come in.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果代码中有一个多余的分隔符会发生什么呢？试着在*Employees.csv*文件中*Adam*的中间加入一个逗号，然后运行代码。会发生什么呢？现在Adam所在的行所有内容都被移动了：*am*变成了新的姓氏，*Bertram*变成了新的部门，*IT*变成了新的经理。`Import-Csv`足够智能，能够理解CSV的格式，但并不够聪明去理解其内容——这就是你要介入的地方。
- en: Turning Raw Data into Objects
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将原始数据转换为对象
- en: '`Import-Csv` doesn’t just read in the CSV and print it out with fancy formatting.
    The content of the file is put into an array of `PSCustomObject`s. Here, each
    `PSCustomObject` is an object that holds the data for one row. Each object has
    properties that correspond to the headers in the header row, and if you want the
    data for that header’s column, all you have to do is access that property. Just
    by knowing which form of data to expect, `Import-Csv` can take a string of data
    it has never seen before and turn it into easy-to-use objects. Pretty cool!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Import-Csv`不仅仅是读取CSV并打印出带有花哨格式的数据。文件的内容被放入一个`PSCustomObject`数组中。在这里，每个`PSCustomObject`是一个保存一行数据的对象。每个对象都有与头行中的标题对应的属性，如果你想获取某个标题列的数据，只需要访问该属性即可。只要知道预期的数据形式，`Import-Csv`就能将它从一个从未见过的字符串数据转换成易于使用的对象。相当酷！'
- en: 'Having the data as an array of `PSCustomObject`s allows you to use that data
    much more effectively. Let’s say you want to find only the employees with the
    last name of *Bertram*. Since each data row in the CSV is a `PSCustomObject`,
    you can do this by using `Where-Object`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据作为`PSCustomObject`数组保存，允许你更有效地使用这些数据。假设你只想找到姓氏为*Bertram*的员工。由于CSV中的每一行数据都是一个`PSCustomObject`，你可以通过使用`Where-Object`来实现：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If, instead, you want to return only rows in the CSV that have a department
    of Executive Office, you can do so easily! You use the same technique and change
    the property name from Last Name to Department, and the value from Bertram to
    Executive Office:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想返回 CSV 中只有“行政办公室”部门的行，你也可以轻松实现！你只需使用相同的技巧，将属性名称从“Last Name”改为“Department”，并将值从“Bertram”改为“Executive
    Office”：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What happens if you use semicolons for your delimiter instead of commas? Try
    changing the CSV file and see what happens. Not good, right? You don’t have to
    use a comma as a delimiter, but commas are the delimiter that `Import-Csv` natively
    understands. If you want to use a different delimiter, you have to specify the
    new delimiter in your `Import-Csv` command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用分号作为分隔符而不是逗号，会发生什么？尝试更改 CSV 文件，看看会发生什么。不好吧？你不一定非得使用逗号作为分隔符，但逗号是`Import-Csv`原生理解的分隔符。如果你想使用其他分隔符，你需要在`Import-Csv`命令中指定新的分隔符。
- en: 'To demonstrate, replace all the commas in our *Employees.csv* file with tabs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，将我们*Employees.csv*文件中的所有逗号替换为制表符：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you have a tab-separated file, you can then specify the tab character (represented
    by a backtick and the `t` character) as the new delimiter by using the `Delimiter`
    parameter ([Listing 10-3](ch10.xhtml#ch10list3)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个制表符分隔的文件，你就可以通过使用`Delimiter`参数（[列表 10-3](ch10.xhtml#ch10list3)）指定制表符字符（由反引号和`t`字符表示）作为新的分隔符。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-3: Using the Delimiter parameter of Import-Csv*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-3：使用 Import-Csv 的 Delimiter 参数*'
- en: Notice that the output is the same as it was in [Listing 10-2](ch10.xhtml#ch10list2).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出与[列表 10-2](ch10.xhtml#ch10list2)中的相同。
- en: Defining Your Own Header
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义你自己的表头
- en: What if you have a table of data, but you want to change the header row to be
    more user-friendly? `Import-Csv` can do this too. As with the new delimiter, you
    want to pass a parameter in to `Import-Csv`. [Listing 10-4](ch10.xhtml#ch10list4)
    uses the `Header` parameter to pass in a series of strings separated by commas
    (the new headers).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个数据表，但想将表头行更改为更具用户友好的形式呢？`Import-Csv`也能做到这一点。与新的分隔符一样，你需要在 `Import-Csv`
    中传递一个参数。[列表 10-4](ch10.xhtml#ch10list4)使用 `Header` 参数传入一个由逗号分隔的字符串序列（新的表头）。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-4: Using the Header parameter of Import-Csv*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-4：使用 Import-Csv 的 Header 参数*'
- en: As you can see, after the command runs, each object in the data row will have
    the new labels as property names.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令运行后，数据行中的每个对象都会将新标签作为属性名称。
- en: Creating CSV Files
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 CSV 文件
- en: 'So much for reading CSV files. What if you want to make your own? You could
    type one out by hand, but that would take time and energy, especially if you’re
    dealing with thousands of rows. Luckily, PowerShell also has a native cmdlet for
    creating CSV files: `Export-Csv`. You can use this cmdlet to create CSV files
    from any existing PowerShell object; you simply have to tell PowerShell which
    objects to use as rows, and where it should create the file.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，关于读取 CSV 文件的部分结束。如果你想自己制作一个 CSV 文件呢？你可以手动键入，但那会花费时间和精力，特别是当你处理成千上万行数据时。幸运的是，PowerShell
    也有一个原生 cmdlet 来创建 CSV 文件：`Export-Csv`。你可以使用这个 cmdlet 从任何现有的 PowerShell 对象创建 CSV
    文件；你只需告诉 PowerShell 使用哪些对象作为行，并指定它应将文件创建到何处。
- en: Let’s deal with the second requirement first. Say you run some PowerShell commands,
    and then you want to save the output in the console to a file somehow. You could
    use `Out-File`, but that would send the unstructured text directly to a new file.
    You want a nice structured file instead, complete with header rows and delimiters.
    Enter `Export-Csv`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理第二个需求。假设你运行了一些 PowerShell 命令，然后你希望以某种方式将控制台中的输出保存到文件中。你可以使用`Out-File`，但那样会将未经结构化的文本直接发送到新文件中。你需要一个结构化良好的文件，包含表头行和分隔符。这时，`Export-Csv`就派上用场了。
- en: 'As an example, let’s say you want to pull all the running processes from your
    computer and record the process name, company, and description of each one. You
    can use `Get-Process` to do this and `Select-Object` to narrow down the properties
    you want to see, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想从计算机中获取所有正在运行的进程，并记录每个进程的名称、公司和描述。你可以使用 `Get-Process` 来做到这一点，并使用 `Select-Object`
    来缩小你想查看的属性，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In [Listing 10-5](ch10.xhtml#ch10list5), you can see what happens when you commit
    this output to the filesystem in a structured manner by using `Export-Csv`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 10-5](ch10.xhtml#ch10list5)中，你可以看到当你以结构化方式将此输出提交到文件系统时，使用 `Export-Csv`
    的结果。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-5: Using Export-Csv*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-5：使用 Export-Csv*'
- en: By piping the output directly to `Export-Csv`, specifying the path to the CSV
    you’d like to create (using the `Path` parameter), and using the `NoTypeInformation`
    parameter, you’ve created a CSV file with the expected header row and data rows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将输出直接传输到`Export-Csv`，并指定你希望创建的CSV文件路径（使用`Path`参数），并使用`NoTypeInformation`参数，你已经创建了一个包含预期标题行和数据行的CSV文件。
- en: '**NOTE**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The NoTypeInformation parameter is not required, but if you don’t use it,
    you will get a line at the top of your CSV file specifying the type of object
    it came from. Unless you’re reimporting the CSV file directly back into PowerShell,
    this usually isn’t desired. An example line looks like #TYPE Selected.System.Diagnostics.Process.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*NoTypeInformation参数不是必需的，但如果不使用它，你的CSV文件顶部会出现一行，指定该文件来自的对象类型。除非你将CSV文件直接重新导入到PowerShell，否则通常不希望这样。一个示例行如下：#TYPE
    Selected.System.Diagnostics.Process.*'
- en: 'Project 1: Building a Computer Inventory Report'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目1：构建计算机库存报告
- en: To bring together everything you’ve learned so far, let’s work on a mini-project,
    something you may run into in your daily life.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将到目前为止所学的内容整合起来，让我们做一个迷你项目，这是你在日常工作中可能会遇到的。
- en: Imagine for a moment that your company has acquired another company that has
    no idea what servers and PCs it has on its network. All it has is a CSV file of
    IP addresses and the department where each device is located. You’ve been brought
    in to figure out what these devices are and to provide a new CSV file to management
    with the results.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的公司收购了一家没有任何关于其网络上有哪些服务器和PC设备的知识的公司。它唯一拥有的就是一个包含IP地址和每个设备所在部门的CSV文件。你被招募进来，任务是弄清楚这些设备是什么，并将结果提供给管理层，创建一个新的CSV文件。
- en: 'What do you have to do? At a high level, this is a two-step process: read in
    their CSV and write your own. Your CSV file will need the following information:
    each IP address you process, the department it’s supposed to be in, whether or
    not the IP address responds to a ping, and the DNS name of that device.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做什么？从高层次来看，这是一个两步的过程：读取他们的CSV并写出你自己的CSV。你的CSV文件需要包含以下信息：你处理的每个IP地址、它应该属于的部门、该IP地址是否响应ping请求，以及该设备的DNS名称。
- en: 'You’ll start with a CSV file that looks just like that looks like the following
    snippet. The IP addresses are part of a full 255.255.255.0 network, so they go
    all the way up to 192.168.0.254:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从一个看起来像以下片段的CSV文件开始。IP地址属于一个完整的255.255.255.0网络，因此它们的范围一直到192.168.0.254：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’ve created a script called *Discover-Computer.ps1* that’s available in this
    chapter’s resources. As you move through this experiment, start adding code to
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为*Discover-Computer.ps1*的脚本，该脚本可以在本章的资源中找到。在进行这个实验时，可以开始向脚本中添加代码。
- en: 'First, you need to read each row in the CSV file. You do this with `Import-Csv`,
    which will capture each row of the CSV into a variable for further processing:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要读取CSV文件中的每一行。你可以使用`Import-Csv`来实现，它将CSV的每一行捕获到一个变量中，以便进一步处理：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that you have the data, you need to use it. You’ll perform two actions
    on each IP address: pinging it and finding its hostname. Let’s go ahead and test
    these actions on a row of our CSV to ensure that you have the syntax right.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了数据，接下来需要使用它。你将对每个IP地址执行两个操作：ping测试和查找其主机名。让我们先在CSV中的一行数据上测试这些操作，以确保语法正确。
- en: In the following listing, you use the `Test-Connection` command, which sends
    a single ICMP packet to the IP address you specify (here the IP address in the
    first row of our CSV file). The `Quiet` parameter tells the command to return
    either a `True` or `False` value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，你使用了`Test-Connection`命令，它向你指定的IP地址发送一个ICMP数据包（这里是CSV文件中第一行的IP地址）。`Quiet`参数告诉命令返回`True`或`False`的值。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the second line of this code, you’re obtaining the hostname by using the
    `Resolve-DnsName` command on the same IP address. The `Resolve-DnsName` command
    returns multiple properties. Here, because you’re concerned with only the name,
    you enclose the entire command in parentheses and use dot notation to return the
    `Name` property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码的第二行中，你通过对相同IP地址使用`Resolve-DnsName`命令来获取主机名。`Resolve-DnsName`命令返回多个属性。这里，因为你只关心名称，所以将整个命令括在括号内，并使用点符号返回`Name`属性。
- en: 'Once you’re comfortable with the syntax for each action, you need to do this
    for every row in the CSV. The easiest way to do this is with a `foreach` loop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了每个操作的语法，你需要对CSV中的每一行都执行此操作。最简单的方法是使用`foreach`循环：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the code yourself. What happens? You get a bunch of `True`/`False` lines
    with hostnames, but no way to know which IP address the output is associated with.
    You’ll have to create a *hashtable* for each row and assign your own elements
    to it. You also need to account for if or when `Test-Connection` or `Resolve-DnsName`
    returns an error. [Listing 10-6](ch10.xhtml#ch10list6) shows an example of how
    to do all this.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自运行代码。会发生什么？你得到了一堆带有主机名的`True`/`False`行，但无法知道哪个IP地址与输出相关联。你需要为每一行创建一个*哈希表*并为其分配自己的元素。你还需要考虑`Test-Connection`或`Resolve-DnsName`返回错误的情况。[清单10-6](ch10.xhtml#ch10list6)展示了如何做到这一点的示例。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-6: Mini-project—CSV file discovery*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-6：迷你项目——CSV文件发现*'
- en: Let’s walk through what’s happening. First, you create a hashtable with values
    corresponding to the row’s columns and the extra information you want ❷. Next,
    test whether the computer is connected by pinging the IP address ❸. If the computer
    is connected, set `IsOnline` to `True`. Then do the same with the `HostName`,
    testing whether it’s found ❹ and updating the hashtable’s value if it is. If any
    errors occur, record that in the hashtable’s `Error` value ❺. Lastly, turn your
    hashtable into a `PSCustomObject` and return it (regardless of whether an error
    is thrown) ❻. Note that you’ve wrapped this whole function in a `try/catch` block
    ❶, which will execute the code in the `catch` block if the code in the `try` block
    throws an error. Because you’re using the `ErrorAction` parameter, `Resolve-DnsName`
    will throw an exception (an error) if something unexpected happens.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解发生了什么。首先，你创建一个哈希表，包含与行的列对应的值以及你想要的额外信息❷。接下来，通过ping测试计算机是否连接，测试IP地址❸。如果计算机连接，设置`IsOnline`为`True`。然后，对`HostName`做同样的测试，检查它是否被找到❹，如果找到，则更新哈希表中的值。如果出现任何错误，将其记录在哈希表的`Error`值中❺。最后，将你的哈希表转换为`PSCustomObject`并返回它（无论是否抛出错误）❻。注意，你已将整个函数包裹在`try/catch`块中❶，如果`try`块中的代码抛出错误，则会执行`catch`块中的代码。因为你使用了`ErrorAction`参数，所以如果`Resolve-DnsName`遇到意外情况，它将抛出一个异常（错误）。
- en: 'Run this, and you should see output that looks like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你应该看到如下所示的输出：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Congrats! You’ve done most of the hard work, and now you can tell which IP address
    is associated with which output. All that’s left is to record the output to a
    CSV. As you learned earlier, you can do this with `Export-Csv`. You’ll simply
    pipe the `PSCustomObject` you created into `Export-Csv`, and the output will go
    directly into a CSV file rather than being output to the console.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了大部分繁重的工作，现在你可以知道哪个IP地址与哪个输出相关联。剩下的就是将输出记录到CSV文件中。正如你之前所学的，你可以使用`Export-Csv`来做到这一点。你只需将你创建的`PSCustomObject`管道传递给`Export-Csv`，输出将直接写入CSV文件，而不是输出到控制台。
- en: 'Notice that next, you’ll use the `Append` parameter. By default, `Export-Csv`
    overwrites the CSV file. Using the `Append` parameter adds a row to the end of
    an existing CSV file rather than overwriting it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接下来你将使用`Append`参数。默认情况下，`Export-Csv`会覆盖CSV文件。使用`Append`参数会将一行添加到现有CSV文件的末尾，而不是覆盖它：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the script runs, you’ll see that the CSV file will be the exact same as
    the output you saw in your PowerShell console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本运行，你会看到CSV文件与在PowerShell控制台中看到的输出完全相同：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should now have a CSV file called *DeviceDiscovery.csv* (or whatever you
    named it) that has rows for each IP address in the original CSV, along with values
    for all of the original CSV file values and the values that you discovered with
    `Test-Connection` and `Resolve-DnsName`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该有一个名为*DeviceDiscovery.csv*（或你命名的任何名字）的CSV文件，文件中包含原始CSV中每个IP地址的行，以及你通过`Test-Connection`和`Resolve-DnsName`发现的所有原始CSV文件值和新发现的值。
- en: Excel Spreadsheets
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Excel电子表格
- en: 'It’s hard to imagine a business that doesn’t use Excel spreadsheets. Chances
    are, if you get a scripting project, it will involve an Excel spreadsheet. But
    before we dive deep into the world of Excel, it’s worth stating something clearly:
    if possible, don’t use it at all!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象有哪个企业不使用Excel电子表格。如果你接到一个脚本编写项目，可能会涉及到一个Excel电子表格。但在深入了解Excel的世界之前，有一点需要明确地说明：如果可能，尽量不要使用它！
- en: A CSV file can store data as effectively as a simple Excel spreadsheet, and
    CSV files are much easier to manage with PowerShell. Excel spreadsheets come in
    a proprietary format, and you can’t even read them by using PowerShell unless
    you’re using an external library. If you have an Excel workbook with a single
    worksheet, do yourself a favor and save it as a CSV file. Of course, this isn’t
    always possible, but if it is, you’ll thank yourself later. Trust me.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件可以像简单的 Excel 电子表格一样有效地存储数据，并且使用 PowerShell 管理 CSV 文件要容易得多。Excel 电子表格是专有格式的文件，除非使用外部库，否则你无法直接用
    PowerShell 读取它们。如果你有一个只有一个工作表的 Excel 工作簿，最好将其保存为 CSV 文件。当然，这并不总是可能的，但如果可以的话，以后你会感谢自己。相信我。
- en: But what if it isn’t possible to save it as a CSV? In that case, you need to
    use a community module. Once upon a time, reading *.xls* or *.xlsx* Excel spreadsheets
    with PowerShell required a software developer’s delicate touch. You had to have
    Excel installed, and you had to access *COM objects*, complex programming components
    that take all the fun out of working in PowerShell. Luckily, other people have
    done the hard work for you, so rather than focus on learning how to use COM, in
    this section, you’ll rely on Doug Finke’s wonderful `ImportExcel` module. This
    freely available community module does not require Excel to be installed, and
    it’s much simpler than COM objects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果无法将其保存为CSV呢？在这种情况下，你需要使用一个社区模块。曾几何时，使用 PowerShell 读取 *.xls* 或 *.xlsx* 格式的
    Excel 表格需要软件开发人员的精细操作。你必须安装 Excel，并且必须访问 *COM 对象*，这是一种复杂的编程组件，让 PowerShell 的工作变得不那么有趣。幸运的是，其他人已经为你做了繁重的工作，所以在本节中，你将依赖
    Doug Finke 的精彩 `ImportExcel` 模块。这个免费的社区模块不需要安装 Excel，而且比 COM 对象简单得多。
- en: First, you need to install the module. The `ImportExcel` module is available
    via the PowerShell Gallery and can be installed by running `Install-Module ImportExcel`.
    Once you’ve installed the `ImportExcel` module, it’s time to see what it can do.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装该模块。`ImportExcel`模块可以通过 PowerShell Gallery 获取，可以通过运行 `Install-Module
    ImportExcel` 来安装。一旦安装了 `ImportExcel` 模块，你就可以开始查看它的功能了。
- en: Creating Excel Spreadsheets
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 Excel 电子表格
- en: To start, you need to create an Excel spreadsheet. Now, sure, you could create
    one the usual way by opening Excel and going through all that jazz—but where’s
    the fun in that? Let’s use PowerShell to create a simple spreadsheet with a single
    worksheet (you have to crawl before you can walk). To do this, you’ll use the
    `Export-Excel` command. Just like `Export-Csv`, `Export``-Excel` will read the
    property names of each object it receives, create a header row from them, and
    then create the data rows right below.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个 Excel 电子表格。当然，你可以像平常一样打开 Excel 创建一个电子表格，但这样有趣吗？让我们使用 PowerShell 创建一个只有一个工作表的简单电子表格（在你学会走之前，得先学会爬行）。为此，你将使用
    `Export-Excel` 命令。就像 `Export-Csv` 一样，`Export-Excel` 会读取它接收到的每个对象的属性名称，使用这些属性名称创建标题行，然后在下面创建数据行。
- en: The easiest way to use `Export-Excel` is to pipe one or more objects into it
    just as you would with `Export-Csv`. As an example, let’s create an Excel workbook
    with a single worksheet that contains all the running processes on my computer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Export-Excel`的最简单方法是将一个或多个对象传递给它，就像使用`Export-Csv`一样。举个例子，假设我们要创建一个包含我计算机上所有正在运行的进程的
    Excel 工作簿，工作簿中只有一个工作表。
- en: The input Get-Process | Export-Excel .\Processes.xlsx gives us a spreadsheet
    that looks like [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 Get-Process | Export-Excel .\Processes.xlsx 会生成一个像[图10-2](ch10.xhtml#ch10fig2)一样的电子表格。
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig02.jpg)'
- en: '*Figure 10-2: The Excel spreadsheet*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：Excel 电子表格*'
- en: If you haven’t converted to CSVs yet, you’re probably working with something
    more complicated than just a single worksheet. Let’s add a couple more worksheets
    to our existing workbook. To do that, use the `WorksheetName` parameter, as shown
    in [Listing 10-7](ch10.xhtml#ch10list7). This will create additional worksheets
    by using the objects that are sent to `Export-Excel`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有将其转换为CSV格式，那么你可能正在处理比单一工作表更复杂的内容。让我们在现有的工作簿中再添加几个工作表。为此，请使用`WorksheetName`参数，如[示例10-7](ch10.xhtml#ch10list7)所示。通过将发送到`Export-Excel`的对象，你可以创建额外的工作表。
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-7: Adding worksheets to an Excel workbook*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-7：向 Excel 工作簿添加工作表*'
- en: Creating a spreadsheet by using `Export-Excel` can be a *whole* lot more complicated,
    but to save us time (and the Earth a couple of trees), we don’t go into it here.
    If you’re curious, check out the help documentation on `Export-Excel` and you’ll
    see the dozens of parameters you can use!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Export-Excel`创建电子表格可能会复杂得多，但为了节省时间（并为地球节省几棵树），我们在这里就不详细讨论了。如果你感兴趣，可以查阅`Export-Excel`的帮助文档，你会看到可以使用的众多参数！
- en: Reading Excel Spreadsheets
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取Excel电子表格
- en: Now that you have a spreadsheet you can work with, let’s focus on reading the
    rows inside. To read a spreadsheet, you use the `Import-Excel` command. This command
    reads a worksheet in a workbook and returns one or more `PSCustomObject` objects
    representing each row. The simplest way to use this command is to specify the
    workbook path by using the `Path` parameter. You’ll see in [Listing 10-8](ch10.xhtml#ch10list8)
    that `Import-Excel` returns an object that uses the column names as properties.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个可以操作的电子表格，让我们集中讨论如何读取其中的行。要读取电子表格，你使用`Import-Excel`命令。该命令读取工作簿中的一个工作表，并返回一个或多个代表每一行的`PSCustomObject`对象。使用这个命令的最简单方法是通过`Path`参数指定工作簿的路径。你会在[示例10-8](ch10.xhtml#ch10list8)中看到，`Import-Excel`返回一个使用列名作为属性的对象。
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-8: Using Import-Excel*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-8：使用Import-Excel*'
- en: By default, `Import-Excel` will return only the first worksheet. Our example
    workbook has multiple worksheets, so you need to figure out a way to go through
    each sheet. But imagine it’s been a while since you last created that spreadsheet,
    and you can’t remember the worksheet names. No problem. You’ll use `Get-ExcelSheetInfo`
    to find all the worksheets in the workbook, as shown in [Listing 10-9](ch10.xhtml#ch10list9).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Import-Excel`将只返回第一个工作表。我们的示例工作簿有多个工作表，因此你需要找出一种方法来遍历每个工作表。但假设自从你最后创建这个电子表格以来已经有一段时间了，你记不住工作表的名称了。没问题。你可以使用`Get-ExcelSheetInfo`来查找工作簿中的所有工作表，如[示例10-9](ch10.xhtml#ch10list9)所示。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-9: Using Get-ExcelSheetInfo*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-9：使用Get-ExcelSheetInfo*'
- en: You’ll use this output to pull data from all our worksheets. Make a `foreach`
    loop and call `Import-Excel` for every worksheet inside the workbook, just as
    in [Listing 10-10](ch10.xhtml#ch10list10).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用这个输出从所有工作表中提取数据。创建一个`foreach`循环，并对工作簿中的每个工作表调用`Import-Excel`，就像在[示例10-10](ch10.xhtml#ch10list10)中一样。
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 10-10: Getting all rows from all worksheets*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-10：从所有工作表获取所有行*'
- en: Notice that you use a calculated property with `Select-Object` ❶. Typically,
    when using the `Property` parameter of `Select-Object`, a simple string is used,
    specifying the property you want returned. When you use a calculated property,
    however, you provide `Select-Object` with a hashtable containing the name of the
    property to return and an expression that runs when `Select-Object` receives input.
    The result of the expression will be the value of the new, calculated property.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你在`Select-Object` ❶中使用了一个计算属性。通常，在使用`Select-Object`的`Property`参数时，使用简单的字符串来指定你想返回的属性。但如果使用计算属性，你需要为`Select-Object`提供一个包含返回属性名称和在接收输入时运行的表达式的哈希表。表达式的结果将是新计算属性的值。
- en: By default, `Import-Excel` doesn’t add the worksheet name as a property to each
    object—meaning you won’t know which worksheet the row comes from. To account for
    this, you need to create a property called `Worksheet` on each row object so you
    have something to reference later.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Import-Excel`不会将工作表名称作为属性添加到每个对象中——这意味着你无法知道行来自哪个工作表。为了解决这个问题，你需要在每一行对象上创建一个名为`Worksheet`的属性，以便后续引用。
- en: Adding to Excel Spreadsheets
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向Excel电子表格添加数据
- en: In the previous section, you created a workbook from scratch. There will inevitably
    come a time when you need to add rows to a worksheet. Luckily, this is easy enough
    with the `ImportExcel` module; you just need to use the `Append` parameter on
    the `Export-Excel` command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你从头开始创建了一个工作簿。总会有那么一刻，你需要向工作表添加行。幸运的是，使用`ImportExcel`模块这非常简单；你只需要在`Export-Excel`命令中使用`Append`参数即可。
- en: As an example, let’s say you want to track process execution history on your
    computer. You’d like to export all the processes running on your computer over
    a period of time and then compare results in Excel later. To do so, you need to
    export all the running processes and make sure to include a timestamp on each
    row to indicate when the process information was gathered.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想跟踪你计算机上的进程执行历史。你希望导出你计算机上在一段时间内运行的所有进程，并在Excel中对结果进行比较。为此，你需要导出所有正在运行的进程，并确保在每行中包含一个时间戳，表示收集进程信息的时间。
- en: 'Let’s add another worksheet to our demo workbook and call it **ProcessesOverTime**.
    You’ll use a calculated property to add a timestamp property to each process row,
    like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在演示工作簿中添加另一个工作表，并将其命名为**ProcessesOverTime**。你将使用计算属性为每个进程行添加一个时间戳属性，像这样：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run this command, and then open the Processes workbook. You should see a worksheet
    called ProcessesOverTime with a list of all running processes on your computer,
    and an additional timestamp column indicating when the process information was
    queried.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，打开进程工作簿。你应该能看到一个名为ProcessesOverTime的工作表，列出计算机上所有运行的进程，并且还有一个附加的时间戳列，指示进程信息被查询的时间。
- en: 'At this point, you’ll append additional rows to the worksheet by using the
    same command you just used, but this time with the `Append` parameter. This command
    can be run as many times as you like. It will just keep appending rows to the
    worksheet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你将通过使用刚才使用的相同命令，但这次加上`Append`参数，向工作表附加更多行。这个命令可以执行多次，每次都会将行附加到工作表中：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you collect your data, you can review your Excel workbook and all the process
    information you collected.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集了数据，你可以查看你的Excel工作簿以及所有收集到的进程信息。
- en: 'Project 2: Creating a Windows Service Monitoring Tool'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目2：创建一个Windows服务监控工具
- en: Let’s put together the skills you learned in this section and work on another
    mini-project. This time, you’ll build a process to track Windows service states
    over time and record them to an Excel worksheet. Then, you’ll build a report showing
    when various services have changed state—basically, you’re making a lo-fi monitoring
    tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将你在本节中学到的技能结合起来，进行另一个迷你项目。这一次，你将构建一个进程来跟踪Windows服务的状态变化并将其记录到Excel工作表中。然后，你将生成一份报告，展示各个服务何时发生状态变化——基本上，你在制作一个低成本的监控工具。
- en: The first thing you want to do is figure out how to pull all Windows services,
    returning only their name and state. You can do this easily enough by running
    `Get-Service | Select-Object -Property Name,Status`. Next, you need to get a timestamp
    on each row in the Excel worksheet. Just as you did in the lesson, you’ll use
    a calculated property to do this; see [Listing 10-11](ch10.xhtml#ch10list11).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要弄清楚如何拉取所有Windows服务，并仅返回它们的名称和状态。你可以通过运行`Get-Service | Select-Object -Property
    Name,Status`来轻松实现这一点。接下来，你需要在每一行Excel工作表中添加一个时间戳。就像在课程中一样，你将使用计算属性来实现这一点；见[清单10-11](ch10.xhtml#ch10list11)。
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 10-11: Exporting service states*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-11：导出服务状态*'
- en: You should now have an Excel workbook created called *ServiceStates.xlsx* with
    a single worksheet called Services that’ll look something like [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经创建了一个名为*ServiceStates.xlsx*的Excel工作簿，里面有一个名为Services的工作表，内容大致如下所示：[图10-3](ch10.xhtml#ch10fig3)。
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig03.jpg)'
- en: '*Figure 10-3: The Excel workbook*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：Excel工作簿*'
- en: Before running the same command again, let’s change the state of various Windows
    services. This will allow you to track changes over time. Stop and start a few
    services to change their states. Then run the same command as in [Listing 10-11](ch10.xhtml#ch10list11),
    although this time using the `Append` parameter to `Export-Excel`. This will get
    you some data to work with. (Don’t forget to use the `Append` parameter, or the
    command will overwrite the existing worksheet!)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次运行相同的命令之前，让我们更改一些Windows服务的状态。这将允许你跟踪状态的变化。停止并启动一些服务以更改它们的状态。然后像在[清单10-11](ch10.xhtml#ch10list11)中一样运行相同的命令，不过这次使用`Append`参数进行`Export-Excel`。这将为你提供一些可以使用的数据。（别忘了使用`Append`参数，否则命令会覆盖现有的工作表！）
- en: Once you have the data, it’s time to summarize it. Excel provides multiple ways
    to do this, but for now, you’ll stick with a pivot table. A *pivot table* is a
    way to summarize data by grouping one or more properties together and then performing
    an action on those properties’ corresponding values (counting, adding, and so
    on). Using a pivot table, you can easily spot which services changed states and
    when they did so.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到数据后，是时候对其进行汇总了。Excel提供了多种方法来实现这一点，但现在你将使用透视表。*透视表*是一种通过将一个或多个属性分组，然后对这些属性的对应值执行某些操作（如计数、求和等）来汇总数据的方法。使用透视表，你可以轻松查看哪些服务发生了状态变化，以及它们何时发生变化。
- en: You’ll use the `IncludePivotTable`, `PivotRows`, `PivotColumns`, and `PivotData`
    parameters to create a summary pivot table ([Figure 10-4](ch10.xhtml#ch10fig4)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`IncludePivotTable`、`PivotRows`、`PivotColumns`和`PivotData`参数来创建一个汇总透视表（见[图10-4](ch10.xhtml#ch10fig4)）。
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: Service state pivot table*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：服务状态透视表*'
- en: As you can see in [Listing 10-12](ch10.xhtml#ch10list12), you’re reading the
    data in the Services worksheet and using that data to create a pivot table.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[清单 10-12](ch10.xhtml#ch10list12)中看到的，你正在读取 Services 工作表中的数据，并使用这些数据创建数据透视表。
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-12: Creating an Excel pivot table with PowerShell*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：使用 PowerShell 创建 Excel 数据透视表*'
- en: The `ImportExcel` PowerShell module has a suite of options you can use here.
    If you want to keep working with this dataset, play around with it and see what
    you can do. Take a look at the ImportExcel GitHub repository ([*https://github.com/dfinke/ImportExcel*](https://github.com/dfinke/ImportExcel)),
    or if you want to use different data, give that a go. As long as you have the
    data, PowerShell can manipulate and represent it just about any way you like!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImportExcel` PowerShell 模块提供了一系列选项供你使用。如果你想继续使用这个数据集，随意操作并查看你能做些什么。看看 ImportExcel
    GitHub 仓库（[*https://github.com/dfinke/ImportExcel*](https://github.com/dfinke/ImportExcel)），或者如果你想使用其他数据，尝试一下。只要你有数据，PowerShell
    就能以几乎任何你喜欢的方式进行操作和表示！'
- en: JSON Data
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 数据
- en: If you’ve been working in tech for the last five years, you’ve probably read
    some JSON. Created in the early 2000s, *JavaScript Object Notation (JSON)* is
    a machine-readable, human-understandable language that represents hierarchical
    sets of data. As its name might suggest, it’s heavily used in JavaScript applications,
    meaning it has a strong presence in web development.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在过去五年里一直从事技术工作，你可能已经读过一些 JSON。JSON 是在 2000 年代初期创建的，*JavaScript 对象表示法（JSON）*是一种机器可读、人类可理解的语言，用于表示层级数据集。正如它的名字所示，它在
    JavaScript 应用程序中被广泛使用，这意味着它在 web 开发中占有重要地位。
- en: A recent surge in the number of online services that use a *REST API*—a technology
    used to send data between client and server—has led to a similar surge in the
    use of JSON. If you’re doing anything with the web, JSON is a good format to know,
    and it’s one you can easily manage in PowerShell.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，使用 *REST API*（一种用于在客户端和服务器之间传输数据的技术）在线服务的数量激增，导致了 JSON 使用量的激增。如果你从事任何与 web
    相关的工作，JSON 是一个值得了解的格式，而且在 PowerShell 中也很容易管理。
- en: Reading JSON
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取 JSON
- en: 'Similar to reading the CSVs, you can read JSON a couple of ways in PowerShell:
    with parsing or no parsing. Since JSON is just plaintext, PowerShell treats it
    as a string by default. As an example, look at the JSON file *Employees.json*
    found in this chapter’s resources, reproduced here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于读取 CSV，PowerShell 中读取 JSON 的方式有几种：有解析和无解析。由于 JSON 本质上是纯文本，PowerShell 默认将其视为字符串。例如，看看本章资源中找到的
    JSON 文件 *Employees.json*，这里重新展示一下：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want only the string output, you can use `Get-Content -Path Employees``.json
    -Raw` to read the file and return a string. But there’s not much you can do with
    a string. You need structure. To get that, you need something that understands
    the JSON schema (the way individual nodes and arrays of nodes are represented
    in JSON) and can parse the file accordingly. You need the `ConvertFrom-Json` cmdlet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要字符串输出，可以使用 `Get-Content -Path Employees``.json -Raw` 来读取文件并返回字符串。但你不能仅用字符串做太多事。你需要结构化的数据。为了得到这些，你需要一些能够理解
    JSON 模式（即各个节点和节点数组在 JSON 中如何表示）并能据此解析文件的工具。你需要 `ConvertFrom-Json` cmdlet。
- en: The `ConvertFrom-Json` cmdlet is a native cmdlet in PowerShell that takes raw
    JSON as input and converts it into PowerShell objects. You can see in [Listing
    10-13](ch10.xhtml#ch10list13) that PowerShell knows `Employees` is a property
    now.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertFrom-Json` cmdlet 是 PowerShell 中的一个原生命令，它接受原始的 JSON 输入，并将其转换为 PowerShell
    对象。你可以在[清单 10-13](ch10.xhtml#ch10list13)中看到，PowerShell 现在知道 `Employees` 是一个属性。'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-13: Converting JSON to objects*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-13：将 JSON 转换为对象*'
- en: 'If you take a look at the `Employees` property, you’ll see that all the employee
    nodes have been parsed out, with each key representing a column header, and each
    value representing the row value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `Employees` 属性，你会看到所有员工节点都已被解析出来，每个键代表一列标题，每个值代表行的值：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Employees` property is now an array of objects that you can query and manipulate
    just as you would any other array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employees` 属性现在是一个对象数组，你可以像查询和操作任何其他数组一样，查询和操作它。'
- en: Creating JSON Strings
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 JSON 字符串
- en: 'Let’s say you have a whole bunch of data from a whole bunch of sources and
    you want to convert it all to JSON. What do you do? This is the magic of the `ConvertTo-Json`
    cmdlet: it can convert any object in PowerShell to JSON.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有来自多个来源的大量数据，并且想要将它们全部转换为 JSON。你该怎么办？这就是 `ConvertTo-Json` cmdlet 的神奇之处：它可以将
    PowerShell 中的任何对象转换为 JSON。
- en: 'As an example, let’s convert the CSV file you built earlier in the chapter
    into *Employees.json*. First, you need to import our CSV:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将你在本章前面构建的CSV文件转换为*Employees.json*。首先，你需要导入我们的CSV：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To do the conversion, you need to pipe the output to `ConvertTo-Json`, as in
    [Listing 10-14](ch10.xhtml#ch10list14).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行转换，你需要将输出通过管道传递给`ConvertTo-Json`，如[清单 10-14](ch10.xhtml#ch10list14)所示。
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 10-14: Converting objects to JSON*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-14：将对象转换为JSON*'
- en: 'As you might expect by now, there are a couple parameters you can pass in to
    modify the conversion. A nice one is the `Compress` parameter, which minifies
    the output by removing all the potentially unwanted line breaks:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能预料到的那样，你可以传递几个参数来修改转换。一项有用的参数是`Compress`，它通过去除所有可能不需要的换行符来缩小输出：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If it has a property and a property value, `ConvertTo-Json` can do its job.
    The property will always be the node key, and the property value will always be
    the node value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有一个属性和值，`ConvertTo-Json`就可以完成它的工作。属性总是节点的键，属性值总是节点的值。
- en: 'Project 3: Querying and Parsing a REST API'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目3：查询和解析REST API
- en: 'Now that you know how to parse JSON, let’s do something a little fancier: let’s
    use PowerShell to query a REST API and parse the results. You could use just about
    any REST API, but some require authentication, and it’ll be easier to do this
    without the extra steps. Let’s use one that doesn’t require authentication. I’ve
    found a REST API at *postcodes.io*, a service that allows you to query UK postal
    codes from various criteria.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何解析JSON了，接下来我们做一些更高级的操作：使用PowerShell查询一个REST API并解析结果。你可以使用几乎任何REST API，但有些需要身份验证，因此不涉及这些额外步骤会更容易。我们使用一个不需要身份验证的API。我找到一个不需要身份验证的REST
    API，它来自*postcodes.io*，这是一个允许你根据不同标准查询英国邮政编码的服务。
- en: 'The URI you’ll use is *[http://api.postcodes.io/random/postcodes](http://api.postcodes.io/random/postcodes)*.
    When you access this URI, it will query the *postcodes.io* API service and return
    a random postcode in JSON form. To query this URI, you’ll use PowerShell’s `Invoke-WebRequest`
    cmdlet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的URI是* [http://api.postcodes.io/random/postcodes](http://api.postcodes.io/random/postcodes)*。当你访问这个URI时，它会查询*postcodes.io*
    API服务，并返回一个随机的邮政编码，格式为JSON。要查询此URI，你将使用PowerShell的`Invoke-WebRequest` cmdlet：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In Windows PowerShell, `Invoke-WebRequest` relies on Internet Explorer. If you
    don't have Internet Explorer on your computer, you may have to use the `-UseBasicParsing`
    parameter to remove the dependency. “Advanced” parsing breaks down the resulting
    HTML output a bit more but it's not needed in all cases.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PowerShell中，`Invoke-WebRequest`依赖于Internet Explorer。如果你的计算机上没有Internet
    Explorer，你可能需要使用`-UseBasicParsing`参数来去除该依赖。 “高级”解析会稍微详细地拆解结果的HTML输出，但并不是所有情况下都需要。
- en: 'Now, let’s see if you can convert the result into a PowerShell object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你能否将结果转换为PowerShell对象：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can convert the response to JSON without a problem. But you have to use
    two commands, `Invoke-WebRequest` and `ConvertFrom-Json`. Wouldn’t life be great
    if you could use only one? It turns out that PowerShell has a command that will
    do everything for you: `Invoke-RestMethod`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以毫无问题地将响应转换为JSON。但你必须使用两个命令，`Invoke-WebRequest`和`ConvertFrom-Json`。如果你只需要使用一个命令，生活是不是会更美好？事实证明，PowerShell有一个命令可以为你完成所有操作：`Invoke-RestMethod`。
- en: 'The `Invoke-RestMethod` cmdlet is similar to `Invoke-WebRequest`; it sends
    various HTTP verbs to web services and returns the response. Because the *postcodes.io*
    API service does not require any authentication, you can simply use the `Uri`
    parameter on `Invoke-RestMethod` to get the API response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-RestMethod` cmdlet类似于`Invoke-WebRequest`；它将各种HTTP请求方法发送到Web服务并返回响应。由于*postcodes.io*
    API服务不需要任何身份验证，你可以直接在`Invoke-RestMethod`中使用`Uri`参数来获取API响应：'
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can see that `Invoke-RestMethod` returns an HTTP status code and the response
    from the API in the `result` property. So where’s the JSON? Well, just as you
    wanted, it’s already been converted to an object for you. There’s no need to manually
    convert the JSON to an object, as you can use the `result` property:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`Invoke-RestMethod`返回了HTTP状态代码和来自API的响应，在`result`属性中。所以，JSON在哪里呢？如你所愿，它已经被转换为对象了。你无需手动将JSON转换为对象，因为你可以直接使用`result`属性：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Working with JSON in PowerShell is a straightforward process. With PowerShell’s
    easy-to-use cmdlets, you’re usually spared any complicated string parsing—simply
    pass in JSON, or a soon-to-be-JSONified object, into the pipeline and watch the
    magic happen!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中处理JSON是一个直接的过程。借助PowerShell易于使用的cmdlet，通常无需复杂的字符串解析——只需将JSON或即将转化为JSON的对象传入管道，然后看着魔法发生！
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter covered a few ways to structure data, as well as how to work with
    those structures in PowerShell. PowerShell’s native cmdlets make this process
    a breeze, abstracting away a lot of complicated code and leaving the user with
    easy-to-use commands. But don’t let its simplicity fool you: PowerShell can parse
    and manipulate nearly any kind of data. Even if it doesn’t have a native command
    to handle the data type, because of its .NET foundation, it’s able to dig into
    any .NET classes for any advanced concepts.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几种数据结构的构建方式，以及如何在 PowerShell 中处理这些结构。PowerShell 原生的 cmdlet 使得这个过程变得轻松，它抽象了许多复杂的代码，提供了简单易用的命令。但不要让它的简洁性让你掉以轻心：PowerShell
    可以解析和操作几乎任何类型的数据。即便它没有原生命令来处理某种数据类型，由于基于 .NET 框架，它也能够深入到任何 .NET 类中，处理任何高级概念。
- en: In the next chapter, we’ll work with Microsoft’s Active Directory (AD). Full
    of repetitive tasks, AD is a common place to start when learning to use PowerShell;
    we’ll spend a lot of time on this great resource throughout the rest of this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习微软的活动目录（AD）。活动目录充满了重复的任务，是学习使用 PowerShell 时常见的起点；在本书的其余部分，我们将花费大量时间在这一重要资源上。
