- en: '**G  More ROM Photography**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**G.1 TMS320M10, C15, C25, C5x**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caps0ff (2020a) describes the photography and reverse engineering of TMS320M10
    chips in Eighties arcade games from Taoplan, such as Flying Shark and Kyukyoku
    Tiger. The same technique works on early successors of the M10, such as the TMS320C25.
  prefs: []
  type: TYPE_NORMAL
- en: Caps0ff also mentions prior work into the TMS320C15, which used a contact ROM
    instead of a diffusion ROM. Bits in that chip used a different ordering scheme,
    and those in the popular BSMT2000 audio chip, a preprogrammed variant of the C15,
    have also been extracted by photography.^([1](footnotes.xhtml#app7fn1))
  prefs: []
  type: TYPE_NORMAL
- en: 'A TMS320’s ROM ID is usually found near the model number, such as D70015 in
    their example. “Eh,” you might ask, “why do I care about their model number so
    many years after manufacturing, when all records have surely been lost?” Well,
    Caps0ff shares a lovely trick for this: in a mask-programmed ROM that has a unique
    mask for each customer, such as high-volume TMS320 chips, the ROM serial number
    is on the same mask as the ROM bits. So if you delayer to clarify the serial number,
    you will *also* be clarifying the ROM bits. They are on the same layer at exactly
    the same depth.'
  prefs: []
  type: TYPE_NORMAL
- en: In the M10, this was just the trick. Removing a few layers to clarify the serial
    number made the bits pop right out, when they had been barely visible from the
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0388-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure G.1: BSMT2000 ROM from a TMS320C15'
  prefs: []
  type: TYPE_NORMAL
- en: Caps0ff (2020b) describes the process of reverse engineering the TMS320C50 and
    TMS320C53 ROMs. The C53 from an arcade cabinet was their real target. By first
    dumping the ROM image from a C50 development kit with a debugger, then comparing
    that file to photographs of the ROM bits, they were able to know the ordering
    of the ROM bits in the C53, leaving only the bank ordering to guess. (The C53
    has four banks, while the C50 has just one.) This ROM format is now one of many
    supported in Zorrom.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the TMS320 chips can also be dumped by abusing their microprocessor
    mode to execute external memory. Details for this trick can be found in [Chapter
    F.2](app06.xhtml#app06_2).
  prefs: []
  type: TYPE_NORMAL
- en: '**G.2 CH340 Unknown Architecture**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cornateanu (2021) is a general tutorial on decapsulation and delayering chips
    for photography and ROM recovery, and the CH340 USB/Serial controller is its example
    target. The top metal layer hides the bits, keeping them invisible from the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Cornateanu describes delayering the chip with HF, which removed the top metal
    layer to expose the bits. From the look of his photos it’s a diffusion ROM, but
    the dice are quite small and I’ve had considerable trouble reproducing his work
    in my own lab.
  prefs: []
  type: TYPE_NORMAL
- en: Bit extraction was performed with Rompar, but because the CPU architecture was
    (and remains) unknown, the bits were decoded to bytes with Bitviewer, rather than
    Zorrom. Bit order was determined by looking at the address line decoder circuitry,
    then confirmed by recognizing USB descriptor tables and strings.
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the ROM, he knew the memory contents but still not the CPU
    architecture, which is a weird one built around 14-bit words. Writing an IDA Pro
    plugin for this architecture remains a work in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '**G.3 Intel 8271 New ISA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Evans (2020) describes a photographic dump of the Intel 8271 floppy controller’s
    mask ROM, which contains 864 bytes. This chip is also sold as the NEC D765.
  prefs: []
  type: TYPE_NORMAL
- en: The order was successfully guessed as left-to-right then top-to-bottom, MSBit-first,
    with bytes built from one bit per 8-bit group. Bits were inverted. That gave the
    first few bytes as `fc 06 02 f7`. This happened to be correct, but the harder
    part was in figuring out the instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering an instruction set requires some hints as to a starting
    position. Ken Shirriff’s encyclopedic knowledge came to the rescue. He found that
    Louie, Wipfli, and Ebright (1977) is a conference presentation on the chip’s design,
    including instruction counts and a die photograph. Ken also found that Louie had
    filed a patent, US4152761A, that describes the chip’s design.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these sources and a ton of study of the instruction PLA bits, Evans
    reverse engineered much of the instruction set and then enough of the ROM to come
    up with a way to write raw floppy disk tracks. This made it possible to clone
    BBC Micro floppy disks, only a few decades too late for it to be profitable in
    piracy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0391-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure G.2: Intel 8271 ROM'
  prefs: []
  type: TYPE_NORMAL
- en: '**G.4 Nintendo 64 CIC**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like the CIC chip of the Nintendo NES described in [Chapter 25](ch25.xhtml#ch25),
    the Nintendo 64 uses a 4-bit Sharp microcontroller in the SM5 family to enforce
    licensing, so third parties cannot make their own games. Unlike the original NES,
    the N64’s CIC successfully prevented the appearance of unlicensed cartridges for
    the entirety of this console’s commercial lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: That is not, however, to say that the scheme lasted forever. Eighteen years
    after launch, the N64’s CIC chip was successfully broken independently by two
    teams and with two methods.
  prefs: []
  type: TYPE_NORMAL
- en: Kammerstetter et al. (2014) describes a technique for reverse engineering the
    test mode of the CIC chip, allowing a sort of debugger to be attached, which can
    then read the program more or less directly out of ROM.
  prefs: []
  type: TYPE_NORMAL
- en: As a parallel effort, Ryan, H, and McMaster (2015) describes a dump of the mask
    ROM by Dash etching, in which junctions are stained to indicate their doping with
    a mixture of HNO[3], HF, and HAc acids under a strong light for a few seconds.
    Because Dash etching has a frustratingly low yield, they purchased a large number
    of cheap sports cartridges and decapsulated the CIC chips from these cartridges
    in bulk.
  prefs: []
  type: TYPE_NORMAL
