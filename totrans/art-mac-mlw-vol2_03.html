<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label="39"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch2">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">2</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">PARSING BINARIES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In the previous chapter, we enumerated running processes and extracted information that could help us heuristically detect malware. However, we didn’t cover how to examine the actual binary that backed each process. This chapter describes how to programmatically parse and analyze universal and Mach-O, the native executable binary file format of macOS.</p>&#13;
<p class="TX">You’ll learn how to extract information such as a binary’s dependencies and symbols, as well as detect whether the binary contains anomalies, such as encrypted data or instructions. This information will improve your ability to classify a binary as malicious or benign.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-18"/><span class="SANS_Futura_Std_Bold_B_11">Universal Binaries</span></h3>&#13;
<p class="TNI">The majority of Mach-O binaries are distributed in universal binaries. Called <i>fat binaries</i> in Apple parlance, these are containers for multiple <span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label="40"/>architecture-specific (but generally logically equivalent) Mach-O binaries known as <i>slices</i>. At runtime, the macOS dynamic loader (<i>dyld</i>) will load and then execute whichever embedded Mach-O binary best matches the host’s native architecture (for example, Intel or ARM). Because these embedded binaries hold the information you’re looking to extract, such as dependencies, you must first understand how to programmatically parse the universal binary.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-17"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting</span></h4>&#13;
<p class="TNI">Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> utility can inspect universal binaries. For example, the CloudMensis malware is distributed as a universal binary named <i>WindowServer</i> containing two Mach-O binaries: one compiled for Intel x86_64 and one for Apple Silicon ARM64 systems. Let’s execute <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> against CloudMensis. As you can see, the tool identifies it as a universal binary and shows its two embedded Mach-Os:</p>&#13;
&#13;
<pre><code>% <b>file CloudMensis/WindowServer</b>&#13;
CloudMensis/WindowServer: Mach-O universal binary with 2 architectures:&#13;
[x86_64:Mach-O 64-bit executable x86_64] [arm64:Mach-O 64-bit executable arm64]&#13;
&#13;
CloudMensis/WindowServer (for architecture x86_64): Mach-O 64-bit executable x86_64&#13;
CloudMensis/WindowServer (for architecture arm64):  Mach-O 64-bit executable arm64&#13;
</code></pre>&#13;
<p class="TX">To programmatically access these embedded binaries, we have to parse the universal binary’s header, which contains the offset of each Mach-O. Luckily, parsing the header is straightforward. Universal binaries start with a <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> structure. We can find relevant universal structures and constants in Apple’s SDK <i>mach-o/fat.h</i> header file:</p>&#13;
&#13;
<pre><code>struct fat_header {&#13;
    uint32_t    magic;        /* FAT_MAGIC or FAT_MAGIC_64 */&#13;
    uint32_t    nfat_arch;    /* number of structs that follow */&#13;
};&#13;
</code></pre>&#13;
<p class="TX">Apple’s comments in this header file indicate that <span class="SANS_TheSansMonoCd_W5Regular_11">magic</span>, the first member of the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> structure (an unsigned 32-bit integer), will contain the constant <span class="SANS_TheSansMonoCd_W5Regular_11">FAT_MAGIC</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">FAT_MAGIC_64</span>. The use of <span class="SANS_TheSansMonoCd_W5Regular_11">FAT_MAGIC_64</span> means the next structures are of the type <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch_64</span>, used when the following slice or offset to it is greater than 4GB.<sup><a role="doc-noteref" id="chapter2_1" href="#chapter2-1">1</a></sup> Comments in Apple’s <i>fat.h</i> header files note that support for this extended format is a work in progress, and universal binaries are rarely, if ever, so massive, so we’ll focus on the traditional <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure in this chapter.</p>&#13;
<p class="TX">Not mentioned in the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> structure’s comments is the fact that the values in the structure are assumed to be big-endian, a vestige of the OSX PPC days. Therefore, on little-endian systems such as Intel and Apple Silicon, when you read a universal binary into memory, values such as the 4 bytes for <span class="SANS_TheSansMonoCd_W5Regular_11">magic</span> will appear in reverse-byte order.</p>&#13;
<p class="TX">Apple accounts for this fact by providing the “swapped” magic constant <span class="SANS_TheSansMonoCd_W5Regular_11">FAT_CIGAM</span>. (Yes, <span class="SANS_TheSansMonoCd_W5Regular_11">CIGAM</span> is just magic backward.) The hexadecimal value of this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label="41"/>constant is <span class="SANS_TheSansMonoCd_W5Regular_11">0xbebafeca</span>.<sup><a role="doc-noteref" id="chapter2_2" href="#chapter2-2">2</a></sup> We can see this value by using <span class="SANS_TheSansMonoCd_W5Regular_11">xxd</span> to dump the bytes at the start of the CloudMensis universal binary. On a little-endian host, we make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">-e</span> flag to display the hexadecimal values in little-endian:</p>&#13;
&#13;
<pre><code>% <b>xxd -e -c 4 -g 0 CloudMensis/WindowServer</b>&#13;
00000000: bebafeca ...&#13;
...&#13;
</code></pre>&#13;
<p class="TX">The output, when interpreted as a 4-byte value, will have the host’s endianness applied, which explains why we see the swapped universal magic value <span class="SANS_TheSansMonoCd_W5Regular_11">FAT_CIGAM</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">0xbebafeca</span>).</p>&#13;
<p class="TX">Following the <span class="SANS_TheSansMonoCd_W5Regular_11">magic</span> field in the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> structure, we find the <span class="SANS_TheSansMonoCd_W5Regular_11">nfat_arch</span> field, which specifies the number of <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structures. We’ll find one <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure for each architecture-specific Mach-O binary embedded in the universal binary. As illustrated in <a href="chapter2.xhtml#fig2-1">Figure 2-1</a>, these structures immediately follow the fat header.</p>&#13;
<figure class="IMG"><img class="img6" id="fig2-1" src="../images/Figure2-1.jpg" alt="" width="728" height="663"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The layout of a universal binary</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> showed that CloudMensis contained two embedded Mach-Os, we’d expect to see <span class="SANS_TheSansMonoCd_W5Regular_11">nfat_arch</span> set to <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>. We confirm that this is the case by using <span class="SANS_TheSansMonoCd_W5Regular_11">xxd</span> once again. This time, though, we skip the <span class="SANS_TheSansMonoCd_W5Regular_11">-e</span> flag so as to keep the values in big endian:</p>&#13;
&#13;
<pre><code>% <b>xxd -c 4 -g 0 CloudMensis/WindowServer</b>&#13;
...&#13;
00000004: 00000002 ...&#13;
</code></pre>&#13;
<p class="TX">You can find the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure definition in the <i>fat.h</i> header file:</p>&#13;
&#13;
<pre><code>struct fat_arch {&#13;
    cpu_type_t       cputype;       /* cpu specifier (int) */&#13;
    cpu_subtype_t    cpusubtype;    /* machine specifier (int) */&#13;
    uint32_t         offset;        /* file offset to this object file */&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label="42"/>    uint32_t    size;     /* size of this object file */&#13;
    uint32_t    align;    /* alignment as a power of 2 */&#13;
};&#13;
</code></pre>&#13;
<p class="TX">The first two members of the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure specify the CPU type and subtype of the Mach-O binary, while the next two specify the offset and size of this slice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-18"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing</span></h4>&#13;
<p class="TNI">Let’s programmatically parse a universal binary and locate each embedded Mach-O binary. We’ll show two methods of doing so: using the older <span class="SANS_TheSansMonoCd_W5Regular_11">NX*</span> APIs compatible with older versions of macOS and the newer <span class="SANS_TheSansMonoCd_W5Regular_11">Macho*</span> APIs available on macOS 13 and newer.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can find the code mentioned in this chapter in the</i> <span class="note_LinkURL_Italic">parseBinary</span> <i>project in the book’s GitHub repository at</i> <a href="https://github.com/Objective-see/TAOMM"><span class="note_LinkURL_Italic">https://github.com/Objective-see/TAOMM</span><i>.</i></a></p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h5 class="H3" id="sec4"><span class="SANS_Futura_Std_Bold_Condensed_B_11">NX* APIs</span></h5>&#13;
<p class="TNI">We’ll begin by checking whether the file is indeed a universal binary. Then we’ll iterate over all <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structures, printing out their values, and leverage the <span class="SANS_TheSansMonoCd_W5Regular_11">NXFindBestFatArch</span> API to find the embedded binary most compatible with the host’s architecture. The system will load and execute this binary when the universal binary is launched, so it’s the one we’ll focus on in our analysis.</p>&#13;
<p class="TX">Your own code may instead want to examine each embedded Mach-O binary, especially as nothing stops a developer from making these binaries completely different. Although you’ll rarely find this to be the case, the 2023 3CX supply chain attack provides one notable exception. To trojanize the 3CX application, attackers subverted a legitimate universal binary that contained both Intel and ARM binaries, adding malicious code to the former and leaving the ARM binary untouched.</p>&#13;
<p class="TX">Let’s start by loading a file and performing some initial checks (<a href="chapter2.xhtml#Lis2-1">Listing 2-1</a>).</p>&#13;
<span id="Lis2-1"/>&#13;
<pre><code>#import &lt;mach-o/fat.h&gt;&#13;
#import &lt;mach-o/arch.h&gt;&#13;
#import &lt;mach-o/swap.h&gt;&#13;
#import &lt;mach-o/loader.h&gt;&#13;
&#13;
int main(int argc, const char* argv[]) {&#13;
&#13;
    NSData* data = [NSData dataWithContentsOfFile:[NSString stringWithUTF8String:argv[1]]]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    struct fat_header* fatHeader = (struct fat_header*)data.bytes; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    if((FAT_MAGIC == fatHeader-&gt;magic) || <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        (FAT_CIGAM == fatHeader-&gt;magic)) {&#13;
        printf("\nBinary is universal (fat)\n");&#13;
        struct fat_arch* bestArch = parseFat(argv[1], fatHeader);&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label="43"/>        ...&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Loading, validating, and finding the “best” slice of a universal binary</span></p>&#13;
<p class="TX">After reading the contents of the file into memory <span class="CodeAnnotation" aria-label="annotation1">❶</span> and typecasting the initial bytes to a <span class="SANS_TheSansMonoCd_W5Regular_11">struct fat_header *</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the code checks that it is indeed a universal binary <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Note that it checks both the big-endian (<span class="SANS_TheSansMonoCd_W5Regular_11">FAT_MAGIC</span>) and little-endian (<span class="SANS_TheSansMonoCd_W5Regular_11">FAT_CIGAM</span>) versions of the magic value.</p>&#13;
<p class="TX">To keep things simple, this code doesn’t support the large fat file format. Moreover, for production code, you should perform other sanity checks, such as ensuring that the file was successfully loaded and that it’s bigger than the size of a <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> structure.</p>&#13;
<p class="TX">The parsing logic lives in a helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">parseFat</span>, which you can see invoked in <a href="chapter2.xhtml#Lis2-1">Listing 2-1</a>. After printing out the fat header, this function will iterate over each <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure and return the most compatible Mach-O slice.</p>&#13;
<p class="TX">First, though, we must deal with any differences in endianness. The values in the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structures are always in big-endian order, so on little-endian systems such as Intel and Apple Silicon, we must swap them. To do so, we first invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NXGetLocalArchInfo</span> API to determine the host’s underlying byte order (<a href="chapter2.xhtml#Lis2-2">Listing 2-2</a>). We’ll use the value returned, a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">NXArchInfo</span> structure, to swap the endianness (as well as later, to determine the most compatible Mach-O).</p>&#13;
<span id="Lis2-2"/>&#13;
<pre><code>struct fat_arch* parseFat(const char* file, NSData* data) {&#13;
    const NXArchInfo* localArch = NXGetLocalArchInfo();&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Determining the local machine’s architecture</span></p>&#13;
<p class="TX">You might notice that the <span class="SANS_TheSansMonoCd_W5Regular_11">NXGetLocalArchInfo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">swap_*</span> APIs are marked as deprecated, although they’re still available and fully functional at the time of publication. You can use replacement <span class="SANS_TheSansMonoCd_W5Regular_11">macho_*</span> APIs, found in <i>mach-o/utils.h</i>, on macOS 13 and newer, and you’ll learn about this in the next section. However, until macOS 15, one of these new APIs was broken, so you may still want to stick to the older APIs.</p>&#13;
<p class="TX">Next, we perform the swap with the <span class="SANS_TheSansMonoCd_W5Regular_11">swap_fat_header</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">swap_fat_arch</span> functions (<a href="chapter2.xhtml#Lis2-3">Listing 2-3</a>).</p>&#13;
<span id="Lis2-3"/>&#13;
<pre><code>struct fat_header* header = (struct fat_header*)data.bytes;&#13;
&#13;
if(FAT_CIGAM == header-&gt;magic) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    swap_fat_header(header, localArch-&gt;byteorder); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    swap_fat_arch((struct fat_arch*)((unsigned char*)header + sizeof(struct fat_header)),&#13;
    header-&gt;nfat_arch, localArch-&gt;byteorder); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label="44"/>printf("Fat header\n");&#13;
printf("fat_magic %#x\n", header-&gt;magic);&#13;
printf("nfat_arch %d\n",  header-&gt;nfat_arch);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Swapping the fat header and fat architecture structures to match the host’s byte ordering</span></p>&#13;
<p class="TX">The code first checks whether a swap is needed <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Recall that if the magic constant of the fat header is <span class="SANS_TheSansMonoCd_W5Regular_11">FAT_CIGAM</span>, the code is executing on a little-endian host, so we should perform a swap. By invoking the helper APIs <span class="SANS_TheSansMonoCd_W5Regular_11">swap_fat_header</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">swap_fat_arch</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the code converts the header and all <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> values to match the host’s byte ordering, as returned by <span class="SANS_TheSansMonoCd_W5Regular_11">NXGetLocalArchInfo</span>. The latter API takes the number of <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structures to swap, which the code provides via the <span class="SANS_TheSansMonoCd_W5Regular_11">nfat_arch</span> field of the now-swapped fat header.</p>&#13;
<p class="TX">Once the header and all <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structures conform to the host’s byte ordering, the code can print out details of each embedded Mach-O binary that the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structures describe (<a href="chapter2.xhtml#Lis2-4">Listing 2-4</a>).</p>&#13;
<span id="Lis2-4"/>&#13;
<pre><code>struct fat_arch* arch = (struct fat_arch*)((unsigned char*)header + sizeof(struct fat_header));&#13;
&#13;
for(uint32_t i = 0; i &lt; header-&gt;nfat_arch; i++) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    printf("architecture %d\n", i);&#13;
    printFatArch(&amp;arch[i]);&#13;
}&#13;
&#13;
void printFatArch(struct fat_arch* arch) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    int32_t cpusubtype = 0;&#13;
    cpusubtype = arch-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    printf(" cputype %u (%#x)\n", arch-&gt;cputype, arch-&gt;cputype);&#13;
    printf(" cpusubtype %u (%#x)\n", cpusubtype, cpusubtype);&#13;
    printf(" capabilities 0x%#x\n", (arch-&gt;cpusubtype &amp; CPU_SUBTYPE_MASK) &gt;&gt; 24);&#13;
    printf(" offset %u (%#x)\n", arch-&gt;offset, arch-&gt;offset);&#13;
    printf(" size %u (%#x)\n", arch-&gt;size, arch-&gt;size);&#13;
    printf(" align 2^%u (%d)\n", arch-&gt;align, (int)pow(2, arch-&gt;align));&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Printing out each <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fat_arch</span> structure</span></p>&#13;
<p class="TX">The code starts by initializing a pointer to the first <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure, which comes immediately after the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span>. Then it iterates over each, bounded by the <span class="SANS_TheSansMonoCd_W5Regular_11">nfat_arch</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_header</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. To print out values from each <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure, the code invokes a helper function we’ve named <span class="SANS_TheSansMonoCd_W5Regular_11">printFatArch</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which first separates the CPU subtype and its capabilities, as both are found in the <span class="SANS_TheSansMonoCd_W5Regular_11">cpusubtype</span> member. Apple provides the <span class="SANS_TheSansMonoCd_W5Regular_11">CPU_SUBTYPE _MASK</span> constant to extract just the bits that describe the subtype <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Let’s run this code against CloudMensis. It outputs the following:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary CloudMensis/WindowServer</b>&#13;
Binary is universal (fat)&#13;
Fat header&#13;
fat_magic 0xcafebabe&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/>nfat_arch 2&#13;
architecture 0&#13;
    cputype 16777223 (0x1000007)&#13;
    cpusubtype 3 (0x3)&#13;
    capabilities 0x0&#13;
    offset 16384 (0x4000)&#13;
    size 708560 (0xacfd0)&#13;
    align 2^14 (16384)&#13;
architecture 1&#13;
    cputype 16777228 (0x100000c)&#13;
    cpusubtype 0 (0)&#13;
    capabilities 0x0&#13;
    offset 737280 (0xb4000)&#13;
    size 688176 (0xa8030)&#13;
    align 2^14 (16384)&#13;
</code></pre>&#13;
<p class="TX">From the output, we can see the malware’s two embedded Mach-O binaries:</p>&#13;
<ul class="ul">&#13;
<li class="BL">At offset 16384, a binary compatible with <span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_X86_64</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">0x1000007</span>) that is 708,560 bytes long</li>&#13;
<li class="BL">At offset 737280, a binary compatible with <span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_ARM64</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">0x100000c</span>) that is 688,176 bytes long</li>&#13;
</ul>&#13;
<p class="TX">To confirm the accuracy of this code, we can compare this output against the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span> command, whose <span class="SANS_TheSansMonoCd_W5Regular_11">-f</span> flag parses and displays fat headers:</p>&#13;
&#13;
<pre><code>% <b>otool -f CloudMensis/WindowServer</b>&#13;
Fat headers&#13;
fat_magic 0xcafebabe&#13;
nfat_arch 2&#13;
architecture 0&#13;
    cputype 16777223&#13;
    cpusubtype 3&#13;
    capabilities 0x0&#13;
    offset 16384&#13;
    size 708560&#13;
    align 2^14 (16384)&#13;
architecture 1&#13;
    cputype 16777228&#13;
    cpusubtype 0&#13;
    capabilities 0x0&#13;
    offset 737280&#13;
    size 688176&#13;
    align 2^14 (16384)&#13;
</code></pre>&#13;
<p class="TX">In the tool’s output, we see the same information about the malware’s two embedded binaries.</p>&#13;
<p class="TX">Next, let’s add some code to determine which of the embedded Mach-O binaries matches the host’s native architecture. Recall that we already invoked the <span class="SANS_TheSansMonoCd_W5Regular_11">NXGetLocalArchInfo</span> API to retrieve the host architecture. Moreover, we also showed how to compute the offset to the first <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/>which immediately follows the fat header. To find the natively compatible Mach-O, we can now invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NXFindBestFatArch</span> API (<a href="chapter2.xhtml#Lis2-5">Listing 2-5</a>).</p>&#13;
<span id="Lis2-5"/>&#13;
<pre><code>bestArchitecture = NXFindBestFatArch(localArch-&gt;cputype, localArch-&gt;&#13;
cpusubtype, arch, header-&gt;nfat_arch);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Determining a universal binary’s best architecture</span></p>&#13;
<p class="TX">We pass the API the host’s architecture, a pointer to the start of the <span class="SANS_TheSansMonoCd_W5Regular_11">fat _arch</span> structures, and the number of these structures. The <span class="SANS_TheSansMonoCd_W5Regular_11">NXFindBestFatArch</span> API will then determine the Mach-O binary from within the universal binary that is the most compatible with the host’s native architecture. Recall the <span class="SANS_TheSansMonoCd_W5Regular_11">parseFat</span> helper function returns this value and prints it out.</p>&#13;
<p class="TX">If we add this code to the binary parser and then run it again against CloudMensis, it outputs the following:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary CloudMensis/WindowServer</b>&#13;
...&#13;
best architecture match&#13;
    cputype 16777228 (0x100000c)&#13;
    cpusubtype 0 (0)&#13;
    capabilities 0x0&#13;
    offset 737280 (0xb4000)&#13;
    size 688176 (0xa8030)&#13;
    align 2^14 (16384)&#13;
</code></pre>&#13;
<p class="TX">On an Apple Silicon (ARM64) system, the code has correctly determined that the second embedded Mach-O binary, with a CPU type of <span class="SANS_TheSansMonoCd_W5Regular_11">16777228/0x100000c</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_ARM64</span>), is the most compatible Mach-O in the universal CloudMensis binary. When launching this universal binary, we can use the Kind column in Activity Monitor to confirm that macOS indeed selected and ran the Apple Silicon Mach-O (<a href="chapter2.xhtml#fig2-2">Figure 2-2</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-2" src="../images/Figure2-2.jpg" alt="" width="1390" height="717"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The CloudMensis binary</span> <span class="SANS_Futura_Std_Book_11">WindowServer</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">running as a native Apple Silicon binary</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>Another way to confirm that CloudMensis runs as a native Apple Silicon binary is to use the <i>enumerateProcesses</i> project presented in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. Recall that it extracts the architecture of each running process:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(1990):/Library/WebServer/share/httpd/manual/WindowServer&#13;
...&#13;
architecture: Apple Silicon&#13;
</code></pre>&#13;
<p class="TX">We receive the same result.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Macho* APIs</span></h5>&#13;
<p class="TNI">In macOS 13, Apple introduced the <span class="SANS_TheSansMonoCd_W5Regular_11">macho_*</span> APIs. Found in <i>mach-o/utils.h</i>, these APIs offer a simplified way to iterate over Mach-O binaries in a universal binary and select the most compatible one. The deprecated <span class="SANS_TheSansMonoCd_W5Regular_11">NX*</span> APIs still work for this purpose, but if you’re developing tools on macOS 13 or later, it’s wise to instead use the newer functions.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">macho_for_each_slice</span> API lets us extract a universal binary’s Mach-Os without having to manually parse the universal header or deal with the nuances of byte orderings. We invoke this function with a path to a file and callback block to run for each Mach-O slice. If invoked against a stand-alone Mach-O, the function will run its callback just once, and if the file isn’t a well- formed universal binary or Mach-O, the function will gracefully fail, meaning we don’t have to manually verify the file type ourselves. The <i>mach-o/utils.h</i> header file includes the possible return values and their meanings:</p>&#13;
&#13;
<pre><code>ENOENT - path does not exist&#13;
EACCES - path exists but caller does not have permission to access it&#13;
EFTYPE - path exists but it is not a Mach-o or fat file&#13;
EBADMACHO - path is a Mach-o file, but it is malformed&#13;
</code></pre>&#13;
<p class="TX">The callback block invoked for each embedded Mach-O has the following type:</p>&#13;
&#13;
<pre><code>void (^ _Nullable callback)(const struct mach_header* _Nonnull slice,&#13;
uint64_t offset, size_t size, bool* _Nonnull stop)&#13;
</code></pre>&#13;
<p class="TX">This type might look a little confusing at first, but if we focus solely on the parameters, we see that the callback will be invoked with a variety of information about the slice, including a pointer to a <span class="SANS_TheSansMonoCd_W5Regular_11">mach_header</span> structure, the slice’s offset, and its size.</p>&#13;
<p class="TX">The code in <a href="chapter2.xhtml#Lis2-6">Listing 2-6</a>, part of the <span class="SANS_TheSansMonoCd_W5Regular_11">parseFat</span> helper function, invokes <span class="SANS_TheSansMonoCd_W5Regular_11">macho_for_each_slice</span> to print out information about each embedded Mach-O. It also includes some basic error handling, which we can use to filter out files that are neither universal nor Mach-Os.</p>&#13;
<span id="Lis2-6"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label="48"/>struct fat_arch* parseFat(const char* file, struct fat_header* header) {&#13;
    ...&#13;
    if(@available(macOS 13.0, *)) {&#13;
        __block int count = 0;&#13;
&#13;
        int result = macho_for_each_slice(file,&#13;
        ^(const struct mach_header* slice, uint64_t offset, size_t size, bool* stop) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
            printf("architecture %d\n", count++); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            printf("offset %llu (%#llx)\n", offset, offset);&#13;
            printf("size %zu (%#zx)\n", size, size);&#13;
            printf("name %s\n\n", macho_arch_name_for_mach_header(slice)); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        });&#13;
        if(0 != result) {&#13;
            printf("ERROR: macho_for_each_slice failed\n");&#13;
&#13;
            switch(result) { <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
                case EFTYPE:&#13;
                    printf("EFTYPE: path exists but it is not a Mach-o or fat file\n\n");&#13;
                    break;&#13;
&#13;
                case EBADMACHO:&#13;
                    printf("EBADMACHO: path is a Mach-o file, but it is malformed\n\n");&#13;
                    break;&#13;
&#13;
                ...&#13;
            }&#13;
        }&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: Iterating over all embedded Mach-Os</span></p>&#13;
<p class="TX">This code invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">macho_for_each_slice</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. In the callback block, we print out a counter variable followed by the slice’s offset and size <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We also make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">macho_arch_name_for_mach_header</span> function to print out the name of each slice’s architecture <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">If the user-specified file isn’t a well-formed universal or Mach-O binary, the function will fail. The code handles this, printing out a generic error message, as well as additional information for common errors <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">If we add this code to the <i>parseBinary</i> project and then run it against the CloudMensis universal binary, it should print out the same offset and size values for the malware’s two embedded Mach-Os as the code that leveraged the <span class="SANS_TheSansMonoCd_W5Regular_11">NX*</span> APIs:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary CloudMensis/WindowServer</b>&#13;
...&#13;
architecture 0&#13;
    offset 16384 (0x4000)&#13;
    size 708560 (0xacfd0)&#13;
    name x86_64&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label="49"/>architecture 1&#13;
    offset 737280 (0xb4000)&#13;
    size 688176 (0xa8030)&#13;
    name arm64&#13;
</code></pre>&#13;
<p class="TX">Now, what about finding the most compatible slice, or the one that the host would load and run if the universal binary were executed? The <span class="SANS_TheSansMonoCd_W5Regular_11">macho _best_slice</span> function is designed to return exactly that. It takes a path to a file to inspect and a callback block to invoke with the best slice. Add the function in <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a> to the previous code.</p>&#13;
<span id="Lis2-7"/>&#13;
<pre><code>result = macho_best_slice(argv[1],&#13;
^(const struct mach_header* _Nonnull slice, uint64_t offset, size_t sliceSize) {&#13;
    printf("best architecture\n");&#13;
    printf("offset %llu (%#llx)\n", offset, offset);&#13;
    printf("size %zu (%#zx)\n", sliceSize, sliceSize);&#13;
    printf("name %s\n\n", macho_arch_name_for_mach_header(slice));&#13;
});&#13;
if(0 != result) {&#13;
    printf("ERROR: macho_best_slice failed with %d\n", result);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Invoking <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">macho_best_slice</span> to find the best slice</span></p>&#13;
<p class="TX">If we run this against CloudMensis (on a version of macOS prior to 15), however, it fails with the value <span class="SANS_TheSansMonoCd_W5Regular_11">86</span>:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary CloudMensis/WindowServer</b>&#13;
...&#13;
ERROR: macho_best_slice failed with 86&#13;
</code></pre>&#13;
<p class="TX">According to the <i>mach-o/utils.h</i> header file, this error value maps to <span class="SANS_TheSansMonoCd_W5Regular_11">EBADARCH</span>, which means none of the slices can load. This is odd, considering that the <span class="SANS_TheSansMonoCd_W5Regular_11">NXFindBestFatArch</span> function identified the embedded ARM64 Mach-O binary as compatible with my Apple Silicon analysis machine. Moreover, this ARM64 Mach-O definitely runs, as you saw in <a href="chapter2.xhtml#fig2-2">Figure 2-2</a>. It turns out, as is often the case with new APIs from Apple, that the <span class="SANS_TheSansMonoCd_W5Regular_11">macho_best_slice</span> function was broken until macOS 15. On older versions of macOS, for any third-party universal binary on Apple Silicon systems, the function returns <span class="SANS_TheSansMonoCd_W5Regular_11">EBADARCH</span>.</p>&#13;
<p class="TX">Reverse engineering, as well as studying the code of <i>dyld</i>,<sup><a role="doc-noteref" id="chapter2_3" href="#chapter2-3">3</a></sup> revealed the cause of the error: instead of passing a list of compatible CPU types (such as <span class="SANS_TheSansMonoCd_W5Regular_11">arm64</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">x86_64</span>) to the slice selection function, the code incorrectly passed in only the CPU type for which the operating system was compiled. On Apple Silicon, this CPU type is <span class="SANS_TheSansMonoCd_W5Regular_11">arm64e</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">CPU_SUBTYPE_ARM64E</span>), used exclusively by Apple. This explains why the selection logic never chose slices in third-party universal binaries, which are compiled as <span class="SANS_TheSansMonoCd_W5Regular_11">arm64</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">x86_64</span> (but never <span class="SANS_TheSansMonoCd_W5Regular_11">arm64e</span>), and instead returned the <span class="SANS_TheSansMonoCd_W5Regular_11">EBADARCH</span> error.</p>&#13;
<p class="TX">You can read more about the bug in my write-up “Apple Gets an ‘F’ for Slicing Apples.”<sup><a role="doc-noteref" id="chapter2_4" href="#chapter2-4">4</a></sup> My analysis proposed a simple fix: instead of invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">GradedArchs::forCurrentOS</span> method, Apple should have invoked <span class="SANS_TheSansMonoCd_W5Regular_11">GradedArchs::launchCurrentOS</span> to obtain the correct list of compatible CPU <span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label="50"/>types. The good news is that Apple eventually took this recommendation, meaning that <span class="SANS_TheSansMonoCd_W5Regular_11">macho_best_slice</span> on macOS 15 and above works as expected.</p>&#13;
<p class="TX">Now that you know how to parse universal binaries, let’s turn our attention to the Mach-O binaries embedded within them.<sup><a role="doc-noteref" id="chapter2_5" href="#chapter2-5">5</a></sup></p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-19"/><span class="SANS_Futura_Std_Bold_B_11">Mach-O Headers</span></h3>&#13;
<p class="TNI">Mach-O binaries contain the information we’re after, such as dependencies and symbols. To programmatically extract these, we must parse the Mach-O’s header. In a universal binary, we can locate this header by analyzing the fat header and architecture structures, as you saw in the previous section. In a single-architecture, stand-alone Mach-O, finding the header is trivial, as it’s located at the start of the file.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-8">Listing 2-8</a> follows the code that identifies the best Mach-O within a universal binary. It confirms that the slice is indeed a Mach-O, then handles cases in which a file is a stand-alone Mach-O.</p>&#13;
<span id="Lis2-8"/>&#13;
<pre><code>NSData* data = [NSData dataWithContentsOfFile:[NSString stringWithUTF8String:argv[1]]];&#13;
&#13;
struct mach_header_64* machoHeader = (struct mach_header_64*)data.bytes; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
if((FAT_MAGIC == fatHeader-&gt;magic) ||&#13;
    (FAT_CIGAM == fatHeader-&gt;magic)) {&#13;
    // Removed the code that finds the best architecture, for brevity&#13;
    ...&#13;
    machoHeader = (struct mach_header_64*)(data.bytes + bestArch-&gt;offset); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
}&#13;
&#13;
if((MH_MAGIC_64 == machoHeader-&gt;magic) || <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    (MH_CIGAM_64 == machoHeader-&gt;magic)) {&#13;
    printf("binary is Mach-O\n");&#13;
    // Add code here to parse the Mach-O.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: Finding the relevant Mach-O header</span></p>&#13;
<p class="TX">After loading the file into memory, we typecast the bytes at the start of the file to a <span class="SANS_TheSansMonoCd_W5Regular_11">mach_header_64</span> structure <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the binary is universal, we find the <span class="SANS_TheSansMonoCd_W5Regular_11">fat_arch</span> structure that describes the most compatible embedded Mach-O. Using this structure’s <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span> member, we update the pointer to point to the embedded binary <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Before we parse the binary, we must verify that the pointer really points to the start of the Mach-O. We take a simple verification approach: checking for the presence of a Mach-O magic value <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Because the binary’s header and the host machine architecture could have different endianness, the code checks for both the <span class="SANS_TheSansMonoCd_W5Regular_11">MH_MAGIC_64</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">MH_CIGAM_64</span> constants, defined in Apple’s <i>mach-o/loader.h</i> header file:</p>&#13;
&#13;
<pre><code>#define MH_MAGIC_64 0xfeedfacf&#13;
#define MH_CIGAM_64 0xcffaedfe&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label="51"/>For the sake of simplicity, the code skips recommended sanity and error checks. For example, production code should, at the very minimum, ensure that the size of the read-in bytes is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">sizeof(struct mach_header_64)</span> before dereferencing offsets in the header.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Mach-O headers are of <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type mach_header or mach_header_64</span>. Recent versions of macOS support 64-bit code only, so this section focuses on</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mach_header_64</span>, <i>defined in </i><span class="note_Italic">mach-o/loader.h</span><i>.</i></p>&#13;
<p class="TX">Now that we’re sure we’re looking at a Mach-O, we can parse it. <a href="chapter2.xhtml#Lis2-9">Listing 2-9</a> defines a helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">parseMachO</span> for this purpose. It takes a pointer to the <span class="SANS_TheSansMonoCd_W5Regular_11">mach_header_64</span> structure.</p>&#13;
<span id="Lis2-9"/>&#13;
<pre><code>void parseMachO(struct mach_header_64* header) {&#13;
    if(MH_CIGAM_64 == machoHeader-&gt;magic) {&#13;
        swap_mach_header_64(machoHeader, ((NXArchInfo*)NXGetLocalArchInfo())-&gt;byteorder);&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Swapping the Mach-O header to match the host’s byte ordering</span></p>&#13;
<p class="TX">Because the binary’s header and the host machine could have a different endianness, the code first checks for the swapped Mach-O magic value. If you encounter it, swap the header via the <span class="SANS_TheSansMonoCd_W5Regular_11">swap_mach_header_64</span> API. Note here that the code makes use of the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">NXGetLocalArchInfo</span> function, but if you’re writing code for versions of macOS 13 or newer, you should use the more modern <span class="SANS_TheSansMonoCd_W5Regular_11">macho*</span> APIs (again noting that the <span class="SANS_TheSansMonoCd_W5Regular_11">macho_best_slice</span> function was broken until macOS 15).</p>&#13;
<p class="TX">To print out the Mach-O header, we write a helper function, <span class="SANS_TheSansMonoCd_W5Regular_11">printMachOHeader</span> (<a href="chapter2.xhtml#Lis2-10">Listing 2-10</a>).</p>&#13;
<span id="Lis2-10"/>&#13;
<pre><code>void printMachOHeader(struct mach_header_64* header) {&#13;
    int32_t cpusubtype = 0;&#13;
    cpusubtype = header-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK;&#13;
&#13;
    printf("Mach-O header\n");&#13;
    printf(" magic %#x\n", header-&gt;magic);&#13;
    printf(" cputype %u (%#x)\n", header-&gt;cputype, header-&gt;cputype);&#13;
    printf(" cpusubtype %u (%#x)\n", cpusubtype, cpusubtype);&#13;
    printf(" capabilities %#x\n", (header-&gt;cpusubtype &amp; CPU_SUBTYPE_MASK) &gt;&gt; 24);&#13;
&#13;
    printf(" filetype %u (%#x)\n", header-&gt;filetype, header-&gt;filetype);&#13;
&#13;
    printf(" ncmds %u\n", header-&gt;ncmds);&#13;
    printf(" sizeofcmds %u\n", header-&gt;sizeofcmds);&#13;
&#13;
    printf(" flags %#x\n", header-&gt;flags);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Printing out a Mach-O header</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label="52"/>You can find an overview of each header member in the comments of the <span class="SANS_TheSansMonoCd_W5Regular_11">mach_header_64</span> structure definition. For example, following the <span class="SANS_TheSansMonoCd_W5Regular_11">magic</span> field are the two fields that describe the binary’s compatible CPU type and subtype. The <span class="SANS_TheSansMonoCd_W5Regular_11">cpusubtype</span> member also contains the binary’s capabilities, and these can be extracted into their own field.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> type indicates whether the binary is a stand-alone executable or a loadable library. The next fields describe the number and size of the binary’s load commands, which we’ll make extensive use of shortly. Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">flags</span> member of the structure indicates additional optional features, such as whether the binary is compatible with address space layout randomization.</p>&#13;
<p class="TX">Let’s run the Mach-O parsing code against CloudMensis. After searching the universal header, the tool finds the compatible Mach-O header and then prints it out:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary CloudMensis/WindowServer</b>&#13;
Mach-O header:&#13;
    magic 0xfeedfacf&#13;
    cputype 16777228 (0x100000c)&#13;
    cpusubtype 0 (0)&#13;
    capabilities 0&#13;
    filetype 2 (0x2)&#13;
    ncmds 28&#13;
    sizeofcmds 4192&#13;
    flags 0x200085&#13;
</code></pre>&#13;
<p class="TX">This output matches that of Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span>, whose <span class="SANS_TheSansMonoCd_W5Regular_11">-h</span> flag instructs it to print out the Mach-O header:</p>&#13;
&#13;
<pre><code>% <b>otool -h CloudMensis/WindowServer</b>&#13;
...&#13;
CloudMensis/WindowServer (architecture arm64):&#13;
Mach header&#13;
 magic       cputype    cpusubtype   caps   filetype  ncmds  sizeofcmds  flags&#13;
 0xfeedfacf  16777228   0            0x00   2         28     4192        0x00200085&#13;
</code></pre>&#13;
<p class="TX">Running <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> flag converts the returned numerical values into symbols:</p>&#13;
&#13;
<pre><code>% <b>otool -hv CloudMensis/WindowServer</b>&#13;
...&#13;
CloudMensis/WindowServer (architecture arm64):&#13;
Mach header&#13;
magic        cputype cpusubtype caps filetype ncmds sizeofcmds flags&#13;
MH_MAGIC_64  ARM64   ALL        0x00 EXECUTE  28    4192       NOUNDEFS DYLDLINK&#13;
                                                               TWOLEVEL PIE&#13;
</code></pre>&#13;
<p class="TX">These values confirm that our tool works as expected.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label="53"/>&#13;
<h3 class="H1" id="sec7"><span id="h1-20"/><span class="SANS_Futura_Std_Bold_B_11">Load Commands</span></h3>&#13;
<p class="TNI">Load commands are instructions to <i>dyld</i> that immediately follow the Mach-O header. A header field named <span class="SANS_TheSansMonoCd_W5Regular_11">ncmds</span> specifies the number of load commands, and each command is a structure of type <span class="SANS_TheSansMonoCd_W5Regular_11">load_command</span> containing the command type (<span class="SANS_TheSansMonoCd_W5Regular_11">cmd</span>) and size (<span class="SANS_TheSansMonoCd_W5Regular_11">cmdsize</span>), as you can see here:</p>&#13;
&#13;
<pre><code>struct load_command {&#13;
   uint32_t cmd;        /* type of load command */&#13;
   uint32_t cmdsize;    /* total size of command in bytes */&#13;
};&#13;
</code></pre>&#13;
<p class="TX">Some load commands describe the segments in the binary, such as the <span class="SANS_TheSansMonoCd_W5Regular_11">__TEXT</span> segment that contains the binary’s code, while others describe dependencies, the location of the symbol table, and more. As such, code that aims to extract information found within Mach-Os will generally start by parsing load commands.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-11">Listing 2-11</a> defines a helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">findLoadCommand</span> for this purpose. It takes a pointer to a Mach-O header and the type of load command to find. After locating the start of the load commands, it iterates over each to create an array containing commands that match the specified type.</p>&#13;
<span id="Lis2-11"/>&#13;
<pre><code>NSMutableArray* findLoadCommand(struct mach_header_64* header, uint32_t type) {&#13;
    NSMutableArray* commands = [NSMutableArray array];&#13;
    struct load_command* command = NULL;&#13;
&#13;
    command = (struct load_command*)((unsigned char*)header + sizeof(struct mach_header_64)); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    for(uint32_t i = 0; i &lt; header-&gt;ncmds; i++) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        if(type == command-&gt;cmd) { <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
            [commands addObject:[NSValue valueWithPointer:command]]; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
        }&#13;
        command = (struct load_command*)((unsigned char*)command + command-&gt;cmdsize); <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
    }&#13;
&#13;
    return commands;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: Iterating over all load commands and collecting those that match a specified type</span></p>&#13;
<p class="TX">We start by calculating a pointer to the first load command, which immediately follows the Mach-O header <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then we iterate over all load commands, which appear one after another <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and check the <span class="SANS_TheSansMonoCd_W5Regular_11">cmd</span> member of each to see if it matches the specified type <span class="CodeAnnotation" aria-label="annotation3">❸</span>. As we can’t directly store pointers in an Objective-C array, we first create an <span class="SANS_TheSansMonoCd_W5Regular_11">NSValue</span> object with the load command’s address <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Finally, we advance to the next load command. Load commands can vary in size, so we use the current command’s <span class="SANS_TheSansMonoCd_W5Regular_11">cmdsize</span> field <span class="CodeAnnotation" aria-label="annotation5">❺</span> to find the next one.</p>&#13;
<p class="TX">With an understanding of load commands and a helper function that returns commands of interest, let’s now consider a few examples of pertinent information we can extract, starting with dependencies.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label="54"/>&#13;
<h3 class="H1" id="sec8"><span id="h1-21"/><span class="SANS_Futura_Std_Bold_B_11">Extracting Dependencies</span></h3>&#13;
<p class="TNI">One of the reasons to parse Mach-Os is to extract their <i>dependencies</i>: dynamic libraries that <i>dyld</i> will automatically load. Understanding the dependencies of a binary can provide insight into its likely capabilities or even uncover malicious dependencies. For example, CloudMensis links against the <i>DiskArbitration</i> framework, which provides APIs to interact with external disks. Using this framework’s APIs, the malware monitors for the insertion of removable USB drives so it can exfiltrate external files.</p>&#13;
<p class="TX">When writing code, we can often achieve the same outcome in several ways. For example, in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we extracted all loaded libraries and frameworks from a running process by leveraging <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span>. In this chapter, we’ll perform a similar task by manually parsing the Mach-O. This static approach will extract direct dependencies only, excluding recursion; that is to say, we won’t extract the dependencies of dependencies. Moreover, libraries directly loaded by the binary at runtime are not dependencies per se and thus will not be extracted. While simple, this technique should help us understand the Mach-O’s capabilities and doesn’t require executing external binaries like <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span>. Also, the code will run against any Mach-O binary without requiring it to be currently executing.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-19"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Dependency Paths</span></h4>&#13;
<p class="TNI">To extract a binary’s dependencies, we can enumerate its <span class="SANS_TheSansMonoCd_W5Regular_11">LC_LOAD_DYLIB</span> load commands, each of which contains a path to a library or framework on which the Mach-O depends. The <span class="SANS_TheSansMonoCd_W5Regular_11">dylib_command</span> structure describes these load commands:</p>&#13;
&#13;
<pre><code>struct dylib_command {&#13;
    uint32_t       cmd;          /* LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB, LC_REEXPORT_DYLIB */&#13;
    uint32_t       cmdsize;      /* includes pathname string */&#13;
    struct dylib   dylib;        /* the library identification */&#13;
};&#13;
</code></pre>&#13;
<p class="TX">We’ll extract these dependencies in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">extractDependencies</span> that accepts a pointer to a Mach-O header and returns an array containing the names of dependencies.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To keep things simple, we won’t take into account <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LC_LOAD_WEAK_DYLIB</span> load commands, which describe optional dependencies.</i></p>&#13;
<p class="TX">In <a href="chapter2.xhtml#Lis2-12">Listing 2-12</a>, the code starts by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">findLoadCommand</span> helper function to find load commands whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">LC_LOAD_DYLIB</span>. It then iterates over each of these load commands to extract the dependency’s path.</p>&#13;
<span id="Lis2-12"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label="55"/>NSMutableArray* extractDependencies(struct mach_header_64* header) {&#13;
    ...&#13;
    NSMutableArray* commands = findLoadCommand(header, LC_LOAD_DYLIB);&#13;
&#13;
    for(NSValue* command in commands) {&#13;
        // Add code here to extract each dependency.&#13;
    }&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Finding all <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LC_LOAD_DYLIB</span> load commands</span></p>&#13;
<p class="TX">Let’s now extract the name of each dependency. To understand how we’ll do so, take a look at the <span class="SANS_TheSansMonoCd_W5Regular_11">dylib</span> structure that describes a dependency. This structure is the last member of the <span class="SANS_TheSansMonoCd_W5Regular_11">dylib_command</span> structure used to describe <span class="SANS_TheSansMonoCd_W5Regular_11">LC_LOAD_DYLIB</span> load commands:</p>&#13;
&#13;
<pre><code>struct dylib {&#13;
    union lc_str  name;                  /* library's path name */&#13;
    uint32_t timestamp;                  /* library's build time stamp */&#13;
    uint32_t current_version;            /* library's current version number */&#13;
    uint32_t compatibility_version;      /* library's compatibility vers number*/&#13;
};&#13;
</code></pre>&#13;
<p class="TX">Of interest to us is the structure’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> field, whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">lc_str</span>. A comment in Apple’s <i>loader.h</i> file explains that we must first extract the offset to the dependency path and then use it to compute the path’s bytes and length (<a href="chapter2.xhtml#Lis2-13">Listing 2-13</a>).</p>&#13;
<span id="Lis2-13"/>&#13;
<pre><code>NSMutableArray* dependencies = [NSMutableArray array];&#13;
&#13;
for(NSValue* command in commands) {&#13;
    struct dylib_command* dependency = command.pointerValue; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    uint32_t offset = dependency-&gt;dylib.name.offset; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    char* bytes = (char*)dependency + offset;&#13;
    NSUInteger length = dependency-&gt;cmdsize-offset;&#13;
&#13;
    NSString* path = [[NSString alloc] initWithBytes:bytes length:length encoding:NSUTF8     StringEncoding]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    [dependencies addObject:path];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Extracting a dependency from an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LC_LOAD_DYLIB</span> load command</span></p>&#13;
<p class="TX">We previously stored the pointer to each matching load command as an <span class="SANS_TheSansMonoCd_W5Regular_11">NSValue</span> object, so we must first extract these <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then we extract the offset to the dependency path and use it to compute the path’s bytes and length <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Now we can easily extract the path into a string object and save it into an array <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We return this array containing all dependencies once the enumeration is complete.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label="56"/>When we compile and run this code against CloudMensis, it outputs the following:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary CloudMensis/WindowServer</b>&#13;
...&#13;
Dependencies: (count: 12): (&#13;
    ...&#13;
    "/usr/lib/libobjc.A.dylib",&#13;
    "/usr/lib/libSystem.B.dylib",&#13;
    ...&#13;
    "/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration",&#13;
    "/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration"&#13;
)&#13;
</code></pre>&#13;
<p class="TX">Notice the inclusion of the <i>DiskArbitration</i> framework we mentioned earlier. Once again, we can use <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span>, this time with the <span class="SANS_TheSansMonoCd_W5Regular_11">-L</span> flag, to confirm the accuracy of our code:</p>&#13;
&#13;
<pre><code>% <b>otool -L CloudMensis/WindowServer</b>&#13;
...&#13;
"/usr/lib/libobjc.A.dylib",&#13;
"/usr/lib/libSystem.B.dylib",&#13;
...&#13;
"/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration",&#13;
"/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration"&#13;
</code></pre>&#13;
<p class="TX">The dependencies extracted from CloudMensis via <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span> match those extracted by our code, so we can move on to analyzing them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-20"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Dependencies</span></h4>&#13;
<p class="TNI">The majority of CloudMensis’s dependencies are system libraries and frameworks, such as <i>libobjc.A.dylib</i> and <i>libSystem.B.dylib</i>. Essentially all Mach-O binaries link against these, and from the point of view of malware detection, they’re uninteresting. However, the <i>DiskArbitration</i> dependency is notable, as it provides the <span class="SANS_TheSansMonoCd_W5Regular_11">DA*</span> APIs to interact with external disks. Here is a snippet of CloudMensis’s decompiled binary code showing its interactions with the <i>DiskArbitration</i> APIs:</p>&#13;
&#13;
<pre><code>-(void)loop_usb {&#13;
    rax = DASessionCreate(**_kCFAllocatorDefault);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> DARegisterDiskAppearedCallback(rax, 0x0, OnDiskAppeared, 0x0);&#13;
    ...&#13;
}&#13;
&#13;
int OnDiskAppeared() {&#13;
    ...&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> r13 = DADiskCopyDescription(rdi);&#13;
    rax = CFDictionaryGetValue(r13, **_kDADiskDescriptionVolumeNameKey);&#13;
    r14 = [NSString stringWithFormat:@"/Volumes/%@", rax];&#13;
    ...&#13;
&#13;
    rax = [functions alloc];&#13;
    r15 = [rax randPathWithPrefix:0x64 isZip:0x0];&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label="57"/>    rax = [FileTreeXML alloc];&#13;
    [rax startFileTree:r14 dropPath:r15];&#13;
    ...&#13;
    [rax MoveToFileStore:r15 Copy:0x0];&#13;
    rax = [NSURL fileURLWithPath:r14];&#13;
    r14 = [NSMutableArray arrayWithObject:rax];&#13;
&#13;
    rax = [functions alloc];&#13;
    [rax SearchAndMoveFS:r14 removable:0x1];&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">First, in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">loop_usb</span>, the malware invokes various <span class="SANS_TheSansMonoCd_W5Regular_11">DiskArbitration</span> APIs to register a callback that the operating system will invoke automatically once a new disk appears <span class="CodeAnnotation" aria-label="annotation1">❶</span>. When this <span class="SANS_TheSansMonoCd_W5Regular_11">OnDiskAppeared</span> callback is invoked—for example, when an external USB drive is inserted—it calls other <span class="SANS_TheSansMonoCd_W5Regular_11">DA*</span> APIs, such as <span class="SANS_TheSansMonoCd_W5Regular_11">DADiskCopyDescription</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, to access information about the new disk. The remainder of the code in the <span class="SANS_TheSansMonoCd_W5Regular_11">OnDiskAppeared</span> callback is responsible for generating a file listing, then copying files off the drive into a custom file store. These files eventually get exfiltrated to the attacker’s remote command-and-control server.</p>&#13;
<p class="TX">Let’s run the dependency code against another malware sample that leverages even more frameworks to achieve a wide range of offensive capabilities. Mokes is a cross-platform cyber-espionage implant that has infected macOS users in attacks leveraging browser zero-days.<sup><a role="doc-noteref" id="chapter2_6" href="#chapter2-6">6</a></sup> Running the dependency extractor code against the malware’s binary, named <i>storeuserd</i>, generates the following output:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary Mokes/storeuserd</b>&#13;
...&#13;
Dependencies: (count: 25): (&#13;
    "/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration",&#13;
    "/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit",&#13;
    "/System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices",&#13;
    "/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices",&#13;
    "/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation",&#13;
    "/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation",&#13;
    "/System/Library/Frameworks/Security.framework/Versions/A/Security",&#13;
    "/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration",&#13;
    "/System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa",&#13;
    "/System/Library/Frameworks/Carbon.framework/Versions/A/Carbon",&#13;
    "/System/Library/Frameworks/AudioToolbox.framework/Versions/A/AudioToolbox",&#13;
    "/System/Library/Frameworks/CoreAudio.framework/Versions/A/CoreAudio",&#13;
    "/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore",&#13;
    "/System/Library/Frameworks/AVFoundation.framework/Versions/A/AVFoundation",&#13;
    "/System/Library/Frameworks/CoreMedia.framework/Versions/A/CoreMedia",&#13;
    "/System/Library/Frameworks/AppKit.framework/Versions/C/AppKit",&#13;
    "/System/Library/Frameworks/AudioUnit.framework/Versions/A/AudioUnit",&#13;
    "/System/Library/Frameworks/CoreWLAN.framework/Versions/A/CoreWLAN",&#13;
    ...&#13;
)&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label="58"/>Several of these dependencies shed light on the malware’s capabilities and could guide future analysis. For example, the malware leverages the <i>AVFoundation</i> framework to record audio and video from the mic and webcam of an infected host. It also uses <span class="SANS_TheSansMonoCd_W5Regular_11">CoreWLAN</span> to enumerate and monitor network interfaces and <span class="SANS_TheSansMonoCd_W5Regular_11">DiskArbitration</span> to monitor external storage drives to find and exfiltrate files of interest.</p>&#13;
<p class="TX">Of course, dependencies alone can’t prove that code is malicious. For example, a binary that links against the <span class="SANS_TheSansMonoCd_W5Regular_11">AVFoundation</span> isn’t necessarily spying on the user; it might be a legitimate videoconferencing app or simply be making use of the framework for benign multimedia-related tasks. However, taking a look at the following snippet of disassembly from Mokes confirms that it does indeed leverage <span class="SANS_TheSansMonoCd_W5Regular_11">AVFoundation</span> APIs in a nefarious manner:</p>&#13;
&#13;
<pre><code>rax = AVFAudioInputSelectorControl::createCaptureDevice();&#13;
...&#13;
rax = [AVCaptureDeviceInput deviceInputWithDevice:rax error:&amp;var_28];&#13;
...&#13;
QMetaObject::tr(..., "Could not connect the video recorder");&#13;
</code></pre>&#13;
<p class="TX">This excerpt shows the code interfacing with the webcam to spy on victims.</p>&#13;
<p class="TX">Another reason to extract dependencies from a Mach-O binary is to detect malicious subversions. ZuRu is one such example. Its malware authors surreptitiously trojanized popular applications such as iTerm by adding a malicious dependency to them, then distributed the applications via sponsored ads that would appear as the first result when users searched online for the applications.</p>&#13;
<p class="TX">The subversion was stealthy, as it left the original application’s functionality wholly intact. However, extracting dependencies quickly reveals the malicious dependency. To demonstrate this, let’s first extract the dependencies from a legitimate copy of iTerm2:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary /Applications/iTerm.app/Contents/MacOS/iTerm2</b>&#13;
...&#13;
Dependencies: (count: 33):&#13;
    "/usr/lib/libaprutil-1.0.dylib",&#13;
    "/usr/lib/libicucore.A.dylib",&#13;
    "/usr/lib/libc++.1.dylib",&#13;
    "@rpath/BetterFontPicker.framework/Versions/A/BetterFontPicker",&#13;
    "@rpath/SearchableComboListView.framework/Versions/A/SearchableComboListView",&#13;
    "/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory",&#13;
    ...&#13;
    "/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore",&#13;
    "/System/Library/Frameworks/WebKit.framework/Versions/A/WebKit",&#13;
    "/usr/lib/libsqlite3.dylib",&#13;
    "/usr/lib/libz.1.dylib"&#13;
)&#13;
</code></pre>&#13;
<p class="TX">Nothing unusual here. Now, if we extract the dependencies from a trojanized instance of iTerm, we uncover a new dependency, <i>libcrypto.2.dylib</i>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label="59"/>located in the application bundle. This dependency sticks out, not only because it doesn’t exist in the legitimate application but also because it’s the only dependency that uses the <span class="SANS_TheSansMonoCd_W5Regular_11">@executable_path</span> variable:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary ZuRu/iTerm.app/Contents/MacOS/iTerm2</b>&#13;
...&#13;
Dependencies: (count: 34):&#13;
    "/usr/lib/libaprutil-1.0.dylib",&#13;
    "/usr/lib/libicucore.A.dylib",&#13;
    "/usr/lib/libc++.1.dylib",&#13;
    "@rpath/BetterFontPicker.framework/Versions/A/BetterFontPicker",&#13;
    "@rpath/SearchableComboListView.framework/Versions/A/SearchableComboListView",&#13;
    "/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory",&#13;
    ...&#13;
    "/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore",&#13;
    "/System/Library/Frameworks/WebKit.framework/Versions/A/WebKit",&#13;
    "/usr/lib/libsqlite3.dylib",&#13;
    "/usr/lib/libz.1.dylib",&#13;
    "@executable_path/../Frameworks/libcrypto.2.dylib"&#13;
)&#13;
</code></pre>&#13;
<p class="TX">There is nothing inherently malicious about the <span class="SANS_TheSansMonoCd_W5Regular_11">@executable_path</span> variable; it simply tells the loader how to relatively resolve the library’s path (meaning the library is likely embedded in the same bundle as the executable). Nevertheless, the addition of a new dependency that referenced a newly added library clearly warranted additional analysis, and such analysis revealed that the dependency contained all of the malware’s malicious logic.<sup><a role="doc-noteref" id="chapter2_7" href="#chapter2-7">7</a></sup></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-22"/><span class="SANS_Futura_Std_Bold_B_11">Extracting Symbols</span></h3>&#13;
<p class="TNI">A binary’s symbols contain the names of the binary’s functions or methods and those of the APIs it imports. These function names can reveal the file’s capabilities and even provide indicators that it is malicious. For example, let’s extract the symbols from malware called DazzleSpy using the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">nm</span> tool:</p>&#13;
&#13;
<pre><code>% <b>nm DazzleSpy/softwareupdate</b>&#13;
...&#13;
"+[Exec doShellInCmd:]",&#13;
"-[ShellClassObject startPty]",&#13;
"-[MethodClass getIPAddress]",&#13;
"-[MouseClassObject PostMouseEvent::::]",&#13;
"-[KeychainClassObject getPasswordFromSecKeychainItemRef:]"&#13;
...&#13;
</code></pre>&#13;
<p class="TX">From the format of these symbols, we can tell that the malware was written in Objective-C. The Objective-C runtime requires method names to remain intact in the compiled binary, so understanding the binaries’ capabilities is often relatively easy. For example, the symbols embedded in DazzleSpy reveal methods that appear to execute shell commands, survey the system, post mouse events, and steal passwords from the keychain.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label="60"/>It’s worth noting, though, that nothing stops malware authors from using misleading method names, so you should never draw conclusions solely from extracted symbols. You might also encounter symbols that have been obfuscated (providing a pretty good indication that the binary has something to hide). Finally, the authors may have stripped a binary to remove symbols that aren’t essential for program execution.</p>&#13;
<p class="TX">Later in the <span class="SANS_TheSansMonoCd_W5Regular_11">nm</span> symbol output for DazzleSpy, we also find APIs that the malware imports from system libraries and frameworks:</p>&#13;
&#13;
<pre><code>_bind&#13;
_connect&#13;
_AVMediaTypeVideo&#13;
_AVCaptureSessionRuntimeErrorNotification&#13;
_NSFullUserName&#13;
_SecKeychainItemCopyContent&#13;
</code></pre>&#13;
<p class="TX">These include networking APIs such as <span class="SANS_TheSansMonoCd_W5Regular_11">bind</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">connect</span> related to the malware’s backdoor capabilities, <span class="SANS_TheSansMonoCd_W5Regular_11">AVFoundation</span> imports related to its remote desktop capabilities, and APIs to survey a system and grab items from the victim’s keychain.</p>&#13;
<p class="TX">How can we extract a Mach-O binary’s symbols programmatically? As you’ll see, this requires yet again parsing the binary’s load commands. We’ll focus specifically on the <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SYMTAB</span> load command, which contains information about a binary’s symbols found in the symbol table (hence the load command’s suffix <span class="SANS_TheSansMonoCd_W5Regular_11">SYMTAB</span>). This load command consists of a <span class="SANS_TheSansMonoCd_W5Regular_11">symtab_command</span> structure, defined in <i>loader.h</i>:</p>&#13;
&#13;
<pre><code>struct symtab_command {&#13;
    uint32_t        cmd;            /* LC_SYMTAB */&#13;
    uint32_t        cmdsize;        /* sizeof(struct symtab_command) */&#13;
    uint32_t        symoff;         /* symbol table offset */&#13;
    uint32_t        nsyms;          /* number of symbol table entries */&#13;
    uint32_t        stroff;         /* string table offset */&#13;
    uint32_t        strsize;        /* string table size in bytes */&#13;
};&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">symoff</span> member contains the offset of the symbol table, while <span class="SANS_TheSansMonoCd_W5Regular_11">nsyms</span> contains the number of entries in this table. The symbol table consists of <span class="SANS_TheSansMonoCd_W5Regular_11">nlist_64</span> structures, defined in <i>nlist.h</i>:</p>&#13;
&#13;
<pre><code>struct nlist_64 {&#13;
    union {&#13;
        uint32_t  n_strx;  /* index into the string table */&#13;
    } n_un;&#13;
    uint8_t n_type;        /* type flag, see below */&#13;
    uint8_t n_sect;        /* section number or NO_SECT */&#13;
    uint16_t n_desc;       /* see &lt;mach-o/stab.h&gt; */&#13;
    uint64_t n_value;      /* value of this symbol (or stab offset) */&#13;
};&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>Each <span class="SANS_TheSansMonoCd_W5Regular_11">nlist_64</span> structure in the symbol table contains an index to the string table, in the <span class="SANS_TheSansMonoCd_W5Regular_11">n_strx</span> field. We can find the string table’s offset in the <span class="SANS_TheSansMonoCd_W5Regular_11">symtab_command</span> structure’s <span class="SANS_TheSansMonoCd_W5Regular_11">stroff</span> field. By adding the specified index from <span class="SANS_TheSansMonoCd_W5Regular_11">n_strx</span> to this offset, we can retrieve the symbol as a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>-terminated string. Thus, to extract a binary’s symbols, we must perform the following steps:</p>&#13;
<p class="NLF">  1.  Find the <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SYMTAB</span> load command that contains the <span class="SANS_TheSansMonoCd_W5Regular_11">symtab_command</span> structure.</p>&#13;
<p class="NL">  2.  Use the <span class="SANS_TheSansMonoCd_W5Regular_11">symoff</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">symtab_command</span> structure to find the offset of the symbol table.</p>&#13;
<p class="NL">  3.  Use the <span class="SANS_TheSansMonoCd_W5Regular_11">stroff</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">symtab_command</span> structure to find the offset of the string table.</p>&#13;
<p class="NL">  4.  Iterate through all of the symbol table’s <span class="SANS_TheSansMonoCd_W5Regular_11">nlist_64</span> structures to extract each symbol’s index (<span class="SANS_TheSansMonoCd_W5Regular_11">n_strx</span>) into the string table.</p>&#13;
<p class="NLL">  5.  Apply this index to the string table to find the name of the symbol.</p>&#13;
<p class="TX">The function in <a href="chapter2.xhtml#Lis2-14">Listing 2-14</a> implements these steps. Given a pointer to a Mach-O header, it saves all symbols into an array and returns it to the caller.</p>&#13;
<span id="Lis2-14"/>&#13;
<pre><code>NSMutableArray* extractSymbols(struct mach_header_64* header) {&#13;
    NSMutableArray* symbols = [NSMutableArray array];&#13;
&#13;
    NSMutableArray* commands = findLoadCommand(header, LC_SYMTAB);&#13;
    struct symtab_command* symTableCmd = ((NSValue*)commands.firstObject).pointerValue; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    void* symbolTable = (((void*)header) + symTableCmd-&gt;symoff); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    void* stringTable = (((void*)header) + symTableCmd-&gt;stroff); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    struct nlist_64* nlist = (struct nlist_64*)symbolTable; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
    for(uint32_t j = 0; j &lt; symTableCmd-&gt;nsyms; j++) { <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
        char* symbol = (char*)stringTable + nlist-&gt;n_un.n_strx; <span class="codewide_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
        if(0 != symbol[0]) {&#13;
            [symbols addObject:[NSString stringWithUTF8String:symbol]];&#13;
        }&#13;
        nlist++;&#13;
    }&#13;
    return symbols;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Extracting a binary’s symbols</span></p>&#13;
<p class="TX">Because this function is somewhat involved, we’ll walk through it in detail. First, it finds the <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SYMTAB</span> load command by means of the <span class="SANS_TheSansMonoCd_W5Regular_11">findLoadCommand</span> helper function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It then uses the fields in the load command’s <span class="SANS_TheSansMonoCd_W5Regular_11">symtab _command</span> structure to compute the in-memory address of both the symbol table <span class="CodeAnnotation" aria-label="annotation2">❷</span> and the string table <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After initializing a pointer to the first <span class="SANS_TheSansMonoCd_W5Regular_11">nlist_64</span> structure, found at the start of the symbol table <span class="CodeAnnotation" aria-label="annotation4">❹</span>, the code iterates over it and all subsequent <span class="SANS_TheSansMonoCd_W5Regular_11">nlist_64</span> structures <span class="CodeAnnotation" aria-label="annotation5">❺</span>. For each of these structures, it adds the index to the string table to compute the address of the symbol’s string representation <span class="CodeAnnotation" aria-label="annotation6">❻</span>. If the symbol is not <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, the code adds it to an array to return to the caller.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label="62"/>Let’s compile and run this code against DazzleSpy. As we can see, the code is able to extract the malware’s method names, as well as the API imports it invokes:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary DazzleSpy/softwareupdate</b>&#13;
...&#13;
Symbols (count: 3101): (&#13;
&#13;
"-[ShellClassObject startPty]",&#13;
"-[ShellClassObject startTask]",&#13;
&#13;
"-[MethodClass getDiskSize]",&#13;
"-[MethodClass getDiskFreeSize]",&#13;
"-[MethodClass getDiskSystemSize]",&#13;
"-[MethodClass getAllhardwareports]",&#13;
"-[MethodClass getIPAddress]",&#13;
&#13;
"-[MouseClassObject PostMouseEvent::::]",&#13;
"-[MouseClassObject postScrollEvent:]",&#13;
&#13;
"-[KeychainClassObject getPass:cmdTo:]",&#13;
"-[KeychainClassObject getPasswordFromSecKeychainItemRef:]",&#13;
&#13;
"_bind",&#13;
"_connect",&#13;
...&#13;
"_AVMediaTypeVideo",&#13;
"_AVCaptureSessionRuntimeErrorNotification",&#13;
)&#13;
</code></pre>&#13;
<p class="TX">The ability to extract symbols from any Mach-O binary will improve our heuristic malware detection. Next, we’ll programmatically detect anomalous characteristics that often indicate a binary is up to something nefarious.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Newer binaries may contain a <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LC_DYLD_CHAINED_FIXUPS</span> load command that optimizes how symbols and imports are handled on recent versions of macOS. In this case, a different approach is needed to extract embedded symbols. See the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">extractChainedSymbols</span> <i>function in the</i> parseBinary <i>project for more details and a programmatic implementation of such extraction.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-23"/><span class="SANS_Futura_Std_Bold_B_11">Detecting Packed Binaries</span></h3>&#13;
<p class="TNI">An <i>executable packer</i> is a tool that compresses binary code to shrink its size for distribution. The packer inserts a small unpacker stub at the binary’s entry point, and this stub executes automatically when the packed program is run, restoring the original code in memory.</p>&#13;
<p class="TX">Malware authors are quite fond of packers, as compressed code is more difficult to analyze. Moreover, certain packers encrypt or further obfuscate the binary in an attempt to thwart signature-based detections and complicate analysis. Legitimate software is rarely packed on macOS, so the ability to detect obfuscation can be a powerful heuristic for flagging binaries that warrant closer inspection.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>I’ll wrap up this chapter by showing how to detect packed and encrypted Mach-O binaries by looking for a lack of dependencies and symbols, anomalous section and segment names, and high entropy.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-21"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dependencies and Symbols</span></h4>&#13;
<p class="TNI">One simple, albeit somewhat naive, approach to packer detection is enumerating a binary’s dependencies and symbols—or, rather, lack thereof. Nonpacked binaries will always have dependencies on various system frameworks and libraries such as <i>libSystem.B.dylib</i>, as well as imports from these dependencies. Packed binaries, on the other hand, may lack even a single dependency or symbol, as the unpacker stub will dynamically resolve and load any required libraries.</p>&#13;
<p class="TX">A binary with no dependencies or symbols is, at the very least, anomalous, and our tool should flag it for analysis. For example, running the dependency and symbol extraction code against the oRAT malware finds no dependencies or symbols:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary oRat/darwinx64</b>&#13;
...&#13;
Dependencies: (count: 0): ()&#13;
Symbols: (count: 0): ()&#13;
</code></pre>&#13;
<p class="TX">Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">nm</span> confirm this absence as well:</p>&#13;
&#13;
<pre><code>% <b>otool -L oRat/darwinx64</b>&#13;
oRat/darwinx64:&#13;
&#13;
% <b>nm oRat/darwinx64</b>&#13;
oRat/darwinx64: no symbols&#13;
</code></pre>&#13;
<p class="TX">It turns out oRAT is packed via UPX, a cross-platform packer that Mac malware authors favor. Examples of other macOS malware packed with UPX include IPStorm, ZuRu, and Coldroot.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-22"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Section and Segment Names</span></h4>&#13;
<p class="TNI">Binaries packed with UPX may contain UPX-specific section or segment names, such as <span class="SANS_TheSansMonoCd_W5Regular_11">__XHDR</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">UPX_DATA</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">upxTEXT</span>. If we find these names when parsing a Mach-O binary’s segments, we can conclude that the binary was packed. Other packers, such as MPress, add their own segment names, such as <span class="SANS_TheSansMonoCd_W5Regular_11">__MPRESS__</span>.</p>&#13;
<p class="TX">The following code snippet, from UPX’s <i>p_mach.cpp</i> file,<sup><a role="doc-noteref" id="chapter2_8" href="#chapter2-8">8</a></sup> shows references to nonstandard segment names:</p>&#13;
&#13;
<pre><code>if (!strcmp("__XHDR", segptr-&gt;segname)) {&#13;
    // PackHeader precedes __LINKEDIT&#13;
    style = 391;  // UPX 3.91&#13;
}&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>if (!strcmp("__TEXT", segptr-&gt;segname)) {&#13;
    ptrTEXT = segptr;&#13;
    style = 391;  // UPX 3.91&#13;
}&#13;
if (!strcmp("UPX_DATA", segptr-&gt;segname)) {&#13;
    // PackHeader follows loader at __LINKEDIT&#13;
    style = 392;  // UPX 3.92&#13;
}&#13;
</code></pre>&#13;
<p class="TX">To retrieve a binary’s section and segment names, we can iterate through its load commands, looking for those of type <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span>. These load commands consist of <span class="SANS_TheSansMonoCd_W5Regular_11">segment_command_64</span> structures that contain a member named <span class="SANS_TheSansMonoCd_W5Regular_11">segname</span> with the name of the segment. Here is the <span class="SANS_TheSansMonoCd_W5Regular_11">segment_command_64</span> structure:</p>&#13;
&#13;
<pre><code>struct segment_command_64 {/* for 64-bit architectures */&#13;
    uint32_t        cmd;            /* LC_SEGMENT_64 */&#13;
    uint32_t        cmdsize;        /* includes sizeof section_64 structs */&#13;
    char            segname[16];    /* segment name */&#13;
    ...&#13;
    uint32_t        nsects;         /* number of sections in segment */&#13;
    uint32_t        flags;          /* flags */&#13;
};&#13;
</code></pre>&#13;
<p class="TX">Any sections within the segment should immediately follow the <span class="SANS_TheSansMonoCd_W5Regular_11">segment _command_64</span> structure, whose <span class="SANS_TheSansMonoCd_W5Regular_11">nsects</span> member specifies the number of sections. The <span class="SANS_TheSansMonoCd_W5Regular_11">section_64</span> structure, shown here, describes sections:</p>&#13;
&#13;
<pre><code>struct section_64 {/* for 64-bit architectures */&#13;
    char            sectname[16];   /* name of this section */&#13;
    char            segname[16];    /* segment this section goes in */&#13;
    ...&#13;
};&#13;
</code></pre>&#13;
<p class="TX">Since the segment name can be extracted from the <span class="SANS_TheSansMonoCd_W5Regular_11">segment_command_64</span> structure, here we’re solely interested in the section name, <span class="SANS_TheSansMonoCd_W5Regular_11">sectname</span>. To detect packers such as UPX, our code can iterate through each segment and its sections, comparing the names with those of common packers. First, though, we need a function that accepts a Mach-O header, then extracts the binary’s segments and sections. The <span class="SANS_TheSansMonoCd_W5Regular_11">extractSegmentsAndSections</span> function partially shown in <a href="chapter2.xhtml#Lis2-15">Listing 2-15</a> does exactly this.</p>&#13;
<span id="Lis2-15"/>&#13;
<pre><code>NSMutableArray* extractSegmentsAndSections(struct mach_header_64* header) {&#13;
&#13;
    NSMutableArray* names = [NSMutableArray array];&#13;
    NSCharacterSet* nullCharacterSet = [NSCharacterSet&#13;
    characterSetWithCharactersInString:@"\0"];&#13;
&#13;
    NSMutableArray* commands = findLoadCommand(header, LC_SEGMENT_64);&#13;
    for(NSValue* command in commands) {&#13;
        // Add code here to iterate over each segment and its sections.&#13;
    }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>    return names;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-15: Retrieving a list of <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LC_SEGMENT_64</span> load commands</span></p>&#13;
<p class="TX">This code declares a few variables and then invokes the now-familiar <span class="SANS_TheSansMonoCd_W5Regular_11">findLoadCommand</span> helper function with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span>. Now that we have a list of the load commands describing each segment in the binary, we can iterate over each, saving their names and the names of all their sections (<a href="chapter2.xhtml#Lis2-16">Listing 2-16</a>).</p>&#13;
<span id="Lis2-16"/>&#13;
<pre><code>NSMutableArray* extractSegmentsAndSections(struct mach_header_64* header) {&#13;
    NSMutableArray* names = [NSMutableArray array];&#13;
    ...&#13;
&#13;
    for(NSValue* command in commands) {&#13;
        struct segment_command_64* segment = command.pointerValue; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
        NSString* name = [[NSString alloc] initWithBytes:segment-&gt;segname&#13;
        length:sizeof(segment-&gt;segname) encoding:NSASCIIStringEncoding]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
        name = [name stringByTrimmingCharactersInSet:nullCharacterSet];&#13;
        [names addObject:name];&#13;
&#13;
        struct section_64* section = (struct section_64*)((unsigned char*)segment +&#13;
        sizeof(struct segment_command_64)); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
        for(uint32_t i = 0; i &lt; segment-&gt;nsects; i++) { <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            name = [[NSString alloc] initWithBytes:section-&gt;sectname&#13;
            length:sizeof(section-&gt;sectname) encoding:NSASCIIStringEncoding]; <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
&#13;
            name = [name stringByTrimmingCharactersInSet:nullCharacterSet];&#13;
            [names addObject:name];&#13;
&#13;
            section++;&#13;
        }&#13;
    }&#13;
    return names;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-16: Iterating over each segment and its sections to extract their names</span></p>&#13;
<p class="TX">After extracting the pointer to each <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span> and saving it into a <span class="SANS_TheSansMonoCd_W5Regular_11">struct segment_command_64*</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the code extracts the name of the segment from the <span class="SANS_TheSansMonoCd_W5Regular_11">segname</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">segment_command_64</span> structure, stored in a rather unwieldy (and not necessarily <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>-terminated) <span class="SANS_TheSansMonoCd_W5Regular_11">char</span> array. The code converts it into a string object, trims any <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>s, and then saves it into an array to return to the caller <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Next, we iterate over the <span class="SANS_TheSansMonoCd_W5Regular_11">section_64</span> structures found in the <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span> command. One structure exists for each section in the segment. Because they begin immediately after the <span class="SANS_TheSansMonoCd_W5Regular_11">segment_command_64</span> structure, we initialize a pointer to the first <span class="SANS_TheSansMonoCd_W5Regular_11">section_64</span> structure, adding the start of the <span class="SANS_TheSansMonoCd_W5Regular_11">segment _command_64</span> structure to the size of this structure <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Now we can iterate <span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/>over each section structure, bounded by the <span class="SANS_TheSansMonoCd_W5Regular_11">nsects</span> member of the segment structure <span class="CodeAnnotation" aria-label="annotation4">❹</span>. As with each segment name, we extract, convert, trim, and save the section names <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Once we’ve extracted all segment and section names, we pass this list to a simple helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">isPacked</span>. Shown in <a href="chapter2.xhtml#Lis2-17">Listing 2-17</a>, it checks whether any names match those of well-known packers, such as UPX and MPress.</p>&#13;
<span id="Lis2-17"/>&#13;
<pre><code>NSMutableSet* isPacked(NSMutableArray* segsAndSects) {&#13;
    NSSet* packers = [NSSet setWithObjects:@"__XHDR", @"upxTEXT", @"__MPRESS__", nil]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    NSMutableSet* packedNames = [NSMutableSet setWithArray:segsAndSects]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    [packedNames intersectSet:packers]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    return packedNames;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-17: Checking for segment and section names matching those of known packers</span></p>&#13;
<p class="TX">First, we initialize a set with a few well-known packer-related segment and section names <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then we convert the list of segments and sections into a mutable set <span class="CodeAnnotation" aria-label="annotation2">❷</span>, as mutable set objects support the <span class="SANS_TheSansMonoCd_W5Regular_11">intersectSet:</span> method, which will remove any items in the first set that aren’t in the second. Once we’ve called this method <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the only names left in the set of segment and section names will match the packer-related ones.</p>&#13;
<p class="TX">After adding this code to the <i>parseBinary</i> project, we can run it against the macOS variant of the IPStorm malware:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary IPStorm/IPStorm</b>&#13;
binary is Mach-O&#13;
...&#13;
segments and sections: (&#13;
    "__PAGEZERO",&#13;
    "__TEXT",&#13;
    "upxTEXT",&#13;
    "__LINKEDIT"&#13;
)&#13;
&#13;
binary appears to be packed&#13;
packer-related section or segment {(upxTEXT)} detected&#13;
</code></pre>&#13;
<p class="TX">Because the IPStorm binary contains a section named <span class="SANS_TheSansMonoCd_W5Regular_11">upxTEXT</span> indicative of UPX, our code correctly ascertains that the binary is packed.</p>&#13;
<p class="TX">This name-based approach to packer detection has a low false-positive detection rate. However, it won’t detect custom packers or even modified versions of known packers. For example, if an attacker modifies UPX to remove custom section names (which, as UPX is open source, is easy to do), we’ll have a false negative, and the packed binary won’t be detected.</p>&#13;
<p class="TX">We find an example of this behavior in the malware known as Ocean- Lotus. In variant <i>H</i>, its authors packed the binary, <i>flashlightd</i>, with a customized version of UPX. Our current packer detector fails to determine that the malware is packed:</p>&#13;
&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>% <b>./parseBinary OceanLotus.H/flashlightd</b>&#13;
binary is Mach-O&#13;
...&#13;
segments and sections: (&#13;
    "__PAGEZERO",&#13;
    "__TEXT",&#13;
    "__cfstring",&#13;
    "__LINKEDIT"&#13;
)&#13;
&#13;
binary does not appear to be packed&#13;
no packer-related sections or segments detected&#13;
</code></pre>&#13;
<p class="TX">However, if we manually examine the malware, it becomes fairly obvious that the binary is packed. In a disassembler, large chunks of the binary appear obfuscated. We can also see that the binary contains no symbols or dependencies:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary OceanLotus.H/flashlightd</b>&#13;
binary is Mach-O&#13;
...&#13;
Dependencies: (count: 0): ()&#13;
Symbols: (count: 0): ()&#13;
</code></pre>&#13;
<p class="TX">Clearly, our packer detection approach needs some improvement. You’ll see how to detect packed binaries via their entropy next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-23"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Entropy Calculations</span></h4>&#13;
<p class="TNI">When a binary is packed, the amount of randomness in it greatly increases. This is largely due to the fact that packers either compress or encrypt the binary’s original instructions. If we can calculate a binary’s quantity of unique bytes and classify it as anomalously high, we can fairly accurately conclude the binary is packed.</p>&#13;
<p class="TX">Let’s parse a Mach-O binary and calculate the entropy of its executable segments. The code in <a href="chapter2.xhtml#Lis2-18">Listing 2-18</a> builds on the segment parsing code in the <span class="SANS_TheSansMonoCd_W5Regular_11">isPackedByEntropy</span> function. After enumerating all <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span> load commands, the function invokes a helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">calcEntropy</span> on each to calculate the entropy of the segment’s data.</p>&#13;
<span id="Lis2-18"/>&#13;
<pre><code>float calcEntropy(unsigned char* data, NSUInteger length) {&#13;
    float pX = 0.0f;&#13;
    float entropy = 0.0f;&#13;
    unsigned int occurrences[256] = {0};&#13;
&#13;
    for(NSUInteger i = 0; i &lt; length; i++) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> occurrences[0xFF &amp; (int)data[i]]++;&#13;
    }&#13;
&#13;
    for(NSUInteger i = 0; i &lt; sizeof(occurrences)/sizeof(occurrences[0]); i++) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(0 == occurrences[i]) {&#13;
            continue;&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> pX = occurrences[i]/(float)length;&#13;
        entropy -= pX*log2(pX);&#13;
    }&#13;
    return entropy;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-18: Computing the Shannon entropy</span></p>&#13;
<p class="TX">The function first computes the number of occurrences of each byte value, from <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">0xFF</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. After skipping values that don’t occur <span class="CodeAnnotation" aria-label="annotation2">❷</span>, it performs a standard formula <span class="CodeAnnotation" aria-label="annotation3">❸</span> to compute the Shannon entropy.<sup><a role="doc-noteref" id="chapter2_9" href="#chapter2-9">9</a></sup> The function should return a value between 0.0 and 8.0, ranging from no entropy (meaning all the values are the same) to the highest level of entropy.<sup><a role="doc-noteref" id="chapter2_10" href="#chapter2-10">10</a></sup></p>&#13;
<p class="TX">The code uses the entropy to determine whether the binary is likely packed (<a href="chapter2.xhtml#Lis2-19">Listing 2-19</a>). It’s inspired by the popular Windows-centric AnalyzePE and pefile Python libraries.<sup><a role="doc-noteref" id="chapter2_11" href="#chapter2-11">11</a></sup></p>&#13;
<span id="Lis2-19"/>&#13;
<pre><code>BOOL isPackedByEntropy(struct mach_header_64* header, NSUInteger size) {&#13;
    ...&#13;
    BOOL isPacked = NO;&#13;
    float compressedData = 0.0f;&#13;
&#13;
    NSMutableArray* commands = findLoadCommand(header, LC_SEGMENT_64);&#13;
    for(NSValue* command in commands) {&#13;
        ...&#13;
        struct segment_command_64* segment = command.pointerValue;&#13;
&#13;
        float segmentEntropy = calcEntropy(((unsigned char*)header +&#13;
        segment-&gt;fileoff), segment-&gt;filesize);&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if(segmentEntropy &gt; 7.0f) {&#13;
            compressedData += segment-&gt;filesize;&#13;
        }&#13;
    }&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if((compressedData/size) &gt; .2) {&#13;
        isPacked = YES;&#13;
    }&#13;
    ...&#13;
    return isPacked;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-19: Packer detection via entropy analysis</span></p>&#13;
<p class="TX">Testing has shown that if the entropy of an average-size segment is above 7.0, we can confidently conclude that the segment contains compressed data, meaning it’s either packed or encrypted. In this case, we append the segment’s size to a variable to keep track of the total amount of compressed data <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Once we’ve computed the entropy of each segment, we check how much of the binary’s total data is packed by dividing the amount of compressed <span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/>data by the size of the Mach-O. Research has shown that Mach-O binaries with a ratio of packed data to overall length greater than 20 percent are likely packed (though the ratio is usually much higher) <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Let’s test this code against the packed IPStorm sample:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary IPStorm/IPStorm</b>&#13;
binary is Mach-O&#13;
...&#13;
segment (size: 0) __PAGEZERO's entropy: 0.000000&#13;
segment (size: 8216576) __TEXT's entropy: 7.884009&#13;
segment (size: 16) __LINKEDIT's entropy: 0.000000&#13;
&#13;
total compressed data: 8216576.000000&#13;
total compressed data vs. size: 0.999998&#13;
&#13;
binary appears to be packed&#13;
significant amount of high-entropy data detected&#13;
</code></pre>&#13;
<p class="TX">Hooray! The code correctly detected that the malware is packed. This is because the <span class="SANS_TheSansMonoCd_W5Regular_11">__TEXT</span> segment has a very high entropy (7.884 out of 8), and because it’s the only segment containing any data, the ratio of packed data to the overall binary length is very high. Equally important is the fact that the code correctly determined that an unpacked version of the malware is indeed no longer packed:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary IPStorm/IPStorm_unpacked</b>&#13;
binary is Mach-O&#13;
...&#13;
segment (size: 0) __PAGEZERO's entropy: 0.000000&#13;
segment (size: 17190912) __TEXT's entropy: 6.185554&#13;
segment (size: 1265664) __DATA's entropy: 5.337738&#13;
segment (size: 1716348) __LINKEDIT's entropy: 5.618924&#13;
&#13;
total compressed data: 0.000000&#13;
total compressed data vs. size: 0.000000&#13;
&#13;
binary does *not* appear to be packed&#13;
no significant amount of high-entropy data detected&#13;
</code></pre>&#13;
<p class="TX">In this unpacked binary, the tool detects more segments, but all have an entropy of around 6 or below. Thus, it doesn’t classify any of them as containing compressed data, so the ratio of compressed data to binary size is zero.</p>&#13;
<p class="TX">As you’ve seen, this entropy-based approach can generically detect almost any packed binary, regardless of the packer used. This holds true even in the case of OceanLotus, whose authors used a customized version of UPX in an attempt to avoid detection:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary OceanLotus.H/flashlightd</b>&#13;
...&#13;
segment (size: 0) __PAGEZERO's entropy: 0.000000&#13;
segment (size: 45056) __TEXT's entropy: 7.527715&#13;
segment (size: 2888) __LINKEDIT's entropy: 6.201859&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/>total compressed data: 45056.000000&#13;
total compressed data vs. size: 0.939763&#13;
&#13;
binary appears to be packed&#13;
significant amount of high-entropy data detected&#13;
</code></pre>&#13;
<p class="TX">Although the packed malware doesn’t contain any segments or sections that match known packers, the large <span class="SANS_TheSansMonoCd_W5Regular_11">__TEXT</span> segment contains a very high amount of entropy (7.5+). As such, the code correctly determines that the OceanLotus sample is packed.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-24"/><span class="SANS_Futura_Std_Bold_B_11">Detecting Encrypted Binaries</span></h3>&#13;
<p class="TNI">While Apple encrypts the Intel versions of various system binaries, encrypted third-party binaries are rarely legitimate, and you should flag these for closer analysis. <i>Binary encryptors</i> encrypt the original malware code at the binary level. To automatically decrypt the malware at runtime, the encryptor will often insert a decryption stub and keying information at the start of the binary unless the operating system natively supports encrypted binaries, which macOS does.</p>&#13;
<p class="TX">As with packed binaries, we can detect encrypted binaries using entropy calculations, as any well-encrypted file will have a very high level of randomness. Thus, the code provided in the previous section should identify them. However, you might find it worthwhile to write code that focuses specifically on detecting binaries encrypted with the native macOS encryption scheme. The encryption scheme is undocumented and proprietary, so any third-party binary leveraging it should be treated as suspect.</p>&#13;
<p class="TX">We can see in the open source macOS Mach-O loader<sup><a role="doc-noteref" id="chapter2_12" href="#chapter2-12">12</a></sup> how to detect such binaries. In the loader’s code, we find mention of an <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span> flag value named <span class="SANS_TheSansMonoCd_W5Regular_11">SG_PROTECTED_VERSION_1</span> whose value is <span class="SANS_TheSansMonoCd_W5Regular_11">0x8</span>. As explained in Apple’s <i>mach-o/loader.h</i> file, this means the segment is encrypted with Apple’s proprietary encryption scheme:</p>&#13;
&#13;
<pre><code>#define SG_PROTECTED_VERSION_1  0x8 /* This segment is protected.  If the&#13;
                                       segment starts at file offset 0, the&#13;
                                       first page of the segment is not&#13;
                                       protected.  All other pages of the&#13;
                                       segment are protected. */&#13;
</code></pre>&#13;
<p class="TX">Usually, malware will encrypt only the <span class="SANS_TheSansMonoCd_W5Regular_11">__TEXT</span> segment, which contains the binary’s executable code.</p>&#13;
<p class="TX">Although it’s rare to discover malware leveraging this proprietary encryption scheme, we find an example in a HackingTeam implant installer. Using <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span>, let’s dump the load commands of this binary. Sure enough, the flags of the <span class="SANS_TheSansMonoCd_W5Regular_11">__TEXT</span> segment are set to <span class="SANS_TheSansMonoCd_W5Regular_11">SG_PROTECTED_VERSION_1</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">0x8</span>):</p>&#13;
&#13;
<pre><code>% <b>otool -l HackingTeam/installer</b>&#13;
...&#13;
Load command 1&#13;
      cmd LC_SEGMENT&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>  cmdsize 328&#13;
  segname __TEXT&#13;
   vmaddr 0x00001000&#13;
   vmsize 0x00004000&#13;
  fileoff 0&#13;
 filesize 16384&#13;
  maxprot 0x00000007&#13;
 initprot 0x00000005&#13;
   nsects 4&#13;
    <b>flags 0x8</b>&#13;
</code></pre>&#13;
<p class="TX">To detect if a binary is encrypted using this native encryption scheme, we can simply iterate over its <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT_64</span> load commands, looking for any that have the <span class="SANS_TheSansMonoCd_W5Regular_11">SG_PROTECTED_VERSION_1</span> bits set in the <span class="SANS_TheSansMonoCd_W5Regular_11">flags</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">segment_command_64</span> structure (<a href="chapter2.xhtml#Lis2-20">Listing 2-20</a>).</p>&#13;
<span id="Lis2-20"/>&#13;
<pre><code>if(SG_PROTECTED_VERSION_1 == (segment-&gt;flags &amp; SG_PROTECTED_VERSION_1)) {&#13;
    // Segment is encrypted.&#13;
    // Add code here to report this or to perform further processing.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-20: Checking whether a segment is encrypted with the native macOS encryption scheme</span></p>&#13;
<p class="TX">This chapter has focused on 64-bit Mach-Os, but the HackingTeam installer is almost 10 years old and was distributed as a 32-bit Intel binary, which isn’t compatible with recent versions of macOS. To write code capable of detecting HackingTeam’s 32-bit installer, we’d have to make sure it uses the 32-bit versions of the Mach-O structures, such as <span class="SANS_TheSansMonoCd_W5Regular_11">mach_header</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">LC_SEGMENT</span>.<sup><a role="doc-noteref" id="chapter2_13" href="#chapter2-13">13</a></sup> If we made these changes and ran the code against the installer, it would correctly flag the binary as leveraging Apple’s proprietary encryption scheme:</p>&#13;
&#13;
<pre><code>% <b>./parseBinary HackingTeam/installer</b>&#13;
...&#13;
segment __TEXT's flags: 'SG_PROTECTED_VERSION_1'&#13;
&#13;
binary is encrypted&#13;
</code></pre>&#13;
<p class="TX">We noted that though macOS does natively support encrypted binaries, because this is not documented, any third-party binary that is encrypted in this manner should be closely examined, as it may be malware with something to hide.<sup><a role="doc-noteref" id="chapter2_14" href="#chapter2-14">14</a></sup></p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-25"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">In this chapter, you learned how to confirm that a file is a Mach-O or a universal binary containing Mach-Os. Then you extracted dependencies and names and detected whether the binary was packed or encrypted.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>Of course, there are many other interesting things you could do with a Mach-O binary to classify it as benign or malicious. Take a look at Kimo Bumanglag’s Objective by the Sea talk for ideas.<sup><a role="doc-noteref" id="chapter2_15" href="#chapter2-15">15</a></sup></p>&#13;
<p class="TX">A final thought: I’ve noted that no single data point covered in this chapter can definitively indicate that a binary is malicious. For example, nothing stops legitimate developers from packing their binaries. Luckily, we have another powerful mechanism at our disposal to detect malware: code signing. <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> is dedicated to this topic. Read on!</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-1" href="#chapter2_1">  1</a></span>.  UniqMartin, comment on “FatArch64,” Homebrew, July 7, 2018, <a href="https://github.com/Homebrew/ruby-macho/issues/101#issuecomment-403202114"><i>https://<wbr/>github<wbr/>.com<wbr/>/Homebrew<wbr/>/ruby<wbr/>-macho<wbr/>/issues<wbr/>/101#issuecomment<wbr/>-403202114</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-2" href="#chapter2_2">  2</a></span>.  “magic,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/kernel/fat_header/1558632-magic"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/kernel<wbr/>/fat<wbr/>_header<wbr/>/1558632<wbr/>-magic</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-3" href="#chapter2_3">  3</a></span>.  See <i>utils.cpp</i> at <a href="https://github.com/apple-oss-distributions/dyld/blob/d1a0f6869ece370913a3f749617e457f3b4cd7c4/libdyld/utils.cpp"><i>https://<wbr/>github<wbr/>.com<wbr/>/apple<wbr/>-oss<wbr/>-distributions<wbr/>/dyld<wbr/>/blob<wbr/>/d1a0f6869ece370913a3f749617e457f3b4cd7c4<wbr/>/libdyld<wbr/>/utils<wbr/>.cpp</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-4" href="#chapter2_4">  4</a></span>.  Patrick Wardle, “Apple Gets an ‘F’ for Slicing Apples,” Objective-See, February 22, 2024, <a href="https://objective-see.org/blog/blog_0x80.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x80<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-5" href="#chapter2_5">  5</a></span>.  For more on universal binaries, see Howard Oakley, “Universal Binaries: Inside Fat Headers,” <i>The Eclectic Light Company</i>, July 28, 2020, <a href="https://eclecticlight.co/2020/07/28/universal-binaries-inside-fat-headers/"><i>https://<wbr/>eclecticlight<wbr/>.co<wbr/>/2020<wbr/>/07<wbr/>/28<wbr/>/universal<wbr/>-binaries<wbr/>-inside<wbr/>-fat<wbr/>-headers<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-6" href="#chapter2_6">  6</a></span>.  Patrick Wardle, “Burned by Fire(fox),” Objective-See, June 23, 2019, <a href="https://objective-see.org/blog/blog_0x45.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x45<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-7" href="#chapter2_7">  7</a></span>.  For more details on ZuRu, see Patrick Wardle, “Made in China: OSX.ZuRu,” Objective-See, September 14, 2021, <a href="https://objective-see.org/blog/blog_0x66.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x66<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-8" href="#chapter2_8">  8</a></span>.  See <a href="https://upx.github.io"><i>https://<wbr/>upx<wbr/>.github<wbr/>.io</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-9" href="#chapter2_9">  9</a></span>.  “Entropy (information theory),” Wikipedia, <a href="https://en.wikipedia.org/wiki/Entropy_(information_theory"><i>https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Entropy<wbr/>_(information<wbr/>_theory)</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-10" href="#chapter2_10">10</a></span>.  To gain a deeper understanding of entropy, see Ms Aerin, “The Intuition Behind Shannon’s Entropy,” Towards Data Science, September 30, 2018, <a href="https://towardsdatascience.com/the-intuition-behind-shannons-entropy-e74820fe9800"><i>https://<wbr/>towardsdatascience<wbr/>.com<wbr/>/the<wbr/>-intuition<wbr/>-behind<wbr/>-shannons<wbr/>-entropy<wbr/>-e74820fe9800</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-11" href="#chapter2_11">11</a></span>.  See <a href="https://github.com/hiddenillusion/AnalyzePE/blob/master/peutils.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/hiddenillusion<wbr/>/AnalyzePE<wbr/>/blob<wbr/>/master<wbr/>/peutils<wbr/>.py</i></a> and <a href="https://github.com/erocarrera/pefile/blob/master/pefile.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/erocarrera<wbr/>/pefile<wbr/>/blob<wbr/>/master<wbr/>/pefile<wbr/>.py</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-12" href="#chapter2_12">12</a></span>.  See <a href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h"><i>https://<wbr/>opensource<wbr/>.apple<wbr/>.com<wbr/>/source<wbr/>/xnu<wbr/>/xnu<wbr/>-7195<wbr/>.81<wbr/>.3<wbr/>/EXTERNAL<wbr/>_HEADERS<wbr/>/mach<wbr/>-o<wbr/>/loader<wbr/>.h</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-13" href="#chapter2_13">13</a></span>.  For more details about HackingTeam’s encrypted installer, see Patrick Wardle, “HackingTeam Reborn; A Brief Analysis of an RCS Implant <span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label="73"/>Installer,” Objective-See, February 26, 2016, <a href="https://objective-see.org/blog/blog_0x0D.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x0D<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-14" href="#chapter2_14">14</a></span>.  You can read more about the macOS support of encrypted binaries and how to decrypt them in Patrick Wardle, <i>The Art of Mac Malware: The Guide to Analyzing Malicious Software</i>, Volume 1 (San Francisco: No Starch Press, 2022), 187–218, or in Amit Singh, “ ‘TPM DRM’ in Mac OS X: A Myth That Won’t Die,” <i>OSX Book</i>, December 2007, <a href="https://web.archive.org/web/20200603015401/http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/"><i>https://<wbr/>web<wbr/>.archive<wbr/>.org<wbr/>/web<wbr/>/20200603015401<wbr/>/http:<wbr/>/<wbr/>/osxbook<wbr/>.com<wbr/>/book<wbr/>/bonus<wbr/>/chapter7<wbr/>/tpmdrmmyth<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter2-15" href="#chapter2_15">15</a></span>.  Kimo Bumanglag, “Learning How to Machine Learn,” paper presented at Objective by the Sea v5, Spain, October 6, 2022, <a href="https://objectivebythesea.org/v5/talks/OBTS_v5_kBumanglag.pdf"><i>https://<wbr/>objectivebythesea<wbr/>.org<wbr/>/v5<wbr/>/talks<wbr/>/OBTS<wbr/>_v5<wbr/>_kBumanglag<wbr/>.pdf</i></a>. To learn more about the Mach-O format in general, consult Wardle, <i>The Art of Mac Malware</i>, 1:99–123; Bartosz Olszanowski, “Mach-O Reader - Parsing Mach-O Headers,” <i>Olszanowski Blog</i>, May 8, 2020, <a href="https://olszanowski.blog/posts/macho-reader-parsing-headers/"><i>https://<wbr/>olszanowski<wbr/>.blog<wbr/>/posts<wbr/>/macho<wbr/>-reader<wbr/>-parsing<wbr/>-headers<wbr/>/</i></a>; and Alex Denisov, “Parsing Mach-O Files,” <i>Low Level Bits</i>, August 20, 2015, <a href="https://lowlevelbits.org/parsing-mach-o-files/"><i>https://<wbr/>lowlevelbits<wbr/>.org<wbr/>/parsing<wbr/>-mach<wbr/>-o<wbr/>-files<wbr/>/</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>