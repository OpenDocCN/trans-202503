- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 NEON AND SIMD PROGRAMMING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11 NEON 和 SIMD 编程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter discusses the vector instructions on the ARM. This special class
    of instructions provides parallel processing, traditionally known as *single-instruction,
    multiple-data (SIMD)* instructions because, quite literally, a single instruction
    operates on several pieces of data concurrently. As a result of this concurrency,
    SIMD instructions can often execute several times faster (in theory, as much as
    32 to 64 times faster) than the comparable *single-instruction, single-data (SISD)*
    instructions that compose the standard ARM instruction set.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 ARM 上的矢量指令。这一特殊类型的指令提供了并行处理，传统上被称为 *单指令多数据（SIMD）* 指令，因为，字面上说，一条指令可以同时作用于多个数据单元。由于这种并发性，SIMD
    指令通常比标准 ARM 指令集中的 *单指令单数据（SISD）* 指令执行速度快得多（理论上，可以快 32 到 64 倍）。
- en: Vector instructions, also known as the *Neon instruction set* or *ARM Advanced
    SIMD*, provide an extension to the standard scalar instructions. While a *scalar
    instruction* operates on a single piece of data at a time, the Neon instructions
    simultaneously operate on a *vector* (a fancy name for an array) of data objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量指令，也称为 *Neon 指令集* 或 *ARM 高级 SIMD*，为标准标量指令提供了扩展。标准的 *标量指令* 每次操作一个数据单元，而 Neon
    指令则同时操作一个数据对象的 *矢量*（即数组）。
- en: This chapter covers a brief history of SIMD instructions, then discusses the
    ARM Neon architecture (including the vector registers) and Neon data types. The
    majority of this chapter then covers the Neon instruction set. A complete treatise
    on SIMD programming is beyond the scope of this book; however, it wouldn’t do
    to write this chapter without at least a few SIMD programming examples in order
    to demonstrate the benefits of SIMD programming, so this chapter concludes with
    examples that show a bitonic sort and a numeric-to-hex-string conversion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要回顾了 SIMD 指令的历史，然后讨论了 ARM Neon 架构（包括矢量寄存器）和 Neon 数据类型。接下来的大部分内容将讲解 Neon 指令集。关于
    SIMD 编程的完整论述超出了本书的范围；然而，写这章时至少提供一些 SIMD 编程示例以展示 SIMD 编程的优势是必要的，因此本章的最后将给出一些例子，展示比托尼排序和数字到十六进制字符串的转换。
- en: 11.1 The History of SIMD Instruction Extensions
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1 SIMD 指令扩展的历史
- en: The Neon instruction set extensions were added to the ARM instruction set long
    after the ARM was created. Arm created Neon to counter competition from the Intel
    x86 CPU family. To understand why the Neon instruction set is so radically different
    from the standard instruction set, you have to understand the history of SIMD
    (vector) instruction sets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 指令集扩展是在 ARM 创建之后很久才加入到 ARM 指令集中的。ARM 创建 Neon 是为了应对英特尔 x86 CPU 家族的竞争。要理解为什么
    Neon 指令集与标准指令集有如此根本的不同，必须了解 SIMD（矢量）指令集的历史。
- en: The first vector computers were supercomputers such as the CDC Star-100, Texas
    Instruments Advanced Scientific Computer (ASC), and Cray computers, which could
    operate on a vector of data with a single instruction. These vector computers
    were the precursor to the early SIMD computers such as the Thinking Machines CM-1
    and CM-2\. Ultimately, supercomputers moved away from the SIMD approach when Intel
    introduced SIMD features on its low-cost i860 (and, later, Pentium processors).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个矢量计算机是超级计算机，如 CDC Star-100、德州仪器的高级科学计算机（ASC）和 Cray 计算机，它们可以用单条指令操作一个数据矢量。这些矢量计算机是早期
    SIMD 计算机的前身，如 Thinking Machines 的 CM-1 和 CM-2。最终，随着英特尔在其低成本 i860（后来是 Pentium 处理器）上引入
    SIMD 特性，超级计算机开始远离 SIMD 方法。
- en: The Intel Multimedia Extensions (MMX) instruction set was the first widely adopted
    desktop SIMD architecture. Intel added parallel integer arithmetic instructions
    to the venerable x86 instruction set to accelerate digital audio processing and
    other digital signal processing applications. The PowerPC followed this with the
    much more capable AltiVec architecture (which included support for single-precision
    floating-point values). Intel then produced the SSE2 and SSE3, AVX, AVX2, and
    AVX-512 SIMD instruction architectures (which now include full double-precision
    floating-point support).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔多媒体扩展（MMX）指令集是第一个广泛采用的桌面 SIMD 架构。英特尔将并行整数运算指令添加到传统的 x86 指令集中，以加速数字音频处理和其他数字信号处理应用。之后，PowerPC
    推出了更强大的 AltiVec 架构（其中包括对单精度浮点值的支持）。随后，英特尔推出了 SSE2 和 SSE3、AVX、AVX2 和 AVX-512 SIMD
    指令架构（现在包括完全的双精度浮点支持）。
- en: Intel’s approach to adding vector instructions to its x86 series CPUs was a
    bit hackneyed. Given the limited transistor budgets on CPUs in the middle 1990s,
    Intel added a few vector instructions (MMX) in its early Pentium processors and
    then extended the SIMD instruction set as its CPUs became larger and had more
    transistors available to implement advanced features. This evolution produced
    a bit of a kludge, with new sets of instructions replicating and obsoleting older
    instructions (with the newer instruction set’s ability to handle more data or
    handle data differently).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: By the time ARM added SIMD instructions via its *Neon Advanced SIMD* instructions,
    Intel had gone through multiple generations of SIMD instructions; Arm was able
    to cherry-pick the more interesting and useful instructions from Intel’s set,
    leaving behind all the kruft and legacy instructions. For this reason, the Neon
    instruction set is considerably more compact and much easier to understand than
    Intel’s MMX/SSE/AVX instruction sets.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.2 Vector Registers'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM provides 32 main FP/Neon registers that are 128 bits each, broken into
    five groups based on their size:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: V0 to V31, the 128-bit vector registers (for Neon instructions), also referenced
    as Q0 to Q31, the qword registers; the V*n* names support special syntax for vector
    operations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D0 to D31, the 64-bit double-precision floating-point registers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S0 to S31, the 32-bit single-precision floating-point registers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H0 to H31, the 16-bit half-precision floating-point registers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B0 to B31, the 8-bit byte registers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 11-1](chapter11.xhtml#fig11-1) shows the vector register layout.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The FP/Neon registers'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The B*n*, H*n*, S*n*, D*n*, and V*n* registers overlay one another, as shown
    in [Figure 11-2](chapter11.xhtml#fig11-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Byte, half-word, single, double, and vector register overlays'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: See [Chapter 6](chapter6.xhtml) for more information about the scalar floating-point
    D*n*, S*n*, and H*n* registers. Keep in mind, however, that if you mix vector
    and floating-point operations in your code, the instructions share the same register
    set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 11-1](chapter11.xhtml#fig11-1) and [11-2](chapter11.xhtml#fig11-2)
    give the impression that the V*n* registers are 128-bit registers (which, presumably,
    you can manipulate as a single 128-bit value). In fact, the V*n* registers are
    vectors containing sixteen 8-bit, eight 16-bit, four 32-bit, two 64-bit, or (single)
    128-bit values, as [Figure 11-3](chapter11.xhtml#fig11-3) shows.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Vector register overlays'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'When an instruction operates on a particular element of a vector register,
    you reference that element by using one of the following register names (in all
    cases, *n* represents a vector register number in the range 0 to 31):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: V*n* or Q*n* when referencing the whole 128-bit register
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.B when treating the whole register as an array of 16 bytes
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.H when treating the whole register as an array of eight half words
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.S when treating the whole register as an array of four words (single-precision
    values)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.D when treating the whole register as an array of two dwords (double-precision
    values)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.2D[0] or V*n*.2D[1] when referencing 64-bit double-precision in bit positions
    0 to 63 or 64 to 127, respectively
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.4S[0], V*n*.4S[1], V*n*.4S[2], V*n*.4S[3] when accessing a 32-bit single-precision
    value in bit positions 0 to 31, 32 to 63, 64 to 95, or 96 to 127, respectively
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.8H[0], V*n*.8H[1], ..., V*n*.8H[7] when accessing a 16-bit half-word value
    in bit positions 0 to 15, 16 to 31, ..., 112 to 127, respectively
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.16B[0], V*n*.16B[1], ..., V*n*.16B[15] when accessing an 8-bit byte in
    bit positions 0 to 7, 8 to 16, ..., 120 to 127
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact name to choose will depend on the instruction and situation. You’ll
    see examples of these registers in use in the next section, “Vector Data Movement
    Instructions,” particularly section 11.3.4, “Vector Load and Store,” on [page
    632](chapter11.xhtml#pg_632).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 11-2](chapter11.xhtml#fig11-2) and [11-3](chapter11.xhtml#fig11-3)
    showed the five basic types associated with the data in a vector register: bytes,
    half words, single-precision values, double-precision values, and 128-bit qwords.
    In fact, the 32-bit (single) and 64-bit (double) fields support both floating-point
    (single and double) and integer (word and dword) types, bringing the total number
    of types to seven.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Except for the special 128-bit case, the vector registers contain arrays of
    bytes, half words, words, and qwords. For reasons you’ll learn when this chapter
    discusses vector operations, each element of the array is known as a *lane*. When
    performing operations using two vector registers, the CPU generally computes results
    by using the operands in corresponding lanes in the two source registers and stores
    the result in the corresponding lane in a destination register. For example, suppose
    that V1 contains 2.0 in the HO 64 bits (lane 1) and 1.0 in the LO 64 bits (lane
    0), and that V2 contains 20.0 in lane 1 and 10.0 in lane 0\. Summing these two
    vector registers and storing the result in V3 produces 22.0 in lane 1 and 11.0
    in lane 0.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Although the vector registers generally contain arrays of data (when performing
    SIMD operations), don’t forget that the floating-point registers (D*n* and S*n*)
    overlay the vector registers as well. When doing normal floating-point operations
    (see [Chapter 6](chapter6.xhtml)), these registers contain a single value rather
    than an array of values. These single values are known as *scalars*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Very few operations treat an entire 128-bit Neon register as a scalar value.
    Those that do (mainly load and store instructions) use the name Q*n* to denote
    a scalar value rather than V*n* (a vector value).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Vector Data Movement Instructions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Move instructions are the most common integer and floating-point instructions
    you’ll use in the Neon instruction set. In this section, you’ll learn how to use
    these instructions to move data between registers, load constants into Neon registers,
    and load and store vector registers to and from memory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1 Data Movement Between Registers
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the mov instruction to move data between vector registers. Unfortunately,
    the obvious syntax won’t work:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mov instruction copies elements of a vector into a vector register. It can
    copy data between two vector registers or data between a general-purpose (X*n*
    or W*n*) register and a vector register. The exact syntax depends on how much
    data you’re copying and the location of the source and destination registers (vector
    or general-purpose).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving data from a 32-bit general-purpose register (W*m*) into a vector register
    (V*n*) uses one of the following syntaxes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The index i must be a literal integer constant, as demonstrated in the following
    examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moving data from a 64-bit general-purpose register (X*m*) into a vector register
    (V*n*) uses the following syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve used the word *inserts* in these examples because the mov instruction copies
    only the byte, hword, word, or dword into the vector register at the index that
    *i* specifies. It does not affect the other data in V*n*. For example
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: inserts only the LO byte from W0 into lane 4 in the V0 register; it leaves all
    other bytes in V0 unchanged. Moving bytes, hwords, and words is possible only
    when using the W*m* register; if you use X*m* in the instruction, you can move
    only 64 bits. The type specification for the vector register is S (single-precision)
    for 32 bits and D (double-precision) for 64 bits. You use this designation even
    when copying 32-bit and 64-bit integers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The ARM instruction* ins *(insert) is a synonym for* mov *when copying data
    from a general-purpose register to a vector register—yet another reason for saying
    these instructions* insert *data rather than saying they* copy *data.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous examples copy the value from a 32- or 64-bit general-purpose register
    into a vector register. You can also copy data from one vector register (V*n*)
    to another (V*m*) by using the following syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These instructions copy 64 bits (8 bytes, four half words, two words, or a
    single dword) or 128 bits (16 bytes, eight half words, four words / single-precision
    values, or two dwords / double-precision values) from one vector register to another.
    In theory, you should be able to enter something like mov v1, v0 or mov q1, q0
    to move the contents of the 128-bit vector register V0 (Q0) into V1 (Q1). Sadly,
    Gas does not accept this syntax, so you’ll have to use one of the previous four
    instructions, as in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also extract a single byte from one vector register and insert it in
    an arbitrary lane in another vector register, using the following syntax
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where i2 is the index of a byte in the source vector and i1 is the destination
    index. Both indices must be in the range 0 to 15.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also extract a half word from one vector and insert that into another:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The rules are the same for bytes, except that the two index values must be in
    the range 0 to 7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy words (single-precision values) and dwords (double-precision values)
    by using the following syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s an example that copies the LO dwords of V0 and V1 merges them into the
    two dwords in V2:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Thus far, I’ve described how to move data from a general-purpose register to
    a vector register and between two vector registers. The only missing combination
    is moving data from a vector register to a general-purpose register, handled by
    the following mov, umov, and smov instructions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are no 8- or 16-bit zero extensions to 64 bits. Zero-extending into W*n*
    automatically zero-extends all the way through the upper 32 bits of X*n*. Here
    are some examples of these instructions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that smov x1, v0.s[3] is moving an integer value, even though the specified
    type is S (single-precision).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.2 Vector Load Immediate Instructions
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM CPU provides a limited set of instructions that allow you to load certain
    immediate constants into a vector register. The integer versions of these instructions
    allow only an unsigned 8-bit immediate operand that can be used as is or shifted
    to the left 1, 2, or 3 bytes (filling vacated positions with 0s or 1s). Furthermore,
    these immediate instructions copy the data into every lane of a byte array, half-word
    array, or word array. The floating-point versions of these instructions allow
    a limited set of floating-point constants (the same limitations as for scalar
    floating-point constants; see section 6.9.1.4, “fmov with Immediate Operand,”
    on [page 334](chapter6.xhtml#pg_334)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The standard *move immediate* instruction is movi
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'where size is 16B, 8B, 4H, 8H, 2S, or 4S; uimm8 is an 8-bit constant; and uimm64
    is either 0 or 0xFFFFffffFFFFffff. The lsl #c component is optional for instructions
    with 4H, 8H, 2S, and 4S sizes. The msl #c option is optional for 2S and 4S sizes.
    The movi instructions initialize all lanes in the vector register, or just the
    lanes in the LO 64 bits, with the specified immediate constant. The following
    paragraphs describe the specific variants of each of these instructions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.8B, #uimm8 instruction fills each of the LO 8 bytes of V*n* with
    the specified constant and the HO 64 bits of the register with 0s. For example'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: loads 0x80808080 into V0.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.16B, #uimm8 instruction fills all 16 bytes of V*n* with the specified
    constant. Each lane receives a copy of the uimm8 value.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.4H, #uimm8 instruction fills the four hword lanes in the LO 64
    bits of V*n* with a copy of the uimm8 constant, and fills the HO 64 bits of V*n*
    with 0\. Because this instruction accepts only 8-bit immediate constants, the
    HO 8 bits of each half-word lane will contain 0s. For example'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: loads 0x0001000100010001 into V1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.4H, #uimm8, lsl #0 instruction is identical to movi Vn.4H, #uimm8*.*
    If the shift constant is #8, this instruction shifts the immediate constant to
    the left eight positions before storing it into the four half-word lanes (in the
    LO 64 bits of V*n*). In this case, the LO 8 bits of each of these lanes will contain
    0s. For example'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: loads 0x0100010001000100 into V1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.8H, #uimm8 and movi Vn.8H, #uimm8, lsl #c instructions do the same
    thing as the 4H instructions, except that they store the immediate constant (shifted
    by 0 or 8 bits) into all eight lanes of the V*n* register.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.2S, #uimm8 instruction fills the two word (single-precision) lanes
    in the LO 64 bits of V*n* with a copy of the uimm8 constant, and fills the HO
    64 bits of V*n* with 0\. Because this instruction accepts only 8-bit immediate
    constants, the HO 24 bits of each word lane will contain 0s. Although the type
    specification is S, this instruction assigns integer constants, not floating-point
    constants, to the lanes. If the optional shift clause is present (movi Vn.2S,
    #uimm8, lsl #c, where c is 0, 8, 16, or 24), this instruction will shift the 8-bit
    constant by the specified number of bits before storing the constant into the
    two lanes. Here are a few examples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The movi Vn.2S, #uimm8, msl #c instruction is almost identical to its lsl counterpart,
    except it shifts 1 bits rather than 0 bits into the vacated positions during the
    shift-left operation. The shift count is limited to 8 or 16 rather than 0, 8,
    16, and 24 (an annoying inconsistency). For example'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: loads 0x0001FFFF0001FFFF into V5.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.4S, #uimm8 instruction fills the four word (single-precision) lanes
    in V*n* with a copy of the uimm8 constant. Otherwise, this instruction (and the
    variant with shifting) behaves identically to the 2S version.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.2D, #uimm64 instruction loads one of two constants (0 or –1) into
    the two dword lanes of the V*n* register. Once again, keep in mind that these
    are integer constants, not floating-point constants, despite the use of the 2D
    type specifier.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The second move immediate instruction is mvni (move and *not* immediate). It
    supports the following syntax
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: where size and uimm8 have the same meanings as given for movi.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations are the same as for movi, except that mvni inverts all the bits
    before storing them into the lanes of the V*n* destination register. The HO 64
    bits of V*n* still receive 0s for the 4H and 2S type specifiers, as shown in the
    following examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the absence of the 2D types for the mvni instruction. These instructions
    are unnecessary because the two allowable movi uimm64 constants are already the
    inverse of each other. If you want inverted bits, just use the other uimm64 constant
    (0 versus –1) with the movi instruction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The third form of the move immediate instruction, fmov, allows you to load
    certain floating-point constants into the lanes of a vector register. The allowable
    syntax is the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 移动立即数指令的第三种形式，fmov，允许你将某些浮点常量加载到向量寄存器的各个通道中。允许的语法如下：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The floating-point immediate constant (fimm) must be a value defined by
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点立即数常量（fimm）必须是由以下方式定义的值
- en: ±*n* ÷ 16 × 2*r*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ±*n* ÷ 16 × 2*r*
- en: 'where 16 ≤ *n* ≤ 31 and –3 ≤ *r* ≤ 4\. You cannot represent 0.0 with this formula;
    if you need to load 0.0 into the lanes of a vector register, just load the integer
    constant 0 into those lanes by using the movi instruction (all 0 bits is 0.0):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 16 ≤ *n* ≤ 31 且 –3 ≤ *r* ≤ 4。你不能通过此公式表示 0.0；如果需要将 0.0 加载到向量寄存器的各个通道中，只需使用
    movi 指令将整数常量 0 加载到这些通道（所有位为 0 即为 0.0）：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The move immediate instructions load only certain constant values into the
    vector registers. The following are the exact values you can load as immediate
    floating-point constants (Gas will accept only these values):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 移动立即数指令只将某些常量值加载到向量寄存器中。以下是你可以作为立即数浮点常量加载的确切值（Gas 只接受这些值）：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Based on the way programs typically use the Neon registers, this is a reasonable
    set of values, which can be encoded into a 32-bit instruction opcode. To load
    larger or different constants, see section 11.3.4, “Vector Load and Store,” on
    the next page.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于程序通常使用 Neon 寄存器的方式，这是一个合理的值集合，可以编码成 32 位指令操作码。要加载更大或不同的常量，请参见下一页第 11.3.4 节，“向量加载与存储”。
- en: 11.3.3 Register or Lane Value Duplication
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3 寄存器或通道值复制
- en: 'The dup instruction allows you to duplicate a value held in a general-purpose
    register or in a single lane of a vector register, throughout all the lanes in
    a vector register. This instruction supports the following forms:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: dup 指令允许你将保存在通用寄存器或向量寄存器单一通道中的值复制到向量寄存器的所有通道中。此指令支持以下形式：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first instruction in each pair duplicates only data in the LO 64 bits of
    V*n*; the second instruction of each pair copies a full 128 bits. The two single
    instructions copy 128 bits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每对指令中的第一条指令仅复制 V*n* 的 LO 64 位数据；每对指令中的第二条指令复制完整的 128 位数据。这两条单独的指令复制 128 位数据。
- en: 11.3.4 Vector Load and Store
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.4 向量加载与存储
- en: The mov, movi, mvni, fmov, and dup instructions can move data between vector
    registers and between general-purpose and vector registers, and can load constants
    into vector registers. However, they don’t allow you to load a register from memory
    or store the value held in a vector register to memory. The Neon instruction set
    provides several load and store instructions to handle these tasks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: mov、movi、mvni、fmov 和 dup 指令可以在向量寄存器之间以及在通用寄存器和向量寄存器之间移动数据，并且可以将常量加载到向量寄存器中。然而，它们不允许你从内存加载寄存器或将向量寄存器中的值存储到内存中。Neon
    指令集提供了几条加载和存储指令来处理这些任务。
- en: Because the load and store instructions are the most fundamental, this section
    considers them first. To load or store an entire 128-bit vector register, use
    the following syntax
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为加载和存储指令是最基础的，所以本节首先讨论它们。要加载或存储整个 128 位的向量寄存器，请使用以下语法
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where memory is one of the usual ARM memory addressing modes (same as for the
    scalar ldr and str instructions). Note the use of Q*n* to denote the register
    (rather than V*n*). This is one of the few places the Q*n* register is legal (one
    wonders why they didn’t just use V*n*). These instructions will load or store
    a full 16 bytes, that is, 128 bits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中内存是常见的 ARM 内存寻址模式之一（与标量 ldr 和 str 指令相同）。注意使用 Q*n* 来表示寄存器（而非 V*n*）。这是 Q*n*
    寄存器合法使用的少数几个地方之一（让人想知道为什么不直接使用 V*n*）。这些指令将加载或存储完整的 16 字节，即 128 位。
- en: 'The stp instructions also allow vector register (Q*n*) operands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: stp 指令还允许使用向量寄存器（Q*n*）操作数：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that n and m in these instructions don’t have to be consecutive numbers
    but can be any arbitrary value in the range 0 to 31.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些指令中的 n 和 m 不必是连续的数字，而可以是 0 到 31 范围内的任意值。
- en: 11.3.5 Interleaved Load and Store
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5 交错加载与存储
- en: The Neon instruction set provides load and store instructions that load data
    into a single lane across multiple vector registers. These instructions load interleaved
    data from memory into one, two, three, or four vector registers. The load (ld1,
    ld2, ld3, and ld4) and store (st1, st2, st3, and st4) instructions support non-interleaved
    data, pairs of interleaved data, triplets of interleaved data, and quad-interleaved
    data, respectively. The following subsections describe these types of interleaved
    load and store instructions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Neon 指令集提供了加载和存储指令，将数据加载到多个向量寄存器的单个通道中。这些指令从内存加载交错的数据到一个、两个、三个或四个向量寄存器中。加载（ld1、ld2、ld3
    和 ld4）和存储（st1、st2、st3 和 st4）指令分别支持非交错数据、交错数据对、交错数据三元组和交错数据四元组。以下小节将描述这些类型的交错加载和存储指令。  '
- en: '##### 11.3.5.1 Interleaved Load and Store Addressing Modes'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 11.3.5.1 交错加载和存储寻址模式  '
- en: The interleaved load and store instructions access memory, but they do not support
    the full set of ARM memory addressing modes, just three
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '交错的加载和存储指令访问内存，但它们不支持 ARM 内存寻址模式的完整集合，仅支持三种  '
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where instr is one of ldn/stn and register_list is a comma-separated set of
    Q*n* registers that the load and store instructions will use when loading data
    from, or storing data to, memory. (The following sections discuss register _list
    at greater length.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，instr 是 ldn/stn 之一，register_list 是一个以逗号分隔的 Q*n* 寄存器集合，加载和存储指令将在从内存加载数据或向内存存储数据时使用这些寄存器。（以下章节将更详细地讨论寄存器
    _list。）  '
- en: The standard register-indirect addressing mode is[Xn]. The ldn/stn instructions
    will access the data at the memory address held in general-purpose register X*n*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '标准的寄存器间接寻址模式是[Xn]。ldn/stn 指令将访问存储在通用寄存器 X*n* 中的内存地址的数据。  '
- en: The [Xn], Xm addressing mode computes its effective address as the sum of the
    values in X*n* and X*m*. This is a post-increment addressing mode; immediately
    after accessing the specified memory address, this mode adds the value of X*m*
    to X*n*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], Xm 寻址模式将有效地址计算为 X*n* 和 X*m* 中值的和。这是一个后增量寻址模式；在访问指定的内存地址后，立即将 X*m* 的值加到
    X*n* 中。  '
- en: 'The [Xn], #imm addressing mode is also a post-increment addressing mode, which
    computes its effective address as the sum of Xn + imm, then adds the immediate
    constant to X*n* after referencing the address. The immediate value is limited
    to the constants 1, 2, 4, 8, 16, 32, 48, or 64, where the register_list operand(s)
    determines the value you must use. The following sections describe the allowable
    immediate constants for each version of the instruction.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], #imm 寻址模式也是一种后增量寻址模式，它将有效地址计算为 Xn + imm 的和，然后在引用地址后将立即数加到 X*n* 中。立即数的值限制为常数
    1、2、4、8、16、32、48 或 64，register_list 操作数决定了你必须使用的值。以下章节将描述每个版本指令的允许立即常数。  '
- en: 11.3.5.2 ld1/st1
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '11.3.5.2 ld1/st1  '
- en: The ld1 instruction loads one to four registers with data from sequential (non-interleaved)
    memory locations. With a single vector register, the syntax for this instruction
    is the following
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'ld1 指令从顺序（非交错）内存位置加载一到四个寄存器的数据。使用单一向量寄存器时，该指令的语法如下  '
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'where memory is one of the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，memory 是以下之一：  '
- en: '[Xn]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn]  '
- en: '[Xn], Xm'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], Xm  '
- en: '[Xn], #imm'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], #imm  '
- en: The imm operand, if present, must match the size of the register operand. That
    is, for B it must be 1; for 8B, 8; for 16B, 16; for H, 2; and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '如果存在 imm 操作数，它必须与寄存器操作数的大小匹配。也就是说，对于 B 必须是 1；对于 8B，必须是 8；对于 16B，必须是 16；对于 H，必须是
    2；依此类推。  '
- en: The ld1 instruction with the {Vn.8B} register list operand loads 8 bytes into
    the LO 64 bits of V*n*, while the {Vn.16B} register list operand loads 16 bytes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 {Vn.8B} 寄存器列表操作数的 ld1 指令将 8 字节数据加载到 V*n* 的低 64 位中，而 {Vn.16B} 寄存器列表操作数则加载
    16 字节。
- en: With a 4H or 2S type specification, the ld1 register also loads 64 bits (four
    hwords or two words) into the LO 64 bits of V*n*. With an 8H or 4S type, the ld1
    instruction loads 128 bits into V*n*. Although the 8B, 4H, and 2S types and the
    16B, 8H, 4S, and 2D types seem to be interchangeable (they load the same amount
    of data into V*n*), you should aim to pick the most appropriate type for the data
    you’re manipulating. Not only does this improve your documentation, but also the
    internal microarchitecture of the ARM CPU might be able to optimize its operations
    better based on the type of data you are using.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: With the bare B, H, S, or D type specification, the ld1 instruction loads a
    single lane in V*n* with data from memory. This operation does not affect the
    data in the other lanes in V*n*. This is the most important variant of the ld1
    instruction because it allows you to build up data in a vector register one lane
    at a time from different locations in memory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does the ld1 instruction require braces around the vector register specification?
    The destination operand of this instruction is actually a register *list*. You
    can specify one to four registers in this list, as shown in the following examples:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The registers that may appear in this list have two restrictions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: They must be consecutively numbered registers (with V0 being the successor to
    V31).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type specifications must be identical for all registers in the list.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have two or more consecutively numbered registers in a list, you can
    use the shorthand
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'where m is 1, 2, or 3, and t is one of the usual vector types, as shown in
    the following examples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you specify more than one register in the list, the ld1 instruction will
    load values from consecutive locations into the register. For example, the following
    code will load V0 from the 16 bytes at the address held in X0, V1 from the 16
    bytes at X0 + 16, and V2 from the 16 bytes at X0 + 32:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The st1 instruction supports an identical instruction syntax (except, of course,
    you substitute the st1 mnemonic for ld1). It stores the contents of the register(s)
    or lanes from those registers into the specified memory location. Here is an example
    that demonstrates storing the values in V0 and V1 to the location specified by
    X0:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This instruction stores the value in V0 at the address held in X0, and the value
    in V1 to address X0 + 16.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.3 ld2/st2
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld2 and st2 instructions load and store interleaved data. These two instructions
    use the following syntax
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: where the register list must contain exactly two registers, and their register
    numbers must be consecutive. The t1 size is 8B, 16B, 4H, 8H, 2S, 4S, or 2D, while
    t2 is B, H, S, or D. The literal constant index is an appropriate lane number
    for the type’s size (0 to 15 for B, 0 to 7 for H, 0 to 3 for S, and 0 to 1 for
    D). Finally, memory is one of the addressing modes described in section 11.3.5.1,
    “Interleaved Load and Store Addressing Modes,” on [page 633](chapter11.xhtml#pg_633).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The variants with index (which load a single lane into the two registers) load
    the first register’s lane from the specified memory address and load the second
    register’s lane n bytes later (where n is the size of the lane, in bytes).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The ld2 instruction with the t1 type specification (8B, 16B, 4H, 8H, and so
    on), meanwhile, loads the two registers one value at a time (of the specified
    type: B, H, S, or D), alternating destination lanes between the two registers.
    For example'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: loads the LO 8 bytes of V0 from memory locations X0, X0 + 2, X0 + 4, X0 + 6,
    X0 + 8, X0 + 10, X0 + 12, and X0 + 14\. It loads the LO 8 bytes of V1 from locations
    X0 + 1, X0 + 3, X0 + 5, X0 + 7, X0 + 9, X0 + 11, X0 + 13, and X0 + 15\. This deinterleaves
    the data in memory, loading the even bytes into V0 and the odd bytes into V1\.
    [Figure 11-4](chapter11.xhtml#fig11-4) shows how ld2 extracts interleaved data
    from X0 and stores the deinterleaved results in V0 and V1.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-4.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The ld2 deinterleaving operation'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: If you specify the half-word type (4H or 8H), the ld2 instruction deinterleaves
    16-bit values (even and odd half words). This is particularly useful for deinterleaving
    digital audio tracks that interleave left and right channels (16 bits per sample).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If you specify 2S/4S or 2D, this instruction will deinterleave words or dwords.
    For example, if you have an array of floating-point complex numbers, the ld2 instruction
    can deinterleave the real and imaginary components.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Because ld2 deinterleaves pairs of objects, the register list must contain exactly
    two registers. The assembler will reject any other number of registers in the
    list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The st2 instruction uses the same syntax (except, of course, substituting st2
    for ld2). This instruction stores data lanes of the specified type from two registers
    into memory, interleaving the data between the two registers. The store operation
    is basically reversing the arrows in [Figure 11-4](chapter11.xhtml#fig11-4) (that
    is, copying the data from V0 and V1 into X0, interleaving the two data sets).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.4 ld3/st3
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld3 and st3 instructions behave in a similar fashion to ld2/st2, except
    that they (de)interleave three objects in memory rather than two, and the register
    list must contain exactly three registers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: A common example of using the ld3/st3 instructions is to (de)interleave red,
    green, blue (RGB) values consisting of 3 bytes—an 8-bit red, 8-bit green, and
    8-bit blue value—in memory. Using the ld3 instruction, you can deinterleave an
    array of 3-byte RGB values into separate red, green, and blue byte arrays. You
    can use the st3 instruction to interleave red, green, and blue values into an
    RGB array.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.5 ld4/st4
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Finally, as you’ve probably figured out by now, the ld4 instruction copies
    four consecutive values from memory and stores those values into the same lane
    of the four registers specified by the four-element register list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This instruction copies the four dwords starting at the address held in X0 into
    lane 0 of V4, V5, V6, and V7, respectively. [Figure 11-5](chapter11.xhtml#fig11-5)
    diagrams how this ld4 instruction operates.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-5.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: The ld4 instruction operation'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The ld4/st4 instructions are useful for (de)interleaving data in memory that
    consists of an array of four objects. For example, suppose that you have an array
    of CMYK (cyan-magenta-yellow-black) color pixels in memory, arranged as shown
    in [Figure 11-6](chapter11.xhtml#fig11-6).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-6.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: CMYK pixel layout in memory'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When submitting an image to a printing service, you generally need to provide
    color separations—that is, four separate images consisting only of the cyan pixels,
    magenta pixels, yellow pixels, and black pixels. Therefore, you’ll need to extract
    all the cyan pixels from the full-color image and create a separate image for
    that; likewise for the magenta, yellow, and black pixels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You can use the ld4 instruction to extract the cyan, magenta, yellow, and black
    values from the original image and place those pixels in four separate vector
    registers. For example, assuming X0 points at the first CMYK pixel (32 bits) in
    memory
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: will extract the 4 bytes pointed at by X0 and distribute them into lane 0 of
    V0 (cyan), V1 (magenta), V2 (yellow), and V3 (black). If you add 4 to X0 and repeat
    this instruction, specifying lane 1 instead of lane 0, this will separate the
    second pixel into lane 1 of V0–V4\. Repeat this 14 more times and you’ll have
    16 cyan pixels in V0, 16 magenta pixels in V1, 16 yellow pixels in V2, and 16
    black pixels in V3\. You can then store away these four registers into the graphic
    image area that will hold the four-color separations. Repeat this process for
    all the pixels in the four-color image and you’ll have your color separations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can use the 8B and 16B types to process 8 or 16 pixels concurrently:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This instruction copies 64 bytes into V0, V1, V2, and V3, with every fourth
    byte going into successive lanes in the four registers: V0 gets bytes at offsets
    *i* % 4, V1 gets bytes at offsets (*i* % 4) + 1, and so on, where *i* is the byte
    index into memory.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.6 ldnr
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld1, ld2, ld3, and ld4 instructions load the lanes of one to four registers
    with successive values in memory, deinterleaving an array of interleaved objects
    (bytes, hwords, words, or dwords). The ld1r, ld2r, ld3r, and ld4r instructions
    also deinterleave an interleaved object, but the memory object is a single object
    that the instruction replicates through all lanes in the vector register(s).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for these instructions is the same as for the ldn instructions with
    the addition of the r suffix on the mnemonic:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The .t represents a lane type (more on this in a moment), and memory is the
    usual ldn addressing modes. You can also use the range syntax
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: when specifying two or more registers in the list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'For these instructions, allowable types are 8B, 16B, 4H, 8H, 2S, 4S, and 2D.
    These type specifications do the following when used with the ld1r instruction:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 8B loads the first 8 lanes of V*n* with a copy of the byte found at memory,
    replicating that byte in each lane.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16B loads all 16 lanes of V*n* with a copy of the byte found at memory, replicating
    that byte in each lane.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4H loads the first 4 lanes of V*n*, replicating the hword found at memory.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8H loads all 8 lanes of V*n*, replicating the hword found at memory.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2S loads the first 2 lanes of V*n*, replicating the word found at memory.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4S loads all 4 lanes of V*n*, replicating the word found at memory.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D loads the 2 dword lanes of V*n*, replicating the dword found at memory.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ld1r instruction fetches only a single lane value from memory and writes
    it to all the lanes of the destination register. The ld2r instruction fetches
    two lane objects from successive memory locations and replicates the first value
    throughout the first register and the second value throughout the second. The
    ld3r instruction fetches three lane objects from memory and replicates them through
    the first, second, and third registers, respectively. Finally, the ld4r instruction
    fetches four lane objects from memory and uses them to initialize the lanes of
    the four registers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6 Register Interleaving and Deinterleaving
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ldn/stn and ldnr instructions operate between memory and the vector registers.
    When you want the ability to interleave and deinterleave data appearing in vector
    registers, leaving the result in a vector register, use the trn1, trn2, zip1,
    zip2, uzip1, uzip2, and ext instructions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.1 trn1 and trn2
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The trn1 and trn2 (transpose) instructions—so called because you can use them
    to transpose the elements of a 2 × 2 matrix (or larger arrays with a little effort)—extract
    data from two source registers and interleave that data into a destination register.
    These instructions use the following syntax
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. The d (destination), a, and b
    items are register numbers in the range 0 to 31\. These register numbers are arbitrary
    (they don’t have to be consecutive values, as is the case for the ldn/stn and
    ldnr instructions).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The trn1 instruction copies the data from even-numbered lanes in Va.t into
    the corresponding lanes in Vd.t, and data from even-numbered lanes in Vb.t into
    the odd lanes in Vd.t, while ignoring the odd-numbered lanes in Va.t and Vb.t.
    For example, consider the following instruction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This instruction interleaves the alternate bytes in V2 and V4, leaving the result
    in V0, as shown in [Figure 11-7](chapter11.xhtml#fig11-7).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-7.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: The trn1 v0.4s, v2.4s, v4.4s operation'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The trn2 instruction copies the values in the odd lanes in Va.t and Vb.t into
    alternating lanes in Vd.t, as shown in [Figure 11-8](chapter11.xhtml#fig11-8)
    (similar to trn1 except that it swaps the source locations).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-8.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: The trn2 v0.4s, v2.4s, v4.4s operation'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Consider the 2×2 matrix of double-precision values held in V2 and V3 as shown
    in [Figure 11-9](chapter11.xhtml#fig11-9) (note the positions of the array elements,
    which is different from what you would normally expect).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-9.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: A 2×2 matrix held in V2 and V3'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two instructions will transpose this matrix, leaving the result
    in V0 and V1:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Of course, trn1 and trn2 are generally useful for rearranging and interleaving
    values in the vector registers, even if you aren’t transposing 2×2 matrices.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.2 zip1 and zip2
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The zip1 and zip2 instructions are similar to trn1 and trn2 insofar as they
    produce an interleaved result from data taken from two source registers. The name
    *zip* comes from *zipper*: the instruction interleaves lanes just like a zipper
    interleaves the two halves of the connector. Except for the mnemonics, the syntax
    is identical to trn1 and trn2'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D (all types must be the same in
    the instruction).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The zipn and trnn instructions differ in the way they select the source lanes
    to interleave. The zip1 instruction interleaves lane values taken from the beginning
    of the source registers (consuming half the lanes of each source register and
    ignoring the remaining lanes). See [Figure 11-10](chapter11.xhtml#fig11-10) for
    an example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-10.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: The zip1 v0.4s, v1.4s, v2.4s operation'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The zip2 instruction works similarly except that it processes the second half
    of the lanes in the source registers. [Figure 11-11](chapter11.xhtml#fig11-11)
    shows an example.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-11.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: The zip2 v0.4s, v1.4s, v2.4s operation'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these figures, the zip1 and zip2 instructions are typically
    what you would use to create interleaved data using only registers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.3 uzp1 and uzp2
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The uzp1 and uzp2 (unzip1 and unzip2) instructions are the inverse of zip1
    and zip2. They take interleaved data in two source registers and produce deinterleaved
    data in the destination register. Their syntax is the same as that of the trnn
    and zipn instructions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As usual, t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The uzp1 instruction copies the even lanes from Va.t into the first half of
    Vd.t, then appends the even lanes of Vb.t to the end of Vd.t. See [Figure 11-12](chapter11.xhtml#fig11-12)
    for an example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-12.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: The uzp1 v0.4s, v1.4s, v2.4s operation'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The uzp2 instruction copies the odd lanes from the source registers. [Figure
    11-13](chapter11.xhtml#fig11-13) shows an example of the uzp2 instruction in action.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-13.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: The uzp2 v0.4s, v1.4s, v2.4s operation'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If the type specifier is 64 bits (8B, 4H, or 2S), the uzp1 and uzp2 instructions
    leave 0s in the HO lanes of the destination register.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.4 ext
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ext (extract) instruction creates an 8- or 16-byte vector from *n* bytes
    in one vector and 8-*n* (or 16-*n*) bytes from a second vector. This instruction
    allows you to extract an 8- or 16-byte vector from across two vectors. The syntax
    for this instruction is as follows
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: where n is a starting index, Vd is the destination register, and Vs1 and Vs2
    are the source registers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The ext Vd.8B, Vs1.8B, Vs2.8B, #n instruction fetches the LO n bytes from Vs2
    and copies them to the HO n bytes of the LO 64 bits in Vd*.* It also extracts
    the LO 8-n bytes from Vs1 and copies them to the LO 8-n bytes of Vd. For an example
    of ext, see [Figure 11-14](chapter11.xhtml#fig11-14).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-14.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-14: The ext v0.8B, v1.8B, v2.8B, #2 instruction'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The ext Vd.16B, Vs1.16B, Vs2.16B, #n instruction fetches the LO n bytes from
    Vs2 and copies them to the HO n bytes of Vd*.* It also extracts the LO 16-n bytes
    from Vs1 and copies them to the LO 16-n bytes of Vd (see [Figure 11-15](chapter11.xhtml#fig11-15)
    for an example).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-15.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-15: The ext v0.16B, v1.16B, v2.16B, #5 instruction'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: This instruction supports only the 8B and 16B types. You can easily extract
    hwords, words, or dwords by choosing an appropriate index value (n) that includes
    all the objects you want to extract.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.7 Table Lookups with tbl and tbx
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tbl and tbx (table lookup) instructions allow you to exchange all the byte
    values in one register with values taken from a lookup table containing up to
    64 entries. The syntax for these instructions is
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where table_list is a list of one to four (consecutively numbered) registers,
    all of which must have a 16B type attached to them. (You can also use the Vn.t
    - Vm.t syntax, where m > n and m < (n + 4).) This list of registers provides a
    lookup table that contains 16, 32, 48, or 64 entries. The LO byte of the first
    register is index 0 in the table; the HO byte of the last register is index 15,
    31, 47, or 63 into the table.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The tbl instruction fetches each byte from the source register (Vs.t) and uses
    its value as an index into the lookup table. It fetches the byte at that index
    from the table and copies it to the corresponding location in the destination
    register—that is, the same byte index from which the source byte was taken; so
    this is equivalent to Vd[i] = table[Vs[i]]. If the value is out of range (greater
    than 15, 31, 47, or 63, depending on the size of the table), the tbl instruction
    stores a 0 into the corresponding location in the destination register. The tbx
    instruction works similarly to tbl, except that it leaves the destination location
    unchanged if the source value is out of range.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: For very small tables (64 entries or fewer), you can use tbl and tbx to implement
    lookup tables as described in [Chapter 10](chapter10.xhtml). However, the main
    purpose of these two instructions is to provide arbitrary vector permutations
    like the trn1/trn2, zip1/zip2, uzp1/uzp2, and ext instructions. Suppose, for example,
    that you want to reverse the positions of all 16 bytes in a vector register (swapping
    indices 0 and 15, 1 and 14, 2 and 13, 3 and 12, and so on). [Figure 11-16](chapter11.xhtml#fig11-16)
    shows a 16-byte endian swap operation, where the double-ended arrows point to
    the two locations where the bytes are exchanged.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-16.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-16: A 16-byte endian swap'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: If you load a vector register with the following 16-byte value
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'and then use this value in the source register for the tbl (or tbx) instruction,
    tbl (or tbx) will swap the bytes in a single 16-byte register supplied as the
    table_list, storing the reversed bytes in the destination register. Assuming you’ve
    loaded this value into V0, the following instruction will swap the bytes in {V1},
    placing the results in V2:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After you load V1 with the bytes to be swapped and execute this instruction,
    V2 will contain the swapped values.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: To use tbl or tbx as a vector permutation instruction, load the permutation
    indexes into the source register (V0 in this example). The indices will always
    be values in the range 0 to 15, to select specific entries in table_list. For
    a true permutation, each of the values (0 to 15) will appear exactly once in the
    source register, and there will always be a single register in the table _list.
    Because you’re limiting the values in the source register to the range 0 to 15,
    the table index values are always in range, so you can use either tbl or tbx.
    Both work exactly the same when the values are not out of range.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can use any permutation you like by specifying different values
    in the source register. As with the ext instruction, tbl and tbx support only
    the 8B and 16B lane types. However, it’s easy enough to synthesize other types
    (for permutations, anyway) by choosing the positions of the source register lane
    values to permute hwords, words, and dwords. Obviously, for table lookup operations
    (rather than permutations), you’re limited to 8-bit values, so hword, word, and
    dword types don’t make any sense.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.8 Endian Swaps with rev16, rev32, and rev64
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The rev16, rev32, and rev64 instructions are similar to their scalar counterparts
    rev16, rev32, and rev (see section 3.3, “Little-Endian and Big-Endian Data Organization,”
    on [page 133](chapter3.xhtml#pg_133)), except, of course, they operate on the
    lanes in a vector source register rather than on a general-purpose integer register.
    Here is their syntax:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The legal types and lane counts for these instructions appear in [Table 11-1](chapter11.xhtml#tab11-1).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1: Legal Types and Lane Counts for rev* Instructions'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Type and lane count |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| t2 | 8B, 16B, 4H, or 8H |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| t3 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: If the lane count and type is 8B, 4H, or 2S, the instruction operates only on
    the LO 64 bits of the source register (and clears the HO 64 bits of the destination
    register). If the lane count and type is 16B, 8H, or 4S, these instructions operate
    on the full 128 bits of the source register.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 Vertical and Horizontal Operations
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point, vector operations have been *vertical*, meaning they’ve operated
    on the same lane across multiple registers (which, when stacked as appearing in
    most figures thus far, show a vertical operational direction). Consider the following
    vector addition instruction:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As for the scalar addition operation (for example, add w0, w1, w2), this instruction
    adds the values of two source registers (V1.16B and V2.16B), producing a sum in
    the destination register. However, this is not a 128-bit addition operation, but
    rather an 8-bit operation repeated 16 times. Vector operations typically operate
    on a lane-by-lane basis, performing multiple small operations in parallel. For
    this particular instruction, the CPU adds together 16 byte values, producing 16
    independent byte results. This is the magic behind SIMD programming: the ability
    to do 16 times as much work with a single instruction (so it should run about
    16 times faster than running these 16-byte additions individually).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-17](chapter11.xhtml#fig11-17) shows the lane-by-lane operation of
    the add instruction with the lane-by-lane addition following the arrow directions.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-17.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-17: Lane-by-lane operations'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Lane-by-lane operations are independent of one another, meaning that if any
    carries, overflows, or other exceptional conditions occur, such anomalies are
    limited in scope to a single lane. Because there is only a single set of NVZC
    condition code flags, vector instructions cannot (and do not) affect these flags.
    If an unsigned carry out of one lane occurs (such as when adding 255 + 1 in a
    byte lane), the sum wraps around with no indication of overflow or underflow.
    In general, you must handle overflows completely differently from the way you’d
    handle them when doing scalar arithmetic. This chapter covers some strategies
    for doing so when discussing saturation in later sections.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Certain vector instructions provide *horizontal operations*, also known as *reducing
    operations*. Rather than operating lane by lane between two registers, these operations
    operate on all the lanes within a single vector register, producing a scalar result.
    For example, the addv instruction will produce the sum of all the lanes in a single
    vector register.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 SIMD Logical Operations
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because logical (Boolean) operations are computed on a bitwise basis, vector
    logical operations are unique insofar as you can use them to perform 128 individual
    bit operations. Whether you treat the source operands as sixteen 1-byte values
    or as one 128-byte value, the result is the same. For that reason, the vector
    logical operations support only two types: 8B (for 64-bit operands) and 16B (for
    128-bit operands). If you really want to operate on 4H or 2S operands, just specify
    8B; you’ll get the same result. Likewise, for 8H, 4S, or 2D operands, specifying
    16B produces the same result.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set supports eight logical instructions, as shown in [Table
    11-2](chapter11.xhtml#tab11-2). Here, t is 8B or 16B, Vd is the destination register,
    Vs1 is the left source register, and Vs2 is the right source register (Vs is the
    only source register for the not instruction).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-2: Neon Logical Instructions'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| and | and Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & Vs2 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| orr | orr Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; Vs2 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| orn | orn Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; ~(Vs2) |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| eor | eor Vd.t, Vs1.t, Vs2.t | Vd = Vs1 ^ Vs2 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| bic | bic Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & ~(Vs2) (bit clear) |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| bif | bif Vd.t, Vs1.t, Vs2.t | Bit insert if false |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| bit | bit Vd.t, Vs1.t, Vs2.t | Bit insert if true |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| bsl | bsl Vd.t, Vs1.t, Vs2.t | Bitwise select |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| not | not Vd.t, Vs.t | Vd = ~Vs |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: The and, orr, and eor instructions do the usual logical operations (same as
    scalar) and require no further explanation. The orn instruction is similar to
    bic insofar as it inverts the second source operand prior to the OR operation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The bic (bit clear) instruction clears all the bits in the value of Vs1 in the
    positions containing 1s in Vs2. It stores the result in Vd. Note that there is
    no need for a bis (bit set) instruction, because orr will set bits in Vd.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The bif (bit insert if false) and bit (bit insert if true) instructions are
    unusual insofar as they use three operands in their computation (rather than using
    a function of two inputs and storing the result in a third operand). The bif instruction
    copies the bits from Vs1 to Vd wherever the corresponding bit in Vs2 contains
    a 0\. In the bit positions where Vs2 contains a 1, this instruction leaves the
    corresponding bit in Vd unchanged. The bit instruction works similarly, except
    it copies the bits when the corresponding bit in Vs2 contains a 1 (rather than
    0).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The bsl (bit select) instruction selects bits from Vs1 or Vs2 (and copies them
    to Vd) based on the original contents of Vd. If Vd originally contained a 1 in
    a particular bit position, bsl selects the corresponding bit from Vs1. Otherwise,
    it selects the bit from Vs2.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The not instruction inverts all the bits in the source register and stores the
    result into the destination register. This instruction is different from the other
    logical instructions, having only a single source operand.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set supports a few special immediate versions of the orr
    and bic instructions
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'where imm is an unsigned 8-bit immediate value; the type (t) is 2S, 4S, 4H,
    or 8H; and shift is 0 or 8 if t is 4H/8H and 0, 8, 16, or 24 if t is 2S or 4S.
    If shift is not specified, it is assumed to be 0\. These instructions require
    the H and S types rather than the B types, since they replicate the immediate
    value through the bytes in the lanes in Vd.t.  ### 11.6 SIMD Shift Operations'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Shift instructions are generally considered to be logical operations. However,
    from a vector point of view, they are more correctly thought of as arithmetic
    operations because shift operations can produce overflows. Vector shift operations
    handle overflows in one of four ways:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring any carry out of the shift operation (truncation)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saturating the shift result
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rounding the result
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing an extended shift operation whose destination operand is larger than
    the source register
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section describes these various shift operations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Neon instruction set uses mnemonics based on* shr *and* shl *for shift
    left and shift right. This is in contrast to the* lsl*,* lsr*, and* asr *instructions
    that the scalar integer instruction set uses. I cannot think of a good reason
    they did it this way; it would have made the instruction set easier to learn had
    they stuck to a consistent naming convention.*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.1 Shift-Left Instruction
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shl instruction shifts each lane of a vector register to the left the specified
    number of bits. This instruction shifts 0s into the (vacated) LO bits. Any carry
    out of the HO bit of the lane is lost. The syntax is as follows
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: where Vd is the destination register and Vs is the source register. The immediate
    count value must be in the ranges appearing in [Table 11-3](chapter11.xhtml#tab11-3)
    (based on the specified type). The assembler will report an error if an immediate
    shift value is outside these ranges.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-3: Valid shl Shift Values'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Shift range |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| 8B/16B | 0 to 7 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| 4H/8H | 0 to 15 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| 2S/4S | 0 to 31 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| 2D | 0 to 63 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: There is also a scalar shl instruction that operates on the LO dword of a vector
    register, with the following syntax
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: where Dd is the destination scalar register and Ds is the source register (corresponding
    to the LO 64 bits of Vd and Vs). The imm shift count must be in the range 0 to
    63\. Note that this instruction will zero out the HO 64 bits of Dd.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: To shift the lanes by a variable number of bits, see section 11.6.9, “Shift
    by a Variable Number of Bits,” on [page 657](chapter11.xhtml#pg_657).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.2 Saturating Shift Left
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The saturating shift-left instructions uqshl, sqshl, and sqshlu shift the lanes
    in a vector to the left the specified number of bit positions. If an overflow
    (whether signed or unsigned) occurs, these instructions saturate the result to
    the largest (signed or unsigned) value depending on the instruction. The syntax
    for these instructions is as follows
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: where Vd is the destination register, Vs is the source register, imm is an appropriate
    immediate shift constant or Vc contains a shift count in the LO byte, and t is
    type 8B, 16B, 4H, 8H, 2S, 4S, or 2D. The t specification must be the same for
    Vd and Vs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'The shift value’s range depends on the lane type; see [Table 11-3](chapter11.xhtml#tab11-3)
    in the previous section for the legal immediate values. For immediate values,
    the assembler will report an error if the shift constant is out of range. For
    the register shift count variants, if the LO byte contains an out-of-range value,
    then the instruction will always saturate the result if a lane contains a nonzero
    value (see the discussion of saturation that follows). The uqshl instruction shifts
    values to the left one bit position, storing the result in the corresponding lane
    in the destination register. If the HO bit is set (before the shift), this instruction
    stores all 1 bits (the maximum unsigned value) in the destination lane. For example,
    if a lane contains 0x7F in V1, the corresponding lane will contain 0xFE (0x7F
    shifted left one position) after the execution of the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: However, if a source lane contains the value 0x80 through 0xFF, then shifting
    it to the left one position produces 0xFF in the destination lane. In general,
    if anything other than 0 bits are shifted out of a source lane, the corresponding
    destination lane will contain 0xFF.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The sqshl instruction is a signed saturation shift-left operation. For signed
    values, an overflow will occur during a left shift if the H two bits of a lane
    contain different values. For negative source values (the HO bit is set), overflow
    saturates to a result with the HO bit set and all other bits containing 0s (for
    example, with hword types, 0xa000 will saturate to 0x8000).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The sqshlu instruction is similar to sqshl, except that it treats the destination
    as an unsigned value. Positive (and 0) source values will shift to the left exactly
    like the uqshl instruction, while negative source values (with the HO bit set)
    will saturate to 0.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: There are also scalar versions of the uqshl, sqshl, and sqshlu instructions
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: where Rn (n = d or s) is one of the registers B*n*, H*n*, S*n*, or D*n*, and
    d, s, and imm have the usual meanings and limitations. Unlike the plain shl instruction,
    these instructions allow byte, hword, and word registers, as well as dword registers.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: As for the vector instructions, the uqshl instructions do an unsigned saturation.
    If any bits are shifted out of the HO bit of the source register, these instructions
    set the destination (B*n*, H*n*, S*n*, or D*n*) to all 1 bits. These instructions
    zero-extend the result through the rest of the vector register containing R*d*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The sqshl instruction does a signed saturation, leaving the result in the destination
    (scalar) register. This instruction zeros out the remaining HO bits of the corresponding
    vector register (that is, all the HO bits beyond the size of the scalar register).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The sqshlu instruction does a shift on a signed source value but saturates it
    to an unsigned value (negative results saturate to 0, just as with the vector
    register versions of this instruction).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.3 Shift-Left Long
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *shift-left long* instructions sshll, sshll2, ushll, and ushll2 provide
    a mechanism to handle overflow during a shift operation. These instructions sign-
    or zero-extend the value in a lane to twice its size and then perform the left
    shift on the double-sized source, storing the result into the (double-sized) destination
    lane. The syntax for these instructions is
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: where t2 is the double-sized type and can be 8H, 4S, or 2D; t is the original
    type and can be 8B, 4H, or 2S. imm is the shift count and should be in the range
    0 to n – 1, where n is the number of bits in the t type.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The ushll instruction zero-extends the values in the source lanes to twice their
    size, shifts the zero-extended result by the specified number of bits, and stores
    the result into the corresponding (double-sized) destination lanes. The sshll
    instruction sign-extends the source lane values to twice their size, then shifts
    the results and stores them in the double-sized destination lanes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Because these instructions double the size of their values, they operate only
    on the LO 64 bits of the source register (lanes 0 to 7 for bytes, 0 to 3 for hwords,
    and 0 to 1 for words). These instructions ignore the HO 64 bits of the source
    register.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the upper 64 bits of the source register, the ARM provides the ushll2
    and sshll2 instructions:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These accomplish the same operations as the ushll and sshll instructions, except
    that they take their source operands from the HO 64 bits rather than the LO 64
    bits. To indicate this, the t4/t3 type pairs must be 8H/16B, 4S/8H, or 2D/4S.
    The imm shift values must match the source lane size in bits (0 to 15 for 8H/16B,
    0 to 31 for 4S/8H, and 0 to 63 for 2D/4S).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The ushll, ushll2, sshll, and sshll2 instructions have no scalar versions. Just
    use the vector versions and zero out the HO bits yourself if you need this operation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.4 Shift and Insert
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sli and sri instructions allow you to shift a source operand a certain number
    of bits and then (using other instructions) insert other bits into the locations
    (0 bits) vacated by the shift operation. Here’s the syntax for these instructions
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'where *t* is the usual set of types: 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For sli,
    imm is the shift count, which must be in the range 0 to n – 1, where n is bit
    size of a lane. For sri, the immediate value is a count in the range 1 to n.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: The sli instruction shifts each lane in Vs.t to the left the specified number
    of bits. It then logically ORs the n - imm LO bits of Vd.t into the result (replacing
    the 0s that were shifted in) and stores the result back into Vd.t, as shown in
    [Figure 11-18](chapter11.xhtml#fig11-18).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-18.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: The sli instruction operation'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to shift in 1 bits rather than 0 bits, you could load the destination
    register with all 1 bits, then execute the sli instruction, as shown in the following
    code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This produces 0x0000001f0000001f0000001f0000001f in V0.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The sri instruction shifts each lane in Vs.t to the right the specified number
    of bits, then logically ORs the n - imm HO bits of Vd.t into the result (replacing
    the 0s that were shifted in), then stores the result back into Vd.t, as shown
    in [Figure 11-19](chapter11.xhtml#fig11-19).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-19.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: The sri instruction operation'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'The scalar versions of the sli and sri instructions have the following syntax:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: These instructions operate on the LO 64 bits of the specified vector register
    (Dn) and zero out the HO 64 bits of the destination register.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.5 Signed and Unsigned Shift Right
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because an arithmetic shift left and a logical shift left are essentially the
    same operation, the ARM uses a single instruction for both operations: shl. However,
    the logical and arithmetic shifts are different for right shifts. Therefore, the
    Neon instruction set provides two instructions, sshr and ushr, for signed and
    unsigned shift right (respectively, arithmetic shift right and logical shift right).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: As noted in [Chapter 2](chapter2.xhtml), a shift-left operation is the same
    as a multiplication by 2\. Shift-right operations are approximately the same as
    a division by 2\. I say *approximately* because the behaviors of signed and unsigned
    numbers are somewhat different. For example, when you shift the value 1 to the
    right one position, you get a 0 result. If you shift the signed value –1 (all
    1 bits) to the right by using an arithmetic shift right, however, the result is
    –1\. In one case, the shift rounds toward 0, while in the other it rounds away
    from 0\. Neither case is particularly correct or incorrect, but not being able
    to choose the rounding direction can be a problem.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'With scalar instructions, you can reverse this rounding effect by adding the
    carry flag to the result after the shift:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Because the vector operations don’t track carries out of a shift in the carry
    flag, you don’t have the option of correcting for this. The Neon instruction set
    therefore provides the rounding shift instructions srshr and urshr, which will
    add in the carry for you.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the Neon shift-right instructions is shown here:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The allowable types for the vector registers are the usual 8B, 16B, 4H, 8H,
    2S, 4S, or 2D. The rounding variants (with the r as the second character in the
    mnemonic) add the carry flag back into the destination lane after the shift operation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The sshr, srshr, ushr, and urshr instructions also have scalar versions:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: These instructions operate on the LO 64 bits of the vector registers specified
    by Dd (destination) and Ds (source). The imm shift operand must be a value in
    the range 1 to 64\. They will zero out the HO 64 bits of the corresponding Vd
    register. Otherwise, they are identical to their vector components.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.6 Accumulating Shift Right
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The accumulating shift-right instructions have the following syntax:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: These instructions are largely the same as the shift-right instructions, but
    they add their shifted values to the corresponding destination lanes (rather than
    just storing the shift lane values).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.6.7 Narrowing Shift Right'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The shrn, shrn2, rshrn, and rshrn2 instructions provide the converse operations
    to the shll and shll2 instructions. Rather than double the size of the operands
    when shifting, they halve (“narrow”) the size. The syntax for these instructions
    is as follows
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'where:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: t1 is 8B, 4H, or 2S
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: t2 is 8H, 4S, or 2D
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: t3 is 8B, 16B, 4H, 8H, 2S, or 4S
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: t4 is 8H, 4S, or 2D
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: The shrn instruction shifts each lane right the specified number of bits (shifting
    0s in from the left); extracts the LO 8, 16, or 32 bits (depending on size of
    t1); and stores the result into the same lane number in the destination register.
    The shrn instruction ignores (truncates) any HO bits left in the shift operation
    that don’t fit in the destination lane (which, recall, is half the size of the
    source lane). This instruction zeros out the HO 64 bits of the destination register.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The shrn2 instruction performs the exact same operation but stores the results
    in the HO 64 bits.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: The rshrn and rshrn2 instructions do the same thing as shrn and shrn2, respectively,
    but round the shifted result before narrowing it. The rshrn instruction also clears
    the upper half of the destination register.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Because the narrowing shift-right instructions throw away all but the LO bits
    that fit in the destination lane, you might think a separate set of instructions
    must extract the HO bits after the shift operation. There’s no need for such instructions,
    though; just add 8, 16, or 32 to your shrn, shrn2, rshurn, or rshrn2 shift count
    to extract the HO bits.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.8 Saturating Shift Right with Narrowing
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The standard narrowing shift instructions truncate any HO bits when narrowing
    the result to half the source lane size. The saturating shift-right instructions
    will saturate the shifted value if it does not fit in the destination lane. [Table
    11-4](chapter11.xhtml#tab11-4) gives the syntax for these instructions.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-4: Lane-by-Lane Saturating Shift Right with Narrowing Instructions'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| uqshrn | uqshrn Vd.t1, Vs.t2, #imm | Unsigned shift right by imm bits with
    narrowing. Stores data into LO 64 bits of Vd. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| uqrshrn | uqrshrn Vd.t1, Vs.t2, #imm | Unsigned shift right by imm bits with
    narrowing and rounding. Stores data into LO 64 bits of Vd. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| sqshrn | sqshrn Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing. Stores data into LO 64 bits of Vd. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| sqrshrn | sqrshrn Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing and rounding. Stores data into LO 64 bits of Vd. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| sqshrun | sqshrun Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing and saturation to an unsigned number. Stores data into LO 64 bits of
    Vd. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| sqrshrun | sqrshrun Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing, rounding, and saturation to an unsigned number. Stores data into LO
    64 bits of Vd. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| uqshrn2 | uqshrn2 Vd.t3, Vs.t4, #imm | Unsigned shift right by imm bits with
    narrowing. Stores data into HO 64 bits of Vd. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: '| uqrshrn2 | uqrshrn2 Vd.t3, Vs.t4, #imm | Unsigned shift right by imm bits
    with narrowing and rounding. Stores data into HO 64 bits of Vd. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
- en: '| sqshrn2 | sqshrn2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing. Stores data into HO 64 bits of Vd. |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
- en: '| sqrshrn2 | sqrshrn2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing and rounding. Stores data into HO 64 bits of Vd. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
- en: '| sqshrun2 | sqshrun2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing and saturation to an unsigned number. Stores data into HO 64 bits of
    Vd. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
- en: '| sqrshrun2 | sqrshrun2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits
    with narrowing, rounding, and saturation to an unsigned number. Stores data into
    HO 64 bits of Vd. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
- en: '[Table 11-5](chapter11.xhtml#tab11-5) lists the legal types and lane counts
    for the saturating shift-right instructions appearing in [Table 11-4](chapter11.xhtml#tab11-4).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-5: Saturating Shift-Right Types and Lane Counts'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types and lane counts |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 8B/8H, 4H/4S, or 2S/2D |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 16B/8H, 8H/4S, or 4S/2D |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: The instructions with the 2 suffix store their narrowed results into the HO
    64 bits of the destination register. Those without this suffix will zero out the
    HO 64 bits of the destination register.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The uqrshrn, sqrshrn, uqrshrn2, and sqrshrn2 instructions round the shifted
    result before saturating the value (if saturation is necessary). Rounding consists
    of adding the last bit shifted out of the source lane back into the value.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The instructions with the s prefix operate on signed values, while those with
    the u prefix operate on unsigned values. Unsigned values saturate to all 1 bits
    (if the unsigned value will not fit in the destination lane size), but signed
    values will saturate to either a HO bit of 1 with other bits 0s, or a HO bit of
    0 with all other bits containing 1s.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'The sqrshrun and sqrshrun2 instructions do the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Perform an arithmetic shift-right operation by the specified number of bits
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Round the result by adding the last bit shifted out back into the result
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saturate the result to the maximum unsigned value (all 1 bits) if the result
    will not fit into the destination lane; negative values saturate to 0
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the saturated result into the destination lane
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sqrshrun instruction stores the results in the LO 64 bits of the destination
    register; sqrshrun2 stores the results in the HO 64 bits of the destination register.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions also have scalar versions:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that these instructions clear the upper bits (beyond the specified scalar
    register) of the underlying vector register.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.9 Shift by a Variable Number of Bits
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To shift a lane by a variable number of bits, use one of the following instructions
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: where t is the usual 8B, 16B, 4H, 8H, 2S, 4S, or 2D.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Vc.t holds the signed shift count in the LO byte. For positive values (in the
    range 0 to 0x7F), the instruction shifts the bits in a lane the number of bit
    positions to the left. For negative values (0xFF to 0x80; –1 to –128), the instruction
    shifts the bits to the right, despite using a shl mnemonic. See [Table 11-6](chapter11.xhtml#tab11-6)
    for legal ranges when specifying the shift count by using a register.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-6: Legal Vc.t Shift Ranges'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Unsigned (SHL) | Signed (SHR) |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
- en: '| 8B/16B | 0 to 7 | –1 to –7 |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
- en: '| 4H/8H | 0 to 15 | –1 to –15 |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
- en: '| 2S/4S | 0 to 31 | –1 to –31 |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
- en: '| 2D | 0 to 63 | –1 to –63 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: Values outside the ranges listed in [Table 11-6](chapter11.xhtml#tab11-6) will
    produce the results shown in [Table 11-7](chapter11.xhtml#tab11-7).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-7: Result of Shift If Count Exceeds Allowable Range'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '| Shift instruction | Positive count, positive overflow | Positive count, negative
    overflow | Negative count, positive value | Negative count, negative value |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: '| sshl | 0 | 0 | 0 | –1 (all 1 bits) |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
- en: '| ushl | 0 | 0 | 0 | 0 |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
- en: '| sqshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | –1 (all 1 bits) |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
- en: '| uqshl | All 1 bits (for example, 0xff) | All 1 bits (for example, 0xff) |
    0 | 0 |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
- en: '| srshl | 0 | 0 | 0 | 0 (–1 + carry) |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| urshl | 0 | 0 | 0 | 1 (0 + carry) |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| sqshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | –1 (all 1 bits) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| uqshl | –1 (all 1 bits) | –1 (all 1 bits) | 0 | 0 |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '| sqrshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | 0 (–1 + carry) |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '| uqrshl | –1 (all 1 bits) | –1 (all 1 bits) | 0 | 1 (0 + carry) |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
- en: Using shf (for shift) in these instructions would probably have been a better
    choice then shl, since that name better matches the operation. Just keep in mind
    that the value in the LO byte of Vc.t is a signed integer and negative values
    indicate a right shift.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: The Neon shl instruction also has some scalar saturating versions
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: where R represents one of the scalar register names (B, H, S, or D). These instructions
    shift the value in the scalar register Rs the number of bit positions specified
    by the LO byte of Rc and store the shifted result in Rd. Rc is treated as a signed
    number; positive values shift Rs left, while negative values shift Rs right. If
    an overflow (signed or unsigned, as appropriate) occurs during the shift, these
    instructions set Rd to the maximum positive signed or unsigned value.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: If the shift count is negative for the sqshl instruction, the CPU performs an
    arithmetic shift-right operation, which will replicate the HO bit when shifting
    to the right. Positive (and 0) source values will saturate to 0, and negative
    source values will saturate to –1 (all 1 bits).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The sqrshl and uqrshl instructions are special rounding versions of the saturating
    shift instructions. During a shift-right operation (that is, when Rc is negative),
    these instructions round the result by adding 1 if the last bit shifted out was
    a 1 bit.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 SIMD Arithmetic Operations
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set includes several common arithmetic operations, including
    addition, subtraction, and multiplication. The only surprise is that there is
    no division operation; instead, you’ll have to compute the reciprocal and multiply
    by that value (using the instructions provided to estimate reciprocals).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1 SIMD Addition
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Neon provides a wide set of instructions that add lanes (ignoring overflow),
    add and saturate (when overflow occurs), or perform horizontal additions.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.1 Vector Addition
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions you can use to add integer
    and floating-point values in lanes within the vector registers, as listed in [Table
    11-8](chapter11.xhtml#tab11-8). These instructions compute Vd = Vl + Vr, where
    Vd is the destination, Vl is the left operand, and Vr is the right operand.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-8: Neon Addition Instructions'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
- en: '| add | add Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane integer sum |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
- en: '| fadd | fadd Vd.t2, Vl.t2, Vr.t2 | Computes lane-by-lane floating-point sum
    |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
- en: '| sqadd | sqadd Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane signed integer
    sum, with saturation |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
- en: '| uqadd | uqadd Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane unsigned integer
    sum, with saturation |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
- en: '| saddl | saddl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane signed integer
    sum, with long extension |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
- en: '| uaddl | uaddl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane unsigned integer
    sum, with long extension |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
- en: '| saddl2 | saddl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed integer
    sum, with long extension |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
- en: '| uaddl2 | uaddl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned integer
    sum, with long extension |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
- en: '| saddw | saddw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane signed integer
    sum, with wide extension |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
- en: '| uaddw | uaddw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane unsigned integer
    sum, with wide extension |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
- en: '| saddw2 | saddw2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed integer
    sum, with wide extension |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
- en: '| uaddw2 | uaddw2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned integer
    sum, with wide extension |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
- en: '| addhn | addhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane addition with narrowing
    |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
- en: '| raddhn | raddhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane addition with
    rounding and narrowing |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
- en: '| addhn2 | addhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane addition with
    narrowing (uses HO bits) |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
- en: '| raddhn2 | raddhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane addition with
    rounding and narrowing (uses HO bits) |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
- en: '| shadd | shadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed addition
    with halving |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
- en: '| uhadd | uhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned addition
    with halving |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
- en: '| srhadd | srhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed addition
    with rounding and halving |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
- en: '| urhadd | urhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned addition
    with rounding and halving |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
- en: '| addp | addp Vd.t1, Vl.t1, Vr.t1 | Adds vector pairwise |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
- en: '| faddp | faddp Vd.t2, Vl.t2, Vr.t2 | Adds vector floating-point pairwise |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
- en: '| saddlp | saddlp Vd.t8, Vl.t9 | Adds vector pairwise, signed long integer
    |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
- en: '| uaddlp | uaddlp Vd.t8, Vl.t9 | Adds vector pairwise, unsigned long integer
    |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
- en: '| saddalp | saddalp Vd.t8, Vl.t9 | Adds vector pairwise and accumulates, signed
    long integer |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
- en: '| uaddalp | uaddalp Vd.t8, Vl.t9 | Adds vector pairwise and accumulates, unsigned
    long integer |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
- en: '[Table 11-9](chapter11.xhtml#tab11-9) lists the legal types for the addition
    and subtraction instructions.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-9: Legal Types for Vector Addition and Subtraction'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, 4S, or 2D |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
- en: '| t2 | 2S, 4S, or 2D |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 8H/8B, 4S/4H, or 2D/2S |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
- en: '| t5/t6 | 8H/16B, 4S/8H, or 2D/4S |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
- en: '| t7 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| t8/t9 | 4H/8B, 8H/16B, 2S/4H, 4S/8H, 1D/2S, or 2D/4S |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: The remainder of this section describes each of the addition instructions in
    [Table 11-8](chapter11.xhtml#tab11-8) in greater detail.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The add instruction, with vector register operands, does a lane-by-lane addition.
    Any overflow (signed or unsigned) is ignored, with the sum holding the LO bits
    of the result. If the type is 8B, 4H, or 2S, the add instruction adds only the
    lanes in the LO 64 bits of the registers, zeroing out the HO 64 bits of the destination
    register. [Figure 11-20](chapter11.xhtml#fig11-20) provides an example of a 16B
    lane-by-lane addition.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-20.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: 16B lane-by-lane addition using add Vd.16b, Vs1.16b, Vs2.16b'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: The fadd instruction, with vector register operands, adds two- or four-lane
    single-precision values together, or a pair of double-precision floating-point
    values. With 2S types, the fadd instruction clears the HO 64 bits of the destination
    register.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: The sqadd and uqadd instructions do a lane-by-lane addition (signed and unsigned,
    respectively), except they saturate their results in the case of overflow (or
    underflow, when adding signed numbers). As with add, those instructions that take
    64-bit source operands produce a 64-bit result and zero out the HO 64 bits of
    the destination register.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: The saddl and uaddl instructions take the lanes in the LO 64 bits of the source
    registers, sign- or zero-extend these values to twice their size, compute the
    sum, and store the results in the full destination register (with double-sized
    lanes). The destination register type must be specified as twice the size of the
    source register types (see [Figure 11-21](chapter11.xhtml#fig11-21)). Because
    the sum of two *n*-bit numbers requires no more than *n* + 1 bits, these instructions
    will produce the correct result without any possibility of overflow or underflow.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-21.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: A uaddl operation (uaddl Vd.4s, Vs1.4h, Vs2.4h)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: The saddl2 and uaddl2 instructions also sign- or zero-extend the values in the
    lanes in one-half of the source register and produce a sum in the full 128 bits
    of the destination register. However, the saddl2 and uaddl2 instructions compute
    the sum of the lanes in the HO 64 bits of the source registers (see [Figure 11-22](chapter11.xhtml#fig11-22)).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-22.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: A saddl2 operation (saddl2 Vd.4s, Vs1.8h, Vs2.8h)'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Although the saddl2 and uaddl2 instructions’ source operands are only 64 bits,
    you must specify the 128-bit types (16B, 8H, 4S) as the source type because the
    instruction retrieves the data from the upper 64 bits of a 128-bit value.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The saddw, uaddw, saddw2, and uaddw2 instructions allow you to produce the sum
    of two operands whose sizes are different. The saddw and uaddw instructions expect
    the second source operand’s type to be half the size of the first source and the
    destination operands’ types, though you specify the same number of lanes for all
    three operands. These instructions will sign- or zero-extend (respectively) the
    lanes in the second source operand to the size of the other two, compute the sum,
    and then store the data into the destination lanes (see [Figure 11-23](chapter11.xhtml#fig11-23)).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-23.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: A uaddw operation (uaddw Vd.4s, Vs1.4s, Vs2.4h)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: The saddw2 and uaddw2 instructions also sign- or zero-extend the second source
    operand, but they operate on the HO 64 bits rather than the LO 64 bits (see [Figure
    11-24](chapter11.xhtml#fig11-24)). You must specify double the number of lanes
    for the second operand so that the instruction will operate on the full 128 bits
    of the second source operand.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-24.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-24: A saddw2 operation (saddw2 Vd.4s, Vs1.4s, Vs2.4h)'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Overflow (underflow) is possible when using the saddw, uaddw, saddw2, and uaddw2
    instructions (for example, when adding 0xFFFF with 0x01). These instructions will
    ignore the overflow and keep the LO bits of the result.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: The addhn (vector add with narrowing) and raddhn (vector add, round, and narrow)
    instructions add the specified lanes together, then *narrow* the result by keeping
    only the HO bits. These instructions’ destination type is half the size of the
    source types. For example, if you add half-word lanes together, the narrowing
    additions will keep only the HO byte of the results.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'The raddhn instruction rounds the result before storing it into the destination
    register. If the LO half of the result contains a 1 in its HO bit position, raddhn
    increments the HO byte by 1; otherwise, it returns the same result as addhn. Consider
    the following instruction:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If V2 contained 0x00010001 and V1 contained 0xFE7FFE7F, then V0 would contain
    0xFFFF after execution of this instruction. Had V1 contained 0xFE7EFE7E, though,
    V0 would contain 0xFEFE afterward.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Overflow can still occur during the execution of addhn and raddhn. Adding half
    words 0xFFFF and 0x0001 together will produce 0x00 in the corresponding destination
    byte lane.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The addhn2 and raddhn2 instructions also compute *add and narrowing* (with rounding,
    if specified); however, they store their results in the HO 64 bits of the destination
    register and leave the LO 64 bits of the destination unchanged. Because these
    instructions operate on the HO 64 bits of the destination, the destination’s lane
    count must be twice that of the source registers. For example
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: adds the LO 8 half words of V1 and V2 and stores the HO 8-bit result of each
    lane addition into the HO 8 bytes of V0 (leaving the LO 8 bytes untouched). You
    must specify the destination register’s type as 16B, even though this instruction
    stores only 8 bytes into the register.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: The shadd, uhadd, srhadd, and urhadd instructions add a pair of lanes together,
    shift right by 1 (with optional rounding, for those instructions containing an
    r), and store the result into the destination lane. As usual, the instructions
    beginning with an s handle signed values, while the instructions beginning with
    a u handle unsigned values. Because an addition of *n* bits never produces more
    than *n* + 1 bits, and a division by 2 is the same as a shift right by 1 bit,
    these instructions never produce an overflow. Consider the addition of the two
    largest single-byte values, 0xFF + 0xFF = 0x1FE. Shifting this sum to the right
    1 bit gives you 0xFF, which fits just fine into 8 bits. Even with rounding, overflow
    will not occur.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are especially handy for processing digital audio. For example,
    suppose you want to mix together two 16-bit audio tracks. Simply summing the hwords
    from the two tracks will boost the volume by 3 decibels (dB) (equivalent to doubling
    the digital value). Halving the result after the sum reduces this volume increase
    by 3 dB. The urhadd instruction would be ideal for mixing these tracks as it would
    divide the result by 2, averaging the values of the two tracks.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.2 Pairwise Addition
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thus far, all the addition operations have operated on corresponding lanes in
    the source operands, producing a result that the instructions store in the same
    lane in the destination register. This is known as a *vertical addition* because
    the data flows vertically from register to register, as shown previously in [Figure
    11-20](chapter11.xhtml#fig11-20). On occasion, you may want to produce the sum
    of adjacent elements within a vector rather than the elements in corresponding
    lanes of two vectors (horizontal addition). You can accomplish this with the *pairwise
    addition* instructions from [Table 11-8](chapter11.xhtml#tab11-8).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'The pairwise addition instructions, as their name suggests, add adjacent pairs
    of lanes in vectors. Because the result requires half the number of lanes that
    are present in the source, the pairwise additions produce a single vector result
    from two source registers. Consider the following example that pairwise-adds the
    half words in V1 and V2, producing the pairwise sum in V0:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This instruction computes the following results:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: V0[0] = V2[0] + V2[1]
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: V0[1] = V2[2] + V2[3]
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: V0[2] = V1[0] + V1[1]
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: V0[3] = V1[2] + V1[3]
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-25](chapter11.xhtml#fig11-25) diagrams this operation.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-25.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-25: The addp v0.4s, v2.4s, v1.4s instruction'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction also has a floating-point version that adds adjacent single-
    or double-precision values in a pair of vectors: faddp. For example, the following
    instruction performs the same operation as the previous addp integer example but
    adds adjacent single-precision floating-point values rather than 32-bit integer
    values:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The addp instruction ignores any overflow during the addition. To produce a
    correct result, use the saddlp and uaddlp instruction (signed and unsigned pairwise
    add long) to sign- or zero-extend the lane values prior to the addition. The syntax
    for these two instructions is different from that of the other addition instructions:
    there are only two register operands (a source and a destination register). For
    example, because the following instruction doubles the size of the result to place
    in the destination operand and sums adjacent elements of the source operand, there
    is no need for a second register operand:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note that the destination register type size must be twice that of the source,
    and the number of lanes must be half that of the source.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: The uaddalp and saddalp instructions are functionally similar to uaddlp and
    saddlp, but rather than simply storing the pairwise sum into the destination lanes,
    they add the sum to the value already present in the destination lanes.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.3 Vector Saturating Accumulate
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set includes two instructions that sum the lanes of a source
    vector into the corresponding lanes of a destination vector. The instructions
    are
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: where t is 8B, 4H, or 2S when operating on the LO 64 bits of the registers,
    or 16B, 8H, 4S, or 2D when operating on all 128 bits. The 64-bit variants will
    clear the HO 64 bits of Vd.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are unusual in that they allow you to add (with saturation)
    an unsigned input into a signed value or add a signed number into an unsigned
    value (usually instructions operate on only one type of data).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: The usqadd instruction adds a signed value in the source lanes to the unsigned
    value in the corresponding destination lanes. Should the sum exceed the maximum
    (unsigned) value for the destination lane’s size, this instruction will saturate
    the lane to the maximum value. Should the sum go negative, this instruction saturates
    the destination lane to 0\. For example, if a half-word destination lane contains
    0xFFF0 and the corresponding source lane contains 0xFF, the usqadd instruction
    (with a 4H or 8H type) will produce 0xFFFF in the destination lane. On the other
    hand, if the destination lane contains 0x08 and the source lane contains 0xFFF0
    (–16), then their sum will produce 0 in the destination lane.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'The suqadd instruction is the converse operation: it adds an unsigned source
    operand to a signed destination operand, saturating to the maximum signed value.
    For example, if a destination half-word lane contains 0x7FF0 and the corresponding
    source lane contains 0x00FF, their sum will produce 0x7FFF, the maximum signed
    value. Note that if the destination operand contains 0xFFFF (–1) and the source
    operand is 0x0002, you wind up with 0x0001 in the destination lane (–1 + 2 = 1).'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: The usqadd and suqadd instructions also have scalar variants
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: where Rd and Rs are one of the scalar registers Bn, Hn, Sn, or Dn.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The suqadd instruction will always produce the maximum signed value when overflowing,
    as you can’t reduce the value by adding an unsigned number to it.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.4 Horizontal Add
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The addv (add across vector) instruction produces the sum of all the lanes in
    a single source vector register and leaves the result in a scalar element of another
    vector register (this is known as *reduction*). The syntax for this instruction
    is as follows
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: where R is the destination register and is one of B*n*, H*n*, or S*n*. The legal
    vector register type and lane count depend on the scalar register; [Table 11-10](chapter11.xhtml#tab11-10)
    lists the valid types.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-10: Valid Vector Register Types for addv'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '| Scalar register (Rd) | Valid lane count and types |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
- en: '| Bd | 8B or 16B |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
- en: '| Hd | 4H or 8H |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
- en: '| Sd | 4S |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
- en: This instruction is useful for summing up the elements of an array. Unfortunately,
    the destination scalar type must be the same as the source lanes’ type, and any
    overflow is ignored. There is no instruction that will zero- or sign-extend the
    sum to a double-sized result. Therefore, it’s advisable to zero- or sign-extend
    the vector elements to the next larger size prior to executing addv if overflow
    is possible. You can accomplish this by using the saddlp or uaddlp instruction
    to add adjacent pairs and sign- or zero-extend (respectively), then use the addv
    instruction to sum the resulting double-sized lanes.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: The addvl instruction is part of the ARM *scalable vector extensions (SVE)*,
    which are beyond the scope of this book. While you might expect addvl to be a
    long version of the addv instruction, it actually does something completely different.
    See the ARM SVE documentation for more details.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.5 Scalar Saturating and Scalar Pairwise Addition
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set also provides a couple of saturating scalar addition
    instructions
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: where R represents one of the scalar register names B, H, S, or D. These instructions
    operate on the 8-, 16-, 32-, or 64-bit signed or unsigned integer values found
    in the LO bits of the specified V register (see [Figure 11-2](chapter11.xhtml#fig11-2)
    for the correspondence between the V*n*, B*n*, H*n*, S*n*, and D*n* registers).
    These instructions do the same thing as their vector counterparts, except, of
    course, they operate only on a scalar value rather than doing a lane-by-lane vector
    operation.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the scalar variants of the addp and faddp instructions:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note the limited lane count and type support of these instructions.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: The addp instruction ignores (discards) any overflow from the addition of the
    two dword elements from the source vector. The addpl and addpl2 instructions have
    no scalar versions. Use the actual addpl and addpl2 instructions (with a second
    vector containing 0s) if you need an extended-precision version of this instruction.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.2 Subtraction
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While there aren’t quite as many Neon instructions for subtraction as there
    are for addition, most of the addition instructions have a subtraction complement.
    [Table 11-11](chapter11.xhtml#tab11-11) provides the syntax for the various vector
    subtraction instructions and associated data types; these instructions generally
    compute Vd = Vl *–* Vr (exceptions as noted), where Vd = destination, Vl = left
    operand, and Vr = right operand.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-11: Neon Subtraction Instructions'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
- en: '| sub | sub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane integer difference
    |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
- en: '| fsub | fsub Vd.t2, Vl.t2, Vr.t2 | Computes lane-by-lane floating-point difference
    |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
- en: '| uqsub | uqsub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane unsigned integer
    subtraction with saturation |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
- en: '| sqsub | sqsub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane signed integer
    subtraction with saturation |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
- en: '| usubl | usubl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane unsigned long integer
    subtraction |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
- en: '| ssubl | ssubl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane signed long integer
    subtraction |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
- en: '| usubl2 | usubl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned long
    integer subtraction of the HO half of Vr |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
- en: '| ssubl2 | ssubl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed long integer
    subtraction of the HO half of Vr |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
- en: '| usubw | usubw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane unsigned wide integer
    subtraction |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
- en: '| ssubw | ssubw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane signed wide integer
    subtraction |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
- en: '| usubw2 | usubw2 Vd.t5, Vl.t4, Vr.t6 | Computes lane-by-lane unsigned wide
    integer subtraction involving the upper half of Vl |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
- en: '| ssubw2 | ssubw2 Vd.t5, Vl.t5, Vr.t6 | Computes lane-by-lane signed wide integer
    subtraction involving the upper half of Vl |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
- en: '| subhn | subhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane subtraction with
    narrowing |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
- en: '| rsubhn | rsubhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane subtraction with
    rounding and narrowing |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
- en: '| subhn2 | subhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane subtraction with
    narrowing (uses HO bits) |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
- en: '| rsubhn2 | rsubhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane subtraction
    with rounding and narrowing (uses HO bits) |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
- en: '| uhsub | uhsub Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned subtraction
    with halving |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
- en: '| shsub | shsub Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed subtraction
    with halving |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
- en: The behavior of these instructions is very similar to their addition counterparts,
    except, of course, that they subtract the values in the lanes rather than adding
    them. See the previous section for more details.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a saturating scalar subtraction instruction:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: That subtracts the two source scalar registers (B*n*, H*n*, S*n*, or D*n*),
    producing a scalar result.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.3 Absolute Difference
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the normal subtraction instructions, the Neon instruction set
    includes several instructions that compute the difference of the values in corresponding
    lanes and then compute the absolute value of this difference. These instructions
    are handy for computing distances and other vector (as in physics) calculations.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-12](chapter11.xhtml#tab11-12) lists the available absolute difference
    instructions. In the Syntax column, Vd = destination, Vl = left operand, and Vr
    = right operand. Each instruction generally computes Vd = abs(Vl *–* Vr), unless
    otherwise noted.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-12: Neon Absolute Difference Instructions'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
- en: '| uabd | uabd Vd.t1, Vl.t1, Vr.t1 | Vector unsigned absolute difference; lanes
    contain unsigned values. |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
- en: '| sabd | sabd Vd.t1, Vl.t1, Vr.t1 | Vector signed absolute difference; lanes
    contain signed values. |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
- en: '| uaba | uaba Vd.t1, Vl.t1, Vr.t1 | Vector unsigned absolute difference and
    accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values. |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: '| saba | saba Vd.t1, Vl.t1, Vr.t1 | Vector signed absolute difference and accumulate;
    Vd = Vd + abs(Vl – Vr), where lanes contain signed values. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| uabdl | uabdl Vd.t2, Vl.t3, Vr.t3 | Vector unsigned absolute difference long;
    lanes contain unsigned values. |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| sabdl | sabdl Vd.t2, Vl.t3, Vr.t3 | Vector signed absolute difference long;
    lanes contain signed values. |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
- en: '| uabal | uabal Vd.t2, Vl.t3, Vr.t3 | Vector unsigned absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
- en: '| sabal | sabal Vd.t2, Vl.t3, Vr.t3 | Vector signed absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain signed values. |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
- en: '| uabdl2 | uabdl2 Vd.t4, Vl.t5, Vr.t5 | Vector unsigned absolute difference
    long; lanes contain unsigned values. Uses HO 64 bits of Vl and Vr. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
- en: '| sabdl2 | sabdl2 Vd.t4, Vl.t5 Vr.t5 | Vector signed absolute difference long;
    lanes contain signed values. Uses HO 64 bits of Vl and Vr. |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
- en: '| uabal2 | uabal2 Vd.t4, Vl.t5, Vr.t5 | Vector unsigned absolute difference
    long and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values.
    Uses HO 64 bits of Vl and Vr. |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
- en: '| sabal2 | sabal2 Vd.t4, Vl.t5, Vr.t5 | Vector signed absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain signed values. Uses
    HO 64 bits of Vl and Vr. |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Vd.t6, Vl.t6, Vr.t6 | Vector floating-point absolute difference;
    lanes contain floating-point values. |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Sd, Sl, Sr | Scalar single-precision floating-point absolute
    difference; Sd = abs(Sl – Sr). |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Dd, Dl, Dr | Scalar double-precision floating-point absolute
    difference; Dd = abs(Dl – Dr). |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
- en: '[Table 11-13](chapter11.xhtml#tab11-13) lists the legal types for the absolute
    difference instructions.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-13: Legal Types for Absolute Difference Instructions'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
- en: '| t2/t3 | 8H/8B, 4S/4H, or 2D/2S |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
- en: '| t4/t5 | 8H/16B, 4S/8H, or 2D/4S |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
- en: '| t6 | 2S, 4S, or 2D |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
- en: The uabd and sabd instructions compute the difference of each lane, take the
    absolute value of the difference, and store the result into the destination lane.
    Although the two instructions operate on unsigned and signed source operands (respectively),
    the result is always an unsigned value. Effectively, these are just variants of
    the sub instruction that take the absolute value of the result. As long as you
    treat the result as an unsigned number (particularly in the case of the sabd instruction),
    these instructions will not produce an overflow (underflow).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: The uaba and saba instructions add the absolute value of the difference to the
    corresponding lane in the destination register. If an overflow occurs (on the
    addition), these instructions store the LO bits (the lane size) into the corresponding
    destination lane. For signed operations, if Vl contains the most negative value
    (for example, 0x80 for a byte) and Vr contains 0, overflow occurs and the instruction
    winds up adding that most negative value to the destination lane.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: The suffix-l and suffix-l2 variants of these instructions compute a long calculation.
    The uabdl and sabdl instructions first zero- or sign-extend (respectively) the
    lane values to twice the lanes’ size, then compute the absolute value of the difference
    and store the result into the corresponding double-sized lane. The uabdl2 and
    sabdl2 instructions do the same thing but grab the lane data from the HO 64 bits
    of the source operands (refer back to [Figures 11-21](chapter11.xhtml#fig11-21)
    and [11-22](chapter11.xhtml#fig11-22) and substitute the appropriate instruction
    to see how this works).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: The fabd instruction computes the absolute difference of two floating-point
    values. With vector register operands, it processes two double-precision or four
    single-precision floating-point values at a time. This instruction also supports
    scalar operations (single- or double-precision) by specifying the D*n* or S*n*
    registers as operands. Unfortunately, there is no floating-point absolute difference
    and accumulate instruction. You can simulate this instruction by following an
    fabd instruction with an fadd instruction (using a spare vector register to hold
    the temporary result from fabd).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4 Vector Multiplication
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set includes several instructions that compute the product
    of corresponding lanes in the vector register (both integer and floating-point
    products). The standard vector multiply instructions appear in [Table 11-14](chapter11.xhtml#tab11-14).
    Note that Vl is the left source operand and Vr is the right source operand.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-14: Neon Vector Multiply Instructions'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
- en: '| mul | mul Vd.t1, Vl.t1, Vr.t1 | Multiplication: Vd = Vl × Vr. Ignores overflow,
    keeps LO bits of result (lane by lane). |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
- en: '| mla | mla Vd.t1, Vl.t1, Vr.t1 | Multiply and accumulate: Vd = Vd + Vl × Vr.
    Ignores overflow, keeps LO bits of result (lane by lane). |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
- en: '| mls | mls Vd.t1, Vl.t1, Vr.t1 | Multiply and subtract: Vd = Vd − Vl × Vr.
    Ignores overflow, keeps LO bits of result (lane by lane). |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
- en: '| smull | smull Vd.t2, Vl.t3, Vr.t3 | Signed extended multiplication: Vd =
    Vl × Vr. Multiplies LO half of Vl by Vr and stores extended-precision result in
    the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
- en: '| umull | umull Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiplication: Vd
    = Vl × Vr. Multiplies LO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
- en: '| smull2 | smull2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiplication: Vd
    = Vl × Vr. Multiplies HO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
- en: '| umull2 | umull2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiplication: Vd
    = Vl × Vr. Multiplies HO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
- en: '| smlal | smlal Vd.t2, Vl.t3, Vr.t3 | Signed extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies LO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
- en: '| umlal | umlal Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies LO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
- en: '| smlal2 | smlal2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies HO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
- en: '| umlal2 | umlal2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies HO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
- en: '| smlsl | smlsl Vd.t2, Vl.t3, Vr.t3 | Signed extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies LO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
- en: '| umlsl | umlsl Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies LO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
- en: '| smlsl2 | smlsl2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies HO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
- en: '| umlsl2 | umlsl2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies HO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply: Vd = Vl × Vr.
    Multiplies the floating-point values in the Vl and Vr lanes and stores the product
    into the corresponding Vd lanes (lane by lane). |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply: Vd = Vl × Vr.
    Multiplies the floating-point values in the Vl and Vr lanes and stores the product
    into the corresponding Vd lanes (lane by lane). This variant handles the case
    where one source operand is 0 and the other is ±∞, producing the value ±2 (–2
    if –∞, +2 otherwise). |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply and accumulate:
    Vd = Vd + Vl × Vr (lane by lane). |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply and subtract: Vd
    = Vd – Vl × Vr (lane by lane). |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
- en: '[Table 11-15](chapter11.xhtml#tab11-15) lists the legal types for the instructions
    appearing in [Table 11-14](chapter11.xhtml#tab11-14).'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-15: Legal Types for Vector Multiply Instructions'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types | Notes |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, or 4S | 8B, 4S, and 2S operate only on LO 64 bits.
    |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: '| t2/t3 | 8H/8B, 4S/4H, or 2D/2S | t3 lanes are taken from the LO 64 bits.
    |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
- en: '| t4/t5 | 8H/16B, 4S/8H, or 2D/4S | t5 lanes are taken from the HO 64 bits.
    |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
- en: '| t6 | 2S, 4S, or 2D |  |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
- en: There are also pmul, pmull, and pmull2 (polynomial multiplication) instructions.
    However, polynomial multiplication isn’t a traditional multiply operation, and
    a discussion of this is beyond the scope of this book. See the Arm documentation
    for more details on these instructions.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.1 Vector Saturating Multiplication and Double
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The vector saturating multiplication and double instructions build on the standard
    multiply, multiply and accumulate, and multiply and subtract instructions to produce
    an extended precision (long) result that doubles the product and saturates the
    result. The instructions in this set appear in [Table 11-16](chapter11.xhtml#tab11-16)
    and compute Vd = saturate({Vd ±}(Vl × Vr) × 2), where Vd is the destination operand,
    Vl is the left operand, and Vr is the right operand; {Vd ±} indicates that Vd
    ± is an optional source operand.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-16: Vector Multiply and Double with Saturation Instructions'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
- en: '| sqdmull | sqdmull Vd.t1, Vl.t2, Vr.t2 | Vd = (Vl × Vr) × 2 (lane by lane)
    |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal | sqdmlal Vd.t1, Vl.t2, Vr.t2 | Vd = Vd + (Vl × Vr) × 2 (lane by
    lane) |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl | sqdmlsl Vd.t1, Vl.t2, Vr.t2 | Vd = Vd − (Vl × Vr) × 2 (lane by
    lane) |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
- en: '| sqdmull2 | sqdmull2 Vd.t3, Vl.t4, Vr.t4 | Vd = (Vl × Vr) × 2 (lane by lane,
    HO 64 bits of source) |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal2 | sqdmlal2 Vd.t3, Vl.t4, Vr.t4 | Vd = Vd + (Vl × Vr) × 2 (lane by
    lane, HO 64 bits) |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl2 | sqdmlsl2 Vd.t3, Vl.t4, Vr.t4 | Vd = Vd – (Vl × Vr) × 2 (lane by
    lane, HO 64 bits) |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
- en: '| sqdmull | sqdmull Vd.t5, Vl.t6, Vr.t7[x] | Vd = (Vl × Vr) × 2 (Vl lanes ×
    Vr[x] scalar) |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal | sqdmlal Vd.t5, Vl.t6, Vr.t7[x] | Vd = Vd + (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar) |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl | sqdmlsl Vd.t5, Vl.t6, Vr.t7[x] | Vd = Vd – (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar) |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
- en: '| sqdmull2 | sqdmull2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar, HO 64 bits) |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal2 | sqdmlal2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = Vd + (Vl × Vr) × 2 (Vl
    lanes × Vr[x] scalar, HO 64 bits) |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl2 | sqdmlsl2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = Vd – (Vl × Vr) × 2 (Vl
    lanes × Vr[x] scalar, HO 64 bits) |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
- en: The legal types and lane counts appear in [Table 11-17](chapter11.xhtml#tab11-17).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-17: Legal Types and Lane Counts for Vector Multiply and Double with
    Saturation'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types and lane counts |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4S/4H, or 2D/2S |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 4S/8H, or 2D/4S |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
- en: '| t5/t6/t7 | 4S/4H/H, or 2D/2S/S |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
- en: '| t8/t9/t10 | 4S/8H/H, or 2D/4S/S |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
- en: These instructions all sign-extend their source operands to twice their size
    and multiply them to produce a product. They then multiply this product by 2\.
    The standard multiply variants saturate and store this product into the corresponding
    destination lane. The multiply and accumulate variants add the product (multiplied
    by 2) to the destination and saturate the result. The multiply and subtract variants
    subtract the product (multiplied by 2) from the destination and saturate the result.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: The instructions without a 2 suffix extract their lanes from the LO 64 bits
    of the first source register, while those with a 2 suffix extract their lanes
    from the HO 64 bits of the second source register.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: The last six instructions in [Table 11-16](chapter11.xhtml#tab11-16) multiply
    the lanes in Vl by a scalar value selected from one of the lanes in Vr (selected
    by the [x] index operator). Here, x must be an appropriate value for the source
    type (0 to 7 for bytes, 0 to 3 for half words, or 0 to 1 for words). For the last
    six forms, if t10 is H, then the Vr register number (r) must be in the range 0
    to 15.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of “short” versions of the sqdmul* instructions don’t double the type
    size in the destination register: sqdmulh and sqrdmulh. These instructions also
    multiply their source operands, double the result, and saturate it. However, they
    store only the HO 64 bits of the result into the destination lane (with saturation
    and possible rounding). [Table 11-18](chapter11.xhtml#tab11-18) lists these instructions.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-18: Saturating Multiply and Double Instructions, HO Bits'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Vd.t1, Vl.t1, Vr.t1 | Lane-by-lane multiply, double, saturate,
    and keep HO half of product. |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Vd.t1, Vl.t1, Vr.t1 | Lane-by-lane multiply, double,
    round, saturate, and keep HO half of product. |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Vd.t2, Vl.t3, Vr.t4[x] | Multiply the lanes in Vl by the
    scalar selected by Vr[x]; double the result, saturate, and keep the HO half of
    the product. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Vd.t2, Vl.t3, Vr.t4[x] | Multiply the lanes in Vl by
    the scalar selected by Vr[x]; double the result, round, saturate, and keep the
    HO half of the product. |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Rd, Rl, Rr | Scalar version of sqdmulh. |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Rd, Rl, Rr | Scalar version of sqrdmulh. |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
- en: In this table, t1 is 4H, 8H, 2S, or 4S. For the 4H and 2S types, the instruction
    works only with the LO 64 bits of the registers; the 8H and 4S types use all 128
    bits.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: The type specification t2/t3/t4 is 4H/4H/H, 8H/8H/H, 2S/2S/S, or 4S/S; the 4H
    and 2S types work with the LO 64 bits of the registers, and the 8H and 4S types
    work on all 128 bits of the registers. If the type is H, Vr’s register number
    must be in the range 0 to 15.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: If the [x] index appears after Vr*.*t4, the instruction multiplies the lanes
    in Vl by the scalar value extracted from lane x of Vr, which must be an appropriate
    value for the source type (0 to 7 for bytes, 0 to 3 for half words, or 0 to 1
    for words).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: These instructions have two scalar variants. R (in Rd, Rl, and Rr) must be H
    or S. For example
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: computes H0 = saturate(H1 × H2 × 2).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.2 Vector Multiplication by a Scalar Element
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions that multiply all the
    elements of a vector by a single scalar value, as listed in [Table 11-19](chapter11.xhtml#tab11-19).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-19: Vector Multiply by Scalar Instructions'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
- en: '| mul | mul Vd.t1, Vl.t1, Vr.t2[x] | Multiply integer vector element by scalar
    value. Multiply each lane in Vl by Vr[x] (scalar value) and store the product
    into the corresponding lane in Vd (that is, for each lane i, Vd[i] = Vl[i] × Vr[x]).
    |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
- en: '| mla | mla Vd.t1, Vl.t1, Vr.t2[x] | Multiply vector elements by a scalar and
    accumulate. For each lane i, Vd[i] = Vd[i] + Vl[i] × Vr[x]. |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
- en: '| mls | mls Vd.t1, Vl.t1, Vr.t2[x] | Multiply vector elements by a scalar and
    subtract. For each Iane i, Vd[i] = –d[i] – Vl[i] × Vr[x]. |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
- en: '| smull | smull Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar,
    long. Sign-extend the (LO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the LO 64 bits
    of Vl. |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
- en: '| smlal | smlal Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar and
    accumulate, long. Similar to smull, but sums the product into Vd rather than just
    storing it into Vd. |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
- en: '| smlsl | smlsl Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar and
    subtract, long. Similar to smull, but subtracts the product from Vd rather than
    just storing it into Vd. |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
- en: '| smull2 | smull2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar,
    long. Sign-extend the (HO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the HO 64 bits
    of Vl. |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
- en: '| smlal2 | smlal2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar
    and accumulate, long (HO source). Similar to smull2, but sums the product into
    Vd rather than just storing it into Vd. |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
- en: '| smlsl2 | smlsl2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar
    and subtract, long (HO source). Similar to smull2, but subtracts the product from
    Vd rather than just storing it into Vd. |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
- en: '| umull | umull Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar,
    long. Zero-extend the (LO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the LO 64 bits
    of Vl. |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
- en: '| umlal | umlal Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar
    and accumulate, long. Similar to umull, but sums the product into Vd rather than
    just storing it into Vd. |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
- en: '| umlsl | umlsl Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar
    and subtract, long. Similar to umull, but subtracts the product from Vd rather
    than just storing it into Vd. |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
- en: '| umull2 | umull2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar,
    long. Zero-extend the (HO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the HO 64 bits
    of Vl. |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
- en: '| umlal2 | umlal2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar
    and accumulate, long (HO source). Similar to umull2, but sums the product into
    Vd rather than just storing it into Vd. |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
- en: '| umlsl2 | umlsl2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar
    and subtract, long (HO source). Similar to umull2, but subtracts the product from
    Vd rather than just storing it into Vd. |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar. Multiply each lane in Vl by Vr[x] (scalar value) and store the product
    into the corresponding lane in Vd (that is, for each lane i, Vd[i] = Vl[i] × Vr[x]).
    |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Vd.t9, Vl.t10, Vr.t11[x] | Like fmul, except it’s a special
    variant that handles the case where one source operand is 0 and the other is ±∞.
    This produces the value ±2 (–2 if –∞, +2 otherwise). |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar and accumulate. Multiply each lane in Vl by Vr[x] (scalar value) and add
    the product into the corresponding lane in Vd (that is, for each lane i, Vd[i]
    = Vd[i] + Vl[i] × Vr[x]). |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar and subtract. Multiply each lane in Vl by Vr[x] (scalar value) and subtract
    the product from the corresponding lane in Vd (that is, for each lane i, Vd[i]
    = Vd[i] – Vl[i] × Vr[x]). |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
- en: '[Table 11-20](chapter11.xhtml#tab11-20) lists the legal types and lane counts
    for the instructions in [Table 11-19](chapter11.xhtml#tab11-19).'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-20: Legal Types and Lane Counts for Vector Multiply by Scalar'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types and lane counts |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4H/H, 8H/H, 2S/S, or 4S/S |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
- en: '| t3/t4/t5 | 4S/4H/H or 2D/2S/S |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
- en: '| t6/t7/t8 | 4S/8H/H, or 2D/4S/S |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
- en: '| t9/t10/t11 | 2S/2S/S, 4S/S, or 2D/D |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
- en: '[Figure 11-26](chapter11.xhtml#fig11-26) shows the basic operation of the mul,
    mla, mls, fmul, fmla, and fmls instructions.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-26.jpg)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-26: Vector multiply by scalar operation'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-27](chapter11.xhtml#fig11-27) shows the basic operation of the smull,
    umull, smlal, umlal, smlsl, and umlsl instructions.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-27.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-27: Vector multiply by scalar, long (LO bits)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-28](chapter11.xhtml#fig11-28) shows the basic operation of the smull2,
    umull2, smlal2, umlal2, smlsl2, and umlsl2 instructions.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-28.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-28: Vector multiply by scalar, long (HO bits)'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Because the product of two *n*-bit numbers fits into 2*n* bits, the smul/smul2
    and umul/umul2 instructions will not produce an overflow. However, keep in mind
    that an addition or subtraction after the multiplication could require an additional
    bit (2*n* + 1 bits). Should that occur, these instructions will ignore the overflow
    and keep the LO bits.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.3 Scalar Multiplication by a Vector Element
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides variants of the fmul instructions that multiply
    a scalar register (Sn or Dn) by a vector element (Vn[x]), storing the result back
    into a scalar register. [Table 11-21](chapter11.xhtml#tab11-21) lists the syntax
    for these instructions, where Fl is the left source operand and Vr is the right
    source operand.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-21: Floating-Point Scalar Multiplication by Vector Element Instructions'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Fd, Fl, Vr.t[x] | Fd = Fl × Vr.t[x] |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Fd, Fl, Vr.t[x] | Fd = Fl × Vr.t[x]. Handles case where Fl
    = 0.0 and Vr.t is ±∞, which produces ±2.0. |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Fd, Fl, Vr.t[x] | Fd = Fd + Fl × Vr.t[x] |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Fd, Fl, Vr.t[x] | Fd = Fd – Fl × Vr.t[x] |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
- en: Registers Fd and Fl are each one of the scalar floating-point registers (Sn
    or Dn). Type t must be a matching size (S or D). If the type is single-precision
    (Sn), then Vr must be a register in the range V0 to V15.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: These multiplication instructions have no integer equivalents.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.5 Vector Division
  id: totrans-798
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set does not provide any instructions to perform integer
    division on vectors. It does, however, provide an instruction to perform floating-point
    division on lanes in a pair of vectors
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: where t is 2S, 4S, or 2D. (A division by zero produces NaN in the destination
    lane.)
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: Because floating-point division is rather slow, especially when iterated over
    all the lanes, the Neon instruction set includes a pair of instructions that will
    compute the reciprocal of a floating-point value. Multiplication by a reciprocal
    is usually much faster than division. If you’re dividing by a constant, you can
    precompute the reciprocal value at assembly time and use that (no runtime cost).
    If the value is a variable that you cannot compute at assembly time, you can use
    the frecpe instruction to *approximate* the reciprocals of all the lanes in a
    vector register
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: where t is 2S, 4S, or 2D (2S operates on the LO 64 bits of the registers).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: There is a scalar version of frecpe
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: where Rd and Rs are either S*n* or D*n*.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'The frecpe instruction produces a reciprocal approximation that is within 8
    bits of the correct value—not great, but good enough for quick-and-dirty calculations.
    If you need better accuracy, use the frecps instruction (same syntax except for
    the mnemonic) to compute another step in the Newton-Raphson reciprocal approximation
    algorithm, using code like the following:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The more times you repeat the refinement step, the more accurate your result
    will be. However, at some point, the cost of executing all these floating-point
    instructions will exceed the time consumed by a single fdiv instruction, so take
    care because using frecps has diminishing returns.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: There is a urecpe instruction for estimating fixed-point reciprocals, but fixed-point
    arithmetic is beyond this scope of this book. To learn more, see the ARM Architecture
    Reference Manual, linked in section 11.15, “For More Information,” on [page 700](chapter11.xhtml#pg_700).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.6 Sign Operations
  id: totrans-812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set includes four instructions that allow you to negate
    or take the absolute values of the lanes in a vector register
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: where t1 represents the usual integer types (8B, 16B, 4H, 8H, 2S, 4S, or 2D)
    and t2 represents the usual floating-point types (2S, 4S, and 2D). The 8B, 4H,
    and 2S types reference only the LO 64 bits of the vector register.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: The abs and fabs instructions compute the absolute values of each of the lanes
    in the source register, storing the result into the destination register. Obviously,
    abs works on (signed) integer values, while fabs works on floating-point values.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: The neg and fneg instruction negate (change the sign of) the source lanes, leaving
    the negated result in the corresponding destination lane. As expected, neg works
    on signed integers, and fneg works on floating-point values.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: The sqabs and sqneg instructions are special saturating variants of the abs
    and neg instructions that never overflow. The most negative value (for example,
    0x80 for byte values) will overflow when you take its absolute value or negate
    it; in both cases, you wind up with the same value. The sqabs and sqneg instruction
    will produce the maximum positive value (for example, 0x7F for byte values) if
    you attempt to negate it or take its absolute value.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: The abs, neg, sqabs, and sqneg instructions also have scalar versions, as shown
    in [Table 11-22](chapter11.xhtml#tab11-22). For abs and neg, Rd and Rs can be
    only Dn; for sqabs and sqneg, Rd and Rs are one of the scalar registers Bn, Hn,
    Sn, or Dn.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-22: Scalar Sign Operations'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
- en: '| abs | abs Rd, Rs | Rd = abs(Rs) |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
- en: '| neg | neg Rd, Rs | Rd = –Rs |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
- en: '| sqabs | sqabs Rd, Rs | Rd = abs(Rs), saturated to maximum signed value |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
- en: '| sqneg | sqneg Rd, Rs | Rd = –Rs, saturated to signed range |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
- en: The instructions in [Table 11-22](chapter11.xhtml#tab11-22) operate on the scalar
    value in the specified register.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7 Minimum and Maximum
  id: totrans-828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions that will select the
    minimum or maximum value from corresponding lanes in two vector registers and
    store that value into the corresponding lane of a destination register, as shown
    in [Table 11-23](chapter11.xhtml#tab11-23).
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-23: Vector Min and Max Instructions'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-831
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-832
  prefs: []
  type: TYPE_TB
- en: '| smin | smin Vd.t1, Vl.t1, Vr.t1 | Vd = min(Vl, Vr) (signed integer values)
    |'
  id: totrans-833
  prefs: []
  type: TYPE_TB
- en: '| smax | smax Vd.t1, Vl.t1, Vr.t1 | Vd = max(Vl, Vr) (signed integer values)
    |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
- en: '| umin | umin Vd.t1, Vl.t1, Vr.t1 | Vd = min(Vl, Vr) (unsigned integer values)
    |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
- en: '| umax | umax Vd.t1, Vl.t1, Vr.t1 | Vd = max(Vl, Vr) (unsigned integer values)
    |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
- en: '| fmin | fmin Vd.t2, Vl.t2, Vr.t2 | Vd = min(Vl, Vr) (floating-point values)
    |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
- en: '| fmax | fmax Vd.t2, Vl.t2, Vr.t2 | Vd = max(Vl, Vr) (floating-point values)
    |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
- en: '| fminnm | fminnm Vd.t2, Vl.t2, Vr.t2 | Vd = min(Vl, Vr) (floating-point values)
    |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
- en: '| fmaxnm | fmaxnm Vd.t2, Vl.t2, Vr.t2 | Vd = max(Vl, Vr) (floating-point values)
    |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
- en: In this table, t1 must be 8B, 16B, 4H, 8H, 2S, or 4S. If t1 is 8B, 4H, or 2S,
    the instructions operate only on the lanes in the LO 64 bits of the vector registers;
    if it is 16B, 8H, or 4S, the instructions operate on all 128 bits of the vector
    registers.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: The type t2 must be 2S, 4S, or 2D. If it is 2S, the instructions operate only
    on the LO 64 bits of the vector registers; otherwise, they operate on the entire
    128 bits.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: The fmin and fmax instructions return NaN if either (or both) of the corresponding
    source lanes contain a NaN. The fminnm and fmaxnm instructions, on the other hand,
    return the numeric value if one lane contains a valid number and the other contains
    a NaN. If both lanes contain a valid floating-point value, all four instructions
    behave the same and return the minimum or maximum value (as appropriate).
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.1 Pairwise Minimum and Maximum
  id: totrans-844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The minimum and maximum instructions also have pairwise variants, as shown in
    [Table 11-24](chapter11.xhtml#tab11-24), where t1 and t2 are the same as for the
    lane-by- lane instructions.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-24: Pairwise Minimum and Maximum Instructions'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description | Operates on |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
- en: '| sminp | sminp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_min(Vl, Vr) | Signed integers
    |'
  id: totrans-849
  prefs: []
  type: TYPE_TB
- en: '| smaxp | smaxp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_max(Vl, Vr) | Signed integers
    |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
- en: '| uminp | uminp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_min(Vl, Vr) | Unsigned
    integers |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
- en: '| umaxp | umaxp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_max(Vl, Vr) | Unsigned
    integers |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
- en: '| fminp | fminp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_min(Vl, Vr) | Floating-point
    values |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
- en: '| fmaxp | fmaxp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_max(Vl, Vr) | Floating-point
    values |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
- en: '| fminnmp | fminnmp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_min(Vl, Vr) | Floating-point
    values |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmp | fmaxnmp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_max(Vl, Vr) | Floating-point
    values |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
- en: The pairwise topology is the same as for the addp instruction (see [Figure 11-29](chapter11.xhtml#fig11-29)
    for a uminp example).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-29.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-29: Pairwise minimum and maximum operations'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: There are also a set of pairwise-scalar floating-point minimum and maximum instructions,
    as shown in [Table 11-25](chapter11.xhtml#tab11-25), where Rd/t must be Sn/2S
    or Dn/2D.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-25: Pairwise-Scalar Floating-Point Minimum and Maximum Instructions'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
- en: '| fmaxp | fmaxp Rd, Vs.t | Rd = max(Vs) |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmp | fmaxnmp Rd, Vs.t | Rd = max(Vs) (choose number over NaN) |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
- en: '| fminp | fminp Rd, Vs.t | Rd = min(Vs) |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
- en: '| fminnmp | fminnmp Rd, Vs.t | Rd = min(Vs) (choose number over NaN) |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
- en: These instructions have no integer versions.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.2 Horizontal Minimum and Maximum
  id: totrans-869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The horizontal minimum and maximum instructions select the minimum or maximum
    value within a single vector, as shown in [Table 11-26](chapter11.xhtml#tab11-26).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-26: Horizontal (Across Vector) Minimum and Maximum Instructions'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
- en: '| sminv | sminv Rd, Vs.t1 | Extract minimum signed lane value from Vs and store
    into Rd. |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
- en: '| smaxv | smaxv Rd, Vs.t1 | Extract maximum signed lane value from Vs and store
    into Rd. |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
- en: '| uminv | uminv Rd, Vs.t1 | Extract minimum unsigned lane value from Vs and
    store into Rd. |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
- en: '| umaxv | umaxv Rd, Vs.t1 | Extract maximum unsigned lane value from Vs and
    store into Rd. |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
- en: '| fminv | fminv Sd, Vs.t2 | Extract minimum real lane value from Vs and store
    into Sd. |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
- en: '| fmaxv | fmaxv Sd, Vs.t2 | Extract maximum real lane value from Vs and store
    into Rd. |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
- en: '| fminnmv | fminnmv Sd, Vs.t2 | Extract minimum real lane value from Vs and
    store into Sd. |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmv | fmaxnmv Sd, Vs.t2 | Extract maximum real lane value from Vs and
    store into Rd. |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
- en: In this table, Rd/t1 is B/8B, B/16B, H/4H, H/8H, or S/4S. If t1 is 8B, or 4H,
    the instruction operates only on the lanes in the LO 64 bits of Vs. For floating-point
    minimum and maximum, only single-precision operands are legal; t2 must be 2S or
    4S (operating on the LO 64 bits or the full 128 bits of the source register).
    As for the standard fmin and fmax instructions, the nm variants differ insofar
    as they return the numeric value if one of the operands is NaN.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 Floating-Point and Integer Conversions
  id: totrans-883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions to convert between floating-point
    and integer (or fixed-point) formats. Section 6.9.4, “Floating-Point Conversion
    Instructions,” on [page 343](chapter6.xhtml#pg_343) provided examples of these
    conversion instructions when operating on scalar registers; the following subsections
    present the vector equivalents.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.1 Floating-Point to Integer
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides vector equivalents of the fcvt* instructions
    that convert floating-point values to their integer equivalents, as shown in [Table
    11-27](chapter11.xhtml#tab11-27).
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-27: Floating-Point to Integer Conversion Instructions'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
- en: '| fcvtns | fcvtns Vd.t, Vs.t | Round to nearest signed integer. Exactly one-half
    rounds to nearest even integer. |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
- en: '| fcvtas | fcvtas Vd.t, Vs.t | Round to nearest signed integer. Exactly one-half
    rounds away from zero. |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
- en: '| fcvtps | fcvtps Vd.t, Vs.t | Round toward +∞ (signed integer). |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
- en: '| fcvtms | fcvtms Vd.t, Vs.t | Round toward –∞ (signed integer). |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
- en: '| fcvtzs | fcvtzs Vd.t, Vs.t | Round toward 0 (signed integer). |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
- en: '| fcvtnu | fcvtnu Vd.t, Vs.t | Round to nearest unsigned integer. Exactly one-half
    rounds to nearest even integer. |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
- en: '| fcvtau | fcvtau Vd.t, Vs.t | Round to nearest unsigned integer. Exactly one-half
    rounds away from 0. |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
- en: '| fcvtpu | fcvtpu Vd.t, Vs.t | Round toward +∞ (unsigned integer). |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
- en: '| fcvtmu | fcvtmu Vd.t, Vs.t | Round toward –∞ (unsigned integer). |'
  id: totrans-898
  prefs: []
  type: TYPE_TB
- en: '| fcvtzu | fcvtzu Vd.t, Vs.t | Round toward 0 (unsigned integer). |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
- en: In this table, t is 2S (which uses only the LO 64 bits of the vector registers),
    4S, or 2D. The source operand is always assumed to contain floating-point values
    (single- or double-precision), and the destination lanes will receive signed or
    unsigned integer values (words or dwords). Note that when converting negative
    floating-point values to unsigned integers, the conversion saturates the conversion
    to 0.0.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'The fcvtz* instruction also has some fixed-point variants:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The imm operand specifies the number of fractional bits to maintain in the fixed-point
    value (this must be 1 to 31 for single-precision or word types and 1 to 63 for
    double-precision or dword types). Because integer operations are somewhat faster
    than floating-point calculations, sometimes it is faster to convert operands to
    fixed-point, do a chain of calculations, then convert the result back to floating-point.
    However, this book doesn’t cover fixed-point arithmetic in depth, so I won’t discuss
    this technique any further. See section 11.15, “For More Information,” on [page
    700](chapter11.xhtml#pg_700) for additional information.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.2 Integer to Floating-Point
  id: totrans-904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ucvtf and scvtf instructions convert 32- and 64-bit integers to single-
    and double-precision values, respectively. Their syntax is roughly the same as
    that of fcvt*:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As with fcvt*, t must be 2S, 4S, or 2D (2S converts only the LO 64 bits).
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: Because double-precision values have only a 56-bit mantissa and single-precision
    values have only a 24-bit mantissa, you cannot exactly represent certain 32- and
    64-bit integers as single- or double-precision floating-point values. In those
    cases, the scvtf and ucvtf instructions produce the closest approximation. However,
    keep in mind that executing *cvtf followed by an fcvt* instruction may not return
    the exact same integer.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.8.3 Conversion Between Floating-Point Formats'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set provides three instructions that will convert a small
    floating-point format to a larger form, or a larger form to a smaller form. This
    is one of the few instructions in the ARM instruction set that supports half-precision
    (16-bit) floating-point numbers. [Table 11-28](chapter11.xhtml#tab11-28) shows
    the available instructions.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-28: Floating-Point Conversion Instructions'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane conversion |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
- en: '| fcvtl | fcvtl Vd.t1, Vs.t2 | Convert from a smaller size to the next larger
    size by using the LO 64 bits of the source register. |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
- en: '| fcvtl2 | fcvtl2 Vd.t3, Vs.t4 | Convert from a smaller size to the next larger
    size by using the upper 64 bits of the source register (does not affect the LO
    bits of the destination register). |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
- en: '| fcvtn | fcvtn Vd.t5, Vs.t6 | Convert from a larger size to a smaller size
    by using the LO 64 bits of the destination register. |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
- en: '| fcvtn2 | fcvtn2 Vd.t7, Vs.t8 | Convert from a larger size to a smaller size
    by using the HO 64 bits of the destination register (does not affect the LO bits
    of the destination register). |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
- en: '| fcvtxn | fcvtxn Vd.2S, Vs.2D | Like fcvtn, except rounding is different (see
    text). |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
- en: '| fcvtxn2 | fcvtxn2 Vd.4S, Vs.2D | Like fcvtn2, except rounding is different
    (see text). |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
- en: The legal types and lane counts for the instructions in [Table 11-28](chapter11.xhtml#tab11-28)
    appear in [Table 11-29](chapter11.xhtml#tab11-29), where H = 16-bit half-precision
    floating-point, S = 32-bit single-precision floating-point, and D = 64-bit double-precision
    floating-point.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-29: Legal Types and Lane Counts for Floating-Point Conversions'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types and lane counts |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4S/4H or 2D/2S |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 4S/8H or 2D/4S |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
- en: '| t5/t6 | 4H/4S or 2S/2D |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
- en: '| t7/t8 | 8H/4S or 4S/2D |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
- en: Conversion from a smaller size to a larger size always produces an exact result.
    Conversion from a larger size down to a smaller size may require rounding the
    result to fit in the smaller size (worst case, overflow or underflow will occur
    if the larger value cannot be represented at all in the smaller floating-point
    format).
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: 'When rounding larger values to fit into a smaller format, the fcvtn and fcvtn2
    instructions use the standard IEEE-754 round-to-nearest-even algorithm. In some
    cases, this may not produce the best result. For example, it is generally better
    to round to the nearest odd when converting a half-precision value to a double-precision
    value (which requires two steps: convert half-precision to single-precision, then
    convert single-precision to double-precision). The fcvtxn and fcvtxn2 instructions
    employ this non-IEEE rounding scheme to produce better results.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.4 Floating-Point Values Rounded to the Nearest Integral
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Certain algorithms require rounding a floating-point value to an integer but
    require the result to be maintained in the floating-point format. The frint* instructions
    listed in [Table 11-30](chapter11.xhtml#tab11-30) provide this capability.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-30: Rounding a Floating-Point Value to an Integral Value'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane rounding operation |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
- en: '| frintn | frintn Vd.t, Vs.t | Round to nearest integer. Exactly one-half rounds
    to nearest even integer. |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
- en: '| frinta | frinta Vd.t, Vs.t | Round to nearest integer. Exactly one-half rounds
    away from 0. |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
- en: '| frintp | frintp Vd.t, Vs.t | Round toward +∞. |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
- en: '| frintm | frintm Vd.t, Vs.t | Round toward –∞. |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
- en: '| frintz | frintz Vd.t, Vs.t | Round toward 0. |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
- en: '| frinti | frinti Vd.t, Vs.t | Round using FPCR rounding mode. |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
- en: '| frintx | frintx Vd.t, Vs.t | Round using FPCR rounding mode with exactness
    test. |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
- en: In this table, t must be 2S, 4S, or 2D. If it is 2S, these instructions use
    only the LO 64 bits of the registers.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: The frintx instruction generates a floating-point inexact result exception if
    the rounded result is not equal to the original source value. You won’t normally
    use this instruction unless you have an appropriate exception handler in place.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 Vector Square-Root Instructions
  id: totrans-944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set provides two instructions for computing the square
    root of a floating-point value and computing (and refining) an estimate of the
    reciprocal of the square root of a floating-point value. [Table 11-31](chapter11.xhtml#tab11-31)
    lists these instructions.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-31: Vector Square Root Instructions'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane operation |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
- en: '| fsqrt | fsqrt Vd.t, Vs.t | Compute square root of source and store into destination
    |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
- en: '| frsqrte | frsqrte Vd.t, Vs.t | First step of Newton-Raphson approximation
    of the reciprocal of the square root |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
- en: '| frsqrts | frsqrts Vd.t, Vs1.t, Vs2.t | Additional steps of the Newton-Raphson
    approximation |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
- en: In the table, t must be 2S, 4S, or 2D. If it’s 2S, these instructions operate
    on the lanes in the LO 64 bits of the vector registers.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: These three instructions also have scalar versions
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: where Rd and Rs are one of the floating-point scalar registers Sn or Dn.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Note that the frsqrts instruction multiplies corresponding floating-point values
    in the lanes of the two source registers, subtracts each of the products from
    3.0, divides these results by 2.0, and places the results into the destination
    register.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 11.10 Vector Comparisons
  id: totrans-957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vector comparisons are fundamentally different from normal (general-purpose
    register) comparisons. When comparing general-purpose registers (or even individual
    floating-point scalar values), the ARM CPU sets the condition codes based on the
    result of the comparison; the code following the comparison then tests those condition
    codes, using a conditional branch, for example. This scheme doesn’t work when
    comparing vector elements because the CPU always performs multiple comparisons
    in parallel. There’s only one set of condition codes, so the CPU cannot put the
    results of multiple comparisons into the condition codes, meaning vector comparisons
    require a different mechanism to make the comparison results available to the
    program.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a generic comparison that produces less than, greater than, or equal
    results simultaneously (in the condition codes), a vector comparison asks for
    a specific comparison, such as, “Are the elements of this vector greater than
    the elements of another vector?” The result is true or false for each lane-by-lane
    comparison. A vector comparison will store the true or false result into the corresponding
    lanes of a destination vector. Vector comparisons use all 0 bits in a lane to
    represent false and all 1 bits in a lane to represent true.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: 'Neon has two general sets of vector comparison instructions: one for integer
    comparisons and another for floating-point comparisons. The following subsections
    discuss each of these forms.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.10.1 Vector Integer Comparisons'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-32](chapter11.xhtml#tab11-32) lists the generic vector integer compare
    instructions, where t is 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For the 8B, 4H, and 2S
    types, these instructions operate only on the LO 64 bits of the registers and
    clear the HO 64 bits of the destination register.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-32: Vector Integer Comparison Instructions'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Vd.t, Vl.t, Vr.t | Signed or unsigned comparison for equality
    |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
- en: '| cmhs | cmhs Vd.t, Vl.t, Vr.t | Unsigned comparison for greater than or equal
    (Vd = Vl ≥ Vr) |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
- en: '| cmhi | cmhi Vd.t, Vl.t, Vr.t | Unsigned comparison for greater than (Vd =
    Vl > Vr) |'
  id: totrans-968
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Vd.t, Vl.t, Vr.t | Signed comparison for greater than or equal
    (Vd = Vl ≥ Vr) |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Vd.t, Vl.t, Vr.t | Signed comparison for greater than (Vd = Vl
    > Vr) |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
- en: There is no cmne instruction. You can invert all the bits in the destination
    register (using the not instruction) if you need this comparison, or you can use
    0 bits to imply true and 1 bits to imply false. Likewise, there are no cmls, cmlo,
    cmle, or cmlt instructions; you can derive these from cmgt, cmge, cmhs, or cmhi
    by reversing the operands.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: These instructions have scalar variants, as shown in [Table 11-33](chapter11.xhtml#tab11-33),
    where Rd, Rl, and Rr must be Dn.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-33: Scalar Integer Comparison Instructions'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Rd, Rl, Rr | Signed or unsigned comparison for equality |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
- en: '| cmhs | cmhs Rd, Rl, Rr | Unsigned comparison for greater than or equal (Rd
    = Rl ≥ Rr) |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
- en: '| cmhi | cmhi Rd, Rl, Rr | Unsigned comparison for greater than (Rd = Rl >
    Rr) |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Rd, Rl, Rr | Signed comparison for greater than or equal (Rd
    = Rl ≥ Rr) |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Rd, Rl, Rr | Signed comparison for greater than (Rd = Rl > Rr)
    |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
- en: A special set of vector comparison instructions exists to compare the lanes
    of a single vector against 0\. This saves setting up a register to contain all
    0s for this common case. The available instructions perform only signed comparisons
    (it doesn’t make much sense to compare unsigned values against 0). [Table 11-34](chapter11.xhtml#tab11-34)
    lists these instructions.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-34: Signed Vector Comparisons Against 0'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison against 0 |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Vd.t, Vl.t, #0 | Signed comparison for lanes equal to 0 |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Vd.t, Vl.t, #0 | Signed comparison for lanes greater than or
    equal to 0 |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Vd.t, Vl.t, #0 | Signed comparison for lanes greater than 0 |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
- en: '| cmle | cmle Vd.t, Vl.t, #0 | Signed comparison for lanes less than or equal
    to 0 |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
- en: '| cmlt | cmlt Vd.t, Vl.t, #0 | Signed comparison for lanes less than 0 |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
- en: The type t must be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For the 8B, 4H, and 2S types,
    these instructions operate only on the LO 64 bits of the registers and clear the
    HO 64 bits of the destination register. The only legal immediate constant is 0
    with these instructions.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-35](chapter11.xhtml#tab11-35) lists the scalar versions of these
    instructions.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-35: Scalar Vector Comparisons Against 0'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison against 0 |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Rd, Rl, #0 | Signed comparison for register equal to 0 |'
  id: totrans-995
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Rd, Rl, #0 | Signed comparison for register greater than or equal
    to 0 |'
  id: totrans-996
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Rd, Rl, #0 | Signed comparison for register greater than 0 |'
  id: totrans-997
  prefs: []
  type: TYPE_TB
- en: '| cmle | cmle Rd, Rl, #0 | Signed comparison for register less than or equal
    to 0 |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
- en: '| cmlt | cmlt Rd, Rl, #0 | Signed comparison for register less than 0 |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
- en: In this table, Rd, Rl, and Rr must be Dn.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.2 Vector Floating-Point Comparisons
  id: totrans-1001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also compare floating-point values in the vector registers’ lanes. [Table
    11-36](chapter11.xhtml#tab11-36) lists the various fcm* instructions available
    for this purpose, where t is 2S, 4S, or 2D. If t is 2S, these instructions use
    only the LO 64 bits of the registers.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-36: Vector Floating-Point Comparison Instructions'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Vd.t, Vl.t, Vr.t | Floating-point comparison for equality |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = Vl ≥ Vr)
    |'
  id: totrans-1007
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = Vl > Vr)
    |'
  id: totrans-1008
  prefs: []
  type: TYPE_TB
- en: '[Table 11-37](chapter11.xhtml#tab11-37) lists variants of the fcm* instructions
    that compare the lanes in a vector register against 0.0, where t is 2S, 4S, or
    2D. If t is 2S, these instructions use only the LO 64 bits of the registers.'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-37: Vector Floating-Point Comparison Against 0.0'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison against 0.0 |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Vd.t, Vl.t, #0 | Floating-point comparison for register equal
    to 0.0 |'
  id: totrans-1013
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Vd.t, Vl.t, #0 | Floating-point comparison for register greater
    than or equal to 0.0 |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Vd.t, Vl.t, #0 | Floating-point comparison for register greater
    than 0.0 |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
- en: '| fcmle | fcmle Vd.t, Vl.t, #0 | Floating-point comparison for register less
    than or equal to 0.0 |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
- en: '| fcmlt | fcmlt Vd.t, Vl.t, #0 | Floating-point comparison for register less
    than 0.0 |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
- en: 'Note that the immediate constant is 0 (versus 0.0), even though this is a floating-point
    comparison. The only legal operand for this instruction is #0.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: As for the integer comparisons, the fcm* instructions provide a set of scalar
    instructions that also store true (all 1 bits) or false (all 0 bits) into the
    destination register (in contrast to the fcmp instructions that set the condition
    code flags). [Table 11-38](chapter11.xhtml#tab11-38) lists the scalar versions
    of these instructions, where Rd, Rl, and Rr must be Sn or Dn*.*
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-38: Scalar Variants of the Vector Floating-Point Comparisons'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison (including against
    0.0) |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Rd, Rl, Rr | Floating-point comparison for equality |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Rd, Rl, Rr | Floating-point comparison (Rd = Rl ≥ Rr) |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Rd, Rl, Rr | Floating-point comparison (Rd = Rl > Rr) |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Rd, Rl, #0 | Floating-point comparison for register equal to
    0.0 |'
  id: totrans-1026
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Rd, Rl, #0 | Floating-point comparison for register greater
    than or equal to 0.0 |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Rd, Rl, #0 | Floating-point comparison for register greater
    than 0.0 |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
- en: '| fcmle | fcmle Rd, Rl, #0 | Floating-point comparison for register less than
    or equal to 0.0 |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
- en: '| fcmlt | fcmlt Rd, Rl, #0 | Floating-point comparison for register less than
    0.0 |'
  id: totrans-1030
  prefs: []
  type: TYPE_TB
- en: 'Neon has a couple of additional floating-point comparisons: fac* (vector floating-point
    absolute value compare). These instructions compare the absolute values of corresponding
    lanes in the source vector register and set the destination register accordingly.
    [Table 11-39](chapter11.xhtml#tab11-39) lists these instructions.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-39: Floating-Point Absolute-Value Comparisons'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
- en: '| facge | facge Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = abs(Vl)
    ≥ abs(Vr)) |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
- en: '| facgt | facgt Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = abs(Vl)
    > abs(Vr)) |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
- en: There is no faceq instruction, since there’s no need for one; just use fcmeq.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: The fac* instructions also have scalar versions, listed in [Table 11-40](chapter11.xhtml#tab11-40).
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-40: Scalar Floating-Point Absolute-Value Comparisons'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
- en: '| facge | facge Rd, Rl, Rr | Floating-point comparison (Rd = abs(Rl) ≥ abs(Rr))
    |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
- en: '| facgt | facgt Rd, Rl, Rr | Floating-point comparison (Rd = abs(Rl) > abs(Rr))
    |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
- en: Note that Rd, Rl, and Rr must be Sn or Dn.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.3 Vector Bit Test Instructions
  id: totrans-1045
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides a vector version of the tst instruction, cmtst,
    which has the following syntax
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. If t is 8B, 4H, or 2S, this instruction
    operates only on the LO 64 bits of the source registers and clears the HO 64 bits
    of the destination register.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: This instruction does a lane-by-lane logical AND operation between Vl and Vr.
    If the result is nonzero, it stores all 1 bits into the corresponding destination
    lane. Otherwise, it stores all 0s into the destination lane.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction also has a scalar version:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This form supports only 64-bit register operands (D*n*).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.4 Vector Comparison Results
  id: totrans-1053
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Throughout your programming experience, including with HLLs, you’ve probably
    become accustomed to using the result of comparisons (such as Boolean expressions)
    to divert control flow (such as with an if/then/else statement). Vector comparisons
    present a completely different paradigm because the lanes in a comparison could
    all produce different results. What’s the best way to deal with this?
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider the easy stuff: complex Boolean expressions involving ANDs,
    ORs, and other logical operators. Because the vector comparisons compute convenient
    results (all 1s or all 0s), it’s easy to compute something like this:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Consider the following code:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This leaves the result of the previous Boolean calculation (0x0000 or 0xFFFF)
    in the LO 64 bits of the V0 register (lanes 0 to 3; remember that the and instruction
    allows only 8B and 16B types, but they produce the same result as 4H would if
    it were a legal type).
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: You can use similar instruction sequences for OR, NOT, and any of the other
    logical vector operations (see [Table 11-2](chapter11.xhtml#tab11-2)). Such calculations
    will use complete Boolean evaluation.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Short-circuit evaluation doesn’t make sense for vector operations; see section
    7.6.3, “Complex* if *Statements Using Complete Boolean Evaluation,” on [page 378](chapter7.xhtml#pg_378)
    for more information on complete Boolean evaluation.*'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: If you absolutely, positively must branch to some locations based on the result
    of all the vector comparisons, keep in mind that the number of branch locations
    increases exponentially with the number of lanes (specifically, its 2*^n* different
    possibilities, where *n* is the number of lanes). For example, if you execute
    the following instruction
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: then the LO 64 bits of V0 will contain four Boolean values, yielding 16 combinations
    of the four comparisons. It’s ugly, but you could create a jump table (see section
    7.6.7.3, “Indirect Jump switch Implementation,” on [page 391](chapter7.xhtml#pg_391))
    with 16 entries and then transfer control by using code like the following
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: where mask is
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: and JmpTbl is a 16-entry .dword table with the offset to the labels to jump
    to, based on all the combinations of true and false for four lane comparisons.
    This code moves bit 0 of lane 0 into bit 0 of X0, bit 0 of lane 1 into bit 1 of
    X0, bit 0 of lane 2 into bit 2 of X0, and bit 0 of lane 3 into bit 3 of X0\. This
    forms a 4-bit index (16 possible values) into JmpTbl.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, you could create a jump table with 16 entries and write code
    to transfer control, but this would be so ugly it’s not an option worth seriously
    considering.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you don’t need to know the particular configuration of matches in
    a vector comparison, only whether any matches exist at all. For example, suppose
    you were looking for a 0 byte in a string of characters (such as when computing
    the length of a zero-terminating string). You could load 16 characters at a time
    from the string and search for a 0 byte by comparing all of them against 0:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This instruction sets the particular lane in V0 to 0xFF, corresponding to any
    lane in V1 that contains a 0 byte. You can use the following sequence to check
    whether there were any 0 bytes at all:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the SIMD paradigm, an ideal solution would be to do calculations in parallel
    and use masks to disable certain calculations. For example, suppose you have a
    vector of 32-bit integers to which you would like to add another vector’s lanes,
    with the caveat that you don’t want to add anything if a particular lane contains
    a value greater than 16 bits (0xFFFF). Consider the following code:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The and instruction sets dword lanes greater than 0xFFFF to 0 so that they will
    have no impact on the final lane sums.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.11 A Sorting Example Using SIMD Code'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: Sorting data is a common vector solution. Listing 11-1 demonstrates a simple
    sort of eight elements by using a vectorized bitonic sorting algorithm.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here’s the build command and the sample output for Listing 11-1:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As you can see, this code properly sorted the data.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 11.12 A Numeric-to-Hex-String Example Using SIMD Code
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Listing 11-2 is a Neon example of something you should be familiar with: [Chapter
    9](chapter9.xhtml)’s dtoStr function that converts a dword into a hexadecimal
    string. It’s a practical example of converting existing code to SIMD.'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here’s the build command and the sample output for Listing 11-2:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you were to time this code, you’d find that it runs significantly faster
    than the scalar code in [Chapter 9](chapter9.xhtml).
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 11.13 Use of SIMD Instructions in Real Programs
  id: totrans-1090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve read through this chapter but aren’t sure how to apply SIMD instructions
    in real programs, don’t feel like you’re missing something. *SIMD* might as well
    stand for “*S*IMD *I*nstruction sets are *M*assively *D*ifficult to use.” Although
    ARM’s Neon instruction set is a bit more general-purpose than, say, Intel’s SSE/AVX
    extensions, SIMD instructions were created to accelerate the execution of very
    specific algorithms. I like to paraphrase a line from this book’s technical reviewer,
    Tony Tribelli, with respect to SIMD instructions’ applicability: “I look at a
    particular SIMD instruction and ask myself, ‘What benchmark was this instruction
    created for?’ ” That is, it often seems like SIMD instructions were added to the
    instruction set to make one benchmark program run faster and make the ARM CPU
    look better, though the instruction probably isn’t useful outside the context
    of that benchmark.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'In many respects, this statement is dead on: many SIMD instructions were created
    to solve one particular problem, and their applicability beyond that solution
    is merely coincidental. If you can’t figure out how to use a given instruction,
    you probably haven’t yet discovered the problem it was originally created to address.'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: If nothing else, the vector registers’ lanes are a good place to store temporary
    values when you’re already using all the general-purpose registers. You can use
    the mov instruction to copy data between a general-purpose register and a lane
    in a vector register; this is much faster than spilling the register to memory.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to use the Neon instruction set for high-performance computing,
    see section 11.15, “For More Information,” on the next page, or search “SIMD parallel
    algorithms” or “SIMD vector algorithms” on the internet.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.14 Moving On'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: This lengthy chapter covered many instructions. It began with a brief history
    of SIMD instruction sets; covered the vector registers on the ARM; discussed SIMD
    data types, lanes, and scalar operations; and then presented the Neon instruction
    set. This chapter ended with a pair of short examples that demonstrated bitonic
    sorting and numeric-to-hexadecimal-string conversion using the vector registers.
    These constitute useful ways to use the SIMD instructions on the ARM. Although
    SIMD instructions aren’t often applicable in general programs, with a little thought
    you should be able to use them to speed up your code in certain situations.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: A couple of the remaining chapters will employ SIMD instructions to improve
    performance. [Chapter 12](chapter12.xhtml) uses Neon instructions to improve the
    performance of various bit operations, while [Chapter 14](chapter14.xhtml) uses
    Neon instructions to implement fast memory move operations. You can apply what
    you’ve learned in this chapter to algorithms you’ve learned in previous chapters
    that could benefit from using SIMD instructions, such as the numeric-to-hex-string
    code. I’ll leave it to you to implement these changes.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: 11.15 For More Information
  id: totrans-1098
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on fixed-point arithmetic and other Neon instructions and
    data types, consult the ARM Architecture Reference Manual at *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/ddi0487<wbr>/latest](https://developer.arm.com/documentation/ddi0487/latest)*.
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on ARM scalable vector extensions (SVEs), see the documentation at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/102476<wbr>/0001<wbr>/SVE<wbr>-architecture<wbr>-fundamentals](https://developer.arm.com/documentation/102476/0001/SVE-architecture-fundamentals)*.
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM offers a guide on implementing fixed-point arithmetic on 32-bit CPUs at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/dai0033<wbr>/a](https://developer.arm.com/documentation/dai0033/a)*.
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those interested in vector sorting with ARM SVE can reference “A Fast Vectorized
    Sorting Implementation Based on the ARM Scalable Vector Extension (SVE)” by Bérenger
    Bramas for one implementation: *[https://<wbr>arxiv<wbr>.org<wbr>/pdf<wbr>/2105<wbr>.07782<wbr>.pdf](https://arxiv.org/pdf/2105.07782.pdf)*.'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the Vector Sorting Algorithms page of the CMSIS DSP Software Library for
    more on vector sorting with ARM: *[https://<wbr>arm<wbr>-software<wbr>.github<wbr>.io<wbr>/CMSIS<wbr>_5<wbr>/DSP<wbr>/html<wbr>/group<wbr>_<wbr>_Sorting<wbr>.html](https://arm-software.github.io/CMSIS_5/DSP/html/group__Sorting.html)*.'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM documentation also provides more detail on vector sorting on Neon at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/den0018<wbr>/a<wbr>/NEON<wbr>-Code<wbr>-Examples<wbr>-with<wbr>-Optimization<wbr>/Median<wbr>-filter<wbr>/Basic<wbr>-principles<wbr>-and<wbr>-bitonic<wbr>-sorting](https://developer.arm.com/documentation/den0018/a/NEON-Code-Examples-with-Optimization/Median-filter/Basic-principles-and-bitonic-sorting)*.
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast and Robust Vectorized In-Place Sorting of Primitive Types” by Mark Blacher,
    Joachim Giesen, and Lars Kühne at *[https://<wbr>drops<wbr>.dagstuhl<wbr>.de<wbr>/opus<wbr>/volltexte<wbr>/2021<wbr>/13775<wbr>/pdf<wbr>/LIPIcs<wbr>-SEA<wbr>-2021<wbr>-3<wbr>.pdf](https://drops.dagstuhl.de/opus/volltexte/2021/13775/pdf/LIPIcs-SEA-2021-3.pdf)*
    covers quick sorting with vector instructions (written for AVX2, but easily translatable
    to Neon) using the bitonic sorting algorithm.
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the master’s thesis “A Study of the Use of SIMD Instructions for Two Image
    Processing Algorithms” by Eric Welch at *[https://<wbr>scholarworks<wbr>.rit<wbr>.edu<wbr>/cgi<wbr>/viewcontent<wbr>.cgi<wbr>?article<wbr>=3686&context<wbr>=theses](https://scholarworks.rit.edu/cgi/viewcontent.cgi?article=3686&context=theses)*
    for a discussion of SIMD image processing algorithms.
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another master’s thesis on SIMD signal processing algorithms is “Performance
    Optimization of Signal Processing Algorithms for SIMD Architectures” by Sharan
    Yagneswar, which can be found at *[https://<wbr>www<wbr>.diva<wbr>-portal<wbr>.org<wbr>/smash<wbr>/get<wbr>/diva2:1138490<wbr>/FULLTEXT01<wbr>.pdf](https://www.diva-portal.org/smash/get/diva2:1138490/FULLTEXT01.pdf)*.
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
