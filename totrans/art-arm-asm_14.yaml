- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 11 NEON AND SIMD PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the vector instructions on the ARM. This special class
    of instructions provides parallel processing, traditionally known as *single-instruction,
    multiple-data (SIMD)* instructions because, quite literally, a single instruction
    operates on several pieces of data concurrently. As a result of this concurrency,
    SIMD instructions can often execute several times faster (in theory, as much as
    32 to 64 times faster) than the comparable *single-instruction, single-data (SISD)*
    instructions that compose the standard ARM instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: Vector instructions, also known as the *Neon instruction set* or *ARM Advanced
    SIMD*, provide an extension to the standard scalar instructions. While a *scalar
    instruction* operates on a single piece of data at a time, the Neon instructions
    simultaneously operate on a *vector* (a fancy name for an array) of data objects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a brief history of SIMD instructions, then discusses the
    ARM Neon architecture (including the vector registers) and Neon data types. The
    majority of this chapter then covers the Neon instruction set. A complete treatise
    on SIMD programming is beyond the scope of this book; however, it wouldn’t do
    to write this chapter without at least a few SIMD programming examples in order
    to demonstrate the benefits of SIMD programming, so this chapter concludes with
    examples that show a bitonic sort and a numeric-to-hex-string conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 The History of SIMD Instruction Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set extensions were added to the ARM instruction set long
    after the ARM was created. Arm created Neon to counter competition from the Intel
    x86 CPU family. To understand why the Neon instruction set is so radically different
    from the standard instruction set, you have to understand the history of SIMD
    (vector) instruction sets.
  prefs: []
  type: TYPE_NORMAL
- en: The first vector computers were supercomputers such as the CDC Star-100, Texas
    Instruments Advanced Scientific Computer (ASC), and Cray computers, which could
    operate on a vector of data with a single instruction. These vector computers
    were the precursor to the early SIMD computers such as the Thinking Machines CM-1
    and CM-2\. Ultimately, supercomputers moved away from the SIMD approach when Intel
    introduced SIMD features on its low-cost i860 (and, later, Pentium processors).
  prefs: []
  type: TYPE_NORMAL
- en: The Intel Multimedia Extensions (MMX) instruction set was the first widely adopted
    desktop SIMD architecture. Intel added parallel integer arithmetic instructions
    to the venerable x86 instruction set to accelerate digital audio processing and
    other digital signal processing applications. The PowerPC followed this with the
    much more capable AltiVec architecture (which included support for single-precision
    floating-point values). Intel then produced the SSE2 and SSE3, AVX, AVX2, and
    AVX-512 SIMD instruction architectures (which now include full double-precision
    floating-point support).
  prefs: []
  type: TYPE_NORMAL
- en: Intel’s approach to adding vector instructions to its x86 series CPUs was a
    bit hackneyed. Given the limited transistor budgets on CPUs in the middle 1990s,
    Intel added a few vector instructions (MMX) in its early Pentium processors and
    then extended the SIMD instruction set as its CPUs became larger and had more
    transistors available to implement advanced features. This evolution produced
    a bit of a kludge, with new sets of instructions replicating and obsoleting older
    instructions (with the newer instruction set’s ability to handle more data or
    handle data differently).
  prefs: []
  type: TYPE_NORMAL
- en: By the time ARM added SIMD instructions via its *Neon Advanced SIMD* instructions,
    Intel had gone through multiple generations of SIMD instructions; Arm was able
    to cherry-pick the more interesting and useful instructions from Intel’s set,
    leaving behind all the kruft and legacy instructions. For this reason, the Neon
    instruction set is considerably more compact and much easier to understand than
    Intel’s MMX/SSE/AVX instruction sets.
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.2 Vector Registers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM provides 32 main FP/Neon registers that are 128 bits each, broken into
    five groups based on their size:'
  prefs: []
  type: TYPE_NORMAL
- en: V0 to V31, the 128-bit vector registers (for Neon instructions), also referenced
    as Q0 to Q31, the qword registers; the V*n* names support special syntax for vector
    operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D0 to D31, the 64-bit double-precision floating-point registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S0 to S31, the 32-bit single-precision floating-point registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H0 to H31, the 16-bit half-precision floating-point registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B0 to B31, the 8-bit byte registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 11-1](chapter11.xhtml#fig11-1) shows the vector register layout.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The FP/Neon registers'
  prefs: []
  type: TYPE_NORMAL
- en: The B*n*, H*n*, S*n*, D*n*, and V*n* registers overlay one another, as shown
    in [Figure 11-2](chapter11.xhtml#fig11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Byte, half-word, single, double, and vector register overlays'
  prefs: []
  type: TYPE_NORMAL
- en: See [Chapter 6](chapter6.xhtml) for more information about the scalar floating-point
    D*n*, S*n*, and H*n* registers. Keep in mind, however, that if you mix vector
    and floating-point operations in your code, the instructions share the same register
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 11-1](chapter11.xhtml#fig11-1) and [11-2](chapter11.xhtml#fig11-2)
    give the impression that the V*n* registers are 128-bit registers (which, presumably,
    you can manipulate as a single 128-bit value). In fact, the V*n* registers are
    vectors containing sixteen 8-bit, eight 16-bit, four 32-bit, two 64-bit, or (single)
    128-bit values, as [Figure 11-3](chapter11.xhtml#fig11-3) shows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Vector register overlays'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an instruction operates on a particular element of a vector register,
    you reference that element by using one of the following register names (in all
    cases, *n* represents a vector register number in the range 0 to 31):'
  prefs: []
  type: TYPE_NORMAL
- en: V*n* or Q*n* when referencing the whole 128-bit register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.B when treating the whole register as an array of 16 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.H when treating the whole register as an array of eight half words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.S when treating the whole register as an array of four words (single-precision
    values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.D when treating the whole register as an array of two dwords (double-precision
    values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.2D[0] or V*n*.2D[1] when referencing 64-bit double-precision in bit positions
    0 to 63 or 64 to 127, respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.4S[0], V*n*.4S[1], V*n*.4S[2], V*n*.4S[3] when accessing a 32-bit single-precision
    value in bit positions 0 to 31, 32 to 63, 64 to 95, or 96 to 127, respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.8H[0], V*n*.8H[1], ..., V*n*.8H[7] when accessing a 16-bit half-word value
    in bit positions 0 to 15, 16 to 31, ..., 112 to 127, respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V*n*.16B[0], V*n*.16B[1], ..., V*n*.16B[15] when accessing an 8-bit byte in
    bit positions 0 to 7, 8 to 16, ..., 120 to 127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact name to choose will depend on the instruction and situation. You’ll
    see examples of these registers in use in the next section, “Vector Data Movement
    Instructions,” particularly section 11.3.4, “Vector Load and Store,” on [page
    632](chapter11.xhtml#pg_632).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 11-2](chapter11.xhtml#fig11-2) and [11-3](chapter11.xhtml#fig11-3)
    showed the five basic types associated with the data in a vector register: bytes,
    half words, single-precision values, double-precision values, and 128-bit qwords.
    In fact, the 32-bit (single) and 64-bit (double) fields support both floating-point
    (single and double) and integer (word and dword) types, bringing the total number
    of types to seven.'
  prefs: []
  type: TYPE_NORMAL
- en: Except for the special 128-bit case, the vector registers contain arrays of
    bytes, half words, words, and qwords. For reasons you’ll learn when this chapter
    discusses vector operations, each element of the array is known as a *lane*. When
    performing operations using two vector registers, the CPU generally computes results
    by using the operands in corresponding lanes in the two source registers and stores
    the result in the corresponding lane in a destination register. For example, suppose
    that V1 contains 2.0 in the HO 64 bits (lane 1) and 1.0 in the LO 64 bits (lane
    0), and that V2 contains 20.0 in lane 1 and 10.0 in lane 0\. Summing these two
    vector registers and storing the result in V3 produces 22.0 in lane 1 and 11.0
    in lane 0.
  prefs: []
  type: TYPE_NORMAL
- en: Although the vector registers generally contain arrays of data (when performing
    SIMD operations), don’t forget that the floating-point registers (D*n* and S*n*)
    overlay the vector registers as well. When doing normal floating-point operations
    (see [Chapter 6](chapter6.xhtml)), these registers contain a single value rather
    than an array of values. These single values are known as *scalars*.
  prefs: []
  type: TYPE_NORMAL
- en: Very few operations treat an entire 128-bit Neon register as a scalar value.
    Those that do (mainly load and store instructions) use the name Q*n* to denote
    a scalar value rather than V*n* (a vector value).
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Vector Data Movement Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Move instructions are the most common integer and floating-point instructions
    you’ll use in the Neon instruction set. In this section, you’ll learn how to use
    these instructions to move data between registers, load constants into Neon registers,
    and load and store vector registers to and from memory.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1 Data Movement Between Registers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the mov instruction to move data between vector registers. Unfortunately,
    the obvious syntax won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The mov instruction copies elements of a vector into a vector register. It can
    copy data between two vector registers or data between a general-purpose (X*n*
    or W*n*) register and a vector register. The exact syntax depends on how much
    data you’re copying and the location of the source and destination registers (vector
    or general-purpose).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving data from a 32-bit general-purpose register (W*m*) into a vector register
    (V*n*) uses one of the following syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The index i must be a literal integer constant, as demonstrated in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving data from a 64-bit general-purpose register (X*m*) into a vector register
    (V*n*) uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I’ve used the word *inserts* in these examples because the mov instruction copies
    only the byte, hword, word, or dword into the vector register at the index that
    *i* specifies. It does not affect the other data in V*n*. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: inserts only the LO byte from W0 into lane 4 in the V0 register; it leaves all
    other bytes in V0 unchanged. Moving bytes, hwords, and words is possible only
    when using the W*m* register; if you use X*m* in the instruction, you can move
    only 64 bits. The type specification for the vector register is S (single-precision)
    for 32 bits and D (double-precision) for 64 bits. You use this designation even
    when copying 32-bit and 64-bit integers.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The ARM instruction* ins *(insert) is a synonym for* mov *when copying data
    from a general-purpose register to a vector register—yet another reason for saying
    these instructions* insert *data rather than saying they* copy *data.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous examples copy the value from a 32- or 64-bit general-purpose register
    into a vector register. You can also copy data from one vector register (V*n*)
    to another (V*m*) by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These instructions copy 64 bits (8 bytes, four half words, two words, or a
    single dword) or 128 bits (16 bytes, eight half words, four words / single-precision
    values, or two dwords / double-precision values) from one vector register to another.
    In theory, you should be able to enter something like mov v1, v0 or mov q1, q0
    to move the contents of the 128-bit vector register V0 (Q0) into V1 (Q1). Sadly,
    Gas does not accept this syntax, so you’ll have to use one of the previous four
    instructions, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also extract a single byte from one vector register and insert it in
    an arbitrary lane in another vector register, using the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: where i2 is the index of a byte in the source vector and i1 is the destination
    index. Both indices must be in the range 0 to 15.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also extract a half word from one vector and insert that into another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The rules are the same for bytes, except that the two index values must be in
    the range 0 to 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy words (single-precision values) and dwords (double-precision values)
    by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example that copies the LO dwords of V0 and V1 merges them into the
    two dwords in V2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus far, I’ve described how to move data from a general-purpose register to
    a vector register and between two vector registers. The only missing combination
    is moving data from a vector register to a general-purpose register, handled by
    the following mov, umov, and smov instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no 8- or 16-bit zero extensions to 64 bits. Zero-extending into W*n*
    automatically zero-extends all the way through the upper 32 bits of X*n*. Here
    are some examples of these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember that smov x1, v0.s[3] is moving an integer value, even though the specified
    type is S (single-precision).
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.2 Vector Load Immediate Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM CPU provides a limited set of instructions that allow you to load certain
    immediate constants into a vector register. The integer versions of these instructions
    allow only an unsigned 8-bit immediate operand that can be used as is or shifted
    to the left 1, 2, or 3 bytes (filling vacated positions with 0s or 1s). Furthermore,
    these immediate instructions copy the data into every lane of a byte array, half-word
    array, or word array. The floating-point versions of these instructions allow
    a limited set of floating-point constants (the same limitations as for scalar
    floating-point constants; see section 6.9.1.4, “fmov with Immediate Operand,”
    on [page 334](chapter6.xhtml#pg_334)).
  prefs: []
  type: TYPE_NORMAL
- en: The standard *move immediate* instruction is movi
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'where size is 16B, 8B, 4H, 8H, 2S, or 4S; uimm8 is an 8-bit constant; and uimm64
    is either 0 or 0xFFFFffffFFFFffff. The lsl #c component is optional for instructions
    with 4H, 8H, 2S, and 4S sizes. The msl #c option is optional for 2S and 4S sizes.
    The movi instructions initialize all lanes in the vector register, or just the
    lanes in the LO 64 bits, with the specified immediate constant. The following
    paragraphs describe the specific variants of each of these instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.8B, #uimm8 instruction fills each of the LO 8 bytes of V*n* with
    the specified constant and the HO 64 bits of the register with 0s. For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: loads 0x80808080 into V0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.16B, #uimm8 instruction fills all 16 bytes of V*n* with the specified
    constant. Each lane receives a copy of the uimm8 value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.4H, #uimm8 instruction fills the four hword lanes in the LO 64
    bits of V*n* with a copy of the uimm8 constant, and fills the HO 64 bits of V*n*
    with 0\. Because this instruction accepts only 8-bit immediate constants, the
    HO 8 bits of each half-word lane will contain 0s. For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: loads 0x0001000100010001 into V1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.4H, #uimm8, lsl #0 instruction is identical to movi Vn.4H, #uimm8*.*
    If the shift constant is #8, this instruction shifts the immediate constant to
    the left eight positions before storing it into the four half-word lanes (in the
    LO 64 bits of V*n*). In this case, the LO 8 bits of each of these lanes will contain
    0s. For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: loads 0x0100010001000100 into V1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.8H, #uimm8 and movi Vn.8H, #uimm8, lsl #c instructions do the same
    thing as the 4H instructions, except that they store the immediate constant (shifted
    by 0 or 8 bits) into all eight lanes of the V*n* register.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.2S, #uimm8 instruction fills the two word (single-precision) lanes
    in the LO 64 bits of V*n* with a copy of the uimm8 constant, and fills the HO
    64 bits of V*n* with 0\. Because this instruction accepts only 8-bit immediate
    constants, the HO 24 bits of each word lane will contain 0s. Although the type
    specification is S, this instruction assigns integer constants, not floating-point
    constants, to the lanes. If the optional shift clause is present (movi Vn.2S,
    #uimm8, lsl #c, where c is 0, 8, 16, or 24), this instruction will shift the 8-bit
    constant by the specified number of bits before storing the constant into the
    two lanes. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The movi Vn.2S, #uimm8, msl #c instruction is almost identical to its lsl counterpart,
    except it shifts 1 bits rather than 0 bits into the vacated positions during the
    shift-left operation. The shift count is limited to 8 or 16 rather than 0, 8,
    16, and 24 (an annoying inconsistency). For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: loads 0x0001FFFF0001FFFF into V5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.4S, #uimm8 instruction fills the four word (single-precision) lanes
    in V*n* with a copy of the uimm8 constant. Otherwise, this instruction (and the
    variant with shifting) behaves identically to the 2S version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The movi Vn.2D, #uimm64 instruction loads one of two constants (0 or –1) into
    the two dword lanes of the V*n* register. Once again, keep in mind that these
    are integer constants, not floating-point constants, despite the use of the 2D
    type specifier.'
  prefs: []
  type: TYPE_NORMAL
- en: The second move immediate instruction is mvni (move and *not* immediate). It
    supports the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: where size and uimm8 have the same meanings as given for movi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations are the same as for movi, except that mvni inverts all the bits
    before storing them into the lanes of the V*n* destination register. The HO 64
    bits of V*n* still receive 0s for the 4H and 2S type specifiers, as shown in the
    following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note the absence of the 2D types for the mvni instruction. These instructions
    are unnecessary because the two allowable movi uimm64 constants are already the
    inverse of each other. If you want inverted bits, just use the other uimm64 constant
    (0 versus –1) with the movi instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third form of the move immediate instruction, fmov, allows you to load
    certain floating-point constants into the lanes of a vector register. The allowable
    syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The floating-point immediate constant (fimm) must be a value defined by
  prefs: []
  type: TYPE_NORMAL
- en: ±*n* ÷ 16 × 2*r*
  prefs: []
  type: TYPE_NORMAL
- en: 'where 16 ≤ *n* ≤ 31 and –3 ≤ *r* ≤ 4\. You cannot represent 0.0 with this formula;
    if you need to load 0.0 into the lanes of a vector register, just load the integer
    constant 0 into those lanes by using the movi instruction (all 0 bits is 0.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The move immediate instructions load only certain constant values into the
    vector registers. The following are the exact values you can load as immediate
    floating-point constants (Gas will accept only these values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Based on the way programs typically use the Neon registers, this is a reasonable
    set of values, which can be encoded into a 32-bit instruction opcode. To load
    larger or different constants, see section 11.3.4, “Vector Load and Store,” on
    the next page.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.3 Register or Lane Value Duplication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The dup instruction allows you to duplicate a value held in a general-purpose
    register or in a single lane of a vector register, throughout all the lanes in
    a vector register. This instruction supports the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction in each pair duplicates only data in the LO 64 bits of
    V*n*; the second instruction of each pair copies a full 128 bits. The two single
    instructions copy 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.4 Vector Load and Store
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The mov, movi, mvni, fmov, and dup instructions can move data between vector
    registers and between general-purpose and vector registers, and can load constants
    into vector registers. However, they don’t allow you to load a register from memory
    or store the value held in a vector register to memory. The Neon instruction set
    provides several load and store instructions to handle these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Because the load and store instructions are the most fundamental, this section
    considers them first. To load or store an entire 128-bit vector register, use
    the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: where memory is one of the usual ARM memory addressing modes (same as for the
    scalar ldr and str instructions). Note the use of Q*n* to denote the register
    (rather than V*n*). This is one of the few places the Q*n* register is legal (one
    wonders why they didn’t just use V*n*). These instructions will load or store
    a full 16 bytes, that is, 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stp instructions also allow vector register (Q*n*) operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that n and m in these instructions don’t have to be consecutive numbers
    but can be any arbitrary value in the range 0 to 31.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5 Interleaved Load and Store
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides load and store instructions that load data
    into a single lane across multiple vector registers. These instructions load interleaved
    data from memory into one, two, three, or four vector registers. The load (ld1,
    ld2, ld3, and ld4) and store (st1, st2, st3, and st4) instructions support non-interleaved
    data, pairs of interleaved data, triplets of interleaved data, and quad-interleaved
    data, respectively. The following subsections describe these types of interleaved
    load and store instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '##### 11.3.5.1 Interleaved Load and Store Addressing Modes'
  prefs: []
  type: TYPE_NORMAL
- en: The interleaved load and store instructions access memory, but they do not support
    the full set of ARM memory addressing modes, just three
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: where instr is one of ldn/stn and register_list is a comma-separated set of
    Q*n* registers that the load and store instructions will use when loading data
    from, or storing data to, memory. (The following sections discuss register _list
    at greater length.)
  prefs: []
  type: TYPE_NORMAL
- en: The standard register-indirect addressing mode is[Xn]. The ldn/stn instructions
    will access the data at the memory address held in general-purpose register X*n*.
  prefs: []
  type: TYPE_NORMAL
- en: The [Xn], Xm addressing mode computes its effective address as the sum of the
    values in X*n* and X*m*. This is a post-increment addressing mode; immediately
    after accessing the specified memory address, this mode adds the value of X*m*
    to X*n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Xn], #imm addressing mode is also a post-increment addressing mode, which
    computes its effective address as the sum of Xn + imm, then adds the immediate
    constant to X*n* after referencing the address. The immediate value is limited
    to the constants 1, 2, 4, 8, 16, 32, 48, or 64, where the register_list operand(s)
    determines the value you must use. The following sections describe the allowable
    immediate constants for each version of the instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.2 ld1/st1
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld1 instruction loads one to four registers with data from sequential (non-interleaved)
    memory locations. With a single vector register, the syntax for this instruction
    is the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'where memory is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Xn]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Xn], Xm'
  prefs: []
  type: TYPE_NORMAL
- en: '[Xn], #imm'
  prefs: []
  type: TYPE_NORMAL
- en: The imm operand, if present, must match the size of the register operand. That
    is, for B it must be 1; for 8B, 8; for 16B, 16; for H, 2; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The ld1 instruction with the {Vn.8B} register list operand loads 8 bytes into
    the LO 64 bits of V*n*, while the {Vn.16B} register list operand loads 16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: With a 4H or 2S type specification, the ld1 register also loads 64 bits (four
    hwords or two words) into the LO 64 bits of V*n*. With an 8H or 4S type, the ld1
    instruction loads 128 bits into V*n*. Although the 8B, 4H, and 2S types and the
    16B, 8H, 4S, and 2D types seem to be interchangeable (they load the same amount
    of data into V*n*), you should aim to pick the most appropriate type for the data
    you’re manipulating. Not only does this improve your documentation, but also the
    internal microarchitecture of the ARM CPU might be able to optimize its operations
    better based on the type of data you are using.
  prefs: []
  type: TYPE_NORMAL
- en: With the bare B, H, S, or D type specification, the ld1 instruction loads a
    single lane in V*n* with data from memory. This operation does not affect the
    data in the other lanes in V*n*. This is the most important variant of the ld1
    instruction because it allows you to build up data in a vector register one lane
    at a time from different locations in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does the ld1 instruction require braces around the vector register specification?
    The destination operand of this instruction is actually a register *list*. You
    can specify one to four registers in this list, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The registers that may appear in this list have two restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: They must be consecutively numbered registers (with V0 being the successor to
    V31).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type specifications must be identical for all registers in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have two or more consecutively numbered registers in a list, you can
    use the shorthand
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'where m is 1, 2, or 3, and t is one of the usual vector types, as shown in
    the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When you specify more than one register in the list, the ld1 instruction will
    load values from consecutive locations into the register. For example, the following
    code will load V0 from the 16 bytes at the address held in X0, V1 from the 16
    bytes at X0 + 16, and V2 from the 16 bytes at X0 + 32:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The st1 instruction supports an identical instruction syntax (except, of course,
    you substitute the st1 mnemonic for ld1). It stores the contents of the register(s)
    or lanes from those registers into the specified memory location. Here is an example
    that demonstrates storing the values in V0 and V1 to the location specified by
    X0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This instruction stores the value in V0 at the address held in X0, and the value
    in V1 to address X0 + 16.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.3 ld2/st2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld2 and st2 instructions load and store interleaved data. These two instructions
    use the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: where the register list must contain exactly two registers, and their register
    numbers must be consecutive. The t1 size is 8B, 16B, 4H, 8H, 2S, 4S, or 2D, while
    t2 is B, H, S, or D. The literal constant index is an appropriate lane number
    for the type’s size (0 to 15 for B, 0 to 7 for H, 0 to 3 for S, and 0 to 1 for
    D). Finally, memory is one of the addressing modes described in section 11.3.5.1,
    “Interleaved Load and Store Addressing Modes,” on [page 633](chapter11.xhtml#pg_633).
  prefs: []
  type: TYPE_NORMAL
- en: The variants with index (which load a single lane into the two registers) load
    the first register’s lane from the specified memory address and load the second
    register’s lane n bytes later (where n is the size of the lane, in bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The ld2 instruction with the t1 type specification (8B, 16B, 4H, 8H, and so
    on), meanwhile, loads the two registers one value at a time (of the specified
    type: B, H, S, or D), alternating destination lanes between the two registers.
    For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: loads the LO 8 bytes of V0 from memory locations X0, X0 + 2, X0 + 4, X0 + 6,
    X0 + 8, X0 + 10, X0 + 12, and X0 + 14\. It loads the LO 8 bytes of V1 from locations
    X0 + 1, X0 + 3, X0 + 5, X0 + 7, X0 + 9, X0 + 11, X0 + 13, and X0 + 15\. This deinterleaves
    the data in memory, loading the even bytes into V0 and the odd bytes into V1\.
    [Figure 11-4](chapter11.xhtml#fig11-4) shows how ld2 extracts interleaved data
    from X0 and stores the deinterleaved results in V0 and V1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The ld2 deinterleaving operation'
  prefs: []
  type: TYPE_NORMAL
- en: If you specify the half-word type (4H or 8H), the ld2 instruction deinterleaves
    16-bit values (even and odd half words). This is particularly useful for deinterleaving
    digital audio tracks that interleave left and right channels (16 bits per sample).
  prefs: []
  type: TYPE_NORMAL
- en: If you specify 2S/4S or 2D, this instruction will deinterleave words or dwords.
    For example, if you have an array of floating-point complex numbers, the ld2 instruction
    can deinterleave the real and imaginary components.
  prefs: []
  type: TYPE_NORMAL
- en: Because ld2 deinterleaves pairs of objects, the register list must contain exactly
    two registers. The assembler will reject any other number of registers in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: The st2 instruction uses the same syntax (except, of course, substituting st2
    for ld2). This instruction stores data lanes of the specified type from two registers
    into memory, interleaving the data between the two registers. The store operation
    is basically reversing the arrows in [Figure 11-4](chapter11.xhtml#fig11-4) (that
    is, copying the data from V0 and V1 into X0, interleaving the two data sets).
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.4 ld3/st3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld3 and st3 instructions behave in a similar fashion to ld2/st2, except
    that they (de)interleave three objects in memory rather than two, and the register
    list must contain exactly three registers.
  prefs: []
  type: TYPE_NORMAL
- en: A common example of using the ld3/st3 instructions is to (de)interleave red,
    green, blue (RGB) values consisting of 3 bytes—an 8-bit red, 8-bit green, and
    8-bit blue value—in memory. Using the ld3 instruction, you can deinterleave an
    array of 3-byte RGB values into separate red, green, and blue byte arrays. You
    can use the st3 instruction to interleave red, green, and blue values into an
    RGB array.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.5 ld4/st4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Finally, as you’ve probably figured out by now, the ld4 instruction copies
    four consecutive values from memory and stores those values into the same lane
    of the four registers specified by the four-element register list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This instruction copies the four dwords starting at the address held in X0 into
    lane 0 of V4, V5, V6, and V7, respectively. [Figure 11-5](chapter11.xhtml#fig11-5)
    diagrams how this ld4 instruction operates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: The ld4 instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: The ld4/st4 instructions are useful for (de)interleaving data in memory that
    consists of an array of four objects. For example, suppose that you have an array
    of CMYK (cyan-magenta-yellow-black) color pixels in memory, arranged as shown
    in [Figure 11-6](chapter11.xhtml#fig11-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: CMYK pixel layout in memory'
  prefs: []
  type: TYPE_NORMAL
- en: When submitting an image to a printing service, you generally need to provide
    color separations—that is, four separate images consisting only of the cyan pixels,
    magenta pixels, yellow pixels, and black pixels. Therefore, you’ll need to extract
    all the cyan pixels from the full-color image and create a separate image for
    that; likewise for the magenta, yellow, and black pixels.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the ld4 instruction to extract the cyan, magenta, yellow, and black
    values from the original image and place those pixels in four separate vector
    registers. For example, assuming X0 points at the first CMYK pixel (32 bits) in
    memory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: will extract the 4 bytes pointed at by X0 and distribute them into lane 0 of
    V0 (cyan), V1 (magenta), V2 (yellow), and V3 (black). If you add 4 to X0 and repeat
    this instruction, specifying lane 1 instead of lane 0, this will separate the
    second pixel into lane 1 of V0–V4\. Repeat this 14 more times and you’ll have
    16 cyan pixels in V0, 16 magenta pixels in V1, 16 yellow pixels in V2, and 16
    black pixels in V3\. You can then store away these four registers into the graphic
    image area that will hold the four-color separations. Repeat this process for
    all the pixels in the four-color image and you’ll have your color separations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can use the 8B and 16B types to process 8 or 16 pixels concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction copies 64 bytes into V0, V1, V2, and V3, with every fourth
    byte going into successive lanes in the four registers: V0 gets bytes at offsets
    *i* % 4, V1 gets bytes at offsets (*i* % 4) + 1, and so on, where *i* is the byte
    index into memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.5.6 ldnr
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ld1, ld2, ld3, and ld4 instructions load the lanes of one to four registers
    with successive values in memory, deinterleaving an array of interleaved objects
    (bytes, hwords, words, or dwords). The ld1r, ld2r, ld3r, and ld4r instructions
    also deinterleave an interleaved object, but the memory object is a single object
    that the instruction replicates through all lanes in the vector register(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for these instructions is the same as for the ldn instructions with
    the addition of the r suffix on the mnemonic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The .t represents a lane type (more on this in a moment), and memory is the
    usual ldn addressing modes. You can also use the range syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: when specifying two or more registers in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these instructions, allowable types are 8B, 16B, 4H, 8H, 2S, 4S, and 2D.
    These type specifications do the following when used with the ld1r instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: 8B loads the first 8 lanes of V*n* with a copy of the byte found at memory,
    replicating that byte in each lane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16B loads all 16 lanes of V*n* with a copy of the byte found at memory, replicating
    that byte in each lane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4H loads the first 4 lanes of V*n*, replicating the hword found at memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8H loads all 8 lanes of V*n*, replicating the hword found at memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2S loads the first 2 lanes of V*n*, replicating the word found at memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4S loads all 4 lanes of V*n*, replicating the word found at memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D loads the 2 dword lanes of V*n*, replicating the dword found at memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ld1r instruction fetches only a single lane value from memory and writes
    it to all the lanes of the destination register. The ld2r instruction fetches
    two lane objects from successive memory locations and replicates the first value
    throughout the first register and the second value throughout the second. The
    ld3r instruction fetches three lane objects from memory and replicates them through
    the first, second, and third registers, respectively. Finally, the ld4r instruction
    fetches four lane objects from memory and uses them to initialize the lanes of
    the four registers.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6 Register Interleaving and Deinterleaving
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ldn/stn and ldnr instructions operate between memory and the vector registers.
    When you want the ability to interleave and deinterleave data appearing in vector
    registers, leaving the result in a vector register, use the trn1, trn2, zip1,
    zip2, uzip1, uzip2, and ext instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.1 trn1 and trn2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The trn1 and trn2 (transpose) instructions—so called because you can use them
    to transpose the elements of a 2 × 2 matrix (or larger arrays with a little effort)—extract
    data from two source registers and interleave that data into a destination register.
    These instructions use the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. The d (destination), a, and b
    items are register numbers in the range 0 to 31\. These register numbers are arbitrary
    (they don’t have to be consecutive values, as is the case for the ldn/stn and
    ldnr instructions).
  prefs: []
  type: TYPE_NORMAL
- en: 'The trn1 instruction copies the data from even-numbered lanes in Va.t into
    the corresponding lanes in Vd.t, and data from even-numbered lanes in Vb.t into
    the odd lanes in Vd.t, while ignoring the odd-numbered lanes in Va.t and Vb.t.
    For example, consider the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This instruction interleaves the alternate bytes in V2 and V4, leaving the result
    in V0, as shown in [Figure 11-7](chapter11.xhtml#fig11-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: The trn1 v0.4s, v2.4s, v4.4s operation'
  prefs: []
  type: TYPE_NORMAL
- en: The trn2 instruction copies the values in the odd lanes in Va.t and Vb.t into
    alternating lanes in Vd.t, as shown in [Figure 11-8](chapter11.xhtml#fig11-8)
    (similar to trn1 except that it swaps the source locations).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: The trn2 v0.4s, v2.4s, v4.4s operation'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the 2×2 matrix of double-precision values held in V2 and V3 as shown
    in [Figure 11-9](chapter11.xhtml#fig11-9) (note the positions of the array elements,
    which is different from what you would normally expect).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: A 2×2 matrix held in V2 and V3'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two instructions will transpose this matrix, leaving the result
    in V0 and V1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Of course, trn1 and trn2 are generally useful for rearranging and interleaving
    values in the vector registers, even if you aren’t transposing 2×2 matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.2 zip1 and zip2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The zip1 and zip2 instructions are similar to trn1 and trn2 insofar as they
    produce an interleaved result from data taken from two source registers. The name
    *zip* comes from *zipper*: the instruction interleaves lanes just like a zipper
    interleaves the two halves of the connector. Except for the mnemonics, the syntax
    is identical to trn1 and trn2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D (all types must be the same in
    the instruction).
  prefs: []
  type: TYPE_NORMAL
- en: The zipn and trnn instructions differ in the way they select the source lanes
    to interleave. The zip1 instruction interleaves lane values taken from the beginning
    of the source registers (consuming half the lanes of each source register and
    ignoring the remaining lanes). See [Figure 11-10](chapter11.xhtml#fig11-10) for
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: The zip1 v0.4s, v1.4s, v2.4s operation'
  prefs: []
  type: TYPE_NORMAL
- en: The zip2 instruction works similarly except that it processes the second half
    of the lanes in the source registers. [Figure 11-11](chapter11.xhtml#fig11-11)
    shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: The zip2 v0.4s, v1.4s, v2.4s operation'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these figures, the zip1 and zip2 instructions are typically
    what you would use to create interleaved data using only registers.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.3 uzp1 and uzp2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The uzp1 and uzp2 (unzip1 and unzip2) instructions are the inverse of zip1
    and zip2. They take interleaved data in two source registers and produce deinterleaved
    data in the destination register. Their syntax is the same as that of the trnn
    and zipn instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As usual, t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D.
  prefs: []
  type: TYPE_NORMAL
- en: The uzp1 instruction copies the even lanes from Va.t into the first half of
    Vd.t, then appends the even lanes of Vb.t to the end of Vd.t. See [Figure 11-12](chapter11.xhtml#fig11-12)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: The uzp1 v0.4s, v1.4s, v2.4s operation'
  prefs: []
  type: TYPE_NORMAL
- en: The uzp2 instruction copies the odd lanes from the source registers. [Figure
    11-13](chapter11.xhtml#fig11-13) shows an example of the uzp2 instruction in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: The uzp2 v0.4s, v1.4s, v2.4s operation'
  prefs: []
  type: TYPE_NORMAL
- en: If the type specifier is 64 bits (8B, 4H, or 2S), the uzp1 and uzp2 instructions
    leave 0s in the HO lanes of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.6.4 ext
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ext (extract) instruction creates an 8- or 16-byte vector from *n* bytes
    in one vector and 8-*n* (or 16-*n*) bytes from a second vector. This instruction
    allows you to extract an 8- or 16-byte vector from across two vectors. The syntax
    for this instruction is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: where n is a starting index, Vd is the destination register, and Vs1 and Vs2
    are the source registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ext Vd.8B, Vs1.8B, Vs2.8B, #n instruction fetches the LO n bytes from Vs2
    and copies them to the HO n bytes of the LO 64 bits in Vd*.* It also extracts
    the LO 8-n bytes from Vs1 and copies them to the LO 8-n bytes of Vd. For an example
    of ext, see [Figure 11-14](chapter11.xhtml#fig11-14).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-14: The ext v0.8B, v1.8B, v2.8B, #2 instruction'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ext Vd.16B, Vs1.16B, Vs2.16B, #n instruction fetches the LO n bytes from
    Vs2 and copies them to the HO n bytes of Vd*.* It also extracts the LO 16-n bytes
    from Vs1 and copies them to the LO 16-n bytes of Vd (see [Figure 11-15](chapter11.xhtml#fig11-15)
    for an example).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-15: The ext v0.16B, v1.16B, v2.16B, #5 instruction'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction supports only the 8B and 16B types. You can easily extract
    hwords, words, or dwords by choosing an appropriate index value (n) that includes
    all the objects you want to extract.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.7 Table Lookups with tbl and tbx
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tbl and tbx (table lookup) instructions allow you to exchange all the byte
    values in one register with values taken from a lookup table containing up to
    64 entries. The syntax for these instructions is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: where table_list is a list of one to four (consecutively numbered) registers,
    all of which must have a 16B type attached to them. (You can also use the Vn.t
    - Vm.t syntax, where m > n and m < (n + 4).) This list of registers provides a
    lookup table that contains 16, 32, 48, or 64 entries. The LO byte of the first
    register is index 0 in the table; the HO byte of the last register is index 15,
    31, 47, or 63 into the table.
  prefs: []
  type: TYPE_NORMAL
- en: The tbl instruction fetches each byte from the source register (Vs.t) and uses
    its value as an index into the lookup table. It fetches the byte at that index
    from the table and copies it to the corresponding location in the destination
    register—that is, the same byte index from which the source byte was taken; so
    this is equivalent to Vd[i] = table[Vs[i]]. If the value is out of range (greater
    than 15, 31, 47, or 63, depending on the size of the table), the tbl instruction
    stores a 0 into the corresponding location in the destination register. The tbx
    instruction works similarly to tbl, except that it leaves the destination location
    unchanged if the source value is out of range.
  prefs: []
  type: TYPE_NORMAL
- en: For very small tables (64 entries or fewer), you can use tbl and tbx to implement
    lookup tables as described in [Chapter 10](chapter10.xhtml). However, the main
    purpose of these two instructions is to provide arbitrary vector permutations
    like the trn1/trn2, zip1/zip2, uzp1/uzp2, and ext instructions. Suppose, for example,
    that you want to reverse the positions of all 16 bytes in a vector register (swapping
    indices 0 and 15, 1 and 14, 2 and 13, 3 and 12, and so on). [Figure 11-16](chapter11.xhtml#fig11-16)
    shows a 16-byte endian swap operation, where the double-ended arrows point to
    the two locations where the bytes are exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-16: A 16-byte endian swap'
  prefs: []
  type: TYPE_NORMAL
- en: If you load a vector register with the following 16-byte value
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'and then use this value in the source register for the tbl (or tbx) instruction,
    tbl (or tbx) will swap the bytes in a single 16-byte register supplied as the
    table_list, storing the reversed bytes in the destination register. Assuming you’ve
    loaded this value into V0, the following instruction will swap the bytes in {V1},
    placing the results in V2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After you load V1 with the bytes to be swapped and execute this instruction,
    V2 will contain the swapped values.
  prefs: []
  type: TYPE_NORMAL
- en: To use tbl or tbx as a vector permutation instruction, load the permutation
    indexes into the source register (V0 in this example). The indices will always
    be values in the range 0 to 15, to select specific entries in table_list. For
    a true permutation, each of the values (0 to 15) will appear exactly once in the
    source register, and there will always be a single register in the table _list.
    Because you’re limiting the values in the source register to the range 0 to 15,
    the table index values are always in range, so you can use either tbl or tbx.
    Both work exactly the same when the values are not out of range.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can use any permutation you like by specifying different values
    in the source register. As with the ext instruction, tbl and tbx support only
    the 8B and 16B lane types. However, it’s easy enough to synthesize other types
    (for permutations, anyway) by choosing the positions of the source register lane
    values to permute hwords, words, and dwords. Obviously, for table lookup operations
    (rather than permutations), you’re limited to 8-bit values, so hword, word, and
    dword types don’t make any sense.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.8 Endian Swaps with rev16, rev32, and rev64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The rev16, rev32, and rev64 instructions are similar to their scalar counterparts
    rev16, rev32, and rev (see section 3.3, “Little-Endian and Big-Endian Data Organization,”
    on [page 133](chapter3.xhtml#pg_133)), except, of course, they operate on the
    lanes in a vector source register rather than on a general-purpose integer register.
    Here is their syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The legal types and lane counts for these instructions appear in [Table 11-1](chapter11.xhtml#tab11-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1: Legal Types and Lane Counts for rev* Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Type and lane count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B |'
  prefs: []
  type: TYPE_TB
- en: '| t2 | 8B, 16B, 4H, or 8H |'
  prefs: []
  type: TYPE_TB
- en: '| t3 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  prefs: []
  type: TYPE_TB
- en: If the lane count and type is 8B, 4H, or 2S, the instruction operates only on
    the LO 64 bits of the source register (and clears the HO 64 bits of the destination
    register). If the lane count and type is 16B, 8H, or 4S, these instructions operate
    on the full 128 bits of the source register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 Vertical and Horizontal Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point, vector operations have been *vertical*, meaning they’ve operated
    on the same lane across multiple registers (which, when stacked as appearing in
    most figures thus far, show a vertical operational direction). Consider the following
    vector addition instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the scalar addition operation (for example, add w0, w1, w2), this instruction
    adds the values of two source registers (V1.16B and V2.16B), producing a sum in
    the destination register. However, this is not a 128-bit addition operation, but
    rather an 8-bit operation repeated 16 times. Vector operations typically operate
    on a lane-by-lane basis, performing multiple small operations in parallel. For
    this particular instruction, the CPU adds together 16 byte values, producing 16
    independent byte results. This is the magic behind SIMD programming: the ability
    to do 16 times as much work with a single instruction (so it should run about
    16 times faster than running these 16-byte additions individually).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-17](chapter11.xhtml#fig11-17) shows the lane-by-lane operation of
    the add instruction with the lane-by-lane addition following the arrow directions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-17: Lane-by-lane operations'
  prefs: []
  type: TYPE_NORMAL
- en: Lane-by-lane operations are independent of one another, meaning that if any
    carries, overflows, or other exceptional conditions occur, such anomalies are
    limited in scope to a single lane. Because there is only a single set of NVZC
    condition code flags, vector instructions cannot (and do not) affect these flags.
    If an unsigned carry out of one lane occurs (such as when adding 255 + 1 in a
    byte lane), the sum wraps around with no indication of overflow or underflow.
    In general, you must handle overflows completely differently from the way you’d
    handle them when doing scalar arithmetic. This chapter covers some strategies
    for doing so when discussing saturation in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Certain vector instructions provide *horizontal operations*, also known as *reducing
    operations*. Rather than operating lane by lane between two registers, these operations
    operate on all the lanes within a single vector register, producing a scalar result.
    For example, the addv instruction will produce the sum of all the lanes in a single
    vector register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 SIMD Logical Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because logical (Boolean) operations are computed on a bitwise basis, vector
    logical operations are unique insofar as you can use them to perform 128 individual
    bit operations. Whether you treat the source operands as sixteen 1-byte values
    or as one 128-byte value, the result is the same. For that reason, the vector
    logical operations support only two types: 8B (for 64-bit operands) and 16B (for
    128-bit operands). If you really want to operate on 4H or 2S operands, just specify
    8B; you’ll get the same result. Likewise, for 8H, 4S, or 2D operands, specifying
    16B produces the same result.'
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set supports eight logical instructions, as shown in [Table
    11-2](chapter11.xhtml#tab11-2). Here, t is 8B or 16B, Vd is the destination register,
    Vs1 is the left source register, and Vs2 is the right source register (Vs is the
    only source register for the not instruction).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-2: Neon Logical Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| and | and Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & Vs2 |'
  prefs: []
  type: TYPE_TB
- en: '| orr | orr Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; Vs2 |'
  prefs: []
  type: TYPE_TB
- en: '| orn | orn Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; ~(Vs2) |'
  prefs: []
  type: TYPE_TB
- en: '| eor | eor Vd.t, Vs1.t, Vs2.t | Vd = Vs1 ^ Vs2 |'
  prefs: []
  type: TYPE_TB
- en: '| bic | bic Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & ~(Vs2) (bit clear) |'
  prefs: []
  type: TYPE_TB
- en: '| bif | bif Vd.t, Vs1.t, Vs2.t | Bit insert if false |'
  prefs: []
  type: TYPE_TB
- en: '| bit | bit Vd.t, Vs1.t, Vs2.t | Bit insert if true |'
  prefs: []
  type: TYPE_TB
- en: '| bsl | bsl Vd.t, Vs1.t, Vs2.t | Bitwise select |'
  prefs: []
  type: TYPE_TB
- en: '| not | not Vd.t, Vs.t | Vd = ~Vs |'
  prefs: []
  type: TYPE_TB
- en: The and, orr, and eor instructions do the usual logical operations (same as
    scalar) and require no further explanation. The orn instruction is similar to
    bic insofar as it inverts the second source operand prior to the OR operation.
  prefs: []
  type: TYPE_NORMAL
- en: The bic (bit clear) instruction clears all the bits in the value of Vs1 in the
    positions containing 1s in Vs2. It stores the result in Vd. Note that there is
    no need for a bis (bit set) instruction, because orr will set bits in Vd.
  prefs: []
  type: TYPE_NORMAL
- en: The bif (bit insert if false) and bit (bit insert if true) instructions are
    unusual insofar as they use three operands in their computation (rather than using
    a function of two inputs and storing the result in a third operand). The bif instruction
    copies the bits from Vs1 to Vd wherever the corresponding bit in Vs2 contains
    a 0\. In the bit positions where Vs2 contains a 1, this instruction leaves the
    corresponding bit in Vd unchanged. The bit instruction works similarly, except
    it copies the bits when the corresponding bit in Vs2 contains a 1 (rather than
    0).
  prefs: []
  type: TYPE_NORMAL
- en: The bsl (bit select) instruction selects bits from Vs1 or Vs2 (and copies them
    to Vd) based on the original contents of Vd. If Vd originally contained a 1 in
    a particular bit position, bsl selects the corresponding bit from Vs1. Otherwise,
    it selects the bit from Vs2.
  prefs: []
  type: TYPE_NORMAL
- en: The not instruction inverts all the bits in the source register and stores the
    result into the destination register. This instruction is different from the other
    logical instructions, having only a single source operand.
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set supports a few special immediate versions of the orr
    and bic instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'where imm is an unsigned 8-bit immediate value; the type (t) is 2S, 4S, 4H,
    or 8H; and shift is 0 or 8 if t is 4H/8H and 0, 8, 16, or 24 if t is 2S or 4S.
    If shift is not specified, it is assumed to be 0\. These instructions require
    the H and S types rather than the B types, since they replicate the immediate
    value through the bytes in the lanes in Vd.t.  ### 11.6 SIMD Shift Operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shift instructions are generally considered to be logical operations. However,
    from a vector point of view, they are more correctly thought of as arithmetic
    operations because shift operations can produce overflows. Vector shift operations
    handle overflows in one of four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring any carry out of the shift operation (truncation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saturating the shift result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rounding the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing an extended shift operation whose destination operand is larger than
    the source register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section describes these various shift operations.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Neon instruction set uses mnemonics based on* shr *and* shl *for shift
    left and shift right. This is in contrast to the* lsl*,* lsr*, and* asr *instructions
    that the scalar integer instruction set uses. I cannot think of a good reason
    they did it this way; it would have made the instruction set easier to learn had
    they stuck to a consistent naming convention.*'
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.1 Shift-Left Instruction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shl instruction shifts each lane of a vector register to the left the specified
    number of bits. This instruction shifts 0s into the (vacated) LO bits. Any carry
    out of the HO bit of the lane is lost. The syntax is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: where Vd is the destination register and Vs is the source register. The immediate
    count value must be in the ranges appearing in [Table 11-3](chapter11.xhtml#tab11-3)
    (based on the specified type). The assembler will report an error if an immediate
    shift value is outside these ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-3: Valid shl Shift Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Shift range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8B/16B | 0 to 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 4H/8H | 0 to 15 |'
  prefs: []
  type: TYPE_TB
- en: '| 2S/4S | 0 to 31 |'
  prefs: []
  type: TYPE_TB
- en: '| 2D | 0 to 63 |'
  prefs: []
  type: TYPE_TB
- en: There is also a scalar shl instruction that operates on the LO dword of a vector
    register, with the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: where Dd is the destination scalar register and Ds is the source register (corresponding
    to the LO 64 bits of Vd and Vs). The imm shift count must be in the range 0 to
    63\. Note that this instruction will zero out the HO 64 bits of Dd.
  prefs: []
  type: TYPE_NORMAL
- en: To shift the lanes by a variable number of bits, see section 11.6.9, “Shift
    by a Variable Number of Bits,” on [page 657](chapter11.xhtml#pg_657).
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.2 Saturating Shift Left
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The saturating shift-left instructions uqshl, sqshl, and sqshlu shift the lanes
    in a vector to the left the specified number of bit positions. If an overflow
    (whether signed or unsigned) occurs, these instructions saturate the result to
    the largest (signed or unsigned) value depending on the instruction. The syntax
    for these instructions is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: where Vd is the destination register, Vs is the source register, imm is an appropriate
    immediate shift constant or Vc contains a shift count in the LO byte, and t is
    type 8B, 16B, 4H, 8H, 2S, 4S, or 2D. The t specification must be the same for
    Vd and Vs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shift value’s range depends on the lane type; see [Table 11-3](chapter11.xhtml#tab11-3)
    in the previous section for the legal immediate values. For immediate values,
    the assembler will report an error if the shift constant is out of range. For
    the register shift count variants, if the LO byte contains an out-of-range value,
    then the instruction will always saturate the result if a lane contains a nonzero
    value (see the discussion of saturation that follows). The uqshl instruction shifts
    values to the left one bit position, storing the result in the corresponding lane
    in the destination register. If the HO bit is set (before the shift), this instruction
    stores all 1 bits (the maximum unsigned value) in the destination lane. For example,
    if a lane contains 0x7F in V1, the corresponding lane will contain 0xFE (0x7F
    shifted left one position) after the execution of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: However, if a source lane contains the value 0x80 through 0xFF, then shifting
    it to the left one position produces 0xFF in the destination lane. In general,
    if anything other than 0 bits are shifted out of a source lane, the corresponding
    destination lane will contain 0xFF.
  prefs: []
  type: TYPE_NORMAL
- en: The sqshl instruction is a signed saturation shift-left operation. For signed
    values, an overflow will occur during a left shift if the H two bits of a lane
    contain different values. For negative source values (the HO bit is set), overflow
    saturates to a result with the HO bit set and all other bits containing 0s (for
    example, with hword types, 0xa000 will saturate to 0x8000).
  prefs: []
  type: TYPE_NORMAL
- en: The sqshlu instruction is similar to sqshl, except that it treats the destination
    as an unsigned value. Positive (and 0) source values will shift to the left exactly
    like the uqshl instruction, while negative source values (with the HO bit set)
    will saturate to 0.
  prefs: []
  type: TYPE_NORMAL
- en: There are also scalar versions of the uqshl, sqshl, and sqshlu instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: where Rn (n = d or s) is one of the registers B*n*, H*n*, S*n*, or D*n*, and
    d, s, and imm have the usual meanings and limitations. Unlike the plain shl instruction,
    these instructions allow byte, hword, and word registers, as well as dword registers.
  prefs: []
  type: TYPE_NORMAL
- en: As for the vector instructions, the uqshl instructions do an unsigned saturation.
    If any bits are shifted out of the HO bit of the source register, these instructions
    set the destination (B*n*, H*n*, S*n*, or D*n*) to all 1 bits. These instructions
    zero-extend the result through the rest of the vector register containing R*d*.
  prefs: []
  type: TYPE_NORMAL
- en: The sqshl instruction does a signed saturation, leaving the result in the destination
    (scalar) register. This instruction zeros out the remaining HO bits of the corresponding
    vector register (that is, all the HO bits beyond the size of the scalar register).
  prefs: []
  type: TYPE_NORMAL
- en: The sqshlu instruction does a shift on a signed source value but saturates it
    to an unsigned value (negative results saturate to 0, just as with the vector
    register versions of this instruction).
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.3 Shift-Left Long
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *shift-left long* instructions sshll, sshll2, ushll, and ushll2 provide
    a mechanism to handle overflow during a shift operation. These instructions sign-
    or zero-extend the value in a lane to twice its size and then perform the left
    shift on the double-sized source, storing the result into the (double-sized) destination
    lane. The syntax for these instructions is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: where t2 is the double-sized type and can be 8H, 4S, or 2D; t is the original
    type and can be 8B, 4H, or 2S. imm is the shift count and should be in the range
    0 to n – 1, where n is the number of bits in the t type.
  prefs: []
  type: TYPE_NORMAL
- en: The ushll instruction zero-extends the values in the source lanes to twice their
    size, shifts the zero-extended result by the specified number of bits, and stores
    the result into the corresponding (double-sized) destination lanes. The sshll
    instruction sign-extends the source lane values to twice their size, then shifts
    the results and stores them in the double-sized destination lanes.
  prefs: []
  type: TYPE_NORMAL
- en: Because these instructions double the size of their values, they operate only
    on the LO 64 bits of the source register (lanes 0 to 7 for bytes, 0 to 3 for hwords,
    and 0 to 1 for words). These instructions ignore the HO 64 bits of the source
    register.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the upper 64 bits of the source register, the ARM provides the ushll2
    and sshll2 instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These accomplish the same operations as the ushll and sshll instructions, except
    that they take their source operands from the HO 64 bits rather than the LO 64
    bits. To indicate this, the t4/t3 type pairs must be 8H/16B, 4S/8H, or 2D/4S.
    The imm shift values must match the source lane size in bits (0 to 15 for 8H/16B,
    0 to 31 for 4S/8H, and 0 to 63 for 2D/4S).
  prefs: []
  type: TYPE_NORMAL
- en: The ushll, ushll2, sshll, and sshll2 instructions have no scalar versions. Just
    use the vector versions and zero out the HO bits yourself if you need this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.4 Shift and Insert
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sli and sri instructions allow you to shift a source operand a certain number
    of bits and then (using other instructions) insert other bits into the locations
    (0 bits) vacated by the shift operation. Here’s the syntax for these instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'where *t* is the usual set of types: 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For sli,
    imm is the shift count, which must be in the range 0 to n – 1, where n is bit
    size of a lane. For sri, the immediate value is a count in the range 1 to n.'
  prefs: []
  type: TYPE_NORMAL
- en: The sli instruction shifts each lane in Vs.t to the left the specified number
    of bits. It then logically ORs the n - imm LO bits of Vd.t into the result (replacing
    the 0s that were shifted in) and stores the result back into Vd.t, as shown in
    [Figure 11-18](chapter11.xhtml#fig11-18).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: The sli instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to shift in 1 bits rather than 0 bits, you could load the destination
    register with all 1 bits, then execute the sli instruction, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This produces 0x0000001f0000001f0000001f0000001f in V0.
  prefs: []
  type: TYPE_NORMAL
- en: The sri instruction shifts each lane in Vs.t to the right the specified number
    of bits, then logically ORs the n - imm HO bits of Vd.t into the result (replacing
    the 0s that were shifted in), then stores the result back into Vd.t, as shown
    in [Figure 11-19](chapter11.xhtml#fig11-19).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: The sri instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The scalar versions of the sli and sri instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: These instructions operate on the LO 64 bits of the specified vector register
    (Dn) and zero out the HO 64 bits of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.5 Signed and Unsigned Shift Right
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because an arithmetic shift left and a logical shift left are essentially the
    same operation, the ARM uses a single instruction for both operations: shl. However,
    the logical and arithmetic shifts are different for right shifts. Therefore, the
    Neon instruction set provides two instructions, sshr and ushr, for signed and
    unsigned shift right (respectively, arithmetic shift right and logical shift right).'
  prefs: []
  type: TYPE_NORMAL
- en: As noted in [Chapter 2](chapter2.xhtml), a shift-left operation is the same
    as a multiplication by 2\. Shift-right operations are approximately the same as
    a division by 2\. I say *approximately* because the behaviors of signed and unsigned
    numbers are somewhat different. For example, when you shift the value 1 to the
    right one position, you get a 0 result. If you shift the signed value –1 (all
    1 bits) to the right by using an arithmetic shift right, however, the result is
    –1\. In one case, the shift rounds toward 0, while in the other it rounds away
    from 0\. Neither case is particularly correct or incorrect, but not being able
    to choose the rounding direction can be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'With scalar instructions, you can reverse this rounding effect by adding the
    carry flag to the result after the shift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Because the vector operations don’t track carries out of a shift in the carry
    flag, you don’t have the option of correcting for this. The Neon instruction set
    therefore provides the rounding shift instructions srshr and urshr, which will
    add in the carry for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the Neon shift-right instructions is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The allowable types for the vector registers are the usual 8B, 16B, 4H, 8H,
    2S, 4S, or 2D. The rounding variants (with the r as the second character in the
    mnemonic) add the carry flag back into the destination lane after the shift operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sshr, srshr, ushr, and urshr instructions also have scalar versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: These instructions operate on the LO 64 bits of the vector registers specified
    by Dd (destination) and Ds (source). The imm shift operand must be a value in
    the range 1 to 64\. They will zero out the HO 64 bits of the corresponding Vd
    register. Otherwise, they are identical to their vector components.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.6 Accumulating Shift Right
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The accumulating shift-right instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: These instructions are largely the same as the shift-right instructions, but
    they add their shifted values to the corresponding destination lanes (rather than
    just storing the shift lane values).
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.6.7 Narrowing Shift Right'
  prefs: []
  type: TYPE_NORMAL
- en: The shrn, shrn2, rshrn, and rshrn2 instructions provide the converse operations
    to the shll and shll2 instructions. Rather than double the size of the operands
    when shifting, they halve (“narrow”) the size. The syntax for these instructions
    is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: t1 is 8B, 4H, or 2S
  prefs: []
  type: TYPE_NORMAL
- en: t2 is 8H, 4S, or 2D
  prefs: []
  type: TYPE_NORMAL
- en: t3 is 8B, 16B, 4H, 8H, 2S, or 4S
  prefs: []
  type: TYPE_NORMAL
- en: t4 is 8H, 4S, or 2D
  prefs: []
  type: TYPE_NORMAL
- en: The shrn instruction shifts each lane right the specified number of bits (shifting
    0s in from the left); extracts the LO 8, 16, or 32 bits (depending on size of
    t1); and stores the result into the same lane number in the destination register.
    The shrn instruction ignores (truncates) any HO bits left in the shift operation
    that don’t fit in the destination lane (which, recall, is half the size of the
    source lane). This instruction zeros out the HO 64 bits of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: The shrn2 instruction performs the exact same operation but stores the results
    in the HO 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The rshrn and rshrn2 instructions do the same thing as shrn and shrn2, respectively,
    but round the shifted result before narrowing it. The rshrn instruction also clears
    the upper half of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: Because the narrowing shift-right instructions throw away all but the LO bits
    that fit in the destination lane, you might think a separate set of instructions
    must extract the HO bits after the shift operation. There’s no need for such instructions,
    though; just add 8, 16, or 32 to your shrn, shrn2, rshurn, or rshrn2 shift count
    to extract the HO bits.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.8 Saturating Shift Right with Narrowing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The standard narrowing shift instructions truncate any HO bits when narrowing
    the result to half the source lane size. The saturating shift-right instructions
    will saturate the shifted value if it does not fit in the destination lane. [Table
    11-4](chapter11.xhtml#tab11-4) gives the syntax for these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-4: Lane-by-Lane Saturating Shift Right with Narrowing Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| uqshrn | uqshrn Vd.t1, Vs.t2, #imm | Unsigned shift right by imm bits with
    narrowing. Stores data into LO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| uqrshrn | uqrshrn Vd.t1, Vs.t2, #imm | Unsigned shift right by imm bits with
    narrowing and rounding. Stores data into LO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqshrn | sqshrn Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing. Stores data into LO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrshrn | sqrshrn Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing and rounding. Stores data into LO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqshrun | sqshrun Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing and saturation to an unsigned number. Stores data into LO 64 bits of
    Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrshrun | sqrshrun Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing, rounding, and saturation to an unsigned number. Stores data into LO
    64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| uqshrn2 | uqshrn2 Vd.t3, Vs.t4, #imm | Unsigned shift right by imm bits with
    narrowing. Stores data into HO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| uqrshrn2 | uqrshrn2 Vd.t3, Vs.t4, #imm | Unsigned shift right by imm bits
    with narrowing and rounding. Stores data into HO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqshrn2 | sqshrn2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing. Stores data into HO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrshrn2 | sqrshrn2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing and rounding. Stores data into HO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqshrun2 | sqshrun2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing and saturation to an unsigned number. Stores data into HO 64 bits of
    Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrshrun2 | sqrshrun2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits
    with narrowing, rounding, and saturation to an unsigned number. Stores data into
    HO 64 bits of Vd. |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-5](chapter11.xhtml#tab11-5) lists the legal types and lane counts
    for the saturating shift-right instructions appearing in [Table 11-4](chapter11.xhtml#tab11-4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-5: Saturating Shift-Right Types and Lane Counts'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types and lane counts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 8B/8H, 4H/4S, or 2S/2D |'
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 16B/8H, 8H/4S, or 4S/2D |'
  prefs: []
  type: TYPE_TB
- en: The instructions with the 2 suffix store their narrowed results into the HO
    64 bits of the destination register. Those without this suffix will zero out the
    HO 64 bits of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: The uqrshrn, sqrshrn, uqrshrn2, and sqrshrn2 instructions round the shifted
    result before saturating the value (if saturation is necessary). Rounding consists
    of adding the last bit shifted out of the source lane back into the value.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions with the s prefix operate on signed values, while those with
    the u prefix operate on unsigned values. Unsigned values saturate to all 1 bits
    (if the unsigned value will not fit in the destination lane size), but signed
    values will saturate to either a HO bit of 1 with other bits 0s, or a HO bit of
    0 with all other bits containing 1s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sqrshrun and sqrshrun2 instructions do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform an arithmetic shift-right operation by the specified number of bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Round the result by adding the last bit shifted out back into the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saturate the result to the maximum unsigned value (all 1 bits) if the result
    will not fit into the destination lane; negative values saturate to 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the saturated result into the destination lane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sqrshrun instruction stores the results in the LO 64 bits of the destination
    register; sqrshrun2 stores the results in the HO 64 bits of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions also have scalar versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that these instructions clear the upper bits (beyond the specified scalar
    register) of the underlying vector register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.9 Shift by a Variable Number of Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To shift a lane by a variable number of bits, use one of the following instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: where t is the usual 8B, 16B, 4H, 8H, 2S, 4S, or 2D.
  prefs: []
  type: TYPE_NORMAL
- en: Vc.t holds the signed shift count in the LO byte. For positive values (in the
    range 0 to 0x7F), the instruction shifts the bits in a lane the number of bit
    positions to the left. For negative values (0xFF to 0x80; –1 to –128), the instruction
    shifts the bits to the right, despite using a shl mnemonic. See [Table 11-6](chapter11.xhtml#tab11-6)
    for legal ranges when specifying the shift count by using a register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-6: Legal Vc.t Shift Ranges'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Unsigned (SHL) | Signed (SHR) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8B/16B | 0 to 7 | –1 to –7 |'
  prefs: []
  type: TYPE_TB
- en: '| 4H/8H | 0 to 15 | –1 to –15 |'
  prefs: []
  type: TYPE_TB
- en: '| 2S/4S | 0 to 31 | –1 to –31 |'
  prefs: []
  type: TYPE_TB
- en: '| 2D | 0 to 63 | –1 to –63 |'
  prefs: []
  type: TYPE_TB
- en: Values outside the ranges listed in [Table 11-6](chapter11.xhtml#tab11-6) will
    produce the results shown in [Table 11-7](chapter11.xhtml#tab11-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-7: Result of Shift If Count Exceeds Allowable Range'
  prefs: []
  type: TYPE_NORMAL
- en: '| Shift instruction | Positive count, positive overflow | Positive count, negative
    overflow | Negative count, positive value | Negative count, negative value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sshl | 0 | 0 | 0 | –1 (all 1 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| ushl | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| sqshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | –1 (all 1 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| uqshl | All 1 bits (for example, 0xff) | All 1 bits (for example, 0xff) |
    0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| srshl | 0 | 0 | 0 | 0 (–1 + carry) |'
  prefs: []
  type: TYPE_TB
- en: '| urshl | 0 | 0 | 0 | 1 (0 + carry) |'
  prefs: []
  type: TYPE_TB
- en: '| sqshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | –1 (all 1 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| uqshl | –1 (all 1 bits) | –1 (all 1 bits) | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| sqrshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | 0 (–1 + carry) |'
  prefs: []
  type: TYPE_TB
- en: '| uqrshl | –1 (all 1 bits) | –1 (all 1 bits) | 0 | 1 (0 + carry) |'
  prefs: []
  type: TYPE_TB
- en: Using shf (for shift) in these instructions would probably have been a better
    choice then shl, since that name better matches the operation. Just keep in mind
    that the value in the LO byte of Vc.t is a signed integer and negative values
    indicate a right shift.
  prefs: []
  type: TYPE_NORMAL
- en: The Neon shl instruction also has some scalar saturating versions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: where R represents one of the scalar register names (B, H, S, or D). These instructions
    shift the value in the scalar register Rs the number of bit positions specified
    by the LO byte of Rc and store the shifted result in Rd. Rc is treated as a signed
    number; positive values shift Rs left, while negative values shift Rs right. If
    an overflow (signed or unsigned, as appropriate) occurs during the shift, these
    instructions set Rd to the maximum positive signed or unsigned value.
  prefs: []
  type: TYPE_NORMAL
- en: If the shift count is negative for the sqshl instruction, the CPU performs an
    arithmetic shift-right operation, which will replicate the HO bit when shifting
    to the right. Positive (and 0) source values will saturate to 0, and negative
    source values will saturate to –1 (all 1 bits).
  prefs: []
  type: TYPE_NORMAL
- en: The sqrshl and uqrshl instructions are special rounding versions of the saturating
    shift instructions. During a shift-right operation (that is, when Rc is negative),
    these instructions round the result by adding 1 if the last bit shifted out was
    a 1 bit.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 SIMD Arithmetic Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set includes several common arithmetic operations, including
    addition, subtraction, and multiplication. The only surprise is that there is
    no division operation; instead, you’ll have to compute the reciprocal and multiply
    by that value (using the instructions provided to estimate reciprocals).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1 SIMD Addition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Neon provides a wide set of instructions that add lanes (ignoring overflow),
    add and saturate (when overflow occurs), or perform horizontal additions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.1 Vector Addition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions you can use to add integer
    and floating-point values in lanes within the vector registers, as listed in [Table
    11-8](chapter11.xhtml#tab11-8). These instructions compute Vd = Vl + Vr, where
    Vd is the destination, Vl is the left operand, and Vr is the right operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-8: Neon Addition Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| add | add Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane integer sum |'
  prefs: []
  type: TYPE_TB
- en: '| fadd | fadd Vd.t2, Vl.t2, Vr.t2 | Computes lane-by-lane floating-point sum
    |'
  prefs: []
  type: TYPE_TB
- en: '| sqadd | sqadd Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane signed integer
    sum, with saturation |'
  prefs: []
  type: TYPE_TB
- en: '| uqadd | uqadd Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane unsigned integer
    sum, with saturation |'
  prefs: []
  type: TYPE_TB
- en: '| saddl | saddl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane signed integer
    sum, with long extension |'
  prefs: []
  type: TYPE_TB
- en: '| uaddl | uaddl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane unsigned integer
    sum, with long extension |'
  prefs: []
  type: TYPE_TB
- en: '| saddl2 | saddl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed integer
    sum, with long extension |'
  prefs: []
  type: TYPE_TB
- en: '| uaddl2 | uaddl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned integer
    sum, with long extension |'
  prefs: []
  type: TYPE_TB
- en: '| saddw | saddw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane signed integer
    sum, with wide extension |'
  prefs: []
  type: TYPE_TB
- en: '| uaddw | uaddw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane unsigned integer
    sum, with wide extension |'
  prefs: []
  type: TYPE_TB
- en: '| saddw2 | saddw2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed integer
    sum, with wide extension |'
  prefs: []
  type: TYPE_TB
- en: '| uaddw2 | uaddw2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned integer
    sum, with wide extension |'
  prefs: []
  type: TYPE_TB
- en: '| addhn | addhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane addition with narrowing
    |'
  prefs: []
  type: TYPE_TB
- en: '| raddhn | raddhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane addition with
    rounding and narrowing |'
  prefs: []
  type: TYPE_TB
- en: '| addhn2 | addhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane addition with
    narrowing (uses HO bits) |'
  prefs: []
  type: TYPE_TB
- en: '| raddhn2 | raddhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane addition with
    rounding and narrowing (uses HO bits) |'
  prefs: []
  type: TYPE_TB
- en: '| shadd | shadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed addition
    with halving |'
  prefs: []
  type: TYPE_TB
- en: '| uhadd | uhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned addition
    with halving |'
  prefs: []
  type: TYPE_TB
- en: '| srhadd | srhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed addition
    with rounding and halving |'
  prefs: []
  type: TYPE_TB
- en: '| urhadd | urhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned addition
    with rounding and halving |'
  prefs: []
  type: TYPE_TB
- en: '| addp | addp Vd.t1, Vl.t1, Vr.t1 | Adds vector pairwise |'
  prefs: []
  type: TYPE_TB
- en: '| faddp | faddp Vd.t2, Vl.t2, Vr.t2 | Adds vector floating-point pairwise |'
  prefs: []
  type: TYPE_TB
- en: '| saddlp | saddlp Vd.t8, Vl.t9 | Adds vector pairwise, signed long integer
    |'
  prefs: []
  type: TYPE_TB
- en: '| uaddlp | uaddlp Vd.t8, Vl.t9 | Adds vector pairwise, unsigned long integer
    |'
  prefs: []
  type: TYPE_TB
- en: '| saddalp | saddalp Vd.t8, Vl.t9 | Adds vector pairwise and accumulates, signed
    long integer |'
  prefs: []
  type: TYPE_TB
- en: '| uaddalp | uaddalp Vd.t8, Vl.t9 | Adds vector pairwise and accumulates, unsigned
    long integer |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-9](chapter11.xhtml#tab11-9) lists the legal types for the addition
    and subtraction instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-9: Legal Types for Vector Addition and Subtraction'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, 4S, or 2D |'
  prefs: []
  type: TYPE_TB
- en: '| t2 | 2S, 4S, or 2D |'
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 8H/8B, 4S/4H, or 2D/2S |'
  prefs: []
  type: TYPE_TB
- en: '| t5/t6 | 8H/16B, 4S/8H, or 2D/4S |'
  prefs: []
  type: TYPE_TB
- en: '| t7 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  prefs: []
  type: TYPE_TB
- en: '| t8/t9 | 4H/8B, 8H/16B, 2S/4H, 4S/8H, 1D/2S, or 2D/4S |'
  prefs: []
  type: TYPE_TB
- en: The remainder of this section describes each of the addition instructions in
    [Table 11-8](chapter11.xhtml#tab11-8) in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: The add instruction, with vector register operands, does a lane-by-lane addition.
    Any overflow (signed or unsigned) is ignored, with the sum holding the LO bits
    of the result. If the type is 8B, 4H, or 2S, the add instruction adds only the
    lanes in the LO 64 bits of the registers, zeroing out the HO 64 bits of the destination
    register. [Figure 11-20](chapter11.xhtml#fig11-20) provides an example of a 16B
    lane-by-lane addition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: 16B lane-by-lane addition using add Vd.16b, Vs1.16b, Vs2.16b'
  prefs: []
  type: TYPE_NORMAL
- en: The fadd instruction, with vector register operands, adds two- or four-lane
    single-precision values together, or a pair of double-precision floating-point
    values. With 2S types, the fadd instruction clears the HO 64 bits of the destination
    register.
  prefs: []
  type: TYPE_NORMAL
- en: The sqadd and uqadd instructions do a lane-by-lane addition (signed and unsigned,
    respectively), except they saturate their results in the case of overflow (or
    underflow, when adding signed numbers). As with add, those instructions that take
    64-bit source operands produce a 64-bit result and zero out the HO 64 bits of
    the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: The saddl and uaddl instructions take the lanes in the LO 64 bits of the source
    registers, sign- or zero-extend these values to twice their size, compute the
    sum, and store the results in the full destination register (with double-sized
    lanes). The destination register type must be specified as twice the size of the
    source register types (see [Figure 11-21](chapter11.xhtml#fig11-21)). Because
    the sum of two *n*-bit numbers requires no more than *n* + 1 bits, these instructions
    will produce the correct result without any possibility of overflow or underflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: A uaddl operation (uaddl Vd.4s, Vs1.4h, Vs2.4h)'
  prefs: []
  type: TYPE_NORMAL
- en: The saddl2 and uaddl2 instructions also sign- or zero-extend the values in the
    lanes in one-half of the source register and produce a sum in the full 128 bits
    of the destination register. However, the saddl2 and uaddl2 instructions compute
    the sum of the lanes in the HO 64 bits of the source registers (see [Figure 11-22](chapter11.xhtml#fig11-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: A saddl2 operation (saddl2 Vd.4s, Vs1.8h, Vs2.8h)'
  prefs: []
  type: TYPE_NORMAL
- en: Although the saddl2 and uaddl2 instructions’ source operands are only 64 bits,
    you must specify the 128-bit types (16B, 8H, 4S) as the source type because the
    instruction retrieves the data from the upper 64 bits of a 128-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: The saddw, uaddw, saddw2, and uaddw2 instructions allow you to produce the sum
    of two operands whose sizes are different. The saddw and uaddw instructions expect
    the second source operand’s type to be half the size of the first source and the
    destination operands’ types, though you specify the same number of lanes for all
    three operands. These instructions will sign- or zero-extend (respectively) the
    lanes in the second source operand to the size of the other two, compute the sum,
    and then store the data into the destination lanes (see [Figure 11-23](chapter11.xhtml#fig11-23)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: A uaddw operation (uaddw Vd.4s, Vs1.4s, Vs2.4h)'
  prefs: []
  type: TYPE_NORMAL
- en: The saddw2 and uaddw2 instructions also sign- or zero-extend the second source
    operand, but they operate on the HO 64 bits rather than the LO 64 bits (see [Figure
    11-24](chapter11.xhtml#fig11-24)). You must specify double the number of lanes
    for the second operand so that the instruction will operate on the full 128 bits
    of the second source operand.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-24: A saddw2 operation (saddw2 Vd.4s, Vs1.4s, Vs2.4h)'
  prefs: []
  type: TYPE_NORMAL
- en: Overflow (underflow) is possible when using the saddw, uaddw, saddw2, and uaddw2
    instructions (for example, when adding 0xFFFF with 0x01). These instructions will
    ignore the overflow and keep the LO bits of the result.
  prefs: []
  type: TYPE_NORMAL
- en: The addhn (vector add with narrowing) and raddhn (vector add, round, and narrow)
    instructions add the specified lanes together, then *narrow* the result by keeping
    only the HO bits. These instructions’ destination type is half the size of the
    source types. For example, if you add half-word lanes together, the narrowing
    additions will keep only the HO byte of the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The raddhn instruction rounds the result before storing it into the destination
    register. If the LO half of the result contains a 1 in its HO bit position, raddhn
    increments the HO byte by 1; otherwise, it returns the same result as addhn. Consider
    the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If V2 contained 0x00010001 and V1 contained 0xFE7FFE7F, then V0 would contain
    0xFFFF after execution of this instruction. Had V1 contained 0xFE7EFE7E, though,
    V0 would contain 0xFEFE afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow can still occur during the execution of addhn and raddhn. Adding half
    words 0xFFFF and 0x0001 together will produce 0x00 in the corresponding destination
    byte lane.
  prefs: []
  type: TYPE_NORMAL
- en: The addhn2 and raddhn2 instructions also compute *add and narrowing* (with rounding,
    if specified); however, they store their results in the HO 64 bits of the destination
    register and leave the LO 64 bits of the destination unchanged. Because these
    instructions operate on the HO 64 bits of the destination, the destination’s lane
    count must be twice that of the source registers. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: adds the LO 8 half words of V1 and V2 and stores the HO 8-bit result of each
    lane addition into the HO 8 bytes of V0 (leaving the LO 8 bytes untouched). You
    must specify the destination register’s type as 16B, even though this instruction
    stores only 8 bytes into the register.
  prefs: []
  type: TYPE_NORMAL
- en: The shadd, uhadd, srhadd, and urhadd instructions add a pair of lanes together,
    shift right by 1 (with optional rounding, for those instructions containing an
    r), and store the result into the destination lane. As usual, the instructions
    beginning with an s handle signed values, while the instructions beginning with
    a u handle unsigned values. Because an addition of *n* bits never produces more
    than *n* + 1 bits, and a division by 2 is the same as a shift right by 1 bit,
    these instructions never produce an overflow. Consider the addition of the two
    largest single-byte values, 0xFF + 0xFF = 0x1FE. Shifting this sum to the right
    1 bit gives you 0xFF, which fits just fine into 8 bits. Even with rounding, overflow
    will not occur.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are especially handy for processing digital audio. For example,
    suppose you want to mix together two 16-bit audio tracks. Simply summing the hwords
    from the two tracks will boost the volume by 3 decibels (dB) (equivalent to doubling
    the digital value). Halving the result after the sum reduces this volume increase
    by 3 dB. The urhadd instruction would be ideal for mixing these tracks as it would
    divide the result by 2, averaging the values of the two tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.2 Pairwise Addition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thus far, all the addition operations have operated on corresponding lanes in
    the source operands, producing a result that the instructions store in the same
    lane in the destination register. This is known as a *vertical addition* because
    the data flows vertically from register to register, as shown previously in [Figure
    11-20](chapter11.xhtml#fig11-20). On occasion, you may want to produce the sum
    of adjacent elements within a vector rather than the elements in corresponding
    lanes of two vectors (horizontal addition). You can accomplish this with the *pairwise
    addition* instructions from [Table 11-8](chapter11.xhtml#tab11-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'The pairwise addition instructions, as their name suggests, add adjacent pairs
    of lanes in vectors. Because the result requires half the number of lanes that
    are present in the source, the pairwise additions produce a single vector result
    from two source registers. Consider the following example that pairwise-adds the
    half words in V1 and V2, producing the pairwise sum in V0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction computes the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: V0[0] = V2[0] + V2[1]
  prefs: []
  type: TYPE_NORMAL
- en: V0[1] = V2[2] + V2[3]
  prefs: []
  type: TYPE_NORMAL
- en: V0[2] = V1[0] + V1[1]
  prefs: []
  type: TYPE_NORMAL
- en: V0[3] = V1[2] + V1[3]
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-25](chapter11.xhtml#fig11-25) diagrams this operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-25: The addp v0.4s, v2.4s, v1.4s instruction'
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction also has a floating-point version that adds adjacent single-
    or double-precision values in a pair of vectors: faddp. For example, the following
    instruction performs the same operation as the previous addp integer example but
    adds adjacent single-precision floating-point values rather than 32-bit integer
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The addp instruction ignores any overflow during the addition. To produce a
    correct result, use the saddlp and uaddlp instruction (signed and unsigned pairwise
    add long) to sign- or zero-extend the lane values prior to the addition. The syntax
    for these two instructions is different from that of the other addition instructions:
    there are only two register operands (a source and a destination register). For
    example, because the following instruction doubles the size of the result to place
    in the destination operand and sums adjacent elements of the source operand, there
    is no need for a second register operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note that the destination register type size must be twice that of the source,
    and the number of lanes must be half that of the source.
  prefs: []
  type: TYPE_NORMAL
- en: The uaddalp and saddalp instructions are functionally similar to uaddlp and
    saddlp, but rather than simply storing the pairwise sum into the destination lanes,
    they add the sum to the value already present in the destination lanes.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.3 Vector Saturating Accumulate
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set includes two instructions that sum the lanes of a source
    vector into the corresponding lanes of a destination vector. The instructions
    are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: where t is 8B, 4H, or 2S when operating on the LO 64 bits of the registers,
    or 16B, 8H, 4S, or 2D when operating on all 128 bits. The 64-bit variants will
    clear the HO 64 bits of Vd.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are unusual in that they allow you to add (with saturation)
    an unsigned input into a signed value or add a signed number into an unsigned
    value (usually instructions operate on only one type of data).
  prefs: []
  type: TYPE_NORMAL
- en: The usqadd instruction adds a signed value in the source lanes to the unsigned
    value in the corresponding destination lanes. Should the sum exceed the maximum
    (unsigned) value for the destination lane’s size, this instruction will saturate
    the lane to the maximum value. Should the sum go negative, this instruction saturates
    the destination lane to 0\. For example, if a half-word destination lane contains
    0xFFF0 and the corresponding source lane contains 0xFF, the usqadd instruction
    (with a 4H or 8H type) will produce 0xFFFF in the destination lane. On the other
    hand, if the destination lane contains 0x08 and the source lane contains 0xFFF0
    (–16), then their sum will produce 0 in the destination lane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suqadd instruction is the converse operation: it adds an unsigned source
    operand to a signed destination operand, saturating to the maximum signed value.
    For example, if a destination half-word lane contains 0x7FF0 and the corresponding
    source lane contains 0x00FF, their sum will produce 0x7FFF, the maximum signed
    value. Note that if the destination operand contains 0xFFFF (–1) and the source
    operand is 0x0002, you wind up with 0x0001 in the destination lane (–1 + 2 = 1).'
  prefs: []
  type: TYPE_NORMAL
- en: The usqadd and suqadd instructions also have scalar variants
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are one of the scalar registers Bn, Hn, Sn, or Dn.
  prefs: []
  type: TYPE_NORMAL
- en: The suqadd instruction will always produce the maximum signed value when overflowing,
    as you can’t reduce the value by adding an unsigned number to it.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.4 Horizontal Add
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The addv (add across vector) instruction produces the sum of all the lanes in
    a single source vector register and leaves the result in a scalar element of another
    vector register (this is known as *reduction*). The syntax for this instruction
    is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: where R is the destination register and is one of B*n*, H*n*, or S*n*. The legal
    vector register type and lane count depend on the scalar register; [Table 11-10](chapter11.xhtml#tab11-10)
    lists the valid types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-10: Valid Vector Register Types for addv'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scalar register (Rd) | Valid lane count and types |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bd | 8B or 16B |'
  prefs: []
  type: TYPE_TB
- en: '| Hd | 4H or 8H |'
  prefs: []
  type: TYPE_TB
- en: '| Sd | 4S |'
  prefs: []
  type: TYPE_TB
- en: This instruction is useful for summing up the elements of an array. Unfortunately,
    the destination scalar type must be the same as the source lanes’ type, and any
    overflow is ignored. There is no instruction that will zero- or sign-extend the
    sum to a double-sized result. Therefore, it’s advisable to zero- or sign-extend
    the vector elements to the next larger size prior to executing addv if overflow
    is possible. You can accomplish this by using the saddlp or uaddlp instruction
    to add adjacent pairs and sign- or zero-extend (respectively), then use the addv
    instruction to sum the resulting double-sized lanes.
  prefs: []
  type: TYPE_NORMAL
- en: The addvl instruction is part of the ARM *scalable vector extensions (SVE)*,
    which are beyond the scope of this book. While you might expect addvl to be a
    long version of the addv instruction, it actually does something completely different.
    See the ARM SVE documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.5 Scalar Saturating and Scalar Pairwise Addition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set also provides a couple of saturating scalar addition
    instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: where R represents one of the scalar register names B, H, S, or D. These instructions
    operate on the 8-, 16-, 32-, or 64-bit signed or unsigned integer values found
    in the LO bits of the specified V register (see [Figure 11-2](chapter11.xhtml#fig11-2)
    for the correspondence between the V*n*, B*n*, H*n*, S*n*, and D*n* registers).
    These instructions do the same thing as their vector counterparts, except, of
    course, they operate only on a scalar value rather than doing a lane-by-lane vector
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the scalar variants of the addp and faddp instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note the limited lane count and type support of these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The addp instruction ignores (discards) any overflow from the addition of the
    two dword elements from the source vector. The addpl and addpl2 instructions have
    no scalar versions. Use the actual addpl and addpl2 instructions (with a second
    vector containing 0s) if you need an extended-precision version of this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.2 Subtraction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While there aren’t quite as many Neon instructions for subtraction as there
    are for addition, most of the addition instructions have a subtraction complement.
    [Table 11-11](chapter11.xhtml#tab11-11) provides the syntax for the various vector
    subtraction instructions and associated data types; these instructions generally
    compute Vd = Vl *–* Vr (exceptions as noted), where Vd = destination, Vl = left
    operand, and Vr = right operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-11: Neon Subtraction Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sub | sub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane integer difference
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsub | fsub Vd.t2, Vl.t2, Vr.t2 | Computes lane-by-lane floating-point difference
    |'
  prefs: []
  type: TYPE_TB
- en: '| uqsub | uqsub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane unsigned integer
    subtraction with saturation |'
  prefs: []
  type: TYPE_TB
- en: '| sqsub | sqsub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane signed integer
    subtraction with saturation |'
  prefs: []
  type: TYPE_TB
- en: '| usubl | usubl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane unsigned long integer
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| ssubl | ssubl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane signed long integer
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| usubl2 | usubl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned long
    integer subtraction of the HO half of Vr |'
  prefs: []
  type: TYPE_TB
- en: '| ssubl2 | ssubl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed long integer
    subtraction of the HO half of Vr |'
  prefs: []
  type: TYPE_TB
- en: '| usubw | usubw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane unsigned wide integer
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| ssubw | ssubw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane signed wide integer
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| usubw2 | usubw2 Vd.t5, Vl.t4, Vr.t6 | Computes lane-by-lane unsigned wide
    integer subtraction involving the upper half of Vl |'
  prefs: []
  type: TYPE_TB
- en: '| ssubw2 | ssubw2 Vd.t5, Vl.t5, Vr.t6 | Computes lane-by-lane signed wide integer
    subtraction involving the upper half of Vl |'
  prefs: []
  type: TYPE_TB
- en: '| subhn | subhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane subtraction with
    narrowing |'
  prefs: []
  type: TYPE_TB
- en: '| rsubhn | rsubhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane subtraction with
    rounding and narrowing |'
  prefs: []
  type: TYPE_TB
- en: '| subhn2 | subhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane subtraction with
    narrowing (uses HO bits) |'
  prefs: []
  type: TYPE_TB
- en: '| rsubhn2 | rsubhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane subtraction
    with rounding and narrowing (uses HO bits) |'
  prefs: []
  type: TYPE_TB
- en: '| uhsub | uhsub Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned subtraction
    with halving |'
  prefs: []
  type: TYPE_TB
- en: '| shsub | shsub Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed subtraction
    with halving |'
  prefs: []
  type: TYPE_TB
- en: The behavior of these instructions is very similar to their addition counterparts,
    except, of course, that they subtract the values in the lanes rather than adding
    them. See the previous section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a saturating scalar subtraction instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: That subtracts the two source scalar registers (B*n*, H*n*, S*n*, or D*n*),
    producing a scalar result.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.3 Absolute Difference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the normal subtraction instructions, the Neon instruction set
    includes several instructions that compute the difference of the values in corresponding
    lanes and then compute the absolute value of this difference. These instructions
    are handy for computing distances and other vector (as in physics) calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-12](chapter11.xhtml#tab11-12) lists the available absolute difference
    instructions. In the Syntax column, Vd = destination, Vl = left operand, and Vr
    = right operand. Each instruction generally computes Vd = abs(Vl *–* Vr), unless
    otherwise noted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-12: Neon Absolute Difference Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| uabd | uabd Vd.t1, Vl.t1, Vr.t1 | Vector unsigned absolute difference; lanes
    contain unsigned values. |'
  prefs: []
  type: TYPE_TB
- en: '| sabd | sabd Vd.t1, Vl.t1, Vr.t1 | Vector signed absolute difference; lanes
    contain signed values. |'
  prefs: []
  type: TYPE_TB
- en: '| uaba | uaba Vd.t1, Vl.t1, Vr.t1 | Vector unsigned absolute difference and
    accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values. |'
  prefs: []
  type: TYPE_TB
- en: '| saba | saba Vd.t1, Vl.t1, Vr.t1 | Vector signed absolute difference and accumulate;
    Vd = Vd + abs(Vl – Vr), where lanes contain signed values. |'
  prefs: []
  type: TYPE_TB
- en: '| uabdl | uabdl Vd.t2, Vl.t3, Vr.t3 | Vector unsigned absolute difference long;
    lanes contain unsigned values. |'
  prefs: []
  type: TYPE_TB
- en: '| sabdl | sabdl Vd.t2, Vl.t3, Vr.t3 | Vector signed absolute difference long;
    lanes contain signed values. |'
  prefs: []
  type: TYPE_TB
- en: '| uabal | uabal Vd.t2, Vl.t3, Vr.t3 | Vector unsigned absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values. |'
  prefs: []
  type: TYPE_TB
- en: '| sabal | sabal Vd.t2, Vl.t3, Vr.t3 | Vector signed absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain signed values. |'
  prefs: []
  type: TYPE_TB
- en: '| uabdl2 | uabdl2 Vd.t4, Vl.t5, Vr.t5 | Vector unsigned absolute difference
    long; lanes contain unsigned values. Uses HO 64 bits of Vl and Vr. |'
  prefs: []
  type: TYPE_TB
- en: '| sabdl2 | sabdl2 Vd.t4, Vl.t5 Vr.t5 | Vector signed absolute difference long;
    lanes contain signed values. Uses HO 64 bits of Vl and Vr. |'
  prefs: []
  type: TYPE_TB
- en: '| uabal2 | uabal2 Vd.t4, Vl.t5, Vr.t5 | Vector unsigned absolute difference
    long and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values.
    Uses HO 64 bits of Vl and Vr. |'
  prefs: []
  type: TYPE_TB
- en: '| sabal2 | sabal2 Vd.t4, Vl.t5, Vr.t5 | Vector signed absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain signed values. Uses
    HO 64 bits of Vl and Vr. |'
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Vd.t6, Vl.t6, Vr.t6 | Vector floating-point absolute difference;
    lanes contain floating-point values. |'
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Sd, Sl, Sr | Scalar single-precision floating-point absolute
    difference; Sd = abs(Sl – Sr). |'
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Dd, Dl, Dr | Scalar double-precision floating-point absolute
    difference; Dd = abs(Dl – Dr). |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-13](chapter11.xhtml#tab11-13) lists the legal types for the absolute
    difference instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-13: Legal Types for Absolute Difference Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  prefs: []
  type: TYPE_TB
- en: '| t2/t3 | 8H/8B, 4S/4H, or 2D/2S |'
  prefs: []
  type: TYPE_TB
- en: '| t4/t5 | 8H/16B, 4S/8H, or 2D/4S |'
  prefs: []
  type: TYPE_TB
- en: '| t6 | 2S, 4S, or 2D |'
  prefs: []
  type: TYPE_TB
- en: The uabd and sabd instructions compute the difference of each lane, take the
    absolute value of the difference, and store the result into the destination lane.
    Although the two instructions operate on unsigned and signed source operands (respectively),
    the result is always an unsigned value. Effectively, these are just variants of
    the sub instruction that take the absolute value of the result. As long as you
    treat the result as an unsigned number (particularly in the case of the sabd instruction),
    these instructions will not produce an overflow (underflow).
  prefs: []
  type: TYPE_NORMAL
- en: The uaba and saba instructions add the absolute value of the difference to the
    corresponding lane in the destination register. If an overflow occurs (on the
    addition), these instructions store the LO bits (the lane size) into the corresponding
    destination lane. For signed operations, if Vl contains the most negative value
    (for example, 0x80 for a byte) and Vr contains 0, overflow occurs and the instruction
    winds up adding that most negative value to the destination lane.
  prefs: []
  type: TYPE_NORMAL
- en: The suffix-l and suffix-l2 variants of these instructions compute a long calculation.
    The uabdl and sabdl instructions first zero- or sign-extend (respectively) the
    lane values to twice the lanes’ size, then compute the absolute value of the difference
    and store the result into the corresponding double-sized lane. The uabdl2 and
    sabdl2 instructions do the same thing but grab the lane data from the HO 64 bits
    of the source operands (refer back to [Figures 11-21](chapter11.xhtml#fig11-21)
    and [11-22](chapter11.xhtml#fig11-22) and substitute the appropriate instruction
    to see how this works).
  prefs: []
  type: TYPE_NORMAL
- en: The fabd instruction computes the absolute difference of two floating-point
    values. With vector register operands, it processes two double-precision or four
    single-precision floating-point values at a time. This instruction also supports
    scalar operations (single- or double-precision) by specifying the D*n* or S*n*
    registers as operands. Unfortunately, there is no floating-point absolute difference
    and accumulate instruction. You can simulate this instruction by following an
    fabd instruction with an fadd instruction (using a spare vector register to hold
    the temporary result from fabd).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4 Vector Multiplication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set includes several instructions that compute the product
    of corresponding lanes in the vector register (both integer and floating-point
    products). The standard vector multiply instructions appear in [Table 11-14](chapter11.xhtml#tab11-14).
    Note that Vl is the left source operand and Vr is the right source operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-14: Neon Vector Multiply Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mul | mul Vd.t1, Vl.t1, Vr.t1 | Multiplication: Vd = Vl × Vr. Ignores overflow,
    keeps LO bits of result (lane by lane). |'
  prefs: []
  type: TYPE_TB
- en: '| mla | mla Vd.t1, Vl.t1, Vr.t1 | Multiply and accumulate: Vd = Vd + Vl × Vr.
    Ignores overflow, keeps LO bits of result (lane by lane). |'
  prefs: []
  type: TYPE_TB
- en: '| mls | mls Vd.t1, Vl.t1, Vr.t1 | Multiply and subtract: Vd = Vd − Vl × Vr.
    Ignores overflow, keeps LO bits of result (lane by lane). |'
  prefs: []
  type: TYPE_TB
- en: '| smull | smull Vd.t2, Vl.t3, Vr.t3 | Signed extended multiplication: Vd =
    Vl × Vr. Multiplies LO half of Vl by Vr and stores extended-precision result in
    the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| umull | umull Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiplication: Vd
    = Vl × Vr. Multiplies LO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| smull2 | smull2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiplication: Vd
    = Vl × Vr. Multiplies HO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| umull2 | umull2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiplication: Vd
    = Vl × Vr. Multiplies HO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| smlal | smlal Vd.t2, Vl.t3, Vr.t3 | Signed extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies LO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| umlal | umlal Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies LO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| smlal2 | smlal2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies HO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| umlal2 | umlal2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies HO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  prefs: []
  type: TYPE_TB
- en: '| smlsl | smlsl Vd.t2, Vl.t3, Vr.t3 | Signed extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies LO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  prefs: []
  type: TYPE_TB
- en: '| umlsl | umlsl Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies LO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  prefs: []
  type: TYPE_TB
- en: '| smlsl2 | smlsl2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies HO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  prefs: []
  type: TYPE_TB
- en: '| umlsl2 | umlsl2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies HO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply: Vd = Vl × Vr.
    Multiplies the floating-point values in the Vl and Vr lanes and stores the product
    into the corresponding Vd lanes (lane by lane). |'
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply: Vd = Vl × Vr.
    Multiplies the floating-point values in the Vl and Vr lanes and stores the product
    into the corresponding Vd lanes (lane by lane). This variant handles the case
    where one source operand is 0 and the other is ±∞, producing the value ±2 (–2
    if –∞, +2 otherwise). |'
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply and accumulate:
    Vd = Vd + Vl × Vr (lane by lane). |'
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply and subtract: Vd
    = Vd – Vl × Vr (lane by lane). |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-15](chapter11.xhtml#tab11-15) lists the legal types for the instructions
    appearing in [Table 11-14](chapter11.xhtml#tab11-14).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-15: Legal Types for Vector Multiply Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, or 4S | 8B, 4S, and 2S operate only on LO 64 bits.
    |'
  prefs: []
  type: TYPE_TB
- en: '| t2/t3 | 8H/8B, 4S/4H, or 2D/2S | t3 lanes are taken from the LO 64 bits.
    |'
  prefs: []
  type: TYPE_TB
- en: '| t4/t5 | 8H/16B, 4S/8H, or 2D/4S | t5 lanes are taken from the HO 64 bits.
    |'
  prefs: []
  type: TYPE_TB
- en: '| t6 | 2S, 4S, or 2D |  |'
  prefs: []
  type: TYPE_TB
- en: There are also pmul, pmull, and pmull2 (polynomial multiplication) instructions.
    However, polynomial multiplication isn’t a traditional multiply operation, and
    a discussion of this is beyond the scope of this book. See the Arm documentation
    for more details on these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.1 Vector Saturating Multiplication and Double
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The vector saturating multiplication and double instructions build on the standard
    multiply, multiply and accumulate, and multiply and subtract instructions to produce
    an extended precision (long) result that doubles the product and saturates the
    result. The instructions in this set appear in [Table 11-16](chapter11.xhtml#tab11-16)
    and compute Vd = saturate({Vd ±}(Vl × Vr) × 2), where Vd is the destination operand,
    Vl is the left operand, and Vr is the right operand; {Vd ±} indicates that Vd
    ± is an optional source operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-16: Vector Multiply and Double with Saturation Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmull | sqdmull Vd.t1, Vl.t2, Vr.t2 | Vd = (Vl × Vr) × 2 (lane by lane)
    |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal | sqdmlal Vd.t1, Vl.t2, Vr.t2 | Vd = Vd + (Vl × Vr) × 2 (lane by
    lane) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl | sqdmlsl Vd.t1, Vl.t2, Vr.t2 | Vd = Vd − (Vl × Vr) × 2 (lane by
    lane) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmull2 | sqdmull2 Vd.t3, Vl.t4, Vr.t4 | Vd = (Vl × Vr) × 2 (lane by lane,
    HO 64 bits of source) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal2 | sqdmlal2 Vd.t3, Vl.t4, Vr.t4 | Vd = Vd + (Vl × Vr) × 2 (lane by
    lane, HO 64 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl2 | sqdmlsl2 Vd.t3, Vl.t4, Vr.t4 | Vd = Vd – (Vl × Vr) × 2 (lane by
    lane, HO 64 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmull | sqdmull Vd.t5, Vl.t6, Vr.t7[x] | Vd = (Vl × Vr) × 2 (Vl lanes ×
    Vr[x] scalar) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal | sqdmlal Vd.t5, Vl.t6, Vr.t7[x] | Vd = Vd + (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl | sqdmlsl Vd.t5, Vl.t6, Vr.t7[x] | Vd = Vd – (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmull2 | sqdmull2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar, HO 64 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal2 | sqdmlal2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = Vd + (Vl × Vr) × 2 (Vl
    lanes × Vr[x] scalar, HO 64 bits) |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl2 | sqdmlsl2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = Vd – (Vl × Vr) × 2 (Vl
    lanes × Vr[x] scalar, HO 64 bits) |'
  prefs: []
  type: TYPE_TB
- en: The legal types and lane counts appear in [Table 11-17](chapter11.xhtml#tab11-17).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-17: Legal Types and Lane Counts for Vector Multiply and Double with
    Saturation'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types and lane counts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4S/4H, or 2D/2S |'
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 4S/8H, or 2D/4S |'
  prefs: []
  type: TYPE_TB
- en: '| t5/t6/t7 | 4S/4H/H, or 2D/2S/S |'
  prefs: []
  type: TYPE_TB
- en: '| t8/t9/t10 | 4S/8H/H, or 2D/4S/S |'
  prefs: []
  type: TYPE_TB
- en: These instructions all sign-extend their source operands to twice their size
    and multiply them to produce a product. They then multiply this product by 2\.
    The standard multiply variants saturate and store this product into the corresponding
    destination lane. The multiply and accumulate variants add the product (multiplied
    by 2) to the destination and saturate the result. The multiply and subtract variants
    subtract the product (multiplied by 2) from the destination and saturate the result.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions without a 2 suffix extract their lanes from the LO 64 bits
    of the first source register, while those with a 2 suffix extract their lanes
    from the HO 64 bits of the second source register.
  prefs: []
  type: TYPE_NORMAL
- en: The last six instructions in [Table 11-16](chapter11.xhtml#tab11-16) multiply
    the lanes in Vl by a scalar value selected from one of the lanes in Vr (selected
    by the [x] index operator). Here, x must be an appropriate value for the source
    type (0 to 7 for bytes, 0 to 3 for half words, or 0 to 1 for words). For the last
    six forms, if t10 is H, then the Vr register number (r) must be in the range 0
    to 15.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of “short” versions of the sqdmul* instructions don’t double the type
    size in the destination register: sqdmulh and sqrdmulh. These instructions also
    multiply their source operands, double the result, and saturate it. However, they
    store only the HO 64 bits of the result into the destination lane (with saturation
    and possible rounding). [Table 11-18](chapter11.xhtml#tab11-18) lists these instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-18: Saturating Multiply and Double Instructions, HO Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Vd.t1, Vl.t1, Vr.t1 | Lane-by-lane multiply, double, saturate,
    and keep HO half of product. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Vd.t1, Vl.t1, Vr.t1 | Lane-by-lane multiply, double,
    round, saturate, and keep HO half of product. |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Vd.t2, Vl.t3, Vr.t4[x] | Multiply the lanes in Vl by the
    scalar selected by Vr[x]; double the result, saturate, and keep the HO half of
    the product. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Vd.t2, Vl.t3, Vr.t4[x] | Multiply the lanes in Vl by
    the scalar selected by Vr[x]; double the result, round, saturate, and keep the
    HO half of the product. |'
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Rd, Rl, Rr | Scalar version of sqdmulh. |'
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Rd, Rl, Rr | Scalar version of sqrdmulh. |'
  prefs: []
  type: TYPE_TB
- en: In this table, t1 is 4H, 8H, 2S, or 4S. For the 4H and 2S types, the instruction
    works only with the LO 64 bits of the registers; the 8H and 4S types use all 128
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: The type specification t2/t3/t4 is 4H/4H/H, 8H/8H/H, 2S/2S/S, or 4S/S; the 4H
    and 2S types work with the LO 64 bits of the registers, and the 8H and 4S types
    work on all 128 bits of the registers. If the type is H, Vr’s register number
    must be in the range 0 to 15.
  prefs: []
  type: TYPE_NORMAL
- en: If the [x] index appears after Vr*.*t4, the instruction multiplies the lanes
    in Vl by the scalar value extracted from lane x of Vr, which must be an appropriate
    value for the source type (0 to 7 for bytes, 0 to 3 for half words, or 0 to 1
    for words).
  prefs: []
  type: TYPE_NORMAL
- en: These instructions have two scalar variants. R (in Rd, Rl, and Rr) must be H
    or S. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: computes H0 = saturate(H1 × H2 × 2).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.2 Vector Multiplication by a Scalar Element
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions that multiply all the
    elements of a vector by a single scalar value, as listed in [Table 11-19](chapter11.xhtml#tab11-19).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-19: Vector Multiply by Scalar Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mul | mul Vd.t1, Vl.t1, Vr.t2[x] | Multiply integer vector element by scalar
    value. Multiply each lane in Vl by Vr[x] (scalar value) and store the product
    into the corresponding lane in Vd (that is, for each lane i, Vd[i] = Vl[i] × Vr[x]).
    |'
  prefs: []
  type: TYPE_TB
- en: '| mla | mla Vd.t1, Vl.t1, Vr.t2[x] | Multiply vector elements by a scalar and
    accumulate. For each lane i, Vd[i] = Vd[i] + Vl[i] × Vr[x]. |'
  prefs: []
  type: TYPE_TB
- en: '| mls | mls Vd.t1, Vl.t1, Vr.t2[x] | Multiply vector elements by a scalar and
    subtract. For each Iane i, Vd[i] = –d[i] – Vl[i] × Vr[x]. |'
  prefs: []
  type: TYPE_TB
- en: '| smull | smull Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar,
    long. Sign-extend the (LO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the LO 64 bits
    of Vl. |'
  prefs: []
  type: TYPE_TB
- en: '| smlal | smlal Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar and
    accumulate, long. Similar to smull, but sums the product into Vd rather than just
    storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| smlsl | smlsl Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar and
    subtract, long. Similar to smull, but subtracts the product from Vd rather than
    just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| smull2 | smull2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar,
    long. Sign-extend the (HO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the HO 64 bits
    of Vl. |'
  prefs: []
  type: TYPE_TB
- en: '| smlal2 | smlal2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar
    and accumulate, long (HO source). Similar to smull2, but sums the product into
    Vd rather than just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| smlsl2 | smlsl2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar
    and subtract, long (HO source). Similar to smull2, but subtracts the product from
    Vd rather than just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| umull | umull Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar,
    long. Zero-extend the (LO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the LO 64 bits
    of Vl. |'
  prefs: []
  type: TYPE_TB
- en: '| umlal | umlal Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar
    and accumulate, long. Similar to umull, but sums the product into Vd rather than
    just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| umlsl | umlsl Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar
    and subtract, long. Similar to umull, but subtracts the product from Vd rather
    than just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| umull2 | umull2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar,
    long. Zero-extend the (HO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the HO 64 bits
    of Vl. |'
  prefs: []
  type: TYPE_TB
- en: '| umlal2 | umlal2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar
    and accumulate, long (HO source). Similar to umull2, but sums the product into
    Vd rather than just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| umlsl2 | umlsl2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar
    and subtract, long (HO source). Similar to umull2, but subtracts the product from
    Vd rather than just storing it into Vd. |'
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar. Multiply each lane in Vl by Vr[x] (scalar value) and store the product
    into the corresponding lane in Vd (that is, for each lane i, Vd[i] = Vl[i] × Vr[x]).
    |'
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Vd.t9, Vl.t10, Vr.t11[x] | Like fmul, except it’s a special
    variant that handles the case where one source operand is 0 and the other is ±∞.
    This produces the value ±2 (–2 if –∞, +2 otherwise). |'
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar and accumulate. Multiply each lane in Vl by Vr[x] (scalar value) and add
    the product into the corresponding lane in Vd (that is, for each lane i, Vd[i]
    = Vd[i] + Vl[i] × Vr[x]). |'
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar and subtract. Multiply each lane in Vl by Vr[x] (scalar value) and subtract
    the product from the corresponding lane in Vd (that is, for each lane i, Vd[i]
    = Vd[i] – Vl[i] × Vr[x]). |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-20](chapter11.xhtml#tab11-20) lists the legal types and lane counts
    for the instructions in [Table 11-19](chapter11.xhtml#tab11-19).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-20: Legal Types and Lane Counts for Vector Multiply by Scalar'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types and lane counts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4H/H, 8H/H, 2S/S, or 4S/S |'
  prefs: []
  type: TYPE_TB
- en: '| t3/t4/t5 | 4S/4H/H or 2D/2S/S |'
  prefs: []
  type: TYPE_TB
- en: '| t6/t7/t8 | 4S/8H/H, or 2D/4S/S |'
  prefs: []
  type: TYPE_TB
- en: '| t9/t10/t11 | 2S/2S/S, 4S/S, or 2D/D |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 11-26](chapter11.xhtml#fig11-26) shows the basic operation of the mul,
    mla, mls, fmul, fmla, and fmls instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-26: Vector multiply by scalar operation'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-27](chapter11.xhtml#fig11-27) shows the basic operation of the smull,
    umull, smlal, umlal, smlsl, and umlsl instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-27: Vector multiply by scalar, long (LO bits)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-28](chapter11.xhtml#fig11-28) shows the basic operation of the smull2,
    umull2, smlal2, umlal2, smlsl2, and umlsl2 instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-28: Vector multiply by scalar, long (HO bits)'
  prefs: []
  type: TYPE_NORMAL
- en: Because the product of two *n*-bit numbers fits into 2*n* bits, the smul/smul2
    and umul/umul2 instructions will not produce an overflow. However, keep in mind
    that an addition or subtraction after the multiplication could require an additional
    bit (2*n* + 1 bits). Should that occur, these instructions will ignore the overflow
    and keep the LO bits.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.3 Scalar Multiplication by a Vector Element
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides variants of the fmul instructions that multiply
    a scalar register (Sn or Dn) by a vector element (Vn[x]), storing the result back
    into a scalar register. [Table 11-21](chapter11.xhtml#tab11-21) lists the syntax
    for these instructions, where Fl is the left source operand and Vr is the right
    source operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-21: Floating-Point Scalar Multiplication by Vector Element Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Fd, Fl, Vr.t[x] | Fd = Fl × Vr.t[x] |'
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Fd, Fl, Vr.t[x] | Fd = Fl × Vr.t[x]. Handles case where Fl
    = 0.0 and Vr.t is ±∞, which produces ±2.0. |'
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Fd, Fl, Vr.t[x] | Fd = Fd + Fl × Vr.t[x] |'
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Fd, Fl, Vr.t[x] | Fd = Fd – Fl × Vr.t[x] |'
  prefs: []
  type: TYPE_TB
- en: Registers Fd and Fl are each one of the scalar floating-point registers (Sn
    or Dn). Type t must be a matching size (S or D). If the type is single-precision
    (Sn), then Vr must be a register in the range V0 to V15.
  prefs: []
  type: TYPE_NORMAL
- en: These multiplication instructions have no integer equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.5 Vector Division
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set does not provide any instructions to perform integer
    division on vectors. It does, however, provide an instruction to perform floating-point
    division on lanes in a pair of vectors
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: where t is 2S, 4S, or 2D. (A division by zero produces NaN in the destination
    lane.)
  prefs: []
  type: TYPE_NORMAL
- en: Because floating-point division is rather slow, especially when iterated over
    all the lanes, the Neon instruction set includes a pair of instructions that will
    compute the reciprocal of a floating-point value. Multiplication by a reciprocal
    is usually much faster than division. If you’re dividing by a constant, you can
    precompute the reciprocal value at assembly time and use that (no runtime cost).
    If the value is a variable that you cannot compute at assembly time, you can use
    the frecpe instruction to *approximate* the reciprocals of all the lanes in a
    vector register
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: where t is 2S, 4S, or 2D (2S operates on the LO 64 bits of the registers).
  prefs: []
  type: TYPE_NORMAL
- en: There is a scalar version of frecpe
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are either S*n* or D*n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frecpe instruction produces a reciprocal approximation that is within 8
    bits of the correct value—not great, but good enough for quick-and-dirty calculations.
    If you need better accuracy, use the frecps instruction (same syntax except for
    the mnemonic) to compute another step in the Newton-Raphson reciprocal approximation
    algorithm, using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The more times you repeat the refinement step, the more accurate your result
    will be. However, at some point, the cost of executing all these floating-point
    instructions will exceed the time consumed by a single fdiv instruction, so take
    care because using frecps has diminishing returns.
  prefs: []
  type: TYPE_NORMAL
- en: There is a urecpe instruction for estimating fixed-point reciprocals, but fixed-point
    arithmetic is beyond this scope of this book. To learn more, see the ARM Architecture
    Reference Manual, linked in section 11.15, “For More Information,” on [page 700](chapter11.xhtml#pg_700).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.6 Sign Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set includes four instructions that allow you to negate
    or take the absolute values of the lanes in a vector register
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: where t1 represents the usual integer types (8B, 16B, 4H, 8H, 2S, 4S, or 2D)
    and t2 represents the usual floating-point types (2S, 4S, and 2D). The 8B, 4H,
    and 2S types reference only the LO 64 bits of the vector register.
  prefs: []
  type: TYPE_NORMAL
- en: The abs and fabs instructions compute the absolute values of each of the lanes
    in the source register, storing the result into the destination register. Obviously,
    abs works on (signed) integer values, while fabs works on floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: The neg and fneg instruction negate (change the sign of) the source lanes, leaving
    the negated result in the corresponding destination lane. As expected, neg works
    on signed integers, and fneg works on floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: The sqabs and sqneg instructions are special saturating variants of the abs
    and neg instructions that never overflow. The most negative value (for example,
    0x80 for byte values) will overflow when you take its absolute value or negate
    it; in both cases, you wind up with the same value. The sqabs and sqneg instruction
    will produce the maximum positive value (for example, 0x7F for byte values) if
    you attempt to negate it or take its absolute value.
  prefs: []
  type: TYPE_NORMAL
- en: The abs, neg, sqabs, and sqneg instructions also have scalar versions, as shown
    in [Table 11-22](chapter11.xhtml#tab11-22). For abs and neg, Rd and Rs can be
    only Dn; for sqabs and sqneg, Rd and Rs are one of the scalar registers Bn, Hn,
    Sn, or Dn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-22: Scalar Sign Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| abs | abs Rd, Rs | Rd = abs(Rs) |'
  prefs: []
  type: TYPE_TB
- en: '| neg | neg Rd, Rs | Rd = –Rs |'
  prefs: []
  type: TYPE_TB
- en: '| sqabs | sqabs Rd, Rs | Rd = abs(Rs), saturated to maximum signed value |'
  prefs: []
  type: TYPE_TB
- en: '| sqneg | sqneg Rd, Rs | Rd = –Rs, saturated to signed range |'
  prefs: []
  type: TYPE_TB
- en: The instructions in [Table 11-22](chapter11.xhtml#tab11-22) operate on the scalar
    value in the specified register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7 Minimum and Maximum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions that will select the
    minimum or maximum value from corresponding lanes in two vector registers and
    store that value into the corresponding lane of a destination register, as shown
    in [Table 11-23](chapter11.xhtml#tab11-23).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-23: Vector Min and Max Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| smin | smin Vd.t1, Vl.t1, Vr.t1 | Vd = min(Vl, Vr) (signed integer values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| smax | smax Vd.t1, Vl.t1, Vr.t1 | Vd = max(Vl, Vr) (signed integer values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| umin | umin Vd.t1, Vl.t1, Vr.t1 | Vd = min(Vl, Vr) (unsigned integer values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| umax | umax Vd.t1, Vl.t1, Vr.t1 | Vd = max(Vl, Vr) (unsigned integer values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fmin | fmin Vd.t2, Vl.t2, Vr.t2 | Vd = min(Vl, Vr) (floating-point values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fmax | fmax Vd.t2, Vl.t2, Vr.t2 | Vd = max(Vl, Vr) (floating-point values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fminnm | fminnm Vd.t2, Vl.t2, Vr.t2 | Vd = min(Vl, Vr) (floating-point values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxnm | fmaxnm Vd.t2, Vl.t2, Vr.t2 | Vd = max(Vl, Vr) (floating-point values)
    |'
  prefs: []
  type: TYPE_TB
- en: In this table, t1 must be 8B, 16B, 4H, 8H, 2S, or 4S. If t1 is 8B, 4H, or 2S,
    the instructions operate only on the lanes in the LO 64 bits of the vector registers;
    if it is 16B, 8H, or 4S, the instructions operate on all 128 bits of the vector
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: The type t2 must be 2S, 4S, or 2D. If it is 2S, the instructions operate only
    on the LO 64 bits of the vector registers; otherwise, they operate on the entire
    128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The fmin and fmax instructions return NaN if either (or both) of the corresponding
    source lanes contain a NaN. The fminnm and fmaxnm instructions, on the other hand,
    return the numeric value if one lane contains a valid number and the other contains
    a NaN. If both lanes contain a valid floating-point value, all four instructions
    behave the same and return the minimum or maximum value (as appropriate).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.1 Pairwise Minimum and Maximum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The minimum and maximum instructions also have pairwise variants, as shown in
    [Table 11-24](chapter11.xhtml#tab11-24), where t1 and t2 are the same as for the
    lane-by- lane instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-24: Pairwise Minimum and Maximum Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description | Operates on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sminp | sminp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_min(Vl, Vr) | Signed integers
    |'
  prefs: []
  type: TYPE_TB
- en: '| smaxp | smaxp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_max(Vl, Vr) | Signed integers
    |'
  prefs: []
  type: TYPE_TB
- en: '| uminp | uminp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_min(Vl, Vr) | Unsigned
    integers |'
  prefs: []
  type: TYPE_TB
- en: '| umaxp | umaxp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_max(Vl, Vr) | Unsigned
    integers |'
  prefs: []
  type: TYPE_TB
- en: '| fminp | fminp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_min(Vl, Vr) | Floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxp | fmaxp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_max(Vl, Vr) | Floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| fminnmp | fminnmp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_min(Vl, Vr) | Floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmp | fmaxnmp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_max(Vl, Vr) | Floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: The pairwise topology is the same as for the addp instruction (see [Figure 11-29](chapter11.xhtml#fig11-29)
    for a uminp example).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-29: Pairwise minimum and maximum operations'
  prefs: []
  type: TYPE_NORMAL
- en: There are also a set of pairwise-scalar floating-point minimum and maximum instructions,
    as shown in [Table 11-25](chapter11.xhtml#tab11-25), where Rd/t must be Sn/2S
    or Dn/2D.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-25: Pairwise-Scalar Floating-Point Minimum and Maximum Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxp | fmaxp Rd, Vs.t | Rd = max(Vs) |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmp | fmaxnmp Rd, Vs.t | Rd = max(Vs) (choose number over NaN) |'
  prefs: []
  type: TYPE_TB
- en: '| fminp | fminp Rd, Vs.t | Rd = min(Vs) |'
  prefs: []
  type: TYPE_TB
- en: '| fminnmp | fminnmp Rd, Vs.t | Rd = min(Vs) (choose number over NaN) |'
  prefs: []
  type: TYPE_TB
- en: These instructions have no integer versions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.2 Horizontal Minimum and Maximum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The horizontal minimum and maximum instructions select the minimum or maximum
    value within a single vector, as shown in [Table 11-26](chapter11.xhtml#tab11-26).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-26: Horizontal (Across Vector) Minimum and Maximum Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sminv | sminv Rd, Vs.t1 | Extract minimum signed lane value from Vs and store
    into Rd. |'
  prefs: []
  type: TYPE_TB
- en: '| smaxv | smaxv Rd, Vs.t1 | Extract maximum signed lane value from Vs and store
    into Rd. |'
  prefs: []
  type: TYPE_TB
- en: '| uminv | uminv Rd, Vs.t1 | Extract minimum unsigned lane value from Vs and
    store into Rd. |'
  prefs: []
  type: TYPE_TB
- en: '| umaxv | umaxv Rd, Vs.t1 | Extract maximum unsigned lane value from Vs and
    store into Rd. |'
  prefs: []
  type: TYPE_TB
- en: '| fminv | fminv Sd, Vs.t2 | Extract minimum real lane value from Vs and store
    into Sd. |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxv | fmaxv Sd, Vs.t2 | Extract maximum real lane value from Vs and store
    into Rd. |'
  prefs: []
  type: TYPE_TB
- en: '| fminnmv | fminnmv Sd, Vs.t2 | Extract minimum real lane value from Vs and
    store into Sd. |'
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmv | fmaxnmv Sd, Vs.t2 | Extract maximum real lane value from Vs and
    store into Rd. |'
  prefs: []
  type: TYPE_TB
- en: In this table, Rd/t1 is B/8B, B/16B, H/4H, H/8H, or S/4S. If t1 is 8B, or 4H,
    the instruction operates only on the lanes in the LO 64 bits of Vs. For floating-point
    minimum and maximum, only single-precision operands are legal; t2 must be 2S or
    4S (operating on the LO 64 bits or the full 128 bits of the source register).
    As for the standard fmin and fmax instructions, the nm variants differ insofar
    as they return the numeric value if one of the operands is NaN.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 Floating-Point and Integer Conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions to convert between floating-point
    and integer (or fixed-point) formats. Section 6.9.4, “Floating-Point Conversion
    Instructions,” on [page 343](chapter6.xhtml#pg_343) provided examples of these
    conversion instructions when operating on scalar registers; the following subsections
    present the vector equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.1 Floating-Point to Integer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides vector equivalents of the fcvt* instructions
    that convert floating-point values to their integer equivalents, as shown in [Table
    11-27](chapter11.xhtml#tab11-27).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-27: Floating-Point to Integer Conversion Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtns | fcvtns Vd.t, Vs.t | Round to nearest signed integer. Exactly one-half
    rounds to nearest even integer. |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtas | fcvtas Vd.t, Vs.t | Round to nearest signed integer. Exactly one-half
    rounds away from zero. |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtps | fcvtps Vd.t, Vs.t | Round toward +∞ (signed integer). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtms | fcvtms Vd.t, Vs.t | Round toward –∞ (signed integer). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtzs | fcvtzs Vd.t, Vs.t | Round toward 0 (signed integer). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtnu | fcvtnu Vd.t, Vs.t | Round to nearest unsigned integer. Exactly one-half
    rounds to nearest even integer. |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtau | fcvtau Vd.t, Vs.t | Round to nearest unsigned integer. Exactly one-half
    rounds away from 0. |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtpu | fcvtpu Vd.t, Vs.t | Round toward +∞ (unsigned integer). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtmu | fcvtmu Vd.t, Vs.t | Round toward –∞ (unsigned integer). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtzu | fcvtzu Vd.t, Vs.t | Round toward 0 (unsigned integer). |'
  prefs: []
  type: TYPE_TB
- en: In this table, t is 2S (which uses only the LO 64 bits of the vector registers),
    4S, or 2D. The source operand is always assumed to contain floating-point values
    (single- or double-precision), and the destination lanes will receive signed or
    unsigned integer values (words or dwords). Note that when converting negative
    floating-point values to unsigned integers, the conversion saturates the conversion
    to 0.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fcvtz* instruction also has some fixed-point variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The imm operand specifies the number of fractional bits to maintain in the fixed-point
    value (this must be 1 to 31 for single-precision or word types and 1 to 63 for
    double-precision or dword types). Because integer operations are somewhat faster
    than floating-point calculations, sometimes it is faster to convert operands to
    fixed-point, do a chain of calculations, then convert the result back to floating-point.
    However, this book doesn’t cover fixed-point arithmetic in depth, so I won’t discuss
    this technique any further. See section 11.15, “For More Information,” on [page
    700](chapter11.xhtml#pg_700) for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.2 Integer to Floating-Point
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ucvtf and scvtf instructions convert 32- and 64-bit integers to single-
    and double-precision values, respectively. Their syntax is roughly the same as
    that of fcvt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: As with fcvt*, t must be 2S, 4S, or 2D (2S converts only the LO 64 bits).
  prefs: []
  type: TYPE_NORMAL
- en: Because double-precision values have only a 56-bit mantissa and single-precision
    values have only a 24-bit mantissa, you cannot exactly represent certain 32- and
    64-bit integers as single- or double-precision floating-point values. In those
    cases, the scvtf and ucvtf instructions produce the closest approximation. However,
    keep in mind that executing *cvtf followed by an fcvt* instruction may not return
    the exact same integer.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.8.3 Conversion Between Floating-Point Formats'
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set provides three instructions that will convert a small
    floating-point format to a larger form, or a larger form to a smaller form. This
    is one of the few instructions in the ARM instruction set that supports half-precision
    (16-bit) floating-point numbers. [Table 11-28](chapter11.xhtml#tab11-28) shows
    the available instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-28: Floating-Point Conversion Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane conversion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtl | fcvtl Vd.t1, Vs.t2 | Convert from a smaller size to the next larger
    size by using the LO 64 bits of the source register. |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtl2 | fcvtl2 Vd.t3, Vs.t4 | Convert from a smaller size to the next larger
    size by using the upper 64 bits of the source register (does not affect the LO
    bits of the destination register). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtn | fcvtn Vd.t5, Vs.t6 | Convert from a larger size to a smaller size
    by using the LO 64 bits of the destination register. |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtn2 | fcvtn2 Vd.t7, Vs.t8 | Convert from a larger size to a smaller size
    by using the HO 64 bits of the destination register (does not affect the LO bits
    of the destination register). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtxn | fcvtxn Vd.2S, Vs.2D | Like fcvtn, except rounding is different (see
    text). |'
  prefs: []
  type: TYPE_TB
- en: '| fcvtxn2 | fcvtxn2 Vd.4S, Vs.2D | Like fcvtn2, except rounding is different
    (see text). |'
  prefs: []
  type: TYPE_TB
- en: The legal types and lane counts for the instructions in [Table 11-28](chapter11.xhtml#tab11-28)
    appear in [Table 11-29](chapter11.xhtml#tab11-29), where H = 16-bit half-precision
    floating-point, S = 32-bit single-precision floating-point, and D = 64-bit double-precision
    floating-point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-29: Legal Types and Lane Counts for Floating-Point Conversions'
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types and lane counts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4S/4H or 2D/2S |'
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 4S/8H or 2D/4S |'
  prefs: []
  type: TYPE_TB
- en: '| t5/t6 | 4H/4S or 2S/2D |'
  prefs: []
  type: TYPE_TB
- en: '| t7/t8 | 8H/4S or 4S/2D |'
  prefs: []
  type: TYPE_TB
- en: Conversion from a smaller size to a larger size always produces an exact result.
    Conversion from a larger size down to a smaller size may require rounding the
    result to fit in the smaller size (worst case, overflow or underflow will occur
    if the larger value cannot be represented at all in the smaller floating-point
    format).
  prefs: []
  type: TYPE_NORMAL
- en: 'When rounding larger values to fit into a smaller format, the fcvtn and fcvtn2
    instructions use the standard IEEE-754 round-to-nearest-even algorithm. In some
    cases, this may not produce the best result. For example, it is generally better
    to round to the nearest odd when converting a half-precision value to a double-precision
    value (which requires two steps: convert half-precision to single-precision, then
    convert single-precision to double-precision). The fcvtxn and fcvtxn2 instructions
    employ this non-IEEE rounding scheme to produce better results.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.4 Floating-Point Values Rounded to the Nearest Integral
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Certain algorithms require rounding a floating-point value to an integer but
    require the result to be maintained in the floating-point format. The frint* instructions
    listed in [Table 11-30](chapter11.xhtml#tab11-30) provide this capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-30: Rounding a Floating-Point Value to an Integral Value'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane rounding operation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| frintn | frintn Vd.t, Vs.t | Round to nearest integer. Exactly one-half rounds
    to nearest even integer. |'
  prefs: []
  type: TYPE_TB
- en: '| frinta | frinta Vd.t, Vs.t | Round to nearest integer. Exactly one-half rounds
    away from 0. |'
  prefs: []
  type: TYPE_TB
- en: '| frintp | frintp Vd.t, Vs.t | Round toward +∞. |'
  prefs: []
  type: TYPE_TB
- en: '| frintm | frintm Vd.t, Vs.t | Round toward –∞. |'
  prefs: []
  type: TYPE_TB
- en: '| frintz | frintz Vd.t, Vs.t | Round toward 0. |'
  prefs: []
  type: TYPE_TB
- en: '| frinti | frinti Vd.t, Vs.t | Round using FPCR rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| frintx | frintx Vd.t, Vs.t | Round using FPCR rounding mode with exactness
    test. |'
  prefs: []
  type: TYPE_TB
- en: In this table, t must be 2S, 4S, or 2D. If it is 2S, these instructions use
    only the LO 64 bits of the registers.
  prefs: []
  type: TYPE_NORMAL
- en: The frintx instruction generates a floating-point inexact result exception if
    the rounded result is not equal to the original source value. You won’t normally
    use this instruction unless you have an appropriate exception handler in place.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 Vector Square-Root Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set provides two instructions for computing the square
    root of a floating-point value and computing (and refining) an estimate of the
    reciprocal of the square root of a floating-point value. [Table 11-31](chapter11.xhtml#tab11-31)
    lists these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-31: Vector Square Root Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane operation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fsqrt | fsqrt Vd.t, Vs.t | Compute square root of source and store into destination
    |'
  prefs: []
  type: TYPE_TB
- en: '| frsqrte | frsqrte Vd.t, Vs.t | First step of Newton-Raphson approximation
    of the reciprocal of the square root |'
  prefs: []
  type: TYPE_TB
- en: '| frsqrts | frsqrts Vd.t, Vs1.t, Vs2.t | Additional steps of the Newton-Raphson
    approximation |'
  prefs: []
  type: TYPE_TB
- en: In the table, t must be 2S, 4S, or 2D. If it’s 2S, these instructions operate
    on the lanes in the LO 64 bits of the vector registers.
  prefs: []
  type: TYPE_NORMAL
- en: These three instructions also have scalar versions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are one of the floating-point scalar registers Sn or Dn.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the frsqrts instruction multiplies corresponding floating-point values
    in the lanes of the two source registers, subtracts each of the products from
    3.0, divides these results by 2.0, and places the results into the destination
    register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10 Vector Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vector comparisons are fundamentally different from normal (general-purpose
    register) comparisons. When comparing general-purpose registers (or even individual
    floating-point scalar values), the ARM CPU sets the condition codes based on the
    result of the comparison; the code following the comparison then tests those condition
    codes, using a conditional branch, for example. This scheme doesn’t work when
    comparing vector elements because the CPU always performs multiple comparisons
    in parallel. There’s only one set of condition codes, so the CPU cannot put the
    results of multiple comparisons into the condition codes, meaning vector comparisons
    require a different mechanism to make the comparison results available to the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a generic comparison that produces less than, greater than, or equal
    results simultaneously (in the condition codes), a vector comparison asks for
    a specific comparison, such as, “Are the elements of this vector greater than
    the elements of another vector?” The result is true or false for each lane-by-lane
    comparison. A vector comparison will store the true or false result into the corresponding
    lanes of a destination vector. Vector comparisons use all 0 bits in a lane to
    represent false and all 1 bits in a lane to represent true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neon has two general sets of vector comparison instructions: one for integer
    comparisons and another for floating-point comparisons. The following subsections
    discuss each of these forms.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.10.1 Vector Integer Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-32](chapter11.xhtml#tab11-32) lists the generic vector integer compare
    instructions, where t is 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For the 8B, 4H, and 2S
    types, these instructions operate only on the LO 64 bits of the registers and
    clear the HO 64 bits of the destination register.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-32: Vector Integer Comparison Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Vd.t, Vl.t, Vr.t | Signed or unsigned comparison for equality
    |'
  prefs: []
  type: TYPE_TB
- en: '| cmhs | cmhs Vd.t, Vl.t, Vr.t | Unsigned comparison for greater than or equal
    (Vd = Vl ≥ Vr) |'
  prefs: []
  type: TYPE_TB
- en: '| cmhi | cmhi Vd.t, Vl.t, Vr.t | Unsigned comparison for greater than (Vd =
    Vl > Vr) |'
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Vd.t, Vl.t, Vr.t | Signed comparison for greater than or equal
    (Vd = Vl ≥ Vr) |'
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Vd.t, Vl.t, Vr.t | Signed comparison for greater than (Vd = Vl
    > Vr) |'
  prefs: []
  type: TYPE_TB
- en: There is no cmne instruction. You can invert all the bits in the destination
    register (using the not instruction) if you need this comparison, or you can use
    0 bits to imply true and 1 bits to imply false. Likewise, there are no cmls, cmlo,
    cmle, or cmlt instructions; you can derive these from cmgt, cmge, cmhs, or cmhi
    by reversing the operands.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions have scalar variants, as shown in [Table 11-33](chapter11.xhtml#tab11-33),
    where Rd, Rl, and Rr must be Dn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-33: Scalar Integer Comparison Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Rd, Rl, Rr | Signed or unsigned comparison for equality |'
  prefs: []
  type: TYPE_TB
- en: '| cmhs | cmhs Rd, Rl, Rr | Unsigned comparison for greater than or equal (Rd
    = Rl ≥ Rr) |'
  prefs: []
  type: TYPE_TB
- en: '| cmhi | cmhi Rd, Rl, Rr | Unsigned comparison for greater than (Rd = Rl >
    Rr) |'
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Rd, Rl, Rr | Signed comparison for greater than or equal (Rd
    = Rl ≥ Rr) |'
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Rd, Rl, Rr | Signed comparison for greater than (Rd = Rl > Rr)
    |'
  prefs: []
  type: TYPE_TB
- en: A special set of vector comparison instructions exists to compare the lanes
    of a single vector against 0\. This saves setting up a register to contain all
    0s for this common case. The available instructions perform only signed comparisons
    (it doesn’t make much sense to compare unsigned values against 0). [Table 11-34](chapter11.xhtml#tab11-34)
    lists these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-34: Signed Vector Comparisons Against 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison against 0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Vd.t, Vl.t, #0 | Signed comparison for lanes equal to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Vd.t, Vl.t, #0 | Signed comparison for lanes greater than or
    equal to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Vd.t, Vl.t, #0 | Signed comparison for lanes greater than 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmle | cmle Vd.t, Vl.t, #0 | Signed comparison for lanes less than or equal
    to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmlt | cmlt Vd.t, Vl.t, #0 | Signed comparison for lanes less than 0 |'
  prefs: []
  type: TYPE_TB
- en: The type t must be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For the 8B, 4H, and 2S types,
    these instructions operate only on the LO 64 bits of the registers and clear the
    HO 64 bits of the destination register. The only legal immediate constant is 0
    with these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-35](chapter11.xhtml#tab11-35) lists the scalar versions of these
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-35: Scalar Vector Comparisons Against 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison against 0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Rd, Rl, #0 | Signed comparison for register equal to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Rd, Rl, #0 | Signed comparison for register greater than or equal
    to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Rd, Rl, #0 | Signed comparison for register greater than 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmle | cmle Rd, Rl, #0 | Signed comparison for register less than or equal
    to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| cmlt | cmlt Rd, Rl, #0 | Signed comparison for register less than 0 |'
  prefs: []
  type: TYPE_TB
- en: In this table, Rd, Rl, and Rr must be Dn.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.2 Vector Floating-Point Comparisons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also compare floating-point values in the vector registers’ lanes. [Table
    11-36](chapter11.xhtml#tab11-36) lists the various fcm* instructions available
    for this purpose, where t is 2S, 4S, or 2D. If t is 2S, these instructions use
    only the LO 64 bits of the registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-36: Vector Floating-Point Comparison Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Vd.t, Vl.t, Vr.t | Floating-point comparison for equality |'
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = Vl ≥ Vr)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = Vl > Vr)
    |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-37](chapter11.xhtml#tab11-37) lists variants of the fcm* instructions
    that compare the lanes in a vector register against 0.0, where t is 2S, 4S, or
    2D. If t is 2S, these instructions use only the LO 64 bits of the registers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-37: Vector Floating-Point Comparison Against 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison against 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Vd.t, Vl.t, #0 | Floating-point comparison for register equal
    to 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Vd.t, Vl.t, #0 | Floating-point comparison for register greater
    than or equal to 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Vd.t, Vl.t, #0 | Floating-point comparison for register greater
    than 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmle | fcmle Vd.t, Vl.t, #0 | Floating-point comparison for register less
    than or equal to 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmlt | fcmlt Vd.t, Vl.t, #0 | Floating-point comparison for register less
    than 0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Note that the immediate constant is 0 (versus 0.0), even though this is a floating-point
    comparison. The only legal operand for this instruction is #0.'
  prefs: []
  type: TYPE_NORMAL
- en: As for the integer comparisons, the fcm* instructions provide a set of scalar
    instructions that also store true (all 1 bits) or false (all 0 bits) into the
    destination register (in contrast to the fcmp instructions that set the condition
    code flags). [Table 11-38](chapter11.xhtml#tab11-38) lists the scalar versions
    of these instructions, where Rd, Rl, and Rr must be Sn or Dn*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-38: Scalar Variants of the Vector Floating-Point Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison (including against
    0.0) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Rd, Rl, Rr | Floating-point comparison for equality |'
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Rd, Rl, Rr | Floating-point comparison (Rd = Rl ≥ Rr) |'
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Rd, Rl, Rr | Floating-point comparison (Rd = Rl > Rr) |'
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Rd, Rl, #0 | Floating-point comparison for register equal to
    0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Rd, Rl, #0 | Floating-point comparison for register greater
    than or equal to 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Rd, Rl, #0 | Floating-point comparison for register greater
    than 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmle | fcmle Rd, Rl, #0 | Floating-point comparison for register less than
    or equal to 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fcmlt | fcmlt Rd, Rl, #0 | Floating-point comparison for register less than
    0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Neon has a couple of additional floating-point comparisons: fac* (vector floating-point
    absolute value compare). These instructions compare the absolute values of corresponding
    lanes in the source vector register and set the destination register accordingly.
    [Table 11-39](chapter11.xhtml#tab11-39) lists these instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-39: Floating-Point Absolute-Value Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| facge | facge Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = abs(Vl)
    ≥ abs(Vr)) |'
  prefs: []
  type: TYPE_TB
- en: '| facgt | facgt Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = abs(Vl)
    > abs(Vr)) |'
  prefs: []
  type: TYPE_TB
- en: There is no faceq instruction, since there’s no need for one; just use fcmeq.
  prefs: []
  type: TYPE_NORMAL
- en: The fac* instructions also have scalar versions, listed in [Table 11-40](chapter11.xhtml#tab11-40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-40: Scalar Floating-Point Absolute-Value Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| facge | facge Rd, Rl, Rr | Floating-point comparison (Rd = abs(Rl) ≥ abs(Rr))
    |'
  prefs: []
  type: TYPE_TB
- en: '| facgt | facgt Rd, Rl, Rr | Floating-point comparison (Rd = abs(Rl) > abs(Rr))
    |'
  prefs: []
  type: TYPE_TB
- en: Note that Rd, Rl, and Rr must be Sn or Dn.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.3 Vector Bit Test Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides a vector version of the tst instruction, cmtst,
    which has the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. If t is 8B, 4H, or 2S, this instruction
    operates only on the LO 64 bits of the source registers and clears the HO 64 bits
    of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: This instruction does a lane-by-lane logical AND operation between Vl and Vr.
    If the result is nonzero, it stores all 1 bits into the corresponding destination
    lane. Otherwise, it stores all 0s into the destination lane.
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction also has a scalar version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This form supports only 64-bit register operands (D*n*).
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.4 Vector Comparison Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Throughout your programming experience, including with HLLs, you’ve probably
    become accustomed to using the result of comparisons (such as Boolean expressions)
    to divert control flow (such as with an if/then/else statement). Vector comparisons
    present a completely different paradigm because the lanes in a comparison could
    all produce different results. What’s the best way to deal with this?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider the easy stuff: complex Boolean expressions involving ANDs,
    ORs, and other logical operators. Because the vector comparisons compute convenient
    results (all 1s or all 0s), it’s easy to compute something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This leaves the result of the previous Boolean calculation (0x0000 or 0xFFFF)
    in the LO 64 bits of the V0 register (lanes 0 to 3; remember that the and instruction
    allows only 8B and 16B types, but they produce the same result as 4H would if
    it were a legal type).
  prefs: []
  type: TYPE_NORMAL
- en: You can use similar instruction sequences for OR, NOT, and any of the other
    logical vector operations (see [Table 11-2](chapter11.xhtml#tab11-2)). Such calculations
    will use complete Boolean evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Short-circuit evaluation doesn’t make sense for vector operations; see section
    7.6.3, “Complex* if *Statements Using Complete Boolean Evaluation,” on [page 378](chapter7.xhtml#pg_378)
    for more information on complete Boolean evaluation.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you absolutely, positively must branch to some locations based on the result
    of all the vector comparisons, keep in mind that the number of branch locations
    increases exponentially with the number of lanes (specifically, its 2*^n* different
    possibilities, where *n* is the number of lanes). For example, if you execute
    the following instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: then the LO 64 bits of V0 will contain four Boolean values, yielding 16 combinations
    of the four comparisons. It’s ugly, but you could create a jump table (see section
    7.6.7.3, “Indirect Jump switch Implementation,” on [page 391](chapter7.xhtml#pg_391))
    with 16 entries and then transfer control by using code like the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: where mask is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: and JmpTbl is a 16-entry .dword table with the offset to the labels to jump
    to, based on all the combinations of true and false for four lane comparisons.
    This code moves bit 0 of lane 0 into bit 0 of X0, bit 0 of lane 1 into bit 1 of
    X0, bit 0 of lane 2 into bit 2 of X0, and bit 0 of lane 3 into bit 3 of X0\. This
    forms a 4-bit index (16 possible values) into JmpTbl.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, you could create a jump table with 16 entries and write code
    to transfer control, but this would be so ugly it’s not an option worth seriously
    considering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you don’t need to know the particular configuration of matches in
    a vector comparison, only whether any matches exist at all. For example, suppose
    you were looking for a 0 byte in a string of characters (such as when computing
    the length of a zero-terminating string). You could load 16 characters at a time
    from the string and search for a 0 byte by comparing all of them against 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction sets the particular lane in V0 to 0xFF, corresponding to any
    lane in V1 that contains a 0 byte. You can use the following sequence to check
    whether there were any 0 bytes at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In the SIMD paradigm, an ideal solution would be to do calculations in parallel
    and use masks to disable certain calculations. For example, suppose you have a
    vector of 32-bit integers to which you would like to add another vector’s lanes,
    with the caveat that you don’t want to add anything if a particular lane contains
    a value greater than 16 bits (0xFFFF). Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The and instruction sets dword lanes greater than 0xFFFF to 0 so that they will
    have no impact on the final lane sums.
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.11 A Sorting Example Using SIMD Code'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting data is a common vector solution. Listing 11-1 demonstrates a simple
    sort of eight elements by using a vectorized bitonic sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and the sample output for Listing 11-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code properly sorted the data.
  prefs: []
  type: TYPE_NORMAL
- en: 11.12 A Numeric-to-Hex-String Example Using SIMD Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Listing 11-2 is a Neon example of something you should be familiar with: [Chapter
    9](chapter9.xhtml)’s dtoStr function that converts a dword into a hexadecimal
    string. It’s a practical example of converting existing code to SIMD.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and the sample output for Listing 11-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: If you were to time this code, you’d find that it runs significantly faster
    than the scalar code in [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 11.13 Use of SIMD Instructions in Real Programs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve read through this chapter but aren’t sure how to apply SIMD instructions
    in real programs, don’t feel like you’re missing something. *SIMD* might as well
    stand for “*S*IMD *I*nstruction sets are *M*assively *D*ifficult to use.” Although
    ARM’s Neon instruction set is a bit more general-purpose than, say, Intel’s SSE/AVX
    extensions, SIMD instructions were created to accelerate the execution of very
    specific algorithms. I like to paraphrase a line from this book’s technical reviewer,
    Tony Tribelli, with respect to SIMD instructions’ applicability: “I look at a
    particular SIMD instruction and ask myself, ‘What benchmark was this instruction
    created for?’ ” That is, it often seems like SIMD instructions were added to the
    instruction set to make one benchmark program run faster and make the ARM CPU
    look better, though the instruction probably isn’t useful outside the context
    of that benchmark.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many respects, this statement is dead on: many SIMD instructions were created
    to solve one particular problem, and their applicability beyond that solution
    is merely coincidental. If you can’t figure out how to use a given instruction,
    you probably haven’t yet discovered the problem it was originally created to address.'
  prefs: []
  type: TYPE_NORMAL
- en: If nothing else, the vector registers’ lanes are a good place to store temporary
    values when you’re already using all the general-purpose registers. You can use
    the mov instruction to copy data between a general-purpose register and a lane
    in a vector register; this is much faster than spilling the register to memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to use the Neon instruction set for high-performance computing,
    see section 11.15, “For More Information,” on the next page, or search “SIMD parallel
    algorithms” or “SIMD vector algorithms” on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.14 Moving On'
  prefs: []
  type: TYPE_NORMAL
- en: This lengthy chapter covered many instructions. It began with a brief history
    of SIMD instruction sets; covered the vector registers on the ARM; discussed SIMD
    data types, lanes, and scalar operations; and then presented the Neon instruction
    set. This chapter ended with a pair of short examples that demonstrated bitonic
    sorting and numeric-to-hexadecimal-string conversion using the vector registers.
    These constitute useful ways to use the SIMD instructions on the ARM. Although
    SIMD instructions aren’t often applicable in general programs, with a little thought
    you should be able to use them to speed up your code in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of the remaining chapters will employ SIMD instructions to improve
    performance. [Chapter 12](chapter12.xhtml) uses Neon instructions to improve the
    performance of various bit operations, while [Chapter 14](chapter14.xhtml) uses
    Neon instructions to implement fast memory move operations. You can apply what
    you’ve learned in this chapter to algorithms you’ve learned in previous chapters
    that could benefit from using SIMD instructions, such as the numeric-to-hex-string
    code. I’ll leave it to you to implement these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 11.15 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on fixed-point arithmetic and other Neon instructions and
    data types, consult the ARM Architecture Reference Manual at *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/ddi0487<wbr>/latest](https://developer.arm.com/documentation/ddi0487/latest)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on ARM scalable vector extensions (SVEs), see the documentation at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/102476<wbr>/0001<wbr>/SVE<wbr>-architecture<wbr>-fundamentals](https://developer.arm.com/documentation/102476/0001/SVE-architecture-fundamentals)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM offers a guide on implementing fixed-point arithmetic on 32-bit CPUs at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/dai0033<wbr>/a](https://developer.arm.com/documentation/dai0033/a)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those interested in vector sorting with ARM SVE can reference “A Fast Vectorized
    Sorting Implementation Based on the ARM Scalable Vector Extension (SVE)” by Bérenger
    Bramas for one implementation: *[https://<wbr>arxiv<wbr>.org<wbr>/pdf<wbr>/2105<wbr>.07782<wbr>.pdf](https://arxiv.org/pdf/2105.07782.pdf)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the Vector Sorting Algorithms page of the CMSIS DSP Software Library for
    more on vector sorting with ARM: *[https://<wbr>arm<wbr>-software<wbr>.github<wbr>.io<wbr>/CMSIS<wbr>_5<wbr>/DSP<wbr>/html<wbr>/group<wbr>_<wbr>_Sorting<wbr>.html](https://arm-software.github.io/CMSIS_5/DSP/html/group__Sorting.html)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM documentation also provides more detail on vector sorting on Neon at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/den0018<wbr>/a<wbr>/NEON<wbr>-Code<wbr>-Examples<wbr>-with<wbr>-Optimization<wbr>/Median<wbr>-filter<wbr>/Basic<wbr>-principles<wbr>-and<wbr>-bitonic<wbr>-sorting](https://developer.arm.com/documentation/den0018/a/NEON-Code-Examples-with-Optimization/Median-filter/Basic-principles-and-bitonic-sorting)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast and Robust Vectorized In-Place Sorting of Primitive Types” by Mark Blacher,
    Joachim Giesen, and Lars Kühne at *[https://<wbr>drops<wbr>.dagstuhl<wbr>.de<wbr>/opus<wbr>/volltexte<wbr>/2021<wbr>/13775<wbr>/pdf<wbr>/LIPIcs<wbr>-SEA<wbr>-2021<wbr>-3<wbr>.pdf](https://drops.dagstuhl.de/opus/volltexte/2021/13775/pdf/LIPIcs-SEA-2021-3.pdf)*
    covers quick sorting with vector instructions (written for AVX2, but easily translatable
    to Neon) using the bitonic sorting algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the master’s thesis “A Study of the Use of SIMD Instructions for Two Image
    Processing Algorithms” by Eric Welch at *[https://<wbr>scholarworks<wbr>.rit<wbr>.edu<wbr>/cgi<wbr>/viewcontent<wbr>.cgi<wbr>?article<wbr>=3686&context<wbr>=theses](https://scholarworks.rit.edu/cgi/viewcontent.cgi?article=3686&context=theses)*
    for a discussion of SIMD image processing algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another master’s thesis on SIMD signal processing algorithms is “Performance
    Optimization of Signal Processing Algorithms for SIMD Architectures” by Sharan
    Yagneswar, which can be found at *[https://<wbr>www<wbr>.diva<wbr>-portal<wbr>.org<wbr>/smash<wbr>/get<wbr>/diva2:1138490<wbr>/FULLTEXT01<wbr>.pdf](https://www.diva-portal.org/smash/get/diva2:1138490/FULLTEXT01.pdf)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
