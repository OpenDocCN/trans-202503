- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 NEON AND SIMD PROGRAMMING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11 NEON 和 SIMD 编程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter discusses the vector instructions on the ARM. This special class
    of instructions provides parallel processing, traditionally known as *single-instruction,
    multiple-data (SIMD)* instructions because, quite literally, a single instruction
    operates on several pieces of data concurrently. As a result of this concurrency,
    SIMD instructions can often execute several times faster (in theory, as much as
    32 to 64 times faster) than the comparable *single-instruction, single-data (SISD)*
    instructions that compose the standard ARM instruction set.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 ARM 上的矢量指令。这一特殊类型的指令提供了并行处理，传统上被称为 *单指令多数据（SIMD）* 指令，因为，字面上说，一条指令可以同时作用于多个数据单元。由于这种并发性，SIMD
    指令通常比标准 ARM 指令集中的 *单指令单数据（SISD）* 指令执行速度快得多（理论上，可以快 32 到 64 倍）。
- en: Vector instructions, also known as the *Neon instruction set* or *ARM Advanced
    SIMD*, provide an extension to the standard scalar instructions. While a *scalar
    instruction* operates on a single piece of data at a time, the Neon instructions
    simultaneously operate on a *vector* (a fancy name for an array) of data objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量指令，也称为 *Neon 指令集* 或 *ARM 高级 SIMD*，为标准标量指令提供了扩展。标准的 *标量指令* 每次操作一个数据单元，而 Neon
    指令则同时操作一个数据对象的 *矢量*（即数组）。
- en: This chapter covers a brief history of SIMD instructions, then discusses the
    ARM Neon architecture (including the vector registers) and Neon data types. The
    majority of this chapter then covers the Neon instruction set. A complete treatise
    on SIMD programming is beyond the scope of this book; however, it wouldn’t do
    to write this chapter without at least a few SIMD programming examples in order
    to demonstrate the benefits of SIMD programming, so this chapter concludes with
    examples that show a bitonic sort and a numeric-to-hex-string conversion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要回顾了 SIMD 指令的历史，然后讨论了 ARM Neon 架构（包括矢量寄存器）和 Neon 数据类型。接下来的大部分内容将讲解 Neon 指令集。关于
    SIMD 编程的完整论述超出了本书的范围；然而，写这章时至少提供一些 SIMD 编程示例以展示 SIMD 编程的优势是必要的，因此本章的最后将给出一些例子，展示比托尼排序和数字到十六进制字符串的转换。
- en: 11.1 The History of SIMD Instruction Extensions
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1 SIMD 指令扩展的历史
- en: The Neon instruction set extensions were added to the ARM instruction set long
    after the ARM was created. Arm created Neon to counter competition from the Intel
    x86 CPU family. To understand why the Neon instruction set is so radically different
    from the standard instruction set, you have to understand the history of SIMD
    (vector) instruction sets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 指令集扩展是在 ARM 创建之后很久才加入到 ARM 指令集中的。ARM 创建 Neon 是为了应对英特尔 x86 CPU 家族的竞争。要理解为什么
    Neon 指令集与标准指令集有如此根本的不同，必须了解 SIMD（矢量）指令集的历史。
- en: The first vector computers were supercomputers such as the CDC Star-100, Texas
    Instruments Advanced Scientific Computer (ASC), and Cray computers, which could
    operate on a vector of data with a single instruction. These vector computers
    were the precursor to the early SIMD computers such as the Thinking Machines CM-1
    and CM-2\. Ultimately, supercomputers moved away from the SIMD approach when Intel
    introduced SIMD features on its low-cost i860 (and, later, Pentium processors).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个矢量计算机是超级计算机，如 CDC Star-100、德州仪器的高级科学计算机（ASC）和 Cray 计算机，它们可以用单条指令操作一个数据矢量。这些矢量计算机是早期
    SIMD 计算机的前身，如 Thinking Machines 的 CM-1 和 CM-2。最终，随着英特尔在其低成本 i860（后来是 Pentium 处理器）上引入
    SIMD 特性，超级计算机开始远离 SIMD 方法。
- en: The Intel Multimedia Extensions (MMX) instruction set was the first widely adopted
    desktop SIMD architecture. Intel added parallel integer arithmetic instructions
    to the venerable x86 instruction set to accelerate digital audio processing and
    other digital signal processing applications. The PowerPC followed this with the
    much more capable AltiVec architecture (which included support for single-precision
    floating-point values). Intel then produced the SSE2 and SSE3, AVX, AVX2, and
    AVX-512 SIMD instruction architectures (which now include full double-precision
    floating-point support).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔多媒体扩展（MMX）指令集是第一个广泛采用的桌面 SIMD 架构。英特尔将并行整数运算指令添加到传统的 x86 指令集中，以加速数字音频处理和其他数字信号处理应用。之后，PowerPC
    推出了更强大的 AltiVec 架构（其中包括对单精度浮点值的支持）。随后，英特尔推出了 SSE2 和 SSE3、AVX、AVX2 和 AVX-512 SIMD
    指令架构（现在包括完全的双精度浮点支持）。
- en: Intel’s approach to adding vector instructions to its x86 series CPUs was a
    bit hackneyed. Given the limited transistor budgets on CPUs in the middle 1990s,
    Intel added a few vector instructions (MMX) in its early Pentium processors and
    then extended the SIMD instruction set as its CPUs became larger and had more
    transistors available to implement advanced features. This evolution produced
    a bit of a kludge, with new sets of instructions replicating and obsoleting older
    instructions (with the newer instruction set’s ability to handle more data or
    handle data differently).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔在其 x86 系列 CPU 中添加向量指令的方法有些拗口。由于上世纪 90 年代中期 CPU 的晶体管预算有限，英特尔在其早期的奔腾处理器中增加了一些向量指令（MMX），然后随着其
    CPU 的增大和可用晶体管数量的增加，扩展了 SIMD 指令集，支持实现更先进的特性。这一演变产生了一些杂乱无章的情况，新的指令集复制并淘汰了旧的指令（新指令集能够处理更多的数据或以不同的方式处理数据）。
- en: By the time ARM added SIMD instructions via its *Neon Advanced SIMD* instructions,
    Intel had gone through multiple generations of SIMD instructions; Arm was able
    to cherry-pick the more interesting and useful instructions from Intel’s set,
    leaving behind all the kruft and legacy instructions. For this reason, the Neon
    instruction set is considerably more compact and much easier to understand than
    Intel’s MMX/SSE/AVX instruction sets.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到了 ARM 通过其 *Neon 高级 SIMD* 指令添加 SIMD 指令时，英特尔已经经历了多代 SIMD 指令；ARM 能够从英特尔的指令集中挑选出更有趣且实用的指令，抛弃了所有不必要的遗留指令。因此，Neon
    指令集比英特尔的 MMX/SSE/AVX 指令集要简洁得多，理解起来也容易得多。
- en: '### 11.2 Vector Registers'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '### 11.2 向量寄存器'
- en: 'The ARM provides 32 main FP/Neon registers that are 128 bits each, broken into
    five groups based on their size:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了 32 个主 FP/Neon 寄存器，每个大小为 128 位，按其大小分为五组：
- en: V0 to V31, the 128-bit vector registers (for Neon instructions), also referenced
    as Q0 to Q31, the qword registers; the V*n* names support special syntax for vector
    operations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V0 到 V31，为 128 位向量寄存器（用于 Neon 指令），也可以引用为 Q0 到 Q31，qword 寄存器；V*n* 名称支持向量操作的特殊语法
- en: D0 to D31, the 64-bit double-precision floating-point registers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D0 到 D31，为 64 位双精度浮点寄存器
- en: S0 to S31, the 32-bit single-precision floating-point registers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S0 到 S31，为 32 位单精度浮点寄存器
- en: H0 to H31, the 16-bit half-precision floating-point registers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H0 到 H31，为 16 位半精度浮点寄存器
- en: B0 to B31, the 8-bit byte registers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B0 到 B31，为 8 位字节寄存器
- en: '[Figure 11-1](chapter11.xhtml#fig11-1) shows the vector register layout.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](chapter11.xhtml#fig11-1) 显示了向量寄存器的布局。'
- en: '![](../images/Figure11-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-1.jpg)'
- en: 'Figure 11-1: The FP/Neon registers'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：FP/Neon 寄存器
- en: The B*n*, H*n*, S*n*, D*n*, and V*n* registers overlay one another, as shown
    in [Figure 11-2](chapter11.xhtml#fig11-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: B*n*、H*n*、S*n*、D*n* 和 V*n* 寄存器彼此重叠，如 [图 11-2](chapter11.xhtml#fig11-2) 所示。
- en: '![](../images/Figure11-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-2.jpg)'
- en: 'Figure 11-2: Byte, half-word, single, double, and vector register overlays'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：字节、半字、单精度、双精度和向量寄存器重叠
- en: See [Chapter 6](chapter6.xhtml) for more information about the scalar floating-point
    D*n*, S*n*, and H*n* registers. Keep in mind, however, that if you mix vector
    and floating-point operations in your code, the instructions share the same register
    set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有关标量浮点寄存器 D*n*、S*n* 和 H*n* 的更多信息，请参见 [第 6 章](chapter6.xhtml)。不过请记住，如果在代码中混合使用向量和浮点操作，则这些指令共享相同的寄存器集合。
- en: '[Figures 11-1](chapter11.xhtml#fig11-1) and [11-2](chapter11.xhtml#fig11-2)
    give the impression that the V*n* registers are 128-bit registers (which, presumably,
    you can manipulate as a single 128-bit value). In fact, the V*n* registers are
    vectors containing sixteen 8-bit, eight 16-bit, four 32-bit, two 64-bit, or (single)
    128-bit values, as [Figure 11-3](chapter11.xhtml#fig11-3) shows.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](chapter11.xhtml#fig11-1) 和 [图 11-2](chapter11.xhtml#fig11-2) 给人一种印象，即
    V*n* 寄存器是 128 位寄存器（可以作为一个 128 位的值进行操作）。实际上，V*n* 寄存器是包含 16 个 8 位、8 个 16 位、4 个 32
    位、2 个 64 位或（单个）128 位值的向量，正如 [图 11-3](chapter11.xhtml#fig11-3) 所示。'
- en: '![](../images/Figure11-3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-3.jpg)'
- en: 'Figure 11-3: Vector register overlays'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：向量寄存器重叠
- en: 'When an instruction operates on a particular element of a vector register,
    you reference that element by using one of the following register names (in all
    cases, *n* represents a vector register number in the range 0 to 31):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当指令操作某个向量寄存器的特定元素时，可以通过以下寄存器名称引用该元素（在所有情况下，*n* 代表一个向量寄存器编号，范围从 0 到 31）：
- en: V*n* or Q*n* when referencing the whole 128-bit register
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V*n* 或 Q*n* 当引用整个 128 位寄存器时
- en: V*n*.B when treating the whole register as an array of 16 bytes
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V*n*.B 当将整个寄存器视为 16 字节的数组时
- en: V*n*.H when treating the whole register as an array of eight half words
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将整个寄存器视为八个半字组成的数组时，使用V*n*.H。
- en: V*n*.S when treating the whole register as an array of four words (single-precision
    values)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将整个寄存器视为四个字（单精度值）组成的数组时，使用V*n*。
- en: V*n*.D when treating the whole register as an array of two dwords (double-precision
    values)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将整个寄存器视为两个双字（双精度值）组成的数组时，使用V*n*.D。
- en: V*n*.2D[0] or V*n*.2D[1] when referencing 64-bit double-precision in bit positions
    0 to 63 or 64 to 127, respectively
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当引用位位置0到63或64到127中的64位双精度时，使用V*n*.2D[0]或V*n*.2D[1]。
- en: V*n*.4S[0], V*n*.4S[1], V*n*.4S[2], V*n*.4S[3] when accessing a 32-bit single-precision
    value in bit positions 0 to 31, 32 to 63, 64 to 95, or 96 to 127, respectively
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问位位置0到31、32到63、64到95或96到127中的32位单精度值时，使用V*n*.4S[0]、V*n*.4S[1]、V*n*.4S[2]、V*n*.4S[3]。
- en: V*n*.8H[0], V*n*.8H[1], ..., V*n*.8H[7] when accessing a 16-bit half-word value
    in bit positions 0 to 15, 16 to 31, ..., 112 to 127, respectively
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问位位置0到15、16到31、...、112到127中的16位半字值时，使用V*n*.8H[0]、V*n*.8H[1]、...、V*n*.8H[7]。
- en: V*n*.16B[0], V*n*.16B[1], ..., V*n*.16B[15] when accessing an 8-bit byte in
    bit positions 0 to 7, 8 to 16, ..., 120 to 127
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问位位置0到7、8到15、...、120到127中的8位字节时，使用V*n*.16B[0]、V*n*.16B[1]、...、V*n*.16B[15]。
- en: The exact name to choose will depend on the instruction and situation. You’ll
    see examples of these registers in use in the next section, “Vector Data Movement
    Instructions,” particularly section 11.3.4, “Vector Load and Store,” on [page
    632](chapter11.xhtml#pg_632).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择确切名称将取决于指令和情况。你将在下一节“向量数据移动指令”中看到这些寄存器的使用示例，特别是11.3.4节“向量加载与存储”，在[第632页](chapter11.xhtml#pg_632)。
- en: '[Figures 11-2](chapter11.xhtml#fig11-2) and [11-3](chapter11.xhtml#fig11-3)
    showed the five basic types associated with the data in a vector register: bytes,
    half words, single-precision values, double-precision values, and 128-bit qwords.
    In fact, the 32-bit (single) and 64-bit (double) fields support both floating-point
    (single and double) and integer (word and dword) types, bringing the total number
    of types to seven.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-2](chapter11.xhtml#fig11-2)和[图11-3](chapter11.xhtml#fig11-3)展示了与向量寄存器中数据相关的五种基本类型：字节、半字、单精度值、双精度值和128位四字（qword）。事实上，32位（单精度）和64位（双精度）字段支持浮点（单精度和双精度）和整数（字和双字）类型，将类型的总数增加到七种。'
- en: Except for the special 128-bit case, the vector registers contain arrays of
    bytes, half words, words, and qwords. For reasons you’ll learn when this chapter
    discusses vector operations, each element of the array is known as a *lane*. When
    performing operations using two vector registers, the CPU generally computes results
    by using the operands in corresponding lanes in the two source registers and stores
    the result in the corresponding lane in a destination register. For example, suppose
    that V1 contains 2.0 in the HO 64 bits (lane 1) and 1.0 in the LO 64 bits (lane
    0), and that V2 contains 20.0 in lane 1 and 10.0 in lane 0\. Summing these two
    vector registers and storing the result in V3 produces 22.0 in lane 1 and 11.0
    in lane 0.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特殊的128位情况外，向量寄存器包含字节、半字、字和四字（qword）的数组。由于你将在本章讨论向量操作时了解的原因，每个数组元素被称为*lane*。在使用两个向量寄存器执行操作时，CPU通常通过使用两个源寄存器中对应的lane中的操作数来计算结果，并将结果存储在目标寄存器中的相应lane中。例如，假设V1在高64位（lane
    1）包含2.0，在低64位（lane 0）包含1.0，而V2在lane 1中包含20.0，在lane 0中包含10.0。将这两个向量寄存器相加并将结果存储在V3中，会在lane
    1中得到22.0，在lane 0中得到11.0。
- en: Although the vector registers generally contain arrays of data (when performing
    SIMD operations), don’t forget that the floating-point registers (D*n* and S*n*)
    overlay the vector registers as well. When doing normal floating-point operations
    (see [Chapter 6](chapter6.xhtml)), these registers contain a single value rather
    than an array of values. These single values are known as *scalars*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管向量寄存器通常包含数据数组（在执行SIMD操作时），但不要忘记，浮点寄存器（D*n*和S*n*）也覆盖了向量寄存器。当执行正常的浮点操作时（参见[第6章](chapter6.xhtml)），这些寄存器只包含单一的值，而不是值的数组。这些单一值被称为*标量*。
- en: Very few operations treat an entire 128-bit Neon register as a scalar value.
    Those that do (mainly load and store instructions) use the name Q*n* to denote
    a scalar value rather than V*n* (a vector value).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有操作将整个128位Neon寄存器视为标量值。那些将其视为标量值的操作（主要是加载和存储指令）使用名称Q*n*来表示标量值，而不是V*n*（向量值）。
- en: 11.3 Vector Data Movement Instructions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3 向量数据移动指令
- en: Move instructions are the most common integer and floating-point instructions
    you’ll use in the Neon instruction set. In this section, you’ll learn how to use
    these instructions to move data between registers, load constants into Neon registers,
    and load and store vector registers to and from memory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 移动指令是 Neon 指令集中的最常见整数和浮点指令。在这一节中，你将学习如何使用这些指令在寄存器之间移动数据、将常量加载到 Neon 寄存器中，以及将向量寄存器从内存加载和存储。
- en: 11.3.1 Data Movement Between Registers
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1 寄存器之间的数据传输
- en: 'You can use the mov instruction to move data between vector registers. Unfortunately,
    the obvious syntax won’t work:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 mov 指令在向量寄存器之间移动数据。不幸的是，显然的语法无法正常工作：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mov instruction copies elements of a vector into a vector register. It can
    copy data between two vector registers or data between a general-purpose (X*n*
    or W*n*) register and a vector register. The exact syntax depends on how much
    data you’re copying and the location of the source and destination registers (vector
    or general-purpose).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: mov 指令将向量元素复制到向量寄存器。它可以在两个向量寄存器之间复制数据，或者在通用寄存器（X*n* 或 W*n*）和向量寄存器之间复制数据。具体语法取决于你要复制的数据量以及源寄存器和目标寄存器的位置（向量寄存器或通用寄存器）。
- en: 'Moving data from a 32-bit general-purpose register (W*m*) into a vector register
    (V*n*) uses one of the following syntaxes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从 32 位通用寄存器（W*m*）移动到向量寄存器（V*n*）使用以下语法之一：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The index i must be a literal integer constant, as demonstrated in the following
    examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 索引 i 必须是一个字面整数常量，如下例所示：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moving data from a 64-bit general-purpose register (X*m*) into a vector register
    (V*n*) uses the following syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从 64 位通用寄存器（X*m*）移动到向量寄存器（V*n*）使用以下语法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve used the word *inserts* in these examples because the mov instruction copies
    only the byte, hword, word, or dword into the vector register at the index that
    *i* specifies. It does not affect the other data in V*n*. For example
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这些示例中使用了*插入*这个词，因为 mov 指令只将字节、半字、字或双字复制到向量寄存器中，由索引 *i* 指定的位置。它不会影响 V*n* 中的其他数据。例如：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: inserts only the LO byte from W0 into lane 4 in the V0 register; it leaves all
    other bytes in V0 unchanged. Moving bytes, hwords, and words is possible only
    when using the W*m* register; if you use X*m* in the instruction, you can move
    only 64 bits. The type specification for the vector register is S (single-precision)
    for 32 bits and D (double-precision) for 64 bits. You use this designation even
    when copying 32-bit and 64-bit integers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只将 W0 中的 LO 字节插入到 V0 寄存器的第 4 个 lane；它不会更改 V0 中的其他字节。只有使用 W*m* 寄存器时，才能移动字节、半字和字。如果你在指令中使用
    X*m*，你只能移动 64 位。向量寄存器的类型指定为 S（单精度）用于 32 位，D（双精度）用于 64 位。即使是在复制 32 位和 64 位整数时，你也要使用这个指定。
- en: NOTE
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The ARM instruction* ins *(insert) is a synonym for* mov *when copying data
    from a general-purpose register to a vector register—yet another reason for saying
    these instructions* insert *data rather than saying they* copy *data.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*ARM 指令* ins *(插入) 是* mov *的同义词，用于将数据从通用寄存器复制到向量寄存器——这也是我们说这些指令*插入*数据而不是说它们*复制*数据的另一个原因。*'
- en: 'The previous examples copy the value from a 32- or 64-bit general-purpose register
    into a vector register. You can also copy data from one vector register (V*n*)
    to another (V*m*) by using the following syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将值从 32 位或 64 位通用寄存器复制到向量寄存器。你还可以通过以下语法将数据从一个向量寄存器（V*n*）复制到另一个向量寄存器（V*m*）：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These instructions copy 64 bits (8 bytes, four half words, two words, or a
    single dword) or 128 bits (16 bytes, eight half words, four words / single-precision
    values, or two dwords / double-precision values) from one vector register to another.
    In theory, you should be able to enter something like mov v1, v0 or mov q1, q0
    to move the contents of the 128-bit vector register V0 (Q0) into V1 (Q1). Sadly,
    Gas does not accept this syntax, so you’ll have to use one of the previous four
    instructions, as in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将 64 位（8 字节，四个半字，两个字或一个双字）或 128 位（16 字节，八个半字，四个单精度值或两个双字/双精度值）从一个向量寄存器复制到另一个向量寄存器。理论上，你应该能够输入类似
    mov v1, v0 或 mov q1, q0 的语法，将 128 位向量寄存器 V0（Q0）的内容移动到 V1（Q1）。可惜的是，Gas 不接受这种语法，因此你需要使用之前的四个指令之一，如下例所示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also extract a single byte from one vector register and insert it in
    an arbitrary lane in another vector register, using the following syntax
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从一个向量寄存器中提取单个字节，并使用以下语法将其插入到另一个向量寄存器的任意 lane 中：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where i2 is the index of a byte in the source vector and i1 is the destination
    index. Both indices must be in the range 0 to 15.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `i2` 是源向量中字节的索引，`i1` 是目标索引。两个索引必须在 0 到 15 的范围内。
- en: 'You can also extract a half word from one vector and insert that into another:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从一个向量中提取半字并将其插入到另一个向量中：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The rules are the same for bytes, except that the two index values must be in
    the range 0 to 7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字节，规则相同，只是两个索引值必须在 0 到 7 的范围内。
- en: 'You can copy words (single-precision values) and dwords (double-precision values)
    by using the following syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语法复制字（单精度值）和双字（双精度值）：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s an example that copies the LO dwords of V0 and V1 merges them into the
    two dwords in V2:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示了如何将 V0 和 V1 的低 64 位（LO dwords）复制并合并到 V2 的两个 64 位中：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Thus far, I’ve described how to move data from a general-purpose register to
    a vector register and between two vector registers. The only missing combination
    is moving data from a vector register to a general-purpose register, handled by
    the following mov, umov, and smov instructions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经描述了如何将数据从通用寄存器移动到向量寄存器，以及在两个向量寄存器之间移动数据。唯一缺少的组合是将数据从向量寄存器移动到通用寄存器，这是通过以下的
    `mov`、`umov` 和 `smov` 指令来实现的：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are no 8- or 16-bit zero extensions to 64 bits. Zero-extending into W*n*
    automatically zero-extends all the way through the upper 32 bits of X*n*. Here
    are some examples of these instructions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 没有将 8 位或 16 位扩展到 64 位的零扩展操作。将数据零扩展到 W*n* 会自动将零扩展到 X*n* 的上 32 位。以下是这些指令的示例：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that smov x1, v0.s[3] is moving an integer value, even though the specified
    type is S (single-precision).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`smov x1, v0.s[3]` 是将一个整数值移动到寄存器中，尽管指定的类型是 S（单精度）。
- en: 11.3.2 Vector Load Immediate Instructions
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2 向量加载立即数指令
- en: The ARM CPU provides a limited set of instructions that allow you to load certain
    immediate constants into a vector register. The integer versions of these instructions
    allow only an unsigned 8-bit immediate operand that can be used as is or shifted
    to the left 1, 2, or 3 bytes (filling vacated positions with 0s or 1s). Furthermore,
    these immediate instructions copy the data into every lane of a byte array, half-word
    array, or word array. The floating-point versions of these instructions allow
    a limited set of floating-point constants (the same limitations as for scalar
    floating-point constants; see section 6.9.1.4, “fmov with Immediate Operand,”
    on [page 334](chapter6.xhtml#pg_334)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 提供了一组有限的指令，允许将某些立即数常量加载到向量寄存器中。这些指令的整数版本只允许使用无符号的 8 位立即操作数，可以直接使用或左移
    1、2 或 3 字节（用 0 或 1 填充空出的位）。此外，这些立即数指令将数据复制到字节数组、半字数组或字数组的每个通道中。浮点版本的这些指令允许有限的浮点常量（与标量浮点常量的限制相同；请参见第
    6.9.1.4 节“带立即操作数的 fmov”在[第 334 页](chapter6.xhtml#pg_334)）。
- en: The standard *move immediate* instruction is movi
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 *立即数移动* 指令是 `movi`。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'where size is 16B, 8B, 4H, 8H, 2S, or 4S; uimm8 is an 8-bit constant; and uimm64
    is either 0 or 0xFFFFffffFFFFffff. The lsl #c component is optional for instructions
    with 4H, 8H, 2S, and 4S sizes. The msl #c option is optional for 2S and 4S sizes.
    The movi instructions initialize all lanes in the vector register, or just the
    lanes in the LO 64 bits, with the specified immediate constant. The following
    paragraphs describe the specific variants of each of these instructions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，size 可以是 16B、8B、4H、8H、2S 或 4S；`uimm8` 是一个 8 位常量；`uimm64` 是 0 或 0xFFFFffffFFFFffff。对于
    4H、8H、2S 和 4S 大小的指令，`lsl #c` 组件是可选的。对于 2S 和 4S 大小，`msl #c` 选项是可选的。`movi` 指令将指定的立即数初始化到向量寄存器的所有通道中，或者只初始化
    LO 64 位的通道。接下来的段落将描述每个指令的具体变体。'
- en: 'The movi Vn.8B, #uimm8 instruction fills each of the LO 8 bytes of V*n* with
    the specified constant and the HO 64 bits of the register with 0s. For example'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`movi Vn.8B, #uimm8` 指令将指定的常量填充到 V*n* 的 LO 8 字节中，并将寄存器的 HO 64 位填充为 0。例如：'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: loads 0x80808080 into V0.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将 0x80808080 加载到 V0 中。
- en: 'The movi Vn.16B, #uimm8 instruction fills all 16 bytes of V*n* with the specified
    constant. Each lane receives a copy of the uimm8 value.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`movi Vn.16B, #uimm8` 指令将指定的常量填充到 V*n* 的所有 16 个字节中。每个通道都会接收 `uimm8` 值的副本。'
- en: 'The movi Vn.4H, #uimm8 instruction fills the four hword lanes in the LO 64
    bits of V*n* with a copy of the uimm8 constant, and fills the HO 64 bits of V*n*
    with 0\. Because this instruction accepts only 8-bit immediate constants, the
    HO 8 bits of each half-word lane will contain 0s. For example'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`movi Vn.4H, #uimm8` 指令将指定的 `uimm8` 常量填充到 V*n* 的 LO 64 位中的四个半字通道，并将 V*n* 的
    HO 64 位填充为 0。由于该指令仅接受 8 位立即数常量，因此每个半字通道的 HO 8 位将包含 0。例如：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: loads 0x0001000100010001 into V1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将 0x0001000100010001 加载到 V1。
- en: 'The movi Vn.4H, #uimm8, lsl #0 instruction is identical to movi Vn.4H, #uimm8*.*
    If the shift constant is #8, this instruction shifts the immediate constant to
    the left eight positions before storing it into the four half-word lanes (in the
    LO 64 bits of V*n*). In this case, the LO 8 bits of each of these lanes will contain
    0s. For example'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'movi Vn.4H, #uimm8, lsl #0 指令与 movi Vn.4H, #uimm8 完全相同。如果移位常量是 #8，则该指令将在将立即数存储到四个半字通道（V*n*
    的低 64 位）之前，将立即数向左移位 8 个位置。在这种情况下，这些通道的每个低 8 位将包含 0。例如：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: loads 0x0100010001000100 into V1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将 0x0100010001000100 加载到 V1。
- en: 'The movi Vn.8H, #uimm8 and movi Vn.8H, #uimm8, lsl #c instructions do the same
    thing as the 4H instructions, except that they store the immediate constant (shifted
    by 0 or 8 bits) into all eight lanes of the V*n* register.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'movi Vn.8H, #uimm8 和 movi Vn.8H, #uimm8, lsl #c 指令与 4H 指令做的事情相同，唯一不同的是它们将立即数（通过
    0 或 8 位移位）存储到 V*n* 寄存器的所有八个通道中。'
- en: 'The movi Vn.2S, #uimm8 instruction fills the two word (single-precision) lanes
    in the LO 64 bits of V*n* with a copy of the uimm8 constant, and fills the HO
    64 bits of V*n* with 0\. Because this instruction accepts only 8-bit immediate
    constants, the HO 24 bits of each word lane will contain 0s. Although the type
    specification is S, this instruction assigns integer constants, not floating-point
    constants, to the lanes. If the optional shift clause is present (movi Vn.2S,
    #uimm8, lsl #c, where c is 0, 8, 16, or 24), this instruction will shift the 8-bit
    constant by the specified number of bits before storing the constant into the
    two lanes. Here are a few examples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'movi Vn.2S, #uimm8 指令将 V*n* 的低 64 位中的两个字（单精度）通道填充为 uimm8 常量，并将 V*n* 的高 64 位填充为
    0。因为该指令仅接受 8 位立即数常量，所以每个字通道的高 24 位将包含 0。尽管类型说明符为 S，但该指令为通道分配的是整数常量，而非浮点常量。如果存在可选的移位子句（movi
    Vn.2S, #uimm8, lsl #c，其中 c 是 0、8、16 或 24），该指令将在将常量存储到两个通道之前，按指定的位数移位 8 位常量。以下是一些示例：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The movi Vn.2S, #uimm8, msl #c instruction is almost identical to its lsl counterpart,
    except it shifts 1 bits rather than 0 bits into the vacated positions during the
    shift-left operation. The shift count is limited to 8 or 16 rather than 0, 8,
    16, and 24 (an annoying inconsistency). For example'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'movi Vn.2S, #uimm8, msl #c 指令几乎与其 lsl 对应指令相同，唯一的区别是它在左移操作中将 1 位而非 0 位移入空出的位。移位计数限制为
    8 或 16，而不是 0、8、16 和 24（一个令人烦恼的不一致）。例如：'
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: loads 0x0001FFFF0001FFFF into V5.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将 0x0001FFFF0001FFFF 加载到 V5。
- en: 'The movi Vn.4S, #uimm8 instruction fills the four word (single-precision) lanes
    in V*n* with a copy of the uimm8 constant. Otherwise, this instruction (and the
    variant with shifting) behaves identically to the 2S version.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'movi Vn.4S, #uimm8 指令将 uimm8 常量复制到 V*n* 中的四个字（单精度）通道。否则，该指令（以及带移位的变体）与 2S 版本的行为完全相同。'
- en: 'The movi Vn.2D, #uimm64 instruction loads one of two constants (0 or –1) into
    the two dword lanes of the V*n* register. Once again, keep in mind that these
    are integer constants, not floating-point constants, despite the use of the 2D
    type specifier.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'movi Vn.2D, #uimm64 指令将常量 0 或 -1 加载到 V*n* 寄存器的两个双字通道中。再次提醒，这些是整数常量，而不是浮点常量，尽管使用了
    2D 类型说明符。'
- en: The second move immediate instruction is mvni (move and *not* immediate). It
    supports the following syntax
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条立即数移动指令是 mvni（移动并*非*立即数）。它支持以下语法：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: where size and uimm8 have the same meanings as given for movi.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，size 和 uimm8 的含义与 movi 中给出的含义相同。
- en: 'The operations are the same as for movi, except that mvni inverts all the bits
    before storing them into the lanes of the V*n* destination register. The HO 64
    bits of V*n* still receive 0s for the 4H and 2S type specifiers, as shown in the
    following examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 操作与 movi 相同，不同之处在于 mvni 在将数据存储到 V*n* 目标寄存器的通道中之前，会将所有位反转。V*n* 的高 64 位仍会为 4H
    和 2S 类型说明符接收 0，如以下示例所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the absence of the 2D types for the mvni instruction. These instructions
    are unnecessary because the two allowable movi uimm64 constants are already the
    inverse of each other. If you want inverted bits, just use the other uimm64 constant
    (0 versus –1) with the movi instruction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 mvni 指令没有 2D 类型。这些指令是不必要的，因为两个允许的 movi uimm64 常量已经是彼此的反向。如果你想要反转的位，只需使用另一个
    uimm64 常量（0 与 -1）并结合 movi 指令使用。
- en: 'The third form of the move immediate instruction, fmov, allows you to load
    certain floating-point constants into the lanes of a vector register. The allowable
    syntax is the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 移动立即数指令的第三种形式，fmov，允许你将某些浮点常量加载到向量寄存器的各个通道中。允许的语法如下：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The floating-point immediate constant (fimm) must be a value defined by
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点立即数常量（fimm）必须是由以下方式定义的值
- en: ±*n* ÷ 16 × 2*r*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ±*n* ÷ 16 × 2*r*
- en: 'where 16 ≤ *n* ≤ 31 and –3 ≤ *r* ≤ 4\. You cannot represent 0.0 with this formula;
    if you need to load 0.0 into the lanes of a vector register, just load the integer
    constant 0 into those lanes by using the movi instruction (all 0 bits is 0.0):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 16 ≤ *n* ≤ 31 且 –3 ≤ *r* ≤ 4。你不能通过此公式表示 0.0；如果需要将 0.0 加载到向量寄存器的各个通道中，只需使用
    movi 指令将整数常量 0 加载到这些通道（所有位为 0 即为 0.0）：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The move immediate instructions load only certain constant values into the
    vector registers. The following are the exact values you can load as immediate
    floating-point constants (Gas will accept only these values):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 移动立即数指令只将某些常量值加载到向量寄存器中。以下是你可以作为立即数浮点常量加载的确切值（Gas 只接受这些值）：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Based on the way programs typically use the Neon registers, this is a reasonable
    set of values, which can be encoded into a 32-bit instruction opcode. To load
    larger or different constants, see section 11.3.4, “Vector Load and Store,” on
    the next page.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于程序通常使用 Neon 寄存器的方式，这是一个合理的值集合，可以编码成 32 位指令操作码。要加载更大或不同的常量，请参见下一页第 11.3.4 节，“向量加载与存储”。
- en: 11.3.3 Register or Lane Value Duplication
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3 寄存器或通道值复制
- en: 'The dup instruction allows you to duplicate a value held in a general-purpose
    register or in a single lane of a vector register, throughout all the lanes in
    a vector register. This instruction supports the following forms:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: dup 指令允许你将保存在通用寄存器或向量寄存器单一通道中的值复制到向量寄存器的所有通道中。此指令支持以下形式：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first instruction in each pair duplicates only data in the LO 64 bits of
    V*n*; the second instruction of each pair copies a full 128 bits. The two single
    instructions copy 128 bits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每对指令中的第一条指令仅复制 V*n* 的 LO 64 位数据；每对指令中的第二条指令复制完整的 128 位数据。这两条单独的指令复制 128 位数据。
- en: 11.3.4 Vector Load and Store
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.4 向量加载与存储
- en: The mov, movi, mvni, fmov, and dup instructions can move data between vector
    registers and between general-purpose and vector registers, and can load constants
    into vector registers. However, they don’t allow you to load a register from memory
    or store the value held in a vector register to memory. The Neon instruction set
    provides several load and store instructions to handle these tasks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: mov、movi、mvni、fmov 和 dup 指令可以在向量寄存器之间以及在通用寄存器和向量寄存器之间移动数据，并且可以将常量加载到向量寄存器中。然而，它们不允许你从内存加载寄存器或将向量寄存器中的值存储到内存中。Neon
    指令集提供了几条加载和存储指令来处理这些任务。
- en: Because the load and store instructions are the most fundamental, this section
    considers them first. To load or store an entire 128-bit vector register, use
    the following syntax
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为加载和存储指令是最基础的，所以本节首先讨论它们。要加载或存储整个 128 位的向量寄存器，请使用以下语法
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where memory is one of the usual ARM memory addressing modes (same as for the
    scalar ldr and str instructions). Note the use of Q*n* to denote the register
    (rather than V*n*). This is one of the few places the Q*n* register is legal (one
    wonders why they didn’t just use V*n*). These instructions will load or store
    a full 16 bytes, that is, 128 bits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中内存是常见的 ARM 内存寻址模式之一（与标量 ldr 和 str 指令相同）。注意使用 Q*n* 来表示寄存器（而非 V*n*）。这是 Q*n*
    寄存器合法使用的少数几个地方之一（让人想知道为什么不直接使用 V*n*）。这些指令将加载或存储完整的 16 字节，即 128 位。
- en: 'The stp instructions also allow vector register (Q*n*) operands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: stp 指令还允许使用向量寄存器（Q*n*）操作数：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that n and m in these instructions don’t have to be consecutive numbers
    but can be any arbitrary value in the range 0 to 31.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些指令中的 n 和 m 不必是连续的数字，而可以是 0 到 31 范围内的任意值。
- en: 11.3.5 Interleaved Load and Store
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5 交错加载与存储
- en: The Neon instruction set provides load and store instructions that load data
    into a single lane across multiple vector registers. These instructions load interleaved
    data from memory into one, two, three, or four vector registers. The load (ld1,
    ld2, ld3, and ld4) and store (st1, st2, st3, and st4) instructions support non-interleaved
    data, pairs of interleaved data, triplets of interleaved data, and quad-interleaved
    data, respectively. The following subsections describe these types of interleaved
    load and store instructions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Neon 指令集提供了加载和存储指令，将数据加载到多个向量寄存器的单个通道中。这些指令从内存加载交错的数据到一个、两个、三个或四个向量寄存器中。加载（ld1、ld2、ld3
    和 ld4）和存储（st1、st2、st3 和 st4）指令分别支持非交错数据、交错数据对、交错数据三元组和交错数据四元组。以下小节将描述这些类型的交错加载和存储指令。  '
- en: '##### 11.3.5.1 Interleaved Load and Store Addressing Modes'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 11.3.5.1 交错加载和存储寻址模式  '
- en: The interleaved load and store instructions access memory, but they do not support
    the full set of ARM memory addressing modes, just three
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '交错的加载和存储指令访问内存，但它们不支持 ARM 内存寻址模式的完整集合，仅支持三种  '
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where instr is one of ldn/stn and register_list is a comma-separated set of
    Q*n* registers that the load and store instructions will use when loading data
    from, or storing data to, memory. (The following sections discuss register _list
    at greater length.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，instr 是 ldn/stn 之一，register_list 是一个以逗号分隔的 Q*n* 寄存器集合，加载和存储指令将在从内存加载数据或向内存存储数据时使用这些寄存器。（以下章节将更详细地讨论寄存器
    _list。）  '
- en: The standard register-indirect addressing mode is[Xn]. The ldn/stn instructions
    will access the data at the memory address held in general-purpose register X*n*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '标准的寄存器间接寻址模式是[Xn]。ldn/stn 指令将访问存储在通用寄存器 X*n* 中的内存地址的数据。  '
- en: The [Xn], Xm addressing mode computes its effective address as the sum of the
    values in X*n* and X*m*. This is a post-increment addressing mode; immediately
    after accessing the specified memory address, this mode adds the value of X*m*
    to X*n*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], Xm 寻址模式将有效地址计算为 X*n* 和 X*m* 中值的和。这是一个后增量寻址模式；在访问指定的内存地址后，立即将 X*m* 的值加到
    X*n* 中。  '
- en: 'The [Xn], #imm addressing mode is also a post-increment addressing mode, which
    computes its effective address as the sum of Xn + imm, then adds the immediate
    constant to X*n* after referencing the address. The immediate value is limited
    to the constants 1, 2, 4, 8, 16, 32, 48, or 64, where the register_list operand(s)
    determines the value you must use. The following sections describe the allowable
    immediate constants for each version of the instruction.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], #imm 寻址模式也是一种后增量寻址模式，它将有效地址计算为 Xn + imm 的和，然后在引用地址后将立即数加到 X*n* 中。立即数的值限制为常数
    1、2、4、8、16、32、48 或 64，register_list 操作数决定了你必须使用的值。以下章节将描述每个版本指令的允许立即常数。  '
- en: 11.3.5.2 ld1/st1
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '11.3.5.2 ld1/st1  '
- en: The ld1 instruction loads one to four registers with data from sequential (non-interleaved)
    memory locations. With a single vector register, the syntax for this instruction
    is the following
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'ld1 指令从顺序（非交错）内存位置加载一到四个寄存器的数据。使用单一向量寄存器时，该指令的语法如下  '
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'where memory is one of the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，memory 是以下之一：  '
- en: '[Xn]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn]  '
- en: '[Xn], Xm'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], Xm  '
- en: '[Xn], #imm'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn], #imm  '
- en: The imm operand, if present, must match the size of the register operand. That
    is, for B it must be 1; for 8B, 8; for 16B, 16; for H, 2; and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '如果存在 imm 操作数，它必须与寄存器操作数的大小匹配。也就是说，对于 B 必须是 1；对于 8B，必须是 8；对于 16B，必须是 16；对于 H，必须是
    2；依此类推。  '
- en: The ld1 instruction with the {Vn.8B} register list operand loads 8 bytes into
    the LO 64 bits of V*n*, while the {Vn.16B} register list operand loads 16 bytes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 {Vn.8B} 寄存器列表操作数的 ld1 指令将 8 字节数据加载到 V*n* 的低 64 位中，而 {Vn.16B} 寄存器列表操作数则加载
    16 字节。
- en: With a 4H or 2S type specification, the ld1 register also loads 64 bits (four
    hwords or two words) into the LO 64 bits of V*n*. With an 8H or 4S type, the ld1
    instruction loads 128 bits into V*n*. Although the 8B, 4H, and 2S types and the
    16B, 8H, 4S, and 2D types seem to be interchangeable (they load the same amount
    of data into V*n*), you should aim to pick the most appropriate type for the data
    you’re manipulating. Not only does this improve your documentation, but also the
    internal microarchitecture of the ARM CPU might be able to optimize its operations
    better based on the type of data you are using.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 4H 或 2S 类型说明时，ld1 寄存器还会将 64 位（四个 hword 或两个 word）加载到 V*n* 的 LO 64 位中。使用 8H
    或 4S 类型时，ld1 指令将 128 位数据加载到 V*n* 中。虽然 8B、4H 和 2S 类型与 16B、8H、4S 和 2D 类型看起来可以互换（它们将相同量的数据加载到
    V*n* 中），但你应该尽量选择最适合你操作数据的类型。这样不仅能提高文档的质量，还有助于 ARM CPU 的内部微架构根据你使用的数据类型更好地优化其操作。
- en: With the bare B, H, S, or D type specification, the ld1 instruction loads a
    single lane in V*n* with data from memory. This operation does not affect the
    data in the other lanes in V*n*. This is the most important variant of the ld1
    instruction because it allows you to build up data in a vector register one lane
    at a time from different locations in memory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用裸 B、H、S 或 D 类型说明时，ld1 指令从内存中加载 V*n* 中的单个 lane 数据。此操作不会影响 V*n* 中其他 lanes 的数据。这是
    ld1 指令最重要的变种，因为它允许你一次从内存的不同位置将数据逐步构建到向量寄存器中的每个 lane。
- en: 'Why does the ld1 instruction require braces around the vector register specification?
    The destination operand of this instruction is actually a register *list*. You
    can specify one to four registers in this list, as shown in the following examples:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 ld1 指令需要在向量寄存器规格说明周围加上大括号？该指令的目标操作数实际上是一个寄存器*列表*。你可以在这个列表中指定一个到四个寄存器，如下所示的示例：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The registers that may appear in this list have two restrictions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表中可以出现的寄存器有两个限制：
- en: They must be consecutively numbered registers (with V0 being the successor to
    V31).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须是连续编号的寄存器（V0 紧随 V31 之后）。
- en: The type specifications must be identical for all registers in the list.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中所有寄存器的类型说明必须相同。
- en: If you have two or more consecutively numbered registers in a list, you can
    use the shorthand
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中有两个或更多连续编号的寄存器，你可以使用简写形式：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'where m is 1, 2, or 3, and t is one of the usual vector types, as shown in
    the following examples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 m 是 1、2 或 3，t 是常见的向量类型之一，如下所示的示例：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you specify more than one register in the list, the ld1 instruction will
    load values from consecutive locations into the register. For example, the following
    code will load V0 from the 16 bytes at the address held in X0, V1 from the 16
    bytes at X0 + 16, and V2 from the 16 bytes at X0 + 32:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在列表中指定多个寄存器时，ld1 指令将从连续的位置加载值到寄存器中。例如，以下代码将从 X0 持有的地址加载 V0，加载 16 字节的数据；从 X0
    + 16 加载 V1，加载 16 字节的数据；从 X0 + 32 加载 V2，加载 16 字节的数据：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The st1 instruction supports an identical instruction syntax (except, of course,
    you substitute the st1 mnemonic for ld1). It stores the contents of the register(s)
    or lanes from those registers into the specified memory location. Here is an example
    that demonstrates storing the values in V0 and V1 to the location specified by
    X0:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: st1 指令支持相同的指令语法（当然，你需要将 st1 助记符替换为 ld1）。它将寄存器中的内容或寄存器中的某些 lane 数据存储到指定的内存位置。下面是一个示例，演示了将
    V0 和 V1 的值存储到由 X0 指定的位置：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This instruction stores the value in V0 at the address held in X0, and the value
    in V1 to address X0 + 16.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将 V0 中的值存储到 X0 所持有的地址，并将 V1 中的值存储到地址 X0 + 16。
- en: 11.3.5.3 ld2/st2
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.5.3 ld2/st2
- en: The ld2 and st2 instructions load and store interleaved data. These two instructions
    use the following syntax
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ld2 和 st2 指令用于加载和存储交错数据。这两个指令使用以下语法：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: where the register list must contain exactly two registers, and their register
    numbers must be consecutive. The t1 size is 8B, 16B, 4H, 8H, 2S, 4S, or 2D, while
    t2 is B, H, S, or D. The literal constant index is an appropriate lane number
    for the type’s size (0 to 15 for B, 0 to 7 for H, 0 to 3 for S, and 0 to 1 for
    D). Finally, memory is one of the addressing modes described in section 11.3.5.1,
    “Interleaved Load and Store Addressing Modes,” on [page 633](chapter11.xhtml#pg_633).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其中寄存器列表必须包含恰好两个寄存器，并且它们的寄存器编号必须是连续的。t1 大小为 8B、16B、4H、8H、2S、4S 或 2D，而 t2 则是 B、H、S
    或 D。字面常数索引是该类型大小的合适 lane 编号（B 为 0 到 15，H 为 0 到 7，S 为 0 到 3，D 为 0 到 1）。最后，内存是[第
    633 页](chapter11.xhtml#pg_633)中描述的寻址模式之一，详见第 11.3.5.1 节，“交错加载和存储寻址模式”。
- en: The variants with index (which load a single lane into the two registers) load
    the first register’s lane from the specified memory address and load the second
    register’s lane n bytes later (where n is the size of the lane, in bytes).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 带索引的变种（加载一个通道到两个寄存器）将从指定的内存地址加载第一个寄存器的通道，并在 n 字节后加载第二个寄存器的通道（其中 n 是通道的大小，以字节为单位）。
- en: 'The ld2 instruction with the t1 type specification (8B, 16B, 4H, 8H, and so
    on), meanwhile, loads the two registers one value at a time (of the specified
    type: B, H, S, or D), alternating destination lanes between the two registers.
    For example'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 t1 类型规格的 ld2 指令（例如 8B、16B、4H、8H 等），同时一次加载两个寄存器的一个值（指定类型：B、H、S 或 D），并交替将目标通道分配给两个寄存器。例如
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: loads the LO 8 bytes of V0 from memory locations X0, X0 + 2, X0 + 4, X0 + 6,
    X0 + 8, X0 + 10, X0 + 12, and X0 + 14\. It loads the LO 8 bytes of V1 from locations
    X0 + 1, X0 + 3, X0 + 5, X0 + 7, X0 + 9, X0 + 11, X0 + 13, and X0 + 15\. This deinterleaves
    the data in memory, loading the even bytes into V0 and the odd bytes into V1\.
    [Figure 11-4](chapter11.xhtml#fig11-4) shows how ld2 extracts interleaved data
    from X0 and stores the deinterleaved results in V0 and V1.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存位置 X0、X0 + 2、X0 + 4、X0 + 6、X0 + 8、X0 + 10、X0 + 12 和 X0 + 14 加载 V0 的 LO 8
    字节。它从位置 X0 + 1、X0 + 3、X0 + 5、X0 + 7、X0 + 9、X0 + 11、X0 + 13 和 X0 + 15 加载 V1 的 LO
    8 字节。这样就解交错了内存中的数据，将偶数字节加载到 V0 中，将奇数字节加载到 V1 中。[图 11-4](chapter11.xhtml#fig11-4)
    显示了 ld2 如何从 X0 提取交错数据，并将解交错的结果存储到 V0 和 V1 中。
- en: '![](../images/Figure11-4.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-4.jpg)'
- en: 'Figure 11-4: The ld2 deinterleaving operation'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：ld2 解交错操作
- en: If you specify the half-word type (4H or 8H), the ld2 instruction deinterleaves
    16-bit values (even and odd half words). This is particularly useful for deinterleaving
    digital audio tracks that interleave left and right channels (16 bits per sample).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了半字类型（4H 或 8H），则 ld2 指令将对 16 位值进行解交错（偶数和奇数半字）。这对于解交错左右声道的数字音频轨道（每个样本 16
    位）特别有用。
- en: If you specify 2S/4S or 2D, this instruction will deinterleave words or dwords.
    For example, if you have an array of floating-point complex numbers, the ld2 instruction
    can deinterleave the real and imaginary components.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了 2S/4S 或 2D，这个指令将解交错字或双字。例如，如果你有一个浮点复数数组，ld2 指令可以解交错实部和虚部。
- en: Because ld2 deinterleaves pairs of objects, the register list must contain exactly
    two registers. The assembler will reject any other number of registers in the
    list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ld2 解交错的是成对的对象，寄存器列表必须恰好包含两个寄存器。汇编器会拒绝任何其他数量的寄存器列表。
- en: The st2 instruction uses the same syntax (except, of course, substituting st2
    for ld2). This instruction stores data lanes of the specified type from two registers
    into memory, interleaving the data between the two registers. The store operation
    is basically reversing the arrows in [Figure 11-4](chapter11.xhtml#fig11-4) (that
    is, copying the data from V0 and V1 into X0, interleaving the two data sets).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: st2 指令使用相同的语法（当然是将 st2 替换为 ld2）。该指令将指定类型的两个寄存器中的数据通道存储到内存中，交错存储这两个寄存器之间的数据。存储操作基本上是反转了[图
    11-4](chapter11.xhtml#fig11-4)中的箭头（即将数据从 V0 和 V1 复制到 X0 中，交错这两个数据集）。
- en: 11.3.5.4 ld3/st3
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.5.4 ld3/st3
- en: The ld3 and st3 instructions behave in a similar fashion to ld2/st2, except
    that they (de)interleave three objects in memory rather than two, and the register
    list must contain exactly three registers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ld3 和 st3 指令的行为类似于 ld2/st2，不同之处在于它们（解）交错内存中的三个对象，而不是两个，并且寄存器列表必须包含恰好三个寄存器。
- en: A common example of using the ld3/st3 instructions is to (de)interleave red,
    green, blue (RGB) values consisting of 3 bytes—an 8-bit red, 8-bit green, and
    8-bit blue value—in memory. Using the ld3 instruction, you can deinterleave an
    array of 3-byte RGB values into separate red, green, and blue byte arrays. You
    can use the st3 instruction to interleave red, green, and blue values into an
    RGB array.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ld3/st3 指令的常见示例是将由 3 字节组成的红、绿、蓝（RGB）值进行（解）交错——其中红色、绿色和蓝色值各占 8 位——存储在内存中。使用
    ld3 指令，你可以将由 3 字节 RGB 值组成的数组解交错成独立的红色、绿色和蓝色字节数组。你可以使用 st3 指令将红色、绿色和蓝色值交错成 RGB
    数组。
- en: 11.3.5.5 ld4/st4
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.5.5 ld4/st4
- en: 'Finally, as you’ve probably figured out by now, the ld4 instruction copies
    four consecutive values from memory and stores those values into the same lane
    of the four registers specified by the four-element register list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如你现在可能已经猜到的那样，ld4 指令将从内存中复制四个连续的值，并将这些值存储到由四元素寄存器列表指定的四个寄存器的同一通道中：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This instruction copies the four dwords starting at the address held in X0 into
    lane 0 of V4, V5, V6, and V7, respectively. [Figure 11-5](chapter11.xhtml#fig11-5)
    diagrams how this ld4 instruction operates.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将从X0地址开始的四个dword复制到V4、V5、V6和V7的第0条通道中。[图11-5](chapter11.xhtml#fig11-5)展示了ld4指令的操作方式。
- en: '![](../images/Figure11-5.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-5.jpg)'
- en: 'Figure 11-5: The ld4 instruction operation'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5：ld4指令操作
- en: The ld4/st4 instructions are useful for (de)interleaving data in memory that
    consists of an array of four objects. For example, suppose that you have an array
    of CMYK (cyan-magenta-yellow-black) color pixels in memory, arranged as shown
    in [Figure 11-6](chapter11.xhtml#fig11-6).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ld4/st4指令对于（解）交织由四个对象组成的内存数据非常有用。例如，假设你有一个内存中的CMYK（青色-品红色-黄色-黑色）颜色像素数组，如[图11-6](chapter11.xhtml#fig11-6)所示。
- en: '![](../images/Figure11-6.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-6.jpg)'
- en: 'Figure 11-6: CMYK pixel layout in memory'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-6：内存中的CMYK像素布局
- en: When submitting an image to a printing service, you generally need to provide
    color separations—that is, four separate images consisting only of the cyan pixels,
    magenta pixels, yellow pixels, and black pixels. Therefore, you’ll need to extract
    all the cyan pixels from the full-color image and create a separate image for
    that; likewise for the magenta, yellow, and black pixels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当将图像提交给打印服务时，通常需要提供颜色分离——即四个独立的图像，分别只包含青色像素、品红色像素、黄色像素和黑色像素。因此，你需要从全彩图像中提取所有青色像素，并为其创建一个单独的图像；品红色、黄色和黑色像素也同样需要处理。
- en: You can use the ld4 instruction to extract the cyan, magenta, yellow, and black
    values from the original image and place those pixels in four separate vector
    registers. For example, assuming X0 points at the first CMYK pixel (32 bits) in
    memory
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用ld4指令从原始图像中提取青色、品红色、黄色和黑色的值，并将这些像素放置到四个独立的向量寄存器中。例如，假设X0指向内存中第一个CMYK像素（32位）
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: will extract the 4 bytes pointed at by X0 and distribute them into lane 0 of
    V0 (cyan), V1 (magenta), V2 (yellow), and V3 (black). If you add 4 to X0 and repeat
    this instruction, specifying lane 1 instead of lane 0, this will separate the
    second pixel into lane 1 of V0–V4\. Repeat this 14 more times and you’ll have
    16 cyan pixels in V0, 16 magenta pixels in V1, 16 yellow pixels in V2, and 16
    black pixels in V3\. You can then store away these four registers into the graphic
    image area that will hold the four-color separations. Repeat this process for
    all the pixels in the four-color image and you’ll have your color separations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将提取X0指向的4个字节，并将它们分配到V0（青色）、V1（品红色）、V2（黄色）和V3（黑色）的第0条通道。如果你将X0加4并重复这条指令，指定通道1而不是通道0，这将把第二个像素分离到V0–V4的第1条通道中。再重复14次，你将得到16个青色像素存储在V0中，16个品红色像素存储在V1中，16个黄色像素存储在V2中，16个黑色像素存储在V3中。然后，你可以将这四个寄存器存储到图像区域中，用于保存四种颜色的分离图像。对所有四色图像中的像素重复这个过程，就可以得到你需要的颜色分离。
- en: 'Of course, you can use the 8B and 16B types to process 8 or 16 pixels concurrently:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用8B和16B类型来同时处理8个或16个像素：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This instruction copies 64 bytes into V0, V1, V2, and V3, with every fourth
    byte going into successive lanes in the four registers: V0 gets bytes at offsets
    *i* % 4, V1 gets bytes at offsets (*i* % 4) + 1, and so on, where *i* is the byte
    index into memory.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将64字节复制到V0、V1、V2和V3，每四个字节分别进入四个寄存器的连续通道：V0接收偏移量*i* % 4的字节，V1接收偏移量(*i* % 4)
    + 1的字节，以此类推，其中*i*是内存中的字节索引。
- en: 11.3.5.6 ldnr
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.5.6 ldnr
- en: The ld1, ld2, ld3, and ld4 instructions load the lanes of one to four registers
    with successive values in memory, deinterleaving an array of interleaved objects
    (bytes, hwords, words, or dwords). The ld1r, ld2r, ld3r, and ld4r instructions
    also deinterleave an interleaved object, but the memory object is a single object
    that the instruction replicates through all lanes in the vector register(s).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ld1、ld2、ld3和ld4指令将一个到四个寄存器的通道加载到内存中连续的值，解交织一个交织的对象数组（字节、半字、字或dword）。而ld1r、ld2r、ld3r和ld4r指令也解交织一个交织的对象，但内存对象是一个单一对象，指令会将其复制到所有的向量寄存器通道中。
- en: 'The syntax for these instructions is the same as for the ldn instructions with
    the addition of the r suffix on the mnemonic:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的语法与ldn指令相同，只是在助记符上增加了r后缀：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The .t represents a lane type (more on this in a moment), and memory is the
    usual ldn addressing modes. You can also use the range syntax
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: .t表示通道类型（稍后会详细说明），内存则是常规的ldn寻址模式。你也可以使用范围语法
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: when specifying two or more registers in the list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当在列表中指定两个或更多寄存器时。
- en: 'For these instructions, allowable types are 8B, 16B, 4H, 8H, 2S, 4S, and 2D.
    These type specifications do the following when used with the ld1r instruction:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些指令，允许的类型有 8B、16B、4H、8H、2S、4S 和 2D。当与 ld1r 指令一起使用时，这些类型规格执行以下操作：
- en: 8B loads the first 8 lanes of V*n* with a copy of the byte found at memory,
    replicating that byte in each lane.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8B 将内存中找到的字节复制到 V*n* 的前 8 条道中，并在每条道中复制该字节。
- en: 16B loads all 16 lanes of V*n* with a copy of the byte found at memory, replicating
    that byte in each lane.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16B 将内存中找到的字节复制到 V*n* 的所有 16 条道中，并在每条道中复制该字节。
- en: 4H loads the first 4 lanes of V*n*, replicating the hword found at memory.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4H 将内存中找到的 hword 复制到 V*n* 的前 4 条道中。
- en: 8H loads all 8 lanes of V*n*, replicating the hword found at memory.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8H 将内存中找到的 hword 复制到 V*n* 的所有 8 条道中。
- en: 2S loads the first 2 lanes of V*n*, replicating the word found at memory.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2S 将内存中找到的 word 复制到 V*n* 的前 2 条道中。
- en: 4S loads all 4 lanes of V*n*, replicating the word found at memory.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4S 将内存中找到的 word 复制到 V*n* 的所有 4 条道中。
- en: 2D loads the 2 dword lanes of V*n*, replicating the dword found at memory.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 将内存中找到的 dword 复制到 V*n* 的 2 条 dword 道中。
- en: The ld1r instruction fetches only a single lane value from memory and writes
    it to all the lanes of the destination register. The ld2r instruction fetches
    two lane objects from successive memory locations and replicates the first value
    throughout the first register and the second value throughout the second. The
    ld3r instruction fetches three lane objects from memory and replicates them through
    the first, second, and third registers, respectively. Finally, the ld4r instruction
    fetches four lane objects from memory and uses them to initialize the lanes of
    the four registers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ld1r 指令从内存中只获取单个道的值，并将其写入目标寄存器的所有道。ld2r 指令从连续的内存位置获取两个道对象，并将第一个值复制到第一个寄存器的所有道中，第二个值复制到第二个寄存器的所有道中。ld3r
    指令从内存中获取三个道对象，并将它们分别复制到第一个、第二个和第三个寄存器中。最后，ld4r 指令从内存中获取四个道对象，并将它们用于初始化四个寄存器的道。
- en: 11.3.6 Register Interleaving and Deinterleaving
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.6 寄存器交错与解交错
- en: The ldn/stn and ldnr instructions operate between memory and the vector registers.
    When you want the ability to interleave and deinterleave data appearing in vector
    registers, leaving the result in a vector register, use the trn1, trn2, zip1,
    zip2, uzip1, uzip2, and ext instructions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ldn/stn 和 ldnr 指令在内存和向量寄存器之间操作。当你需要交错和解交错出现在向量寄存器中的数据，并将结果保留在向量寄存器中时，可以使用 trn1、trn2、zip1、zip2、uzip1、uzip2
    和 ext 指令。
- en: 11.3.6.1 trn1 and trn2
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.6.1 trn1 和 trn2
- en: The trn1 and trn2 (transpose) instructions—so called because you can use them
    to transpose the elements of a 2 × 2 matrix (or larger arrays with a little effort)—extract
    data from two source registers and interleave that data into a destination register.
    These instructions use the following syntax
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: trn1 和 trn2（转置）指令——之所以称之为转置，是因为你可以使用它们转置一个 2 × 2 矩阵（或者稍加努力处理更大的数组）中的元素——从两个源寄存器中提取数据，并将这些数据交错到目标寄存器中。这些指令使用以下语法：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. The d (destination), a, and b
    items are register numbers in the range 0 to 31\. These register numbers are arbitrary
    (they don’t have to be consecutive values, as is the case for the ldn/stn and
    ldnr instructions).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 t 可以是 8B、16B、4H、8H、2S、4S 或 2D。d（目标寄存器）、a 和 b 是寄存器编号，范围为 0 到 31。这些寄存器编号是任意的（它们不必是连续的值，正如
    ldn/stn 和 ldnr 指令的情况）。
- en: 'The trn1 instruction copies the data from even-numbered lanes in Va.t into
    the corresponding lanes in Vd.t, and data from even-numbered lanes in Vb.t into
    the odd lanes in Vd.t, while ignoring the odd-numbered lanes in Va.t and Vb.t.
    For example, consider the following instruction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: trn1 指令将 Va.t 中偶数编号道的数据复制到 Vd.t 中对应的道，并将 Vb.t 中偶数编号道的数据复制到 Vd.t 中的奇数道，同时忽略 Va.t
    和 Vb.t 中的奇数编号道。例如，考虑以下指令：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This instruction interleaves the alternate bytes in V2 and V4, leaving the result
    in V0, as shown in [Figure 11-7](chapter11.xhtml#fig11-7).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令交错 V2 和 V4 中的交替字节，将结果保留在 V0 中，如 [图 11-7](chapter11.xhtml#fig11-7) 所示。
- en: '![](../images/Figure11-7.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-7.jpg)'
- en: 'Figure 11-7: The trn1 v0.4s, v2.4s, v4.4s operation'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7：trn1 v0.4s、v2.4s、v4.4s 操作
- en: The trn2 instruction copies the values in the odd lanes in Va.t and Vb.t into
    alternating lanes in Vd.t, as shown in [Figure 11-8](chapter11.xhtml#fig11-8)
    (similar to trn1 except that it swaps the source locations).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: trn2 指令将 Va.t 和 Vb.t 中奇数编号道的值复制到 Vd.t 中交替的道中，如 [图 11-8](chapter11.xhtml#fig11-8)
    所示（与 trn1 类似，只是交换了源位置）。
- en: '![](../images/Figure11-8.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-8.jpg)'
- en: 'Figure 11-8: The trn2 v0.4s, v2.4s, v4.4s operation'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-8：trn2 v0.4s, v2.4s, v4.4s 操作
- en: Consider the 2×2 matrix of double-precision values held in V2 and V3 as shown
    in [Figure 11-9](chapter11.xhtml#fig11-9) (note the positions of the array elements,
    which is different from what you would normally expect).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如 [图 11-9](chapter11.xhtml#fig11-9) 所示的 V2 和 V3 中存储的 2×2 双精度矩阵（注意数组元素的位置，与通常的期望不同）。
- en: '![](../images/Figure11-9.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-9.jpg)'
- en: 'Figure 11-9: A 2×2 matrix held in V2 and V3'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：V2 和 V3 中存储的 2×2 矩阵
- en: 'The following two instructions will transpose this matrix, leaving the result
    in V0 and V1:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个指令将转置此矩阵，并将结果保留在 V0 和 V1 中：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Of course, trn1 and trn2 are generally useful for rearranging and interleaving
    values in the vector registers, even if you aren’t transposing 2×2 matrices.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，trn1 和 trn2 通常用于重新排列和交错向量寄存器中的值，即使你不是在转置 2×2 矩阵。
- en: 11.3.6.2 zip1 and zip2
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.6.2 zip1 和 zip2
- en: 'The zip1 and zip2 instructions are similar to trn1 and trn2 insofar as they
    produce an interleaved result from data taken from two source registers. The name
    *zip* comes from *zipper*: the instruction interleaves lanes just like a zipper
    interleaves the two halves of the connector. Except for the mnemonics, the syntax
    is identical to trn1 and trn2'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: zip1 和 zip2 指令与 trn1 和 trn2 类似，都是从两个源寄存器中获取数据并生成交错结果。*zip* 这个名字来源于 *zipper*（拉链）：指令就像拉链一样将两边的元素交错在一起。除了助记符外，其语法与
    trn1 和 trn2 完全相同。
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D (all types must be the same in
    the instruction).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 t 可以是 8B、16B、4H、8H、2S、4S 或 2D（指令中的所有类型必须相同）。
- en: The zipn and trnn instructions differ in the way they select the source lanes
    to interleave. The zip1 instruction interleaves lane values taken from the beginning
    of the source registers (consuming half the lanes of each source register and
    ignoring the remaining lanes). See [Figure 11-10](chapter11.xhtml#fig11-10) for
    an example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: zipn 和 trnn 指令在选择源通道进行交错时有所不同。zip1 指令从源寄存器的开始部分交错通道值（消耗了每个源寄存器的一半通道并忽略剩余的通道）。参见
    [图 11-10](chapter11.xhtml#fig11-10) 了解示例。
- en: '![](../images/Figure11-10.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-10.jpg)'
- en: 'Figure 11-10: The zip1 v0.4s, v1.4s, v2.4s operation'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-10：zip1 v0.4s, v1.4s, v2.4s 操作
- en: The zip2 instruction works similarly except that it processes the second half
    of the lanes in the source registers. [Figure 11-11](chapter11.xhtml#fig11-11)
    shows an example.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: zip2 指令的工作方式类似，只不过它处理源寄存器中通道的后半部分。[图 11-11](chapter11.xhtml#fig11-11) 显示了一个示例。
- en: '![](../images/Figure11-11.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-11.jpg)'
- en: 'Figure 11-11: The zip2 v0.4s, v1.4s, v2.4s operation'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-11：zip2 v0.4s, v1.4s, v2.4s 操作
- en: As you can see from these figures, the zip1 and zip2 instructions are typically
    what you would use to create interleaved data using only registers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些图中可以看出，zip1 和 zip2 指令通常用于仅使用寄存器创建交错数据。
- en: 11.3.6.3 uzp1 and uzp2
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.6.3 uzp1 和 uzp2
- en: 'The uzp1 and uzp2 (unzip1 and unzip2) instructions are the inverse of zip1
    and zip2. They take interleaved data in two source registers and produce deinterleaved
    data in the destination register. Their syntax is the same as that of the trnn
    and zipn instructions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: uzp1 和 uzp2（unzip1 和 unzip2）指令是 zip1 和 zip2 的逆操作。它们从两个源寄存器中取出交错数据，并在目标寄存器中生成解交错的数据。它们的语法与
    trnn 和 zipn 指令相同：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As usual, t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，t 可以是 8B、16B、4H、8H、2S、4S 或 2D。
- en: The uzp1 instruction copies the even lanes from Va.t into the first half of
    Vd.t, then appends the even lanes of Vb.t to the end of Vd.t. See [Figure 11-12](chapter11.xhtml#fig11-12)
    for an example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: uzp1 指令将 Va.t 中的偶数通道复制到 Vd.t 的前半部分，然后将 Vb.t 中的偶数通道附加到 Vd.t 的末尾。参见 [图 11-12](chapter11.xhtml#fig11-12)
    了解示例。
- en: '![](../images/Figure11-12.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-12.jpg)'
- en: 'Figure 11-12: The uzp1 v0.4s, v1.4s, v2.4s operation'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：uzp1 v0.4s, v1.4s, v2.4s 操作
- en: The uzp2 instruction copies the odd lanes from the source registers. [Figure
    11-13](chapter11.xhtml#fig11-13) shows an example of the uzp2 instruction in action.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: uzp2 指令从源寄存器中复制奇数通道。[图 11-13](chapter11.xhtml#fig11-13) 显示了 uzp2 指令的一个示例。
- en: '![](../images/Figure11-13.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-13.jpg)'
- en: 'Figure 11-13: The uzp2 v0.4s, v1.4s, v2.4s operation'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-13：uzp2 v0.4s, v1.4s, v2.4s 操作
- en: If the type specifier is 64 bits (8B, 4H, or 2S), the uzp1 and uzp2 instructions
    leave 0s in the HO lanes of the destination register.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型说明符是 64 位（8B、4H 或 2S），则 uzp1 和 uzp2 指令会在目标寄存器的高位通道中填充 0。
- en: 11.3.6.4 ext
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.3.6.4 ext
- en: The ext (extract) instruction creates an 8- or 16-byte vector from *n* bytes
    in one vector and 8-*n* (or 16-*n*) bytes from a second vector. This instruction
    allows you to extract an 8- or 16-byte vector from across two vectors. The syntax
    for this instruction is as follows
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ext（提取）指令通过从一个向量中提取 *n* 字节和从第二个向量中提取 8-*n*（或 16-*n*）字节，创建一个 8 字节或 16 字节的向量。此指令允许您从两个向量中提取一个
    8 字节或 16 字节的向量。此指令的语法如下
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: where n is a starting index, Vd is the destination register, and Vs1 and Vs2
    are the source registers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 n 是起始索引，Vd 是目标寄存器，Vs1 和 Vs2 是源寄存器。
- en: 'The ext Vd.8B, Vs1.8B, Vs2.8B, #n instruction fetches the LO n bytes from Vs2
    and copies them to the HO n bytes of the LO 64 bits in Vd*.* It also extracts
    the LO 8-n bytes from Vs1 and copies them to the LO 8-n bytes of Vd. For an example
    of ext, see [Figure 11-14](chapter11.xhtml#fig11-14).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'ext Vd.8B, Vs1.8B, Vs2.8B, #n 指令从 Vs2 中提取 LO n 字节并将其复制到 Vd 中 LO 64 位的 HO n
    字节中*。* 它还从 Vs1 中提取 LO 8-n 字节并将其复制到 Vd 的 LO 8-n 字节中。有关 ext 的示例，请参见 [图 11-14](chapter11.xhtml#fig11-14)。'
- en: '![](../images/Figure11-14.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-14.jpg)'
- en: 'Figure 11-14: The ext v0.8B, v1.8B, v2.8B, #2 instruction'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-14：ext v0.8B, v1.8B, v2.8B, #2 指令'
- en: 'The ext Vd.16B, Vs1.16B, Vs2.16B, #n instruction fetches the LO n bytes from
    Vs2 and copies them to the HO n bytes of Vd*.* It also extracts the LO 16-n bytes
    from Vs1 and copies them to the LO 16-n bytes of Vd (see [Figure 11-15](chapter11.xhtml#fig11-15)
    for an example).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'ext Vd.16B, Vs1.16B, Vs2.16B, #n 指令从 Vs2 中提取 LO n 字节并将其复制到 Vd 的 HO n 字节中*。*
    它还从 Vs1 中提取 LO 16-n 字节并将其复制到 Vd 的 LO 16-n 字节中（有关示例，请参见 [图 11-15](chapter11.xhtml#fig11-15)）。'
- en: '![](../images/Figure11-15.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-15.jpg)'
- en: 'Figure 11-15: The ext v0.16B, v1.16B, v2.16B, #5 instruction'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-15：ext v0.16B, v1.16B, v2.16B, #5 指令'
- en: This instruction supports only the 8B and 16B types. You can easily extract
    hwords, words, or dwords by choosing an appropriate index value (n) that includes
    all the objects you want to extract.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令仅支持 8B 和 16B 类型。通过选择合适的索引值（n），您可以轻松提取 hwords、words 或 dwords，该索引值包含您要提取的所有对象。
- en: 11.3.7 Table Lookups with tbl and tbx
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.7 使用 tbl 和 tbx 进行表查找
- en: The tbl and tbx (table lookup) instructions allow you to exchange all the byte
    values in one register with values taken from a lookup table containing up to
    64 entries. The syntax for these instructions is
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: tbl 和 tbx（表查找）指令允许您用查找表中最多包含 64 个条目的值交换一个寄存器中的所有字节值。这些指令的语法如下
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where table_list is a list of one to four (consecutively numbered) registers,
    all of which must have a 16B type attached to them. (You can also use the Vn.t
    - Vm.t syntax, where m > n and m < (n + 4).) This list of registers provides a
    lookup table that contains 16, 32, 48, or 64 entries. The LO byte of the first
    register is index 0 in the table; the HO byte of the last register is index 15,
    31, 47, or 63 into the table.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 table_list 是一个包含一个至四个（连续编号）寄存器的列表，这些寄存器都必须附加 16B 类型。（您也可以使用 Vn.t - Vm.t 语法，其中
    m > n 且 m < (n + 4)。）这个寄存器列表提供了一个查找表，包含 16、32、48 或 64 个条目。第一个寄存器的 LO 字节是表中的索引
    0；最后一个寄存器的 HO 字节是表中的索引 15、31、47 或 63。
- en: The tbl instruction fetches each byte from the source register (Vs.t) and uses
    its value as an index into the lookup table. It fetches the byte at that index
    from the table and copies it to the corresponding location in the destination
    register—that is, the same byte index from which the source byte was taken; so
    this is equivalent to Vd[i] = table[Vs[i]]. If the value is out of range (greater
    than 15, 31, 47, or 63, depending on the size of the table), the tbl instruction
    stores a 0 into the corresponding location in the destination register. The tbx
    instruction works similarly to tbl, except that it leaves the destination location
    unchanged if the source value is out of range.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: tbl 指令从源寄存器（Vs.t）中提取每个字节，并将其值用作查找表的索引。它从表中提取该索引处的字节，并将其复制到目标寄存器中对应的位置——即与提取源字节相同的字节索引；因此，这相当于
    Vd[i] = table[Vs[i]]。如果值超出范围（大于 15、31、47 或 63，具体取决于表的大小），tbl 指令会在目标寄存器的相应位置存储
    0。tbx 指令的工作方式与 tbl 类似，不同之处在于如果源值超出范围，它会保持目标位置不变。
- en: For very small tables (64 entries or fewer), you can use tbl and tbx to implement
    lookup tables as described in [Chapter 10](chapter10.xhtml). However, the main
    purpose of these two instructions is to provide arbitrary vector permutations
    like the trn1/trn2, zip1/zip2, uzp1/uzp2, and ext instructions. Suppose, for example,
    that you want to reverse the positions of all 16 bytes in a vector register (swapping
    indices 0 and 15, 1 and 14, 2 and 13, 3 and 12, and so on). [Figure 11-16](chapter11.xhtml#fig11-16)
    shows a 16-byte endian swap operation, where the double-ended arrows point to
    the two locations where the bytes are exchanged.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常小的表（64个条目或更少），你可以使用tbl和tbx来实现查找表，如[第10章](chapter10.xhtml)所述。然而，这两个指令的主要目的是提供任意向量排列，例如trn1/trn2、zip1/zip2、uzp1/uzp2和ext指令。例如，假设你想反转向量寄存器中所有16个字节的位置（交换索引0和15，1和14，2和13，3和12，以此类推）。[图11-16](chapter11.xhtml#fig11-16)显示了一个16字节字节序交换操作，双向箭头指向字节交换的两个位置。
- en: '![](../images/Figure11-16.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-16.jpg)'
- en: 'Figure 11-16: A 16-byte endian swap'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-16：16字节字节序交换
- en: If you load a vector register with the following 16-byte value
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你加载一个向量寄存器，包含以下16字节值
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'and then use this value in the source register for the tbl (or tbx) instruction,
    tbl (or tbx) will swap the bytes in a single 16-byte register supplied as the
    table_list, storing the reversed bytes in the destination register. Assuming you’ve
    loaded this value into V0, the following instruction will swap the bytes in {V1},
    placing the results in V2:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在源寄存器中使用该值作为tbl（或tbx）指令，tbl（或tbx）将在作为table_list提供的单个16字节寄存器中交换字节，并将交换后的字节存储到目标寄存器中。假设你已经将该值加载到V0，以下指令将交换{V1}中的字节，将结果放入V2：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After you load V1 with the bytes to be swapped and execute this instruction,
    V2 will contain the swapped values.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将V1加载为待交换的字节并执行此指令后，V2将包含交换后的值。
- en: To use tbl or tbx as a vector permutation instruction, load the permutation
    indexes into the source register (V0 in this example). The indices will always
    be values in the range 0 to 15, to select specific entries in table_list. For
    a true permutation, each of the values (0 to 15) will appear exactly once in the
    source register, and there will always be a single register in the table _list.
    Because you’re limiting the values in the source register to the range 0 to 15,
    the table index values are always in range, so you can use either tbl or tbx.
    Both work exactly the same when the values are not out of range.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要将tbl或tbx用作向量排列指令，请将排列索引加载到源寄存器（此示例中为V0）。索引的值始终在0到15的范围内，用于选择table_list中的特定条目。对于真正的排列，源寄存器中的每个值（0到15）将恰好出现一次，并且表_list中始终只有一个寄存器。因为你将源寄存器中的值限制在0到15的范围内，所以表索引值总是有效的，因此可以使用tbl或tbx。只要值不超出范围，两者的功能是完全相同的。
- en: Of course, you can use any permutation you like by specifying different values
    in the source register. As with the ext instruction, tbl and tbx support only
    the 8B and 16B lane types. However, it’s easy enough to synthesize other types
    (for permutations, anyway) by choosing the positions of the source register lane
    values to permute hwords, words, and dwords. Obviously, for table lookup operations
    (rather than permutations), you’re limited to 8-bit values, so hword, word, and
    dword types don’t make any sense.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过在源寄存器中指定不同的值，使用你喜欢的任何排列方式。与ext指令一样，tbl和tbx仅支持8B和16B通道类型。然而，通过选择源寄存器通道值的位置来排列半字、字和双字，合成其他类型（至少对于排列来说）是相当容易的。显然，对于表查找操作（而不是排列），你仅限于使用8位值，因此半字、字和双字类型没有任何意义。
- en: 11.3.8 Endian Swaps with rev16, rev32, and rev64
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.8 使用rev16、rev32和rev64进行字节序交换
- en: 'The rev16, rev32, and rev64 instructions are similar to their scalar counterparts
    rev16, rev32, and rev (see section 3.3, “Little-Endian and Big-Endian Data Organization,”
    on [page 133](chapter3.xhtml#pg_133)), except, of course, they operate on the
    lanes in a vector source register rather than on a general-purpose integer register.
    Here is their syntax:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: rev16、rev32和rev64指令类似于它们的标量对应指令rev16、rev32和rev（参见第3.3节，“小端和大端数据组织”，[第133页](chapter3.xhtml#pg_133)），当然，它们操作的是向量源寄存器中的通道，而不是通用整数寄存器。它们的语法如下：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The legal types and lane counts for these instructions appear in [Table 11-1](chapter11.xhtml#tab11-1).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的合法类型和通道数量见[表11-1](chapter11.xhtml#tab11-1)。
- en: 'Table 11-1: Legal Types and Lane Counts for rev* Instructions'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1：rev*指令的合法类型和通道数量
- en: '| t | Type and lane count |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| t | 类型和通道数量 |'
- en: '| --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| t1 | 8B, 16B |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| t1 | 8B, 16B |'
- en: '| t2 | 8B, 16B, 4H, or 8H |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| t2 | 8B, 16B, 4H, 或 8H |'
- en: '| t3 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| t3 | 8B, 16B, 4H, 8H, 2S, 或 4S |'
- en: If the lane count and type is 8B, 4H, or 2S, the instruction operates only on
    the LO 64 bits of the source register (and clears the HO 64 bits of the destination
    register). If the lane count and type is 16B, 8H, or 4S, these instructions operate
    on the full 128 bits of the source register.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通道数和类型是8B、4H或2S，指令仅在源寄存器的低64位上操作（并清除目标寄存器的高64位）。如果通道数和类型是16B、8H或4S，这些指令将在源寄存器的128位全范围内进行操作。
- en: 11.4 Vertical and Horizontal Operations
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4 垂直和水平操作
- en: 'Up to this point, vector operations have been *vertical*, meaning they’ve operated
    on the same lane across multiple registers (which, when stacked as appearing in
    most figures thus far, show a vertical operational direction). Consider the following
    vector addition instruction:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，矢量操作是*垂直*的，意味着它们在多个寄存器中的同一通道上进行操作（在大多数图示中，当寄存器按堆叠方式排列时，显示了垂直的操作方向）。考虑以下矢量加法指令：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As for the scalar addition operation (for example, add w0, w1, w2), this instruction
    adds the values of two source registers (V1.16B and V2.16B), producing a sum in
    the destination register. However, this is not a 128-bit addition operation, but
    rather an 8-bit operation repeated 16 times. Vector operations typically operate
    on a lane-by-lane basis, performing multiple small operations in parallel. For
    this particular instruction, the CPU adds together 16 byte values, producing 16
    independent byte results. This is the magic behind SIMD programming: the ability
    to do 16 times as much work with a single instruction (so it should run about
    16 times faster than running these 16-byte additions individually).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 至于标量加法操作（例如，add w0, w1, w2），该指令将两个源寄存器（V1.16B 和 V2.16B）的值相加，产生一个结果存储在目标寄存器中。然而，这并不是一次128位的加法操作，而是一个8位操作重复执行16次。矢量操作通常是逐通道进行的，并行执行多个小的操作。对于此特定指令，CPU将16个字节值相加，产生16个独立的字节结果。这就是SIMD编程的神奇之处：通过一条指令做16倍的工作（因此它的执行速度大约比逐个执行这16个字节加法快16倍）。
- en: '[Figure 11-17](chapter11.xhtml#fig11-17) shows the lane-by-lane operation of
    the add instruction with the lane-by-lane addition following the arrow directions.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-17](chapter11.xhtml#fig11-17)展示了加法指令的逐通道操作，逐通道加法按照箭头方向进行。'
- en: '![](../images/Figure11-17.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-17.jpg)'
- en: 'Figure 11-17: Lane-by-lane operations'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-17：逐通道操作
- en: Lane-by-lane operations are independent of one another, meaning that if any
    carries, overflows, or other exceptional conditions occur, such anomalies are
    limited in scope to a single lane. Because there is only a single set of NVZC
    condition code flags, vector instructions cannot (and do not) affect these flags.
    If an unsigned carry out of one lane occurs (such as when adding 255 + 1 in a
    byte lane), the sum wraps around with no indication of overflow or underflow.
    In general, you must handle overflows completely differently from the way you’d
    handle them when doing scalar arithmetic. This chapter covers some strategies
    for doing so when discussing saturation in later sections.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 逐通道操作彼此独立，这意味着如果发生进位、溢出或其他异常情况，这些异常仅限于单个通道的范围。由于只有一组NVZC条件码标志，矢量指令无法（也不会）影响这些标志。如果发生无符号进位（例如，在字节通道中执行255
    + 1时），求和结果会自动回绕，并且没有溢出或下溢的标识。通常，处理溢出的方法与处理标量运算时的方式完全不同。本章在后续章节讨论饱和操作时，会介绍一些处理溢出的方法。
- en: Certain vector instructions provide *horizontal operations*, also known as *reducing
    operations*. Rather than operating lane by lane between two registers, these operations
    operate on all the lanes within a single vector register, producing a scalar result.
    For example, the addv instruction will produce the sum of all the lanes in a single
    vector register.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 某些矢量指令提供*水平操作*，也称为*归约操作*。与其在两个寄存器之间逐通道操作，这些操作是在单个矢量寄存器内的所有通道上进行操作，产生一个标量结果。例如，addv指令会产生一个单一矢量寄存器中所有通道的总和。
- en: 11.5 SIMD Logical Operations
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5 SIMD 逻辑操作
- en: 'Because logical (Boolean) operations are computed on a bitwise basis, vector
    logical operations are unique insofar as you can use them to perform 128 individual
    bit operations. Whether you treat the source operands as sixteen 1-byte values
    or as one 128-byte value, the result is the same. For that reason, the vector
    logical operations support only two types: 8B (for 64-bit operands) and 16B (for
    128-bit operands). If you really want to operate on 4H or 2S operands, just specify
    8B; you’ll get the same result. Likewise, for 8H, 4S, or 2D operands, specifying
    16B produces the same result.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑（布尔）运算是按位计算的，矢量逻辑运算具有独特之处，你可以利用它们执行 128 个独立的位操作。无论你将源操作数视为 16 个 1 字节的值，还是作为
    1 个 128 字节的值，结果是相同的。因此，矢量逻辑运算仅支持两种类型：8B（用于 64 位操作数）和 16B（用于 128 位操作数）。如果你真的想对
    4H 或 2S 操作数进行运算，只需指定 8B；你会得到相同的结果。同样，对于 8H、4S 或 2D 操作数，指定 16B 也会得到相同的结果。
- en: The Neon instruction set supports eight logical instructions, as shown in [Table
    11-2](chapter11.xhtml#tab11-2). Here, t is 8B or 16B, Vd is the destination register,
    Vs1 is the left source register, and Vs2 is the right source register (Vs is the
    only source register for the not instruction).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 指令集支持八种逻辑指令，如[表 11-2](chapter11.xhtml#tab11-2)所示。这里，t 是 8B 或 16B，Vd 是目标寄存器，Vs1
    是左侧源寄存器，Vs2 是右侧源寄存器（对于 not 指令，Vs 是唯一的源寄存器）。
- en: 'Table 11-2: Neon Logical Instructions'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-2: Neon 逻辑指令'
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 记忆法 | 语法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| and | and Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & Vs2 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| and | and Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & Vs2 |'
- en: '| orr | orr Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; Vs2 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| orr | orr Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; Vs2 |'
- en: '| orn | orn Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; ~(Vs2) |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| orn | orn Vd.t, Vs1.t, Vs2.t | Vd = Vs1 &#124; ~(Vs2) |'
- en: '| eor | eor Vd.t, Vs1.t, Vs2.t | Vd = Vs1 ^ Vs2 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| eor | eor Vd.t, Vs1.t, Vs2.t | Vd = Vs1 ^ Vs2 |'
- en: '| bic | bic Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & ~(Vs2) (bit clear) |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| bic | bic Vd.t, Vs1.t, Vs2.t | Vd = Vs1 & ~(Vs2)（位清除） |'
- en: '| bif | bif Vd.t, Vs1.t, Vs2.t | Bit insert if false |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| bif | bif Vd.t, Vs1.t, Vs2.t | 如果为假则插入位 |'
- en: '| bit | bit Vd.t, Vs1.t, Vs2.t | Bit insert if true |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| bit | bit Vd.t, Vs1.t, Vs2.t | 如果为真则插入位 |'
- en: '| bsl | bsl Vd.t, Vs1.t, Vs2.t | Bitwise select |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| bsl | bsl Vd.t, Vs1.t, Vs2.t | 按位选择 |'
- en: '| not | not Vd.t, Vs.t | Vd = ~Vs |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| not | not Vd.t, Vs.t | Vd = ~Vs |'
- en: The and, orr, and eor instructions do the usual logical operations (same as
    scalar) and require no further explanation. The orn instruction is similar to
    bic insofar as it inverts the second source operand prior to the OR operation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: and、orr 和 eor 指令执行常规逻辑运算（与标量相同），无需进一步解释。orn 指令与 bic 类似，因其在进行 OR 运算之前会反转第二个源操作数。
- en: The bic (bit clear) instruction clears all the bits in the value of Vs1 in the
    positions containing 1s in Vs2. It stores the result in Vd. Note that there is
    no need for a bis (bit set) instruction, because orr will set bits in Vd.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: bic（位清除）指令在 Vs1 的值中清除所有在 Vs2 中为 1 的位置的位，并将结果存储到 Vd 中。注意，不需要 bis（位设置）指令，因为 orr
    会在 Vd 中设置位。
- en: The bif (bit insert if false) and bit (bit insert if true) instructions are
    unusual insofar as they use three operands in their computation (rather than using
    a function of two inputs and storing the result in a third operand). The bif instruction
    copies the bits from Vs1 to Vd wherever the corresponding bit in Vs2 contains
    a 0\. In the bit positions where Vs2 contains a 1, this instruction leaves the
    corresponding bit in Vd unchanged. The bit instruction works similarly, except
    it copies the bits when the corresponding bit in Vs2 contains a 1 (rather than
    0).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: bif（如果为假则插入位）和 bit（如果为真则插入位）指令之所以不同寻常，是因为它们在计算过程中使用了三个操作数（而不是使用两个输入的函数，并将结果存储到第三个操作数中）。bif
    指令会在 Vs2 中相应位为 0 的位置，将 Vs1 中的位复制到 Vd 中。在 Vs2 中为 1 的位置，此指令会保留 Vd 中对应位的不变。bit 指令的工作方式类似，除了它会在
    Vs2 中相应位为 1 时复制位（而不是 0）。
- en: The bsl (bit select) instruction selects bits from Vs1 or Vs2 (and copies them
    to Vd) based on the original contents of Vd. If Vd originally contained a 1 in
    a particular bit position, bsl selects the corresponding bit from Vs1. Otherwise,
    it selects the bit from Vs2.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: bsl（按位选择）指令根据 Vd 的原始内容，从 Vs1 或 Vs2 中选择位并将其复制到 Vd 中。如果 Vd 在某个位位置上原本为 1，则 bsl
    会从 Vs1 中选择对应的位。否则，它会从 Vs2 中选择该位。
- en: The not instruction inverts all the bits in the source register and stores the
    result into the destination register. This instruction is different from the other
    logical instructions, having only a single source operand.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: not 指令反转源寄存器中的所有位，并将结果存储到目标寄存器中。此指令与其他逻辑指令不同，只有一个源操作数。
- en: The Neon instruction set supports a few special immediate versions of the orr
    and bic instructions
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 指令集支持一些 orr 和 bic 指令的特殊立即数版本
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'where imm is an unsigned 8-bit immediate value; the type (t) is 2S, 4S, 4H,
    or 8H; and shift is 0 or 8 if t is 4H/8H and 0, 8, 16, or 24 if t is 2S or 4S.
    If shift is not specified, it is assumed to be 0\. These instructions require
    the H and S types rather than the B types, since they replicate the immediate
    value through the bytes in the lanes in Vd.t.  ### 11.6 SIMD Shift Operations'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 imm 是一个无符号 8 位立即数；类型（t）是 2S、4S、4H 或 8H；移位（shift）为 0 或 8（如果 t 是 4H/8H），或者
    0、8、16 或 24（如果 t 是 2S 或 4S）。如果没有指定移位，则默认为 0。这些指令需要 H 和 S 类型而非 B 类型，因为它们在 Vd.t
    中通过各通道的字节复制立即数值。### 11.6 SIMD 移位操作
- en: 'Shift instructions are generally considered to be logical operations. However,
    from a vector point of view, they are more correctly thought of as arithmetic
    operations because shift operations can produce overflows. Vector shift operations
    handle overflows in one of four ways:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 移位指令通常被认为是逻辑运算。然而，从向量的角度来看，它们更准确地应该被视为算术运算，因为移位操作可能会产生溢出。向量移位操作通过四种方式处理溢出：
- en: Ignoring any carry out of the shift operation (truncation)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略移位操作的进位（截断）
- en: Saturating the shift result
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饱和移位结果
- en: Rounding the result
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对结果进行四舍五入
- en: Providing an extended shift operation whose destination operand is larger than
    the source register
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供扩展的移位操作，其目标操作数大于源寄存器
- en: This section describes these various shift operations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了这些不同的移位操作。
- en: NOTE
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Neon instruction set uses mnemonics based on* shr *and* shl *for shift
    left and shift right. This is in contrast to the* lsl*,* lsr*, and* asr *instructions
    that the scalar integer instruction set uses. I cannot think of a good reason
    they did it this way; it would have made the instruction set easier to learn had
    they stuck to a consistent naming convention.*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*Neon 指令集使用基于* shr *和* shl *的助记符来表示左移和右移。这与标量整数指令集使用的* lsl*、* lsr* 和* asr*
    指令有所不同。我想不出为什么他们要这么做；如果他们保持一致的命名规则，指令集会更容易学习。*'
- en: 11.6.1 Shift-Left Instruction
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.1 左移指令
- en: The shl instruction shifts each lane of a vector register to the left the specified
    number of bits. This instruction shifts 0s into the (vacated) LO bits. Any carry
    out of the HO bit of the lane is lost. The syntax is as follows
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: shl 指令将向量寄存器的每个通道按指定的位数向左移位。该指令会将 0 填充到（空出的）LO 位中。任何从通道的 HO 位溢出的进位都会丢失。语法如下：
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: where Vd is the destination register and Vs is the source register. The immediate
    count value must be in the ranges appearing in [Table 11-3](chapter11.xhtml#tab11-3)
    (based on the specified type). The assembler will report an error if an immediate
    shift value is outside these ranges.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Vd 是目标寄存器，Vs 是源寄存器。立即数值必须在[表 11-3](chapter11.xhtml#tab11-3)中列出的范围内（取决于指定的类型）。如果立即数移位值超出这些范围，汇编器将报告错误。
- en: 'Table 11-3: Valid shl Shift Values'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-3：有效的 shl 移位值
- en: '| Type | Shift range |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 移位范围 |'
- en: '| --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 8B/16B | 0 to 7 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 8B/16B | 0 到 7 |'
- en: '| 4H/8H | 0 to 15 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 4H/8H | 0 到 15 |'
- en: '| 2S/4S | 0 to 31 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 2S/4S | 0 到 31 |'
- en: '| 2D | 0 to 63 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 2D | 0 到 63 |'
- en: There is also a scalar shl instruction that operates on the LO dword of a vector
    register, with the following syntax
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个标量 shl 指令，它作用于向量寄存器的 LO dword，语法如下：
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: where Dd is the destination scalar register and Ds is the source register (corresponding
    to the LO 64 bits of Vd and Vs). The imm shift count must be in the range 0 to
    63\. Note that this instruction will zero out the HO 64 bits of Dd.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Dd 是目标标量寄存器，Ds 是源寄存器（对应 Vd 和 Vs 的 LO 64 位）。imm 移位计数必须在 0 到 63 的范围内。请注意，该指令会将
    Dd 的 HO 64 位清零。
- en: To shift the lanes by a variable number of bits, see section 11.6.9, “Shift
    by a Variable Number of Bits,” on [page 657](chapter11.xhtml#pg_657).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要按可变的位数移位各通道，请参见第 11.6.9 节，“按可变位数移位”，在[第 657 页](chapter11.xhtml#pg_657)。
- en: 11.6.2 Saturating Shift Left
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.2 饱和左移
- en: The saturating shift-left instructions uqshl, sqshl, and sqshlu shift the lanes
    in a vector to the left the specified number of bit positions. If an overflow
    (whether signed or unsigned) occurs, these instructions saturate the result to
    the largest (signed or unsigned) value depending on the instruction. The syntax
    for these instructions is as follows
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和左移指令 uqshl、sqshl 和 sqshlu 将向量中的各通道向左移位指定的位数。如果发生溢出（无论是有符号还是无符号），这些指令会根据指令的类型将结果饱和到最大的（有符号或无符号）值。此类指令的语法如下：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: where Vd is the destination register, Vs is the source register, imm is an appropriate
    immediate shift constant or Vc contains a shift count in the LO byte, and t is
    type 8B, 16B, 4H, 8H, 2S, 4S, or 2D. The t specification must be the same for
    Vd and Vs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 其中Vd是目标寄存器，Vs是源寄存器，imm是一个合适的立即移位常数，或者Vc在LO字节中包含移位计数，t是8B、16B、4H、8H、2S、4S或2D类型。t的规范必须与Vd和Vs相同。
- en: 'The shift value’s range depends on the lane type; see [Table 11-3](chapter11.xhtml#tab11-3)
    in the previous section for the legal immediate values. For immediate values,
    the assembler will report an error if the shift constant is out of range. For
    the register shift count variants, if the LO byte contains an out-of-range value,
    then the instruction will always saturate the result if a lane contains a nonzero
    value (see the discussion of saturation that follows). The uqshl instruction shifts
    values to the left one bit position, storing the result in the corresponding lane
    in the destination register. If the HO bit is set (before the shift), this instruction
    stores all 1 bits (the maximum unsigned value) in the destination lane. For example,
    if a lane contains 0x7F in V1, the corresponding lane will contain 0xFE (0x7F
    shifted left one position) after the execution of the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 移位值的范围取决于通道类型；请参见前一节中的[表11-3](chapter11.xhtml#tab11-3)以查看合法的立即数值。对于立即数值，如果移位常数超出范围，汇编器会报告错误。对于寄存器移位计数变体，如果LO字节包含超出范围的值，则当某个通道包含非零值时，指令将始终饱和结果（请参见后面关于饱和的讨论）。uqshl指令将值左移一位，将结果存储在目标寄存器的相应通道中。如果HO位被设置（在移位之前），该指令将在目标通道中存储所有1位（最大无符号值）。例如，如果V1中的某个通道包含0x7F，则在执行以下操作后，相应的通道将包含0xFE（0x7F左移一位）：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: However, if a source lane contains the value 0x80 through 0xFF, then shifting
    it to the left one position produces 0xFF in the destination lane. In general,
    if anything other than 0 bits are shifted out of a source lane, the corresponding
    destination lane will contain 0xFF.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果源通道包含0x80到0xFF之间的值，则将其左移一位会在目标通道中产生0xFF。通常，如果任何非0位被从源通道移出，相应的目标通道将包含0xFF。
- en: The sqshl instruction is a signed saturation shift-left operation. For signed
    values, an overflow will occur during a left shift if the H two bits of a lane
    contain different values. For negative source values (the HO bit is set), overflow
    saturates to a result with the HO bit set and all other bits containing 0s (for
    example, with hword types, 0xa000 will saturate to 0x8000).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: sqshl指令是一个有符号饱和左移操作。对于有符号值，如果一个通道的高两位包含不同的值，左移时会发生溢出。对于负源值（HO位被设置），溢出将饱和为一个结果，其中HO位被设置，所有其他位为0（例如，对于半字类型，0xa000将饱和为0x8000）。
- en: The sqshlu instruction is similar to sqshl, except that it treats the destination
    as an unsigned value. Positive (and 0) source values will shift to the left exactly
    like the uqshl instruction, while negative source values (with the HO bit set)
    will saturate to 0.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: sqshlu指令类似于sqshl，不同之处在于它将目标视为无符号值。正值（包括0）源值将像uqshl指令一样向左移位，而负源值（HO位被设置）将饱和为0。
- en: There are also scalar versions of the uqshl, sqshl, and sqshlu instructions
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 还有uqshl、sqshl和sqshlu指令的标量版本。
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: where Rn (n = d or s) is one of the registers B*n*, H*n*, S*n*, or D*n*, and
    d, s, and imm have the usual meanings and limitations. Unlike the plain shl instruction,
    these instructions allow byte, hword, and word registers, as well as dword registers.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 其中Rn（n = d或s）是B*n*、H*n*、S*n*或D*n*中的一个寄存器，d、s和imm具有通常的含义和限制。与普通的shl指令不同，这些指令支持字节、半字和字寄存器，以及双字寄存器。
- en: As for the vector instructions, the uqshl instructions do an unsigned saturation.
    If any bits are shifted out of the HO bit of the source register, these instructions
    set the destination (B*n*, H*n*, S*n*, or D*n*) to all 1 bits. These instructions
    zero-extend the result through the rest of the vector register containing R*d*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量指令，uqshl指令执行无符号饱和。如果任何位被移出源寄存器的HO位，这些指令将目标（B*n*、H*n*、S*n*或D*n*）设置为所有1位。这些指令将结果通过包含R*d*的其余向量寄存器进行零扩展。
- en: The sqshl instruction does a signed saturation, leaving the result in the destination
    (scalar) register. This instruction zeros out the remaining HO bits of the corresponding
    vector register (that is, all the HO bits beyond the size of the scalar register).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: sqshl指令执行有符号饱和，结果保存在目标（标量）寄存器中。该指令将相应向量寄存器的剩余HO位清零（即所有超出标量寄存器大小的HO位）。
- en: The sqshlu instruction does a shift on a signed source value but saturates it
    to an unsigned value (negative results saturate to 0, just as with the vector
    register versions of this instruction).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: sqshlu 指令对有符号源值执行移位操作，但将其饱和为无符号值（负值结果饱和为 0，类似于此指令的向量寄存器版本）。
- en: 11.6.3 Shift-Left Long
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.3 左移长整数
- en: The *shift-left long* instructions sshll, sshll2, ushll, and ushll2 provide
    a mechanism to handle overflow during a shift operation. These instructions sign-
    or zero-extend the value in a lane to twice its size and then perform the left
    shift on the double-sized source, storing the result into the (double-sized) destination
    lane. The syntax for these instructions is
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*左移长整数* 指令 sshll、sshll2、ushll 和 ushll2 提供了一种处理移位操作溢出的方法。这些指令将通道中的值符号扩展或零扩展到两倍大小，然后对扩展后的源值进行左移，并将结果存储到（双倍大小的）目标通道中。以下是这些指令的语法：'
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: where t2 is the double-sized type and can be 8H, 4S, or 2D; t is the original
    type and can be 8B, 4H, or 2S. imm is the shift count and should be in the range
    0 to n – 1, where n is the number of bits in the t type.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 t2 是双倍大小的类型，可以是 8H、4S 或 2D；t 是原始类型，可以是 8B、4H 或 2S。imm 是移位计数，应该在 0 到 n – 1
    的范围内，其中 n 是 t 类型中的位数。
- en: The ushll instruction zero-extends the values in the source lanes to twice their
    size, shifts the zero-extended result by the specified number of bits, and stores
    the result into the corresponding (double-sized) destination lanes. The sshll
    instruction sign-extends the source lane values to twice their size, then shifts
    the results and stores them in the double-sized destination lanes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ushll 指令将源通道中的值零扩展到两倍大小，对零扩展后的结果进行指定的位移，然后将结果存储到相应的（双倍大小的）目标通道中。sshll 指令将源通道值符号扩展到两倍大小，然后对结果进行移位，并将结果存储到双倍大小的目标通道中。
- en: Because these instructions double the size of their values, they operate only
    on the LO 64 bits of the source register (lanes 0 to 7 for bytes, 0 to 3 for hwords,
    and 0 to 1 for words). These instructions ignore the HO 64 bits of the source
    register.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些指令将其值的大小加倍，因此它们仅在源寄存器的低 64 位上操作（字节的通道 0 到 7，半字的通道 0 到 3，字的通道 0 到 1）。这些指令忽略源寄存器的高
    64 位。
- en: 'To handle the upper 64 bits of the source register, the ARM provides the ushll2
    and sshll2 instructions:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理源寄存器的高 64 位，ARM 提供了 ushll2 和 sshll2 指令：
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These accomplish the same operations as the ushll and sshll instructions, except
    that they take their source operands from the HO 64 bits rather than the LO 64
    bits. To indicate this, the t4/t3 type pairs must be 8H/16B, 4S/8H, or 2D/4S.
    The imm shift values must match the source lane size in bits (0 to 15 for 8H/16B,
    0 to 31 for 4S/8H, and 0 to 63 for 2D/4S).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令实现的操作与 ushll 和 sshll 指令相同，不同之处在于它们从高 64 位（HO 64 bits）而不是低 64 位（LO 64 bits）中获取源操作数。为了表示这一点，t4/t3
    类型对必须是 8H/16B、4S/8H 或 2D/4S。imm 位移值必须与源通道的位大小匹配（对于 8H/16B 为 0 到 15，对于 4S/8H 为
    0 到 31，对于 2D/4S 为 0 到 63）。
- en: The ushll, ushll2, sshll, and sshll2 instructions have no scalar versions. Just
    use the vector versions and zero out the HO bits yourself if you need this operation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ushll、ushll2、sshll 和 sshll2 指令没有标量版本。如果需要此操作，只需使用向量版本，并在必要时将高 64 位清零。
- en: 11.6.4 Shift and Insert
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.4 移位与插入
- en: The sli and sri instructions allow you to shift a source operand a certain number
    of bits and then (using other instructions) insert other bits into the locations
    (0 bits) vacated by the shift operation. Here’s the syntax for these instructions
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: sli 和 sri 指令允许你将源操作数按指定的位数进行移位，然后（使用其他指令）将其他位插入移位操作腾出的（0 位）位置。以下是这些指令的语法：
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'where *t* is the usual set of types: 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For sli,
    imm is the shift count, which must be in the range 0 to n – 1, where n is bit
    size of a lane. For sri, the immediate value is a count in the range 1 to n.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t* 是常见的类型集合：8B、16B、4H、8H、2S、4S 或 2D。对于 sli 指令，imm 是位移计数，必须在 0 到 n – 1 的范围内，其中
    n 是一个通道的位数。对于 sri 指令，立即数是一个计数值，范围为 1 到 n。
- en: The sli instruction shifts each lane in Vs.t to the left the specified number
    of bits. It then logically ORs the n - imm LO bits of Vd.t into the result (replacing
    the 0s that were shifted in) and stores the result back into Vd.t, as shown in
    [Figure 11-18](chapter11.xhtml#fig11-18).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: sli 指令将 Vs.t 中的每个通道按指定的位数向左移位。然后，它将 Vd.t 的 n - imm 低位（LO bits）通过逻辑或运算与结果合并（替换被移位进来的
    0），并将结果存回 Vd.t，如 [图 11-18](chapter11.xhtml#fig11-18) 所示。
- en: '![](../images/Figure11-18.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-18.jpg)'
- en: 'Figure 11-18: The sli instruction operation'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-18：sli 指令操作
- en: 'For example, to shift in 1 bits rather than 0 bits, you could load the destination
    register with all 1 bits, then execute the sli instruction, as shown in the following
    code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要移入1位而不是0位，你可以先将目标寄存器加载为全1位，然后执行sli指令，如以下代码所示：
- en: '[PRE61]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This produces 0x0000001f0000001f0000001f0000001f in V0.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在V0中生成0x0000001f0000001f0000001f0000001f。
- en: The sri instruction shifts each lane in Vs.t to the right the specified number
    of bits, then logically ORs the n - imm HO bits of Vd.t into the result (replacing
    the 0s that were shifted in), then stores the result back into Vd.t, as shown
    in [Figure 11-19](chapter11.xhtml#fig11-19).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: sri指令将Vs.t中每个通道右移指定的位数，然后将n - imm高位的Vd.t与结果进行逻辑或运算（替换被移入的0），然后将结果存回Vd.t，如[图11-19](chapter11.xhtml#fig11-19)所示。
- en: '![](../images/Figure11-19.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-19.jpg)'
- en: 'Figure 11-19: The sri instruction operation'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-19：sri指令操作
- en: 'The scalar versions of the sli and sri instructions have the following syntax:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: sli和sri指令的标量版本具有以下语法：
- en: '[PRE62]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: These instructions operate on the LO 64 bits of the specified vector register
    (Dn) and zero out the HO 64 bits of the destination register.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令作用于指定向量寄存器（Dn）的低64位，并将目标寄存器的高64位清零。
- en: 11.6.5 Signed and Unsigned Shift Right
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.5 带符号和无符号右移
- en: 'Because an arithmetic shift left and a logical shift left are essentially the
    same operation, the ARM uses a single instruction for both operations: shl. However,
    the logical and arithmetic shifts are different for right shifts. Therefore, the
    Neon instruction set provides two instructions, sshr and ushr, for signed and
    unsigned shift right (respectively, arithmetic shift right and logical shift right).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算术左移和逻辑左移本质上是相同的操作，ARM使用单一指令来执行这两种操作：shl。然而，右移的逻辑和算术移位有所不同。因此，Neon指令集提供了两条指令，sshr和ushr，分别用于带符号和无符号的右移（即算术右移和逻辑右移）。
- en: As noted in [Chapter 2](chapter2.xhtml), a shift-left operation is the same
    as a multiplication by 2\. Shift-right operations are approximately the same as
    a division by 2\. I say *approximately* because the behaviors of signed and unsigned
    numbers are somewhat different. For example, when you shift the value 1 to the
    right one position, you get a 0 result. If you shift the signed value –1 (all
    1 bits) to the right by using an arithmetic shift right, however, the result is
    –1\. In one case, the shift rounds toward 0, while in the other it rounds away
    from 0\. Neither case is particularly correct or incorrect, but not being able
    to choose the rounding direction can be a problem.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](chapter2.xhtml)所述，左移操作相当于乘以2，右移操作大致等同于除以2。我说是*大致*相同，因为带符号和无符号数的行为有所不同。例如，当你将值1右移一个位置时，结果是0。如果你将带符号值–1（全1位）使用算术右移操作右移，结果则是–1。在一种情况下，移位是向0舍入，而在另一种情况下则是远离0舍入。两种情况都没有特别正确或错误，但无法选择舍入方向可能会成为问题。
- en: 'With scalar instructions, you can reverse this rounding effect by adding the
    carry flag to the result after the shift:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标量指令时，你可以通过在移位后将进位标志添加到结果中来逆转这种舍入效果：
- en: '[PRE63]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Because the vector operations don’t track carries out of a shift in the carry
    flag, you don’t have the option of correcting for this. The Neon instruction set
    therefore provides the rounding shift instructions srshr and urshr, which will
    add in the carry for you.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量操作不会跟踪移位中的进位标志，因此你无法选择纠正这一点。Neon指令集因此提供了舍入移位指令srshr和urshr，这些指令会为你添加进位。
- en: 'The syntax for the Neon shift-right instructions is shown here:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Neon右移指令的语法如下所示：
- en: '[PRE64]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The allowable types for the vector registers are the usual 8B, 16B, 4H, 8H,
    2S, 4S, or 2D. The rounding variants (with the r as the second character in the
    mnemonic) add the carry flag back into the destination lane after the shift operation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 向量寄存器允许的类型是常见的8B、16B、4H、8H、2S、4S或2D。舍入变体（在助记符中第二个字符为r）会在移位操作后将进位标志添加回目标通道。
- en: 'The sshr, srshr, ushr, and urshr instructions also have scalar versions:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: sshr、srshr、ushr和urshr指令也有标量版本：
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: These instructions operate on the LO 64 bits of the vector registers specified
    by Dd (destination) and Ds (source). The imm shift operand must be a value in
    the range 1 to 64\. They will zero out the HO 64 bits of the corresponding Vd
    register. Otherwise, they are identical to their vector components.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令操作在由 Dd（目标）和 Ds（源）指定的向量寄存器的低 64 位上。imm 移位操作数必须在 1 到 64 的范围内。它们会将相应 Vd 寄存器的高
    64 位置为零。除此之外，它们与其向量组件是相同的。
- en: 11.6.6 Accumulating Shift Right
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.6 累积右移
- en: 'The accumulating shift-right instructions have the following syntax:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 累积右移指令具有以下语法：
- en: '[PRE66]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: These instructions are largely the same as the shift-right instructions, but
    they add their shifted values to the corresponding destination lanes (rather than
    just storing the shift lane values).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令与右移指令基本相同，但它们将移位后的值添加到相应的目标通道中（而不是仅仅存储移位后的值）。
- en: '#### 11.6.7 Narrowing Shift Right'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 11.6.7 缩小右移'
- en: The shrn, shrn2, rshrn, and rshrn2 instructions provide the converse operations
    to the shll and shll2 instructions. Rather than double the size of the operands
    when shifting, they halve (“narrow”) the size. The syntax for these instructions
    is as follows
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: shrn, shrn2, rshrn 和 rshrn2 指令提供了与 shll 和 shll2 指令相反的操作。与将操作数大小翻倍的移位操作不同，它们会将大小减半（“缩小”）。这些指令的语法如下：
- en: '[PRE67]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'where:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: t1 is 8B, 4H, or 2S
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: t1 是 8B, 4H 或 2S
- en: t2 is 8H, 4S, or 2D
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: t2 是 8H, 4S 或 2D
- en: t3 is 8B, 16B, 4H, 8H, 2S, or 4S
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: t3 是 8B, 16B, 4H, 8H, 2S 或 4S
- en: t4 is 8H, 4S, or 2D
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: t4 是 8H, 4S 或 2D
- en: The shrn instruction shifts each lane right the specified number of bits (shifting
    0s in from the left); extracts the LO 8, 16, or 32 bits (depending on size of
    t1); and stores the result into the same lane number in the destination register.
    The shrn instruction ignores (truncates) any HO bits left in the shift operation
    that don’t fit in the destination lane (which, recall, is half the size of the
    source lane). This instruction zeros out the HO 64 bits of the destination register.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: shrn 指令将每个通道右移指定数量的位（从左侧移入 0）；提取低 8、16 或 32 位（具体取决于 t1 的大小）；并将结果存储到目标寄存器中相同通道编号的位置。shrn
    指令会忽略（截断）任何无法适应目标通道的高位（回忆一下，目标通道大小是源通道的一半）。该指令会将目标寄存器的高 64 位置为零。
- en: The shrn2 instruction performs the exact same operation but stores the results
    in the HO 64 bits.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: shrn2 指令执行完全相同的操作，但将结果存储到高 64 位。
- en: The rshrn and rshrn2 instructions do the same thing as shrn and shrn2, respectively,
    but round the shifted result before narrowing it. The rshrn instruction also clears
    the upper half of the destination register.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: rshrn 和 rshrn2 指令与 shrn 和 shrn2 指令做的是一样的操作，但在缩小之前会对移位结果进行四舍五入。rshrn 指令还会清除目标寄存器的上半部分。
- en: Because the narrowing shift-right instructions throw away all but the LO bits
    that fit in the destination lane, you might think a separate set of instructions
    must extract the HO bits after the shift operation. There’s no need for such instructions,
    though; just add 8, 16, or 32 to your shrn, shrn2, rshurn, or rshrn2 shift count
    to extract the HO bits.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缩小右移指令会丢弃除了适合目标通道的低位之外的所有高位，你可能会认为需要一组单独的指令来提取右移操作后的高位。但实际上并不需要这样的指令；只需在 shrn,
    shrn2, rshurn 或 rshrn2 的移位计数中添加 8、16 或 32 即可提取高位。
- en: 11.6.8 Saturating Shift Right with Narrowing
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.8 饱和右移与缩小
- en: The standard narrowing shift instructions truncate any HO bits when narrowing
    the result to half the source lane size. The saturating shift-right instructions
    will saturate the shifted value if it does not fit in the destination lane. [Table
    11-4](chapter11.xhtml#tab11-4) gives the syntax for these instructions.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的缩小右移指令在将结果缩小到源通道大小的一半时，会截断任何高位（HO）位。饱和右移指令在移位后的值如果无法适应目标通道时，会将其饱和。有关这些指令的语法，请参考
    [表 11-4](chapter11.xhtml#tab11-4)。
- en: 'Table 11-4: Lane-by-Lane Saturating Shift Right with Narrowing Instructions'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-4: 按通道饱和右移与缩小指令'
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 助记符 | 语法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| uqshrn | uqshrn Vd.t1, Vs.t2, #imm | Unsigned shift right by imm bits with
    narrowing. Stores data into LO 64 bits of Vd. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| uqshrn | uqshrn Vd.t1, Vs.t2, #imm | 无符号右移 imm 位并进行缩小。将数据存储到 Vd 的低 64 位。
    |'
- en: '| uqrshrn | uqrshrn Vd.t1, Vs.t2, #imm | Unsigned shift right by imm bits with
    narrowing and rounding. Stores data into LO 64 bits of Vd. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| uqrshrn | uqrshrn Vd.t1, Vs.t2, #imm | 无符号右移 imm 位并进行缩小和四舍五入。将数据存储到 Vd 的低
    64 位。 |'
- en: '| sqshrn | sqshrn Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing. Stores data into LO 64 bits of Vd. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| sqshrn | sqshrn Vd.t1, Vs.t2, #imm | 按 imm 位数有符号右移并进行缩小处理。将数据存储到 Vd 的低 64
    位。 |'
- en: '| sqrshrn | sqrshrn Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing and rounding. Stores data into LO 64 bits of Vd. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| sqrshrn | sqrshrn Vd.t1, Vs.t2, #imm | 按 imm 位数有符号右移，并进行缩小和四舍五入处理。将数据存储到
    Vd 的低 64 位。 |'
- en: '| sqshrun | sqshrun Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing and saturation to an unsigned number. Stores data into LO 64 bits of
    Vd. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| sqshrun | sqshrun Vd.t1, Vs.t2, #imm | 按 imm 位数有符号右移，并进行缩小和饱和处理为无符号数。将数据存储到
    Vd 的低 64 位。 |'
- en: '| sqrshrun | sqrshrun Vd.t1, Vs.t2, #imm | Signed shift right by imm bits with
    narrowing, rounding, and saturation to an unsigned number. Stores data into LO
    64 bits of Vd. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| sqrshrun | sqrshrun Vd.t1, Vs.t2, #imm | 按 imm 位数有符号右移，并进行缩小、四舍五入和饱和处理为无符号数。将数据存储到
    Vd 的低 64 位。 |'
- en: '| uqshrn2 | uqshrn2 Vd.t3, Vs.t4, #imm | Unsigned shift right by imm bits with
    narrowing. Stores data into HO 64 bits of Vd. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| uqshrn2 | uqshrn2 Vd.t3, Vs.t4, #imm | 按 imm 位数无符号右移并进行缩小处理。将数据存储到 Vd 的高
    64 位。 |'
- en: '| uqrshrn2 | uqrshrn2 Vd.t3, Vs.t4, #imm | Unsigned shift right by imm bits
    with narrowing and rounding. Stores data into HO 64 bits of Vd. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| uqrshrn2 | uqrshrn2 Vd.t3, Vs.t4, #imm | 按 imm 位数无符号右移并进行缩小和四舍五入处理。将数据存储到
    Vd 的高 64 位。 |'
- en: '| sqshrn2 | sqshrn2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing. Stores data into HO 64 bits of Vd. |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| sqshrn2 | sqshrn2 Vd.t3, Vs.t4, #imm | 按 imm 位数有符号右移并进行缩小处理。将数据存储到 Vd 的高
    64 位。 |'
- en: '| sqrshrn2 | sqrshrn2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing and rounding. Stores data into HO 64 bits of Vd. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| sqrshrn2 | sqrshrn2 Vd.t3, Vs.t4, #imm | 按 imm 位数有符号右移，并进行缩小和四舍五入处理。将数据存储到
    Vd 的高 64 位。 |'
- en: '| sqshrun2 | sqshrun2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits with
    narrowing and saturation to an unsigned number. Stores data into HO 64 bits of
    Vd. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| sqshrun2 | sqshrun2 Vd.t3, Vs.t4, #imm | 按 imm 位数有符号右移，并进行缩小和饱和处理为无符号数。将数据存储到
    Vd 的高 64 位。 |'
- en: '| sqrshrun2 | sqrshrun2 Vd.t3, Vs.t4, #imm | Signed shift right by imm bits
    with narrowing, rounding, and saturation to an unsigned number. Stores data into
    HO 64 bits of Vd. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| sqrshrun2 | sqrshrun2 Vd.t3, Vs.t4, #imm | 按 imm 位数有符号右移，并进行缩小、四舍五入和饱和处理为无符号数。将数据存储到
    Vd 的高 64 位。 |'
- en: '[Table 11-5](chapter11.xhtml#tab11-5) lists the legal types and lane counts
    for the saturating shift-right instructions appearing in [Table 11-4](chapter11.xhtml#tab11-4).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-5](chapter11.xhtml#tab11-5) 列出了 [表 11-4](chapter11.xhtml#tab11-4) 中出现的饱和右移指令的合法类型和通道数。'
- en: 'Table 11-5: Saturating Shift-Right Types and Lane Counts'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-5：饱和右移类型和通道数
- en: '| t | Legal types and lane counts |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| t | 法律类型和通道数 |'
- en: '| --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| t1/t2 | 8B/8H, 4H/4S, or 2S/2D |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| t1/t2 | 8B/8H, 4H/4S, 或 2S/2D |'
- en: '| t3/t4 | 16B/8H, 8H/4S, or 4S/2D |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| t3/t4 | 16B/8H, 8H/4S, 或 4S/2D |'
- en: The instructions with the 2 suffix store their narrowed results into the HO
    64 bits of the destination register. Those without this suffix will zero out the
    HO 64 bits of the destination register.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 2 后缀的指令将其缩小的结果存储到目标寄存器的高 64 位。没有此后缀的指令将清零目标寄存器的高 64 位。
- en: The uqrshrn, sqrshrn, uqrshrn2, and sqrshrn2 instructions round the shifted
    result before saturating the value (if saturation is necessary). Rounding consists
    of adding the last bit shifted out of the source lane back into the value.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: uqrshrn、sqrshrn、uqrshrn2 和 sqrshrn2 指令在对结果进行饱和之前，会先对移位结果进行四舍五入（如果需要进行饱和）。四舍五入是通过将源通道移出的最后一位加回到值中来实现的。
- en: The instructions with the s prefix operate on signed values, while those with
    the u prefix operate on unsigned values. Unsigned values saturate to all 1 bits
    (if the unsigned value will not fit in the destination lane size), but signed
    values will saturate to either a HO bit of 1 with other bits 0s, or a HO bit of
    0 with all other bits containing 1s.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 s 前缀的指令对有符号值进行操作，而带有 u 前缀的指令则对无符号值进行操作。无符号值在目标通道大小无法容纳时会饱和为全 1 位，而有符号值会饱和为高位
    1 和其他位 0，或者高位 0 和所有其他位 1。
- en: 'The sqrshrun and sqrshrun2 instructions do the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: sqrshrun 和 sqrshrun2 指令执行以下操作：
- en: Perform an arithmetic shift-right operation by the specified number of bits
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行按指定位数的算术右移操作
- en: Round the result by adding the last bit shifted out back into the result
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将最后移出的位加回结果来对结果进行四舍五入
- en: Saturate the result to the maximum unsigned value (all 1 bits) if the result
    will not fit into the destination lane; negative values saturate to 0
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果无法容纳在目标通道内，则将结果饱和为最大无符号值（全 1 位）；负值则饱和为 0。
- en: Store the saturated result into the destination lane
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将饱和结果存储到目标通道中
- en: The sqrshrun instruction stores the results in the LO 64 bits of the destination
    register; sqrshrun2 stores the results in the HO 64 bits of the destination register.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: sqrshrun 指令将结果存储到目标寄存器的低 64 位中；sqrshrun2 将结果存储到目标寄存器的高 64 位中。
- en: 'These instructions also have scalar versions:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令也有标量版本：
- en: '[PRE68]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that these instructions clear the upper bits (beyond the specified scalar
    register) of the underlying vector register.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些指令会清除基础向量寄存器中超出指定标量寄存器的上位位。
- en: 11.6.9 Shift by a Variable Number of Bits
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.9 按变量数量的位数移位
- en: To shift a lane by a variable number of bits, use one of the following instructions
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要按变量数量的位数移位某个通道，使用以下其中之一指令：
- en: '[PRE69]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: where t is the usual 8B, 16B, 4H, 8H, 2S, 4S, or 2D.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 t 是常见的 8B、16B、4H、8H、2S、4S 或 2D。
- en: Vc.t holds the signed shift count in the LO byte. For positive values (in the
    range 0 to 0x7F), the instruction shifts the bits in a lane the number of bit
    positions to the left. For negative values (0xFF to 0x80; –1 to –128), the instruction
    shifts the bits to the right, despite using a shl mnemonic. See [Table 11-6](chapter11.xhtml#tab11-6)
    for legal ranges when specifying the shift count by using a register.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Vc.t 保持有符号的移位计数值在低字节中。对于正值（范围 0 到 0x7F），指令将一个通道的位左移相应数量的位。对于负值（0xFF 到 0x80；–1
    到 –128），尽管使用了 shl 助记符，指令还是会将位右移。有关通过使用寄存器指定移位计数时的合法范围，请参见[表 11-6](chapter11.xhtml#tab11-6)。
- en: 'Table 11-6: Legal Vc.t Shift Ranges'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-6: 合法的 Vc.t 移位范围'
- en: '| Type | Unsigned (SHL) | Signed (SHR) |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 无符号（SHL） | 有符号（SHR） |'
- en: '| --- | --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8B/16B | 0 to 7 | –1 to –7 |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 8B/16B | 0 到 7 | –1 到 –7 |'
- en: '| 4H/8H | 0 to 15 | –1 to –15 |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 4H/8H | 0 到 15 | –1 到 –15 |'
- en: '| 2S/4S | 0 to 31 | –1 to –31 |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 2S/4S | 0 到 31 | –1 到 –31 |'
- en: '| 2D | 0 to 63 | –1 to –63 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| 2D | 0 到 63 | –1 到 –63 |'
- en: Values outside the ranges listed in [Table 11-6](chapter11.xhtml#tab11-6) will
    produce the results shown in [Table 11-7](chapter11.xhtml#tab11-7).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 超出[表 11-6](chapter11.xhtml#tab11-6)中列出的范围的值将产生[表 11-7](chapter11.xhtml#tab11-7)中显示的结果。
- en: 'Table 11-7: Result of Shift If Count Exceeds Allowable Range'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-7: 当计数超过允许范围时的移位结果'
- en: '| Shift instruction | Positive count, positive overflow | Positive count, negative
    overflow | Negative count, positive value | Negative count, negative value |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 移位指令 | 正数计数，正溢出 | 正数计数，负溢出 | 负数计数，正值 | 负数计数，负值 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| sshl | 0 | 0 | 0 | –1 (all 1 bits) |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| sshl | 0 | 0 | 0 | –1（全 1 位） |'
- en: '| ushl | 0 | 0 | 0 | 0 |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| ushl | 0 | 0 | 0 | 0 |'
- en: '| sqshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | –1 (all 1 bits) |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| sqshl | 高位位 0，其它位 1（例如，0x7F） | 高位位 1，其它位 0（例如，0x80） | 0 | –1（全 1 位） |'
- en: '| uqshl | All 1 bits (for example, 0xff) | All 1 bits (for example, 0xff) |
    0 | 0 |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| uqshl | 全 1 位（例如，0xff） | 全 1 位（例如，0xff） | 0 | 0 |'
- en: '| srshl | 0 | 0 | 0 | 0 (–1 + carry) |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| srshl | 0 | 0 | 0 | 0（–1 + 进位） |'
- en: '| urshl | 0 | 0 | 0 | 1 (0 + carry) |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| urshl | 0 | 0 | 0 | 1（0 + 进位） |'
- en: '| sqshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | –1 (all 1 bits) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| sqshl | 高位位 0，其它位 1（例如，0x7F） | 高位位 1，其它位 0（例如，0x80） | 0 | –1（全 1 位） |'
- en: '| uqshl | –1 (all 1 bits) | –1 (all 1 bits) | 0 | 0 |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| uqshl | –1（全 1 位） | –1（全 1 位） | 0 | 0 |'
- en: '| sqrshl | HO bit 0, all others 1 (for example, 0x7F) | HO bit 1, all others
    0 (for example, 0x80) | 0 | 0 (–1 + carry) |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| sqrshl | 高位位 0，其它位 1（例如，0x7F） | 高位位 1，其它位 0（例如，0x80） | 0 | 0（–1 + 进位） |'
- en: '| uqrshl | –1 (all 1 bits) | –1 (all 1 bits) | 0 | 1 (0 + carry) |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| uqrshl | –1（全 1 位） | –1（全 1 位） | 0 | 1（0 + 进位） |'
- en: Using shf (for shift) in these instructions would probably have been a better
    choice then shl, since that name better matches the operation. Just keep in mind
    that the value in the LO byte of Vc.t is a signed integer and negative values
    indicate a right shift.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指令中使用 shf（用于移位）可能比 shl 更合适，因为该名称更符合操作。只需记住，Vc.t 中低字节的值是有符号整数，负值表示右移。
- en: The Neon shl instruction also has some scalar saturating versions
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 的 shl 指令也有一些标量饱和版本
- en: '[PRE70]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: where R represents one of the scalar register names (B, H, S, or D). These instructions
    shift the value in the scalar register Rs the number of bit positions specified
    by the LO byte of Rc and store the shifted result in Rd. Rc is treated as a signed
    number; positive values shift Rs left, while negative values shift Rs right. If
    an overflow (signed or unsigned, as appropriate) occurs during the shift, these
    instructions set Rd to the maximum positive signed or unsigned value.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 R 代表标量寄存器名称之一（B、H、S 或 D）。这些指令将标量寄存器 Rs 中的值按 Rc 的 LO 字节指定的位数进行移位，并将移位结果存储在
    Rd 中。Rc 被视为一个有符号数；正值将 Rs 左移，而负值将 Rs 右移。如果在移位过程中发生溢出（有符号或无符号，根据情况），这些指令将 Rd 设置为最大正有符号或无符号值。
- en: If the shift count is negative for the sqshl instruction, the CPU performs an
    arithmetic shift-right operation, which will replicate the HO bit when shifting
    to the right. Positive (and 0) source values will saturate to 0, and negative
    source values will saturate to –1 (all 1 bits).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 sqshl 指令的移位计数为负，CPU 将执行算术右移操作，右移时将复制 HO 位。正值（以及 0）源值将饱和为 0，负值源值将饱和为 -1（所有
    1 位）。
- en: The sqrshl and uqrshl instructions are special rounding versions of the saturating
    shift instructions. During a shift-right operation (that is, when Rc is negative),
    these instructions round the result by adding 1 if the last bit shifted out was
    a 1 bit.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: sqrshl 和 uqrshl 指令是饱和移位指令的特殊舍入版本。在右移操作期间（即 Rc 为负时），这些指令通过在最后一个移出的位是 1 时加 1 来舍入结果。
- en: 11.7 SIMD Arithmetic Operations
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7 SIMD 算术操作
- en: The Neon instruction set includes several common arithmetic operations, including
    addition, subtraction, and multiplication. The only surprise is that there is
    no division operation; instead, you’ll have to compute the reciprocal and multiply
    by that value (using the instructions provided to estimate reciprocals).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 指令集包括几个常见的算术操作，包括加法、减法和乘法。唯一的例外是没有除法操作；相反，你必须计算倒数并用该值相乘（使用提供的指令来估算倒数）。
- en: 11.7.1 SIMD Addition
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.1 SIMD 加法
- en: Neon provides a wide set of instructions that add lanes (ignoring overflow),
    add and saturate (when overflow occurs), or perform horizontal additions.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 提供了一套广泛的指令，用于加法通道（忽略溢出）、加法并饱和（当发生溢出时）或执行水平加法。
- en: 11.7.1.1 Vector Addition
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.7.1.1 向量加法
- en: The Neon instruction set provides several instructions you can use to add integer
    and floating-point values in lanes within the vector registers, as listed in [Table
    11-8](chapter11.xhtml#tab11-8). These instructions compute Vd = Vl + Vr, where
    Vd is the destination, Vl is the left operand, and Vr is the right operand.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 指令集提供了几种可以在向量寄存器中的通道内加法整数和浮点值的指令，如[表 11-8](chapter11.xhtml#tab11-8)所列。这些指令计算
    Vd = Vl + Vr，其中 Vd 是目标寄存器，Vl 是左操作数，Vr 是右操作数。
- en: 'Table 11-8: Neon Addition Instructions'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-8: Neon 加法指令'
- en: '| Instruction mnemonic | Syntax | Description |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 指令助记符 | 语法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| add | add Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane integer sum |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| add | add Vd.t1, Vl.t1, Vr.t1 | 逐通道计算整数和 |'
- en: '| fadd | fadd Vd.t2, Vl.t2, Vr.t2 | Computes lane-by-lane floating-point sum
    |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| fadd | fadd Vd.t2, Vl.t2, Vr.t2 | 逐通道计算浮点数和 |'
- en: '| sqadd | sqadd Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane signed integer
    sum, with saturation |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| sqadd | sqadd Vd.t1, Vl.t1, Vr.t1 | 逐通道计算带饱和的有符号整数和 |'
- en: '| uqadd | uqadd Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane unsigned integer
    sum, with saturation |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| uqadd | uqadd Vd.t1, Vl.t1, Vr.t1 | 逐通道计算无符号整数和，带饱和 |'
- en: '| saddl | saddl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane signed integer
    sum, with long extension |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| saddl | saddl Vd.t3, Vl.t4, Vr.t4 | 逐通道计算带长扩展的有符号整数和 |'
- en: '| uaddl | uaddl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane unsigned integer
    sum, with long extension |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| uaddl | uaddl Vd.t3, Vl.t4, Vr.t4 | 逐通道计算带长扩展的无符号整数和 |'
- en: '| saddl2 | saddl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed integer
    sum, with long extension |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| saddl2 | saddl2 Vd.t5, Vl.t6, Vr.t6 | 逐通道计算带长扩展的有符号整数和 |'
- en: '| uaddl2 | uaddl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned integer
    sum, with long extension |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| uaddl2 | uaddl2 Vd.t5, Vl.t6, Vr.t6 | 逐通道计算带长扩展的无符号整数和 |'
- en: '| saddw | saddw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane signed integer
    sum, with wide extension |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| saddw | saddw Vd.t3, Vl.t3, Vr.t4 | 逐通道计算带宽扩展的有符号整数和 |'
- en: '| uaddw | uaddw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane unsigned integer
    sum, with wide extension |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| uaddw | uaddw Vd.t3, Vl.t3, Vr.t4 | 逐通道计算带宽扩展的无符号整数和 |'
- en: '| saddw2 | saddw2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed integer
    sum, with wide extension |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
- en: '| uaddw2 | uaddw2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned integer
    sum, with wide extension |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
- en: '| addhn | addhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane addition with narrowing
    |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
- en: '| raddhn | raddhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane addition with
    rounding and narrowing |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
- en: '| addhn2 | addhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane addition with
    narrowing (uses HO bits) |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
- en: '| raddhn2 | raddhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane addition with
    rounding and narrowing (uses HO bits) |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
- en: '| shadd | shadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed addition
    with halving |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
- en: '| uhadd | uhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned addition
    with halving |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
- en: '| srhadd | srhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed addition
    with rounding and halving |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
- en: '| urhadd | urhadd Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned addition
    with rounding and halving |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
- en: '| addp | addp Vd.t1, Vl.t1, Vr.t1 | Adds vector pairwise |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
- en: '| faddp | faddp Vd.t2, Vl.t2, Vr.t2 | Adds vector floating-point pairwise |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
- en: '| saddlp | saddlp Vd.t8, Vl.t9 | Adds vector pairwise, signed long integer
    |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
- en: '| uaddlp | uaddlp Vd.t8, Vl.t9 | Adds vector pairwise, unsigned long integer
    |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
- en: '| saddalp | saddalp Vd.t8, Vl.t9 | Adds vector pairwise and accumulates, signed
    long integer |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
- en: '| uaddalp | uaddalp Vd.t8, Vl.t9 | Adds vector pairwise and accumulates, unsigned
    long integer |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
- en: '[Table 11-9](chapter11.xhtml#tab11-9) lists the legal types for the addition
    and subtraction instructions.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-9: Legal Types for Vector Addition and Subtraction'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, 4S, or 2D |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
- en: '| t2 | 2S, 4S, or 2D |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 8H/8B, 4S/4H, or 2D/2S |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
- en: '| t5/t6 | 8H/16B, 4S/8H, or 2D/4S |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
- en: '| t7 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| t8/t9 | 4H/8B, 8H/16B, 2S/4H, 4S/8H, 1D/2S, or 2D/4S |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: The remainder of this section describes each of the addition instructions in
    [Table 11-8](chapter11.xhtml#tab11-8) in greater detail.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The add instruction, with vector register operands, does a lane-by-lane addition.
    Any overflow (signed or unsigned) is ignored, with the sum holding the LO bits
    of the result. If the type is 8B, 4H, or 2S, the add instruction adds only the
    lanes in the LO 64 bits of the registers, zeroing out the HO 64 bits of the destination
    register. [Figure 11-20](chapter11.xhtml#fig11-20) provides an example of a 16B
    lane-by-lane addition.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-20.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: 16B lane-by-lane addition using add Vd.16b, Vs1.16b, Vs2.16b'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: The fadd instruction, with vector register operands, adds two- or four-lane
    single-precision values together, or a pair of double-precision floating-point
    values. With 2S types, the fadd instruction clears the HO 64 bits of the destination
    register.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: The sqadd and uqadd instructions do a lane-by-lane addition (signed and unsigned,
    respectively), except they saturate their results in the case of overflow (or
    underflow, when adding signed numbers). As with add, those instructions that take
    64-bit source operands produce a 64-bit result and zero out the HO 64 bits of
    the destination register.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: The saddl and uaddl instructions take the lanes in the LO 64 bits of the source
    registers, sign- or zero-extend these values to twice their size, compute the
    sum, and store the results in the full destination register (with double-sized
    lanes). The destination register type must be specified as twice the size of the
    source register types (see [Figure 11-21](chapter11.xhtml#fig11-21)). Because
    the sum of two *n*-bit numbers requires no more than *n* + 1 bits, these instructions
    will produce the correct result without any possibility of overflow or underflow.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-21.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: A uaddl operation (uaddl Vd.4s, Vs1.4h, Vs2.4h)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: The saddl2 and uaddl2 instructions also sign- or zero-extend the values in the
    lanes in one-half of the source register and produce a sum in the full 128 bits
    of the destination register. However, the saddl2 and uaddl2 instructions compute
    the sum of the lanes in the HO 64 bits of the source registers (see [Figure 11-22](chapter11.xhtml#fig11-22)).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-22.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: A saddl2 operation (saddl2 Vd.4s, Vs1.8h, Vs2.8h)'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Although the saddl2 and uaddl2 instructions’ source operands are only 64 bits,
    you must specify the 128-bit types (16B, 8H, 4S) as the source type because the
    instruction retrieves the data from the upper 64 bits of a 128-bit value.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The saddw, uaddw, saddw2, and uaddw2 instructions allow you to produce the sum
    of two operands whose sizes are different. The saddw and uaddw instructions expect
    the second source operand’s type to be half the size of the first source and the
    destination operands’ types, though you specify the same number of lanes for all
    three operands. These instructions will sign- or zero-extend (respectively) the
    lanes in the second source operand to the size of the other two, compute the sum,
    and then store the data into the destination lanes (see [Figure 11-23](chapter11.xhtml#fig11-23)).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-23.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: A uaddw operation (uaddw Vd.4s, Vs1.4s, Vs2.4h)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: The saddw2 and uaddw2 instructions also sign- or zero-extend the second source
    operand, but they operate on the HO 64 bits rather than the LO 64 bits (see [Figure
    11-24](chapter11.xhtml#fig11-24)). You must specify double the number of lanes
    for the second operand so that the instruction will operate on the full 128 bits
    of the second source operand.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-24.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-24: A saddw2 operation (saddw2 Vd.4s, Vs1.4s, Vs2.4h)'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Overflow (underflow) is possible when using the saddw, uaddw, saddw2, and uaddw2
    instructions (for example, when adding 0xFFFF with 0x01). These instructions will
    ignore the overflow and keep the LO bits of the result.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 saddw、uaddw、saddw2 和 uaddw2 指令时可能会发生溢出（下溢），例如当将 0xFFFF 和 0x01 相加时。这些指令会忽略溢出并保留结果的低位（LO）位。
- en: The addhn (vector add with narrowing) and raddhn (vector add, round, and narrow)
    instructions add the specified lanes together, then *narrow* the result by keeping
    only the HO bits. These instructions’ destination type is half the size of the
    source types. For example, if you add half-word lanes together, the narrowing
    additions will keep only the HO byte of the results.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: addhn（向量加法并缩小）和 raddhn（向量加法、舍入并缩小）指令将指定的通道相加，然后通过仅保留高位（HO）位来*缩小*结果。这些指令的目标类型是源类型的一半大小。例如，如果将半字通道相加，缩小的结果只会保留高位字节（HO）。
- en: 'The raddhn instruction rounds the result before storing it into the destination
    register. If the LO half of the result contains a 1 in its HO bit position, raddhn
    increments the HO byte by 1; otherwise, it returns the same result as addhn. Consider
    the following instruction:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: raddhn 指令在将结果存储到目标寄存器之前进行舍入。如果结果的低半部分的高位（HO 位）为 1，raddhn 会将高字节（HO byte）加 1；否则，它返回与
    addhn 相同的结果。考虑以下指令：
- en: '[PRE71]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If V2 contained 0x00010001 and V1 contained 0xFE7FFE7F, then V0 would contain
    0xFFFF after execution of this instruction. Had V1 contained 0xFE7EFE7E, though,
    V0 would contain 0xFEFE afterward.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 V2 包含 0x00010001，V1 包含 0xFE7FFE7F，那么在执行此指令后，V0 将包含 0xFFFF。如果 V1 包含 0xFE7EFE7E，V0
    则会包含 0xFEFE。
- en: Overflow can still occur during the execution of addhn and raddhn. Adding half
    words 0xFFFF and 0x0001 together will produce 0x00 in the corresponding destination
    byte lane.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 addhn 和 raddhn 时仍然可能发生溢出。将半字 0xFFFF 和 0x0001 相加将会在相应的目标字节通道中产生 0x00。
- en: The addhn2 and raddhn2 instructions also compute *add and narrowing* (with rounding,
    if specified); however, they store their results in the HO 64 bits of the destination
    register and leave the LO 64 bits of the destination unchanged. Because these
    instructions operate on the HO 64 bits of the destination, the destination’s lane
    count must be twice that of the source registers. For example
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: addhn2 和 raddhn2 指令也会进行*加法和缩小*（如果指定，则进行舍入）；然而，它们将结果存储在目标寄存器的高 64 位（HO 64 位）中，并且保持目标寄存器的低
    64 位（LO 64 位）不变。由于这些指令操作的是目标寄存器的高 64 位，因此目标的通道数必须是源寄存器的两倍。例如：
- en: '[PRE72]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: adds the LO 8 half words of V1 and V2 and stores the HO 8-bit result of each
    lane addition into the HO 8 bytes of V0 (leaving the LO 8 bytes untouched). You
    must specify the destination register’s type as 16B, even though this instruction
    stores only 8 bytes into the register.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 将 V1 和 V2 的低 8 个半字相加，并将每个通道加法的高 8 位结果存储到 V0 的高 8 字节中（保持低 8 字节不变）。你必须将目标寄存器的类型指定为
    16B，即使此指令仅将 8 字节存储到寄存器中。
- en: The shadd, uhadd, srhadd, and urhadd instructions add a pair of lanes together,
    shift right by 1 (with optional rounding, for those instructions containing an
    r), and store the result into the destination lane. As usual, the instructions
    beginning with an s handle signed values, while the instructions beginning with
    a u handle unsigned values. Because an addition of *n* bits never produces more
    than *n* + 1 bits, and a division by 2 is the same as a shift right by 1 bit,
    these instructions never produce an overflow. Consider the addition of the two
    largest single-byte values, 0xFF + 0xFF = 0x1FE. Shifting this sum to the right
    1 bit gives you 0xFF, which fits just fine into 8 bits. Even with rounding, overflow
    will not occur.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: shadd、uhadd、srhadd 和 urhadd 指令将一对通道相加，右移 1 位（对于包含 r 的指令，可以选择舍入），并将结果存储到目标通道中。像往常一样，以
    s 开头的指令处理有符号值，而以 u 开头的指令处理无符号值。由于*n* 位的加法永远不会产生超过*n* + 1 位的结果，而除以 2 等同于右移 1 位，这些指令永远不会导致溢出。考虑两个最大的单字节值相加，0xFF
    + 0xFF = 0x1FE。将此和右移 1 位后得到 0xFF，它正好适合 8 位。即使舍入，也不会发生溢出。
- en: These instructions are especially handy for processing digital audio. For example,
    suppose you want to mix together two 16-bit audio tracks. Simply summing the hwords
    from the two tracks will boost the volume by 3 decibels (dB) (equivalent to doubling
    the digital value). Halving the result after the sum reduces this volume increase
    by 3 dB. The urhadd instruction would be ideal for mixing these tracks as it would
    divide the result by 2, averaging the values of the two tracks.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令特别适用于处理数字音频。例如，假设你想要混合两个16位音频轨道。仅仅对两个轨道的半字进行求和，会使音量提高3分贝（dB）（相当于将数字值翻倍）。在求和后将结果减半，能够将音量提升降低3
    dB。urhadd指令非常适合混合这些轨道，因为它会将结果除以2，从而对两个轨道的值进行平均。
- en: 11.7.1.2 Pairwise Addition
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.7.1.2 配对加法
- en: Thus far, all the addition operations have operated on corresponding lanes in
    the source operands, producing a result that the instructions store in the same
    lane in the destination register. This is known as a *vertical addition* because
    the data flows vertically from register to register, as shown previously in [Figure
    11-20](chapter11.xhtml#fig11-20). On occasion, you may want to produce the sum
    of adjacent elements within a vector rather than the elements in corresponding
    lanes of two vectors (horizontal addition). You can accomplish this with the *pairwise
    addition* instructions from [Table 11-8](chapter11.xhtml#tab11-8).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有加法操作都在源操作数中对应的通道上进行，生成的结果会存储在目标寄存器的相同通道中。这被称为*纵向加法*，因为数据从一个寄存器流向另一个寄存器，呈垂直流动，如之前在[图11-20](chapter11.xhtml#fig11-20)中所示。偶尔，你可能想要对向量中的相邻元素求和，而不是对两个向量中对应通道的元素进行求和（横向加法）。你可以通过[表11-8](chapter11.xhtml#tab11-8)中的*配对加法*指令来实现这一点。
- en: 'The pairwise addition instructions, as their name suggests, add adjacent pairs
    of lanes in vectors. Because the result requires half the number of lanes that
    are present in the source, the pairwise additions produce a single vector result
    from two source registers. Consider the following example that pairwise-adds the
    half words in V1 and V2, producing the pairwise sum in V0:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 配对加法指令，顾名思义，是在向量中加相邻的通道对。由于结果需要的通道数是源通道数的一半，因此配对加法会从两个源寄存器中生成一个单一的向量结果。考虑以下示例，它对V1和V2中的半字进行配对加法，生成V0中的配对和：
- en: '[PRE73]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This instruction computes the following results:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算以下结果：
- en: V0[0] = V2[0] + V2[1]
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: V0[0] = V2[0] + V2[1]
- en: V0[1] = V2[2] + V2[3]
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: V0[1] = V2[2] + V2[3]
- en: V0[2] = V1[0] + V1[1]
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: V0[2] = V1[0] + V1[1]
- en: V0[3] = V1[2] + V1[3]
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: V0[3] = V1[2] + V1[3]
- en: '[Figure 11-25](chapter11.xhtml#fig11-25) diagrams this operation.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-25](chapter11.xhtml#fig11-25)展示了这个操作。'
- en: '![](../images/Figure11-25.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-25.jpg)'
- en: 'Figure 11-25: The addp v0.4s, v2.4s, v1.4s instruction'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-25：addp v0.4s, v2.4s, v1.4s指令
- en: 'This instruction also has a floating-point version that adds adjacent single-
    or double-precision values in a pair of vectors: faddp. For example, the following
    instruction performs the same operation as the previous addp integer example but
    adds adjacent single-precision floating-point values rather than 32-bit integer
    values:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令还有一个浮点版本，用于在一对向量中相邻的单精度或双精度值之间进行加法运算：faddp。例如，以下指令执行与之前的addp整数示例相同的操作，但添加的是相邻的单精度浮点值，而不是32位整数值：
- en: '[PRE74]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The addp instruction ignores any overflow during the addition. To produce a
    correct result, use the saddlp and uaddlp instruction (signed and unsigned pairwise
    add long) to sign- or zero-extend the lane values prior to the addition. The syntax
    for these two instructions is different from that of the other addition instructions:
    there are only two register operands (a source and a destination register). For
    example, because the following instruction doubles the size of the result to place
    in the destination operand and sums adjacent elements of the source operand, there
    is no need for a second register operand:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: addp指令在加法过程中会忽略任何溢出。为了获得正确的结果，可以使用saddlp和uaddlp指令（有符号和无符号配对加法长操作）在加法前对数据通道值进行符号扩展或零扩展。这两个指令的语法与其他加法指令不同：它们只有两个寄存器操作数（一个源寄存器和一个目标寄存器）。例如，以下指令将结果的大小加倍，存入目标操作数，同时对源操作数的相邻元素进行求和，因此不需要第二个寄存器操作数：
- en: '[PRE75]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note that the destination register type size must be twice that of the source,
    and the number of lanes must be half that of the source.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目标寄存器的类型大小必须是源寄存器的两倍，并且通道数必须是源寄存器的一半。
- en: The uaddalp and saddalp instructions are functionally similar to uaddlp and
    saddlp, but rather than simply storing the pairwise sum into the destination lanes,
    they add the sum to the value already present in the destination lanes.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.3 Vector Saturating Accumulate
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set includes two instructions that sum the lanes of a source
    vector into the corresponding lanes of a destination vector. The instructions
    are
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: where t is 8B, 4H, or 2S when operating on the LO 64 bits of the registers,
    or 16B, 8H, 4S, or 2D when operating on all 128 bits. The 64-bit variants will
    clear the HO 64 bits of Vd.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are unusual in that they allow you to add (with saturation)
    an unsigned input into a signed value or add a signed number into an unsigned
    value (usually instructions operate on only one type of data).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: The usqadd instruction adds a signed value in the source lanes to the unsigned
    value in the corresponding destination lanes. Should the sum exceed the maximum
    (unsigned) value for the destination lane’s size, this instruction will saturate
    the lane to the maximum value. Should the sum go negative, this instruction saturates
    the destination lane to 0\. For example, if a half-word destination lane contains
    0xFFF0 and the corresponding source lane contains 0xFF, the usqadd instruction
    (with a 4H or 8H type) will produce 0xFFFF in the destination lane. On the other
    hand, if the destination lane contains 0x08 and the source lane contains 0xFFF0
    (–16), then their sum will produce 0 in the destination lane.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'The suqadd instruction is the converse operation: it adds an unsigned source
    operand to a signed destination operand, saturating to the maximum signed value.
    For example, if a destination half-word lane contains 0x7FF0 and the corresponding
    source lane contains 0x00FF, their sum will produce 0x7FFF, the maximum signed
    value. Note that if the destination operand contains 0xFFFF (–1) and the source
    operand is 0x0002, you wind up with 0x0001 in the destination lane (–1 + 2 = 1).'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: The usqadd and suqadd instructions also have scalar variants
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: where Rd and Rs are one of the scalar registers Bn, Hn, Sn, or Dn.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The suqadd instruction will always produce the maximum signed value when overflowing,
    as you can’t reduce the value by adding an unsigned number to it.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.4 Horizontal Add
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The addv (add across vector) instruction produces the sum of all the lanes in
    a single source vector register and leaves the result in a scalar element of another
    vector register (this is known as *reduction*). The syntax for this instruction
    is as follows
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: where R is the destination register and is one of B*n*, H*n*, or S*n*. The legal
    vector register type and lane count depend on the scalar register; [Table 11-10](chapter11.xhtml#tab11-10)
    lists the valid types.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-10: Valid Vector Register Types for addv'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '| Scalar register (Rd) | Valid lane count and types |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
- en: '| Bd | 8B or 16B |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
- en: '| Hd | 4H or 8H |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
- en: '| Sd | 4S |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
- en: This instruction is useful for summing up the elements of an array. Unfortunately,
    the destination scalar type must be the same as the source lanes’ type, and any
    overflow is ignored. There is no instruction that will zero- or sign-extend the
    sum to a double-sized result. Therefore, it’s advisable to zero- or sign-extend
    the vector elements to the next larger size prior to executing addv if overflow
    is possible. You can accomplish this by using the saddlp or uaddlp instruction
    to add adjacent pairs and sign- or zero-extend (respectively), then use the addv
    instruction to sum the resulting double-sized lanes.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: The addvl instruction is part of the ARM *scalable vector extensions (SVE)*,
    which are beyond the scope of this book. While you might expect addvl to be a
    long version of the addv instruction, it actually does something completely different.
    See the ARM SVE documentation for more details.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.5 Scalar Saturating and Scalar Pairwise Addition
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set also provides a couple of saturating scalar addition
    instructions
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: where R represents one of the scalar register names B, H, S, or D. These instructions
    operate on the 8-, 16-, 32-, or 64-bit signed or unsigned integer values found
    in the LO bits of the specified V register (see [Figure 11-2](chapter11.xhtml#fig11-2)
    for the correspondence between the V*n*, B*n*, H*n*, S*n*, and D*n* registers).
    These instructions do the same thing as their vector counterparts, except, of
    course, they operate only on a scalar value rather than doing a lane-by-lane vector
    operation.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the scalar variants of the addp and faddp instructions:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note the limited lane count and type support of these instructions.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: The addp instruction ignores (discards) any overflow from the addition of the
    two dword elements from the source vector. The addpl and addpl2 instructions have
    no scalar versions. Use the actual addpl and addpl2 instructions (with a second
    vector containing 0s) if you need an extended-precision version of this instruction.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.2 Subtraction
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While there aren’t quite as many Neon instructions for subtraction as there
    are for addition, most of the addition instructions have a subtraction complement.
    [Table 11-11](chapter11.xhtml#tab11-11) provides the syntax for the various vector
    subtraction instructions and associated data types; these instructions generally
    compute Vd = Vl *–* Vr (exceptions as noted), where Vd = destination, Vl = left
    operand, and Vr = right operand.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-11: Neon Subtraction Instructions'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
- en: '| sub | sub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane integer difference
    |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
- en: '| fsub | fsub Vd.t2, Vl.t2, Vr.t2 | Computes lane-by-lane floating-point difference
    |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
- en: '| uqsub | uqsub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane unsigned integer
    subtraction with saturation |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
- en: '| sqsub | sqsub Vd.t1, Vl.t1, Vr.t1 | Computes lane-by-lane signed integer
    subtraction with saturation |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
- en: '| usubl | usubl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane unsigned long integer
    subtraction |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
- en: '| ssubl | ssubl Vd.t3, Vl.t4, Vr.t4 | Computes lane-by-lane signed long integer
    subtraction |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
- en: '| usubl2 | usubl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane unsigned long
    integer subtraction of the HO half of Vr |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
- en: '| ssubl2 | ssubl2 Vd.t5, Vl.t6, Vr.t6 | Computes lane-by-lane signed long integer
    subtraction of the HO half of Vr |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
- en: '| usubw | usubw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane unsigned wide integer
    subtraction |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
- en: '| ssubw | ssubw Vd.t3, Vl.t3, Vr.t4 | Computes lane-by-lane signed wide integer
    subtraction |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
- en: '| usubw2 | usubw2 Vd.t5, Vl.t4, Vr.t6 | Computes lane-by-lane unsigned wide
    integer subtraction involving the upper half of Vl |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
- en: '| ssubw2 | ssubw2 Vd.t5, Vl.t5, Vr.t6 | Computes lane-by-lane signed wide integer
    subtraction involving the upper half of Vl |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
- en: '| subhn | subhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane subtraction with
    narrowing |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
- en: '| rsubhn | rsubhn Vd.t4, Vl.t3, Vr.t3 | Computes lane-by-lane subtraction with
    rounding and narrowing |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
- en: '| subhn2 | subhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane subtraction with
    narrowing (uses HO bits) |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
- en: '| rsubhn2 | rsubhn2 Vd.t6, Vl.t5, Vr.t5 | Computes lane-by-lane subtraction
    with rounding and narrowing (uses HO bits) |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
- en: '| uhsub | uhsub Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane unsigned subtraction
    with halving |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
- en: '| shsub | shsub Vd.t7, Vl.t7, Vr.t7 | Computes lane-by-lane signed subtraction
    with halving |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
- en: The behavior of these instructions is very similar to their addition counterparts,
    except, of course, that they subtract the values in the lanes rather than adding
    them. See the previous section for more details.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a saturating scalar subtraction instruction:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: That subtracts the two source scalar registers (B*n*, H*n*, S*n*, or D*n*),
    producing a scalar result.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.3 Absolute Difference
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the normal subtraction instructions, the Neon instruction set
    includes several instructions that compute the difference of the values in corresponding
    lanes and then compute the absolute value of this difference. These instructions
    are handy for computing distances and other vector (as in physics) calculations.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-12](chapter11.xhtml#tab11-12) lists the available absolute difference
    instructions. In the Syntax column, Vd = destination, Vl = left operand, and Vr
    = right operand. Each instruction generally computes Vd = abs(Vl *–* Vr), unless
    otherwise noted.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-12: Neon Absolute Difference Instructions'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction mnemonic | Syntax | Description |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
- en: '| uabd | uabd Vd.t1, Vl.t1, Vr.t1 | Vector unsigned absolute difference; lanes
    contain unsigned values. |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
- en: '| sabd | sabd Vd.t1, Vl.t1, Vr.t1 | Vector signed absolute difference; lanes
    contain signed values. |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
- en: '| uaba | uaba Vd.t1, Vl.t1, Vr.t1 | Vector unsigned absolute difference and
    accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values. |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: '| saba | saba Vd.t1, Vl.t1, Vr.t1 | Vector signed absolute difference and accumulate;
    Vd = Vd + abs(Vl – Vr), where lanes contain signed values. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| uabdl | uabdl Vd.t2, Vl.t3, Vr.t3 | Vector unsigned absolute difference long;
    lanes contain unsigned values. |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| sabdl | sabdl Vd.t2, Vl.t3, Vr.t3 | Vector signed absolute difference long;
    lanes contain signed values. |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
- en: '| uabal | uabal Vd.t2, Vl.t3, Vr.t3 | Vector unsigned absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
- en: '| sabal | sabal Vd.t2, Vl.t3, Vr.t3 | Vector signed absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain signed values. |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
- en: '| uabdl2 | uabdl2 Vd.t4, Vl.t5, Vr.t5 | Vector unsigned absolute difference
    long; lanes contain unsigned values. Uses HO 64 bits of Vl and Vr. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
- en: '| sabdl2 | sabdl2 Vd.t4, Vl.t5 Vr.t5 | Vector signed absolute difference long;
    lanes contain signed values. Uses HO 64 bits of Vl and Vr. |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
- en: '| uabal2 | uabal2 Vd.t4, Vl.t5, Vr.t5 | Vector unsigned absolute difference
    long and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain unsigned values.
    Uses HO 64 bits of Vl and Vr. |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
- en: '| sabal2 | sabal2 Vd.t4, Vl.t5, Vr.t5 | Vector signed absolute difference long
    and accumulate; Vd = Vd + abs(Vl – Vr), where lanes contain signed values. Uses
    HO 64 bits of Vl and Vr. |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Vd.t6, Vl.t6, Vr.t6 | Vector floating-point absolute difference;
    lanes contain floating-point values. |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Sd, Sl, Sr | Scalar single-precision floating-point absolute
    difference; Sd = abs(Sl – Sr). |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
- en: '| fabd | fabd Dd, Dl, Dr | Scalar double-precision floating-point absolute
    difference; Dd = abs(Dl – Dr). |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
- en: '[Table 11-13](chapter11.xhtml#tab11-13) lists the legal types for the absolute
    difference instructions.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-13: Legal Types for Absolute Difference Instructions'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, or 4S |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
- en: '| t2/t3 | 8H/8B, 4S/4H, or 2D/2S |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
- en: '| t4/t5 | 8H/16B, 4S/8H, or 2D/4S |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
- en: '| t6 | 2S, 4S, or 2D |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
- en: The uabd and sabd instructions compute the difference of each lane, take the
    absolute value of the difference, and store the result into the destination lane.
    Although the two instructions operate on unsigned and signed source operands (respectively),
    the result is always an unsigned value. Effectively, these are just variants of
    the sub instruction that take the absolute value of the result. As long as you
    treat the result as an unsigned number (particularly in the case of the sabd instruction),
    these instructions will not produce an overflow (underflow).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: The uaba and saba instructions add the absolute value of the difference to the
    corresponding lane in the destination register. If an overflow occurs (on the
    addition), these instructions store the LO bits (the lane size) into the corresponding
    destination lane. For signed operations, if Vl contains the most negative value
    (for example, 0x80 for a byte) and Vr contains 0, overflow occurs and the instruction
    winds up adding that most negative value to the destination lane.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: The suffix-l and suffix-l2 variants of these instructions compute a long calculation.
    The uabdl and sabdl instructions first zero- or sign-extend (respectively) the
    lane values to twice the lanes’ size, then compute the absolute value of the difference
    and store the result into the corresponding double-sized lane. The uabdl2 and
    sabdl2 instructions do the same thing but grab the lane data from the HO 64 bits
    of the source operands (refer back to [Figures 11-21](chapter11.xhtml#fig11-21)
    and [11-22](chapter11.xhtml#fig11-22) and substitute the appropriate instruction
    to see how this works).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: The fabd instruction computes the absolute difference of two floating-point
    values. With vector register operands, it processes two double-precision or four
    single-precision floating-point values at a time. This instruction also supports
    scalar operations (single- or double-precision) by specifying the D*n* or S*n*
    registers as operands. Unfortunately, there is no floating-point absolute difference
    and accumulate instruction. You can simulate this instruction by following an
    fabd instruction with an fadd instruction (using a spare vector register to hold
    the temporary result from fabd).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4 Vector Multiplication
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set includes several instructions that compute the product
    of corresponding lanes in the vector register (both integer and floating-point
    products). The standard vector multiply instructions appear in [Table 11-14](chapter11.xhtml#tab11-14).
    Note that Vl is the left source operand and Vr is the right source operand.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-14: Neon Vector Multiply Instructions'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
- en: '| mul | mul Vd.t1, Vl.t1, Vr.t1 | Multiplication: Vd = Vl × Vr. Ignores overflow,
    keeps LO bits of result (lane by lane). |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
- en: '| mla | mla Vd.t1, Vl.t1, Vr.t1 | Multiply and accumulate: Vd = Vd + Vl × Vr.
    Ignores overflow, keeps LO bits of result (lane by lane). |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
- en: '| mls | mls Vd.t1, Vl.t1, Vr.t1 | Multiply and subtract: Vd = Vd − Vl × Vr.
    Ignores overflow, keeps LO bits of result (lane by lane). |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
- en: '| smull | smull Vd.t2, Vl.t3, Vr.t3 | Signed extended multiplication: Vd =
    Vl × Vr. Multiplies LO half of Vl by Vr and stores extended-precision result in
    the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
- en: '| umull | umull Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiplication: Vd
    = Vl × Vr. Multiplies LO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
- en: '| smull2 | smull2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiplication: Vd
    = Vl × Vr. Multiplies HO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
- en: '| umull2 | umull2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiplication: Vd
    = Vl × Vr. Multiplies HO half of Vl by Vr and stores extended-precision result
    in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
- en: '| smlal | smlal Vd.t2, Vl.t3, Vr.t3 | Signed extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies LO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
- en: '| umlal | umlal Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies LO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
- en: '| smlal2 | smlal2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies HO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
- en: '| umlal2 | umlal2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiply and accumulate:
    Vd = Vd + Vl × Vr. Multiplies HO half of Vl by Vr and adds extended-precision
    result in the lanes of Vd (double lane size, lane-by-lane result). |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
- en: '| smlsl | smlsl Vd.t2, Vl.t3, Vr.t3 | Signed extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies LO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
- en: '| umlsl | umlsl Vd.t2, Vl.t3, Vr.t3 | Unsigned extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies LO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
- en: '| smlsl2 | smlsl2 Vd.t4, Vl.t5, Vr.t5 | Signed extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies HO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
- en: '| umlsl2 | umlsl2 Vd.t4, Vl.t5, Vr.t5 | Unsigned extended multiply and subtract:
    Vd = Vd – Vl × Vr. Multiplies HO half of Vl by Vr and subtracts this from the
    extended-precision value in the lanes of Vd (double lane size, lane-by-lane result).
    |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply: Vd = Vl × Vr.
    Multiplies the floating-point values in the Vl and Vr lanes and stores the product
    into the corresponding Vd lanes (lane by lane). |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply: Vd = Vl × Vr.
    Multiplies the floating-point values in the Vl and Vr lanes and stores the product
    into the corresponding Vd lanes (lane by lane). This variant handles the case
    where one source operand is 0 and the other is ±∞, producing the value ±2 (–2
    if –∞, +2 otherwise). |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply and accumulate:
    Vd = Vd + Vl × Vr (lane by lane). |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Vd.t6, Vl.t6, Vr.t6 | Floating-point multiply and subtract: Vd
    = Vd – Vl × Vr (lane by lane). |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
- en: '[Table 11-15](chapter11.xhtml#tab11-15) lists the legal types for the instructions
    appearing in [Table 11-14](chapter11.xhtml#tab11-14).'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-15: Legal Types for Vector Multiply Instructions'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types | Notes |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| t1 | 8B, 16B, 4H, 8H, 2S, or 4S | 8B, 4S, and 2S operate only on LO 64 bits.
    |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: '| t2/t3 | 8H/8B, 4S/4H, or 2D/2S | t3 lanes are taken from the LO 64 bits.
    |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
- en: '| t4/t5 | 8H/16B, 4S/8H, or 2D/4S | t5 lanes are taken from the HO 64 bits.
    |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
- en: '| t6 | 2S, 4S, or 2D |  |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
- en: There are also pmul, pmull, and pmull2 (polynomial multiplication) instructions.
    However, polynomial multiplication isn’t a traditional multiply operation, and
    a discussion of this is beyond the scope of this book. See the Arm documentation
    for more details on these instructions.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.1 Vector Saturating Multiplication and Double
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The vector saturating multiplication and double instructions build on the standard
    multiply, multiply and accumulate, and multiply and subtract instructions to produce
    an extended precision (long) result that doubles the product and saturates the
    result. The instructions in this set appear in [Table 11-16](chapter11.xhtml#tab11-16)
    and compute Vd = saturate({Vd ±}(Vl × Vr) × 2), where Vd is the destination operand,
    Vl is the left operand, and Vr is the right operand; {Vd ±} indicates that Vd
    ± is an optional source operand.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-16: Vector Multiply and Double with Saturation Instructions'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
- en: '| sqdmull | sqdmull Vd.t1, Vl.t2, Vr.t2 | Vd = (Vl × Vr) × 2 (lane by lane)
    |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal | sqdmlal Vd.t1, Vl.t2, Vr.t2 | Vd = Vd + (Vl × Vr) × 2 (lane by
    lane) |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl | sqdmlsl Vd.t1, Vl.t2, Vr.t2 | Vd = Vd − (Vl × Vr) × 2 (lane by
    lane) |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
- en: '| sqdmull2 | sqdmull2 Vd.t3, Vl.t4, Vr.t4 | Vd = (Vl × Vr) × 2 (lane by lane,
    HO 64 bits of source) |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal2 | sqdmlal2 Vd.t3, Vl.t4, Vr.t4 | Vd = Vd + (Vl × Vr) × 2 (lane by
    lane, HO 64 bits) |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl2 | sqdmlsl2 Vd.t3, Vl.t4, Vr.t4 | Vd = Vd – (Vl × Vr) × 2 (lane by
    lane, HO 64 bits) |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
- en: '| sqdmull | sqdmull Vd.t5, Vl.t6, Vr.t7[x] | Vd = (Vl × Vr) × 2 (Vl lanes ×
    Vr[x] scalar) |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal | sqdmlal Vd.t5, Vl.t6, Vr.t7[x] | Vd = Vd + (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar) |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl | sqdmlsl Vd.t5, Vl.t6, Vr.t7[x] | Vd = Vd – (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar) |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
- en: '| sqdmull2 | sqdmull2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = (Vl × Vr) × 2 (Vl lanes
    × Vr[x] scalar, HO 64 bits) |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
- en: '| sqdmlal2 | sqdmlal2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = Vd + (Vl × Vr) × 2 (Vl
    lanes × Vr[x] scalar, HO 64 bits) |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
- en: '| sqdmlsl2 | sqdmlsl2 Vd.t8, Vl.t9, Vr.t10[x] | Vd = Vd – (Vl × Vr) × 2 (Vl
    lanes × Vr[x] scalar, HO 64 bits) |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
- en: The legal types and lane counts appear in [Table 11-17](chapter11.xhtml#tab11-17).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-17: Legal Types and Lane Counts for Vector Multiply and Double with
    Saturation'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types and lane counts |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4S/4H, or 2D/2S |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 4S/8H, or 2D/4S |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
- en: '| t5/t6/t7 | 4S/4H/H, or 2D/2S/S |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
- en: '| t8/t9/t10 | 4S/8H/H, or 2D/4S/S |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
- en: These instructions all sign-extend their source operands to twice their size
    and multiply them to produce a product. They then multiply this product by 2\.
    The standard multiply variants saturate and store this product into the corresponding
    destination lane. The multiply and accumulate variants add the product (multiplied
    by 2) to the destination and saturate the result. The multiply and subtract variants
    subtract the product (multiplied by 2) from the destination and saturate the result.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: The instructions without a 2 suffix extract their lanes from the LO 64 bits
    of the first source register, while those with a 2 suffix extract their lanes
    from the HO 64 bits of the second source register.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: The last six instructions in [Table 11-16](chapter11.xhtml#tab11-16) multiply
    the lanes in Vl by a scalar value selected from one of the lanes in Vr (selected
    by the [x] index operator). Here, x must be an appropriate value for the source
    type (0 to 7 for bytes, 0 to 3 for half words, or 0 to 1 for words). For the last
    six forms, if t10 is H, then the Vr register number (r) must be in the range 0
    to 15.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of “short” versions of the sqdmul* instructions don’t double the type
    size in the destination register: sqdmulh and sqrdmulh. These instructions also
    multiply their source operands, double the result, and saturate it. However, they
    store only the HO 64 bits of the result into the destination lane (with saturation
    and possible rounding). [Table 11-18](chapter11.xhtml#tab11-18) lists these instructions.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-18: Saturating Multiply and Double Instructions, HO Bits'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Vd.t1, Vl.t1, Vr.t1 | Lane-by-lane multiply, double, saturate,
    and keep HO half of product. |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Vd.t1, Vl.t1, Vr.t1 | Lane-by-lane multiply, double,
    round, saturate, and keep HO half of product. |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Vd.t2, Vl.t3, Vr.t4[x] | Multiply the lanes in Vl by the
    scalar selected by Vr[x]; double the result, saturate, and keep the HO half of
    the product. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Vd.t2, Vl.t3, Vr.t4[x] | Multiply the lanes in Vl by
    the scalar selected by Vr[x]; double the result, round, saturate, and keep the
    HO half of the product. |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: '| sqdmulh | sqdmulh Rd, Rl, Rr | Scalar version of sqdmulh. |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
- en: '| sqrdmulh | sqrdmulh Rd, Rl, Rr | Scalar version of sqrdmulh. |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
- en: In this table, t1 is 4H, 8H, 2S, or 4S. For the 4H and 2S types, the instruction
    works only with the LO 64 bits of the registers; the 8H and 4S types use all 128
    bits.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: The type specification t2/t3/t4 is 4H/4H/H, 8H/8H/H, 2S/2S/S, or 4S/S; the 4H
    and 2S types work with the LO 64 bits of the registers, and the 8H and 4S types
    work on all 128 bits of the registers. If the type is H, Vr’s register number
    must be in the range 0 to 15.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: If the [x] index appears after Vr*.*t4, the instruction multiplies the lanes
    in Vl by the scalar value extracted from lane x of Vr, which must be an appropriate
    value for the source type (0 to 7 for bytes, 0 to 3 for half words, or 0 to 1
    for words).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: These instructions have two scalar variants. R (in Rd, Rl, and Rr) must be H
    or S. For example
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: computes H0 = saturate(H1 × H2 × 2).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.2 Vector Multiplication by a Scalar Element
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions that multiply all the
    elements of a vector by a single scalar value, as listed in [Table 11-19](chapter11.xhtml#tab11-19).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-19: Vector Multiply by Scalar Instructions'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
- en: '| mul | mul Vd.t1, Vl.t1, Vr.t2[x] | Multiply integer vector element by scalar
    value. Multiply each lane in Vl by Vr[x] (scalar value) and store the product
    into the corresponding lane in Vd (that is, for each lane i, Vd[i] = Vl[i] × Vr[x]).
    |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
- en: '| mla | mla Vd.t1, Vl.t1, Vr.t2[x] | Multiply vector elements by a scalar and
    accumulate. For each lane i, Vd[i] = Vd[i] + Vl[i] × Vr[x]. |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
- en: '| mls | mls Vd.t1, Vl.t1, Vr.t2[x] | Multiply vector elements by a scalar and
    subtract. For each Iane i, Vd[i] = –d[i] – Vl[i] × Vr[x]. |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
- en: '| smull | smull Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar,
    long. Sign-extend the (LO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the LO 64 bits
    of Vl. |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
- en: '| smlal | smlal Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar and
    accumulate, long. Similar to smull, but sums the product into Vd rather than just
    storing it into Vd. |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
- en: '| smlsl | smlsl Vd.t3, Vl.t4, Vr.t5[x] | Signed vector multiply by scalar and
    subtract, long. Similar to smull, but subtracts the product from Vd rather than
    just storing it into Vd. |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
- en: '| smull2 | smull2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar,
    long. Sign-extend the (HO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the HO 64 bits
    of Vl. |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
- en: '| smlal2 | smlal2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar
    and accumulate, long (HO source). Similar to smull2, but sums the product into
    Vd rather than just storing it into Vd. |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
- en: '| smlsl2 | smlsl2 Vd.t6, Vl.t7, Vr.t8[x] | Signed vector multiply by scalar
    and subtract, long (HO source). Similar to smull2, but subtracts the product from
    Vd rather than just storing it into Vd. |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
- en: '| umull | umull Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar,
    long. Zero-extend the (LO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the LO 64 bits
    of Vl. |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
- en: '| umlal | umlal Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar
    and accumulate, long. Similar to umull, but sums the product into Vd rather than
    just storing it into Vd. |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
- en: '| umlsl | umlsl Vd.t3, Vl.t4, Vr.t5[x] | Unsigned vector multiply by scalar
    and subtract, long. Similar to umull, but subtracts the product from Vd rather
    than just storing it into Vd. |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
- en: '| umull2 | umull2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar,
    long. Zero-extend the (HO) lanes in Vl to twice their size, multiply by Vr[x],
    and store the result into the double-sized lane in Vd. Uses only the HO 64 bits
    of Vl. |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
- en: '| umlal2 | umlal2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar
    and accumulate, long (HO source). Similar to umull2, but sums the product into
    Vd rather than just storing it into Vd. |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
- en: '| umlsl2 | umlsl2 Vd.t6, Vl.t7, Vr.t8[x] | Unsigned vector multiply by scalar
    and subtract, long (HO source). Similar to umull2, but subtracts the product from
    Vd rather than just storing it into Vd. |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar. Multiply each lane in Vl by Vr[x] (scalar value) and store the product
    into the corresponding lane in Vd (that is, for each lane i, Vd[i] = Vl[i] × Vr[x]).
    |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Vd.t9, Vl.t10, Vr.t11[x] | Like fmul, except it’s a special
    variant that handles the case where one source operand is 0 and the other is ±∞.
    This produces the value ±2 (–2 if –∞, +2 otherwise). |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar and accumulate. Multiply each lane in Vl by Vr[x] (scalar value) and add
    the product into the corresponding lane in Vd (that is, for each lane i, Vd[i]
    = Vd[i] + Vl[i] × Vr[x]). |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Vd.t9, Vl.t10, Vr.t11[x] | Floating-point vector multiply by
    scalar and subtract. Multiply each lane in Vl by Vr[x] (scalar value) and subtract
    the product from the corresponding lane in Vd (that is, for each lane i, Vd[i]
    = Vd[i] – Vl[i] × Vr[x]). |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
- en: '[Table 11-20](chapter11.xhtml#tab11-20) lists the legal types and lane counts
    for the instructions in [Table 11-19](chapter11.xhtml#tab11-19).'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-20: Legal Types and Lane Counts for Vector Multiply by Scalar'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Legal types and lane counts |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4H/H, 8H/H, 2S/S, or 4S/S |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
- en: '| t3/t4/t5 | 4S/4H/H or 2D/2S/S |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
- en: '| t6/t7/t8 | 4S/8H/H, or 2D/4S/S |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
- en: '| t9/t10/t11 | 2S/2S/S, 4S/S, or 2D/D |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
- en: '[Figure 11-26](chapter11.xhtml#fig11-26) shows the basic operation of the mul,
    mla, mls, fmul, fmla, and fmls instructions.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-26.jpg)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-26: Vector multiply by scalar operation'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-27](chapter11.xhtml#fig11-27) shows the basic operation of the smull,
    umull, smlal, umlal, smlsl, and umlsl instructions.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-27.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-27: Vector multiply by scalar, long (LO bits)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-28](chapter11.xhtml#fig11-28) shows the basic operation of the smull2,
    umull2, smlal2, umlal2, smlsl2, and umlsl2 instructions.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-28.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-28: Vector multiply by scalar, long (HO bits)'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Because the product of two *n*-bit numbers fits into 2*n* bits, the smul/smul2
    and umul/umul2 instructions will not produce an overflow. However, keep in mind
    that an addition or subtraction after the multiplication could require an additional
    bit (2*n* + 1 bits). Should that occur, these instructions will ignore the overflow
    and keep the LO bits.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4.3 Scalar Multiplication by a Vector Element
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Neon instruction set provides variants of the fmul instructions that multiply
    a scalar register (Sn or Dn) by a vector element (Vn[x]), storing the result back
    into a scalar register. [Table 11-21](chapter11.xhtml#tab11-21) lists the syntax
    for these instructions, where Fl is the left source operand and Vr is the right
    source operand.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-21: Floating-Point Scalar Multiplication by Vector Element Instructions'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
- en: '| fmul | fmul Fd, Fl, Vr.t[x] | Fd = Fl × Vr.t[x] |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
- en: '| fmulx | fmulx Fd, Fl, Vr.t[x] | Fd = Fl × Vr.t[x]. Handles case where Fl
    = 0.0 and Vr.t is ±∞, which produces ±2.0. |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
- en: '| fmla | fmla Fd, Fl, Vr.t[x] | Fd = Fd + Fl × Vr.t[x] |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
- en: '| fmls | fmls Fd, Fl, Vr.t[x] | Fd = Fd – Fl × Vr.t[x] |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
- en: Registers Fd and Fl are each one of the scalar floating-point registers (Sn
    or Dn). Type t must be a matching size (S or D). If the type is single-precision
    (Sn), then Vr must be a register in the range V0 to V15.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: These multiplication instructions have no integer equivalents.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.5 Vector Division
  id: totrans-798
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set does not provide any instructions to perform integer
    division on vectors. It does, however, provide an instruction to perform floating-point
    division on lanes in a pair of vectors
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: where t is 2S, 4S, or 2D. (A division by zero produces NaN in the destination
    lane.)
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: Because floating-point division is rather slow, especially when iterated over
    all the lanes, the Neon instruction set includes a pair of instructions that will
    compute the reciprocal of a floating-point value. Multiplication by a reciprocal
    is usually much faster than division. If you’re dividing by a constant, you can
    precompute the reciprocal value at assembly time and use that (no runtime cost).
    If the value is a variable that you cannot compute at assembly time, you can use
    the frecpe instruction to *approximate* the reciprocals of all the lanes in a
    vector register
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: where t is 2S, 4S, or 2D (2S operates on the LO 64 bits of the registers).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: There is a scalar version of frecpe
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: where Rd and Rs are either S*n* or D*n*.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'The frecpe instruction produces a reciprocal approximation that is within 8
    bits of the correct value—not great, but good enough for quick-and-dirty calculations.
    If you need better accuracy, use the frecps instruction (same syntax except for
    the mnemonic) to compute another step in the Newton-Raphson reciprocal approximation
    algorithm, using code like the following:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The more times you repeat the refinement step, the more accurate your result
    will be. However, at some point, the cost of executing all these floating-point
    instructions will exceed the time consumed by a single fdiv instruction, so take
    care because using frecps has diminishing returns.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: There is a urecpe instruction for estimating fixed-point reciprocals, but fixed-point
    arithmetic is beyond this scope of this book. To learn more, see the ARM Architecture
    Reference Manual, linked in section 11.15, “For More Information,” on [page 700](chapter11.xhtml#pg_700).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.6 Sign Operations
  id: totrans-812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set includes four instructions that allow you to negate
    or take the absolute values of the lanes in a vector register
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: where t1 represents the usual integer types (8B, 16B, 4H, 8H, 2S, 4S, or 2D)
    and t2 represents the usual floating-point types (2S, 4S, and 2D). The 8B, 4H,
    and 2S types reference only the LO 64 bits of the vector register.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: The abs and fabs instructions compute the absolute values of each of the lanes
    in the source register, storing the result into the destination register. Obviously,
    abs works on (signed) integer values, while fabs works on floating-point values.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: The neg and fneg instruction negate (change the sign of) the source lanes, leaving
    the negated result in the corresponding destination lane. As expected, neg works
    on signed integers, and fneg works on floating-point values.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: The sqabs and sqneg instructions are special saturating variants of the abs
    and neg instructions that never overflow. The most negative value (for example,
    0x80 for byte values) will overflow when you take its absolute value or negate
    it; in both cases, you wind up with the same value. The sqabs and sqneg instruction
    will produce the maximum positive value (for example, 0x7F for byte values) if
    you attempt to negate it or take its absolute value.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: The abs, neg, sqabs, and sqneg instructions also have scalar versions, as shown
    in [Table 11-22](chapter11.xhtml#tab11-22). For abs and neg, Rd and Rs can be
    only Dn; for sqabs and sqneg, Rd and Rs are one of the scalar registers Bn, Hn,
    Sn, or Dn.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-22: Scalar Sign Operations'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
- en: '| abs | abs Rd, Rs | Rd = abs(Rs) |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
- en: '| neg | neg Rd, Rs | Rd = –Rs |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
- en: '| sqabs | sqabs Rd, Rs | Rd = abs(Rs), saturated to maximum signed value |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
- en: '| sqneg | sqneg Rd, Rs | Rd = –Rs, saturated to signed range |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
- en: The instructions in [Table 11-22](chapter11.xhtml#tab11-22) operate on the scalar
    value in the specified register.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7 Minimum and Maximum
  id: totrans-828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions that will select the
    minimum or maximum value from corresponding lanes in two vector registers and
    store that value into the corresponding lane of a destination register, as shown
    in [Table 11-23](chapter11.xhtml#tab11-23).
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-23: Vector Min and Max Instructions'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-831
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-832
  prefs: []
  type: TYPE_TB
- en: '| smin | smin Vd.t1, Vl.t1, Vr.t1 | Vd = min(Vl, Vr) (signed integer values)
    |'
  id: totrans-833
  prefs: []
  type: TYPE_TB
- en: '| smax | smax Vd.t1, Vl.t1, Vr.t1 | Vd = max(Vl, Vr) (signed integer values)
    |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
- en: '| umin | umin Vd.t1, Vl.t1, Vr.t1 | Vd = min(Vl, Vr) (unsigned integer values)
    |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
- en: '| umax | umax Vd.t1, Vl.t1, Vr.t1 | Vd = max(Vl, Vr) (unsigned integer values)
    |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
- en: '| fmin | fmin Vd.t2, Vl.t2, Vr.t2 | Vd = min(Vl, Vr) (floating-point values)
    |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
- en: '| fmax | fmax Vd.t2, Vl.t2, Vr.t2 | Vd = max(Vl, Vr) (floating-point values)
    |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
- en: '| fminnm | fminnm Vd.t2, Vl.t2, Vr.t2 | Vd = min(Vl, Vr) (floating-point values)
    |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
- en: '| fmaxnm | fmaxnm Vd.t2, Vl.t2, Vr.t2 | Vd = max(Vl, Vr) (floating-point values)
    |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
- en: In this table, t1 must be 8B, 16B, 4H, 8H, 2S, or 4S. If t1 is 8B, 4H, or 2S,
    the instructions operate only on the lanes in the LO 64 bits of the vector registers;
    if it is 16B, 8H, or 4S, the instructions operate on all 128 bits of the vector
    registers.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: The type t2 must be 2S, 4S, or 2D. If it is 2S, the instructions operate only
    on the LO 64 bits of the vector registers; otherwise, they operate on the entire
    128 bits.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: The fmin and fmax instructions return NaN if either (or both) of the corresponding
    source lanes contain a NaN. The fminnm and fmaxnm instructions, on the other hand,
    return the numeric value if one lane contains a valid number and the other contains
    a NaN. If both lanes contain a valid floating-point value, all four instructions
    behave the same and return the minimum or maximum value (as appropriate).
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.1 Pairwise Minimum and Maximum
  id: totrans-844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The minimum and maximum instructions also have pairwise variants, as shown in
    [Table 11-24](chapter11.xhtml#tab11-24), where t1 and t2 are the same as for the
    lane-by- lane instructions.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-24: Pairwise Minimum and Maximum Instructions'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description | Operates on |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
- en: '| sminp | sminp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_min(Vl, Vr) | Signed integers
    |'
  id: totrans-849
  prefs: []
  type: TYPE_TB
- en: '| smaxp | smaxp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_max(Vl, Vr) | Signed integers
    |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
- en: '| uminp | uminp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_min(Vl, Vr) | Unsigned
    integers |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
- en: '| umaxp | umaxp Vd.t1, Vl.t1, Vr.t1 | Vd = pairwise_max(Vl, Vr) | Unsigned
    integers |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
- en: '| fminp | fminp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_min(Vl, Vr) | Floating-point
    values |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
- en: '| fmaxp | fmaxp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_max(Vl, Vr) | Floating-point
    values |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
- en: '| fminnmp | fminnmp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_min(Vl, Vr) | Floating-point
    values |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmp | fmaxnmp Vd.t2, Vl.t2, Vr.t2 | Vd = pairwise_max(Vl, Vr) | Floating-point
    values |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
- en: The pairwise topology is the same as for the addp instruction (see [Figure 11-29](chapter11.xhtml#fig11-29)
    for a uminp example).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-29.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-29: Pairwise minimum and maximum operations'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: There are also a set of pairwise-scalar floating-point minimum and maximum instructions,
    as shown in [Table 11-25](chapter11.xhtml#tab11-25), where Rd/t must be Sn/2S
    or Dn/2D.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-25: Pairwise-Scalar Floating-Point Minimum and Maximum Instructions'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
- en: '| fmaxp | fmaxp Rd, Vs.t | Rd = max(Vs) |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmp | fmaxnmp Rd, Vs.t | Rd = max(Vs) (choose number over NaN) |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
- en: '| fminp | fminp Rd, Vs.t | Rd = min(Vs) |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
- en: '| fminnmp | fminnmp Rd, Vs.t | Rd = min(Vs) (choose number over NaN) |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
- en: These instructions have no integer versions.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.2 Horizontal Minimum and Maximum
  id: totrans-869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The horizontal minimum and maximum instructions select the minimum or maximum
    value within a single vector, as shown in [Table 11-26](chapter11.xhtml#tab11-26).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-26: Horizontal (Across Vector) Minimum and Maximum Instructions'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
- en: '| sminv | sminv Rd, Vs.t1 | Extract minimum signed lane value from Vs and store
    into Rd. |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
- en: '| smaxv | smaxv Rd, Vs.t1 | Extract maximum signed lane value from Vs and store
    into Rd. |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
- en: '| uminv | uminv Rd, Vs.t1 | Extract minimum unsigned lane value from Vs and
    store into Rd. |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
- en: '| umaxv | umaxv Rd, Vs.t1 | Extract maximum unsigned lane value from Vs and
    store into Rd. |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
- en: '| fminv | fminv Sd, Vs.t2 | Extract minimum real lane value from Vs and store
    into Sd. |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
- en: '| fmaxv | fmaxv Sd, Vs.t2 | Extract maximum real lane value from Vs and store
    into Rd. |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
- en: '| fminnmv | fminnmv Sd, Vs.t2 | Extract minimum real lane value from Vs and
    store into Sd. |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
- en: '| fmaxnmv | fmaxnmv Sd, Vs.t2 | Extract maximum real lane value from Vs and
    store into Rd. |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
- en: In this table, Rd/t1 is B/8B, B/16B, H/4H, H/8H, or S/4S. If t1 is 8B, or 4H,
    the instruction operates only on the lanes in the LO 64 bits of Vs. For floating-point
    minimum and maximum, only single-precision operands are legal; t2 must be 2S or
    4S (operating on the LO 64 bits or the full 128 bits of the source register).
    As for the standard fmin and fmax instructions, the nm variants differ insofar
    as they return the numeric value if one of the operands is NaN.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 Floating-Point and Integer Conversions
  id: totrans-883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set provides several instructions to convert between floating-point
    and integer (or fixed-point) formats. Section 6.9.4, “Floating-Point Conversion
    Instructions,” on [page 343](chapter6.xhtml#pg_343) provided examples of these
    conversion instructions when operating on scalar registers; the following subsections
    present the vector equivalents.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.1 Floating-Point to Integer
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides vector equivalents of the fcvt* instructions
    that convert floating-point values to their integer equivalents, as shown in [Table
    11-27](chapter11.xhtml#tab11-27).
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-27: Floating-Point to Integer Conversion Instructions'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
- en: '| fcvtns | fcvtns Vd.t, Vs.t | Round to nearest signed integer. Exactly one-half
    rounds to nearest even integer. |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
- en: '| fcvtas | fcvtas Vd.t, Vs.t | Round to nearest signed integer. Exactly one-half
    rounds away from zero. |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
- en: '| fcvtps | fcvtps Vd.t, Vs.t | Round toward +∞ (signed integer). |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
- en: '| fcvtms | fcvtms Vd.t, Vs.t | Round toward –∞ (signed integer). |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
- en: '| fcvtzs | fcvtzs Vd.t, Vs.t | Round toward 0 (signed integer). |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
- en: '| fcvtnu | fcvtnu Vd.t, Vs.t | Round to nearest unsigned integer. Exactly one-half
    rounds to nearest even integer. |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
- en: '| fcvtau | fcvtau Vd.t, Vs.t | Round to nearest unsigned integer. Exactly one-half
    rounds away from 0. |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
- en: '| fcvtpu | fcvtpu Vd.t, Vs.t | Round toward +∞ (unsigned integer). |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
- en: '| fcvtmu | fcvtmu Vd.t, Vs.t | Round toward –∞ (unsigned integer). |'
  id: totrans-898
  prefs: []
  type: TYPE_TB
- en: '| fcvtzu | fcvtzu Vd.t, Vs.t | Round toward 0 (unsigned integer). |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
- en: In this table, t is 2S (which uses only the LO 64 bits of the vector registers),
    4S, or 2D. The source operand is always assumed to contain floating-point values
    (single- or double-precision), and the destination lanes will receive signed or
    unsigned integer values (words or dwords). Note that when converting negative
    floating-point values to unsigned integers, the conversion saturates the conversion
    to 0.0.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'The fcvtz* instruction also has some fixed-point variants:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The imm operand specifies the number of fractional bits to maintain in the fixed-point
    value (this must be 1 to 31 for single-precision or word types and 1 to 63 for
    double-precision or dword types). Because integer operations are somewhat faster
    than floating-point calculations, sometimes it is faster to convert operands to
    fixed-point, do a chain of calculations, then convert the result back to floating-point.
    However, this book doesn’t cover fixed-point arithmetic in depth, so I won’t discuss
    this technique any further. See section 11.15, “For More Information,” on [page
    700](chapter11.xhtml#pg_700) for additional information.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.2 Integer to Floating-Point
  id: totrans-904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ucvtf and scvtf instructions convert 32- and 64-bit integers to single-
    and double-precision values, respectively. Their syntax is roughly the same as
    that of fcvt*:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As with fcvt*, t must be 2S, 4S, or 2D (2S converts only the LO 64 bits).
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: Because double-precision values have only a 56-bit mantissa and single-precision
    values have only a 24-bit mantissa, you cannot exactly represent certain 32- and
    64-bit integers as single- or double-precision floating-point values. In those
    cases, the scvtf and ucvtf instructions produce the closest approximation. However,
    keep in mind that executing *cvtf followed by an fcvt* instruction may not return
    the exact same integer.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.8.3 Conversion Between Floating-Point Formats'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: The Neon instruction set provides three instructions that will convert a small
    floating-point format to a larger form, or a larger form to a smaller form. This
    is one of the few instructions in the ARM instruction set that supports half-precision
    (16-bit) floating-point numbers. [Table 11-28](chapter11.xhtml#tab11-28) shows
    the available instructions.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-28: Floating-Point Conversion Instructions'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane conversion |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
- en: '| fcvtl | fcvtl Vd.t1, Vs.t2 | Convert from a smaller size to the next larger
    size by using the LO 64 bits of the source register. |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
- en: '| fcvtl2 | fcvtl2 Vd.t3, Vs.t4 | Convert from a smaller size to the next larger
    size by using the upper 64 bits of the source register (does not affect the LO
    bits of the destination register). |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
- en: '| fcvtn | fcvtn Vd.t5, Vs.t6 | Convert from a larger size to a smaller size
    by using the LO 64 bits of the destination register. |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
- en: '| fcvtn2 | fcvtn2 Vd.t7, Vs.t8 | Convert from a larger size to a smaller size
    by using the HO 64 bits of the destination register (does not affect the LO bits
    of the destination register). |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
- en: '| fcvtxn | fcvtxn Vd.2S, Vs.2D | Like fcvtn, except rounding is different (see
    text). |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
- en: '| fcvtxn2 | fcvtxn2 Vd.4S, Vs.2D | Like fcvtn2, except rounding is different
    (see text). |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
- en: The legal types and lane counts for the instructions in [Table 11-28](chapter11.xhtml#tab11-28)
    appear in [Table 11-29](chapter11.xhtml#tab11-29), where H = 16-bit half-precision
    floating-point, S = 32-bit single-precision floating-point, and D = 64-bit double-precision
    floating-point.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-29: Legal Types and Lane Counts for Floating-Point Conversions'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '| t | Types and lane counts |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
- en: '| t1/t2 | 4S/4H or 2D/2S |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
- en: '| t3/t4 | 4S/8H or 2D/4S |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
- en: '| t5/t6 | 4H/4S or 2S/2D |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
- en: '| t7/t8 | 8H/4S or 4S/2D |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
- en: Conversion from a smaller size to a larger size always produces an exact result.
    Conversion from a larger size down to a smaller size may require rounding the
    result to fit in the smaller size (worst case, overflow or underflow will occur
    if the larger value cannot be represented at all in the smaller floating-point
    format).
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: 'When rounding larger values to fit into a smaller format, the fcvtn and fcvtn2
    instructions use the standard IEEE-754 round-to-nearest-even algorithm. In some
    cases, this may not produce the best result. For example, it is generally better
    to round to the nearest odd when converting a half-precision value to a double-precision
    value (which requires two steps: convert half-precision to single-precision, then
    convert single-precision to double-precision). The fcvtxn and fcvtxn2 instructions
    employ this non-IEEE rounding scheme to produce better results.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.4 Floating-Point Values Rounded to the Nearest Integral
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Certain algorithms require rounding a floating-point value to an integer but
    require the result to be maintained in the floating-point format. The frint* instructions
    listed in [Table 11-30](chapter11.xhtml#tab11-30) provide this capability.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-30: Rounding a Floating-Point Value to an Integral Value'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane rounding operation |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
- en: '| frintn | frintn Vd.t, Vs.t | Round to nearest integer. Exactly one-half rounds
    to nearest even integer. |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
- en: '| frinta | frinta Vd.t, Vs.t | Round to nearest integer. Exactly one-half rounds
    away from 0. |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
- en: '| frintp | frintp Vd.t, Vs.t | Round toward +∞. |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
- en: '| frintm | frintm Vd.t, Vs.t | Round toward –∞. |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
- en: '| frintz | frintz Vd.t, Vs.t | Round toward 0. |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
- en: '| frinti | frinti Vd.t, Vs.t | Round using FPCR rounding mode. |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
- en: '| frintx | frintx Vd.t, Vs.t | Round using FPCR rounding mode with exactness
    test. |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
- en: In this table, t must be 2S, 4S, or 2D. If it is 2S, these instructions use
    only the LO 64 bits of the registers.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: The frintx instruction generates a floating-point inexact result exception if
    the rounded result is not equal to the original source value. You won’t normally
    use this instruction unless you have an appropriate exception handler in place.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 Vector Square-Root Instructions
  id: totrans-944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Neon instruction set provides two instructions for computing the square
    root of a floating-point value and computing (and refining) an estimate of the
    reciprocal of the square root of a floating-point value. [Table 11-31](chapter11.xhtml#tab11-31)
    lists these instructions.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-31: Vector Square Root Instructions'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane operation |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
- en: '| fsqrt | fsqrt Vd.t, Vs.t | Compute square root of source and store into destination
    |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
- en: '| frsqrte | frsqrte Vd.t, Vs.t | First step of Newton-Raphson approximation
    of the reciprocal of the square root |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
- en: '| frsqrts | frsqrts Vd.t, Vs1.t, Vs2.t | Additional steps of the Newton-Raphson
    approximation |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
- en: In the table, t must be 2S, 4S, or 2D. If it’s 2S, these instructions operate
    on the lanes in the LO 64 bits of the vector registers.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: These three instructions also have scalar versions
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: where Rd and Rs are one of the floating-point scalar registers Sn or Dn.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Note that the frsqrts instruction multiplies corresponding floating-point values
    in the lanes of the two source registers, subtracts each of the products from
    3.0, divides these results by 2.0, and places the results into the destination
    register.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 11.10 Vector Comparisons
  id: totrans-957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vector comparisons are fundamentally different from normal (general-purpose
    register) comparisons. When comparing general-purpose registers (or even individual
    floating-point scalar values), the ARM CPU sets the condition codes based on the
    result of the comparison; the code following the comparison then tests those condition
    codes, using a conditional branch, for example. This scheme doesn’t work when
    comparing vector elements because the CPU always performs multiple comparisons
    in parallel. There’s only one set of condition codes, so the CPU cannot put the
    results of multiple comparisons into the condition codes, meaning vector comparisons
    require a different mechanism to make the comparison results available to the
    program.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a generic comparison that produces less than, greater than, or equal
    results simultaneously (in the condition codes), a vector comparison asks for
    a specific comparison, such as, “Are the elements of this vector greater than
    the elements of another vector?” The result is true or false for each lane-by-lane
    comparison. A vector comparison will store the true or false result into the corresponding
    lanes of a destination vector. Vector comparisons use all 0 bits in a lane to
    represent false and all 1 bits in a lane to represent true.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: 'Neon has two general sets of vector comparison instructions: one for integer
    comparisons and another for floating-point comparisons. The following subsections
    discuss each of these forms.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '#### 11.10.1 Vector Integer Comparisons'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-32](chapter11.xhtml#tab11-32) lists the generic vector integer compare
    instructions, where t is 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For the 8B, 4H, and 2S
    types, these instructions operate only on the LO 64 bits of the registers and
    clear the HO 64 bits of the destination register.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-32: Vector Integer Comparison Instructions'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Vd.t, Vl.t, Vr.t | Signed or unsigned comparison for equality
    |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
- en: '| cmhs | cmhs Vd.t, Vl.t, Vr.t | Unsigned comparison for greater than or equal
    (Vd = Vl ≥ Vr) |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
- en: '| cmhi | cmhi Vd.t, Vl.t, Vr.t | Unsigned comparison for greater than (Vd =
    Vl > Vr) |'
  id: totrans-968
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Vd.t, Vl.t, Vr.t | Signed comparison for greater than or equal
    (Vd = Vl ≥ Vr) |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Vd.t, Vl.t, Vr.t | Signed comparison for greater than (Vd = Vl
    > Vr) |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
- en: There is no cmne instruction. You can invert all the bits in the destination
    register (using the not instruction) if you need this comparison, or you can use
    0 bits to imply true and 1 bits to imply false. Likewise, there are no cmls, cmlo,
    cmle, or cmlt instructions; you can derive these from cmgt, cmge, cmhs, or cmhi
    by reversing the operands.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: These instructions have scalar variants, as shown in [Table 11-33](chapter11.xhtml#tab11-33),
    where Rd, Rl, and Rr must be Dn.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-33: Scalar Integer Comparison Instructions'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Rd, Rl, Rr | Signed or unsigned comparison for equality |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
- en: '| cmhs | cmhs Rd, Rl, Rr | Unsigned comparison for greater than or equal (Rd
    = Rl ≥ Rr) |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
- en: '| cmhi | cmhi Rd, Rl, Rr | Unsigned comparison for greater than (Rd = Rl >
    Rr) |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Rd, Rl, Rr | Signed comparison for greater than or equal (Rd
    = Rl ≥ Rr) |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Rd, Rl, Rr | Signed comparison for greater than (Rd = Rl > Rr)
    |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
- en: A special set of vector comparison instructions exists to compare the lanes
    of a single vector against 0\. This saves setting up a register to contain all
    0s for this common case. The available instructions perform only signed comparisons
    (it doesn’t make much sense to compare unsigned values against 0). [Table 11-34](chapter11.xhtml#tab11-34)
    lists these instructions.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-34: Signed Vector Comparisons Against 0'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison against 0 |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Vd.t, Vl.t, #0 | Signed comparison for lanes equal to 0 |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Vd.t, Vl.t, #0 | Signed comparison for lanes greater than or
    equal to 0 |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Vd.t, Vl.t, #0 | Signed comparison for lanes greater than 0 |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
- en: '| cmle | cmle Vd.t, Vl.t, #0 | Signed comparison for lanes less than or equal
    to 0 |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
- en: '| cmlt | cmlt Vd.t, Vl.t, #0 | Signed comparison for lanes less than 0 |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
- en: The type t must be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. For the 8B, 4H, and 2S types,
    these instructions operate only on the LO 64 bits of the registers and clear the
    HO 64 bits of the destination register. The only legal immediate constant is 0
    with these instructions.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-35](chapter11.xhtml#tab11-35) lists the scalar versions of these
    instructions.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-35: Scalar Vector Comparisons Against 0'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison against 0 |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
- en: '| cmeq | cmeq Rd, Rl, #0 | Signed comparison for register equal to 0 |'
  id: totrans-995
  prefs: []
  type: TYPE_TB
- en: '| cmge | cmge Rd, Rl, #0 | Signed comparison for register greater than or equal
    to 0 |'
  id: totrans-996
  prefs: []
  type: TYPE_TB
- en: '| cmgt | cmgt Rd, Rl, #0 | Signed comparison for register greater than 0 |'
  id: totrans-997
  prefs: []
  type: TYPE_TB
- en: '| cmle | cmle Rd, Rl, #0 | Signed comparison for register less than or equal
    to 0 |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
- en: '| cmlt | cmlt Rd, Rl, #0 | Signed comparison for register less than 0 |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
- en: In this table, Rd, Rl, and Rr must be Dn.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.2 Vector Floating-Point Comparisons
  id: totrans-1001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also compare floating-point values in the vector registers’ lanes. [Table
    11-36](chapter11.xhtml#tab11-36) lists the various fcm* instructions available
    for this purpose, where t is 2S, 4S, or 2D. If t is 2S, these instructions use
    only the LO 64 bits of the registers.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-36: Vector Floating-Point Comparison Instructions'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Vd.t, Vl.t, Vr.t | Floating-point comparison for equality |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = Vl ≥ Vr)
    |'
  id: totrans-1007
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = Vl > Vr)
    |'
  id: totrans-1008
  prefs: []
  type: TYPE_TB
- en: '[Table 11-37](chapter11.xhtml#tab11-37) lists variants of the fcm* instructions
    that compare the lanes in a vector register against 0.0, where t is 2S, 4S, or
    2D. If t is 2S, these instructions use only the LO 64 bits of the registers.'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-37: Vector Floating-Point Comparison Against 0.0'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Lane-by-lane comparison against 0.0 |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Vd.t, Vl.t, #0 | Floating-point comparison for register equal
    to 0.0 |'
  id: totrans-1013
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Vd.t, Vl.t, #0 | Floating-point comparison for register greater
    than or equal to 0.0 |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Vd.t, Vl.t, #0 | Floating-point comparison for register greater
    than 0.0 |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
- en: '| fcmle | fcmle Vd.t, Vl.t, #0 | Floating-point comparison for register less
    than or equal to 0.0 |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
- en: '| fcmlt | fcmlt Vd.t, Vl.t, #0 | Floating-point comparison for register less
    than 0.0 |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
- en: 'Note that the immediate constant is 0 (versus 0.0), even though this is a floating-point
    comparison. The only legal operand for this instruction is #0.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: As for the integer comparisons, the fcm* instructions provide a set of scalar
    instructions that also store true (all 1 bits) or false (all 0 bits) into the
    destination register (in contrast to the fcmp instructions that set the condition
    code flags). [Table 11-38](chapter11.xhtml#tab11-38) lists the scalar versions
    of these instructions, where Rd, Rl, and Rr must be Sn or Dn*.*
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-38: Scalar Variants of the Vector Floating-Point Comparisons'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description Scalar register comparison (including against
    0.0) |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Rd, Rl, Rr | Floating-point comparison for equality |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Rd, Rl, Rr | Floating-point comparison (Rd = Rl ≥ Rr) |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Rd, Rl, Rr | Floating-point comparison (Rd = Rl > Rr) |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
- en: '| fcmeq | fcmeq Rd, Rl, #0 | Floating-point comparison for register equal to
    0.0 |'
  id: totrans-1026
  prefs: []
  type: TYPE_TB
- en: '| fcmge | fcmge Rd, Rl, #0 | Floating-point comparison for register greater
    than or equal to 0.0 |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
- en: '| fcmgt | fcmgt Rd, Rl, #0 | Floating-point comparison for register greater
    than 0.0 |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
- en: '| fcmle | fcmle Rd, Rl, #0 | Floating-point comparison for register less than
    or equal to 0.0 |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
- en: '| fcmlt | fcmlt Rd, Rl, #0 | Floating-point comparison for register less than
    0.0 |'
  id: totrans-1030
  prefs: []
  type: TYPE_TB
- en: 'Neon has a couple of additional floating-point comparisons: fac* (vector floating-point
    absolute value compare). These instructions compare the absolute values of corresponding
    lanes in the source vector register and set the destination register accordingly.
    [Table 11-39](chapter11.xhtml#tab11-39) lists these instructions.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-39: Floating-Point Absolute-Value Comparisons'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
- en: '| facge | facge Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = abs(Vl)
    ≥ abs(Vr)) |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
- en: '| facgt | facgt Vd.t, Vl.t, Vr.t | Floating-point comparison (Vd = abs(Vl)
    > abs(Vr)) |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
- en: There is no faceq instruction, since there’s no need for one; just use fcmeq.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: The fac* instructions also have scalar versions, listed in [Table 11-40](chapter11.xhtml#tab11-40).
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-40: Scalar Floating-Point Absolute-Value Comparisons'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Syntax | Description |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
- en: '| facge | facge Rd, Rl, Rr | Floating-point comparison (Rd = abs(Rl) ≥ abs(Rr))
    |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
- en: '| facgt | facgt Rd, Rl, Rr | Floating-point comparison (Rd = abs(Rl) > abs(Rr))
    |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
- en: Note that Rd, Rl, and Rr must be Sn or Dn.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.3 Vector Bit Test Instructions
  id: totrans-1045
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Neon instruction set provides a vector version of the tst instruction, cmtst,
    which has the following syntax
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: where t can be 8B, 16B, 4H, 8H, 2S, 4S, or 2D. If t is 8B, 4H, or 2S, this instruction
    operates only on the LO 64 bits of the source registers and clears the HO 64 bits
    of the destination register.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: This instruction does a lane-by-lane logical AND operation between Vl and Vr.
    If the result is nonzero, it stores all 1 bits into the corresponding destination
    lane. Otherwise, it stores all 0s into the destination lane.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction also has a scalar version:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This form supports only 64-bit register operands (D*n*).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.4 Vector Comparison Results
  id: totrans-1053
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Throughout your programming experience, including with HLLs, you’ve probably
    become accustomed to using the result of comparisons (such as Boolean expressions)
    to divert control flow (such as with an if/then/else statement). Vector comparisons
    present a completely different paradigm because the lanes in a comparison could
    all produce different results. What’s the best way to deal with this?
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider the easy stuff: complex Boolean expressions involving ANDs,
    ORs, and other logical operators. Because the vector comparisons compute convenient
    results (all 1s or all 0s), it’s easy to compute something like this:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Consider the following code:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This leaves the result of the previous Boolean calculation (0x0000 or 0xFFFF)
    in the LO 64 bits of the V0 register (lanes 0 to 3; remember that the and instruction
    allows only 8B and 16B types, but they produce the same result as 4H would if
    it were a legal type).
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: You can use similar instruction sequences for OR, NOT, and any of the other
    logical vector operations (see [Table 11-2](chapter11.xhtml#tab11-2)). Such calculations
    will use complete Boolean evaluation.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Short-circuit evaluation doesn’t make sense for vector operations; see section
    7.6.3, “Complex* if *Statements Using Complete Boolean Evaluation,” on [page 378](chapter7.xhtml#pg_378)
    for more information on complete Boolean evaluation.*'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: If you absolutely, positively must branch to some locations based on the result
    of all the vector comparisons, keep in mind that the number of branch locations
    increases exponentially with the number of lanes (specifically, its 2*^n* different
    possibilities, where *n* is the number of lanes). For example, if you execute
    the following instruction
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: then the LO 64 bits of V0 will contain four Boolean values, yielding 16 combinations
    of the four comparisons. It’s ugly, but you could create a jump table (see section
    7.6.7.3, “Indirect Jump switch Implementation,” on [page 391](chapter7.xhtml#pg_391))
    with 16 entries and then transfer control by using code like the following
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: where mask is
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: and JmpTbl is a 16-entry .dword table with the offset to the labels to jump
    to, based on all the combinations of true and false for four lane comparisons.
    This code moves bit 0 of lane 0 into bit 0 of X0, bit 0 of lane 1 into bit 1 of
    X0, bit 0 of lane 2 into bit 2 of X0, and bit 0 of lane 3 into bit 3 of X0\. This
    forms a 4-bit index (16 possible values) into JmpTbl.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, you could create a jump table with 16 entries and write code
    to transfer control, but this would be so ugly it’s not an option worth seriously
    considering.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you don’t need to know the particular configuration of matches in
    a vector comparison, only whether any matches exist at all. For example, suppose
    you were looking for a 0 byte in a string of characters (such as when computing
    the length of a zero-terminating string). You could load 16 characters at a time
    from the string and search for a 0 byte by comparing all of them against 0:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This instruction sets the particular lane in V0 to 0xFF, corresponding to any
    lane in V1 that contains a 0 byte. You can use the following sequence to check
    whether there were any 0 bytes at all:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the SIMD paradigm, an ideal solution would be to do calculations in parallel
    and use masks to disable certain calculations. For example, suppose you have a
    vector of 32-bit integers to which you would like to add another vector’s lanes,
    with the caveat that you don’t want to add anything if a particular lane contains
    a value greater than 16 bits (0xFFFF). Consider the following code:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The and instruction sets dword lanes greater than 0xFFFF to 0 so that they will
    have no impact on the final lane sums.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.11 A Sorting Example Using SIMD Code'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: Sorting data is a common vector solution. Listing 11-1 demonstrates a simple
    sort of eight elements by using a vectorized bitonic sorting algorithm.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here’s the build command and the sample output for Listing 11-1:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As you can see, this code properly sorted the data.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 11.12 A Numeric-to-Hex-String Example Using SIMD Code
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Listing 11-2 is a Neon example of something you should be familiar with: [Chapter
    9](chapter9.xhtml)’s dtoStr function that converts a dword into a hexadecimal
    string. It’s a practical example of converting existing code to SIMD.'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here’s the build command and the sample output for Listing 11-2:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you were to time this code, you’d find that it runs significantly faster
    than the scalar code in [Chapter 9](chapter9.xhtml).
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 11.13 Use of SIMD Instructions in Real Programs
  id: totrans-1090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve read through this chapter but aren’t sure how to apply SIMD instructions
    in real programs, don’t feel like you’re missing something. *SIMD* might as well
    stand for “*S*IMD *I*nstruction sets are *M*assively *D*ifficult to use.” Although
    ARM’s Neon instruction set is a bit more general-purpose than, say, Intel’s SSE/AVX
    extensions, SIMD instructions were created to accelerate the execution of very
    specific algorithms. I like to paraphrase a line from this book’s technical reviewer,
    Tony Tribelli, with respect to SIMD instructions’ applicability: “I look at a
    particular SIMD instruction and ask myself, ‘What benchmark was this instruction
    created for?’ ” That is, it often seems like SIMD instructions were added to the
    instruction set to make one benchmark program run faster and make the ARM CPU
    look better, though the instruction probably isn’t useful outside the context
    of that benchmark.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'In many respects, this statement is dead on: many SIMD instructions were created
    to solve one particular problem, and their applicability beyond that solution
    is merely coincidental. If you can’t figure out how to use a given instruction,
    you probably haven’t yet discovered the problem it was originally created to address.'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: If nothing else, the vector registers’ lanes are a good place to store temporary
    values when you’re already using all the general-purpose registers. You can use
    the mov instruction to copy data between a general-purpose register and a lane
    in a vector register; this is much faster than spilling the register to memory.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to use the Neon instruction set for high-performance computing,
    see section 11.15, “For More Information,” on the next page, or search “SIMD parallel
    algorithms” or “SIMD vector algorithms” on the internet.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.14 Moving On'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: This lengthy chapter covered many instructions. It began with a brief history
    of SIMD instruction sets; covered the vector registers on the ARM; discussed SIMD
    data types, lanes, and scalar operations; and then presented the Neon instruction
    set. This chapter ended with a pair of short examples that demonstrated bitonic
    sorting and numeric-to-hexadecimal-string conversion using the vector registers.
    These constitute useful ways to use the SIMD instructions on the ARM. Although
    SIMD instructions aren’t often applicable in general programs, with a little thought
    you should be able to use them to speed up your code in certain situations.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: A couple of the remaining chapters will employ SIMD instructions to improve
    performance. [Chapter 12](chapter12.xhtml) uses Neon instructions to improve the
    performance of various bit operations, while [Chapter 14](chapter14.xhtml) uses
    Neon instructions to implement fast memory move operations. You can apply what
    you’ve learned in this chapter to algorithms you’ve learned in previous chapters
    that could benefit from using SIMD instructions, such as the numeric-to-hex-string
    code. I’ll leave it to you to implement these changes.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: 11.15 For More Information
  id: totrans-1098
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on fixed-point arithmetic and other Neon instructions and
    data types, consult the ARM Architecture Reference Manual at *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/ddi0487<wbr>/latest](https://developer.arm.com/documentation/ddi0487/latest)*.
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on ARM scalable vector extensions (SVEs), see the documentation at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/102476<wbr>/0001<wbr>/SVE<wbr>-architecture<wbr>-fundamentals](https://developer.arm.com/documentation/102476/0001/SVE-architecture-fundamentals)*.
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM offers a guide on implementing fixed-point arithmetic on 32-bit CPUs at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/dai0033<wbr>/a](https://developer.arm.com/documentation/dai0033/a)*.
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those interested in vector sorting with ARM SVE can reference “A Fast Vectorized
    Sorting Implementation Based on the ARM Scalable Vector Extension (SVE)” by Bérenger
    Bramas for one implementation: *[https://<wbr>arxiv<wbr>.org<wbr>/pdf<wbr>/2105<wbr>.07782<wbr>.pdf](https://arxiv.org/pdf/2105.07782.pdf)*.'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the Vector Sorting Algorithms page of the CMSIS DSP Software Library for
    more on vector sorting with ARM: *[https://<wbr>arm<wbr>-software<wbr>.github<wbr>.io<wbr>/CMSIS<wbr>_5<wbr>/DSP<wbr>/html<wbr>/group<wbr>_<wbr>_Sorting<wbr>.html](https://arm-software.github.io/CMSIS_5/DSP/html/group__Sorting.html)*.'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM documentation also provides more detail on vector sorting on Neon at
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/den0018<wbr>/a<wbr>/NEON<wbr>-Code<wbr>-Examples<wbr>-with<wbr>-Optimization<wbr>/Median<wbr>-filter<wbr>/Basic<wbr>-principles<wbr>-and<wbr>-bitonic<wbr>-sorting](https://developer.arm.com/documentation/den0018/a/NEON-Code-Examples-with-Optimization/Median-filter/Basic-principles-and-bitonic-sorting)*.
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast and Robust Vectorized In-Place Sorting of Primitive Types” by Mark Blacher,
    Joachim Giesen, and Lars Kühne at *[https://<wbr>drops<wbr>.dagstuhl<wbr>.de<wbr>/opus<wbr>/volltexte<wbr>/2021<wbr>/13775<wbr>/pdf<wbr>/LIPIcs<wbr>-SEA<wbr>-2021<wbr>-3<wbr>.pdf](https://drops.dagstuhl.de/opus/volltexte/2021/13775/pdf/LIPIcs-SEA-2021-3.pdf)*
    covers quick sorting with vector instructions (written for AVX2, but easily translatable
    to Neon) using the bitonic sorting algorithm.
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the master’s thesis “A Study of the Use of SIMD Instructions for Two Image
    Processing Algorithms” by Eric Welch at *[https://<wbr>scholarworks<wbr>.rit<wbr>.edu<wbr>/cgi<wbr>/viewcontent<wbr>.cgi<wbr>?article<wbr>=3686&context<wbr>=theses](https://scholarworks.rit.edu/cgi/viewcontent.cgi?article=3686&context=theses)*
    for a discussion of SIMD image processing algorithms.
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another master’s thesis on SIMD signal processing algorithms is “Performance
    Optimization of Signal Processing Algorithms for SIMD Architectures” by Sharan
    Yagneswar, which can be found at *[https://<wbr>www<wbr>.diva<wbr>-portal<wbr>.org<wbr>/smash<wbr>/get<wbr>/diva2:1138490<wbr>/FULLTEXT01<wbr>.pdf](https://www.diva-portal.org/smash/get/diva2:1138490/FULLTEXT01.pdf)*.
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
