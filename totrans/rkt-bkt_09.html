<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_83"/><strong><span class="big">7</span><br/>BOOTKIT INFECTION TECHNIQUES</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">Having explored the Windows boot process, let’s now discuss bootkit infection techniques that target modules involved in system startup. These techniques are split into two groups according to the boot components they target: MBR infection techniques and VBR/Initial Program Loader (IPL) infection techniques. We’ll look at the TDL4 bootkit to demonstrate MBR infection, and then at the Rovnix and Gapz bootkits to demonstrate two different VBR infection techniques.</p>
<h3 class="h3" id="ch07lev1sec1"><span epub:type="pagebreak" id="page_84"/><strong>MBR Infection Techniques</strong></h3>
<p class="noindent">Approaches based on MBR modifications are the most common infection techniques used by bootkits to attack the Windows boot process. Most MBR infection techniques directly modify either the MBR code or MBR data (such as the partition table) or, in some cases, both.</p>
<p class="indent">MBR code modification changes <em>only</em> the MBR boot code, leaving the partition table untouched. This is the most straightforward infection method. It involves overwriting the system MBR code with malicious code while saving the original content of the MBR in some way, such as by storing it in a hidden location on the hard drive.</p>
<p class="indent">Conversely, the MBR data modification method involves altering the MBR partition table, <em>without</em> changing the MBR boot code. This method is more advanced because the contents of the partition table differ from system to system, making it difficult for analysts to find a pattern that will definitively identify the infection.</p>
<p class="indent">Finally, hybrid methods that combine these two techniques are also possible and have been used in the wild.</p>
<p class="indent">Next, we’ll look in more detail at the two MBR infection techniques.</p>
<h4 class="h4" id="ch07lev2sec1"><strong><em>MBR Code Modification: The TDL4 Infection Technique</em></strong></h4>
<p class="noindent">To illustrate the MBR code-modification infection technique, we’ll take an in-depth look at the first real-world bootkit to target the Microsoft Windows 64-bit platform: TDL4. TDL4 reuses the notoriously advanced evasion and anti-forensic techniques of its rootkit predecessor, TDL3 (discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>), but has the added ability to bypass the Kernel-Mode Code Signing Policy (discussed in <a href="ch06.xhtml#ch06">Chapter 6</a>) and infect 64-bit Windows systems.</p>
<p class="indent">On 32-bit systems, the TDL3 rootkit was able to persist through a system reboot by modifying a boot-start kernel-mode driver. However, the mandatory signature checks introduced in 64-bit systems prevented the infected driver from being loaded, rendering TDL3 ineffective.</p>
<p class="indent">In an effort to bypass 64-bit Microsoft Windows, the developers of TDL3 moved the infection point to earlier in the boot process, implementing a bootkit as a means of persistence. Thus, the TDL3 rootkit evolved into the TDL4 bootkit.</p>
<h5 class="h5" id="ch07lev3sec1"><strong>Infecting the System</strong></h5>
<p class="noindent">TDL4 infects the system by overwriting the MBR of the bootable hard drive with a malicious MBR (which, as we discussed, is executed <em>before</em> the Windows kernel image), so it’s able to tamper with the kernel image and disable integrity checks. (Other MBR-based bootkits are described in detail in <a href="ch10.xhtml#ch10">Chapter 10</a>.)</p>
<p class="indent">Like TDL3, TDL4 creates a hidden storage area at the end of the hard drive, into which it writes the original MBR and some modules of its own, as listed in <a href="ch07.xhtml#ch07tab01">Table 7-1</a>. TDL4 stores the original MBR so that it can be loaded later, once infection has taken place, and the system will seemingly boot as <span epub:type="pagebreak" id="page_85"/>normal. The <em>mbr</em>, <em>ldr16</em>, <em>ldr32</em>, and <em>ldr64</em> modules are used by the bootkit at boot time to sidestep Windows integrity checks and to ultimately load the unsigned malicious drivers.</p>
<p class="tabcap" id="ch07tab01"><strong>Table 7-1:</strong> Modules Written to TDL4’s Hidden Storage upon Infecting the System</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:70%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Module name</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>mbr</em></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Original contents of the infected hard drive boot sector</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>ldr16</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">16-bit real-mode loader code</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>ldr32</em></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Fake <em>kdcom.dll</em> library for x86 systems</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>ldr64</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Fake <em>kdcom.dll</em> library for x64 systems</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>drv32</em></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">The main bootkit driver for x86 systems</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>drv64</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The main bootkit driver for x64 systems</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>cmd.dll</em></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Payload to inject into 32-bit processes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>cmd64.dll</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Payload to inject into 64-bit processes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>cfg.ini</em></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Configuration information</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><em>bckfg.tmp</em></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Encrypted list of command and control (C&amp;C) URLs</p></td>
</tr>
</tbody>
</table>
<p class="indent">TDL4 writes data onto the hard drive by sending I/O control code <span class="literal">IOCTL_SCSI_PASS_THROUGH_DIRECT</span> requests directly to the disk miniport driver—the lowest driver in the hard drive driver stack. This enables TDL4 to bypass the standard filter kernel drivers and any defensive measures they might include. TDL4 sends these control code requests using the <span class="literal">DeviceIoControl</span> API, passing as a first parameter the handle opened for the symbolic link <em>\??\PhysicalDriveXX</em>, where <em>XX</em> is the number of the hard drive being infected.</p>
<p class="indent">Opening this handle with write access requires administrative privileges, so TDL4 exploits the MS10-092 vulnerability in the Windows Task Scheduler service (first seen in Stuxnet) to elevate its privileges. In a nutshell, this vulnerability allows an attacker to perform an unauthorized elevation of privileges for a particular task. To gain administrative privileges, then, TDL4 registers a task for Windows Task Scheduler to execute with its current privileges. The malware modifies the scheduled task XML file to run as Local System account, which includes administrative privileges and ensures that the checksum of the modified XML file is the same as before. As a result, this tricks the Task Scheduler into running the task as Local System instead of the normal user, allowing TDL4 to successfully infect the system.</p>
<p class="indent">By writing data in this way, the malware is able to bypass defensive tools implemented at the filesystem level because the <em>I/O Request Packet (IRP)</em>, a data structure describing an I/O operation, goes directly to a disk-class driver handler.</p>
<p class="indent">Once all of its components are installed, TDL4 forces the system to reboot by executing the <span class="literal">NtRaiseHardError</span> native API (shown in <a href="ch07.xhtml#ch07list01">Listing 7-1</a>).</p>
<p class="programs">NTSYSAPI<br/>
NTSTATUS<br/>
NTAPI<br/>
<span epub:type="pagebreak" id="page_86"/>NtRaiseHardError(<br/>
      IN NTSTATUS ErrorStatus,<br/>
      IN ULONG NumberOfParameters,<br/>
      IN PUNICODE_STRING UnicodeStringParameterMask OPTIONAL,<br/>
      IN PVOID *Parameters,<br/>
    <span class="ent">➊</span> IN HARDERROR_RESPONSE_OPTION ResponseOption,<br/>
      OUT PHARDERROR_RESPONSE Response<br/>
);</p>
<p class="listing" id="ch07list01"><em>Listing 7-1: Prototype of the <span class="literal">NtRaiseHardError</span> routine</em></p>
<p class="indent">The code passes <span class="literal">OptionShutdownSystem</span> <span class="ent">➊</span> as its fifth parameter, which puts the system into a <em>Blue Screen of Death (BSoD)</em>. The BSoD automatically reboots the system and ensures that the rootkit modules are loaded at the next boot without alerting the user to the infection (the system appears to have simply crashed).</p>
<h5 class="h5" id="ch07lev3sec2"><strong>Bypassing Security in the Boot Process of a TDL4-Infected System</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07fig01">Figure 7-1</a> shows the boot process on a machine infected with TDL4. This diagram represents a high-level view of the steps the malware takes to evade code integrity checks and load its components onto the system.</p>
<div class="image"><a id="ch07fig01"/><img src="../images/07fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-1: TDL4 bootkit boot process workflow</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_87"/>After the BSoD and subsequent system restart, the BIOS reads the infected MBR into memory and executes it, loading the first part of the bootkit (<span class="ent">➊</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>). Next, the infected MBR locates the bootkit’s filesystem at the end of the bootable hard drive and loads and executes a module called <em>ldr16</em>. The <em>ldr16</em> module contains the code responsible for hooking the BIOS’s 13h interrupt handler (disk service), reloading the original MBR (<span class="ent">➋</span> and <span class="ent">➌</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>), and passing execution to it. This way, booting can continue as normal, but now with the hooked 13h interrupt handler. The original MBR is stored in the <em>mbr</em> module in the hidden filesystem (see <a href="ch07.xhtml#ch07tab01">Table 7-1</a>).</p>
<p class="indent">The BIOS interrupt 13h service provides an interface for performing disk I/O operations in the preboot environment. This is crucial, because at the very beginning of the boot process the storage device drivers have not yet been loaded in the OS, and the standard boot components (namely, <em>bootmgr</em>, <em>winload.exe</em>, and <em>winresume.exe</em>) rely on the 13h service to read system components from the hard drive.</p>
<p class="indent">Once control has been transferred to the original MBR, the boot process proceeds as usual, loading the VBR and <em>bootmgr</em> (<span class="ent">➍</span> and <span class="ent">➎</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>), but the bootkit residing in memory now controls all I/O operations to and from the hard drive.</p>
<p class="indent">The most interesting part of <em>ldr16</em> lies in the routine that implements the hook for the 13h disk services interrupt handler. The code that reads data from the hard drive during boot relies on the BIOS 13h interrupt handler, which is now being intercepted by the bootkit, meaning the bootkit can <em>counterfeit</em> any data read from the hard drive during the boot process. The bootkit takes advantage of this ability by replacing the <em>kdcom.dll</em> library with <em>ldr32</em> or <em>ldr64</em> <span class="ent">➑</span> (depending on the operating system) drawn from the hidden filesystem, substituting its content in the memory buffer during the read operation. As we’ll see soon, replacing <em>kdcom.dll</em> with a malicious <em>dynamic-link library (DLL)</em> allows the bootkit to load its own driver and disable the kernel-mode debugging facilities at the same time.</p>
<div class="sidebar">
<p class="sidebart"><strong>RACE TO THE BOTTOM</strong></p>
<p class="spara">In hijacking the BIOS’s disk interrupt handler, TDL4 mirrors the strategy of rootkits, which tend to migrate down the stack of service interfaces. As a general rule of thumb, the deeper infiltrator wins. For this reason, some defensive software occasionally ends up fighting other defensive software for control of the lower layers of the stack! This race to hook the lower layers of the Windows system, using techniques indistinguishable from rootkit techniques, has led to issues with system stability. A thorough analysis of these issues was published in two articles in <em>Uninformed</em>.<sup><a id="ch07sfn1a" href="ch07.xhtml#ch07sfn1">1</a></sup></p>
<p class="sfootnote"><a id="ch07sfn1" href="ch07.xhtml#ch07sfn1a">1</a>. skape, “What Were They Thinking? Annoyances Caused by Unsafe Assumptions,” <em>Uninformed</em> 1 (May 2005), <em><a href="http://www.uninformed.org/?v=1&amp;a=5&amp;t=pdf">http://www.uninformed.org/?v=1&amp;a=5&amp;t=pdf</a></em>; Skywing, “What Were They Thinking? Anti-Virus Software Gone Wrong,” <em>Uninformed</em> 4 (June 2006), <em><a href="http://www.uninformed.org/?v=4&amp;a=4&amp;t=pdf">http://www.uninformed.org/?v=4&amp;a=4&amp;t=pdf</a></em>.</p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_88"/>To conform to the requirements of the interface used to communicate between the Windows kernel and the serial debugger, the modules <em>ldr32</em> and <em>ldr64</em> (depending on the operating system) export the same symbols as the original <em>kdcom.dll</em> library (as shown in <a href="ch07.xhtml#ch07list02">Listing 7-2</a>).</p>
<p class="programs">Name                   Address           Ordinal<br/>
KdD0Transition         000007FF70451014  1<br/>
KdD3Transition         000007FF70451014  2<br/>
KdDebuggerInitialize0  000007FF70451020  3<br/>
KdDebuggerInitialize1  000007FF70451104  4<br/>
KdReceivePacket        000007FF70451228  5<br/>
KdReserved0            000007FF70451008  6<br/>
KdRestore              000007FF70451158  7<br/>
KdSave                 000007FF70451144  8<br/>
KdSendPacket           000007FF70451608  9</p>
<p class="listing" id="ch07list02"><em>Listing 7-2: Export address table of</em> ldr32/ldr64</p>
<p class="indent">Most of the functions exported from the malicious version of <em>kdcom.dll</em> do nothing but return <span class="literal">0</span>, except for the <span class="literal">KdDebuggerInitialize1</span> function, which is called by the Windows kernel image during the kernel initialization (at <span class="ent">➒</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>). This function contains code that loads the bootkit’s driver on the system. It calls to <span class="literal">PsSetCreateThreadNotifyRoutine</span> to register a callback <span class="literal">CreateThreadNotifyRoutine</span> whenever a thread is created or destroyed; when the callback is triggered, it creates a malicious <span class="literal">DRIVER_OBJECT</span> to hook onto system events and waits until the driver stack for the hard disk device has been built up in the course of the boot process.</p>
<p class="indent">Once the disk-class driver is loaded, the bootkit can access data stored on the hard drive, so it loads its kernel-mode driver from the <em>drv32</em> or <em>drv64</em> module it replaced the <em>kdcom.dll</em> library with, stored in the hidden filesystem, and calls the driver’s entry point.</p>
<h5 class="h5" id="ch07lev3sec3"><strong>Disabling the Code Integrity Checks</strong></h5>
<p class="noindent">In order to replace the original version of <em>kdcom.dll</em> with the malicious DLL on Windows Vista and later versions, the malware needs to disable the kernel-mode code integrity checks, as discussed previously (to avoid detection, it only temporarily disables the checks). If the checks are not disabled, <em>winload.exe</em> will report an error and refuse to continue the boot process.</p>
<p class="indent">The bootkit turns off code integrity checks by telling <em>winload.exe</em> to load the kernel in preinstallation mode (see “<a href="ch06.xhtml#ch06lev2sec5">The Legacy Code Integrity Weakness</a>” on <a href="ch06.xhtml#page_74">page 74</a>), which doesn’t have the checks enabled. The <em>winload.exe</em> module does this by replacing the <span class="literal">BcdLibraryBoolean_EmsEnabled</span> element (encoded as <span class="literal">16000020</span> in the Boot Configuration Data, or BCD) with <span class="literal">BcdOSLoaderBoolean_WinPEMode</span> (encoded as <span class="literal">26000022</span> in BCD; see <span class="ent">➏</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>) when <em>bootmgr</em> reads the BCD from the hard drive, using the same methods TDL4 used to spoof <em>kdcom.dll</em>. (<span class="literal">BcdLibraryBoolean_EmsEnabled</span> is an inheritable object that indicates whether global emergency management <span epub:type="pagebreak" id="page_89"/>services redirection should be enabled and is set to <span class="literal">TRUE</span> by default.) <a href="ch07.xhtml#ch07list03">Listing 7-3</a> shows the assembly code implemented in <em>ldr16</em> that spoofs the <span class="literal">BcdLibraryBoolean_EmsEnabled</span> option <span class="ent">➊</span> <span class="ent">➋</span> <span class="ent">➌</span>.</p>
<p class="programs">seg000:02E4   cmp     dword ptr es:[bx], '0061'     ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:02EC   jnz     short loc_30A                 ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:02EE   cmp     dword ptr es:[bx+4], '0200'   ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:02F7   jnz     short loc_30A                 ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:02F9 <span class="ent">➊</span> mov     dword ptr es:[bx], '0062'     ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:0301 <span class="ent">➋</span> mov     dword ptr es:[bx+4], '2200'   ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:030A   cmp     dword ptr es:[bx], 1666Ch     ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:0312   jnz     short loc_328                 ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:0314   cmp     dword ptr es:[bx+8], '0061'   ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:031D   jnz     short loc_328                 ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:031F <span class="ent">➌</span> mov     dword ptr es:[bx+8], '0062'   ; spoofing BcdLibraryBoolean_EmsEnabled<br/>
seg000:0328   cmp     dword ptr es:[bx], 'NIM/'     ; spoofing /MININT<br/>
seg000:0330   jnz     short loc_33A                 ; spoofing /MININT<br/>
seg000:0332 <span class="ent">➍</span> mov     dword ptr es:[bx], 'M/NI'     ; spoofing /MININT</p>
<p class="listing" id="ch07list03"><em>Listing 7-3: Part of the</em> ldr16 <em>code responsible for spoofing the <span class="literal">BcdLibraryBoolean_EmsEnabled</span> and <span class="literal">/MININT</span> options</em></p>
<p class="indent">Next, the bootkit turns on preinstallation mode long enough to load the malicious version of <em>kdcom.dll</em>. Once it is loaded, the malware disables preinstallation mode as if were never enabled in order to remove any traces from the system. Note that attackers can disable preinstallation mode only while it is on—by corrupting the <span class="literal">/MININT</span> string option in the <em>winload.exe</em> image while reading the image from the hard drive <span class="ent">➍</span> (see <span class="ent">➐</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>). During initialization, the kernel receives a list of parameters from <em>winload.exe</em> to enable specific options and specify characteristics of the boot environment, such as the number of processors in the system, whether to boot in preinstallation mode, and whether to display a progress indicator at boot time. Parameters described by string literals are stored in <em>winload.exe</em>.</p>
<p class="indent">The <em>winload.exe</em> image uses the <span class="literal">/MININT</span> option to notify the kernel that preinstallation mode is enabled, and as a result of the malware’s manipulations, the kernel receives an invalid <span class="literal">/MININT</span> option and continues initialization as if preinstallation mode weren’t enabled. This is the final step in the bootkit-infected boot process (see <span class="ent">➓</span> in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>). A malicious kernel-mode driver is successfully loaded into the operating system, bypassing code integrity checks.</p>
<h5 class="h5" id="ch07lev3sec4"><strong>Encrypting the Malicious MBR Code</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07list04">Listing 7-4</a> shows a part of the malicious MBR code in the TDL4 bootkit. Notice that the malicious code is encrypted (beginning at <span class="ent">➌</span>) in order to avoid detection by static analysis, which uses static signatures.</p>
<p class="programs">seg000:0000       xor     ax, ax<br/>
seg000:0002       mov     ss, ax<br/>
<span epub:type="pagebreak" id="page_90"/>seg000:0004       mov     sp, 7C00h<br/>
seg000:0007       mov     es, ax<br/>
seg000:0009       mov     ds, ax<br/>
seg000:000B       sti<br/>
seg000:000C       pusha<br/>
seg000:000D <span class="ent">➊</span>    mov     cx, 0CFh        ;size of decrypted data<br/>
seg000:0010       mov     bp, 7C19h       ;offset to encrypted data<br/>
seg000:0013<br/>
seg000:0013 decrypt_routine:<br/>
seg000:0013 <span class="ent">➋</span>    ror     byte ptr [bp+0], cl<br/>
seg000:0016       inc     bp<br/>
seg000:0017       loop    decrypt_routine<br/>
seg000:0017 ; -------------------------------------------------------------<br/>
seg000:0019 <span class="ent">➌</span> db 44h                     ;beginning of encrypted data<br/>
seg000:001A    db 85h<br/>
seg000:001C    db 0C7h<br/>
seg000:001D    db 1Ch<br/>
seg000:001E    db 0B8h<br/>
seg000:001F    db 26h<br/>
seg000:0020    db 04h<br/>
seg000:0021    --<span class="codeitalic1">snip</span>--</p>
<p class="listing" id="ch07list04"><em>Listing 7-4: TDL4 code for decrypting malicious MBR</em></p>
<p class="indent">The registers <span class="literal">cx</span> and <span class="literal">bp</span> <span class="ent">➊</span> are initialized with the size and offset of the encrypted code, respectively. The value of the <span class="literal">cx</span> register is used as a counter in the loop <span class="ent">➋</span> that runs the bitwise logical operation <span class="literal">ror</span> (rotate-right instruction) to decrypt the code (marked by <span class="ent">➌</span> and pointed by the <span class="literal">bp</span> register). Once decrypted, the code will hook the INT 13h handler to patch other OS modules in order to disable OS code integrity verification and load malicious drivers.</p>
<h4 class="h4" id="ch07lev2sec2"><strong><em>MBR Partition Table Modification</em></strong></h4>
<p class="noindent">One variant of TDL4, known as Olmasco, demonstrates another approach to MBR infection: modifying the partition table rather than the MBR code. Olmasco first creates an unallocated partition at the end of the bootable hard drive, then creates a hidden partition in the same place by modifying a free partition table entry, #2, in the MBR partition table (see <a href="ch07.xhtml#ch07fig02">Figure 7-2</a>).</p>
<p class="indent">This route of infection is possible because the MBR contains a partition table with entries beginning at offset 0x1BE consisting of four 16-byte entries, each describing a corresponding partition (the array of <span class="literal">MBR_PARTITION_TABLE_ENTRY</span> is shown back in <a href="ch05.xhtml#ch05list02">Listing 5-2</a>) on the hard drive. Thus, the hard drive can have no more than four primary partitions, with only one marked as active. The operating system boots from the active partition. Olmasco overwrites an empty entry in the partition table with the parameters for its own malicious partition, marks the partition active, and initializes the VBR of the newly created partition. (<a href="ch10.xhtml#ch10">Chapter 10</a> provides more detail on Olmasco’s mechanism of infection.)</p>
<div class="image"><span epub:type="pagebreak" id="page_91"/><a id="ch07fig02"/><img src="../images/07fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-2: MBR partition table modification by Olmasco</em></p>
<h3 class="h3" id="ch07lev1sec2"><strong>VBR/IPL Infection Techniques</strong></h3>
<p class="noindent">Sometimes security software checks only for unauthorized modifications on the MBR, leaving the VBR and IPL uninspected. VBR/IPL infectors, like the first VBR bootkits, take advantage of this to improve their chances of remaining undetected.</p>
<p class="indent">All known VBR infection techniques fall into one of two groups: IPL modifications (like the Rovnix bootkit) and BIOS parameter block (BPB) modifications (like the Gapz bootkit).</p>
<h4 class="h4" id="ch07lev2sec3"><strong><em>IPL Modifications: Rovnix</em></strong></h4>
<p class="noindent">Consider the IPL modification infection technique of the Rovnix bootkit. Instead of overwriting the MBR sector, Rovnix modifies the IPL on the bootable hard drive’s active partition and the NTFS bootstrap code. As shown in <a href="ch07.xhtml#ch07fig03">Figure 7-3</a>, Rovnix reads the 15 sectors following the VBR (which contain the IPL), compresses them, prepends the malicious bootstrap code, and writes the modified code back to those 15 sectors. Thus, on the next system startup, the malicious bootstrap code receives control.</p>
<p class="indent">When the malicious bootstrap code is executed, it hooks the INT 13h handler in order to patch <em>bootmgr</em>, <em>winload.exe</em>, and the kernel so that it can gain control once the bootloader components are loaded. Finally, Rovnix decompresses the original IPL code and returns control to it.</p>
<p class="indent">The Rovnix bootkit follows the operating system’s execution flow from boot through processor execution mode switching until the kernel is loaded. Further, by using the debugging registers <span class="literal">DR0</span> through <span class="literal">DR7</span> (an essential part of the x86 and x64 architectures), Rovnix retains control during kernel initialization and loads its own malicious driver, bypassing the kernel-mode code integrity check. These debugging registers allow the malware to set hooks on the system code without actually patching it, thus maintaining the integrity of the code being hooked.</p>
<div class="image"><span epub:type="pagebreak" id="page_92"/><a id="ch07fig03"/><img src="../images/07fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-3: IPL modifications by Rovnix</em></p>
<p class="indent">The Rovnix boot code works closely with the operating system’s boot loader components and relies heavily on their platform-debugging facilities and binary representation. (We’ll discuss Rovnix in more detail in <a href="ch11.xhtml#ch11">Chapter 11</a>.)</p>
<h4 class="h4" id="ch07lev2sec4"><strong><em>VBR Infection: Gapz</em></strong></h4>
<p class="noindent">The Gapz bootkit infects the VBR of the active partition rather than the IPL. Gapz is a remarkably stealthy bootkit because it infects only a few bytes of the original VBR, modifying the <span class="literal">HiddenSectors</span> field (see <a href="ch05.xhtml#ch05list03">Listing 5-3</a> on <a href="ch05.xhtml#page_63">page 63</a>) and leaving all other data and code in the VBR and IPL untouched.</p>
<p class="indent">In the case of Gapz, the most interesting block for analysis is the BPB (<span class="literal">BIOS_PARAMETER_BLOCK</span>), particularly its <span class="literal">HiddenSectors</span> field. The value in this field specifies the number of sectors stored on the NTFS volume that precedes the IPL, as shown in <a href="ch07.xhtml#ch07fig04">Figure 7-4</a>.</p>
<div class="image"><a id="ch07fig04"/><img src="../images/07fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-4: The location of IPL</em></p>
<p class="indent">Gapz overwrites the <span class="literal">HiddenSectors</span> field with the value for the offset in sectors of the malicious bootkit code stored on the hard drive, as shown in <a href="ch07.xhtml#ch07fig05">Figure 7-5</a>. When the VBR code runs again, it loads and executes the <span epub:type="pagebreak" id="page_93"/>bootkit code instead of the legitimate IPL. The Gapz bootkit image is written either before the first partition or after the last one on the hard drive. (We’ll discuss Gapz in more detail in <a href="ch12.xhtml#ch12">Chapter 12</a>.)</p>
<div class="image"><a id="ch07fig05"/><img src="../images/07fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-5: The Gapz VBR infection</em></p>
<h3 class="h3" id="ch07lev1sec3"><strong>Conclusion</strong></h3>
<p class="noindent">In this chapter, you learned about the MBR and VBR bootkit infection techniques. We followed the evolution of the advanced TDL3 rootkit into the modern TDL4 bootkit, and you saw how TDL4 takes control of the system boot, infecting the MBR by replacing it with malicious code. As you’ve seen, the integrity protections in Microsoft 64-bit operating systems (in particular, the Kernel-Mode Code Signing Policy) initiated a new race in bootkit development to target x64 platforms. TDL4 was the first example of a bootkit in the wild to successfully overcome this obstacle, using certain design features that have since been adopted by other bootkits. We also looked at VBR infection techniques, illustrated by the Rovnix and Gapz bootkits, which are the respective subjects of <a href="ch11.xhtml#ch11">Chapters 11</a> and <a href="ch12.xhtml#ch12">12</a>.<span epub:type="pagebreak" id="page_94"/></p>
</body></html>