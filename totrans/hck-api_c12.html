<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 12: Injection</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_249" title="249"/>12</span><br/>
<span class="ChapterTitle">Injection</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">This chapter guides you through the detection and exploitation of several prominent injection vulnerabilities. API requests that are vulnerable to injection allow you to send input that is then directly executed by the API’s supporting technologies (such as the web application, database, or operating system running on the server), bypassing input validation measures.</p>
<p>You’ll typically find injection attacks named after the technology they are targeting. Database injection techniques such as SQL injection take advantage of SQL databases, whereas NoSQL injection takes advantage of NoSQL databases. Cross-site scripting (XSS) attacks insert scripts into web pages that run on a user’s browser. Cross-API scripting (XAS) is similar to XSS but leverages third-party applications ingested by the API you’re attacking. Command injection is an attack against the web server operating system that allows you to send it operating system commands.</p>
<p><span epub:type="pagebreak" id="Page_250" title="250"/>The techniques demonstrated throughout this chapter can be applied to other injection attacks as well. As one of the most severe findings you might come across, API injection can lead to a total compromise of a target’s most sensitive data or even grant you access to the supporting infrastructure.</p>
<h2 id="h1-502444c12-0001">Discovering Injection Vulnerabilities</h2>
<p class="BodyFirst">Before you can inject a payload using an API, you must discover places where the API accepts user input. One way to discover these injection points is by fuzzing and then analyzing the responses you receive. You should attempt injection attacks against all potential inputs and especially within the following:</p>
<ul>
<li>API keys</li>
<li>Tokens</li>
<li>Headers</li>
<li>Query strings in the URL</li>
<li>Parameters in POST/PUT requests</li>
</ul>
<p>Your approach to fuzzing will depend on how much information you know about your target. If you’re not worried about making noise, you could send a variety of fuzzing inputs likely to cause an issue in many possible supporting technologies. Yet the more you know about the API, the better your attacks will be. If you know what database the application uses, what operating system is running on the web server, or the programming language in which the app was written, you’ll be able to submit targeted payloads aimed at detecting vulnerabilities in those particular technologies.</p>
<p>After sending your fuzzing requests, hunt for responses that contain a verbose error message or some other failure to properly handle the request. In particular, look for any indication that your payload bypassed security controls and was interpreted as a command, either at the operating system, programming, or database level. This response could be as obvious as a message such as “SQL Syntax Error” or something as subtle as taking a little more time to process a request. You could even get lucky and receive an entire verbose error dump that can provide you with plenty of details about the host.</p>
<p>When you do come across a vulnerability, make sure to test every similar endpoint for that vulnerability. Chances are, if you find a weakness in the <em>/file/upload</em> endpoint, all endpoints with an upload feature, such as <em>/image/upload</em> and <em>/account/upload</em>, have the same problem.</p>
<p>Lastly, it is important to note that several of these injection attacks have been around for decades. The only thing unique about API injection is that the API provides a newer delivery method for the attack. Since injection vulnerabilities are well known and often have a detrimental impact on application security, they are often well-protected against.</p>
<h2 id="h1-502444c12-0002"><span epub:type="pagebreak" id="Page_251" title="251"/>Cross-Site Scripting (XSS)</h2>
<p class="BodyFirst">XSS is a classic web application vulnerability that has been around for decades. If you’re already familiar with the attack, you might be wondering, is XSS a relevant threat to API security? Of course it is, especially if the data submitted over the API interacts with the web application in the browser.</p>
<p>In an XSS attack, the attacker inserts a malicious script into a website by submitting user input that gets interpreted as JavaScript or HTML by a user’s browser. Often, XSS attacks inject a pop-up message into a web page that instructs a user to click a link that redirects them to the attacker’s malicious content.</p>
<p>In a web application, executing an XSS attack normally consists of injecting XSS payloads into different input fields on the site. When it comes to testing APIs for XSS, your goal is to find an endpoint that allows you to submit requests that interact with the frontend web application. If the application doesn’t sanitize the request’s input, the XSS payload might execute the next time a user visits the application’s page.</p>
<p>That said, for this attack to succeed, the stars have to align. Because XSS has been around for quite some time, API defenders are quick to eliminate opportunities to easily take advantage of this weakness. In addition, XSS takes advantage of web browsers loading client-side scripts, so if an API does not interact with a web browser, the chances of exploiting this vulnerability are slim to none.</p>
<p>Here are a few examples of XSS payloads:</p>
<ol class="none">
<li><code>&lt;script&gt;alert("xss")&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;alert(1);&lt;/script&gt;</code></li>
<li><code>&lt;%00script&gt;alert(1)&lt;/%00script&gt;</code></li>
<li><code>SCRIPT&gt;alert("XSS");///SCRIPT&gt;</code></li>
</ol>
<p>Each of these scripts attempts to launch an alert in a browser. The variations between the payloads are attempts to bypass user input validation. Typically, a web application will try to prevent XSS attacks by filtering out different characters or preventing characters from being sent in the first place. Sometimes, doing something simple such as adding a null byte (<code>%00</code>) or capitalizing different letters will bypass web app protections. We will go into more depth about evading security controls in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</p>
<p>For API-specific XSS payloads, I highly recommend the following resources:</p>
<ol class="none">
<li><b>Payload Box XSS payload list</b>  This list contains over 2,700 XSS scripts that could trigger a successful XSS attack (<a class="LinkURL" href="https://github.com/payloadbox/xss-payload-list">https://github.com/payloadbox/xss-payload-list</a>).</li>
<li><b>Wfuzz wordlist</b>  A shorter wordlist included with one of our primary tools. Useful for a quick check for XSS (<a class="LinkURL" href="https://github.com/xmendez/wfuzz/tree/master/wordlist">https://github.com/xmendez/wfuzz/tree/master/wordlist</a>).</li>
<li><b>NetSec.expert XSS payloads</b>  Contains explanations of different XSS payloads and their use cases. Useful to better understand each payload and conduct more precise attacks (<a class="LinkURL" href="https://netsec.expert/posts/xss-in-2020">https://netsec.expert/posts/xss-in-2020</a>).</li>
</ol>
<p><span epub:type="pagebreak" id="Page_252" title="252"/>If the API implements some form of security, many of your XSS attempts should produce similar results, like 405 Bad Input or 400 Bad Request. However, watch closely for the outliers. If you find requests that result in some form of successful response, try refreshing the relevant web page in your browser to see whether the XSS attempt affected it.</p>
<p>When reviewing the web apps for potential API XSS injection points, look for requests that include client input and are used to display information within the web app. A request used for any of the following is a prime candidate:</p>
<ul>
<li>Updating user profile information</li>
<li>Updating social media “like” information</li>
<li>Updating ecommerce store products</li>
<li>Posting to forums or comment sections</li>
</ul>
<p>Search the web application for requests and then fuzz them with an XSS payload. Review the results for anomalous or successful status codes.</p>
<h2 id="h1-502444c12-0003">Cross-API Scripting (XAS)</h2>
<p class="BodyFirst">XAS is cross-site scripting performed across APIs. For example, imagine that the hAPI Hacking blog has a sidebar powered by a LinkedIn newsfeed. The blog has an API connection to LinkedIn such that when a new post is added to the LinkedIn newsfeed, it appears in the blog sidebar as well. If the data received from LinkedIn isn’t sanitized, there is a chance that an XAS payload added to a LinkedIn newsfeed could be injected into the blog. To test this, you could post a LinkedIn newsfeed update containing an XAS script and check whether it successfully executes on the blog.</p>
<p>XAS does have more complexities than XSS, because the web application must meet certain conditions in order for XAS to succeed. The web app must poorly sanitize the data submitted through its own API or a third-party one. The API input must also be injected into the web application in a way that would launch the script. Moreover, if you’re attempting to attack your target through a third-party API, you may be limited in the number of requests you can make through its platform.</p>
<p>Besides these general challenges, you’ll encounter the same challenge inherent to XSS attacks: input validation. The API provider might attempt to prevent certain characters from being submitted through the API. Since XAS is just another form of XSS, you can borrow from the XSS payloads described in the preceding section.</p>
<p>In addition to testing third-party APIs for XAS, you might look for the vulnerability in cases when a provider’s API adds content or makes changes to its web application. For example, let’s say the hAPI Hacking blog allows users to update their user profiles through either a browser or a POST request to the API endpoint <em>/api/profile/update</em>. The hAPI Hacking blog security team may have spent all their time protecting the blog from input provided using the web application, completely overlooking the API <span epub:type="pagebreak" id="Page_253" title="253"/>as a threat vector. In this situation, you might try sending a typical profile update request containing your payload in one field of POST request:</p>
<pre><code>POST /api/profile/update HTTP/1.1
Host: hapihackingblog.com
Authorization: hAPI.hacker.token
Content-Type: application/json

{
"fname": "hAPI",
"lname": "Hacker",
"city": <b>"&lt;script&gt;alert("xas")&lt;/script&gt;"</b>
}</code></pre>
<p>If the request succeeds, load the web page in a browser to see whether the script executes. If the API implements input validation, the server might issue an HTTP 400 Bad Request response, preventing you from sending scripts as payloads. In that case, try using Burp Suite or Wfuzz to send a large list of XAS/XSS scripts in an attempt to locate some that don’t result in a 400 response.</p>
<p>Another useful XAS tip is to try altering the <code>Content-Type</code> header to induce the API into accepting an HTML payload to spawn the script:</p>
<pre><code>Content-Type: text/html</code></pre>
<p>XAS requires a specific situation to be in place in order to be exploitable. That said, API defenders often do a better job at preventing attacks that have been around for over two decades, such as XSS and SQL injection, than newer and more complex attacks like XAS.</p>
<h2 id="h1-502444c12-0004">SQL Injection</h2>
<p class="BodyFirst">One of the most well-known web application vulnerabilities, SQL injection, allows a remote attacker to interact with the application’s backend SQL database. With this access, an attacker could obtain or delete sensitive data such as credit card numbers, usernames, passwords, and other gems. In addition, an attacker could leverage SQL database functionality to bypass authentication and even gain system access.</p>
<p>This vulnerability has been around for decades, and it seemed to be diminishing before APIs presented a new way to perform injection attacks. Still, API defenders have been keen to detect and prevent SQL injections over APIs. Therefore, these attacks are not likely to succeed. In fact, sending requests that include SQL payloads could arouse the attention of your target’s security team or cause your authorization token to be banned.</p>
<p>Luckily, you can often detect the presence of a SQL database in less obvious ways. When sending a request, try requesting the unexpected. For example, take a look at the Swagger documentation shown in <a href="#figure12-1" id="figureanchor12-1">Figure 12-1</a> for a Pixi endpoint.</p>
<span epub:type="pagebreak" id="Page_254" title="254"/><figure>
<img alt="screenshot of swagger documentation that contains the following values in the body: id, user, pass, name, is_admin , and account_balance" class="keyline" src="image_fi/502444c12/F12001.png"/>
<figcaption><p><a id="figure12-1">Figure 12-1</a>: Pixi API Swagger documentation</p></figcaption>
</figure>
<p>As you can see, Pixi is expecting the consumer to provide certain values in the body of a request. The <code>"id"</code> value should be a number, <code>"name"</code> expects a string, and <code>"is_admin"</code> expects a Boolean value such as true or false. Try providing a string where a number is expected, a number where a string is expected, and a number or string where a Boolean value is expected. If an API is expecting a small number, send a large number, and if it expects a small string, send a large one. By requesting the unexpected, you’re likely to discover a situation the developers didn’t predict, and the database might return an error in the response. These errors are often verbose, revealing sensitive information about the database.</p>
<p>When looking for requests to target for database injections, seek out those that allow client input and can be expected to interact with a database. In <a href="#figure12-1">Figure 12-1</a>, there is a good chance that the collected user information will be stored in a database and that the PUT request allows us to update it. Since there is a probable database interaction, the request is a good candidate to target in a database injection attack. In addition to making obvious requests like this, you should fuzz everything, everywhere, because you might find indications of a database injection weakness in less obvious requests.</p>
<p><span epub:type="pagebreak" id="Page_255" title="255"/>This section will cover two easy ways to test whether an application is vulnerable to SQL injection: manually submitting metacharacters as input to the API and using an automated solution called SQLmap.</p>
<h3 id="h2-502444c12-0001">Manually Submitting Metacharacters</h3>
<p class="BodyFirst"><em>Metacharacters</em> are characters that SQL treats as functions rather than as data. For example, <code>--</code> is a metacharacter that tells the SQL interpreter to ignore the following input because it is a comment. If an API endpoint does not filter SQL syntax from API requests, any SQL queries passed to the database from the API will execute.</p>
<p>Here are some SQL metacharacters that can cause some issues:</p>
<p><code>'</code></p>
<p><code>''</code></p>
<p><code>;%00</code></p>
<p><code>--</code></p>
<p><code>-- -</code></p>
<p><code>""</code></p>
<p><code>;</code></p>
<p><code>' OR '1</code></p>
<p><code>' OR 1 -- -</code></p>
<p><code>" OR "" = "</code></p>
<p><code>" OR 1 = 1 -- -</code></p>
<p><code>' OR '' = '</code></p>
<p><code>OR 1=1</code></p>
<p>All of these symbols and queries are meant to cause problems for SQL queries. A null byte like <code>;%00</code> could cause a verbose SQL-related error to be sent as a response. The <code>OR 1=1</code> is a conditional statement that literally means “or the following statement is true,” and it results in a true condition for the given SQL query. Single and double quotes are used in SQL to indicate the beginning and ending of a string, so quotes could cause an error or a unique state. Imagine that the backend is programmed to handle the API authentication process with a SQL query like the following, which is a SQL authentication query that checks for username and password:</p>
<pre><code>SELECT * FROM userdb WHERE username = 'hAPI_hacker' AND password = 'Password1!'</code></pre>
<p>The query retrieves the values <code>hAPI_hacker</code> and <code>Password1!</code> from the user input. If, instead of a password, we supplied the API with the value <code>' OR 1=1-- -</code>, the SQL query might instead look like this:</p>
<pre><code>SELECT * FROM userdb WHERE username = 'hAPI_hacker' OR 1=1-- -</code></pre>
<p>This would be interpreted as selecting the user with a true statement and skipping the password requirement, as it has been commented out. The query no longer checks for a password at all, and the user is granted access. The attack can be performed to both the username and password fields. In a SQL query, the dashes (<code>--</code>) represent the beginning of a single-line comment. This turns everything within the following query line into a comment that will not be processed. Single and double quotes can be used to escape the current query to cause an error or to append your own SQL query.</p>
<p>The preceding list has been around in many forms for years, and the API defenders are also aware of its existence. Therefore, make sure you attempt various forms of requesting the unexpected.</p>
<h3 id="h2-502444c12-0002"><span epub:type="pagebreak" id="Page_256" title="256"/>SQLmap</h3>
<p class="BodyFirst">One of my favorite ways to automatically test an API for SQL injection is to save a potentially vulnerable request in Burp Suite and then use SQLmap against it. You can discover potential SQL weaknesses by fuzzing all potential inputs in a request and then reviewing the responses for anomalies. In the case of a SQL vulnerability, this anomaly is normally a verbose SQL response like “The SQL database is unable to handle your request . . .”</p>
<p>Once you’ve saved the request, launch SQLmap, one of the standard Kali packages that can be run over the command line. Your SQLmap command might look like the following:</p>
<pre><code>$ <b>sqlmap -r /home/hapihacker/burprequest1 -p </b><var class="bold">password</var></code></pre>
<p>The <code>-r</code> option lets you specify the path to the saved request. The <code>-p</code> option lets you specify the exact parameters you’d like to test for SQL injection. If you do not specify a parameter to attack, SQLmap will attack every parameter, one after another. This is great for performing a thorough attack of a simple request, but a request with many parameters can be fairly time-consuming. SQLmap tests one parameter at a time and tells you when a parameter is unlikely to be vulnerable. To skip a parameter, use the <span class="KeyCaps">ctrl</span>-C keyboard shortcut to pull up SQLmap’s scan options and use the <code>n</code> command to move to the next parameter.</p>
<p>When SQLmap indicates that a certain parameter may be injectable, attempt to exploit it. There are two major next steps, and you can choose which to pursue first: dumping every database entry or attempting to gain access to the system. To dump all database entries, use the following:</p>
<pre><code>$ <b>sqlmap -r /home/hapihacker/burprequest1 -p vuln-param –dump-all</b></code></pre>
<p>If you’re not interested in dumping the entire database, you could use the <code>--dump</code> command to specify the exact table and columns you would like:</p>
<pre><code>$ <b>sqlmap -r /home/hapihacker/burprequest1 -p vuln-param –dump -T users -C password -D helpdesk</b></code></pre>
<p>This example attempts to dump the <code>password</code> column of the <code>users</code> table within the <code>helpdesk</code> database. When this command executes successfully, SQLmap will display database information on the command line and export the information to a CSV file.</p>
<p>Sometimes SQL injection vulnerabilities will allow you to upload a web shell to the server that can then be executed to obtain system access. You could use one of SQLmap’s commands to automatically attempt to upload a web shell and execute the shell to grant you with system access:</p>
<pre><code>$ <b>sqlmap -r /home/hapihacker/burprequest1 -p vuln-param –os-shell</b></code></pre>
<p>This command will attempt to leverage the SQL command access within the vulnerable parameter to upload and launch a shell. If successful, this will give you access to an interactive shell with the operating system.</p>
<p><span epub:type="pagebreak" id="Page_257" title="257"/>Alternatively, you could use the <code>os-pwn</code> option to attempt to gain a shell using Meterpreter or VNC:</p>
<pre><code>$ <b>sqlmap -r /home/hapihacker/burprequest1 -p vuln-param –os-pwn</b></code></pre>
<p>Successful API SQL injections may be few and far between, but if you do find a weakness, the impact can lead to a severe compromise of the database and affected servers. For additional information on SQLmap, check out its documentation at <a class="LinkURL" href="https://github.com/sqlmapproject/sqlmap#readme">https://github.com/sqlmapproject/sqlmap#readme</a>.</p>
<h2 id="h1-502444c12-0005">NoSQL Injection</h2>
<p class="BodyFirst">APIs commonly use NoSQL databases due to how well they scale with the architecture designs common among APIs, as discussed in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. It may even be more common for you to discover NoSQL databases than SQL databases. Also, NoSQL injection techniques aren’t as well known as their structured counterparts. Due to this one small fact, you might be more likely to find NoSQL injections.</p>
<p>As you hunt, remember that NoSQL databases do not share as many commonalities as the different SQL databases do. <em>NoSQL</em> is an umbrella term that means the database does not use SQL. Therefore, these databases have unique structures, modes of querying, vulnerabilities, and exploits. Practically speaking, you’ll conduct many similar attacks and target similar requests, but your actual payloads will vary.</p>
<p>The following are common NoSQL metacharacters you could send in an API call to manipulate the database:</p>
<ol class="none">
<li><code>$gt</code></li>
<li><code>{"$gt":""}</code></li>
<li><code>{"$gt":-1}</code></li>
<li><code>$ne</code></li>
<li><code>{"$ne":""}</code></li>
<li><code>{"$ne":-1}</code></li>
<li><code>$nin</code></li>
<li><code>{"$nin":1}</code></li>
<li><code>{"$nin":[1]}</code></li>
<li><code>|| '1'=='1</code></li>
<li><code>//</code></li>
<li><code>||'a'\\'a</code></li>
<li><code>'||'1'=='1';//</code></li>
<li><code>'/{}:</code></li>
<li><code>'"\;{}</code></li>
<li><code>'"\/$[].&gt;</code></li>
<li><code>{"$where":  "sleep(1000)"}</code></li>
</ol>
<p>A note on a few of these NoSQL metacharacters: as we touched on in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, <code>$gt</code> is a MongoDB NoSQL query operator that selects documents that are greater than the provided value. The <code>$ne</code> query operator selects documents where the value is not equal to the provided value. The <code>$nin</code> operator is the “not in” operator, used to select documents where the field value is not within the specified array. Many of the others in the list contain symbols that are meant to cause verbose errors or other interesting behavior, such as bypassing authentication or waiting 10 seconds.</p>
<p><span epub:type="pagebreak" id="Page_258" title="258"/>Anything out of the ordinary should encourage you to thoroughly test the database. When you send an API authentication request, one possible response for an incorrect password is something like the following, which comes from the Pixi API collection:</p>
<pre><code>HTTP/1.1 202 Accepted
X-Powered-By: Express
Content-Type: application/json; charset=utf-8

{"message":"sorry pal, invalid login"}</code></pre>
<p>Note that a failed response includes a status code of 202 Accepted and includes a failed login message. Fuzzing the <em>/api/login </em>endpoint with certain symbols results in verbose error messaging. For example, the payload <code>'"\;{}</code> sent as the password parameter might cause the following 400 Bad Request message.</p>
<pre><code>HTTP/1.1 400 Bad Request
X-Powered-By: Express
<var>--snip--</var>

SyntaxError: Unexpected token ; in JSON at position 54&lt;br&gt; &amp;nbsp; &amp;nbsp;at JSON.parse (&amp;lt;anonymous&amp;gt;)&lt;br&gt; [...]</code></pre>
<p>Unfortunately, the error messaging does not indicate anything about the database in use. However, this unique response does indicate that this request has an issue with handling certain types of user input, which could be an indication that it is potentially vulnerable to an injection attack. This is exactly the sort of response that should incite you to focus your testing. Since we have our list of NoSQL payloads, we can set the attack position to the password with our NoSQL strings:</p>
<pre><code>POST /login HTTP/1.1
Host: 192.168.195.132:8000
<var>--snip--</var>

user=hapi%40hacker.com&amp;pass=<b>§Password1%21§</b></code></pre>
<p>Since we already have this request saved in our Pixi collection, let’s attempt our injection attack with Postman. Sending various requests with the NoSQL fuzzing payloads results in 202 Accepted responses, as seen with other bad password attempts in <a href="#figure12-2" id="figureanchor12-2">Figure 12-2</a>.</p>
<p>As you can see, the payloads with nested NoSQL commands <code>{"$gt":""}</code> and <code>{"$ne":""}</code> result in successful injection and authentication bypass.</p>
<span epub:type="pagebreak" id="Page_259" title="259"/><figure>
<img alt="screenshot of postman that shows successful attempts when using nested nosql commands" class="keyline" src="image_fi/502444c12/F12002.png"/>
<figcaption><p><a id="figure12-2">Figure 12-2</a>: Successful NoSQL injection attack using Postman</p></figcaption>
</figure>
<h2 id="h1-502444c12-0006">Operating System Command Injection</h2>
<p class="BodyFirst">Operating system command injection is similar to the other injection attacks we’ve covered in this chapter, but instead of, say, database queries, you’ll inject a command separator and operating system commands. When you’re performing operating system injection, it helps a great deal to know which operating system is running on the target server. Make sure you get the most out of your Nmap scans during reconnaissance in an attempt to glean this information.</p>
<p>As with all other injection attacks, you’ll begin by finding a potential injection point. Operating system command injection typically requires being able to leverage system commands that the application has access to or escaping the application altogether. Some key places to target include URL query strings, request parameters, and headers, as well as any request that has thrown unique or verbose errors (especially those containing any operating system information) during fuzzing attempts.</p>
<p>Characters such as the following all act as <em>command separators</em>, which enable a program to pair multiple commands together on a single line. If a web application is vulnerable, it would allow an attacker to add command separators to an existing command and then follow it with additional operating system commands:</p>
<ol class="none">
<li><code>|</code></li>
<li><code>||</code></li>
<li><code>&amp;</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>'</code></li>
<li><code>"</code></li>
<li><code>;</code></li>
<li><code>'"</code></li>
</ol>
<p><span epub:type="pagebreak" id="Page_260" title="260"/>If you don’t know a target’s underlying operating system, put your API fuzzing skills to work by using two payload positions: one for the command separator followed by a second for the operating system command. <a href="#table12-1" id="tableanchor12-1">Table 12-1</a> is a small list of potential operating system commands to use.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-1">Table 12-1</a>: Common Operating System Commands to Use in Injection Attacks</p></figcaption>
<table border="1" id="table-502444c12-0001">
<thead>
<tr>
<td><b>Operating system</b></td>
<td><b>Command</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td><code class="bold">ipconfig</code></td>
<td>Shows the network configuration</td>
</tr>
<tr>
<td/>
<td><code class="bold">dir</code></td>
<td>Prints the contents of a directory</td>
</tr>
<tr>
<td/>
<td><code class="bold">ver</code></td>
<td>Prints the operating system and version</td>
</tr>
<tr>
<td/>
<td><code class="bold">echo</code><b> </b><code class="bold">%CD%</code></td>
<td>Prints the current working directory</td>
</tr>
<tr>
<td/>
<td><code class="bold">whoami</code></td>
<td>Prints the current user</td>
</tr>
<tr>
<td>*nix (Linux and Unix)</td>
<td><code class="bold">ifconfig</code></td>
<td>Shows the network configuration</td>
</tr>
<tr>
<td/>
<td><code class="bold">ls</code></td>
<td>Prints the contents of a directory</td>
</tr>
<tr>
<td/>
<td><code class="bold">uname</code><b> </b><code class="bold">-a</code></td>
<td>Prints the operating system and version</td>
</tr>
<tr>
<td/>
<td><code class="bold">pwd</code></td>
<td>Prints the current working directory</td>
</tr>
<tr>
<td/>
<td><code class="bold">whoami</code></td>
<td>Prints the current user</td>
</tr>
</tbody>
</table>
</figure>
<p>To perform this attack with Wfuzz, you can either manually provide a list of commands or supply them as a wordlist. In the following example, I have saved all my command separators in the file <em>commandsep.txt</em> and operating system commands as <em>os-cmds.txt</em>:</p>
<pre><code>$ <b>wfuzz -z file,wordlists/commandsep.txt -z file,wordlists/os-cmds.txt http://vulnerableAPI.com/api/users/query?=WFUZZWFUZ2Z</b></code></pre>
<p>To perform this same attack in Burp Suite, you could leverage an Intruder cluster bomb attack.</p>
<p>We set the request to be a login POST request and target the <code>user</code> parameter. Two payload positions have been set to each of our files. Review the results for anomalies, such as responses in the 200s and response lengths that stick out.</p>
<p>What you decide to do with your operating system command injection is up to you. You could retrieve SSH keys, the <em>/etc/shadow</em> password file on Linux, and so on. Alternatively, you could escalate or command-inject to a full-blown remote shell. Either way, that is where your API hacking transitions into regular old hacking, and there are plenty of other books on that topic. For additional information, check out the following resources:</p>
<ul>
<li><em>RTFM:</em> <em>Red Team Field Manual</em> (2013) by Ben Clark</li>
<li><em>Penetration Testing: A Hands-On Introduction to Hacking</em> (No Starch Press, 2014) by Georgia Weidman</li>
<li><em>Ethical Hacking: A Hands-On Introduction to Breaking In</em> (No Starch Press, 2021) by Daniel Graham</li>
<li><span epub:type="pagebreak" id="Page_261" title="261"/><em>Advanced Penetration Testing: Hacking the World’s Most Secure Networks</em> (Wiley, 2017) by Wil Allsop</li>
<li><em>Hands-On Hacking</em> (Wiley, 2020) by Jennifer Arcuri and Matthew Hickey</li>
<li><em>The Hacker Playbook 3: Practical Guide to Penetration Testing</em> (Secure Planet, 2018) by Peter Kim</li>
<li><em>The Shellcoder’s Handbook: Discovering and Exploiting Security Holes</em> (Wiley, 2007) by Chris Anley, Felix Lindner, John Heasman, and Gerardo Richarte</li>
</ul>
<h2 id="h1-502444c12-0007">Summary</h2>
<p class="BodyFirst">In this chapter, we used fuzzing to detect several types of API injection vulnerabilities. Then we reviewed the myriad ways these vulnerabilities can be exploited. In the next chapter, you’ll learn how to evade common API security controls.</p>
<h2 class="HeadProject" id="h1-502444c12-0008"><span>Lab #9: Faking Coupons Using NoSQL Injection</span></h2>
<p class="BodyFirst">It’s time to approach the crAPI with our new injection powers. But where to start? Well, one feature we haven’t tested yet that accepts client input is the coupon code feature. Now don’t roll your eyes—coupon scamming can be lucrative! Search for Robin Ramirez, Amiko Fountain, and Marilyn Johnson and you’ll learn how they made $25 million. The crAPI might just be the next victim of a massive coupon heist.</p>
<p>Using the web application as an authenticated user, let’s use the <b>Add Coupon</b> button found within the Shop tab. Enter some test data in the coupon code field and then intercept the corresponding request with Burp Suite (see <a href="#figure12-3" id="figureanchor12-3">Figure 12-3</a>).</p>
<figure>
<img alt="screenshot of crapi’s enter coupon code pop-up window, in which “test!” has been typed into the coupon code box and has given the error message “invalid coupon code”" class="keyline" src="image_fi/502444c12/F12003.png"/>
<figcaption><p><a id="figure12-3">Figure 12-3</a>: The crAPI coupon code validation feature</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_262" title="262"/>In the web application, using this coupon code validation feature with an incorrect coupon code results in an “invalid coupon code” response. The intercepted request should look like the following:</p>
<pre><code>POST /community/api/v2/coupon/validate-coupon HTTP/1.1
Host: 192.168.195.130:8888
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
<var>--snip--</var>
Content-Type: application/json
Authorization: Bearer Hapi.hacker.token
Connection: close

{"coupon_code":"TEST!"}</code></pre>
<p>Notice the <code>"coupon_code"</code> value in the POST request body. This seems like a good field to test if we’re hoping to forge coupons. Let’s send the request over to Intruder and add our payload positions around <code>TEST!</code> so we can fuzz this coupon value. Once we’ve set our payload positions, we can add our injection fuzzing payloads. Try including all the SQL and NoSQL payloads covered in this chapter. Next, begin the Intruder fuzzing attack.</p>
<p>The results of this initial scan all show the same status code (500) and response length (385), as you can see in <a href="#figure12-4" id="figureanchor12-4">Figure 12-4</a>.</p>
<figure>
<img alt="fuzzing results show various requests, all with a length of 385 and a status code of 500" class="keyline" src="image_fi/502444c12/F12004.png"/>
<figcaption><p><a id="figure12-4">Figure 12-4</a>: Intruder fuzzing results</p></figcaption>
</figure>
<p>Nothing appears anomalous here. Still, we should investigate what the requests and responses look like. See Listings 12-1 and 12-2.</p>
<pre><code>POST /community/api/v2/coupon/validate-coupon HTTP/1.1
<var>--snip--</var>

{"coupon_code":"%7b$where%22%3a%22sleep(1000)%22%7d"}</code></pre>
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: The coupon validation request</p>
<pre><code><span epub:type="pagebreak" id="Page_263" title="263"/>HTTP/1.1 500 Internal Server Error
<var>--snip--</var>

{}</code></pre>
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: The coupon validation response</p>
<p>While reviewing the results, you may notice something interesting. Select one of the results and look at the Request tab. Notice that the payload we sent has been encoded. This could be interfering with our injection attack because the encoded data might not be interpreted correctly by the application. In other situations, the payload might need to be encoded to help bypass security controls, but for now, let’s find the source of this problem. At the bottom of the Burp Suite Intruder Payloads tab is an option to URL-encode certain characters. Uncheck this box, as shown in <a href="#figure12-5" id="figureanchor12-5">Figure 12-5</a>, so that the characters will be sent, and then send another attack.</p>
<figure>
<img alt="screenshot of burp suite’s intruder payloads tab that shows the “url-encode these characters” option as unchecked" class="keyline" src="image_fi/502444c12/F12005.png"/>
<figcaption><p><a id="figure12-5">Figure 12-5</a>: Burp Suite Intruder’s payload-encoding options</p></figcaption>
</figure>
<p>The request should now look like <a href="#listing12-3" id="listinganchor12-3">Listing 12-3</a>, and the response should now look like <a href="#listing12-4" id="listinganchor12-4">Listing 12-4</a>:</p>
<pre><code>POST /community/api/v2/coupon/validate-coupon HTTP/1.1
<var>--snip--</var>

{"coupon_code":"{"$nin":[1]}"}"</code></pre>
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: The request with URL encoding disabled</p>
<pre><code>HTTP/1.1 422 Unprocessable Entity
<var>--snip--</var>

{"error":"invalid character '$' after object key:value pair"}</code></pre>
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: The corresponding response</p>
<p>This round of attacks did result in some slightly more interesting responses. Notice the 422 Unprocessable Entity status code, along with the verbose error message. This status code normally means that there is an issue in the syntax of the request.</p>
<p>Taking a closer look at our request, you might notice a possible issue: we placed our payload position within the original key/value quotes generated in the web application’s request. We should experiment with the payload position to include the quotes so as to not interfere with nested object <span epub:type="pagebreak" id="Page_264" title="264"/>injection attempts. Now the Intruder payload positions should look like the following:</p>
<pre><code>{"coupon_code":§"TEST!"§}</code></pre>
<p>Once again, initiate the updated Intruder attack. This time, we receive even more interesting results, including two 200 status codes (see <a href="#figure12-6" id="figureanchor12-6">Figure 12-6</a>).</p>
<figure>
<img alt="screenshot of burp suite’s intruder results that shows various requests of varying lengths; all but two requests are of status code 422, and the two are of status code 200." class="keyline" src="image_fi/502444c12/F12006.png"/>
<figcaption><p><a id="figure12-6">Figure 12-6</a>: Burp Suite Intruder results</p></figcaption>
</figure>
<p>As you can see, two injection payloads, <code>{"$gt":""}</code> and <code>{"$nin":[1]}</code>, resulted in successful responses. By investigating the response to the <code>$nin</code> (not in) NoSQL operator, we see that the API request has returned a valid coupon code. Congratulations on performing a successful API NoSQL injection attack!</p>
<p>Sometimes the injection vulnerability is present, but you need to troubleshoot your attack attempts to find the injection point. Therefore, make sure you analyze your requests and responses and follow the clues left within verbose error messages.</p>
</section>
</body>
</html>