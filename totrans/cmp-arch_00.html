<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a"><span epub:type="pagebreak" id="page_xxi"/><strong>INTRODUCTION</strong></h2>&#13;
<div class="image1"><img src="../images/f0xxi-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">This book explores the field of <em>computer architecture</em>, examining the underlying principles and design of computer hardware. The field spans a wide range of hardware components and technologies at many levels, from basic silicon and transistors, through logic gates, simple calculating machines, and assembly languages, up to complex processors and memory.</p>&#13;
<p class="indent">The book also traces the history of computing, from ancient Greek mechanisms to World War II code-breaking machines, retro 8-bit game consoles, highly optimized contemporary CPUs and deep-learning GPUs, embedded Internet of Things devices and cloud servers, and even future architectures, such as quantum computers. Computer architecture identifies the trends connecting these various machines and components. As you’ll see, some computing principles are much older than you think.</p>&#13;
<h3 class="h3" id="lev1"><span epub:type="pagebreak" id="page_xxii"/>Who Is This Book For?</h3>&#13;
<p class="noindent">Computer architecture is one of a few subjects that separate full-blown computer scientists from mere programmers. If you’re an undergraduate computer science student, it’s probably a requirement for your degree. If you’re a self-taught programmer or hacker, it may be a subject you wish to learn more about, both to make your programs run more harmoniously with your hardware and as a badge of professionalism that many employers look for. This book assumes you know some basic high school programming, math, and physics, but otherwise is self-contained. It can serve as a textbook for the hardware requirements of an undergraduate computer architecture degree or as a first resource for independent learners.</p>&#13;
<h3 class="h3" id="lev2">Why Computer Architecture?</h3>&#13;
<p class="noindent">When I was a young programmer in the 1980s, programming and using a computer was deeply intertwined with an understanding of the computer’s design. For example, the art of writing games on 8-bit micros in the 1980s was very much about becoming one with the particular CPU and chipset in your home microcomputer; we were fiercely loyal to our chosen architectures. Computers had very limited resources, so games were written to exploit specific features of the architecture and to squeeze out as much power as possible. Many game concepts from this time emerged as results of specific architectural structures and tricks.</p>&#13;
<p class="indent">Programming today is quite different. In most application-level programming, there are many levels of software hierarchy insulating the programmer from the hardware. You might program in a language whose types bear little relation to those of the processor and memory. Those types spare you from thinking in terms of memory addresses—or at least they sit on an operating system that replaces physical with virtual memory addresses and prohibits access to programs stored in hardware other than via some abstracted interface of system calls. As a result, when programmers from the 8-bit era see today’s reconstructed Android and JavaScript versions of their games, they can find them inauthentic. The games have lost the intimate connection to the hardware that inspired and constrained them.</p>&#13;
<p class="indent">Some people, <em>systems programmers</em>, design and maintain the stack of tools mediating between hardware and software, but everyone else sits on top of that stack. Nevertheless, those tools still connect you to the underlying hardware, albeit indirectly, and if you understand the hardware’s structure, you can often make more effective use of the tools at all levels. You can also take better measurements of how the tools are performing and use that information to make smarter choices in your programs. You might use a more efficient algorithm or change how some process is implemented.</p>&#13;
<p class="indent">Programmers who really care about high performance, such as writers of game engines and science and financial simulations, can benefit from cutting through some of the layers of the stack and talking directly to the “bare metal” hardware. This kind of programming, known as <em>assembly programming</em>, is rare today, since optimizing compilers can generally beat most <span epub:type="pagebreak" id="page_xxiii"/>handwritten assembly attempts; still, some programmers like to move closer to the metal. They might do this by switching from a memory-managed language to a pointer-based one, or from a language using symbolic types to languages using the machine’s own types. For many decades, the lower-level language of choice has been C, though new contenders, such as Rust, are always emerging.</p>&#13;
<p class="indent">Computer architecture is also directly relevant to computer security. Attacks often involve working at some lower level than the one assumed to be secure. While a computer may be proved safe at some level, such as the userland of an operating system, lower-level details like the precise timings of CPU components and the speed of access to different memory locations open new possibilities for exploitation. For example, the Spectre and Meltdown vulnerabilities exist at the CPU level but can be measured and exploited by userland code when the programmer understands what to look for.</p>&#13;
<p class="indent">Lastly, by studying the history of computer architecture and seeing how the field has evolved not just over decades but also over centuries, we can learn from past mistakes and discover new uses for old ideas. It’s quite common for concepts from historical architectures to come back into use after long periods. For example, to look at a number, Charles Babbage’s mechanical computers had to physically move it out of RAM and into the processor; this meant the number could exist only in one place at a time, rather than being copied. We now see exactly this structure in today’s research into quantum computing, where some of Babbage’s ideas to work around the problem may find new life. The history of architecture acts as a reservoir of ideas that we can draw upon as needed.</p>&#13;
<h3 class="h3" id="lev3">Changes in the Field</h3>&#13;
<p class="noindent">Until recently, computer architecture was a boring, mature subject. It was developed in the 1950s and 1960s, and its basic principles held for a long time. Books were updated periodically to feature the latest product examples, such as CPUs that were faster and used smaller transistors, but the architectural principles remained the same. Since 2010, however, this has all changed: the subject has entered a new “golden age,” in part due to the shifting requirements of other branches of computing. There’s been a recent trend away from traditional desktops, in two opposite directions.</p>&#13;
<p class="indent">First, computers are becoming <em>less</em> powerful, both in the sense of computational ability and energy usage. We now want to have larger numbers of smaller, cheaper, lower-energy computers supporting all aspects of our lives. These sorts of devices enable <em>smart cities</em>, <em>smart agriculture</em>, <em>smart transport</em>, and the <em>Internet of Things</em>. At the same time, these devices collect vast quantities of data—what we now call <em>big data</em>—and processing that data requires a second, new type of computer: extremely large supercomputers or compute clusters located in purpose-built sites the size of factories. Inside these buildings there are no people, only rows of blinking server lights.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxiv"/>You may have heard of <em>deep learning</em>, a rebranding of the 60-year-old <em>neural network</em> algorithm. It could be argued that deep learning isn’t a branch of machine learning or AI theory at all, but rather a branch of computer architecture. After all, it’s new architectures, based on massive hardware parallelization through clusters of GPUs and custom silicon, that have brought the old algorithm up to speed, enabling it to run at scales many orders of magnitude larger than before. Thanks to these advances in computer architecture, we can finally use neural networks to solve real-world problems such as recognizing objects in videos and conversing with humans in natural language chatbots.</p>&#13;
<p class="indent">Another architectural change has shaken a long-held belief. For many decades, programmers swore by <em>Moore’s law</em>, which said, depending on who you believe, that either the number of transistors or the speed of processors would double every 18 months. This made programmers complacent, thinking they would get ever-increasing speed on conventional architectures. Recently, however, considerations of energy usage have brought the speed form of Moore’s law to an end. We’re still able to build more and more transistors, but for the first time since the Victorian era, we now need to reconceptualize computing as inherently parallel in order to make use of them.</p>&#13;
<p class="indent">It remains an open question whether parallel architectures will be visible to programmers in the future and thus require inherently parallel thinking for everyday programming, or whether people will write new compilers that translate between conventional serial programs and novel parallel architectures. Either way, there will be exciting new careers figuring it out. We’re looking for new ideas that might come from very old sources, such as clockwork and water computers, or from very new ones, such as neural, optical, and quantum computing.</p>&#13;
<p class="indent">Finally, the recent widespread availability of online collaboration tools has enabled a new wave of open source architectural systems and tools. RISC-V, BOOM, and Chisel, as well as emulators of past, present, and future machines, have all made the study of computer architecture easier, quicker, and more accessible. You’ll be introduced to many of these tools in this book. For the first time in a long time, it’s very exciting to study and teach architecture!</p>&#13;
<h3 class="h3" id="lev4">How to Use This Book</h3>&#13;
<p class="noindent">Architecture is often a compulsory course or professional requirement, and many people who don’t enjoy the subject still have to learn it—I should know, I used to be one of them! For such students, I’ve added some spoonfuls of sugar to help the medicine go down: I’ll link the subject to other topics you might be more passionate about. If you hate hardware but like music, robotics, AI, history, or even advanced LEGO building, then this might be the book for you. You might even begin to love architecture through one of these connections; or, if you do just need to pass an exam, maybe this book will help you get through it less painfully than some of the others.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxv"/>Though the future of computer architecture is novel and exciting, it’s important to know the past, so this book takes a broadly historical approach. Computers have generally grown more complex over time; by tracing their history, we can progressively build up this complexity. For example, you’ll learn the basic structures of a CPU—as still in use today—by learning to program on a steampunk, Victorian Analytical Engine. I’ll show you how to convert its moving mechanical parts into logic gate-based equivalents and how to build up and program a version of the Manchester Baby, one of the first electronic computers. You’ll then extend electronic machines to 8-bit and 16-bit retro gaming computers, learning to program a Commodore 64 and an Amiga. Next, I’ll introduce modern desktop and smart computers, including x86 and RISC-V architectures, before moving on to cloud and supercomputers. Finally, we’ll look at ideas for future technologies.</p>&#13;
<p class="indent">We’ll study many example systems in this book, but they’re intended primarily to illustrate the general concepts rather than be a guide to the specifics of modern products. When you’ve finished reading the book, you should have enough understanding, for example, to be able to build an 8-bit micro on a breadboard, write retro 8-bit games in assembly, write basic embedded and parallel programs, understand the arc of history, and predict some of the future of architecture. You should also then be ready to read the canonical reference books for future study and work.</p>&#13;
<p class="indent">You’ll get the most out of this book if you try to geek out over each chapter—don’t just take them at face value. For example, large-scale CPUs can be designed in LogiSim, burned onto cheap field programmable gate arrays (FPGAs), and run for real. As another example, you can use all of the architectures and assemblers presented in this book to write your own video games. The LogiSim files and assembly code snippets discussed in the book are all available for download; see the book’s web page, <em><a href="https://nostarch.com/computerarchitecture">https://nostarch.com/computerarchitecture</a></em>, for a link. I also encourage you to learn more about the book’s topics by using the library, Wikipedia, and the wider web, and finding the further readings listed at the end of each chapter; then find the interesting resources that <em>they</em> reference, too. Likewise, try to use the tools presented in the book’s end-of-chapter exercises in new ways, and look out for other interesting project ideas online. For instance, many YouTubers have built simple 8-bit computers by ordering a 6502, RAM chips, and wires from eBay. Architecture is a particularly visual, bloggable, and YouTube-friendly subject, so if you create something interesting, be sure to share the results.</p>&#13;
<p class="indent">A good way to begin your study of architecture is to buy a set of small screwdrivers and void your products’ warranties by opening up your PC, laptop, and smartphone, as well as some less obvious devices such as your router, TV, and washing machine. In the following section, we’ll see some examples of what you might find inside these devices and how to navigate around them.</p>&#13;
<h3 class="h3" id="lev5"><span epub:type="pagebreak" id="page_xxvi"/>Inside Common Devices</h3>&#13;
<p class="noindent">Computer architecture ranges from the atomic scale of transistors to the planetary scale of internetworked grid computing. To get an early feel for the subject, we’ll begin here at the most human level: what we see when we take the cover off a domestic computer and look inside. Typically, the main components visible to the naked eye are silicon chips arranged on a printed circuit board. Later in the book, we’ll dig down through chips, logic gates, and transistors and build upward to clusters and grids.</p>&#13;
<h4 class="h4" id="lev6"><em>Desktop PC</em></h4>&#13;
<p class="noindent">For the last couple of decades, most desktop PCs have used components and casings of standardized sizes, so you can assemble a PC from components made by many competitors without worrying about whether they’ll fit together. IBM started this trend in the 1980s. Thanks to this standardization, if you remove the screws and cover and open up a desktop PC, you’ll usually see something like the structure shown in <a href="fm03.xhtml#fig1">Figure 1</a>.</p>&#13;
<div class="image"><img id="fig1" src="../images/fxxvi-01.jpg" alt="Image" width="488" height="392"/></div>&#13;
<p class="figcap"><em>Figure 1: The inside of a desktop PC</em></p>&#13;
<p class="indent">The key feature is a large printed circuit board called a <em>mainboard</em> (aka a <em>motherboard</em> or <em>systemboard</em>), with other smaller boards plugged into it at right angles. The mainboard, as shown in <a href="fm03.xhtml#fig2">Figure 2</a>, contains the essential parts of the computer, including the <em>central processing unit (CPU)</em>, sometimes just called the <em>processor</em>, and main memory; the other boards are optional extensions.</p>&#13;
<p class="indent">You can usually locate the CPU by eye: it’s the center of the system, looking like the capital city of a country on a map, with all the roads leading to it. It’s typically under a very large fan to disperse the heat created by all the CPU’s transistors. The memory is the next most important component. Main memory is usually clearly visible as some physically large but homogeneous region; this is because main memory is computationally large and homogeneous. In a desktop, main memory appears in several boards of several identical RAM chips, clearly lined up.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_xxvii"/><img id="fig2" src="../images/fxxvii-01.jpg" alt="Image" width="822" height="439"/></div>&#13;
<p class="figcap"><em>Figure 2: A mainboard from a desktop PC</em></p>&#13;
<p class="indent"><em>Printed circuit boards (PCBs)</em>, such as mainboards, are made using a similar process to silk-screening posters or T-shirts, as shown in <a href="fm03.xhtml#fig3">Figure 3</a>. In silk-screen printing, you choose a number of colors for your design and buy a can of paint in each. You then use a CAD program to make your design from block regions of these colors. You print out binary images for each color onto separate transparencies, to show where that color paint will go, and then you make a silk screen <em>mask</em> for each color. A mask begins as a piece of silk fabric, which you cover in a light-sensitive gel. You place the transparency that you printed out over it, then shine a bright light onto it.</p>&#13;
<div class="image"><img id="fig3" src="../images/fxxvii-02.jpg" alt="Image" width="592" height="395"/></div>&#13;
<p class="figcap"><em>Figure 3: To print this poster, a silk screen mask is placed on a piece of paper, and paint is pushed through it using a squeegee.</em></p>&#13;
<p class="noindent">The gel reacts where the printout is transparent and doesn’t react where the printout is black. You then put the mask in water, which washes away the reacted parts of gel and leaves in place the non-reacted parts. The remaining gel doesn’t allow paint to pass through it, but the exposed areas of the silk fabric do allow paint to pass through. You can now lay your mask on top of a blank piece of paper or T-shirt, pour paint all over it, and the paint will pass <span epub:type="pagebreak" id="page_xxviii"/>through only in the desired areas of your design. Once you allow this color layer to dry, you repeat the whole process for each remaining color to build up the design.</p>&#13;
<p class="indent">PCBs can be made similarly. You start with an acid-proof fiberglass insulator board, completely covered with a layer of copper. You design the circuit layout in a CAD program, print it onto a transparency, and shine a light through the transparency to selectively mask a light-sensitive chemical on the board. You then dip the board in acid to remove the unmasked parts of the copper layer. The remaining copper forms the wiring for the PCB. Next, you solder electronic components onto the appropriate locations on the board. The soldering used to be done by hand, but now it’s done by robots, which are much more accurate and can handle smaller components.</p>&#13;
<p class="indent">Beyond the mainboard, the rest of a PC case contains power transformers that convert domestic electricity into the various voltages used in the computer, as well as bulk storage devices such as hard disks and optical media disc drives—that is, CD, DVD, or Blu-ray.</p>&#13;
<p class="indent">In previous decades, PCs had lots of extension cards for interfacing with the monitor, sound equipment, and networks, but more recently these standard interfaces have moved to chips on the mainboard. The standard-sized PC case (called the ATX form factor) often contains mostly empty space in modern desktops as the parts have been miniaturized and integrated onto the mainboard. The noticeable exception to this trend is the graphics card (graphics processing unit, or GPU), which in high-end machines may have grown as large as or larger than the mainboard to enable fast 3D video games and scientific computing. Gamers like to show off these cards by illuminating them with LED lights and using transparent PC cases.</p>&#13;
<h4 class="h4" id="lev7"><em>Laptop</em></h4>&#13;
<p class="noindent">Laptop PCs have the same logical structure as desktops, but they use smaller, less power-consuming components, albeit with less computing power and higher manufacturing costs. <a href="fm03.xhtml#fig4">Figure 4</a> shows an example laptop mainboard.</p>&#13;
<p class="indent">The laptop mainboard isn’t perfectly rectangular; rather, it’s shaped to fit the available space. Since there’s no room for large connectors, many components are soldered directly together. Rather than having swappable extension cards sticking out at right angles to the mainboard, the form factors here are chosen to make everything fit neatly under the keyboard. There’s also less standardization of form factors and components than for desktops, with each manufacturer choosing their own. Together, these features tend to make laptops more expensive and harder to upgrade or interchange.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_xxix"/><img id="fig4" src="../images/fxxix-01.jpg" alt="Image" width="1061" height="581"/></div>&#13;
<p class="figcap"><em>Figure 4: A laptop mainboard</em></p>&#13;
<p class="indent">In recent years, the secure boot systems in laptops have opened up a security application of computer architecture. It used to be quite easy to take your employer’s laptop, which was encumbered by some proprietary operating system, remove the operating system, and replace it with an open source one such as Linux. The makers of the proprietary operating systems tried to remove your freedom to do this, in some cases claiming it was what your employer wanted, by paying hardware makers to implement secure boot systems. These systems lock the user out of access to the hard disk’s boot sector even before the operating system or a bootloader has a chance to load. You now need to circumvent the secure boot at the hardware level, such as by hot-wiring two pins on a dedicated chip together, thus factory-resetting the computer. The pins are quite small nowadays, so it sometimes requires a microscope and precision soldering to do the hot-wiring. (This is purely hypothetical, as it may be illegal to tamper with your employer’s device or with the hardware maker’s agreements with the operating system vendor.)</p>&#13;
<h4 class="h4" id="lev8"><em>Smartphone</em></h4>&#13;
<p class="noindent">In a computing context, the word <em>smart</em> nowadays means “is a computer.” Historically, consumer devices like phones and televisions were designed for single purposes, but a recent trend has been to include full computation power in them. For a while, this was a novelty, but now a large portion of the world’s population carry a full computer in their pocket. We therefore need to take smartphones and other smart devices seriously as computers, just as much as traditional desktops and laptops. <a href="fm03.xhtml#fig5">Figure 5</a> shows a mainboard for a smartphone.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_xxx"/><img src="../images/f0xxx-01.jpg" alt="Image" width="861" height="572"/></div>&#13;
<div class="image"><img id="fig5" src="../images/f0xxx-02.jpg" alt="Image" width="876" height="583"/></div>&#13;
<p class="figcap"><em>Figure 5: The inside of a Wileyfox Swift smartphone, showing the top and bottom sides of the mainboard</em></p>&#13;
<p class="indent">The design is based around an ARM Cortex CPU. Some of the other chips are specialized for phone-specific roles, including Wi-Fi and cell network (GSM) radio communications, battery management, and position and environment sensing (such as the inertial measurement unit and temperature and pressure sensors). The memory is different from desktops and laptops—here we see the use of low-power RAM (LPDDR). This reduces battery usage by clearing and turning off parts of the memory when they aren’t needed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxxi"/>Computers are now so miniaturized that their connectors may be the bottlenecks taking up the most space, rather than the actual computer. For example, replacing a phone’s 3.5 mm headphone jack connector with a smaller port is an ongoing debate. No longer having a standard headphone connector can be a nuisance, but having one is a limiting factor for the phone’s size.</p>&#13;
<h4 class="h4" id="lev9"><em>Washing Machine</em></h4>&#13;
<p class="noindent">If our phones and TVs are computers, might we even consider our washing machine to be a computer nowadays? <a href="fm03.xhtml#fig6">Figure 6</a> shows the mainboard of a typical modern washing machine.</p>&#13;
<p class="indent">There’s a small processor on the board, which probably contains <em>firmware</em>, a single program “burned” into the chip that performs only one task. This is an example of the embedded systems we’ll discuss in <a href="ch12.xhtml">Chapter 12</a>.</p>&#13;
<div class="image"><img id="fig6" src="../images/fxxxi-01.jpg" alt="Image" width="772" height="495"/></div>&#13;
<p class="figcap"><em>Figure 6: The mainboard of a washing machine</em></p>&#13;
<p class="indent">Consumer devices such as washing machines and refrigerators are currently of interest because, like phones, they might be next to become “smart”—that is, capable of running arbitrary programs. When “smart homes” are complete, users will expect to be able to dial into their washing machine to check its status and give it commands from far away. A smart washing machine might even come with an app store that enables you to download and run extra functions, such as machine learning tools. These could detect and appropriately wash different individual items of clothing, saving money and Earth’s energy and water resources.</p>&#13;
<p class="indent">That concludes our tour of a few devices. As we dive into computer architecture in the coming chapters, our understanding of how these devices work and are organized will grow. Before we get started, here’s a quick overview of the book and a few exercises for you to try.</p>&#13;
<h3 class="h3" id="lev10"><span epub:type="pagebreak" id="page_xxxii"/>Book Overview</h3>&#13;
<p class="noindent"><a href="part01.xhtml">Part I</a> introduces the fundamental concepts underlying all architectures.</p>&#13;
<p class="bqt"><strong><a href="ch01.xhtml">Chapter 1: Historical Architectures</a></strong> Describes the historical evolution of computing, not just to teach the history itself but because many concepts recur and increase in complexity over time; this will enable you to learn about complex modern systems by understanding their simpler ancestors first.</p>&#13;
<p class="bqt"><strong><a href="ch02.xhtml">Chapter 2: Data Representation</a></strong> Discusses how to represent data using binary coding schemes, which will later be implemented using digital logic.</p>&#13;
<p class="bqt"><strong><a href="ch03.xhtml">Chapter 3: Basic CPU-Based Architecture</a></strong> Explores what a CPU is, its basic subcomponents, and its machine code user interface.</p>&#13;
<p class="indent">Once you understand the concepts from <a href="part01.xhtml">Part I</a>, the core structures of computer architecture are fundamentally hierarchical; <a href="part02.xhtml">Part II</a> works its way up this hierarchy.</p>&#13;
<p class="bqt"><strong><a href="ch04.xhtml">Chapter 4: Switches</a></strong> Introduces switches, the basic building blocks of modern computers.</p>&#13;
<p class="bqt"><strong><a href="ch05.xhtml">Chapter 5: Digital Logic</a></strong> Constructs logic gates from these switches.</p>&#13;
<p class="bqt"><strong><a href="ch06.xhtml">Chapter 6: Simple Machines</a></strong> Combines these logic gates into simple machines.</p>&#13;
<p class="bqt"><strong><a href="ch07.xhtml">Chapter 7: Digital CPU Design</a></strong> Uses these simple machines to make components of a CPU and, finally, a complete but small-scale CPU.</p>&#13;
<p class="bqt"><strong><a href="ch08.xhtml">Chapter 8: Advanced CPU Design</a></strong> Introduces more advanced, modern CPU features such as pipelining and out-of-order execution.</p>&#13;
<p class="bqt"><strong><a href="ch09.xhtml">Chapter 9: Input/Output</a></strong> Adds input/output (I/O), making one more step from a CPU to a complete computer.</p>&#13;
<p class="bqt"><strong><a href="ch10.xhtml">Chapter 10: Memory</a></strong> Introduces memory, the last requirement for a full computer.</p>&#13;
<p class="indent"><a href="part03.xhtml">Part III</a> consists of progressively complex examples and applications, coinciding roughly with their historical order; these examples are intended to reinforce your knowledge of the structures studied in <a href="part02.xhtml">Part II</a>.</p>&#13;
<p class="bqt"><strong><a href="ch11.xhtml">Chapter 11: Retro Architectures</a></strong> Begins with relatively simple, complete retro computers from the 8-bit and 16-bit era, including showing you how to write retro video games in their assembly languages.</p>&#13;
<p class="bqt"><strong><a href="ch12.xhtml">Chapter 12: Embedded Architectures</a></strong> Shows how modern, low-power Internet of Things devices have similar structures, capabilities, and programming styles to retro devices.</p>&#13;
<p class="bqt"><strong><a href="ch13.xhtml">Chapter 13: Desktop Architectures</a></strong> Studies the complex instruction set and history of the x86 architecture, which is probably the basis for your main desktop computer. This will enable you to program your computer in assembly, on “bare metal” (that is, without an operating <span epub:type="pagebreak" id="page_xxxiii"/>system getting in the way). You’ll also explore the common PC I/O standards and peripherals that your desktop likely contains.</p>&#13;
<p class="bqt"><strong><a href="ch14.xhtml">Chapter 14: Smart Architectures</a></strong> Turns to the multitude of smaller smart devices replacing desktop computers. These are characterized by RISC architectures such as RISC-V, along with assembly programming and digital logic design tooling.</p>&#13;
<p class="bqt"><strong><a href="ch15.xhtml">Chapter 15: Parallel Architectures</a></strong> Discusses parallel architectures, which have become more common as CPUs have struggled to run faster.</p>&#13;
<p class="bqt"><strong><a href="ch16.xhtml">Chapter 16: Future Architectures</a></strong> Concludes by speculating about possible future architectures, including neural, DNA, and quantum computing.</p>&#13;
<div class="box">&#13;
<p class="stitle"><strong>ARCHITECTURE, ORGANIZATION, OR DESIGN?</strong></p>&#13;
<p class="stext"><em>Computer architecture</em> is traditionally distinguished from <em>computer organization</em>, with the former referring to the design of hardware-software interfaces visible to the programmer and the latter referring to the hardware implementations of these interfaces not visible to the programmer. In this context, the programmer was considered to be working at the level of assembly language, which performed the role of the programmer interface. In the modern world, however, it’s rare for programmers to see the assembly language level, as they almost always work in compiled languages. The compiler and now the operating system—and even higher-level structures like libraries and game engines—abstract the user many further levels above the old assembly interface. As such, the old architecture-versus-organization distinction has become less meaningful.</p>&#13;
<p class="stext">In this book, we’ll instead use <em>architecture</em> to refer to the study of all the above, and we’ll use the term <em>instruction set architecture (ISA)</em> to denote the more specific study of the hardware-programmer interface. Our definition of architecture also includes the study of the parts of computer hardware outside the CPU, such as memory and I/O systems, which is sometimes called <em>computer design</em>. Modern computers are increasingly interconnected as clusters and clouds, so it can now be hard or meaningless to distinguish a group of tightly connected computers from a single large computer. Our conception of architecture thus also extends to these kinds of systems.</p>&#13;
<p class="stext">The words <em>architecture</em> and <em>hierarchy</em> both contain the morpheme <em>arch</em>. The connection isn’t trivial: architecture is all about hierarchies. Hierarchies are the ways that complete structures are organized into components and subcomponents. No human could comprehend the structure of a billion transistors on a chip, but as in software design, we survive by mentally chunking them into many layers of abstraction. We chunk transistors into groups of about four or five, called logic gates; then we chunk logic gates into simple machines like adders; then we chunk those machine into components of CPUs and then the CPUs themselves. This way, each level can be designed from tens or hundreds of comprehensible components, with the designer having to think only at the single level at which they’re working. As mentioned earlier, the structure of <a href="part02.xhtml">Part II</a> of this book follows this hierarchy, beginning with transistors and building upward, introducing progressively larger and higher structures.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev11"><span epub:type="pagebreak" id="page_xxxiv"/>Exercises</h3>&#13;
<p class="noindent">Each chapter ends with some exercises to help you apply what you’ve learned to real-world systems. Some of the tasks, indicated by a “Challenging” heading, present an extra challenge and therefore are more difficult. Tasks under a “More Challenging” heading are extremely hard or time-consuming and are intended more as suggestions for large personal projects.</p>&#13;
<h4 class="h4a"><strong>Inside Your Own Devices</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">If you’re happy to void the warranty of your devices, buy a set of small screwdrivers and open up a desktop PC to see what’s inside. Take care to only open the box and not disturb any of the circuit boards themselves. Try to identify the main components, including the power supply, mainboard, CPU, RAM, GPU, and communications devices, as in the examples we discussed earlier. If you’re unsure about your screwdriver skills, you might wish to practice on an older, sacrificial device before or instead of your main one, or to search for internet videos of other people opening a similar device.</li>&#13;
<li class="tm">Most of the components you find inside will have a brand name and model number stamped on them. Search the internet for these to obtain the components’ formal product datasheets. Use the datasheets to identify some of the parts’ key properties, such as the number and speed of the CPU cores, the size of the RAM and its caches, the size of the GPU memory, what input and output devices are present, and what their capabilities and speeds are. (If your CPU is hard to access due to a heatsink, you can usually find its make and model on the mainboard datasheet.)</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Software Device Inspection</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">You can also dig for similar information without voiding your warranty on many machines by using software tools that inspect the hardware for you. For example, if you’re running Linux, try these commands:<br/><p class="indent"><span class="codestrong">lscpu</span></p>&#13;
<p class="indent"><span class="codestrong">cat /proc/cpuinfo</span></p>&#13;
<p class="indent"><span class="codestrong">lshw</span></p>&#13;
<p class="indent"><span class="codestrong">free</span></p>&#13;
<p class="indent"><span class="codestrong">hwinfo</span></p>&#13;
<p class="indent"><span class="codestrong">lspci</span></p>&#13;
<p class="indent"><span class="codestrong">lsusb</span></p>&#13;
<p class="indent"><span class="codestrong">nvidia-smi</span></p>&#13;
<p class="indent"><span class="codestrong">clinfo</span></p>&#13;
<p class="noindent">On Windows, run the Settings program from the Start menu and look around System Settings for similar information.</p></li>&#13;
<li class="tm">Do some internet research to interpret the results.</li>&#13;
<li class="tm"><span epub:type="pagebreak" id="page_xxxv"/>If you physically opened your device, check that the brands and model numbers inside match those reported by the software—it’s quite common and interesting for them to not match, so research why this happens if you see an example!</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Challenging</strong></h4>&#13;
<p class="noindent">If you’re used to opening up desktop computers and looking inside, buy some smaller screwdrivers and do the same for an old laptop.</p>&#13;
<h4 class="h4a"><strong>More Challenging</strong></h4>&#13;
<p class="noindent">If you’re used to opening up laptops, buy some even smaller screwdrivers and try to do the same for your phone or game console. Some phones can be opened using Torx screwdrivers, although others may require a phone repair kit that you can buy online for a few dollars. Some Japanese consoles use Japanese rather than Western-standard screws. You can order a repair kit for these as well, again for a few dollars. (Some devices are not intended to be accessible or repairable and so are glued together, making it hard to do this.)</p>&#13;
<h3 class="h3" id="lev12">Further Reading</h3>&#13;
<p class="noindent">This book is intended primarily for readers who want to learn about architecture in order to be <em>users</em> of it. It should also be useful, however, for those who want to <em>work</em> in architecture, for example, as chip designers. If you’re such a reader, you might want to take at least a quick glance at the larger, harder standard text for working architects, to get more of a flavor of what they do:</p>&#13;
<p class="block">John Hennessy and David Patterson, <em>Computer Architecture: A Quantitative Approach</em>, 6th ed. (Cambridge, MA: Morgan Kaufmann, 2017).</p>&#13;
<p class="noindent">This is the classic and authoritative reference book by the Turing Award–winning inventors of RISC and RISC-V. Just a glance at it is suggested for now. You will likely come back to it after finishing the present book as preparation.<span epub:type="pagebreak" id="page_xxxvi"/></p>&#13;
</div>
</div>
</body></html>