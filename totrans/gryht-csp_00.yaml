- en: '1'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: C# CRASH COURSE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#快速入门
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: Unlike other languages, such as Ruby, Python, and Perl, C# programs can be run
    by default on all modern Windows machines. In addition, running programs written
    in C# on a Linux system such as Ubuntu, Fedora, or another flavor couldn’t be
    easier, especially since Mono can quickly be installed by most Linux package managers
    like apt or yum. This puts C# in a better position to meet cross-platform needs
    than most languages, with the benefit of an easy and powerful standard library
    at your fingertips. All in all, C# and the Mono/.NET libraries make a compelling
    framework for anyone wanting to write cross-platform tools quickly and easily.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言（如Ruby、Python和Perl）不同，C#程序默认可以在所有现代Windows机器上运行。此外，在Linux系统（如Ubuntu、Fedora或其他发行版）上运行用C#编写的程序也非常简单，特别是因为Mono可以通过大多数Linux包管理器（如apt或yum）迅速安装。这使得C#在满足跨平台需求方面比大多数语言更具优势，而且标准库简单而强大，随时可用。总的来说，C#和Mono/.NET库为任何想快速轻松编写跨平台工具的人提供了一个有力的框架。
- en: Choosing an IDE
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 选择IDE
- en: Most who want to learn C# will use an integrated development environment (IDE)
    like Visual Studio for writing and compiling their code. Visual Studio by Microsoft
    is the de facto standard for C# development around the globe. Free versions such
    as Visual Studio Community Edition are available for personal use and can be downloaded
    from Microsoft’s website at [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数想学习C#的人会使用像Visual Studio这样的集成开发环境（IDE）来编写和编译他们的代码。由微软开发的Visual Studio是全球C#开发的事实标准。微软提供了如Visual
    Studio Community Edition这样的免费版本，供个人使用，可以从微软官网 [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
    下载。
- en: 'During the development of this book, I used MonoDevelop and Xamarin Studio
    depending on whether I was on Ubuntu or OS X, respectively. On Ubuntu, you can
    easily install MonoDevelop using the apt package manager. MonoDevelop is maintained
    by Xamarin, the company that also maintains Mono. To install it, use the following
    command: $ sudo apt-get install monodevelop Xamarin Studio is the OS X brand of
    the MonoDevelop IDE. Xamarin Studio and MonoDevelop have the same functionality,
    but with slightly different user interfaces. You can download the installer for
    the Xamarin Studio IDE from the Xamarin website at [https://www.xamarin.com/download-it/](https://www.xamarin.com/download-it/).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开发过程中，我根据自己是在Ubuntu还是OS X上，分别使用了MonoDevelop和Xamarin Studio。在Ubuntu上，你可以通过apt包管理器轻松安装MonoDevelop。MonoDevelop由Xamarin公司维护，Xamarin也是Mono的维护方。要安装它，可以使用以下命令：$
    sudo apt-get install monodevelop。Xamarin Studio是OS X版的MonoDevelop IDE。Xamarin
    Studio和MonoDevelop具有相同的功能，只是用户界面略有不同。你可以从Xamarin官网 [https://www.xamarin.com/download-it/](https://www.xamarin.com/download-it/)
    下载Xamarin Studio IDE的安装程序。
- en: Any of these three IDEs will fulfill our needs in this book. In fact, if you
    just want to use vim, you don’t even need an IDE! We’ll also soon cover how to
    compile a simple example using the command line C# compiler shipped with Mono
    instead of an IDE.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种IDE中的任何一个都能满足本书的需求。事实上，如果你只想使用vim，你甚至不需要IDE！我们还会很快介绍如何使用Mono自带的命令行C#编译器，而不是IDE，来编译一个简单的示例。
- en: A Simple Example
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例
- en: To anyone who’s used C or Java, the C# syntax will seem very familiar. C# is
    a strongly typed language, like C and Java, which means that a variable you declare
    in your code can be only one type (an integer, string, or Dog class, for example)
    and will always be that type, no matter what. Let’s start by taking a quick look
    at the Hello World example in [Listing 1-1](#filepos73487), which shows some basic
    C# types and syntax.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何使用过C或Java的人来说，C#的语法会显得非常熟悉。C#是一种强类型语言，像C和Java一样，这意味着你在代码中声明的变量只能是一个类型（例如整数、字符串或Dog类），并且无论如何，它始终是那个类型。让我们先快速看一下[列表1-1](#filepos73487)中的Hello
    World示例，它展示了一些基本的C#类型和语法。
- en: using ➊System;
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using ➊System;
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: namespace ➋ch1_hello_world
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: namespace ➋ch1_hello_world
- en: '{'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: class ➌MainClass
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: class ➌MainClass
- en: '{'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public static void ➍Main(string[] ➎args)
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void ➍Main(string[] ➎args)
- en: '{'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➏ string hello = "Hello World!";
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏ string hello = "Hello World!";
- en: ➐ DateTime now = DateTime.Now;
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➐ DateTime now = DateTime.Now;
- en: ➑ Console.Write(hello);
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➑ Console.Write(hello);
- en: ➒ Console.WriteLine(" The date is " + now.ToLongDateString());
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➒ Console.WriteLine(" The date is " + now.ToLongDateString());
- en: '}'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-1: A basic Hello World application'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-1：一个基本的Hello World应用程序
- en: 'Right off the bat, we need to import the namespaces we’ll use, and we do this
    with a using statement that imports the System namespace ➊. This enables access
    to libraries in a program, similar to #include in C, import in Java and Python,
    and require in Ruby and Perl. After declaring the library we want to use, we declare
    the namespace ➋ our classes will live in.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们需要导入将要使用的命名空间，我们通过使用using语句来实现这一点，导入System命名空间 ➊。这使得我们可以访问程序中的库，类似于C中的#include，Java和Python中的import，Ruby和Perl中的require。在声明了要使用的库之后，我们声明我们的类所在的命名空间
    ➋。
- en: Unlike C (and older versions of Perl), C# is an object-oriented language, similar
    to Ruby, Python, and Java. This means that we can build complex classes to represent
    data structures, along with the methods for those data structures, while writing
    code. Namespaces allow us to organize our classes and code as well as to prevent
    potential name collisions, such as when two programmers create two classes with
    the same name. If two classes with the same name are in different namespaces,
    there won’t be a problem. Every class is required to have a namespace.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与C（和旧版本的Perl）不同，C#是一种面向对象的语言，类似于Ruby、Python和Java。这意味着我们可以构建复杂的类来表示数据结构，并为这些数据结构编写相应的方法，同时编写代码。命名空间让我们可以组织类和代码，避免潜在的命名冲突，比如当两个程序员创建了同名的两个类时。如果两个同名类位于不同的命名空间中，就不会有问题。每个类都必须有一个命名空间。
- en: With the namespace out of the way, we can declare a class ➌ that will hold our
    Main() method ➍. As we stated previously, classes allow us to create complex data
    types as well as data structures that better fit real-world objects. In this example,
    the name of the class doesn’t actually matter; it’s just a container for our Main()
    method, which is what really matters because the Main() method is what will execute
    when we run our sample application. Every C# application requires a Main() method,
    just like in C and Java. If your C# application accepts arguments on the command
    line, you can use the args variable ➎ to access the arguments passed to the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完命名空间之后，我们可以声明一个类 ➌，该类将包含我们的Main()方法 ➍。正如我们之前所说，类允许我们创建复杂的数据类型以及更适合现实世界对象的数据结构。在这个例子中，类的名称实际上并不重要；它只是我们Main()方法的容器，Main()方法才是关键，因为它是当我们运行示例应用程序时会执行的部分。每个C#应用程序都需要一个Main()方法，就像C和Java一样。如果你的C#应用程序接受命令行参数，你可以使用args变量
    ➎ 来访问传递给应用程序的参数。
- en: Simple data structures, such as strings ➏, exist in C#, and more complex ones,
    such as a class representing the date and time ➐, can also be created. The DateTime
    class is a core C# class for dealing with dates. In our example, we use it to
    store the current date and time (DateTime.Now) in the variable now. Finally, with
    our variables declared, we can print a friendly message using the Console class’s
    Write() ➑ and WriteLine() ➒ methods (the latter of which includes a newline character
    at the end).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C#中存在简单的数据结构，如字符串 ➏，也可以创建更复杂的数据结构，如表示日期和时间的类 ➐。DateTime类是处理日期的核心C#类。在我们的示例中，我们使用它来存储当前日期和时间（DateTime.Now）到变量now中。最后，在声明了我们的变量之后，我们可以使用Console类的Write()
    ➑和WriteLine() ➒方法打印友好的信息（后者在末尾包含换行符）。
- en: 'If you’re using an IDE, you can compile and run the code by clicking the Run
    button, which is in the top-left corner of the IDE and looks like a Play button,
    or by pressing the F5 key. However, if you would like to compile the source code
    from the command line with the Mono compiler, you can easily do that as well.
    From the directory with your C# class code, use the mcs tool shipped with Mono
    to compile your classes into an executable, like so: $ mcs Main.cs -out:ch1_hello_world.exe
    Running the code from [Listing 1-1](#filepos73487) should print both the string
    "Hello World!" and the current date on the same line, as in [Listing 1-2](#filepos77351).
    On some Unix systems, you may need to run mono ch1_hello_world.exe.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是IDE，你可以通过点击运行按钮来编译并运行代码，该按钮位于IDE的左上角，看起来像一个播放按钮，或者按下F5键。不过，如果你希望通过命令行使用Mono编译器来编译源代码，你也可以轻松实现。在包含C#类代码的目录中，使用Mono附带的mcs工具将你的类编译成可执行文件，如下所示：$
    mcs Main.cs -out:ch1_hello_world.exe 从[清单1-1](#filepos73487)中运行代码应该会打印出"Hello
    World!"字符串和当前日期在同一行，如[清单1-2](#filepos77351)所示。在某些Unix系统中，你可能需要运行mono ch1_hello_world.exe。
- en: $ ./ch1_hello_world.exe
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch1_hello_world.exe
- en: Hello World! The date is Wednesday, June 28, 2017
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你好，世界！今天是2017年6月28日，星期三。
- en: 'Listing 1-2: Running the Hello World application'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-2：运行Hello World应用程序
- en: Congratulations on your first C# application!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了第一个C#应用程序！
- en: Introducing Classes and Interfaces
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍类和接口
- en: Classes and interfaces are used to create complex data structures that would
    be difficult to represent with just built-in structures. Classes and interfaces
    can have properties, which are variables that get or set values for a class or
    interface, and methods, which are like functions that execute on the class (or
    subclasses) or interface and are unique to it. Properties and methods are used
    to represent data about an object. For instance, a Firefighter class might need
    an int property to represent the firefighter’s pension or a method that tells
    the firefighter to drive to a place where there’s a fire.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类和接口用于创建复杂的数据结构，这些结构仅凭内建结构难以表示。类和接口可以具有属性，属性是用于获取或设置类或接口值的变量；也可以具有方法，方法类似于函数，在类（或子类）或接口上执行，并且是唯一的。属性和方法用于表示对象的数据。例如，Firefighter类可能需要一个int类型的属性来表示消防员的养老金，或者一个方法来指示消防员开车到发生火灾的地方。
- en: Classes can be used as blueprints to create other classes in a technique called
    subclassing. When a class subclasses another class, it inherits the properties
    and methods from that class (known as the parent class). Interfaces are used as
    a blueprint for new classes as well, but unlike classes, they don’t have inheritance.
    Thus a base class that implements an interface won’t pass down the interface’s
    properties and methods if it’s subclassed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以作为蓝图来创建其他类，这种技术叫做子类化。当一个类继承另一个类时，它会继承该类的属性和方法（称为父类）。接口也用作新类的蓝图，但与类不同，它们没有继承。因此，如果一个基类实现了一个接口，当它被子类化时，不会传递接口的属性和方法。
- en: Creating a Class
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类
- en: We’ll create the simple class shown in [Listing 1-3](#filepos79605) as an example
    that represents a public servant data structure for someone who works every day
    to make our lives easier and better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的类，如[列表1-3](#filepos79605)所示，作为一个例子，表示一个每天为让我们的生活变得更轻松、更美好而工作的公务员数据结构。
- en: public ➊abstract class PublicServant
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊abstract class PublicServant
- en: '{'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public int ➋PensionAmount { get; set; }
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ➋PensionAmount { get; set; }
- en: public abstract void ➌DriveToPlaceOfInterest();
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public abstract void ➌DriveToPlaceOfInterest();
- en: '}'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-3: The  PublicServant  abstract class'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 1-3: 公务员抽象类'
- en: The PublicServant class is a special kind of class. It is an abstract class
    ➊. Generally, you can just create a class like you do any other type of variable,
    and it is called an instance or an object. Abstract classes, though, cannot be
    instantiated like other classes; they can only be inherited through subclassing.
    There are many types of public servants—firefighters and police officers are two
    that come to mind immediately. It would therefore make sense to have a base class
    that these two types of public servants inherit from. In this case, if these two
    classes were subclasses of PublicServant, they would inherit a PensionAmount property
    ➋ and a DriveToPlaceOfInterest delegate ➌ that must be implemented by subclasses
    of PublicServant. There is no general “public servant” job that someone can apply
    for, so there isn’t a reason to create just a PublicServant instance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PublicServant 类是一种特殊类型的类。它是一个抽象类 ➊。通常，您可以像创建任何其他类型的变量一样创建一个类，它被称为实例或对象。然而，抽象类不能像其他类一样被实例化；它们只能通过子类化来继承。公共服务人员有很多类型——消防员和警察是我立刻想到的两个类型。因此，拥有一个基类供这两种公共服务人员继承是合理的。在这种情况下，如果这两个类是PublicServant的子类，它们将继承一个PensionAmount属性
    ➋和一个DriveToPlaceOfInterest委托 ➌，这些必须由PublicServant的子类实现。没有一个通用的“公务员”职位可以申请，因此没有理由仅创建一个PublicServant实例。
- en: Creating an Interface
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建接口
- en: A complement to classes in C# are interfaces. Interfaces allow a programmer
    to force a class to implement certain properties or methods that aren’t inherited.
    Let’s create a simple interface to start with, as shown in [Listing 1-4](#filepos81752).
    This interface is called IPerson and will declare a couple of properties that
    people usually have.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，接口是类的补充。接口允许程序员强制一个类实现某些不被继承的属性或方法。让我们从一个简单的接口开始，如[列表1-4](#filepos81752)所示。这个接口叫做IPerson，将声明一些人们通常拥有的属性。
- en: public interface ➊IPerson
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public interface ➊IPerson
- en: '{'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string ➋Name { get; set; }
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string ➋Name { get; set; }
- en: int ➌Age { get; set; }
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int ➌Age { get; set; }
- en: '}'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-4: The  IPerson  interface'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 1-4: IPerson 接口'
- en: NOTE
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Interfaces in C# are usually prefaced with an I to distinguish them from classes
    that may implement them. This I isn’t required, but it is a very common pattern
    used in mainstream C# development.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C# 中的接口通常以 I 为前缀，以区分可能实现它们的类。这个 I 并不是强制要求的，但它是主流 C# 开发中非常常见的模式。
- en: If a class were to implement the IPerson interface ➊, that class would need
    to implement both a Name ➋ and an Age ➌ property on its own. Otherwise, it wouldn’t
    compile. I’ll show exactly what this means when we implement the Firefighter class
    next, which implements the IPerson interface. For now, just know that interfaces
    are an important and useful feature of C#. Programmers familiar with interfaces
    in Java will feel right at home with them. C programmers can think of them as
    header files with function declarations that expect a .c file to implement the
    function. Those familiar with Perl, Ruby, or Python may find interfaces strange
    at first because there isn’t a comparable feature in those languages.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类要实现 IPerson 接口 ➊，该类需要自己实现 Name ➋ 和 Age ➌ 属性。否则，代码将无法编译。我将在接下来实现 Firefighter
    类时准确展示这意味着什么，Firefighter 类实现了 IPerson 接口。目前，您只需知道接口是 C# 中一个重要且有用的功能。熟悉 Java 的程序员会觉得它们非常自然。C
    程序员可以将其视为包含函数声明的头文件，期望 .c 文件来实现函数。熟悉 Perl、Ruby 或 Python 的人可能会觉得接口最初有些奇怪，因为这些语言没有类似的功能。
- en: Subclassing from an Abstract Class and Implementing an Interface
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象类继承并实现接口
- en: Let’s put our PublicServant class and IPerson interface to some use and solidify
    a bit of what we have talked about. We can create a class to represent our firefighters
    that inherits from the PublicServant class and implements the IPerson interface,
    as shown in [Listing 1-5](#filepos85009).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 PublicServant 类和 IPerson 接口应用于实际场景，巩固我们所讨论的一些内容。我们可以创建一个类来表示我们的消防员，该类继承自
    PublicServant 类并实现 IPerson 接口，如 [示例 1-5](#filepos85009) 所示。
- en: 'public class ➊Firefighter : ➋PublicServant, ➌IPerson'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ➊Firefighter : ➋PublicServant, ➌IPerson'
- en: '{'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➍Firefighter(string name, int age)
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➍Firefighter(string name, int age)
- en: '{'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = name;
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = name;
- en: this.Age = age;
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Age = age;
- en: '}'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: //implement the IPerson interface
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: // 实现 IPerson 接口
- en: public string ➎Name { get; set; }
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➎Name { get; set; }
- en: public int ➏Age { get; set; }
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ➏Age { get; set; }
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public override void ➐DriveToPlaceOfInterest()
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public override void ➐DriveToPlaceOfInterest()
- en: '{'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: GetInFiretruck();
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GetInFiretruck();
- en: TurnOnSiren();
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TurnOnSiren();
- en: FollowDirections();
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FollowDirections();
- en: '}'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void GetInFiretruck() {}
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void GetInFiretruck() {}
- en: private void TurnOnSiren() {}
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void TurnOnSiren() {}
- en: private void FollowDirections() {}
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void FollowDirections() {}
- en: '}'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-5: The  Firefighter  class'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-5：Firefighter 类
- en: The Firefighter class ➊ is a bit more complex than anything we’ve implemented
    yet. First, note that the Firefighter class inherits from the PublicServant class
    ➋ and implements the IPerson interface ➌. This is done by listing the class and
    interface, separated by commas, after the Firefighter class name and a colon.
    We then create a new constructor ➍ that is used to set the properties of a class
    when a new class instance is created. The new constructor will accept the name
    and age of the firefighter as arguments, which will set the Name ➎ and Age ➏ properties
    required by the IPerson interface with the values passed. We then override the
    DriveToPlaceOfInterest() method ➐ inherited from the PublicServant class with
    one of our own, calling a few empty methods that we declare. We’re required to
    implement the DriveToPlaceOfInterest() method because it’s marked as abstract
    in the PublicServant class and abstract methods have to be overridden by subclasses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Firefighter 类 ➊ 比我们之前实现的任何东西都要复杂一些。首先，注意 Firefighter 类继承自 PublicServant 类 ➋，并实现了
    IPerson 接口 ➌。通过在 Firefighter 类名和冒号后列出类和接口，并用逗号分隔，我们实现了这一点。然后，我们创建了一个新的构造函数 ➍，它用于在创建新类实例时设置类的属性。这个新的构造函数将接受消防员的姓名和年龄作为参数，这些值将设置
    IPerson 接口所需的 Name ➎ 和 Age ➏ 属性。接着，我们重写了从 PublicServant 类继承的 DriveToPlaceOfInterest()
    方法 ➐，并定义了我们自己的一些空方法。我们需要实现 DriveToPlaceOfInterest() 方法，因为它在 PublicServant 类中被标记为抽象方法，抽象方法必须由子类进行重写。
- en: NOTE
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Classes come with a default constructor that has no parameters to create instances.
    Creating a new constructor actually overrides the default constructor.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类具有默认构造函数，该构造函数没有参数用于创建实例。创建新的构造函数实际上是覆盖了默认构造函数。
- en: The PublicServant class and IPerson interface can be very flexible and can be
    used to create classes with completely different uses. We will implement one more
    class, a PoliceOfficer class, as shown in [Listing 1-6](#filepos88910), using
    PublicServant and IPerson.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'public class ➊PoliceOfficer : PublicServant, IPerson'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private bool _hasEmergency;
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public PoliceOfficer(string name, int age)
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = name;
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Age = age;
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _hasEmergency = ➋false;
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: //implement the IPerson interface
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int Age { get; set; }
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool ➌HasEmergency
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: get { return _hasEmergency; }
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: set { _hasEmergency = value; }
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public override void ➍DriveToPlaceOfInterest()
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GetInPoliceCar();
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (this.➎HasEmergency)
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TurnOnSiren();
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FollowDirections();
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void GetInPoliceCar() {}
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void TurnOnSiren() {}
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void FollowDirections() {}
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-6: The  PoliceOfficer  class'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The PoliceOfficer class ➊ is similar to the Firefighter class, but there are
    a few differences. Most notably, a new property called HasEmergency ➌ is set in
    the constructor ➋. We also override the DriveToPlaceOfInterest() method ➍ as in
    the previous Firefighter class, but this time, we use the HasEmergency property
    ➎ to determine whether the officer should drive the car with the siren on. We
    can use the same combination of parent class and interface to create classes that
    function completely differently.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Tying Everything Together with the Main() Method
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We can use our new classes to test a few more features of C#. Let’s write a
    new Main() method to show off these new classes, as shown in [Listing 1-7](#filepos92281).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: using System;
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: namespace ch1_the_basics
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public class MainClass
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Firefighter firefighter = new ➊Firefighter("Joe Carrington", 35);
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.➋PensionAmount = 5000;
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(firefighter);
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintPensionAmount(firefighter);
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.DriveToPlaceOfInterest();
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PoliceOfficer officer = new PoliceOfficer("Jane Hope", 32);
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.PensionAmount = 5500;
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.➌HasEmergency = true;
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍PrintNameAndAge(officer);
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintPensionAmount(officer);
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.➎DriveToPlaceOfInterest();
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static void PrintNameAndAge(➏IPerson person)
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Name: " + person.Name);'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Age: " + person.Age);'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static void PrintPensionAmount(➐PublicServant servant)
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (servant is ➑Firefighter)
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Pension of firefighter: " + servant.PensionAmount);'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else if (servant is ➒PoliceOfficer)
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Pension of officer: " + servant.PensionAmount);'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-7: Tying together the  PoliceOfficer  and  Firefighter  classes with
    a  Main()  method'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: To use the PoliceOfficer and Firefighter classes, we must instantiate them using
    the constructors we defined in the respective classes. We do this first with the
    Firefighter class ➊, passing a name of Joe Carrington and an age of 35 to the
    class constructor and assigning the new class to the firefighter variable. We
    also set the firefighter PensionAmount property ➋ to 5000. After the firefighter
    has been set up, we pass the object to the PrintNameAndAge() and PrintPension()
    methods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用警察类和消防员类，我们必须使用我们在各自类中定义的构造函数来实例化它们。我们首先用消防员类 ➊，将姓名乔·卡灵顿和年龄35传递给类的构造函数，并将新类分配给消防员变量。我们还将消防员的
    PensionAmount 属性 ➋ 设置为5000。设置好消防员之后，我们将对象传递给 PrintNameAndAge() 和 PrintPension()
    方法。
- en: Note that the PrintNameAndAge() method takes the IPerson interface ➏ as an argument,
    not a Firefighter, PoliceOfficer, or PublicServant class. When a class implements
    an interface, you can create methods that accept that interface (in our case,
    IPerson) as an argument. If you pass IPerson to a method, the method only has
    access to the properties or methods that the interface requires instead of to
    the whole class. In our example, only the Name and Age properties are available,
    which is all we need for the method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PrintNameAndAge() 方法接受 IPerson 接口 ➏ 作为参数，而不是 Firefighter、PoliceOfficer 或
    PublicServant 类。当一个类实现了某个接口时，你可以创建接受该接口（在我们的例子中是 IPerson）作为参数的方法。如果将 IPerson 传递给方法，那么该方法只能访问接口要求的属性或方法，而不是整个类。在我们的例子中，只有
    Name 和 Age 属性是可用的，这正是我们在该方法中所需要的。
- en: Similarly, the PrintPensionAmount() method accepts PublicServant ➐ as its argument,
    so it only has access to the PublicServant properties and methods. We can use
    the C# is keyword to check whether an object is a certain type of class, so we
    do this to check whether our public servant is a Firefighter ➑ or a PoliceOfficer
    ➒, and we print a message depending on which it is.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，PrintPensionAmount() 方法接受 PublicServant ➐ 作为参数，因此它只能访问 PublicServant 的属性和方法。我们可以使用
    C# 的 is 关键字来检查一个对象是否属于某种类型的类，因此我们用它来检查我们的公务员是消防员 ➑ 还是警察 ➒，并根据实际情况打印相应的消息。
- en: We do the same for the PoliceOfficer class as we did for Firefighter, creating
    a new class with a name of Jane Hope and an age of 32; then we set her pension
    to 5500 and her HasEmergency property ➌ to true. After printing the name, age,
    and pension ➍, we call the officer’s DriveToPlaceOfInterest() method ➎.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对警察类做了与对消防员类相同的处理，创建了一个名为简·霍普、年龄为32岁的新类；然后将她的养老金设置为5500，HasEmergency 属性 ➌
    设置为true。在打印姓名、年龄和养老金 ➍ 之后，我们调用该官员的 DriveToPlaceOfInterest() 方法 ➎。
- en: Running the Main() Method
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Main() 方法
- en: Running the application should demonstrate how classes and methods interact
    with each other, as shown in [Listing 1-8](#filepos96097).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该应用程序应展示类和方法如何相互作用，如[列表1-8](#filepos96097)所示。
- en: $ ./ch1_the_basics.exe
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch1_the_basics.exe
- en: 'Name: Joe Carrington'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 姓名：乔·卡灵顿
- en: 'Age: 35'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 年龄：35
- en: 'Pension of firefighter: 5000'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消防员养老金：5000
- en: 'Name: Jane Hope'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 姓名：简·霍普
- en: 'Age: 32'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 年龄：32
- en: 'Pension of officer: 5500'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 官员养老金：5500
- en: 'Listing 1-8: Running the basics program’s  Main()  method'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-8：运行基础程序的 Main() 方法
- en: As you can see, the public servants’ names, ages, and pensions are printed to
    the screen, exactly as expected!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，公务员的姓名、年龄和养老金已经打印到屏幕上，完全符合预期！
- en: Anonymous Methods
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法
- en: The methods we have used so far have been class methods, but we can also use
    anonymous methods. This powerful feature of C# allows us to dynamically pass and
    assign methods using delegates. With a delegate, a delegate object is created
    that holds a reference to the method that will be called. We create this delegate
    in a parent class and then assign the delegate’s reference to anonymous methods
    in subclasses of the parent class. This way, we can dynamically assign a block
    of code in a subclass to the delegate instead of overriding the parent class’s
    method. To demonstrate how to use delegates and anonymous methods, we can build
    on the classes we have already created.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的方法都是类方法，但我们也可以使用匿名方法。C#的这个强大功能允许我们通过委托动态地传递和分配方法。通过委托，会创建一个委托对象，它持有将被调用的方法的引用。我们在父类中创建这个委托，然后将委托的引用分配给父类子类中的匿名方法。这样，我们可以动态地将子类中的一段代码分配给委托，而不是覆盖父类的方法。为了演示如何使用委托和匿名方法，我们可以基于已经创建的类进行构建。
- en: Assigning a Delegate to a Method
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将委托分配给方法
- en: Let’s update the PublicServant class to use a delegate for the method DriveToPlaceOfInterest(),
    as shown in [Listing 1-9](#filepos98120).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 PublicServant 类，以便使用 delegate 来替代方法 DriveToPlaceOfInterest()，如[Listing
    1-9](#filepos98120)所示。
- en: public abstract class PublicServant
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public abstract class PublicServant
- en: '{'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public int PensionAmount { get; set; }
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int PensionAmount { get; set; }
- en: public delegate void ➊DriveToPlaceOfInterestDelegate();
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public delegate void ➊DriveToPlaceOfInterestDelegate();
- en: public DriveToPlaceOfInterestDelegate ➋DriveToPlaceOfInterest { get; set; }
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public DriveToPlaceOfInterestDelegate ➋DriveToPlaceOfInterest { get; set; }
- en: '}'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-9: The  PublicServant  class with a delegate'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-9: 带有 delegate 的 PublicServant 类'
- en: In the previous PublicServant class, we needed to override the DriveToPlaceOfInterest()
    method if we wanted to change it. In the new PublicServant class, DriveToPlaceOfInterest()
    is replaced with a delegate ➊ and a property ➋ that allow us to call and assign
    DriveToPlaceOfInterest(). Now, any classes inheriting from the PublicServant class
    will have a delegate they can use to set their own anonymous method for DriveToPlaceOfInterest()
    instead of having to override the method within each class. Because they inherit
    from PublicServant, we’ll need to update our Firefighter and PoliceOfficer class
    constructors accordingly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 PublicServant 类中，如果我们想要修改 DriveToPlaceOfInterest() 方法，需要覆盖它。而在新的 PublicServant
    类中，DriveToPlaceOfInterest() 被一个 delegate ➊和一个属性 ➋所替代，允许我们调用和分配 DriveToPlaceOfInterest()。现在，任何继承自
    PublicServant 类的类，都将拥有一个 delegate，可以用来设置自己的匿名方法来替代每个类中需要覆盖的该方法。因为它们继承自 PublicServant，所以我们需要相应地更新
    Firefighter 和 PoliceOfficer 类的构造函数。
- en: Updating the Firefighter Class
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Firefighter 类
- en: We’ll update the Firefighter class first with the new delegate property. The
    constructor, shown in [Listing 1-10](#filepos100265), is the only change we make.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先更新 Firefighter 类，增加新的 delegate 属性。构造函数，如[Listing 1-10](#filepos100265)所示，是我们所做的唯一修改。
- en: public ➊Firefighter(string name, int age)
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊Firefighter(string name, int age)
- en: '{'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.➋Name = name;
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➋Name = name;
- en: this.➌Age = age;
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➌Age = age;
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.DriveToPlaceOfInterest ➍+= delegate
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.DriveToPlaceOfInterest ➍+= delegate
- en: '{'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Driving the firetruck");
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("驾驶消防车");
- en: GetInFiretruck();
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GetInFiretruck();
- en: TurnOnSiren();
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TurnOnSiren();
- en: FollowDirections();
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FollowDirections();
- en: '};'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-10: The  Firefighter  class using the delegate for the  DriveToPlaceOfInterest()  method'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-10: 使用 delegate 来实现 DriveToPlaceOfInterest() 方法的 Firefighter 类'
- en: In the new Firefighter class constructor ➊, we assign the Name ➋ and Age ➌ like
    we did before. Next, we create the anonymous method and assign it to the DriveToPlaceOfInterest
    delegate property using the += operator ➍ so that calling DriveToPlaceOfInterest()
    will call the anonymous method. This anonymous method prints "Driving the firetruck"
    and then runs the empty methods from the original class. This way, we can add
    the customized code we want to each method within a class without having to override
    it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 Firefighter 类构造函数 ➊ 中，我们像之前一样分配 Name ➋ 和 Age ➌。接下来，我们创建匿名方法并将其分配给 DriveToPlaceOfInterest
    delegate 属性，使用 += 操作符 ➍，这样调用 DriveToPlaceOfInterest() 时会调用该匿名方法。这个匿名方法打印 "驾驶消防车"
    然后运行原类中的空方法。这样，我们可以在类中的每个方法中添加自定义代码，而不必覆盖它。
- en: Creating Optional Arguments
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可选参数
- en: The PoliceOfficer class requires a similar change; we update the constructor
    as shown in [Listing 1-11](#filepos103274). Because we’re already updating this
    class, we can also change it to use an optional argument, which is a parameter
    in a constructor that does not have to be included when a new instance is created.
    We’ll create two anonymous methods and use an optional argument to determine which
    method to assign to the delegate.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PoliceOfficer 类需要类似的修改；我们更新构造函数，如[Listing 1-11](#filepos103274)所示。因为我们已经在更新这个类，我们还可以将其修改为使用可选参数，即构造函数中的一个参数，在创建新实例时可以不包含它。我们将创建两个匿名方法，并使用可选参数来决定将哪个方法分配给
    delegate。
- en: public ➊PoliceOfficer(string name, int age, bool ➋hasEmergency = false)
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊PoliceOfficer(string name, int age, bool ➋hasEmergency = false)
- en: '{'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.➌Name = name;
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➌Name = name;
- en: this.➍Age = age;
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➍Age = age;
- en: this.➎HasEmergency = hasEmergency;
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➎HasEmergency = hasEmergency;
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (this.➏HasEmergency)
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (this.➏HasEmergency)
- en: '{'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.DriveToPlaceOfInterest += delegate
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.DriveToPlaceOfInterest += delegate
- en: '{'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Driving the police car with siren");
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("驾驶警车，开启警报");
- en: GetInPoliceCar();
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GetInPoliceCar();
- en: TurnOnSiren();
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TurnOnSiren();
- en: FollowDirections();
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FollowDirections();
- en: '};'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '};'
- en: '} else'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '} else'
- en: '{'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.DriveToPlaceOfInterest += delegate
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.DriveToPlaceOfInterest += delegate
- en: '{'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Driving the police car");
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("驾驶警车");
- en: GetInPoliceCar();
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GetInPoliceCar();
- en: FollowDirections();
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FollowDirections();
- en: '};'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-11: The new  PoliceOfficer  constructor'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-11：新的 PoliceOfficer 构造函数
- en: In the new PoliceOfficer constructor ➊, we set the Name ➌ and Age ➍ properties
    as we did originally. This time, however, we also use an optional third argument
    ➋ to assign the HasEmergency property ➎. The third argument is optional because
    it does not need to be specified; it has a default value (false) when the constructor
    is provided with only the first two arguments. We then set the DriveToPlaceOfInterest
    delegate property with a new anonymous method, depending on whether HasEmergency
    is true ➏.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 PoliceOfficer 构造函数 ➊ 中，我们像之前一样设置了姓名 ➌ 和年龄 ➍ 属性。然而，这次我们还使用了一个可选的第三个参数 ➋ 来分配
    HasEmergency 属性 ➎。第三个参数是可选的，因为它不需要被指定；当构造函数仅提供前两个参数时，它的默认值为 false。然后，我们根据 HasEmergency
    是否为 true ➏，用一个新的匿名方法设置 DriveToPlaceOfInterest 委托属性。
- en: Updating the Main() Method
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Main() 方法
- en: With the new constructors, we can run an updated Main() method that is almost
    identical to the first. It’s detailed in [Listing 1-12](#filepos105699).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的构造函数，我们可以运行几乎与第一次相同的更新版 Main() 方法。详细内容见 [列表 1-12](#filepos105699)。
- en: public static void Main(string[] args)
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Firefighter firefighter = new Firefighter("Joe Carrington", 35);
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Firefighter firefighter = new Firefighter("Joe Carrington", 35);
- en: firefighter.PensionAmount = 5000;
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: firefighter.PensionAmount = 5000;
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(firefighter);
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PrintNameAndAge(firefighter);
- en: PrintPensionAmount(firefighter);
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PrintPensionAmount(firefighter);
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.DriveToPlaceOfInterest();
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: firefighter.DriveToPlaceOfInterest();
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PoliceOfficer officer = new ➊PoliceOfficer("Jane Hope", 32);
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PoliceOfficer officer = new ➊PoliceOfficer("Jane Hope", 32);
- en: officer.PensionAmount = 5500;
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: officer.PensionAmount = 5500;
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(officer);
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PrintNameAndAge(officer);
- en: PrintPensionAmount(officer);
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PrintPensionAmount(officer);
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.DriveToPlaceOfInterest();
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: officer.DriveToPlaceOfInterest();
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer = new ➋PoliceOfficer("John Valor", 32, true);
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: officer = new ➋PoliceOfficer("John Valor", 32, true);
- en: PrintNameAndAge(officer);
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PrintNameAndAge(officer);
- en: officer.➌DriveToPlaceOfInterest();
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: officer.➌DriveToPlaceOfInterest();
- en: '}'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-12: The updated  Main()  method using our classes with delegates
    for driving to places of interest'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-12：使用我们带有委托的类来驾驶到兴趣地点的更新 Main() 方法
- en: The only differences are in the last three lines, which demonstrate creating
    a new PoliceOfficer ➋ who has an emergency (the third argument to the constructor
    is true), as opposed to Jane Hope ➊, who has none. We then call DriveToPlaceOfInterest()
    on the John Valor officer ➌.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同在于最后三行，展示了如何创建一个新的有紧急情况的 PoliceOfficer ➋（构造函数的第三个参数为 true），与没有紧急情况的 Jane
    Hope ➊ 进行对比。然后我们调用 John Valor 警员的 DriveToPlaceOfInterest() 方法 ➌。
- en: Running the Updated Main() Method
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更新后的 Main() 方法
- en: Running the new method shows how creating two PoliceOfficer classes—one with
    an emergency and one without—will print two different things, as demonstrated
    in [Listing 1-13](#filepos107506).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新方法显示如何创建两个 PoliceOfficer 类——一个有紧急情况，另一个没有——会打印出不同的内容，如 [列表 1-13](#filepos107506)
    所示。
- en: $ ./ch1_the_basics_advanced.exe
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch1_the_basics_advanced.exe
- en: 'Name: Joe Carrington'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 姓名：Joe Carrington
- en: 'Age: 35'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 年龄：35
- en: 'Pension of firefighter: 5000'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消防员养老金：5000
- en: Driving the firetruck
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 驾驶消防车
- en: 'Name: Jane Hope'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 姓名：Jane Hope
- en: 'Age: 32'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 年龄：32
- en: 'Pension of officer: 5500'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 警员养老金：5500
- en: ➊ Driving the police car
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊ 驾驶警车
- en: 'Name: John Valor'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 姓名：John Valor
- en: 'Age: 32'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 年龄：32
- en: '➋ Driving the police car with siren Listing 1-13: Running the new  Main()  method
    with classes using delegates'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋ 带警报器驾驶警车 列表 1-13：使用委托的类运行新的 Main() 方法
- en: As you can see, creating a PoliceOfficer class with an emergency causes the
    officer to drive with the siren on ➋. Jane Hope, on the other hand, can drive
    without her siren on ➊ because she has no emergency.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建一个带有紧急情况的 PoliceOfficer 类会导致警员打开警报器驾驶 ➋。而 Jane Hope 则可以不开警报器驾驶 ➊，因为她没有紧急情况。
- en: Integrating with Native Libraries
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与本地库集成
- en: Finally, sometimes you need to use libraries that are available only in standard
    operating system libraries, such as libc on Linux and user32.dll on Windows. If
    you plan to use code in a library that was written in C, C++, or another language
    that gets compiled down to native assembly, C# makes working with these native
    libraries very easy, and we will use this technique in [Chapter 4](index_split_009.html#filepos344540)
    when making cross-platform Metasploit payloads. This feature is called Platform
    Invoke, or P/Invoke for short. Programmers often need to use native libraries
    because they are faster than a virtual machine such as used by .NET or Java. Programmers
    such as financial or scientific professionals who use code to do heavy math might
    write the code that they need to be fast in C (for example, code for interfacing
    directly with hardware) but use C# to handle code that requires less speed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时你需要使用仅在标准操作系统库中可用的库，例如Linux上的libc和Windows上的user32.dll。如果你计划使用一个用C、C++或其他编译为本地汇编的语言编写的库中的代码，C#使得与这些本地库的工作变得非常容易，我们将在[第4章](index_split_009.html#filepos344540)中介绍如何在制作跨平台的Metasploit有效载荷时使用此技术。这个特性被称为平台调用，简称P/Invoke。程序员经常需要使用本地库，因为它们比.NET或Java使用的虚拟机要快。像金融或科学专业人士这样的程序员，通常需要编写快速的代码来进行重数学运算，他们可能会用C语言编写需要快速执行的代码（例如，直接与硬件接口的代码），但使用C#来处理那些对速度要求不高的代码。
- en: '[Listing 1-14](#filepos110442) shows a simple application that uses P/Invoke
    to call the standard C function printf() in Linux or to pop up a message box using
    user32.dll on Windows.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 1-14](#filepos110442) 显示了一个简单的应用程序，使用P/Invoke在Linux中调用标准C函数printf()，或者在Windows上使用user32.dll弹出消息框。'
- en: class MainClass
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: class MainClass
- en: '{'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '[➊DllImport("user32", CharSet=CharSet.Auto)]'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[➊DllImport("user32", CharSet=CharSet.Auto)]'
- en: static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport("libc")]'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport("libc")]'
- en: static extern void printf(string message);
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static extern void printf(string message);
- en: static void ➋Main(string[] args)
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void ➋Main(string[] args)
- en: '{'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: OperatingSystem os = Environment.OSVersion;
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OperatingSystem os = Environment.OSVersion;
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➌os.Platform == ➍PlatformID.Win32Windows||os.Platform == PlatformID.Win32NT)
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➌os.Platform == ➍PlatformID.Win32Windows||os.Platform == PlatformID.Win32NT)
- en: '{'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➎MessageBox(IntPtr.Zero, "Hello world!", "Hello world!", 0);
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎MessageBox(IntPtr.Zero, "Hello world!", "Hello world!", 0);
- en: '} else'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '} else'
- en: '{'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➏printf("Hello world!");
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏printf("Hello world!");
- en: '}'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 1-14: Demonstrating P/Invoke with a simple example'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-14：通过一个简单的示例演示P/Invoke
- en: This example looks more complex than it is. We first declare two functions that
    will be looked up externally in different libraries. We do this using the DllImport
    attribute ➊. Attributes allow you to add extra information to methods (or classes,
    class properties, and so on) that is used at runtime by the .NET or Mono virtual
    machine. In our case, the DllImport attribute tells the runtime to look up the
    method we are declaring in another DLL, instead of expecting us to write it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例看起来比实际复杂。我们首先声明了两个函数，它们将在不同的库中被外部查找。我们使用DllImport特性➊来完成这一操作。特性允许你向方法（或类、类属性等）添加额外的信息，这些信息将在运行时被.NET或Mono虚拟机使用。在我们的例子中，DllImport特性告诉运行时查找我们声明的方法，这些方法位于另一个DLL中，而不是期望我们自己编写。
- en: We also declare the exact function names and the parameters the functions expect.
    For Windows, we can use the MessageBox() function, which expects a few parameters
    such as the title of the pop-up and the text to be displayed. For Linux, the printf()
    function expects a string to print. Both of these functions are looked up at runtime,
    which means we can compile this on any system because the function in the external
    library isn’t looked for until the program is running and the function is called.
    This lets us compile the application on any operating system, regardless of whether
    that system has either or both libraries.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了精确的函数名称以及函数所期望的参数。对于Windows系统，我们可以使用MessageBox()函数，该函数需要一些参数，例如弹出框的标题和要显示的文本。对于Linux系统，printf()函数需要一个字符串来打印。这两个函数都会在运行时被查找，这意味着我们可以在任何系统上编译这个程序，因为外部库中的函数直到程序运行并被调用时才会被查找。这使我们能够在任何操作系统上编译应用程序，而不管该系统是否包含这两个库。
- en: 'With our native functions declared, we can write a quick Main() method ➋ that
    checks the current operating system with an if statement using os.Platform ➌.
    The Platform property we use maps to the PlatformID enumeration ➍, which stores
    the available operating systems that the program could be running on. Using the
    PlatformID enumeration, we can test whether we are on Windows and then call the
    respective method: either MessageBox() ➎ on Windows or printf() ➏ on Unix. This
    application, when compiled, can be run on either a Windows machine or a Linux
    machine, no matter what operating system compiled it.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了我们的本地函数后，我们可以编写一个简单的 Main() 方法 ➋，利用 if 语句和 os.Platform ➌ 来检查当前的操作系统。我们使用的
    Platform 属性对应于 PlatformID 枚举 ➍，该枚举存储了程序可能运行的操作系统。通过使用 PlatformID 枚举，我们可以测试是否在
    Windows 上运行，然后调用相应的方法：在 Windows 上调用 MessageBox() ➎，在 Unix 上调用 printf() ➏。编译后的这个应用程序可以在
    Windows 机器或 Linux 机器上运行，无论是什么操作系统编译的。
- en: Conclusion
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: The C# language has many modern features that make it a great language for complex
    data and applications. We have only scratched the surface of some of the more
    powerful features like anonymous methods and P/Invoke. You’ll become intimate
    with the concepts of classes and interfaces, as well as many other advanced features,
    in the chapters to come. In addition, you’ll learn about many more of the core
    classes available to you, such as HTTP and TCP clients and much more.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: C# 语言拥有许多现代特性，使其成为处理复杂数据和应用程序的优秀语言。我们只触及了其中一些更强大的特性，如匿名方法和 P/Invoke。在接下来的章节中，你将深入了解类和接口的概念，以及许多其他高级特性。此外，你还将学习更多核心类的使用，如
    HTTP 和 TCP 客户端等。
- en: As we develop our own custom security tools throughout this book, you will also
    learn about general programming patterns, which are useful conventions for creating
    classes that make building on them easy and fast. Good examples of programming
    patterns are used in [Chapters 5](index_split_010.html#filepos420379) and [11](index_split_016.html#filepos761301)
    where we interface with APIs and RPCs of third-party tools such as Nessus and
    Metasploit.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将开发自己的自定义安全工具，同时你还将学习到通用的编程模式，这些是创建类的有用规范，能够使基于它们的开发变得更快捷和简单。编程模式的良好示例可以在
    [第5章](index_split_010.html#filepos420379) 和 [第11章](index_split_016.html#filepos761301)
    中看到，在这些章节中，我们与第三方工具如 Nessus 和 Metasploit 的 API 和 RPC 进行了接口交互。
- en: By the end of this book, we will have covered how C# can be used for every security
    practitioner’s job—from the security analyst to the engineer, and even the hobbyist
    researcher at home. C# is a beautiful and powerful language, and with cross-platform
    support from Mono bringing C# to phones and embedded devices, it is just as capable
    and usable as Java and other alternatives.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，我们将涵盖如何使用 C# 来完成每位安全从业人员的工作——从安全分析师到工程师，甚至是家庭中的业余研究人员。C# 是一门美丽且强大的语言，借助
    Mono 的跨平台支持，将 C# 带到手机和嵌入式设备，它与 Java 及其他替代语言同样强大且易于使用。
