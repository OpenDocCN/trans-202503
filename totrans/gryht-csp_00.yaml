- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: C# CRASH COURSE
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike other languages, such as Ruby, Python, and Perl, C# programs can be run
    by default on all modern Windows machines. In addition, running programs written
    in C# on a Linux system such as Ubuntu, Fedora, or another flavor couldn’t be
    easier, especially since Mono can quickly be installed by most Linux package managers
    like apt or yum. This puts C# in a better position to meet cross-platform needs
    than most languages, with the benefit of an easy and powerful standard library
    at your fingertips. All in all, C# and the Mono/.NET libraries make a compelling
    framework for anyone wanting to write cross-platform tools quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an IDE
  prefs: []
  type: TYPE_NORMAL
- en: Most who want to learn C# will use an integrated development environment (IDE)
    like Visual Studio for writing and compiling their code. Visual Studio by Microsoft
    is the de facto standard for C# development around the globe. Free versions such
    as Visual Studio Community Edition are available for personal use and can be downloaded
    from Microsoft’s website at [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'During the development of this book, I used MonoDevelop and Xamarin Studio
    depending on whether I was on Ubuntu or OS X, respectively. On Ubuntu, you can
    easily install MonoDevelop using the apt package manager. MonoDevelop is maintained
    by Xamarin, the company that also maintains Mono. To install it, use the following
    command: $ sudo apt-get install monodevelop Xamarin Studio is the OS X brand of
    the MonoDevelop IDE. Xamarin Studio and MonoDevelop have the same functionality,
    but with slightly different user interfaces. You can download the installer for
    the Xamarin Studio IDE from the Xamarin website at [https://www.xamarin.com/download-it/](https://www.xamarin.com/download-it/).'
  prefs: []
  type: TYPE_NORMAL
- en: Any of these three IDEs will fulfill our needs in this book. In fact, if you
    just want to use vim, you don’t even need an IDE! We’ll also soon cover how to
    compile a simple example using the command line C# compiler shipped with Mono
    instead of an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Example
  prefs: []
  type: TYPE_NORMAL
- en: To anyone who’s used C or Java, the C# syntax will seem very familiar. C# is
    a strongly typed language, like C and Java, which means that a variable you declare
    in your code can be only one type (an integer, string, or Dog class, for example)
    and will always be that type, no matter what. Let’s start by taking a quick look
    at the Hello World example in [Listing 1-1](#filepos73487), which shows some basic
    C# types and syntax.
  prefs: []
  type: TYPE_NORMAL
- en: using ➊System;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: namespace ➋ch1_hello_world
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: class ➌MainClass
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public static void ➍Main(string[] ➎args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏ string hello = "Hello World!";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➐ DateTime now = DateTime.Now;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➑ Console.Write(hello);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➒ Console.WriteLine(" The date is " + now.ToLongDateString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-1: A basic Hello World application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right off the bat, we need to import the namespaces we’ll use, and we do this
    with a using statement that imports the System namespace ➊. This enables access
    to libraries in a program, similar to #include in C, import in Java and Python,
    and require in Ruby and Perl. After declaring the library we want to use, we declare
    the namespace ➋ our classes will live in.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C (and older versions of Perl), C# is an object-oriented language, similar
    to Ruby, Python, and Java. This means that we can build complex classes to represent
    data structures, along with the methods for those data structures, while writing
    code. Namespaces allow us to organize our classes and code as well as to prevent
    potential name collisions, such as when two programmers create two classes with
    the same name. If two classes with the same name are in different namespaces,
    there won’t be a problem. Every class is required to have a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: With the namespace out of the way, we can declare a class ➌ that will hold our
    Main() method ➍. As we stated previously, classes allow us to create complex data
    types as well as data structures that better fit real-world objects. In this example,
    the name of the class doesn’t actually matter; it’s just a container for our Main()
    method, which is what really matters because the Main() method is what will execute
    when we run our sample application. Every C# application requires a Main() method,
    just like in C and Java. If your C# application accepts arguments on the command
    line, you can use the args variable ➎ to access the arguments passed to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Simple data structures, such as strings ➏, exist in C#, and more complex ones,
    such as a class representing the date and time ➐, can also be created. The DateTime
    class is a core C# class for dealing with dates. In our example, we use it to
    store the current date and time (DateTime.Now) in the variable now. Finally, with
    our variables declared, we can print a friendly message using the Console class’s
    Write() ➑ and WriteLine() ➒ methods (the latter of which includes a newline character
    at the end).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using an IDE, you can compile and run the code by clicking the Run
    button, which is in the top-left corner of the IDE and looks like a Play button,
    or by pressing the F5 key. However, if you would like to compile the source code
    from the command line with the Mono compiler, you can easily do that as well.
    From the directory with your C# class code, use the mcs tool shipped with Mono
    to compile your classes into an executable, like so: $ mcs Main.cs -out:ch1_hello_world.exe
    Running the code from [Listing 1-1](#filepos73487) should print both the string
    "Hello World!" and the current date on the same line, as in [Listing 1-2](#filepos77351).
    On some Unix systems, you may need to run mono ch1_hello_world.exe.'
  prefs: []
  type: TYPE_NORMAL
- en: $ ./ch1_hello_world.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hello World! The date is Wednesday, June 28, 2017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-2: Running the Hello World application'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on your first C# application!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Classes and Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: Classes and interfaces are used to create complex data structures that would
    be difficult to represent with just built-in structures. Classes and interfaces
    can have properties, which are variables that get or set values for a class or
    interface, and methods, which are like functions that execute on the class (or
    subclasses) or interface and are unique to it. Properties and methods are used
    to represent data about an object. For instance, a Firefighter class might need
    an int property to represent the firefighter’s pension or a method that tells
    the firefighter to drive to a place where there’s a fire.
  prefs: []
  type: TYPE_NORMAL
- en: Classes can be used as blueprints to create other classes in a technique called
    subclassing. When a class subclasses another class, it inherits the properties
    and methods from that class (known as the parent class). Interfaces are used as
    a blueprint for new classes as well, but unlike classes, they don’t have inheritance.
    Thus a base class that implements an interface won’t pass down the interface’s
    properties and methods if it’s subclassed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Class
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create the simple class shown in [Listing 1-3](#filepos79605) as an example
    that represents a public servant data structure for someone who works every day
    to make our lives easier and better.
  prefs: []
  type: TYPE_NORMAL
- en: public ➊abstract class PublicServant
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int ➋PensionAmount { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public abstract void ➌DriveToPlaceOfInterest();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-3: The  PublicServant  abstract class'
  prefs: []
  type: TYPE_NORMAL
- en: The PublicServant class is a special kind of class. It is an abstract class
    ➊. Generally, you can just create a class like you do any other type of variable,
    and it is called an instance or an object. Abstract classes, though, cannot be
    instantiated like other classes; they can only be inherited through subclassing.
    There are many types of public servants—firefighters and police officers are two
    that come to mind immediately. It would therefore make sense to have a base class
    that these two types of public servants inherit from. In this case, if these two
    classes were subclasses of PublicServant, they would inherit a PensionAmount property
    ➋ and a DriveToPlaceOfInterest delegate ➌ that must be implemented by subclasses
    of PublicServant. There is no general “public servant” job that someone can apply
    for, so there isn’t a reason to create just a PublicServant instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Interface
  prefs: []
  type: TYPE_NORMAL
- en: A complement to classes in C# are interfaces. Interfaces allow a programmer
    to force a class to implement certain properties or methods that aren’t inherited.
    Let’s create a simple interface to start with, as shown in [Listing 1-4](#filepos81752).
    This interface is called IPerson and will declare a couple of properties that
    people usually have.
  prefs: []
  type: TYPE_NORMAL
- en: public interface ➊IPerson
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string ➋Name { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int ➌Age { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-4: The  IPerson  interface'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces in C# are usually prefaced with an I to distinguish them from classes
    that may implement them. This I isn’t required, but it is a very common pattern
    used in mainstream C# development.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a class were to implement the IPerson interface ➊, that class would need
    to implement both a Name ➋ and an Age ➌ property on its own. Otherwise, it wouldn’t
    compile. I’ll show exactly what this means when we implement the Firefighter class
    next, which implements the IPerson interface. For now, just know that interfaces
    are an important and useful feature of C#. Programmers familiar with interfaces
    in Java will feel right at home with them. C programmers can think of them as
    header files with function declarations that expect a .c file to implement the
    function. Those familiar with Perl, Ruby, or Python may find interfaces strange
    at first because there isn’t a comparable feature in those languages.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing from an Abstract Class and Implementing an Interface
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put our PublicServant class and IPerson interface to some use and solidify
    a bit of what we have talked about. We can create a class to represent our firefighters
    that inherits from the PublicServant class and implements the IPerson interface,
    as shown in [Listing 1-5](#filepos85009).
  prefs: []
  type: TYPE_NORMAL
- en: 'public class ➊Firefighter : ➋PublicServant, ➌IPerson'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➍Firefighter(string name, int age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = name;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Age = age;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: //implement the IPerson interface
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➎Name { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int ➏Age { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public override void ➐DriveToPlaceOfInterest()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GetInFiretruck();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TurnOnSiren();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FollowDirections();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void GetInFiretruck() {}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void TurnOnSiren() {}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void FollowDirections() {}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-5: The  Firefighter  class'
  prefs: []
  type: TYPE_NORMAL
- en: The Firefighter class ➊ is a bit more complex than anything we’ve implemented
    yet. First, note that the Firefighter class inherits from the PublicServant class
    ➋ and implements the IPerson interface ➌. This is done by listing the class and
    interface, separated by commas, after the Firefighter class name and a colon.
    We then create a new constructor ➍ that is used to set the properties of a class
    when a new class instance is created. The new constructor will accept the name
    and age of the firefighter as arguments, which will set the Name ➎ and Age ➏ properties
    required by the IPerson interface with the values passed. We then override the
    DriveToPlaceOfInterest() method ➐ inherited from the PublicServant class with
    one of our own, calling a few empty methods that we declare. We’re required to
    implement the DriveToPlaceOfInterest() method because it’s marked as abstract
    in the PublicServant class and abstract methods have to be overridden by subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: Classes come with a default constructor that has no parameters to create instances.
    Creating a new constructor actually overrides the default constructor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The PublicServant class and IPerson interface can be very flexible and can be
    used to create classes with completely different uses. We will implement one more
    class, a PoliceOfficer class, as shown in [Listing 1-6](#filepos88910), using
    PublicServant and IPerson.
  prefs: []
  type: TYPE_NORMAL
- en: 'public class ➊PoliceOfficer : PublicServant, IPerson'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private bool _hasEmergency;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public PoliceOfficer(string name, int age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = name;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Age = age;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _hasEmergency = ➋false;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: //implement the IPerson interface
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int Age { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool ➌HasEmergency
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: get { return _hasEmergency; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: set { _hasEmergency = value; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public override void ➍DriveToPlaceOfInterest()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GetInPoliceCar();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (this.➎HasEmergency)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TurnOnSiren();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FollowDirections();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void GetInPoliceCar() {}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void TurnOnSiren() {}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void FollowDirections() {}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-6: The  PoliceOfficer  class'
  prefs: []
  type: TYPE_NORMAL
- en: The PoliceOfficer class ➊ is similar to the Firefighter class, but there are
    a few differences. Most notably, a new property called HasEmergency ➌ is set in
    the constructor ➋. We also override the DriveToPlaceOfInterest() method ➍ as in
    the previous Firefighter class, but this time, we use the HasEmergency property
    ➎ to determine whether the officer should drive the car with the siren on. We
    can use the same combination of parent class and interface to create classes that
    function completely differently.
  prefs: []
  type: TYPE_NORMAL
- en: Tying Everything Together with the Main() Method
  prefs: []
  type: TYPE_NORMAL
- en: We can use our new classes to test a few more features of C#. Let’s write a
    new Main() method to show off these new classes, as shown in [Listing 1-7](#filepos92281).
  prefs: []
  type: TYPE_NORMAL
- en: using System;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: namespace ch1_the_basics
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public class MainClass
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Firefighter firefighter = new ➊Firefighter("Joe Carrington", 35);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.➋PensionAmount = 5000;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(firefighter);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintPensionAmount(firefighter);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.DriveToPlaceOfInterest();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PoliceOfficer officer = new PoliceOfficer("Jane Hope", 32);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.PensionAmount = 5500;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.➌HasEmergency = true;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍PrintNameAndAge(officer);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintPensionAmount(officer);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.➎DriveToPlaceOfInterest();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static void PrintNameAndAge(➏IPerson person)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Name: " + person.Name);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Age: " + person.Age);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static void PrintPensionAmount(➐PublicServant servant)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (servant is ➑Firefighter)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Pension of firefighter: " + servant.PensionAmount);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else if (servant is ➒PoliceOfficer)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Pension of officer: " + servant.PensionAmount);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-7: Tying together the  PoliceOfficer  and  Firefighter  classes with
    a  Main()  method'
  prefs: []
  type: TYPE_NORMAL
- en: To use the PoliceOfficer and Firefighter classes, we must instantiate them using
    the constructors we defined in the respective classes. We do this first with the
    Firefighter class ➊, passing a name of Joe Carrington and an age of 35 to the
    class constructor and assigning the new class to the firefighter variable. We
    also set the firefighter PensionAmount property ➋ to 5000. After the firefighter
    has been set up, we pass the object to the PrintNameAndAge() and PrintPension()
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the PrintNameAndAge() method takes the IPerson interface ➏ as an argument,
    not a Firefighter, PoliceOfficer, or PublicServant class. When a class implements
    an interface, you can create methods that accept that interface (in our case,
    IPerson) as an argument. If you pass IPerson to a method, the method only has
    access to the properties or methods that the interface requires instead of to
    the whole class. In our example, only the Name and Age properties are available,
    which is all we need for the method.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the PrintPensionAmount() method accepts PublicServant ➐ as its argument,
    so it only has access to the PublicServant properties and methods. We can use
    the C# is keyword to check whether an object is a certain type of class, so we
    do this to check whether our public servant is a Firefighter ➑ or a PoliceOfficer
    ➒, and we print a message depending on which it is.
  prefs: []
  type: TYPE_NORMAL
- en: We do the same for the PoliceOfficer class as we did for Firefighter, creating
    a new class with a name of Jane Hope and an age of 32; then we set her pension
    to 5500 and her HasEmergency property ➌ to true. After printing the name, age,
    and pension ➍, we call the officer’s DriveToPlaceOfInterest() method ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Main() Method
  prefs: []
  type: TYPE_NORMAL
- en: Running the application should demonstrate how classes and methods interact
    with each other, as shown in [Listing 1-8](#filepos96097).
  prefs: []
  type: TYPE_NORMAL
- en: $ ./ch1_the_basics.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Name: Joe Carrington'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Age: 35'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pension of firefighter: 5000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Name: Jane Hope'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Age: 32'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pension of officer: 5500'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-8: Running the basics program’s  Main()  method'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the public servants’ names, ages, and pensions are printed to
    the screen, exactly as expected!
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Methods
  prefs: []
  type: TYPE_NORMAL
- en: The methods we have used so far have been class methods, but we can also use
    anonymous methods. This powerful feature of C# allows us to dynamically pass and
    assign methods using delegates. With a delegate, a delegate object is created
    that holds a reference to the method that will be called. We create this delegate
    in a parent class and then assign the delegate’s reference to anonymous methods
    in subclasses of the parent class. This way, we can dynamically assign a block
    of code in a subclass to the delegate instead of overriding the parent class’s
    method. To demonstrate how to use delegates and anonymous methods, we can build
    on the classes we have already created.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a Delegate to a Method
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update the PublicServant class to use a delegate for the method DriveToPlaceOfInterest(),
    as shown in [Listing 1-9](#filepos98120).
  prefs: []
  type: TYPE_NORMAL
- en: public abstract class PublicServant
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int PensionAmount { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public delegate void ➊DriveToPlaceOfInterestDelegate();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public DriveToPlaceOfInterestDelegate ➋DriveToPlaceOfInterest { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-9: The  PublicServant  class with a delegate'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous PublicServant class, we needed to override the DriveToPlaceOfInterest()
    method if we wanted to change it. In the new PublicServant class, DriveToPlaceOfInterest()
    is replaced with a delegate ➊ and a property ➋ that allow us to call and assign
    DriveToPlaceOfInterest(). Now, any classes inheriting from the PublicServant class
    will have a delegate they can use to set their own anonymous method for DriveToPlaceOfInterest()
    instead of having to override the method within each class. Because they inherit
    from PublicServant, we’ll need to update our Firefighter and PoliceOfficer class
    constructors accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Firefighter Class
  prefs: []
  type: TYPE_NORMAL
- en: We’ll update the Firefighter class first with the new delegate property. The
    constructor, shown in [Listing 1-10](#filepos100265), is the only change we make.
  prefs: []
  type: TYPE_NORMAL
- en: public ➊Firefighter(string name, int age)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➋Name = name;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➌Age = age;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.DriveToPlaceOfInterest ➍+= delegate
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Driving the firetruck");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GetInFiretruck();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TurnOnSiren();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FollowDirections();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-10: The  Firefighter  class using the delegate for the  DriveToPlaceOfInterest()  method'
  prefs: []
  type: TYPE_NORMAL
- en: In the new Firefighter class constructor ➊, we assign the Name ➋ and Age ➌ like
    we did before. Next, we create the anonymous method and assign it to the DriveToPlaceOfInterest
    delegate property using the += operator ➍ so that calling DriveToPlaceOfInterest()
    will call the anonymous method. This anonymous method prints "Driving the firetruck"
    and then runs the empty methods from the original class. This way, we can add
    the customized code we want to each method within a class without having to override
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Optional Arguments
  prefs: []
  type: TYPE_NORMAL
- en: The PoliceOfficer class requires a similar change; we update the constructor
    as shown in [Listing 1-11](#filepos103274). Because we’re already updating this
    class, we can also change it to use an optional argument, which is a parameter
    in a constructor that does not have to be included when a new instance is created.
    We’ll create two anonymous methods and use an optional argument to determine which
    method to assign to the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: public ➊PoliceOfficer(string name, int age, bool ➋hasEmergency = false)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➌Name = name;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➍Age = age;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➎HasEmergency = hasEmergency;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (this.➏HasEmergency)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.DriveToPlaceOfInterest += delegate
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Driving the police car with siren");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GetInPoliceCar();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TurnOnSiren();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FollowDirections();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '} else'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.DriveToPlaceOfInterest += delegate
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Driving the police car");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GetInPoliceCar();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FollowDirections();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-11: The new  PoliceOfficer  constructor'
  prefs: []
  type: TYPE_NORMAL
- en: In the new PoliceOfficer constructor ➊, we set the Name ➌ and Age ➍ properties
    as we did originally. This time, however, we also use an optional third argument
    ➋ to assign the HasEmergency property ➎. The third argument is optional because
    it does not need to be specified; it has a default value (false) when the constructor
    is provided with only the first two arguments. We then set the DriveToPlaceOfInterest
    delegate property with a new anonymous method, depending on whether HasEmergency
    is true ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Main() Method
  prefs: []
  type: TYPE_NORMAL
- en: With the new constructors, we can run an updated Main() method that is almost
    identical to the first. It’s detailed in [Listing 1-12](#filepos105699).
  prefs: []
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Firefighter firefighter = new Firefighter("Joe Carrington", 35);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.PensionAmount = 5000;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(firefighter);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintPensionAmount(firefighter);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: firefighter.DriveToPlaceOfInterest();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PoliceOfficer officer = new ➊PoliceOfficer("Jane Hope", 32);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.PensionAmount = 5500;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(officer);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintPensionAmount(officer);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.DriveToPlaceOfInterest();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer = new ➋PoliceOfficer("John Valor", 32, true);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PrintNameAndAge(officer);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: officer.➌DriveToPlaceOfInterest();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-12: The updated  Main()  method using our classes with delegates
    for driving to places of interest'
  prefs: []
  type: TYPE_NORMAL
- en: The only differences are in the last three lines, which demonstrate creating
    a new PoliceOfficer ➋ who has an emergency (the third argument to the constructor
    is true), as opposed to Jane Hope ➊, who has none. We then call DriveToPlaceOfInterest()
    on the John Valor officer ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Updated Main() Method
  prefs: []
  type: TYPE_NORMAL
- en: Running the new method shows how creating two PoliceOfficer classes—one with
    an emergency and one without—will print two different things, as demonstrated
    in [Listing 1-13](#filepos107506).
  prefs: []
  type: TYPE_NORMAL
- en: $ ./ch1_the_basics_advanced.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Name: Joe Carrington'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Age: 35'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pension of firefighter: 5000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Driving the firetruck
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Name: Jane Hope'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Age: 32'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pension of officer: 5500'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊ Driving the police car
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Name: John Valor'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Age: 32'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➋ Driving the police car with siren Listing 1-13: Running the new  Main()  method
    with classes using delegates'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you can see, creating a PoliceOfficer class with an emergency causes the
    officer to drive with the siren on ➋. Jane Hope, on the other hand, can drive
    without her siren on ➊ because she has no emergency.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Native Libraries
  prefs: []
  type: TYPE_NORMAL
- en: Finally, sometimes you need to use libraries that are available only in standard
    operating system libraries, such as libc on Linux and user32.dll on Windows. If
    you plan to use code in a library that was written in C, C++, or another language
    that gets compiled down to native assembly, C# makes working with these native
    libraries very easy, and we will use this technique in [Chapter 4](index_split_009.html#filepos344540)
    when making cross-platform Metasploit payloads. This feature is called Platform
    Invoke, or P/Invoke for short. Programmers often need to use native libraries
    because they are faster than a virtual machine such as used by .NET or Java. Programmers
    such as financial or scientific professionals who use code to do heavy math might
    write the code that they need to be fast in C (for example, code for interfacing
    directly with hardware) but use C# to handle code that requires less speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-14](#filepos110442) shows a simple application that uses P/Invoke
    to call the standard C function printf() in Linux or to pop up a message box using
    user32.dll on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: class MainClass
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[➊DllImport("user32", CharSet=CharSet.Auto)]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport("libc")]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static extern void printf(string message);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: static void ➋Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OperatingSystem os = Environment.OSVersion;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➌os.Platform == ➍PlatformID.Win32Windows||os.Platform == PlatformID.Win32NT)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎MessageBox(IntPtr.Zero, "Hello world!", "Hello world!", 0);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '} else'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏printf("Hello world!");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 1-14: Demonstrating P/Invoke with a simple example'
  prefs: []
  type: TYPE_NORMAL
- en: This example looks more complex than it is. We first declare two functions that
    will be looked up externally in different libraries. We do this using the DllImport
    attribute ➊. Attributes allow you to add extra information to methods (or classes,
    class properties, and so on) that is used at runtime by the .NET or Mono virtual
    machine. In our case, the DllImport attribute tells the runtime to look up the
    method we are declaring in another DLL, instead of expecting us to write it.
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the exact function names and the parameters the functions expect.
    For Windows, we can use the MessageBox() function, which expects a few parameters
    such as the title of the pop-up and the text to be displayed. For Linux, the printf()
    function expects a string to print. Both of these functions are looked up at runtime,
    which means we can compile this on any system because the function in the external
    library isn’t looked for until the program is running and the function is called.
    This lets us compile the application on any operating system, regardless of whether
    that system has either or both libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our native functions declared, we can write a quick Main() method ➋ that
    checks the current operating system with an if statement using os.Platform ➌.
    The Platform property we use maps to the PlatformID enumeration ➍, which stores
    the available operating systems that the program could be running on. Using the
    PlatformID enumeration, we can test whether we are on Windows and then call the
    respective method: either MessageBox() ➎ on Windows or printf() ➏ on Unix. This
    application, when compiled, can be run on either a Windows machine or a Linux
    machine, no matter what operating system compiled it.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: The C# language has many modern features that make it a great language for complex
    data and applications. We have only scratched the surface of some of the more
    powerful features like anonymous methods and P/Invoke. You’ll become intimate
    with the concepts of classes and interfaces, as well as many other advanced features,
    in the chapters to come. In addition, you’ll learn about many more of the core
    classes available to you, such as HTTP and TCP clients and much more.
  prefs: []
  type: TYPE_NORMAL
- en: As we develop our own custom security tools throughout this book, you will also
    learn about general programming patterns, which are useful conventions for creating
    classes that make building on them easy and fast. Good examples of programming
    patterns are used in [Chapters 5](index_split_010.html#filepos420379) and [11](index_split_016.html#filepos761301)
    where we interface with APIs and RPCs of third-party tools such as Nessus and
    Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this book, we will have covered how C# can be used for every security
    practitioner’s job—from the security analyst to the engineer, and even the hobbyist
    researcher at home. C# is a beautiful and powerful language, and with cross-platform
    support from Mono bringing C# to phones and embedded devices, it is just as capable
    and usable as Java and other alternatives.
  prefs: []
  type: TYPE_NORMAL
