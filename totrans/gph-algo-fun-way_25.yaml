- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONSTRUCTING
    GRAPHS</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">构建图</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This book has covered a range of algorithms that operate over graphs. To apply
    these algorithms to real-world problems, we need a mechanism for programmatically
    creating new graphs or loading them from files.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书已经涵盖了多种操作图的算法。为了将这些算法应用于现实问题，我们需要一个机制，能够以编程方式创建新图或从文件中加载它们。
- en: While the graph creation functions in [Chapter 1](chapter1.xhtml) such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    provide a full mechanism for defining graphs, it would be unrealistic to hard-code
    the creation of each graph. Beyond the tedium of listing out hundreds or thousands
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> statements,
    such an approach is error-prone.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[第1章](chapter1.xhtml)中的图形创建函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> 提供了定义图的完整机制，但为每个图形手动编写代码是不现实的。除了列出数百或数千个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> 语句的繁琐外，这种方法还容易出错。
- en: In this appendix we introduce a variety of simple mechanisms for creating graphs
    and loading them from files. As with previous chapters, we optimize for understandability
    instead of storage size or computational efficiency. This means that some of the
    input formats we use, such as comma-separated values, will be simplistic. However,
    these formats are perfect for demonstrating what information we need to consider
    and how we can programmatically manipulate it to form a graph. Readers can build
    off of these approaches to construct formats optimized for their own applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们介绍了几种简单的机制，用于创建图并从文件中加载它们。与前几章一样，我们优化的是易理解性，而非存储大小或计算效率。这意味着我们使用的某些输入格式，如逗号分隔值，将是简单的。然而，这些格式非常适合展示我们需要考虑的信息以及如何以编程方式操作这些信息来构建图。读者可以基于这些方法构建适合自己应用的优化格式。
- en: This appendix makes use of Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    library to facilitate loading and parsing files. We encourage readers to explore
    the vast ecosystem of more specialized libraries that might further simplify their
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录使用 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> 库来简化文件的加载和解析。我们鼓励读者探索更多专门的库，它们可能进一步简化代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Constructing Graphs from Edges</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">从边构建图</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure
    we’ve used since [Chapter 1](chapter1.xhtml) relies upon a constructor that creates
    an initial graph with no edges. The user can add edges to the graph using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function. In
    this section, we’ll automate this flow to build graphs from lists of edges.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第1章](chapter1.xhtml)开始使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    数据结构依赖于一个构造函数，它创建一个没有边的初始图。用户可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    函数向图中添加边。在本节中，我们将自动化这一流程，基于边的列表构建图。
- en: After creating a new graph from a given list of edges, we extend this functionality
    to read from and write to edge files. Along the way, we tackle the problem of
    nodes being specified by a generic text label rather than a node index.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在从给定的边列表创建一个新图后，我们将扩展该功能以从边文件中读取并写入数据。在此过程中，我们解决了节点是通过通用文本标签而不是节点索引来指定的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inserting Edges from
    a List</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从列表插入边</samp>
- en: 'We can create a graph from a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    data structures:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 数据结构的列表来创建一个图：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to the edge list, the code takes in the number of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp>)
    and whether the graph is undirected (<samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>).
    It creates an initial graph structure with the correct number of nodes and undirected
    setting, then loops over each edge and inserts it into the graph. If the edges
    are undirected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class
    inserts a directed edge in each direction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了边列表，代码还输入节点数量（<samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp>）以及图是否为无向图（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>）。它创建一个初始的图结构，包含正确数量的节点和无向设置，然后循环遍历每个边并将其插入到图中。如果边是无向的，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>函数在<sam class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类中会在两个方向插入有向边。
- en: In many cases, we could compute the number of nodes directly from the edge list
    by tracking the largest node index seen. However, this approach does not allow
    for graphs with fully disconnected nodes, because their index would never appear
    in the edge list and the resulting graph might miss later nodes. Instead, the
    code takes <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> as an
    input parameter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可以通过跟踪看到的最大节点索引来直接计算节点数量。然而，这种方法不允许存在完全断开的节点，因为它们的索引永远不会出现在边列表中，结果图可能会缺少后面的节点。因此，代码将<sam
    class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp>作为输入参数。
- en: '[Figure A-1](#figA-1) shows an example graph construction where the following
    directed edges are inserted:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图A-1](#figA-1)展示了一个图的构造示例，其中插入了以下有向边：'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[Edge(0,1,1.0), Edge(1,3,10.0),
    Edge(2,4,5.0), Edge(3,1,2.0), Edge(1,2,3.0)]</samp>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[Edge(0,1,1.0), Edge(1,3,10.0),
    Edge(2,4,5.0), Edge(3,1,2.0), Edge(1,2,3.0)]</samp>
- en: '[Figure A-1(a)](#figA-1) shows the graph after the first node is inserted.
    Each subfigure shows the state of the graph after one iteration of the code’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图A-1(a)](#figA-1)展示了第一个节点插入后的图。每个子图展示了代码的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环迭代后的图状态。'
- en: '![Six subfigures show a five-node graph with an increasing number of edges.
    In (A), there are no edges. In (B), the edge (0, 1) has been added.](../images/f0a001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![六个子图展示了一个五节点图，边的数量逐渐增加。在（A）中，没有边。在（B）中，边（0, 1）已被添加。](../images/f0a001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The steps of adding
    edges to a graph with five nodes</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图A-1：向一个五节点图中添加边的步骤</samp>
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_graph_from_edges()</samp>
    function in conjunction with algorithms that return lists of edges, such as the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">randomized_kruskals()</samp> algorithm
    in [Chapter 10](chapter10.xhtml).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将<samp class="SANS_TheSansMonoCd_W5Regular_11">make_graph_from_edges()</samp>函数与返回边列表的算法结合使用，例如[第10章](chapter10.xhtml)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">randomized_kruskals()</samp>算法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loading Edge Lists
    from Files</samp>
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从文件加载边列表</samp>
- en: 'A natural approach to constructing graphs is to load the graph directly from
    a file. While there are myriad different formats we could use to store a graph’s
    representation, we’ll start with one of the simplest approaches: storing a graph
    as a file of comma-separated values (CSV). Each row indicates a single edge listing
    the originating node as a string label, the destination node as a string label,
    and an optional floating-point weight. Unconnected nodes are listed alone.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建图的一种自然方法是直接从文件加载图。虽然我们可以使用许多不同的格式来存储图的表示，但我们将从最简单的方法之一开始：将图存储为逗号分隔值（CSV）文件。每一行表示一个边，列出起始节点作为字符串标签，目标节点作为字符串标签，以及一个可选的浮动权重。未连接的节点单独列出。
- en: 'Using this CSV format, we can encode the undirected graph shown in [Figure
    A-2](#figA-2) with the following data:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种CSV格式，我们可以使用以下数据对[图A-2](#figA-2)中显示的无向图进行编码：
- en: a,b
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: a,b
- en: b,c,10.0
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: b,c,10.0
- en: d,e,5.0
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: d,e,5.0
- en: The data define a graph with five nodes a, b, c, d, and e, and three edges.
    Two of the edges are given explicit weights and the third uses a default value
    of 1.0.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据定义了一个包含五个节点a、b、c、d和e，以及三条边的图。两条边具有显式权重，第三条使用默认值1.0。
- en: '![A graph with five nodes and undirected edges (a, b), (b, c), and (d, e).](../images/f0a002.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和无向边（a, b）、（b, c）和（d, e）的图。](../images/f0a002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A graph with five
    nodes and three weighted edges</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图A-2：一个包含五个节点和三条加权边的图</samp>
- en: We can extend this format to account for fully disconnected nodes, which will
    not appear in any edge, by allowing rows with a single entry. This single entry
    simply indicates the node exists so that the program includes it in the graph.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展此格式以考虑完全断开的节点，这些节点不会出现在任何边中，通过允许只有一个条目的行来实现。这一单一条目仅表示节点存在，从而程序将其包含在图中。
- en: We can use this general format to encode a vast number of real-world phenomena.
    For example, we could use a single file to represent note-passing behavior in
    a classroom. Each node represents a student. Each row provides new information
    about the class (graph). A row can contain a single name to indicate the existence
    of a student (node). Alternatively, a row can indicate the directed note-passing
    behavior between a pair of students and includes <samp class="SANS_TheSansMonoCd_W5Regular_11">person1</samp>*,*
    <samp class="SANS_TheSansMonoCd_W5Regular_11">person2</samp>*,* <samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>
    to indicate how many times (represented by weight) person 1 passed a note to person
    2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种通用格式来编码大量的现实世界现象。例如，我们可以使用一个文件来表示教室里的纸条传递行为。每个节点代表一个学生。每一行提供有关课堂（图）的新信息。一行可以包含一个单独的名字，表示学生（节点）的存在。或者，一行可以表示学生之间的有向纸条传递行为，并包含<sup
    class="SANS_TheSansMonoCd_W5Regular_11">person1</sup>*,* <sup class="SANS_TheSansMonoCd_W5Regular_11">person2</sup>*,*
    <sup class="SANS_TheSansMonoCd_W5Regular_11">weight</sup>，表示学生1向学生2传递纸条的次数（由weight表示）。
- en: The code to read such a CSV file makes use of Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    function to read the file and the csv package (which requires importing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>) to parse each row, as shown
    in Listing A-1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 读取此类CSV文件的代码利用Python的<sup class="SANS_TheSansMonoCd_W5Regular_11">open()</sup>函数来读取文件，并使用csv包（需要导入<sup
    class="SANS_TheSansMonoCd_W5Regular_11">csv</sup>）来解析每一行，如列表A-1所示。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: Loading a graph
    from a CSV file</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表A-1：从CSV文件加载图</samp>
- en: The code starts by creating the necessary data structures—an empty graph (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>) and an empty dictionary (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>) that will map the
    string names to the corresponding node index.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建必要的数据结构——一个空的图（<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）和一个空的字典（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>），该字典将字符串名称映射到相应的节点索引。
- en: The code then opens the file and parses it using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp>
    ❶. It iterates through every row in the file, reading up to three entries ❷. For
    each row, it extracts the name of the node from the first entry. Since the code
    reads in names, it needs to map those names to a corresponding index. If the node
    is in the graph already, the code can look it up from the <samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>
    dictionary. Otherwise, it has found a node that is not yet in the graph and must
    insert this node into the graph and the name into the dictionary. If the row has
    only a single entry, the function skips the rest of the logic and continues to
    the next row.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码打开文件并使用<sup class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</sup> ❶进行解析。它遍历文件中的每一行，最多读取三个条目
    ❷。对于每一行，它从第一个条目中提取节点的名称。由于代码读取的是名称，它需要将这些名称映射到相应的索引。如果节点已经在图中，代码可以从<sup class="SANS_TheSansMonoCd_W5Regular_11">node_indices</sup>字典中查找它。否则，它发现了一个尚未在图中的节点，并必须将该节点插入到图中，并将名称插入字典。如果该行仅包含一个条目，函数会跳过剩余的逻辑并继续到下一行。
- en: If the row has a second entry, however, that row specifies an edge ❸. The code
    extracts the second node’s name. Again, it checks whether the node is in the graph
    and, if not, inserts it. The code checks for a third entry in the row, indicating
    a weight ❹. If no weight is provided, the code uses a default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
    Finally, the code uses the combination of the two node indices and the weight
    to insert a new edge into the graph.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这一行有第二个条目，那么该行指定了一个边 ❸。代码提取第二个节点的名称。然后，它检查该节点是否在图中，如果不在，就插入该节点。代码会检查行中是否有第三个条目，表示权重
    ❹。如果没有提供权重，代码会使用默认值 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>。最后，代码使用这两个节点的索引和权重的组合，将一条新边插入到图中。
- en: The code continues row by row in the CSV until it has read the entire file.
    At that point it returns the final graph. The file is closed automatically as
    the code exits the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码会逐行读取CSV文件，直到读取完整个文件。此时，它会返回最终的图。文件会在代码退出 <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    语句时自动关闭。
- en: One of the major complexities in this code is mapping the nodes’ text strings
    to their indices. In theory, we could restrict our loader function to require
    that files supply each node’s integer index. While this would remove the need
    for a mapping, it greatly reduces the usability. Anytime we want to load in a
    new graph, we must first construct a mapping from name to index and convert the
    file. In a later section, we will look at how to incorporate this common operation
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure
    itself.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的主要复杂性之一是将节点的文本字符串映射到它们的索引。理论上，我们可以限制加载函数要求文件提供每个节点的整数索引。虽然这样可以去掉映射的需求，但会大大降低可用性。每次我们想加载一个新的图时，必须首先构建从名称到索引的映射并转换文件。在后续章节中，我们将讨论如何将这一常见操作集成到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 数据结构本身。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Saving Edge Lists
    to Files</samp>
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将边列表保存到文件</samp>
- en: We can use the same comma-separated values format to save our favorite graphs.
    Since most of the graphs we have considered have not used named nodes, we will
    use each node’s integer index as its name in our CSV file. However, we still face
    the problem that the code in Listing A-1 assigns node indices as they are encountered.
    Ideally, we would like node 5 to stay node 5 when reloaded, regardless of the
    order in which the code encounters it in the edge list.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的逗号分隔值格式来保存我们最喜爱的图。由于我们考虑的大多数图未使用命名节点，因此我们将在CSV文件中使用每个节点的整数索引作为其名称。然而，我们仍然面临清单
    A-1 中的代码将节点索引分配到遇到的位置的问题。理想情况下，我们希望节点 5 在重新加载时仍然是节点 5，无论代码在边列表中遇到它的顺序如何。
- en: There are a couple potential solutions to this problem. We could forgo names
    altogether and just store the integer node indices in the CSV, modifying Listing
    A-1 to read the node names directly as integer indices. Alternatively, we can
    output one node name per row in order at the start of the CSV file to indicate
    their existence. This will ensure that the first node is mapped to index 0, the
    second to index 1, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种潜在的方案。我们可以完全放弃使用名称，只在CSV中存储整数节点索引，并修改清单 A-1 以直接将节点名称读取为整数索引。或者，我们可以在CSV文件开始时按顺序输出每行一个节点名称，以指示它们的存在。这样可以确保第一个节点映射到索引
    0，第二个节点映射到索引 1，以此类推。
- en: 'For the following code, we use this second approach to stay consistent with
    Listing A-1\. This code will work for an integer-based reader as well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下代码，我们采用第二种方法，以保持与清单 A-1 一致。这段代码同样适用于基于整数的读取器：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code opens the file and writes to it using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.writer</samp>
    ❶. It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to
    iterate through each node, writing one node index per row ❷. This ensures that
    all nodes are captured in the CSV even if they are not part of any edges. Finally,
    a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops iterate
    through each edge in the graph and write out three values (origin node, destination
    node, and weight) representing the edge ❸. The file closes automatically as the
    code exits the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用<samp class="SANS_TheSansMonoCd_W5Regular_11">csv.writer</samp>打开文件并写入数据❶。它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历每个节点，每行写入一个节点索引❷。这确保了即使某些节点不属于任何边，也会被包含在CSV中。最后，一对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历图中的每条边，并写入三项值（起始节点、目标节点和权重），表示这条边❸。当代码退出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp>语句时，文件会自动关闭。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Inserting Nodes by Name</samp>
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">按名称插入节点</samp>
- en: A significant portion of the code in Listing A-1 consists of handling the mapping
    of a node’s name to its index. We look up each name string in the <samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>
    dictionary to get the index. If the name is not in the dictionary, we need to
    insert a new node and create the corresponding dictionary entry mapping the name
    to the new index. Depending on how you reference nodes in your program, this can
    be a common problem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A-1中的一大部分代码涉及到将节点名称映射到索引的处理。我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>字典中查找每个名称字符串，以获取索引。如果名称不在字典中，我们需要插入一个新节点，并创建一个相应的字典条目，将名称映射到新索引。根据你在程序中如何引用节点，这可能是一个常见问题。
- en: 'To simplify working with named nodes, we can incorporate this logic into the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class itself. We need
    to make two changes. First, we add the creation of an empty dictionary to the
    initialization function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化与命名节点的工作，我们可以将这一逻辑整合到<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类本身中。我们需要做两个修改。首先，在初始化函数中添加一个空字典的创建：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will use this dictionary whenever we need to map a name to an index.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要将名称映射到索引时，我们都会使用这个字典。
- en: Second, we add a function to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class that performs both the lookup and, if necessary, the insertion, as shown
    in Listing A-2.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们向<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类中添加一个函数，该函数执行查找和（如有必要）插入操作，如列表A-2所示。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Adding named nodes
    to a graph</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表A-2：向图中添加命名节点</samp>
- en: The code starts by determining if this node already exists in the graph by checking
    whether its name is in the mapping. If not, the graph inserts the node into the
    graph using the original <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp>
    function. It also inserts the name into the index map. The function finishes by
    returning the node’s index.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过检查节点名称是否在映射中，来判断该节点是否已经存在于图中。如果没有，图将使用原始的<samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp>函数将节点插入图中。它还将名称插入索引映射中。该函数最终返回节点的索引。
- en: We can picture this function in the context of a lazy teacher creating a seating
    chart. On the first day, the teacher allows the students to pick their own seats
    but does not bother to write down who is sitting where. Their seating chart is
    initially empty. As the class progresses, students raise their hands with questions.
    Each time this happens, the teacher glances down at their seating chart. If the
    student’s name is listed, the teacher uses it. Otherwise, they peer at the student
    and, with a complete lack of tact, ask, “Who are you?” When the student finishes
    rolling their eyes and responding, the teacher adds the student to the seating
    chart. The chart progressively gets filled in as the students are acknowledged.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过懒散教师创建座位表的情景来形象化这个函数。在第一天，老师允许学生选择自己的座位，但不打算记录谁坐在哪儿。座位表最初是空的。随着课程的进行，学生们举手提问。每次发生这种情况，老师都会看一眼座位表。如果学生的名字在上面，老师就会使用它。否则，老师会盯着学生看，完全没有技巧地问：“你是谁？”当学生翻完白眼并回答之后，老师会把学生添加到座位表中。随着学生们的出现，座位表逐渐填满。
- en: 'We can use these helper functions to rewrite the CSV reader code from Listing
    A-1 more compactly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些辅助函数，更简洁地重写列表A-1中的CSV读取器代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code follows the same flow as Listing A-1 but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by
    _name()</samp> to do both the node mapping and lookup for the first ❶ and second
    nodes ❷ in each row.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码遵循与列表A-1相同的流程，但使用<samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by
    _name()</samp>来进行节点映射和查找每行中的第一个❶和第二个节点❷。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Co-occurrences</samp>
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">共现</samp>
- en: '*Co-occurrence graphs* represent which pairs of entities have previously co-occurred.
    In biology, they can be used to study interactions, such as which genes are often
    present together or which microbes interact. In sociology, they can model gatherings
    of groups or coauthorship of academic publications. And in pop culture, they can
    help answer critical questions about which movie stars appeared on-screen together,
    as discussed in [Chapter 2](chapter2.xhtml).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*共现图*表示哪些实体对曾经共同出现过。在生物学中，它们可以用来研究相互作用，比如哪些基因经常一起出现，或者哪些微生物之间存在互动。在社会学中，它们可以建模群体聚会或学术出版物的共同作者关系。而在流行文化中，它们可以帮助回答一些关键问题，例如哪些电影明星曾经在同一部电影中共同出演，正如在[第2章](chapter2.xhtml)中讨论的那样。'
- en: The difficulty with ingesting co-occurrence data is that it usually consists
    of a list of sets instead of pairwise interactions. Our favorite online movie
    database probably does not list each pairing of movie stars from last summer’s
    smash hit. Instead, it provides a single list labeled *cast* that includes everyone
    who appeared in the movie.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收共现数据的难点在于，它通常由一组集合而不是成对的交互组成。我们最喜爱的在线电影数据库可能不会列出去年夏天热播电影中所有电影明星的每一对搭档。相反，它提供一个标记为*演员表*的单一列表，列出电影中所有出现的演员。
- en: 'For example, when reviewing all the local theater company’s recent productions,
    we might find the following cast lists:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在回顾当地剧团近期的所有演出时，我们可能会发现以下演员表：
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>)
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (<samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>)
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>)
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)
- en: Using a single cast list, we can easily see that <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    has appeared onstage with <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>.
    However, if we are interested in more complex questions such as how many degrees
    of separation there are between <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>, we need to construct
    a more comprehensive picture. [Figure A-3](#figA-3) shows the co-occurrence graph
    based on these plays.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一的演员表列表，我们可以很容易地看到<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">C</samp>曾在同一舞台上演出。然而，如果我们对更复杂的问题感兴趣，比如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">A</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>之间有多少度的分隔，我们就需要构建一个更全面的图像。[图A-3](#figA-3)展示了基于这些演出的共现图。
- en: '![A graph with 8 nodes and 12 edges. Node A has edges to nodes B, C, and D.](../images/f0a003.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含8个节点和12条边的图。节点A与节点B、C和D之间有边相连。](../images/f0a003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: An undirected graph
    with eight nodes representing the co-occurrence of actors in plays</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图A-3：一个无向图，包含八个节点，表示演员在剧中的共现情况</samp>
- en: To make the model more powerful, we can use edge weights to track how often
    two nodes have co-occurred. For example, Alice and Bob might have a stronger acting
    connection after appearing together in 10 different plays, while Diane’s weaker
    connection to Alice comes from sharing the stage a single time. If you are looking
    for an introduction to the world-famous Alice, it is better to use the stronger
    connection through Bob.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模型更强大，我们可以使用边权来追踪两个节点的共同出现次数。例如，Alice 和 Bob 在 10 个不同的戏剧中共同出演后，可能会有更强的演出关联，而
    Diane 与 Alice 的较弱连接则来源于仅仅一次的同台演出。如果你想了解世界著名的 Alice，最好通过 Bob 使用更强的关联。
- en: 'We can extend the approach used to load graphs from CSVs to construct pairwise
    graphs from arbitrary lists. Instead of expecting at most three entries per row,
    we allow all co-occurring entries to be listed on a single row. The code then
    determines the pairwise edges implied by each list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展从 CSV 加载图的方法，以从任意列表构建成对图形。我们不再期望每行最多只有三个条目，而是允许将所有共同出现的条目列在同一行。然后，代码会根据每个列表推断出成对的边：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As with the earlier CSV reader, the code starts by creating an empty graph,
    opening the file, and parsing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp>.
    This time, the code restricts the graph to being undirected, as there is no implied
    directionality in these co-occurrence edges. The code also does not maintain a
    dictionary of names, but rather uses the helper function from Listing A-2 to insert
    new nodes and retrieve each node’s index.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 CSV 读取器一样，代码首先创建一个空图，打开文件并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp>
    进行解析。这次，代码将图限制为无向图，因为这些共现边没有暗示的方向性。代码还不维护一个名称字典，而是使用列表 A-2 中的辅助函数来插入新节点并检索每个节点的索引。
- en: The code iterates through each row using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. For each row, it uses another pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to iterate over all unique pairs of entities on each row. It looks up the
    nodes’ indices using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>
    function, inserting new nodes as needed. Before creating an edge from the pair,
    the code checks whether the edge exists ❶. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    to allow <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to be returned
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function.
    If the edge already exists, the code retrieves its current weight and increments
    it by 1, then inserts a new edge with the updated weight ❷. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    overwrites the existing edges when a duplicate is inserted, the code effectively
    updates the weights of existing edges.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环逐行迭代。对于每一行，它使用另一对嵌套的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环来遍历每行中的所有唯一条目对。它通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp> 函数查找节点的索引，并在需要时插入新节点。在创建边之前，代码会检查该边是否已存在
    ❶。我们使用 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> 使得 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    可以由 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> 函数返回。如果边已存在，代码会检索其当前权重并将其增加
    1，然后插入具有更新权重的新边 ❷。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    在插入重复项时会覆盖现有的边，代码实际上是更新了现有边的权重。
- en: As with the previous CSV reader in Listing A-1, the code continues row by row
    until it has read the entire file. At that point it returns the final graph.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前在列表 A-1 中的 CSV 读取器一样，代码会逐行读取文件，直到读取完整个文件为止。此时，它会返回最终的图。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Spatial Points</samp>
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">空间点</samp>
- en: When using graphs to model path planning or other physical problems, we often
    need to construct a graph from a series of spatial data points. We can do this
    by creating a graph containing one node for each spatial point and one edge between
    *every pair* of points.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用图形来模拟路径规划或其他物理问题时，我们经常需要从一系列空间数据点构建图形。我们可以通过创建一个图，其中每个空间点对应一个节点，且每对点之间有一条边来实现这一点。
- en: '[Figure A-4](#figA-4) shows an example of such a representation. [Figure A-4(a)](#figA-4)
    shows five two-dimensional points: (0, 0), (1, 0), (1.2, 1), (1.8, 1), and (0.5,
    1.5). [Figure A-4(b)](#figA-4) shows the graph representation with the edge weights
    capturing the distance between points.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图A-4](#figA-4) 展示了这种表示方式的一个例子。[图A-4(a)](#figA-4) 展示了五个二维点：(0, 0)、(1, 0)、(1.2,
    1)、(1.8, 1) 和 (0.5, 1.5)。[图A-4(b)](#figA-4) 展示了图的表示，其中的边权重捕捉了点与点之间的距离。'
- en: '![(A) Shows Five Points Plotted on Cartesian X and Y Axes. (B) Shows the Points
    with the 10 Pairwise Edges, Each Labeled with the Pair’s Distance.](../images/f0a004.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了五个点在笛卡尔 X 和 Y 轴上的坐标。(B) 显示了这五个点与10条成对边的关系，每条边标注了对应的距离。](../images/f0a004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-4: A set of two-dimensional
    spatial points (a) and the corresponding graph representation (b)</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图A-4：一组二维空间点（a）及其对应的图表示（b）</samp>
- en: 'We start by defining a helper class to store the spatial points and compute
    the distance between them:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个辅助类来存储空间点并计算它们之间的距离：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> class
    is not required, it allows us to easily swap in higher-dimensional points or alternative
    distance functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function computes the Euclidean distance in two-dimensional space. Note that we
    will need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    to use the square root function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不要求使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> 类，但它使我们可以轻松地更换为更高维度的点或替代的距离函数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数计算二维空间中的欧几里得距离。请注意，我们需要导入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> 才能使用平方根函数。
- en: 'We can substitute in alternative distance functions by modifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function. For example,
    we could use Manhattan distance by changing the line at ❶ to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数来替换为替代的距离函数。例如，我们可以通过将
    ❶ 处的代码修改为以下内容来使用曼哈顿距离：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can write the code for constructing the graph from spatial points using
    a nested pair of loops:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一对嵌套循环来编写构建图的代码，该图是由空间点构成的：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code allocates a graph with one node for each point in the dataset, then
    uses a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    to iterate through each pair of points. For each pair, the code computes the distance
    between the points using the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> class
    and inserts an undirected edge with the corresponding weight into the graph. Once
    all edges are added, the function returns the completed graph.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码为数据集中的每个点分配一个节点，然后使用一对 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历每一对点。对于每一对，代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp>
    类中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数计算两点之间的距离，并在图中插入带有相应权重的无向边。所有边添加完后，函数返回已完成的图。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Preconditions</samp>
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">前提条件</samp>
- en: In [Chapter 9](chapter9.xhtml) we considered the problem of topological sort—ordering
    nodes according to the graph’s directed edges. [Figure A-5](#figA-5) shows an
    example of such an ordering, where each node is ordered along the horizontal direction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](chapter9.xhtml)中，我们讨论了拓扑排序的问题——根据图的有向边对节点进行排序。[图A-5](#figA-5)展示了这种排序的一个例子，其中每个节点沿水平方向进行排序。
- en: '![A graph with six nodes and directed edges (0, 1), (0, 2), (1, 2), (2, 5),
    (1, 4), (3, 4), and (4, 5).](../images/f0a005.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![一个有六个节点和有向边（0, 1）、（0, 2）、（1, 2）、（2, 5）、（1, 4）、（3, 4）和（4, 5）的图。](../images/f0a005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-5: Six nodes ordered
    by their relative dependencies</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图A-5：根据节点之间的相对依赖关系排序的六个节点</samp>
- en: Topological sort allows us to list steps for an instruction manual, plan for
    courses with prerequisites, or compute the order in which to compile parts of
    a program. Each of these problems required us to specify the dependencies between
    nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序使我们能够列出操作手册的步骤、规划具有先决条件的课程，或者计算编译程序各部分的顺序。这些问题都要求我们明确节点之间的依赖关系。
- en: 'We define a simple function to construct a graph from a dictionary of preconditions.
    Each entry in the dictionary maps a node to a list of its dependencies. For example,
    the graph in [Figure A-5](#figA-5) would be represented as:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的函数，从一个前置条件的字典构建图。字典中的每个条目将一个节点映射到它的依赖列表。例如，[图 A-5](#figA-5)中的图将表示为：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">{0: [], 1: [0], 2: [0, 1], 3:
    [], 4: [1, 3],</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5: [2, 4]}</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">{0: [], 1: [0], 2: [0, 1], 3:
    [], 4: [1, 3],</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5: [2, 4]}</samp>'
- en: Nodes without a dependency, such as nodes 0 and 3, are represented using an
    empty list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有依赖的节点，例如节点 0 和 3，用一个空列表表示。
- en: 'The code for constructing a graph from dependencies consists of loops that
    iterate through each node, as well as each node’s dependencies:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从依赖关系构建图的代码由遍历每个节点的循环组成，同时还遍历每个节点的依赖项：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code starts by allocating an empty directed graph. It fills the graph by
    iterating over each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dependencies</samp>
    list with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. For
    each entry, even those with an empty list of priors, the code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by
    _name()</samp> to look up and potentially insert a new node. This code is sufficient
    to fill in the graph’s nodes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先分配一个空的有向图。它通过遍历 `<samp class="SANS_TheSansMonoCd_W5Regular_11">dependencies</samp>`
    列表中的每个键，使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环来填充图。对于每个条目，即使是那些没有前置依赖的条目，代码也会使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>` 来查找并可能插入一个新节点。此代码足以填充图的节点。
- en: To fill in the edges, the code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate over each node’s dependency list. The dependency’s index is retrieved
    (and a new node may be inserted) using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>.
    The code then inserts the edge *from* the dependency node *to* the current node.
    Since we are interested only in the ordering, the code uses a default <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    weight for all edges. The code concludes by returning the constructed graph.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充边，代码使用第二个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环遍历每个节点的依赖列表。通过
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>` 获取依赖项的索引（并可能插入一个新节点）。然后，代码插入从依赖节点
    *到* 当前节点的边。由于我们只关心排序，代码对所有边使用默认的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>`
    权重。代码最后返回构建的图。
