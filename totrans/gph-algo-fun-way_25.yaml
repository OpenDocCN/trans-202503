- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONSTRUCTING
    GRAPHS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This book has covered a range of algorithms that operate over graphs. To apply
    these algorithms to real-world problems, we need a mechanism for programmatically
    creating new graphs or loading them from files.
  prefs: []
  type: TYPE_NORMAL
- en: While the graph creation functions in [Chapter 1](chapter1.xhtml) such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    provide a full mechanism for defining graphs, it would be unrealistic to hard-code
    the creation of each graph. Beyond the tedium of listing out hundreds or thousands
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> statements,
    such an approach is error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix we introduce a variety of simple mechanisms for creating graphs
    and loading them from files. As with previous chapters, we optimize for understandability
    instead of storage size or computational efficiency. This means that some of the
    input formats we use, such as comma-separated values, will be simplistic. However,
    these formats are perfect for demonstrating what information we need to consider
    and how we can programmatically manipulate it to form a graph. Readers can build
    off of these approaches to construct formats optimized for their own applications.
  prefs: []
  type: TYPE_NORMAL
- en: This appendix makes use of Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    library to facilitate loading and parsing files. We encourage readers to explore
    the vast ecosystem of more specialized libraries that might further simplify their
    code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Constructing Graphs from Edges</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure
    we’ve used since [Chapter 1](chapter1.xhtml) relies upon a constructor that creates
    an initial graph with no edges. The user can add edges to the graph using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function. In
    this section, we’ll automate this flow to build graphs from lists of edges.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a new graph from a given list of edges, we extend this functionality
    to read from and write to edge files. Along the way, we tackle the problem of
    nodes being specified by a generic text label rather than a node index.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inserting Edges from
    a List</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a graph from a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the edge list, the code takes in the number of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp>)
    and whether the graph is undirected (<samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>).
    It creates an initial graph structure with the correct number of nodes and undirected
    setting, then loops over each edge and inserts it into the graph. If the edges
    are undirected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class
    inserts a directed edge in each direction.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we could compute the number of nodes directly from the edge list
    by tracking the largest node index seen. However, this approach does not allow
    for graphs with fully disconnected nodes, because their index would never appear
    in the edge list and the resulting graph might miss later nodes. Instead, the
    code takes <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> as an
    input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-1](#figA-1) shows an example graph construction where the following
    directed edges are inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[Edge(0,1,1.0), Edge(1,3,10.0),
    Edge(2,4,5.0), Edge(3,1,2.0), Edge(1,2,3.0)]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-1(a)](#figA-1) shows the graph after the first node is inserted.
    Each subfigure shows the state of the graph after one iteration of the code’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Six subfigures show a five-node graph with an increasing number of edges.
    In (A), there are no edges. In (B), the edge (0, 1) has been added.](../images/f0a001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The steps of adding
    edges to a graph with five nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_graph_from_edges()</samp>
    function in conjunction with algorithms that return lists of edges, such as the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">randomized_kruskals()</samp> algorithm
    in [Chapter 10](chapter10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loading Edge Lists
    from Files</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A natural approach to constructing graphs is to load the graph directly from
    a file. While there are myriad different formats we could use to store a graph’s
    representation, we’ll start with one of the simplest approaches: storing a graph
    as a file of comma-separated values (CSV). Each row indicates a single edge listing
    the originating node as a string label, the destination node as a string label,
    and an optional floating-point weight. Unconnected nodes are listed alone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this CSV format, we can encode the undirected graph shown in [Figure
    A-2](#figA-2) with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: a,b
  prefs: []
  type: TYPE_NORMAL
- en: b,c,10.0
  prefs: []
  type: TYPE_NORMAL
- en: d,e,5.0
  prefs: []
  type: TYPE_NORMAL
- en: The data define a graph with five nodes a, b, c, d, and e, and three edges.
    Two of the edges are given explicit weights and the third uses a default value
    of 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and undirected edges (a, b), (b, c), and (d, e).](../images/f0a002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A graph with five
    nodes and three weighted edges</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can extend this format to account for fully disconnected nodes, which will
    not appear in any edge, by allowing rows with a single entry. This single entry
    simply indicates the node exists so that the program includes it in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this general format to encode a vast number of real-world phenomena.
    For example, we could use a single file to represent note-passing behavior in
    a classroom. Each node represents a student. Each row provides new information
    about the class (graph). A row can contain a single name to indicate the existence
    of a student (node). Alternatively, a row can indicate the directed note-passing
    behavior between a pair of students and includes <samp class="SANS_TheSansMonoCd_W5Regular_11">person1</samp>*,*
    <samp class="SANS_TheSansMonoCd_W5Regular_11">person2</samp>*,* <samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>
    to indicate how many times (represented by weight) person 1 passed a note to person
    2.
  prefs: []
  type: TYPE_NORMAL
- en: The code to read such a CSV file makes use of Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    function to read the file and the csv package (which requires importing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>) to parse each row, as shown
    in Listing A-1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: Loading a graph
    from a CSV file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by creating the necessary data structures—an empty graph (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>) and an empty dictionary (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>) that will map the
    string names to the corresponding node index.
  prefs: []
  type: TYPE_NORMAL
- en: The code then opens the file and parses it using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp>
    ❶. It iterates through every row in the file, reading up to three entries ❷. For
    each row, it extracts the name of the node from the first entry. Since the code
    reads in names, it needs to map those names to a corresponding index. If the node
    is in the graph already, the code can look it up from the <samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>
    dictionary. Otherwise, it has found a node that is not yet in the graph and must
    insert this node into the graph and the name into the dictionary. If the row has
    only a single entry, the function skips the rest of the logic and continues to
    the next row.
  prefs: []
  type: TYPE_NORMAL
- en: If the row has a second entry, however, that row specifies an edge ❸. The code
    extracts the second node’s name. Again, it checks whether the node is in the graph
    and, if not, inserts it. The code checks for a third entry in the row, indicating
    a weight ❹. If no weight is provided, the code uses a default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
    Finally, the code uses the combination of the two node indices and the weight
    to insert a new edge into the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The code continues row by row in the CSV until it has read the entire file.
    At that point it returns the final graph. The file is closed automatically as
    the code exits the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major complexities in this code is mapping the nodes’ text strings
    to their indices. In theory, we could restrict our loader function to require
    that files supply each node’s integer index. While this would remove the need
    for a mapping, it greatly reduces the usability. Anytime we want to load in a
    new graph, we must first construct a mapping from name to index and convert the
    file. In a later section, we will look at how to incorporate this common operation
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Saving Edge Lists
    to Files</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the same comma-separated values format to save our favorite graphs.
    Since most of the graphs we have considered have not used named nodes, we will
    use each node’s integer index as its name in our CSV file. However, we still face
    the problem that the code in Listing A-1 assigns node indices as they are encountered.
    Ideally, we would like node 5 to stay node 5 when reloaded, regardless of the
    order in which the code encounters it in the edge list.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple potential solutions to this problem. We could forgo names
    altogether and just store the integer node indices in the CSV, modifying Listing
    A-1 to read the node names directly as integer indices. Alternatively, we can
    output one node name per row in order at the start of the CSV file to indicate
    their existence. This will ensure that the first node is mapped to index 0, the
    second to index 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following code, we use this second approach to stay consistent with
    Listing A-1\. This code will work for an integer-based reader as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code opens the file and writes to it using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.writer</samp>
    ❶. It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to
    iterate through each node, writing one node index per row ❷. This ensures that
    all nodes are captured in the CSV even if they are not part of any edges. Finally,
    a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops iterate
    through each edge in the graph and write out three values (origin node, destination
    node, and weight) representing the edge ❸. The file closes automatically as the
    code exits the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Inserting Nodes by Name</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A significant portion of the code in Listing A-1 consists of handling the mapping
    of a node’s name to its index. We look up each name string in the <samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>
    dictionary to get the index. If the name is not in the dictionary, we need to
    insert a new node and create the corresponding dictionary entry mapping the name
    to the new index. Depending on how you reference nodes in your program, this can
    be a common problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify working with named nodes, we can incorporate this logic into the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class itself. We need
    to make two changes. First, we add the creation of an empty dictionary to the
    initialization function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will use this dictionary whenever we need to map a name to an index.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we add a function to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class that performs both the lookup and, if necessary, the insertion, as shown
    in Listing A-2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Adding named nodes
    to a graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by determining if this node already exists in the graph by checking
    whether its name is in the mapping. If not, the graph inserts the node into the
    graph using the original <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp>
    function. It also inserts the name into the index map. The function finishes by
    returning the node’s index.
  prefs: []
  type: TYPE_NORMAL
- en: We can picture this function in the context of a lazy teacher creating a seating
    chart. On the first day, the teacher allows the students to pick their own seats
    but does not bother to write down who is sitting where. Their seating chart is
    initially empty. As the class progresses, students raise their hands with questions.
    Each time this happens, the teacher glances down at their seating chart. If the
    student’s name is listed, the teacher uses it. Otherwise, they peer at the student
    and, with a complete lack of tact, ask, “Who are you?” When the student finishes
    rolling their eyes and responding, the teacher adds the student to the seating
    chart. The chart progressively gets filled in as the students are acknowledged.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these helper functions to rewrite the CSV reader code from Listing
    A-1 more compactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code follows the same flow as Listing A-1 but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by
    _name()</samp> to do both the node mapping and lookup for the first ❶ and second
    nodes ❷ in each row.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Co-occurrences</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Co-occurrence graphs* represent which pairs of entities have previously co-occurred.
    In biology, they can be used to study interactions, such as which genes are often
    present together or which microbes interact. In sociology, they can model gatherings
    of groups or coauthorship of academic publications. And in pop culture, they can
    help answer critical questions about which movie stars appeared on-screen together,
    as discussed in [Chapter 2](chapter2.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty with ingesting co-occurrence data is that it usually consists
    of a list of sets instead of pairwise interactions. Our favorite online movie
    database probably does not list each pairing of movie stars from last summer’s
    smash hit. Instead, it provides a single list labeled *cast* that includes everyone
    who appeared in the movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when reviewing all the local theater company’s recent productions,
    we might find the following cast lists:'
  prefs: []
  type: TYPE_NORMAL
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>)
  prefs: []
  type: TYPE_NORMAL
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)
  prefs: []
  type: TYPE_NORMAL
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>)
  prefs: []
  type: TYPE_NORMAL
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>)
  prefs: []
  type: TYPE_NORMAL
- en: (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)
  prefs: []
  type: TYPE_NORMAL
- en: Using a single cast list, we can easily see that <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    has appeared onstage with <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>.
    However, if we are interested in more complex questions such as how many degrees
    of separation there are between <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>, we need to construct
    a more comprehensive picture. [Figure A-3](#figA-3) shows the co-occurrence graph
    based on these plays.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with 8 nodes and 12 edges. Node A has edges to nodes B, C, and D.](../images/f0a003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: An undirected graph
    with eight nodes representing the co-occurrence of actors in plays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To make the model more powerful, we can use edge weights to track how often
    two nodes have co-occurred. For example, Alice and Bob might have a stronger acting
    connection after appearing together in 10 different plays, while Diane’s weaker
    connection to Alice comes from sharing the stage a single time. If you are looking
    for an introduction to the world-famous Alice, it is better to use the stronger
    connection through Bob.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend the approach used to load graphs from CSVs to construct pairwise
    graphs from arbitrary lists. Instead of expecting at most three entries per row,
    we allow all co-occurring entries to be listed on a single row. The code then
    determines the pairwise edges implied by each list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with the earlier CSV reader, the code starts by creating an empty graph,
    opening the file, and parsing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp>.
    This time, the code restricts the graph to being undirected, as there is no implied
    directionality in these co-occurrence edges. The code also does not maintain a
    dictionary of names, but rather uses the helper function from Listing A-2 to insert
    new nodes and retrieve each node’s index.
  prefs: []
  type: TYPE_NORMAL
- en: The code iterates through each row using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. For each row, it uses another pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to iterate over all unique pairs of entities on each row. It looks up the
    nodes’ indices using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>
    function, inserting new nodes as needed. Before creating an edge from the pair,
    the code checks whether the edge exists ❶. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    to allow <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to be returned
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function.
    If the edge already exists, the code retrieves its current weight and increments
    it by 1, then inserts a new edge with the updated weight ❷. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    overwrites the existing edges when a duplicate is inserted, the code effectively
    updates the weights of existing edges.
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous CSV reader in Listing A-1, the code continues row by row
    until it has read the entire file. At that point it returns the final graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Spatial Points</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using graphs to model path planning or other physical problems, we often
    need to construct a graph from a series of spatial data points. We can do this
    by creating a graph containing one node for each spatial point and one edge between
    *every pair* of points.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-4](#figA-4) shows an example of such a representation. [Figure A-4(a)](#figA-4)
    shows five two-dimensional points: (0, 0), (1, 0), (1.2, 1), (1.8, 1), and (0.5,
    1.5). [Figure A-4(b)](#figA-4) shows the graph representation with the edge weights
    capturing the distance between points.'
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) Shows Five Points Plotted on Cartesian X and Y Axes. (B) Shows the Points
    with the 10 Pairwise Edges, Each Labeled with the Pair’s Distance.](../images/f0a004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-4: A set of two-dimensional
    spatial points (a) and the corresponding graph representation (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a helper class to store the spatial points and compute
    the distance between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> class
    is not required, it allows us to easily swap in higher-dimensional points or alternative
    distance functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function computes the Euclidean distance in two-dimensional space. Note that we
    will need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    to use the square root function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can substitute in alternative distance functions by modifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function. For example,
    we could use Manhattan distance by changing the line at ❶ to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write the code for constructing the graph from spatial points using
    a nested pair of loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code allocates a graph with one node for each point in the dataset, then
    uses a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    to iterate through each pair of points. For each pair, the code computes the distance
    between the points using the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> class
    and inserts an undirected edge with the corresponding weight into the graph. Once
    all edges are added, the function returns the completed graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Preconditions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 9](chapter9.xhtml) we considered the problem of topological sort—ordering
    nodes according to the graph’s directed edges. [Figure A-5](#figA-5) shows an
    example of such an ordering, where each node is ordered along the horizontal direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with six nodes and directed edges (0, 1), (0, 2), (1, 2), (2, 5),
    (1, 4), (3, 4), and (4, 5).](../images/f0a005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-5: Six nodes ordered
    by their relative dependencies</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Topological sort allows us to list steps for an instruction manual, plan for
    courses with prerequisites, or compute the order in which to compile parts of
    a program. Each of these problems required us to specify the dependencies between
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a simple function to construct a graph from a dictionary of preconditions.
    Each entry in the dictionary maps a node to a list of its dependencies. For example,
    the graph in [Figure A-5](#figA-5) would be represented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">{0: [], 1: [0], 2: [0, 1], 3:
    [], 4: [1, 3],</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5: [2, 4]}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes without a dependency, such as nodes 0 and 3, are represented using an
    empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for constructing a graph from dependencies consists of loops that
    iterate through each node, as well as each node’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by allocating an empty directed graph. It fills the graph by
    iterating over each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dependencies</samp>
    list with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. For
    each entry, even those with an empty list of priors, the code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by
    _name()</samp> to look up and potentially insert a new node. This code is sufficient
    to fill in the graph’s nodes.
  prefs: []
  type: TYPE_NORMAL
- en: To fill in the edges, the code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate over each node’s dependency list. The dependency’s index is retrieved
    (and a new node may be inserted) using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>.
    The code then inserts the edge *from* the dependency node *to* the current node.
    Since we are interested only in the ordering, the code uses a default <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    weight for all edges. The code concludes by returning the constructed graph.
  prefs: []
  type: TYPE_NORMAL
