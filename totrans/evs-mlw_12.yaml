- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ANTI-DISASSEMBLY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">反汇编防护</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Because disassemblers break down binary files into assembly code based on their
    own (often very complex) algorithms, there’s some room for error. Malware authors
    are aware of this vulnerability and can actively exploit it. They may also attempt
    to obfuscate the malware’s control flow or string and API function call references,
    making the code especially difficult to navigate statically. These are examples
    of *anti-disassembly* techniques, or ways in which malware complicates the process
    of reverse engineering code with a disassembler. In this chapter, we’ll look at
    these tactics in depth and what malware analysts can do to address them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反汇编器基于自己的（通常非常复杂的）算法将二进制文件分解为汇编代码，因此有一定的误差空间。恶意软件作者意识到这一漏洞，并能够积极利用它。他们可能还会试图模糊恶意软件的控制流、字符串和
    API 函数调用引用，使得代码在静态分析时特别难以理解。这些都是 *反汇编防护* 技术的例子，或者说是恶意软件通过反汇编器逆向工程代码时所采取的复杂化手段。在本章中，我们将深入探讨这些策略以及恶意软件分析师如何应对这些问题。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Breaking Disassemblers</samp>'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">破坏反汇编器</samp>'
- en: Disassemblers interpret a file based on their own hardcoded logic and assumptions,
    which means that they can interpret bytes in different and sometimes problematic
    ways. Code could be incorrectly disassembled into data, or vice versa, and bytes
    might be added to the wrong instructions, producing completely new and erroneous
    instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编器基于自己硬编码的逻辑和假设来解释文件，这意味着它们可能会以不同且有时是问题重重的方式解读字节。代码可能会被错误地反汇编为数据，或者反之，字节也可能会被加到错误的指令上，从而产生完全新的错误指令。
- en: 'As an example, the bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">e8 8c
    45 0a 90</samp> can be dissembled into a call instruction. Removing the first
    byte (<samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>) would result in
    a completely different disassembled instruction. In this common anti-disassembly
    approach, known as the *rogue byte* technique, rogue bytes are inserted into the
    malware to confuse the disassembly process. Consider, for example, the following
    code snippet:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">e8 8c 45 0a 90</samp>
    可以被反汇编为一个调用指令。如果去掉第一个字节（<samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>），将会得到一个完全不同的反汇编指令。在这种常见的反汇编防护方法中，称为
    *流氓字节* 技术，恶意软件中插入流氓字节以混淆反汇编过程。例如，考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here you can see several disassembled instructions in the right column, the
    bytes that make up those instructions in the middle column, and the address offset
    in the left column. These disassembled instructions don’t make much sense. For
    example, there’s a jump-if-zero (<samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>)
    instruction with a target of <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402109</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 1</samp>. This jump will always
    occur because the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    prior to the <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> instruction
    sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    but the code jumps to the *second* byte of the next instruction (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">8b</samp>).
    The code also includes a call instruction to an address that doesn’t even exist
    in this executable, since our executable is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00402xxx</samp>
    address range, not the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x900xxxxx</samp>
    range. Let’s take a closer look.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧列中，你可以看到几个反汇编指令，构成这些指令的字节在中间列，地址偏移量则在左侧列。这些反汇编指令没有太大意义。例如，有一个条件跳转指令（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>），它的目标是 <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402109</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 1</samp>。由于在 <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>
    指令之前有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令将 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，这个跳转将始终发生，但代码会跳转到下一个指令的
    *第二个* 字节（字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">8b</samp>）。代码中还包含一个调用指令，指向一个在此可执行文件中根本不存在的地址，因为我们的可执行文件位于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00402xxx</samp> 地址范围内，而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x900xxxxx</samp> 范围内。让我们更仔细地看看。
- en: 'As [Chapter 3](chapter3.xhtml) explained, a disassembler doesn’t always know
    how to differentiate code from data. This means that when it converts bytes to
    code, that code may in reality be data, or vice versa. The bytes that make up
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">call 0x900a4590</samp> instruction
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">e8 8b 45 0a 90</samp>. The first
    byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>, represents the
    call instruction in the x86 assembly instruction set. If we take out this byte,
    we’re left with <samp class="SANS_TheSansMonoCd_W5Regular_11">8b 45 0a 90</samp>.
    This series of bytes in x86 assembly is equivalent to the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第 3 章](chapter3.xhtml)所解释的，反汇编器并不总是能区分代码和数据。这意味着，当它将字节转换为代码时，这段代码实际上可能是数据，反之亦然。构成
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call 0x900a4590</samp> 指令的字节是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">e8 8b 45 0a 90</samp>。第一个字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>
    在 x86 汇编指令集中表示调用指令。如果我们去掉这个字节，剩下的就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">8b
    45 0a 90</samp>。这串字节在 x86 汇编中等价于以下代码：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we have a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    (to move the value stored on the stack at <samp class="SANS_TheSansMonoCd_W5Regular_11">ebp+10</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>), followed by a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instruction. This code makes
    a lot more sense than our original call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    0x900a4590</samp>). Thus, it seems that the first byte (<samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>)
    is a rogue byte, added to the code simply to confuse disassemblers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令（将存储在栈上的值从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ebp+10</samp> 移动到 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>），后面跟着一条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> 指令。与我们最初的调用指令 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">call 0x900a4590</samp>) 相比，这段代码更有意义。因此，似乎第一个字节
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>) 是一个伪造的字节，它被添加到代码中只是为了混淆反汇编工具。
- en: You can deal with this by overriding incorrect code or data. In IDA, you can
    hit the C and D keys (C for converting data to code and D for converting code
    to data). In Ghidra, it’s the opposite, confusingly enough; press C for converting
    code to data (C stands for “clear code bytes,” in this case) and D for converting
    data to code (D stands for “disassemble”).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过覆盖不正确的代码或数据来处理这个问题。在 IDA 中，你可以按 C 和 D 键（C 用于将数据转换为代码，D 用于将代码转换为数据）。在 Ghidra
    中，恰恰相反，令人困惑的是；按 C 进行将代码转换为数据（在此情况下 C 代表“清除代码字节”），按 D 进行将数据转换为代码（D 代表“反汇编”）。
- en: 'If you select the bogus call instruction in IDA and press D, the instruction
    is broken into data, as shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 IDA 中选择这个虚假的调用指令并按 D，这条指令会被拆解成数据，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that what once was code is now data bytes, starting at ❶. Now, if you
    select the byte values starting at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0040210A</samp>
    (taking care not to select the <samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>
    byte) and continuing until <samp class="SANS_TheSansMonoCd_W5Regular_11">0040210D</samp>,
    then press C to convert this to code, you get the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到曾经是代码的部分现在变成了数据字节，从❶开始。现在，如果你选择从偏移量 <samp class="SANS_TheSansMonoCd_W5Regular_11">0040210A</samp>
    开始的字节值（小心不要选择 <samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp> 字节），一直选择到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0040210D</samp>，然后按 C 将其转换为代码，你将得到以下内容：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The malware moves <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> (in order to zero-out
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>) and then uses a condition
    jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>); as noted earlier,
    the code will always take this jump. However, now the code jumps right over the
    rogue byte (<samp class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>) and executes
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instructions instead. This malware sample cleverly inserted the rogue byte in
    order to trick the disassembler into thinking that it was part of the original
    call instruction!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将<samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>移动到<samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>（为了将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>清零），然后使用条件跳转（<samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>）；如前所述，代码将始终执行这个跳转。然而，现在代码跳过了那个恶意字节（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e8</samp>），而执行了<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令。这个恶意软件样本巧妙地插入了恶意字节，以欺骗反汇编器，使其认为它是原始调用指令的一部分！
- en: 'This is a fairly simple example of an anti-disassembly method, but it’s a common
    one. This presents a challenge for both disassemblers and reverse engineers. When
    you encounter situations like this, in which code is simply incorrect or doesn’t
    make sense, try manually converting the code to data bytes or some of the bytes
    into code. It may help you fix up the code so that you can better understand it.  ###
    <samp class="SANS_Futura_Std_Bold_B_11">Control Flow Obfuscation</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的反反汇编方法示例，但它是常见的。这给反汇编器和逆向工程师带来了挑战。当你遇到像这样代码明显错误或没有意义的情况时，可以尝试手动将代码转换为数据字节，或者将某些字节转换为代码。这可能帮助你修复代码，从而更好地理解它。###
    <samp class="SANS_Futura_Std_Bold_B_11">控制流混淆</samp>
- en: The next anti-disassembly method we’ll look at is *control flow obfuscation*,
    or adding unnecessary complexity to the malware code, making it much more difficult
    to analyze statically. This type of obfuscation can also flummox disassemblers,
    which may fail to properly disassemble the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的反反汇编方法是*控制流混淆*，即向恶意软件代码中添加不必要的复杂性，使其更加难以静态分析。这种类型的混淆也会让反汇编器感到困惑，可能无法正确反汇编代码。
- en: To add this type of obfuscation, malware authors use specialized code obfuscators
    designed specifically for this purpose or malware packers, which we’ll discuss
    in detail in [Chapter 17](chapter17.xhtml). Let’s dig into some of the common
    methods used to obfuscate control flow. At the end of this section, we’ll discuss
    a few general strategies to deal with these tactics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加这种类型的混淆，恶意软件作者使用专门为此目的设计的代码混淆器，或恶意软件打包器，我们将在[第17章](chapter17.xhtml)中详细讨论。让我们深入了解一些常见的控制流混淆方法。在本节的最后，我们将讨论几种应对这些策略的一般方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unnecessary Jumps</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">不必要的跳转</samp>
- en: Malware authors may add unnecessary jump statements to break up the malware’s
    code into smaller blocks (see [Figure 9-1](chapter9.xhtml#fig9-1)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者可能会添加不必要的跳转语句，将恶意软件的代码分割成更小的块（见[图9-1](chapter9.xhtml#fig9-1)）。
- en: '![](../images/fig9-1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Unnecessary jump
    instructions</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-1：不必要的跳转指令</samp>
- en: The code in [Figure 9-1](chapter9.xhtml#fig9-1) was once a single block, but
    an obfuscator has broken it into chunks, with each block connecting to the next
    with a jump statement. Functionally, the code is the same, but now reverse engineers
    will have more difficulty understanding and following it. This example is quite
    basic, but obfuscators can add a nearly infinite amount of complexity to code,
    as you’ll see in the next few sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](chapter9.xhtml#fig9-1)中的代码曾经是一个单一块，但混淆器将其分成了多个块，每个块通过跳转语句连接到下一个块。从功能上讲，代码是相同的，但现在逆向工程师将更难理解和跟踪它。这个例子相当基础，但混淆器可以使代码变得极为复杂，正如你在接下来的几节中将看到的那样。'
- en: 'Obfuscators can also make code jump forward and backward frequently in order
    to make it harder to follow sequentially, as in this example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆器还可以使代码频繁地前后跳转，以增加顺序跟踪的难度，正如在这个例子中所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code jumps around to different areas simply for the sake of confusion.
    It first jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402B20</samp>,
    then back up to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402A30</samp>,
    and then back down to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402B65</samp>,
    creating a hard-to-follow code flow logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会跳转到不同的区域，仅仅是为了制造混淆。它首先跳转到<samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402B20</samp>，然后回到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">loc_402A30</samp>，再回到<samp class="SANS_TheSansMonoCd_W5Regular_11">loc_402B65</samp>，从而创建一个难以跟踪的代码流逻辑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unnecessary Code</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">不必要的代码</samp>
- en: Malware authors can add other types of unnecessary code to their malware. For
    example, they might create copies of code blocks or functions that are effectively
    the same, or at least very similar, so that the code can then be executed interchangeably,
    leading to the same final block of code, as shown in [Figure 9-2](chapter9.xhtml#fig9-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者可以向其恶意软件中添加其他类型的不必要代码。例如，他们可能创建代码块或函数的副本，这些副本实际上是相同的，或者至少非常相似，以便代码可以互换执行，从而导致相同的最终代码块，如[图9-2](chapter9.xhtml#fig9-2)所示。
- en: '![](../images/fig9-2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Interchangeable
    code blocks</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-2：可互换的代码块</samp>
- en: This doesn’t affect the malware’s behavior but creates complexity for reverse
    engineers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会影响恶意软件的行为，但会增加逆向工程师的复杂性。
- en: 'Alternatively, malware authors and obfuscators can add dummy code that will
    never be executed and exists only to confuse analysts, waste CPU cycles, and slow
    down the analysis process. This code could be anything, so it’s difficult to provide
    concrete examples of what it might look like, but this snippet demonstrates the
    technique:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，恶意软件作者和混淆器可以添加永远不会被执行的虚假代码，这些代码仅存在于混淆分析人员、浪费CPU周期并拖慢分析过程。由于这些代码的具体内容可以是任何形式的，因此很难提供具体示例，但以下代码片段演示了这一技巧：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is simply incrementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>
    register by 1, pushing this value to the stack, decrementing it by 1, and then
    pushing that value to the stack. It quite obviously serves no valid purpose.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是将<samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>寄存器增加1，将该值推入栈中，再减少1，并将该值推入栈中。显然，这段代码没有实际的有效目的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Control Flow Flattening</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">控制流平坦化</samp>
- en: '*Control flow flattening* is a method of obfuscating control flow by compressing
    a sequence of conditional code blocks into a single block. This is usually accomplished
    via switch statements that direct control flow. [Figure 9-3](chapter9.xhtml#fig9-3)
    shows a program before control flattening has occurred.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制流平坦化*是一种通过将一系列条件代码块压缩为一个块来混淆控制流的方法。通常是通过switch语句来实现控制流的引导。[图9-3](chapter9.xhtml#fig9-3)展示了应用控制流平坦化前的程序。'
- en: '![](../images/fig9-3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: A program before
    control flow flattening is applied</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-3：应用控制流平坦化前的程序</samp>
- en: This program represents normal, unobfuscated code. In the code block labeled
    ❶, there’s a conditional statement that will jump to one of two locations (code
    block ❷ or ❸). If this program were run through a control flow–flattening algorithm,
    it might end up looking more like [Figure 9-4](chapter9.xhtml#fig9-4).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序代表正常的、未混淆的代码。在标记为❶的代码块中，有一个条件语句会跳转到两个位置之一（代码块❷或❸）。如果该程序通过控制流平坦化算法处理后，它可能看起来更像[图9-4](chapter9.xhtml#fig9-4)。
- en: '![](../images/fig9-4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: A program after
    control flow flattening is applied</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-4：应用控制流平坦化后的程序</samp>
- en: In [Figure 9-3](chapter9.xhtml#fig9-3), code block ❶ was responsible for the
    conditional statement that led to the jump to either code block ❷ or ❸. In the
    flattened code, a *central dispatch* code block ❶ is responsible for the conditional
    statement but also keeps track of where the code should “flow” next. After the
    dispatcher directs the control flow to a block of code, control is returned to
    the dispatcher, which directs the control flow further. The dispatcher adds complexity
    to the disassembled code, making it more difficult for an analyst to understand
    its purpose and where execution will flow next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图9-3](chapter9.xhtml#fig9-3)中，代码块❶负责条件语句，决定跳转到代码块❷或❸。在扁平化的代码中，一个*中央调度*代码块❶负责条件语句，同时跟踪代码接下来应该“流向”哪里。调度器将控制流引导到一个代码块后，控制会返回到调度器，由它进一步引导控制流。调度器增加了反汇编代码的复杂性，使得分析师更难理解代码的目的以及接下来执行的路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Opaque Predicates</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">不透明谓词</samp>
- en: An *opaque predicate* (see [Figure 9-5](chapter9.xhtml#fig9-5)) is a value that
    is known to the program’s author but not to the program or disassembler at runtime.
    The program’s creator (in our case, the malware author) knows that a certain expression
    will result in a specific value, for example, but neither we as reverse engineers
    nor our disassembler tools know this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*不透明谓词*（见[图9-5](chapter9.xhtml#fig9-5)）是一个在程序运行时对程序或反汇编工具不可知，但对程序作者已知的值。程序的创建者（在我们这个例子中，是恶意软件作者）知道某个表达式会产生特定的值，例如，但我们作为反向工程师或我们的反汇编工具对此一无所知。
- en: '![](../images/fig9-5.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: An opaque predicate
    in action</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-5：不透明谓词的实际应用</samp>
- en: This code can take one of two paths, determined by the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    (the opaque predicate). The malware author already knows that the program will
    take the branch to the right, but the analyst and the disassembler must manually
    analyze the logic to learn this. Obviously, this is a simplified example that
    almost anyone could decipher. However, malware authors can make an opaque predicate
    infinitely complex, for example, by calculating complicated mathematical functions
    at runtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以根据表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>（不透明谓词）决定走哪条路径。恶意软件作者已经知道程序将选择右侧分支，但分析师和反汇编器必须手动分析逻辑才能得出这一结论。显然，这是一个简化的例子，几乎任何人都能破译它。然而，恶意软件作者可以将不透明谓词设计得极其复杂，例如，在运行时计算复杂的数学函数。
- en: This technique can also be combined with those previously mentioned, such as
    adding unnecessary code. The malware author could include a large amount of garbage
    code in the left branch that will never be executed. The reverse engineer must
    understand the opaque predicate before analyzing the rest of the program to avoid
    wasting time on the garbage code. Opaque predicates are difficult to deal with
    and, as mentioned, can be as basic or complex as the malware author wishes. Often
    the best way to deal with them is to step through the malware in a debugger that
    will help reveal the true control flow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也可以与之前提到的技术结合使用，比如添加不必要的代码。恶意软件作者可以在左分支中加入大量永远不会被执行的垃圾代码。反向工程师必须在分析程序的其余部分之前理解不透明谓词，以避免在垃圾代码上浪费时间。不透明谓词很难处理，正如前面所提到的，它可以是恶意软件作者希望的任何复杂程度。通常，处理这些问题的最佳方法是通过调试器逐步执行恶意软件，这样可以帮助揭示真正的控制流。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Return Pointer Abuse</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">返回指针滥用</samp>
- en: 'Another way to obfuscate control flow is with return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>)
    instructions. For example, if a program executes Function B, once it reaches the
    end of that function, Function B will issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction to return to its parent function (Function A). Before Function B can
    return, though, the program needs to know where to return to. Therefore, the return
    address is pushed to the stack before Function B executes and is popped off the
    stack once the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction
    is executed. The following assembly code demonstrates this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆控制流的另一种方式是使用返回（<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>）指令。例如，如果一个程序执行函数B，当它到达该函数的末尾时，函数B会发出一个<stext
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>指令来返回到其父函数（函数A）。不过，在函数B返回之前，程序需要知道返回的地址在哪里。因此，返回地址会在函数B执行之前推送到栈中，并且在<stext
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>指令执行后从栈中弹出。下面的汇编代码演示了这一过程：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code issues a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction to push <samp class="SANS_TheSansMonoCd_W5Regular_11">returnAddress</samp>
    and then executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction, which will pop <samp class="SANS_TheSansMonoCd_W5Regular_11">returnAddress</samp>
    off the stack to return the program’s control flow to the parent function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码发出一个<stext class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令将<stext class="SANS_TheSansMonoCd_W5Regular_11">returnAddress</samp>推送到栈中，然后执行<stext
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>指令，这将从栈中弹出<stext class="SANS_TheSansMonoCd_W5Regular_11">returnAddress</samp>，将程序的控制流返回到父函数。
- en: Malware can abuse the way return pointers work to replicate a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> instruction. By pushing
    an address to the stack and then executing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction, the malware will force the control flow to execute the code at the
    new return address. This can confuse some disassemblers and generally makes following
    the code more difficult for the analyst as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以滥用返回指针的工作方式，以复制<stext class="SANS_TheSansMonoCd_W5Regular_11">call</samp>或<stext
    class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>指令。通过将一个地址推送到栈中，然后执行<stext class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>指令，恶意软件将迫使控制流执行新的返回地址处的代码。这可能会使一些反汇编工具感到困惑，并且通常会使分析人员跟踪代码变得更加困难。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SEH Handler Abuse</samp>
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SEH 处理程序滥用</samp>
- en: Malware can also take advantage of the *structured exception handler (SEH)*,
    which stores a series of addresses for the pieces of code responsible for handling
    exceptions in Windows applications. When the application raises an exception,
    its control flow transfers to one of the addresses stored in the SEH.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以利用*结构化异常处理程序（SEH）*，它存储了一系列地址，用于处理 Windows 应用程序中的异常。当应用程序触发异常时，它的控制流会转移到存储在
    SEH 中的一个地址。
- en: 'Malware can abuse the SEH by creating a new exception handler that points to
    malicious code. When the malware purposefully causes an exception in its code,
    the control flow will be transferred to code referenced in the exception handler.
    As a result, the analyst will need to know where the malware established the exception
    handler, as well as where the exception handler is pointing, in order to properly
    reverse engineer the code. Consider the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过创建一个指向恶意代码的新异常处理程序来滥用 SEH。当恶意软件故意在其代码中引发异常时，控制流将被转移到异常处理程序引用的代码。作为结果，分析人员需要知道恶意软件在哪里建立了异常处理程序，以及异常处理程序指向哪里，以便正确地逆向工程代码。考虑以下示例：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The focus of this code block is <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp>,
    which essentially points to the current exception handler. The malware replaces
    the default exception handler code with a pointer to malicious code (<samp class="SANS_TheSansMonoCd_W5Regular_11">evil.429D8C</samp>).
    Once the malware triggers an exception, the code’s control flow will be transferred
    to the address <samp class="SANS_TheSansMonoCd_W5Regular_11">evil.429D8C</samp>.
    As there are no <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions in use here, this control flow transfer can be difficult for the
    untrained eye to follow, so be on the lookout for code referencing <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp>.
    It’s also common to see this followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    instruction, which might indicate that the malware is attempting to cause a division-by-zero
    exception. We’ll discuss SEH and this specific code block further in [Chapter
    11](chapter11.xhtml).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块的重点是<samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp>，它基本上指向当前的异常处理程序。恶意软件将默认的异常处理程序代码替换为指向恶意代码的指针（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">evil.429D8C</samp>）。一旦恶意软件触发异常，代码的控制流将被转移到地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">evil.429D8C</samp>。由于此处没有使用<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令，这种控制流转移可能会让未经训练的眼睛难以跟踪，因此要留意引用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp>的代码。通常，这之后会看到一个<samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>指令，这可能表示恶意软件正在尝试引发一个除零异常。我们将在[第11章](chapter11.xhtml)中进一步讨论SEH和这个特定的代码块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Function Pointer Abuse</samp>
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">函数指针滥用</samp>
- en: 'As you’ve seen, a typical control flow transfer to a new function will involve
    a jump or call instruction. However, crafty malware can obscure these instructions
    by introducing function pointers like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，典型的控制流转移到一个新函数时，会涉及跳转（jump）或调用（call）指令。然而，狡猾的恶意软件可以通过引入函数指针来模糊这些指令，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This malware sample moves the offset address of the function <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_4511D5</samp>
    into a variable on the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">var_26</samp>.
    Then, it uses a call instruction and references the <samp class="SANS_TheSansMonoCd_W5Regular_11">var_26</samp>
    variable, which contains the address of the target function it wishes to call
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub_4511D5</samp>).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本将函数<samp class="SANS_TheSansMonoCd_W5Regular_11">sub_4511D5</samp>的偏移地址移入栈上的一个变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var_26</samp>中。然后，它使用一个调用指令并引用<samp class="SANS_TheSansMonoCd_W5Regular_11">var_26</samp>变量，该变量包含它希望调用的目标函数的地址（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub_4511D5</samp>）。
- en: This is a simple technique, but you can likely see how it might cause confusion
    during static analysis. To overcome this technique, you’d have to pinpoint the
    suspect call instruction and look backward through the code until you could identify
    what is stored in the referenced function pointer. Malware authors can make this
    obfuscation technique much more complex, however. For example, it can pass function
    offsets between different variables, which would make it very difficult for the
    analyst to identify the call’s target function. Analyzing code such as this in
    a debugger can better help you understand what is going on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的技术，但你可能会看到它在静态分析过程中可能引起混淆。要克服这种技术，你需要定位可疑的调用指令，并向后查找代码，直到你能够识别出被引用的函数指针中存储的内容。然而，恶意软件作者可以使这种混淆技术变得更加复杂。例如，它可以在不同的变量之间传递函数偏移量，这会使分析人员很难识别调用的目标函数。通过调试器分析此类代码可以帮助你更好地理解发生了什么。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Control Flow Obfuscation
    Countermeasures</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">控制流混淆对策</samp>
- en: 'This chapter has outlined only a few of the most common control flow obfuscation
    techniques, but you can overcome most of them with a few methods. First, you can
    use the same approach described in “Breaking Disassemblers” on [page 152](chapter9.xhtml#pg_152).
    If you spot code that is impossible or simply doesn’t make sense, try converting
    it into data. This may help you spot anomalies such as rogue bytes. The inverse
    is also true: if you spot data abnormalities or large sections of data in between
    code, try converting the data into code and reassessing it. This small tip may
    help you get around many simple anti-disassembly techniques.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只概述了几种最常见的控制流混淆技术，但你可以通过一些方法克服它们。首先，你可以使用在“破解反汇编器”中描述的相同方法，参见[第152页](chapter9.xhtml#pg_152)。如果你发现一些代码不可能或根本没有意义，尝试将其转化为数据。这可能帮助你发现异常情况，例如异常字节。反之亦然：如果你发现数据异常或大量数据出现在代码之间，尝试将数据转化为代码并重新评估。这一个小技巧可能帮助你绕过许多简单的反汇编技术。
- en: Second, stepping through the code in a debugger can make a world of difference;
    it usually makes understanding the code and control flow much easier. The debugger
    can be used alongside the disassembler, and you can set a debugger breakpoint
    on the addresses of code that you don’t entirely understand. If you spot a rogue
    byte in the code, for example, the debugger can help you understand what may be
    occurring. Some malware analysts like to use a disassembler with a built-in debugger
    (such as IDA Pro) for this very reason, but a separate disassembler and debugger
    will do just fine. I typically pair x64dbg with Ghidra or IDA.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，逐步调试代码可以带来很大的不同；它通常能使理解代码和控制流程变得更加容易。调试器可以与反汇编器一起使用，你可以在自己不完全理解的代码地址上设置调试器断点。例如，如果你在代码中发现一个异常字节，调试器可以帮助你理解可能发生的情况。一些恶意软件分析师喜欢使用带有内置调试器的反汇编器（如
    IDA Pro），就是为了这个原因，但分开的反汇编器和调试器也能做到这一点。我通常将 x64dbg 与 Ghidra 或 IDA 配合使用。
- en: Third, you can try to identify the obfuscator that was used on the malware.
    For example, tools such as Detect It Easy (DIE) and Exeinfo PE will attempt to
    identify possible obfuscators and packers (covered in [Chapter 17](chapter17.xhtml)).
    Once you’ve identified the obfuscator or packer, doing a bit of research on how
    it works may give you some insight into how you can reverse it, or there may even
    be a public deobfuscator available! Some tools attempt to generically deobfuscate
    code and remove some of the complexity, but in my experience they tend to not
    work very well and can leave holes in the code or misinterpret it. Finally, different
    disassemblers tend to disassemble code a bit differently. If you primarily use
    IDA, for example, give Ghidra or another disassembler a try and see if you get
    a result that’s easier to understand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可以尝试识别恶意软件所使用的混淆器。例如，工具如 Detect It Easy（DIE）和 Exeinfo PE 会尝试识别可能的混淆器和压缩工具（详见[第17章](chapter17.xhtml)）。一旦你识别出混淆器或压缩工具，研究它的工作原理可能会给你一些启示，帮助你反向破解，甚至可能找到现成的去混淆工具！一些工具试图通用地去混淆代码并移除部分复杂性，但根据我的经验，它们通常效果不佳，可能会留下漏洞或误解代码。最后，不同的反汇编器在反汇编代码时会有一些差异。例如，如果你主要使用
    IDA，可以尝试 Ghidra 或其他反汇编器，看看是否能获得更容易理解的结果。
- en: Ultimately, dealing with anti-disassembly requires knowledge and experience
    of the assembly language, and there’s no substitute for that. Learning assembly
    (x86, x64, or for whatever type of malware you’re reversing) and continuing to
    build that skill set will help you more quickly identify the anti-disassembly
    and code obfuscation techniques being employed by malware.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，应对反汇编防护需要对汇编语言的知识和经验，而这种经验是无可替代的。学习汇编语言（x86、x64 或针对你正在反向分析的恶意软件类型）并不断提高这项技能，能帮助你更快地识别恶意软件采用的反汇编防护和代码混淆技术。
- en: <samp class="SANS_Futura_Std_Bold_B_11">API Call and String Obfuscation</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">API 调用和字符串混淆</samp>
- en: In this section, you’ll learn how malware can obfuscate its Windows API function
    calls and strings to hide its intentions from analysts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习恶意软件如何混淆其 Windows API 函数调用和字符串，以隐藏其意图，从而避开分析师的检测。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*This section outlines obfuscation techniques that are specifically applicable
    to anti-disassembly and protection against static analysis, but [Chapter 16](chapter16.xhtml)
    covers more generic obfuscation techniques. API call and string obfuscation can
    also be used for endpoint defense evasion, such as sidestepping anti-malware software,
    but [Part IV](part4.xhtml) will discuss this topic in more depth.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节概述了专门用于反汇编和防止静态分析的混淆技术，但[第16章](chapter16.xhtml)涵盖了更通用的混淆技术。API 调用和字符串混淆也可以用于绕过端点防御，如规避反恶意软件软件，但[第四部分](part4.xhtml)将更深入地讨论这个话题。*'
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dynamic API
    Function Resolution</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">动态 API 函数解析</samp>'
- en: '*Dynamic API function resolution* is when a program dynamically obtains the
    address of a function it wishes to call, rather than including the function in
    its import address table (IAT). The Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    can assist with this. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    retrieves the procedural address of a function inside a given module, and it takes
    two parameters: a handle to the module where the target function resides, and
    the name of the target function itself. Sometimes <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    is preceded by a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    which will load the module that contains the target function. Let’s take a look
    at this in practice:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态 API 函数解析* 是指程序动态获取其希望调用的函数的地址，而不是将该函数包含在其导入地址表（IAT）中。Windows API 函数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> 可以协助实现这一点。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> 检索给定模块中函数的过程地址，它需要两个参数：目标函数所在模块的句柄，以及目标函数本身的名称。有时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> 会在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    之后进行，后者会加载包含目标函数的模块。让我们来看一下实际操作：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This malware sample first pushes the name of the module that contains the target
    function (in this case, *kernel32.dll*) to the stack and invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>,
    which loads this library into the address space of the process. <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    returns a handle to the *kernel32.dll* module, which is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    and is then pushed to the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">push
    eax</samp>). Next, the code pushes the name of the target function <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>
    to the stack and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>.
    The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    returns the address of the target function and stores it in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>.
    Finally, the malware executes a call instruction with the target of <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>,
    which will subsequently invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>.
    As you can see, this technique adds a layer of obfuscation to the function call.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本首先将包含目标函数的模块名称（在本例中为*kernel32.dll*）推送到栈上，并调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>，它将该库加载到进程的地址空间中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> 返回一个指向*kernel32.dll*模块的句柄，该句柄被存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 寄存器中，然后被推送到栈上（<samp class="SANS_TheSansMonoCd_W5Regular_11">push
    eax</samp>）。接下来，代码将目标函数的名称 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>
    推送到栈上并调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>。调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> 返回目标函数的地址并将其存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 中。最后，恶意软件执行一个调用指令，目标为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>，这将随之调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>。如您所见，这项技术为函数调用增加了一层混淆。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Jump Tables and Indirect
    API Calls</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">跳转表和间接 API 调用</samp>
- en: API calls can be obfuscated with *jump tables*, data structures that map addresses
    of external libraries. Jump tables can serve as a method both to obfuscate control
    flow and to hamper static code analysis. [Figure 9-6](chapter9.xhtml#fig9-6) shows
    what a jump table might look like in action.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: API调用可以通过*跳转表*进行混淆，跳转表是映射外部库地址的数据结构。跳转表既可以用来混淆控制流，也可以阻碍静态代码分析。[图9-6](chapter9.xhtml#fig9-6)展示了跳转表如何在实际操作中表现。
- en: '![](../images/fig9-6.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: A jump table in
    action</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-6：跳转表的实际应用</samp>
- en: In this simplified example, the malware’s main code makes <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions to different addresses representing the Windows API function the
    malware wishes to call. The malware’s code then transfers control flow to the
    jump table, which in this case is essentially a list of further <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions that use <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    to get the procedure address of the target Windows API function, and subsequently
    invokes that function. When the malware wishes to call <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>,
    for example, it makes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_2082A2B0</samp>,
    which jumps to the jump table, which in turn gets the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>
    in the *kernel32.dll* library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的示例中，恶意软件的主代码向不同的地址发出<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令，这些地址表示恶意软件希望调用的Windows
    API函数。然后，恶意软件的代码将控制流转移到跳转表，该跳转表实际上是一个进一步的<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令的列表，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>来获取目标Windows API函数的过程地址，接着调用该函数。例如，当恶意软件希望调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>时，它会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">sub_2082A2B0</samp>，该函数跳转到跳转表，进而获取在*kernel32.dll*库中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>的地址。
- en: 'Jump tables can be as simple as a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转表可以像这里展示的那样简单，只有一个<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令的列表：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: API functions in the jump table can be dynamically resolved upon the malware’s
    initial execution (thus building the table dynamically) or can be invoked by the
    malware as needed, meaning the function addresses are resolved on demand. This
    adds further complexity to the jump table, making the code more difficult for
    the reverser to follow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转表中的API函数可以在恶意软件首次执行时动态解析（从而动态构建表格），也可以在恶意软件需要时按需调用，这意味着函数地址是按需解析的。这为跳转表增加了进一步的复杂性，使得逆向工程师更难追踪代码。
- en: 'Malware may also use indirect API calls. Similar to jump tables, API function
    addresses are dynamically resolved and stored in memory or in CPU registers for
    later use. Then, the malware invokes the function by issuing a call instruction
    for the address of the function rather than by function name. You can see this
    in the following 64-bit simplified code example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以使用间接的API调用。与跳转表类似，API函数的地址是动态解析的，并存储在内存或CPU寄存器中以供后续使用。然后，恶意软件通过调用该函数地址而不是函数名来调用该函数。你可以在下面的64位简化代码示例中看到这一点：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code is using indirect calls to obfuscate its function calls. First, it
    moves the name of the target function it wishes to call (<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>)
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">rdx</samp>, as well as the
    associated module name (<samp class="SANS_TheSansMonoCd_W5Regular_11">hModule</samp>),
    which, in the case of these functions, resides in *kernel32.dll*. Next, the code
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> to get
    the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>
    function. Then, the code moves this address onto the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    [rbp-39], rax</samp>), which will be used later. The code runs this procedure
    twice more, for the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>. After storing
    the addresses of its target functions on the stack, the code can later invoke
    these functions by their addresses like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用间接调用来混淆它的函数调用。首先，它将目标函数的名称（它希望调用的函数，`<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>`）移入
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">rdx</samp>`，以及相关模块名（`<samp class="SANS_TheSansMonoCd_W5Regular_11">hModule</samp>`），在这些函数的情况下，模块名位于
    *kernel32.dll* 中。接下来，代码调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>`
    获取 `<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>` 函数的地址。然后，代码将该地址移入栈中（`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov [rbp-39], rax</samp>`），以便稍后使用。代码再运行此过程两次，分别针对函数
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>`。在将目标函数的地址存储到栈上后，代码可以通过这些地址像这样调用这些函数：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This call instruction will invoke the function stored on the stack at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rbp-39</samp>, which happens to be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>, a function used for
    encrypting data. Calling functions this way provides a layer of obfuscation for
    researchers who are manually reverse engineering the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用指令将会调用存储在栈上 `<samp class="SANS_TheSansMonoCd_W5Regular_11">rbp-39</samp>`
    处的函数，而这个函数恰好是 `<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>`，一个用于加密数据的函数。以这种方式调用函数为手动逆向工程的研究人员提供了一层混淆。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Stack Strings</samp>
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">栈字符串</samp>
- en: '*Stack strings* refer to strings that are built on the stack dynamically in
    memory by the malware. They add a layer of obfuscation to a malware executable,
    making static analysis a bit more time-consuming, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈字符串* 指的是恶意软件在内存中动态构建的栈上的字符串。它们为恶意可执行文件增加了一层混淆，使静态分析变得更加耗时，如下所示：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code snippet contains several <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions, representing the code moving data onto the stack. What’s interesting
    about them is that they’re moving hex values, byte by byte, into a buffer (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ebp+file</samp>). If you convert these
    hex values into ASCII (using the R key in IDA or selecting **Right-click****Convert****Char**
    in Ghidra), you can deobfuscate this stack string like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了几个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>` 指令，表示代码将数据移入栈中。它们有趣的地方在于，它们将十六进制值逐字节移入一个缓冲区（`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ebp+file</samp>`）。如果你将这些十六进制值转换为 ASCII（在
    IDA 中使用 R 键或在 Ghidra 中选择 **右键****转换****字符**），你可以像这样还原这个栈字符串：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you can make a more educated guess about what the malware is doing with
    this data. It’s creating a string (<samp class="SANS_TheSansMonoCd_W5Regular_11">evil.dll</samp>)
    on the stack and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>,
    which will load this malicious DLL file into the malware’s process. This is a
    form of *process injection*, a technique [Part IV](part4.xhtml) will cover in
    depth.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以更有依据地猜测恶意软件在处理这些数据时做了什么。它正在栈上创建一个字符串（`<samp class="SANS_TheSansMonoCd_W5Regular_11">evil.dll</samp>`），并调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>`，这将把这个恶意 DLL
    文件加载到恶意软件的进程中。这是一种 *进程注入* 技术，第四部分([Part IV](part4.xhtml))会详细讨论这一点。
- en: 'There are some great tools malware analysts can use for automating stack string
    deobfuscation. Running a malware sample through FLOSS (discussed in [Chapter 2](chapter2.xhtml)),
    for example, can deobfuscate some basic string obfuscation and build an IDA script
    file so that you can easily load this data back into your IDA database. Here’s
    an example of FLOSS output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些优秀的工具可以帮助恶意软件分析师自动化堆栈字符串去混淆。比如，运行恶意软件样本通过FLOSS（在[第2章](chapter2.xhtml)中讨论）可以去混淆一些基本的字符串混淆，并生成一个IDA脚本文件，以便你可以轻松地将这些数据加载回IDA数据库。以下是FLOSS输出的示例：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Pestr* ([*https://<wbr>pev<wbr>.sourceforge<wbr>.io*](https://pev.sourceforge.io)),
    another tool for stack string deobfuscation, can be run nearly the same way. Both
    tools are easy enough to quickly run before starting your reverse engineering
    process and may save you some time when analyzing malware code that has implemented
    basic string obfuscation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pestr*（[*https://<wbr>pev<wbr>.sourceforge<wbr>.io*](https://pev.sourceforge.io)），另一种堆栈字符串去混淆工具，也几乎可以以相同的方式运行。这两种工具足够简单，可以在开始逆向工程过程前快速运行，且在分析实现了基本字符串混淆的恶意软件代码时，可能会节省一些时间。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Data Hashing</samp>
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">数据哈希</samp>
- en: 'Malware authors can obfuscate malware functionalities by using data *hashing*,
    which is a kind of one-way data encoding; that is, it takes some data and encodes
    it into something else that can’t be reversed. The ransomware family Maze uses
    the well-known *ROR-13* hashing algorithm to obfuscate Windows API function calls,
    as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者可以通过使用数据*哈希*来混淆恶意软件的功能，这是一种单向数据编码；也就是说，它将一些数据编码成其他无法反转的内容。勒索软件家族Maze使用著名的*ROR-13*哈希算法来混淆Windows
    API函数调用，如下代码所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in
    the second line moves the ROR-13 hash <samp class="SANS_TheSansMonoCd_W5Regular_11">7C0DFCAAh</samp>,
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    onto the stack. Similarly, the hash <samp class="SANS_TheSansMonoCd_W5Regular_11">0EC0E4E8Eh</samp>
    represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    function, which moved to the stack in line 8\. This malware is obfuscating its
    calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> functions
    using hashes in place of the function name. There must be a function that is responsible
    for interpreting these hashes and loading the address of the target functions
    (in this case, function <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_4011A0</samp>),
    but this is not shown in the preceding code and the specifics of this are outside
    the scope of this chapter. However, this is well documented, such as in the blog
    post “Windows API Hashing in Malware” at [*https://<wbr>www<wbr>.ired<wbr>.team<wbr>/offensive<wbr>-security<wbr>/defense<wbr>-evasion<wbr>/windows<wbr>-api<wbr>-hashing<wbr>-in<wbr>-malware*](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行中的<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令将ROR-13哈希值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">7C0DFCAAh</samp>（即<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>的值）移入堆栈。同样，哈希值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0EC0E4E8Eh</samp>表示<samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>函数，它在第8行被移入堆栈。此恶意软件使用哈希值代替函数名来混淆对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>函数的调用。必须有一个函数负责解释这些哈希值并加载目标函数的地址（在此案例中为函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub_4011A0</samp>），但这在前面的代码中并未展示，具体细节超出了本章的讨论范围。不过，这些内容已经有很好的文献记录，例如在博客文章“恶意软件中的Windows
    API哈希”中，链接为[*https://<wbr>www<wbr>.ired<wbr>.team<wbr>/offensive<wbr>-security<wbr>/defense<wbr>-evasion<wbr>/windows<wbr>-api<wbr>-hashing<wbr>-in<wbr>-malware*](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware)。
- en: It’s difficult to understand what’s happening here simply by reviewing the code,
    since the function names are hashed and therefore unreadable. Luckily, many disassemblers
    have special features or plug-ins that can automatically identify potential hashed
    function names. In my case, the IDA plug-in *apihashes* was able to correctly
    identify and annotate the ROR-13–hashed data. Hashing will be discussed in greater
    detail in [Chapter 16](chapter16.xhtml).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看代码很难理解发生了什么，因为函数名已经被哈希化，无法读取。幸运的是，许多反汇编工具都有特殊功能或插件，能够自动识别潜在的哈希函数名。在我的案例中，IDA插件*apihashes*能够正确识别并标注出ROR-13哈希数据。哈希技术将在[第16章](chapter16.xhtml)中进行更详细的讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned about several anti-disassembly techniques malware
    might employ to protect itself from malware analysts and their tools. Deobfuscating
    assembly code is a challenging task that requires a high level of technical skill
    and knowledge of a malware’s behavior and characteristics. Compounding this challenge
    is the fact that many of these techniques are very simple for malware authors
    to implement, thanks to special code compilers, obfuscators, and tools such as
    packers. It’s often much easier for malware authors to implement anti-disassembly
    measures than it is for reverse engineers to circumvent them, but fighting back
    against such techniques is crucial to understanding the malware’s behavior and
    functionality. As an analyst, you should use the range of tools and techniques
    at your disposal to deobfuscate malware code and reveal its true intentions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了恶意软件可能采用的几种反反汇编技术，以保护自己免受恶意软件分析师及其工具的攻击。反混淆汇编代码是一项具有挑战性的任务，需要高水平的技术能力以及对恶意软件行为和特征的深入了解。更具挑战性的是，许多这些技术对于恶意软件作者来说非常简单，因为他们可以利用特殊的代码编译器、混淆器和像打包工具这样的工具来实现。对于恶意软件作者来说，实施反反汇编措施通常比逆向工程师绕过这些措施要容易得多，但对抗这些技术对于理解恶意软件的行为和功能至关重要。作为分析师，您应该利用可用的各种工具和技术来反混淆恶意软件代码，并揭示其真正意图。
- en: 'In the next chapter, we’ll discuss another anti-reversing technique that some
    malware implements to thwart dynamic code analysis: anti-debugging.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论另一个恶意软件为了阻止动态代码分析而实现的反逆向技术：反调试。
