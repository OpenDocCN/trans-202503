["```\n#include <unistd.h>\n\npid_t `fork`(void);\n```", "```\npid_t childPid;             /* Used in parent after successful fork()\n                               to record PID of child */\nswitch (childPid = fork()) {\ncase -1:                    /* fork() failed */\n    /* Handle error */\n\ncase 0:                     /* Child of successful fork() comes here */\n    /* Perform actions specific to child */\n\ndefault:                    /* Parent comes here after successful fork() */\n    /* Perform actions specific to parent */\n}\n```", "```\n`./t_fork`\nPID=28557 (child)  idata=333 istack=666\nPID=28556 (parent) idata=111 istack=222\n```", "```\n`procexec/t_fork.c`\n#include \"tlpi_hdr.h\"\n\nstatic int idata = 111;             /* Allocated in data segment */\n\nint\nmain(int argc, char *argv[])\n{\n    int istack = 222;               /* Allocated in stack segment */\n    pid_t childPid;\n\n    switch (childPid = fork()) {\n    case -1:\n        errExit(\"fork\");\n\n    case 0:\n        idata *= 3;\n        istack *= 3;\n        break;\n\n    default:\n        sleep(3);                   /* Give child a chance to execute */\n        break;\n    }\n\n    /* Both parent and child come here */\n\n    printf(\"PID=%ld %s idata=%d istack=%d\\n\", (long) getpid(),\n            (childPid == 0) ? \"(child) \" : \"(parent)\", idata, istack);\n\n    exit(EXIT_SUCCESS);\n}\n      `procexec/t_fork.c`\n```", "```\n$ `./fork_file_sharing`\nFile offset before fork(): 0\nO_APPEND flag before fork() is: off\nChild has exited\nFile offset in parent: 1000\nO_APPEND flag in parent is: on\n```", "```\n`procexec/fork_file_sharing.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int fd, flags;\n    char template[] = \"/tmp/testXXXXXX\";\n\n    setbuf(stdout, NULL);                   /* Disable buffering of stdout */\n\n    fd = mkstemp(template);\n    if (fd == -1)\n        errExit(\"mkstemp\");\n\n    printf(\"File offset before fork(): %lld\\n\",\n            (long long) lseek(fd, 0, SEEK_CUR));\n\n    flags = fcntl(fd, F_GETFL);\n    if (flags == -1)\n        errExit(\"fcntl - F_GETFL\");\n    printf(\"O_APPEND flag before fork() is: %s\\n\",\n            (flags & O_APPEND) ? \"on\" : \"off\");\n\n    switch (fork()) {\n    case -1:\n        errExit(\"fork\");\n\n    case 0:     /* Child: change file offset and status flags */\n        if (lseek(fd, 1000, SEEK_SET) == -1)\n            errExit(\"lseek\");\n\n        flags = fcntl(fd, F_GETFL);         /* Fetch current flags */\n        if (flags == -1)\n            errExit(\"fcntl - F_GETFL\");\n        flags |= O_APPEND;                  /* Turn O_APPEND on */\n        if (fcntl(fd, F_SETFL, flags) == -1)\n            errExit(\"fcntl - F_SETFL\");\n        _exit(EXIT_SUCCESS);\n\n    default:    /* Parent: can see file changes made by child */\n        if (wait(NULL) == -1)\n            errExit(\"wait\");                /* Wait for child exit */\n        printf(\"Child has exited\\n\");\n\n        printf(\"File offset in parent: %lld\\n\",\n                (long long) lseek(fd, 0, SEEK_CUR));\n\n        flags = fcntl(fd, F_GETFL);\n        if (flags == -1)\n            errExit(\"fcntl - F_GETFL\");\n        printf(\"O_APPEND flag in parent is: %s\\n\",\n                (flags & O_APPEND) ? \"on\" : \"off\");\n        exit(EXIT_SUCCESS);\n    }\n}\n     `procexec/fork_file_sharing.c`\n```", "```\n*from* `procexec/footprint.c`\n    pid_t childPid;\n    int status;\n\n    childPid = fork();\n    if (childPid == -1)\n        errExit(\"fork\");\n\n    if (childPid == 0)              /* Child calls func() and */\n        exit(func(arg));            /* uses return value as exit status */\n\n    /* Parent waits for child to terminate. It can determine the\n       result of func() by inspecting 'status'. */\n\n    if (wait(&status) == -1)\n        errExit(\"wait\");\n\n     *from* `procexec/footprint.c`\n```", "```\n#include <unistd.h>\npid_t `vfork`(void);\n```", "```\n$ `./t_vfork`\nChild executing           *Even though child slept, parent was not scheduled*\nParent executing\nistack=666\n```", "```\n`procexec/t_vfork.c`\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int istack = 222;\n\n    switch (vfork()) {\n    case -1:\n        errExit(\"vfork\");\n\n    case 0:             /* Child executes first, in parent's memory space */\n        sleep(3);                   /* Even if we sleep for a while,\n                                       parent still is not scheduled */\n        write(STDOUT_FILENO, \"Child executing\\n\", 16);\n        istack *= 3;                /* This change will be seen by parent */\n        _exit(EXIT_SUCCESS);\n\n    default:            /* Parent is blocked until child exits */\n        write(STDOUT_FILENO, \"Parent executing\\n\", 17);\n        printf(\"istack=%d\\n\", istack);\n        exit(EXIT_SUCCESS);\n    }\n}\n      `procexec/t_vfork.c`\n```", "```\n$ `./fork_whos_on_first 1`\n0 parent\n0 child\n```", "```\n`procexec/fork_whos_on_first.c`\n#include <sys/wait.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int numChildren, j;\n    pid_t childPid;\n\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [num-children]\\n\", argv[0]);\n\n    numChildren = (argc > 1) ? getInt(argv[1], GN_GT_0, \"num-children\") : 1;\n\n    setbuf(stdout, NULL);                /* Make stdout unbuffered */\n\n    for (j = 0; j < numChildren; j++) {\n        switch (childPid = fork()) {\n        case -1:\n            errExit(\"fork\");\n\n        case 0:\n            printf(\"%d child\\n\", j);\n            _exit(EXIT_SUCCESS);\n\n        default:\n            printf(\"%d parent\\n\", j);\n            wait(NULL);                   /* Wait for child to terminate */\n            break;\n        }\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `procexec/fork_whos_on_first.c`\n```", "```\n$ `./fork_sig_sync`\n[17:59:02 5173] Child started - doing some work\n[17:59:02 5172] Parent about to wait for signal\n[17:59:04 5173] Child about to signal parent\n[17:59:04 5172] Parent got signal\n```", "```\n`procexec/fork_sig_sync.c`\n#include <signal.h>\n#include \"curr_time.h\"                  /* Declaration of currTime() */\n#include \"tlpi_hdr.h\"\n\n#define SYNC_SIG SIGUSR1                /* Synchronization signal */\n\nstatic void             /* Signal handler - does nothing but return */\nhandler(int sig)\n{\n}\n\nint\nmain(int argc, char *argv[])\n{\n    pid_t childPid;\n    sigset_t blockMask, origMask, emptyMask;\n    struct sigaction sa;\n\n    setbuf(stdout, NULL);               /* Disable buffering of stdout */\n\n    sigemptyset(&blockMask);\n    sigaddset(&blockMask, SYNC_SIG);    /* Block signal */\n    if (sigprocmask(SIG_BLOCK, &blockMask, &origMask) == -1)\n        errExit(\"sigprocmask\");\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = handler;\n    if (sigaction(SYNC_SIG, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    switch (childPid = fork()) {\n    case -1:\n        errExit(\"fork\");\n\n    case 0: /* Child */\n\n        /* Child does some required action here... */\n\n        printf(\"[%s %ld] Child started - doing some work\\n\",\n                currTime(\"%T\"), (long) getpid());\n        sleep(2);               /* Simulate time spent doing some work */\n\n        /* And then signals parent that it's done */\n\n        printf(\"[%s %ld] Child about to signal parent\\n\",\n                currTime(\"%T\"), (long) getpid());\n        if (kill(getppid(), SYNC_SIG) == -1)\n            errExit(\"kill\");\n\n        /* Now child can do other things... */\n\n        _exit(EXIT_SUCCESS);\n\n    default: /* Parent */\n\n        /* Parent may do some work here, and then waits for child to\n           complete the required action */\n\n        printf(\"[%s %ld] Parent about to wait for signal\\n\",\n                currTime(\"%T\"), (long) getpid());\n        sigemptyset(&emptyMask);\n        if (sigsuspend(&emptyMask) == -1 && errno != EINTR)\n            errExit(\"sigsuspend\");\n        printf(\"[%s %ld] Parent got signal\\n\", currTime(\"%T\"), (long) getpid());\n\n        /* If required, return signal mask to its original state */\n\n        if (sigprocmask(SIG_SETMASK, &origMask, NULL) == -1)\n            errExit(\"sigprocmask\");\n\n        /* Parent carries on to do other things... */\n\n        exit(EXIT_SUCCESS);\n    }\n}\n      `procexec/fork_sig_sync.c`\n```", "```\n    fork();\n    fork();\n    fork();\n    ```"]