- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating Functions and Procedures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数和存储过程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In [Chapter 8](c08.xhtml), you learned how to call built-in MySQL functions;
    in this chapter, you’ll write your own. You’ll also learn to write procedures
    and explore the key differences between the two.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](c08.xhtml)，你学习了如何调用内置的MySQL函数；在这一章，你将编写自己的函数。你还将学习如何编写存储过程，并探索两者的主要区别。
- en: You’ll add logic to your functions and procedures using `if` statements, loops,
    cursors, and `case` statements to perform different tasks based on the value of
    your data. Lastly, you’ll practice accepting values in your functions and procedures
    and returning values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过`if`语句、循环、游标和`case`语句，向你的函数和存储过程添加逻辑，根据数据的值执行不同的任务。最后，你将练习在函数和存储过程中接收值并返回值。
- en: Functions vs. Procedures
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数与存储过程
- en: Functions and procedures are programs you can call by name. Because they’re
    saved in your MySQL database, they are sometimes called *stored* functions and
    procedures. Collectively, they are referred to as *stored routines* or *stored
    programs*. When you write a complex SQL statement or a group of statements with
    several steps, you should save it as a function or procedure so you can easily
    call it by name later.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和存储过程是可以通过名称调用的程序。由于它们保存在你的MySQL数据库中，因此有时也称为*存储*函数和存储过程。统称它们为*存储例程*或*存储程序*。当你编写一个复杂的SQL语句或包含多个步骤的语句时，你应该将其保存为一个函数或存储过程，以便以后可以方便地通过名称调用。
- en: 'The main difference between a function and a procedure is that a function gets
    called from a SQL statement and always returns one value. A procedure, on the
    other hand, gets called explicitly using a `call` statement. Procedures also pass
    values back to the caller differently than functions. (Note that the caller may
    be a person using a tool like MySQL Workbench, a program written in a programming
    language like Python or PHP, or another MySQL procedure.) While procedures may
    return no values, one value, or many values, a function accepts arguments, performs
    some task, and returns a single value. For example, you might find the population
    of New York by calling the `f_get_state_population()` function from a `select`
    statement, passing in the state name as an argument to the function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和存储过程的主要区别在于，函数可以从SQL语句中调用，并始终返回一个值。而存储过程则是通过显式的`call`语句调用的。存储过程与函数不同，它们返回值的方式也不同。（请注意，调用者可能是使用像MySQL
    Workbench这样的工具的人，或是用Python、PHP等编程语言编写的程序，或者是另一个MySQL存储过程。）存储过程可以不返回值、返回一个值或返回多个值，而函数接受参数，执行某些任务，并返回单个值。例如，你可以通过`select`语句调用`f_get_state_population()`函数，传入州名作为参数，从而得到纽约的州人口：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You pass an argument to a function by putting it between the parentheses. To
    pass more than one argument, separate them by commas. The function accepts the
    argument, does some processing that you defined when you created the function,
    and returns a value:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将参数放在括号中来向函数传递参数。如果要传递多个参数，用逗号分隔。函数接收参数，执行你在创建函数时定义的处理，然后返回一个值：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `f_get_state_population()` function took the text `New York` as an argument,
    did a lookup in your database to find the population, and returned `19299981`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`f_get_state_population()`函数以文本`New York`作为参数，查询数据库找到人口信息，并返回`19299981`。'
- en: 'You can also call functions in the `where` clause of SQL statements, such as
    the following example that returns every `state_population` greater than New York’s:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在SQL语句的`where`子句中调用函数，例如以下示例，返回每个`state_population`大于纽约州的人口：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you called the function `f_get_state_population()` with an argument of
    `New York`. The function returned the value `19299981`, which caused your query
    to evaluate to the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你调用了`f_get_state_population()`函数，传入参数`New York`。该函数返回了值`19299981`，这使得你的查询结果评估为以下内容：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your query returned data from the `state` table for states with a population
    greater than 19,299,981:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的查询返回了来自`state`表的数据，数据包含人口超过19,299,981的州：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Procedures, on the other hand, are not called from SQL queries, but instead
    via the `call` statement. You pass in any arguments the procedure has been designed
    to accept, the procedure performs the tasks you defined, and then control returns
    to the caller.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程与函数不同，它们不能从SQL查询中调用，而是通过`call`语句调用。你传入存储过程设计时需要的任何参数，存储过程执行你定义的任务，然后控制权返回给调用者。
- en: 'For example, you call a procedure named `p_set_state_population()` and pass
    it an argument of `New York` like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你调用一个名为`p_set_state_population()`的过程，并传入`New York`作为参数，如下所示：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You’ll see how to create the `p_set_state_population()` procedure and define
    its tasks in [Listing 11-2](#listing11-2). For now, just know that this is the
    syntax for calling a procedure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[Listing 11-2](#listing11-2)中看到如何创建`p_set_state_population()`过程并定义其任务。目前，你只需知道这是调用过程的语法。
- en: Procedures are often used to execute business logic by updating, inserting,
    and deleting records in tables, and they can also be used to display a dataset
    from the database. Functions are used for smaller tasks, like getting one piece
    of data from the database or formatting a value. Sometimes you can implement the
    same functionality as either a procedure or a function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 过程通常用于通过更新、插入和删除表中的记录来执行业务逻辑，也可以用来显示数据库中的数据集。函数则用于执行较小的任务，比如从数据库获取一条数据或格式化一个值。有时，你可以用过程或函数来实现相同的功能。
- en: Like tables and views, functions and procedures are saved in the database where
    you created them. You can set the current database with the `use` command; then,
    when you define a procedure or function, it will be created in that database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像表和视图一样，函数和过程也保存在你创建它们的数据库中。你可以使用`use`命令来设置当前数据库；然后，当你定义过程或函数时，它将被创建在该数据库中。
- en: Now that you’ve seen how to call functions and procedures, let’s look at how
    to create them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何调用函数和过程，让我们来看看如何创建它们。
- en: Creating Functions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数
- en: '[Listing 11-1](#listing11-1) defines the `f_get_state_population()` function,
    which accepts a state’s name and returns the population of the state.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-1](#listing11-1)定义了`f_get_state_population()`函数，它接受一个州的名称并返回该州的人口。'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-1: Creating the `f_get_state_population()` function'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-1: 创建`f_get_state_population()`函数'
- en: In the first line, you set the current database to `population` with the `use`
    command ❶ so your function will be created in that database.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，你通过`use`命令 ❶ 设置当前数据库为`population`，这样你的函数就会创建在该数据库中。
- en: Before you create the function, you use the `drop function` statement in case
    there’s already a version of this function. If you try to create a function and
    an old version already exists, MySQL will send a `function already exists` error
    and won’t create the function. Similarly, if you try to drop a function that doesn’t
    already exist, MySQL will also send an error. To prevent that error from appearing,
    you add `if exists` after `drop function` ❷, which will drop the function if it
    already exists, but won’t send an error if it doesn’t.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数之前，你需要使用`drop function`语句，以防该函数已经存在。如果你尝试创建一个函数，而旧版本已存在，MySQL 会发送一个`function
    already exists`的错误，并且不会创建该函数。同样，如果你尝试删除一个不存在的函数，MySQL 也会发送错误。为了避免出现该错误，你可以在`drop
    function`后加上`if exists` ❷，这样如果函数已存在，它将被删除，但如果不存在，则不会发送错误。
- en: The function itself is defined between the `create function` ❸ and `end` statements
    ❹. We’ll walk through its components in the following sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身在`create function` ❸ 和 `end` 语句 ❹ 之间定义。我们将在接下来的章节中详细讲解它的组成部分。
- en: Redefining the Delimiter
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新定义分隔符
- en: The function definition also includes lines of code to redefine and then reset
    your delimiter. A *delimiter* is one or more characters that separate one SQL
    statement from another and mark the end of each statement. Typically, you’ll use
    a semicolon as the delimiter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义还包括几行代码，用于重新定义然后重置分隔符。*分隔符*是一个或多个字符，用来分隔一个 SQL 语句和另一个 SQL 语句，并标记每个语句的结束。通常，你会使用分号作为分隔符。
- en: In [Listing 11-1](#listing11-1), you temporarily set the MySQL delimiter to
    `//` using the `delimiter //` statement because your function is made up of multiple
    SQL statements that end in a semicolon. For example, `f_get_state_population()`
    has three semicolons, located after the `declare` statement, the `select` statement,
    and the `return` statement. To ensure that MySQL creates your function starting
    with the `create function` statement and ending with the `end` statement, you
    need a way to tell it not to interpret any semicolons between those two statements
    as the end of your function. This is why you’ve redefined the delimiter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 11-1](#listing11-1)中，你使用`delimiter //`语句暂时将 MySQL 的分隔符设置为`//`，因为你的函数由多个以分号结尾的
    SQL 语句组成。例如，`f_get_state_population()`包含三个分号，分别位于`declare`语句、`select`语句和`return`语句之后。为了确保
    MySQL 从`create function`语句开始，到`end`语句结束时正确创建你的函数，你需要告诉它不要将这两个语句之间的分号视为函数的结束。这就是你重新定义分隔符的原因。
- en: Let’s take a look at what would happen if you didn’t redefine your delimiter.
    If you remove or comment out the `delimiter //` statement at the beginning of
    your code and look at it in MySQL Workbench, you’ll notice some red X markers
    on lines 12 and 19, indicating errors ([Figure 11-1](#figure11-1)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果你不重新定义分隔符会发生什么。如果你删除或注释掉代码开头的`delimiter //`语句，并在MySQL Workbench中查看它，你会注意到第12行和第19行出现了红色X标记，表示错误（[图11-1](#figure11-1)）。
- en: '![](image_fi/503007c11/f11001.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/503007c11/f11001.png)'
- en: 'Figure 11-1: MySQL Workbench showing errors on lines 12 and 19'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：MySQL Workbench显示第12行和第19行的错误
- en: You commented out the `delimiter` statement on line 5 by adding two hyphens
    and a space (`--` ) in front of it; this caused MySQL Workbench to report errors
    on lines 12 and 19 because the semicolon has become the delimiter character. Thus,
    every time MySQL encounters a semicolon, it assumes that is the end of a SQL statement.
    MySQL Workbench tries to help you by showing error markers with a red X to let
    you know the statements ending in semicolons aren’t valid.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过在第5行的`delimiter`语句前添加两个短横线和空格（`--`）注释掉了该语句，这导致MySQL Workbench在第12行和第19行报告错误，因为分号已成为分隔符字符。因此，每当MySQL遇到分号时，它会认为这是SQL语句的结束。MySQL
    Workbench试图通过显示带有红色X的错误标记来帮助你，让你知道以分号结尾的语句无效。
- en: Redefining the delimiter to `//` (or something other than `;`) informs MySQL
    Workbench that the statements creating your function aren’t over until it hits
    `//` at the end of line 21\. You can fix the errors by uncommenting line 5 (removing
    the two hyphens and a space, `--` , at the beginning of the line), thereby reinserting
    the `delimiter //` command.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将分隔符重新定义为`//`（或其他不是`;`的字符）告诉MySQL Workbench，在遇到第21行的`//`之前，创建函数的语句尚未结束。你可以通过取消注释第5行（移除行首的两个短横线和空格`--`），重新插入`delimiter
    //`命令，从而修复错误。
- en: After the function has been created, you set the delimiter back to the semicolon
    on line 23.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数创建后，你将分隔符设置回第23行的分号。
- en: 'Although redefining the delimiter to `//` is necessary here because your function
    body contains three semicolons, there are other situations where you don’t need
    to redefine your delimiter. For example, you can simplify the following function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这里重新定义分隔符为`//`是必要的，因为你的函数体包含了三个分号，但在其他情况下你不需要重新定义分隔符。例如，你可以简化以下函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `begin` and `end` keywords group statements that are part of the function
    body. Since this function body has only one SQL statement, returning the world
    population, you don’t need to use `begin` and `end` here. And you don’t need to
    redefine your delimiter, either, because there’s only one semicolon—at the end
    of the `return` statement. You can remove the code that redefines and resets the
    delimiter and simplify your function to this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin`和`end`关键字将函数体内的语句分组。由于这个函数体只有一条SQL语句，即返回世界人口，你不需要在这里使用`begin`和`end`。而且，你也不需要重新定义分隔符，因为只有一个分号——位于`return`语句的末尾。你可以删除重新定义和重置分隔符的代码，并将函数简化为以下形式：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this is a more concise way to write the function, you might want to keep
    the `begin` and `end` statements and redefine the delimiter because it makes it
    easier to add a second SQL statement in the future. The choice is yours.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种写法更简洁，但你可能希望保留`begin`和`end`语句并重新定义分隔符，因为这样未来添加第二条SQL语句会更容易。选择权在你。
- en: Adding Parameters and Returning a Value
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加参数并返回值
- en: Both built-in functions and custom functions can accept parameters. You created
    the `f_get_state_population()` function in [Listing 11-1](#listing11-1) to accept
    one parameter named `state_param`, which has a `varchar(100)` data type. You can
    define parameters with the data types in [Chapter 4](c04.xhtml), including `int`,
    `date`, `decimal`, and `text`, to define a table’s columns.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内建函数和自定义函数都可以接受参数。在[清单11-1](#listing11-1)中，你创建了`f_get_state_population()`函数，接受一个名为`state_param`的参数，其数据类型为`varchar(100)`。你可以在[第4章](c04.xhtml)中定义带有数据类型的参数，包括`int`、`date`、`decimal`和`text`，用于定义表的列。
- en: Because functions return a value to the caller of the function, you use the
    `returns` keyword in [Listing 11-1](#listing11-1) to let MySQL know the data type
    of the value that your function will return. In this case, the function will return
    an integer, representing the population of a state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数会将值返回给函数的调用者，所以在[清单11-1](#listing11-1)中，你使用`returns`关键字告诉MySQL你的函数将返回的值的数据类型。在这种情况下，函数将返回一个整数，表示某个州的人口。
- en: Specifying Characteristics
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定特性
- en: 'In [Listing 11-1](#listing11-1), once you establish that your function returns
    an integer, you specify some characteristics of your function. A *characteristic*
    is an attribute or property of the function. In this example, you used the `deterministic`
    and `reads sql data` characteristics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 11-1](#listing11-1)中，一旦你确定函数返回一个整数，你就可以指定该函数的一些特性。*特性*是函数的一个属性或特性。在此示例中，你使用了`deterministic`和`reads
    sql data`特性：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can list the characteristics on one line, or you can list each characteristic
    on its own line, like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一行中列出所有特性，也可以将每个特性列在单独的行上，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You need to choose from two sets of characteristics: `deterministic` or `not
    deterministic`, and `reads sql data`, `modifies sql data`, `contains sql`, or
    `no sql`. You must specify at least one of these three characteristics for all
    of your functions: `deterministic`, `no sql`, or `reads sql data`. If you don’t,
    MySQL will send an error message and won’t create your function.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从两个特性集选择：`deterministic`或`not deterministic`，以及`reads sql data`、`modifies
    sql data`、`contains sql`或`no sql`。你必须为所有函数指定至少一个特性：`deterministic`、`no sql`或`reads
    sql data`。如果你没有这样做，MySQL会返回错误信息并且不会创建该函数。
- en: deterministic or not deterministic
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定性或非确定性
- en: Choosing `deterministic` means the function will return the same value given
    the same arguments and the same state of the database. This is usually the case.
    The `f_get_state_population()` function is deterministic because, unless the data
    in the database changes, every time you call `f_get_state_population()` with an
    argument of `New York`, the function will return the value `19299981`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`deterministic`意味着该函数在相同的参数和数据库状态下会返回相同的值。这通常是情况。`f_get_state_population()`函数是确定性的，因为，除非数据库中的数据发生变化，否则每次调用`f_get_state_population()`并传入`New
    York`作为参数时，函数都会返回值`19299981`。
- en: The `not deterministic` characteristic means that the function may not return
    the same value given the same arguments and the same state of the database. This
    would be the case for a function that returns the current date, for example, as
    calling it today will yield a different return value than calling it tomorrow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`not deterministic`特性意味着该函数在相同的参数和数据库状态下可能不会返回相同的值。例如，对于一个返回当前日期的函数来说，今天调用它会得到与明天调用它不同的返回值。'
- en: If you tag a nondeterministic function as `deterministic`, you might get incorrect
    results when you call your function. If you tag a deterministic function as `not
    deterministic`, your function might run slower than necessary. If you don’t define
    a function as `deterministic` or `not deterministic`, MySQL defaults to `not deterministic`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将一个非确定性函数标记为`deterministic`，调用该函数时可能会得到错误结果。如果将一个确定性函数标记为`not deterministic`，则函数可能会比必要的运行得更慢。如果你没有将函数定义为`deterministic`或`not
    deterministic`，MySQL默认将其视为`not deterministic`。
- en: MySQL uses `deterministic` or `not deterministic` for two purposes. First, MySQL
    has a query optimizer that determines the fastest way to execute queries. Specifying
    `deterministic` or `not deterministic` helps the query optimizer make good execution
    choices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL使用`deterministic`或`not deterministic`有两个目的。首先，MySQL有一个查询优化器，它确定执行查询的最快方式。指定`deterministic`或`not
    deterministic`有助于查询优化器做出更好的执行选择。
- en: Second, MySQL has a binary log that keeps track of changes to data in the database.
    The binary log is used to perform *replication*, a process in which data from
    one MySQL database server is copied to another server, known as a *replica*. Specifying
    `deterministic` or `not deterministic` helps MySQL perform this replication.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，MySQL有一个二进制日志，它跟踪数据库中数据的变化。二进制日志用于执行*复制*，即将来自一个MySQL数据库服务器的数据复制到另一个服务器（称为*副本*）。指定`deterministic`或`not
    deterministic`有助于MySQL执行这个复制过程。
- en: reads sql data, modifies sql data, contains sql, or no sql
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取 SQL 数据，修改 SQL 数据，包含 SQL，或无 SQL
- en: The `reads sql` `data` characteristic means that the function reads from the
    database using `select` statements but doesn’t update, delete, or insert any data;
    `modifies sql data`, on the other hand, means that the function does update, delete,
    or insert data. This would be the case more for procedures than for functions
    because procedures are more commonly used for modifying data in the database than
    functions are.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`reads sql data` `data`特性意味着该函数通过`select`语句从数据库中读取数据，但不会更新、删除或插入任何数据；而`modifies
    sql data`则意味着该函数确实会更新、删除或插入数据。对于过程来说，这种情况更为常见，因为过程通常用于修改数据库中的数据，而函数则较少用于此。'
- en: The `contains sql` characteristic means the function has at least one SQL statement
    but doesn’t read or write any data from the database, and `no sql` means the function
    contains no SQL statements. An example of `no sql` would be a function that returns
    a hardcoded number, in which case it doesn’t query the database. You could, for
    example, write a function that always returns `212` so that you don’t need to
    remember the temperature at which water boils.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains sql` 特性意味着该函数至少包含一个 SQL 语句，但不会从数据库读取或写入任何数据，而 `no sql` 则意味着该函数不包含任何
    SQL 语句。`no sql` 的例子是一个返回硬编码数字的函数，在这种情况下它不会查询数据库。例如，你可以编写一个总是返回 `212` 的函数，这样你就不需要记住水的沸点温度。'
- en: If you don’t specify `reads sql data`, `modifies sql data`, `contains sql`,
    or `no sql`, MySQL defaults to `contains sql`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定 `reads sql data`、`modifies sql data`、`contains sql` 或 `no sql`，MySQL
    默认使用 `contains sql`。
- en: Defining the Function Body
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义函数体
- en: After listing the characteristics, you define the function body, the block of
    code that gets executed when the function is called. You use a `begin` and an
    `end` statement to mark the beginning and end of the function body.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列出特性之后，你需要定义函数体，这是在函数被调用时执行的代码块。你使用 `begin` 和 `end` 语句来标记函数体的开始和结束。
- en: In [Listing 11-1](#listing11-1), you declared a variable named `population_var`
    with the `declare` keyword. Variables are named objects that can hold values.
    You can declare them with any of the MySQL data types; in this case, you used
    the `int` type. You’ll learn about different types of variables in the section
    “Defining Local Variables and User Variables” later in the chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 11-1](#listing11-1) 中，你使用 `declare` 关键字声明了一个名为 `population_var` 的变量。变量是可以保存值的命名对象。你可以使用任何
    MySQL 数据类型来声明它们；在这个例子中，你使用了 `int` 类型。你将在本章稍后的“定义本地变量和用户变量”一节中了解不同类型的变量。
- en: Then you add a `select` statement that selects the population from your database
    and writes it into your `population_var` variable. This `select` statement is
    similar to those you’ve used before, except you’re now using the `into` keyword
    to select the value you got from the database into a variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你添加一个 `select` 语句，它从数据库中选择人口数据并将其写入 `population_var` 变量中。这个 `select` 语句类似于你之前使用过的，只是这次你使用了
    `into` 关键字，将从数据库中获取的值选择到一个变量中。
- en: You then return the value of `population_var` to the caller of the function
    with a `return` statement. Since functions always return one value, there must
    be a `return` statement in your function. The data type of the value being returned
    must match the `returns` statement at the beginning of the function. You use `returns`
    to declare the data type of the value you’ll return, and `return` to actually
    return the value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用 `return` 语句将 `population_var` 的值返回给函数的调用者。由于函数总是返回一个值，因此你的函数中必须有一个 `return`
    语句。返回值的数据类型必须与函数开始时的 `returns` 语句匹配。你使用 `returns` 来声明返回值的数据类型，而使用 `return` 来实际返回值。
- en: Your `end` statement is followed by `//` because you redefined your delimiter
    to `//` earlier. Once you reach the `end` statement, your function body is complete,
    so you redefine your delimiter back to a semicolon.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `end` 语句后面跟着 `//`，因为你之前将分隔符重新定义为 `//`。一旦到达 `end` 语句，函数体就完成了，因此你将分隔符重新定义回分号。
- en: Creating Procedures
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建过程
- en: Similar to functions, procedures accept parameters, include a code block surrounded
    by `begin` and `end`, can have defined variables, and can have a redefined delimiter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数类似，过程接受参数，包含由 `begin` 和 `end` 包围的代码块，可以定义变量，并可以重新定义分隔符。
- en: Unlike functions, procedures don’t use the `returns` or `return` keyword because
    procedures don’t return one value in the way that functions do. Also, you can
    display values in procedures using the `select` keyword. Additionally, while MySQL
    requires you to specify characteristics like `deterministic` or `reads sql data`
    when creating functions, this is not required for procedures.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，过程不使用 `returns` 或 `return` 关键字，因为过程不像函数那样返回一个值。此外，你可以使用 `select` 关键字在过程中显示值。另外，虽然
    MySQL 在创建函数时要求指定像 `deterministic` 或 `reads sql data` 等特性，但这对于过程来说不是必须的。
- en: '[Listing 11-2](#listing11-2) creates a procedure called `p_set_state_population()`
    that accepts a parameter for the state’s name, gets the latest population values
    for each county in the state from the `county_population` table, sums the populations,
    and writes the total population to the `state_population` table.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-2](#listing11-2) 创建了一个名为 `p_set_state_population()` 的存储过程，该存储过程接受一个州名作为参数，从
    `county_population` 表中获取该州各县的最新人口数据，求和并将总人口写入 `state_population` 表。'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-2: Creating the `p_set_state_population()` procedure'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-2：创建 `p_set_state_population()` 存储过程
- en: First, you set your current database to `population` with `use` so the procedure
    will be created in the `population` database ❶. Before creating the procedure,
    you check to see if it already exists, and if it does, the old version is deleted
    with the `drop` command ❷. Then you redefine your delimiter to `//` just as you
    did when creating functions ❸.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你通过 `use` 将当前数据库设置为 `population`，这样存储过程将在 `population` 数据库中创建 ❶。在创建存储过程之前，你会检查该存储过程是否已经存在，如果存在，则使用
    `drop` 命令删除旧版本 ❷。然后，像创建函数时一样，你将分隔符重新定义为 `//` ❸。
- en: Next, you create the procedure and call it `p_set_state_population()` ❹. As
    with functions, you name the parameter `state_param` and give it a `varchar(100)`
    data type, and you also specify `in` to set `state_param` as an input parameter
    ❺. Let’s look at this step a little closer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建存储过程并将其命名为 `p_set_state_population()` ❹。与函数相似，你将参数命名为 `state_param`，并赋予其
    `varchar(100)` 数据类型，同时指定 `in` 以将 `state_param` 设置为输入参数 ❺。让我们更详细地看一下这一步。
- en: Unlike functions, procedures can accept parameter values as input and also pass
    values back to the caller as output. They can also accept multiple input and output
    parameters. (You’ll explore output parameters in depth later in this chapter.)
    When you write procedures, you specify the type of parameter using the keyword
    `in` for input, `out` for output, or `inout` for parameters that are both. This
    specification isn’t necessary for functions because function parameters are always
    assumed to be input. If you don’t specify `in`, `out`, or `inout` for your procedure
    parameters, MySQL defaults to `in`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，存储过程可以接受参数值作为输入，并且还可以将值作为输出返回给调用者。存储过程还可以接受多个输入和输出参数。（你将在本章稍后深入探讨输出参数。）在编写存储过程时，你使用
    `in` 关键字指定输入参数，`out` 关键字指定输出参数，或者使用 `inout` 关键字指定既是输入又是输出的参数。对于函数来说，这种指定是没有必要的，因为函数的参数默认总是作为输入。如果你没有为存储过程的参数指定
    `in`、`out` 或 `inout`，MySQL 默认将其视为 `in`。
- en: Next, the procedure body is between the `begin` and `end` statements. In this
    body, you delete the existing row in the `state_population` table for the state
    (if one exists) ❻, then insert a new row into the `state_population` table ❼.
    If you don’t delete the existing row(s) first, the table will have a row for every
    time you run the procedure. You want to start with a clean slate before you write
    the current information to the `state_population` table.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，存储过程的主体位于 `begin` 和 `end` 语句之间。在该主体中，你删除 `state_population` 表中该州的现有行（如果存在）
    ❻，然后向 `state_population` 表中插入新的一行 ❼。如果你不先删除现有行，表中将为每次运行存储过程时都生成一行数据。你希望在写入当前信息到
    `state_population` 表之前先清理干净。
- en: You get the state’s population by summing the populations of the individual
    counties in that state from the `county_population` table ❽.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过从 `county_population` 表中对该州所有县的人口进行求和，来获取该州的人口数据 ❽。
- en: As you did with functions, when you’re done defining the procedure you redefine
    your delimiter to a semicolon ❾.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数创建时一样，当你完成存储过程的定义后，你会将分隔符重新定义为分号 ❾。
- en: Using select to Display Values
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `select` 显示值
- en: When you create procedures and functions, you can use the `select...into` syntax
    to write a value from the database into a variable. But unlike functions, procedures
    can also use `select` statements without the `into` keyword to display values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建存储过程和函数时，可以使用 `select...into` 语法将数据库中的值写入变量中。但与函数不同，存储过程还可以使用不带 `into` 关键字的
    `select` 语句来显示值。
- en: '[Listing 11-3](#listing11-3) creates a procedure called `p_set_and_show_state_population()`
    to select the population of the state into a variable and then display a message
    to the procedure caller.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-3](#listing11-3) 创建了一个名为 `p_set_and_show_state_population()` 的存储过程，该存储过程将州的人口选择到一个变量中，并向存储过程的调用者显示一条消息。'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-3: Creating the `p_set_and_show_state_population()` procedure'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-3：创建 `p_set_and_show_state_population()` 存储过程
- en: In this procedure, you declare a variable called `population_var` as an integer
    ❶ and insert the sum of the county populations into it using a `select...into`
    statement ❷. Then you insert the `state_param` parameter value and the `population_var`
    variable value into your `state_population` table ❸.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个存储过程中，你声明了一个名为`population_var`的整数变量 ❶，并使用`select...into`语句 ❷ 将县人口的总和插入其中。然后，你将`state_param`参数值和`population_var`变量值插入到`state_population`表中
    ❸。
- en: 'When you call the procedure, it not only sets the correct population of New
    York in the `state_population` table, but also displays an informative message:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用存储过程时，它不仅会在`state_population`表中设置正确的纽约人口，还会显示一条信息性消息：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The message displayed is:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的消息是：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You used `select` to display the message, which you built by concatenating (using
    the `concat()` function), the text `Setting the population for`, the `state_param`
    value, the word `to`, and the `population_var` value ❹.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了`select`来显示消息，通过连接（使用`concat()`函数）文本`Setting the population for`、`state_param`值、单词`to`和`population_var`值
    ❹。
- en: Defining Local Variables and User Variables
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义局部变量和用户变量
- en: 'The `population_var` variable is a local variable. *Local variables* are variables
    that you define in your procedures and functions using the `declare` command with
    a data type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`population_var`变量是一个局部变量。*局部变量*是你在存储过程和函数中使用`declare`命令和数据类型定义的变量：'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Local variables are only available—or *in scope*—during the execution of the
    procedure or function containing them. Because you’ve defined `population_var`
    as an `int`, it will accept only integer values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量只在包含它们的存储过程或函数执行期间有效或*在作用范围内*。由于你将`population_var`定义为`int`，它只接受整数值。
- en: You can also use a *user variable*, which starts with the at sign (`@`) and
    can be used for the entire length of your session. As long as you’re connected
    to your MySQL server, the user variable will be in scope. If you create a user
    variable from MySQL Workbench, for example, it will be available until you close
    the tool.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用*用户变量*，它以 at 符号（`@`）开头，并且可以在整个会话期间使用。只要你连接到 MySQL 服务器，用户变量就会在作用范围内。例如，如果你从
    MySQL Workbench 创建用户变量，它将一直有效，直到你关闭工具。
- en: When creating a local variable, you must specify its data type; when creating
    a user variable, it’s not necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建局部变量时，必须指定其数据类型；而创建用户变量时则不需要。
- en: 'You might see code in a function or procedure that uses both local variables
    and user variables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在函数或存储过程中看到同时使用局部变量和用户变量的代码：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You never declared the `@user_var` variable with a data type like `int`, `char`,
    or `bool`, but because it was being set to an integer value (the `local_var` value
    plus 3), MySQL automatically set it to `int` for you.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你从未为`@user_var`变量声明过数据类型，如`int`、`char`或`bool`，但因为它被设置为一个整数值（`local_var`值加上 3），MySQL
    自动将其设置为`int`。
- en: Using Logic in Procedures
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在存储过程中的逻辑使用
- en: In procedures, you can use similar programming logic to what you’d use in programming
    languages like Python, Java, or PHP. For example, you can control the flow of
    execution with conditional statements like `if` and `case` to execute parts of
    your code under specific conditions. You can also use loops to repeatedly execute
    parts of your code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储过程中，你可以使用类似于 Python、Java 或 PHP 等编程语言中的编程逻辑。例如，你可以使用`if`和`case`等条件语句控制执行流，以便在特定条件下执行代码的某些部分。你还可以使用循环反复执行代码的某些部分。
- en: if Statements
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if 语句
- en: An `if` statement is a decision-making statement that executes particular lines
    of code if a condition is true. [Listing 11-4](#listing11-4) creates a procedure
    called `p_compare_population()` that compares the population in the `state_population`
    table to the `county_population` table. If the population values match, it returns
    one message. If they don’t, it returns another.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是一个决策语句，当条件为真时执行特定的代码行。[列表 11-4](#listing11-4) 创建了一个名为`p_compare_population()`的存储过程，用于比较`state_population`表中的人口与`county_population`表中的人口。如果人口值匹配，它返回一条消息。如果不匹配，它返回另一条消息。'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11-4: The `p_compare_population()` procedure'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：`p_compare_population()`存储过程
- en: In the first `select` statement, you select the population for the state from
    the `state_population` table and write it into the `state_population_var` variable
    ❶. Then, in the second `select` statement, you select the sum of the populations
    for each county in the state from the `county_population` table and write it into
    the `county_population_var` variable ❷. You compare the two variables with the
    `if...then` syntax. You’re saying `if` the values match ❸, `then` execute the
    line that displays the message `The population values match`; `else` (otherwise)
    ❹, execute the next line, displaying the message `The population values are different`.
    Then you use `end if` to mark the end of the `if` statement.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`select`语句中，你从`state_population`表中选择州的人口，并将其写入`state_population_var`变量❶。然后，在第二个`select`语句中，你从`county_population`表中选择该州每个县的人口总和，并将其写入`county_population_var`变量❷。你使用`if...then`语法比较这两个变量。你在说，`if`值匹配❸，`then`执行显示消息`The
    population values match`的行；`else`（否则）❹，执行下一行，显示消息`The population values are different`。然后你使用`end
    if`标记`if`语句的结束。
- en: 'You call the procedure using the following `call` statement:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下`call`语句调用该过程：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result is:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The procedure shows that the values in the two tables don’t match. Perhaps the
    population table for the counties contains updated data, but the `state_population`
    table hasn’t been updated yet.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程显示两个表中的值不匹配。可能是县级人口表包含了更新的数据，但`state_population`表还没有更新。
- en: 'MySQL provides the `elseif` keyword to check for more conditions. You could
    expand your `if` statement to display one of *three* messages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL提供了`elseif`关键字来检查更多的条件。你可以扩展你的`if`语句，显示三个消息中的一个：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first condition checks whether the `state_population_var` value equals the
    `county_population_var` value. If that condition is true, the code displays the
    text `The population values match` and control flows to the `end if` statement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件检查`state_population_var`值是否等于`county_population_var`值。如果该条件为真，代码将显示文本`The
    population values match`，然后控制流将进入`end if`语句。
- en: If the first condition was not met, the code checks the `elseif` condition,
    which sees if `state_population_var` is greater than `county_population_var`.
    If that condition is true, your code displays the text `State population is more
    than the sum of county population` and control flows to the `end if` statement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个条件不满足，代码将检查`elseif`条件，查看`state_population_var`是否大于`county_population_var`。如果该条件为真，代码显示文本`State
    population is more than the sum of county population`，然后控制流进入`end if`语句。
- en: If neither condition is met, control flows to the `else` statement, the code
    displays `The sum of county population is more than the state population`, and
    control drops down to the `end if` statement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个条件都不满足，控制流将进入`else`语句，代码显示`The sum of county population is more than the
    state population`，然后控制流下降到`end if`语句。
- en: case Statements
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`case`语句'
- en: A `case` statement is a way to write complex conditional statements. For example,
    [Listing 11-5](#listing11-5) defines a procedure that uses a `case` statement
    to determine if a state has more than 30 million people, between 10 and 30 million
    people, or less than 10 million people.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句是一种编写复杂条件语句的方式。例如，[Listing 11-5](#listing11-5)定义了一个使用`case`语句的过程，用于判断一个州的人口是超过3000万、在1000万到3000万之间，还是低于1000万。'
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-5: The `p_population_group()` procedure'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 11-5：`p_population_group()`过程
- en: Your `case` statement begins with `case` and ends with `end case`. It has two
    `when` conditions—which are similar to `if` statements—and an `else` statement.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`case`语句以`case`开头，以`end case`结尾。它有两个`when`条件——类似于`if`语句——和一个`else`语句。
- en: When the condition `state_population_var > 30000000` is true, the procedure
    displays `Over 30 Million` ❶ and control flows to the `end case` statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件`state_population_var > 30000000`为真时，过程将显示`Over 30 Million`❶，控制流将进入`end case`语句。
- en: When the condition `state_population_var > 10000000` is true, the procedure
    displays `Between 10M and 30M` ❷ and control flows to the `end case` statement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件`state_population_var > 10000000`为真时，过程将显示`Between 10M and 30M`❷，控制流将进入`end
    case`语句。
- en: If neither `when` condition was met, the `else` statement is executed, the procedure
    displays `Under 10 Million` ❸, and control drops down to the `end case` statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有满足任何`when`条件，`else`语句将被执行，过程显示`Under 10 Million`❸，控制流下降到`end case`语句。
- en: 'You can call your procedure to find out which group a state falls into:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用你的过程来查看一个州属于哪个人口组：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Based on the population retrieved from the database for the state, the `case`
    statement displays the correct population grouping for that state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据从数据库中检索到的该州人口，`case`语句会显示该州的正确人口分组。
- en: Loops
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环
- en: 'You can create *loops* in your procedures to execute parts of your code repeatedly.
    MySQL allows you to create simple loops, `repeat` loops, and `while` loops. This
    procedure uses a simple loop to display the text `Looping Again` over and over:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在过程里创建*循环*，以反复执行代码的一部分。MySQL允许你创建简单循环、`repeat`循环和`while`循环。这个过程使用了一个简单循环，不断显示`Looping
    Again`：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now call the procedure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用这个过程：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You mark the beginning and end of your loop with the `loop` and `end loop` commands.
    The commands between them will be executed repeatedly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过`loop`和`end loop`命令标记你的循环的开始和结束。它们之间的命令将被反复执行。
- en: This procedure displays the text `Looping Again` over and over, theoretically
    forever. This is called an *endless loop* and should be avoided. You created the
    loop but didn’t provide a way for it to stop. Whoops!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会不断显示文本`Looping Again`，理论上会一直持续下去。这就是所谓的*无限循环*，应该避免。你创建了循环，但没有提供停止的方式。哎呀！
- en: If you run this procedure in SQL Workbench, it opens a different result tab
    to display the text `Looping Again` each time you go through the loop. Thankfully,
    MySQL eventually senses that too many result tabs have been opened and gives you
    the option to stop running your procedure ([Figure 11-2](#figure11-2)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在SQL Workbench中运行这个过程，它会打开一个不同的结果标签，每次经过循环时都会显示`Looping Again`文本。幸运的是，MySQL最终会检测到已经打开了太多结果标签，并会给你停止运行过程的选项（[图11-2](#figure11-2)）。
- en: '![](image_fi/503007c11/f11002.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/503007c11/f11002.png)'
- en: 'Figure 11-2: Running an endless loop in MySQL Workbench'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：在MySQL Workbench中运行无限循环
- en: 'To avoid creating endless loops, you must design loops to end when some condition
    has been met. This procedure uses a more sensible simple loop that loops 10 times
    and then stops:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免创建无限循环，你必须设计循环在满足某个条件时结束。这个过程使用了一个更合理的简单循环，它循环10次后停止：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this procedure you define a user variable called `@cnt` (short for *counter*)
    and set it to `0` ❶. You label the loop `msl` (for *more sensible loop*) by preceding
    the `loop` statement with `msl:` ❷. Each time you go around in the loop, you add
    1 to `@cnt` ❸. In order for the loop to end, the value of `@cnt` must reach `10`
    ❹. Once it does, you exit the loop using the `leave` command with the name of
    the loop you want to exit, `msl` ❺.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程里，你定义了一个用户变量`@cnt`（简写为*counter*）并将其设置为`0` ❶。你通过在`loop`语句前加上`msl:`来标记循环为`msl`（*更合理的循环*）❷。每次循环时，你将`@cnt`加1
    ❸。为了使循环结束，`@cnt`的值必须达到`10` ❹。一旦达到，你通过`leave`命令退出循环，并指定要退出的循环名`msl` ❺。
- en: When you call this procedure, it runs the code between the `loop` and `end loop`
    statements 10 times, displaying `Looping Again` each time. After the code has
    been executed 10 times, the loop stops, control drops to the line after the `end
    loop` statement, and the procedure returns control to the caller.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用这个过程时，它会执行`loop`和`end loop`语句之间的代码10次，每次显示`Looping Again`。在代码执行10次后，循环停止，控制权会转到`end
    loop`语句之后的行，然后过程将控制权返回给调用者。
- en: 'You can also code a `repeat` loop with the `repeat...until` syntax, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`repeat...until`语法编写一个`repeat`循环，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code between `repeat` and `end repeat` is the body of your loop. The commands
    between them will be executed repeatedly until `@cnt` equals `10` and then control
    will drop down to the `end` statement. The `until` statement is at the end of
    the loop, so the commands in your loop will be executed at least once, because
    the condition `until @cnt = 10` isn’t checked until you’ve gone through the loop
    the first time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`和`end repeat`之间的代码是你循环的主体。它们之间的命令会被反复执行，直到`@cnt`等于`10`，然后控制权会跳转到`end`语句。`until`语句在循环的末尾，因此你的循环中的命令至少会执行一次，因为在第一次通过循环时，条件`until
    @cnt = 10`并没有被检查。'
- en: 'You can also code a `while` loop using the `while` and `end while` statements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`while`和`end while`语句编写一个`while`循环：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Your `while` command specifies the condition that must be met in order for the
    commands in the loop to be executed. If your condition `@cnt < 10` is met, the
    procedure will `do` the commands in the loop. When the `end while` statement is
    reached, control flows back to the `while` command and you check again if `@cnt`
    is still less than `10`. Once your counter is no longer less than 10, control
    flows to the `end` command and the loop ends.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`while`命令指定了必须满足的条件，才能执行循环中的命令。如果条件`@cnt < 10`满足，程序将`do`循环中的命令。当达到`end while`语句时，控制流回到`while`命令，并再次检查`@cnt`是否仍小于`10`。一旦计数器不再小于10，控制流将转到`end`命令，循环结束。
- en: Loops are a handy way to repeat functionality when you need to perform similar
    tasks again and again. Don’t forget to give your loops a way to exit so that you
    avoid writing endless loops, and if you need your loop to execute at least one
    time, use the `repeat...until` syntax.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是一个方便的方式，当你需要一遍又一遍地执行相似任务时，可以使用它。别忘了给你的循环设置退出条件，这样你就能避免写出无休止的循环，如果你需要循环至少执行一次，可以使用`repeat...until`语法。
- en: Displaying Procedure Results with select
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`select`显示过程结果
- en: Since you can use the `select` statement in procedures, you can write procedures
    that query data from the database and display the results. When you write a query
    you’ll need to run again, you can save it as a procedure and call the procedure
    whenever you need it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以在过程里使用`select`语句，你可以编写查询数据库并显示结果的过程。当你编写一个需要再次运行的查询时，可以将其保存为过程，并在需要时调用该过程。
- en: 'Say you wrote a query that selects the populations of all counties in a state,
    formats them with commas, and orders the counties from largest to smallest. You
    might want to save your work as a procedure and name it `p_get_county_population()`,
    like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 比如你写了一个查询，选择所有县的总人口，并用逗号格式化它们，同时按人口从大到小排序。你可能想把这个工作保存为一个过程，并命名为`p_get_county_population()`，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With that procedure in place, you can call it each time you need that information:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个过程，你可以在每次需要该信息时调用它：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The results show all 62 counties in New York, with their populations formatted
    appropriately:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了纽约州的所有62个县，并适当地格式化了它们的人口：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next time you want to see the latest version of this data, you can just
    call the procedure again.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你想查看该数据的最新版本时，只需再次调用这个过程。
- en: Using `select` in your procedure displays your results. You can also pass values
    back to the caller of the procedure using the `output` parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的过程里使用`select`来显示结果。你还可以通过`output`参数将值传回过程的调用者。
- en: Using a Cursor
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用游标
- en: While SQL is very good at quickly updating or deleting many rows in a table
    at once, you’ll occasionally need to loop through a dataset and process it one
    row at a time. You can accomplish this with a cursor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQL非常擅长快速更新或删除表中的多行数据，但有时你需要循环遍历数据集并一次处理一行。你可以通过游标来实现这一点。
- en: A *cursor* is a database object that selects rows from the database, holds them
    in memory, and allows you to loop through them one at a time. To use a cursor,
    first declare the cursor, then open it, fetch each row from it, and close it.
    These steps are shown in [Figure 11-3](#figure11-3).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*游标*是一个数据库对象，它从数据库中选择行，将它们保存在内存中，并允许你一次处理一行。要使用游标，首先声明游标，然后打开它，从中获取每一行，最后关闭它。这些步骤如[图
    11-3](#figure11-3)所示。'
- en: '![](image_fi/503007c11/f11003.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/503007c11/f11003.png)'
- en: 'Figure 11-3: Steps for using a cursor'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：使用游标的步骤
- en: 'Create a procedure called `p_split_big_ny_counties()` that uses a cursor. The
    procedure will use the `county_population` table, which contains the population
    of each county within a state. New York has 62 counties, the largest of which
    are shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`p_split_big_ny_counties()`的过程，它使用游标。该过程将使用`county_population`表，其中包含每个州的各个县的人口。纽约州有62个县，最大的一些县如下所示：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Imagine you’re a database developer working for the State of New York. You’ve
    been asked to break up counties that have over 2 million people into two smaller
    counties, each containing half of the original county’s population.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个为纽约州工作的数据库开发者。你被要求将人口超过200万的县划分为两个更小的县，每个县的人口是原县的一半。
- en: For example, Kings County has a population of 2,736,074 people. You have been
    asked to create a county called `Kings-1` with 1,368,037 people and another called
    `Kings-2` with the remaining 1,368,037\. Then you need to delete the original
    `Kings` row that had a population of 2,736,074\. You could write the procedure
    shown in [Listing 11-6](#listing11-6) to accomplish this task.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Kings县的人口为2,736,074人。你被要求创建一个名为`Kings-1`的县，人口为1,368,037人，另一个名为`Kings-2`的县，人口也是1,368,037人。然后，你需要删除原来的`Kings`行，原始人口为2,736,074人。你可以编写[列表11-6](#listing11-6)中所示的过程来完成这个任务。
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 11-6: Creating the `p_split_big_ny_counties()` procedure'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-6：创建`p_split_big_ny_counties()`过程
- en: This procedure uses a cursor to select the original state, county, and population
    values from the `county_population` table. You fetch one row at a time from the
    cursor and loop through your `fetch_loop` once per each row until all the rows
    have been processed. Let’s walk through it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程使用游标从`county_population`表中选择原始的州、县和人口值。你每次从游标中获取一行，并循环执行`fetch_loop`，直到所有行都处理完毕。让我们逐步讲解。
- en: First you declare the `v_state`, `v_county`, and `v_population` variables that
    will hold the `state`, `county`, and `population` values for each county with
    more than 2 million people ❶. You also declare a variable named `done` that will
    recognize when there are no more rows for your cursor to fetch. You define the
    `done` variable as a boolean and set its default value to `false` ❷.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明`v_state`、`v_county`和`v_population`变量，用来存储每个超过200万人的县的`state`、`county`和`population`值
    ❶。你还声明了一个名为`done`的变量，用来判断游标是否还有更多行可获取。你将`done`变量定义为布尔型，并将其默认值设置为`false` ❷。
- en: 'Then you declare a cursor, called `county_cursor`, whose `select` statement
    gets all counties from the `county_population` table that have a population of
    over 2 million: Kings and Queens counties, in this example ❸.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你声明一个名为`county_cursor`的游标，它的`select`语句从`county_population`表中获取所有人口超过200万的县：以此示例中的Kings和Queens县为例
    ❸。
- en: Next, you declare a condition handler that will automatically set your `done`
    variable to `true` when your cursor has no more rows to read ❹. *Condition handlers*
    define how MySQL should respond to situations that arise in your procedures. Your
    condition handler handles the condition `not found`; if no more rows are found
    by your `fetch` statement, the procedure will execute the `set done = true` statement,
    which will change the value of your `done` variable from `false` to `true`, letting
    you know that there are no more rows to fetch.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你声明一个条件处理程序，当游标没有更多行可读取时，它会自动将`done`变量设置为`true` ❹。*条件处理程序*定义了MySQL在过程运行中遇到各种情况时的响应。你的条件处理程序处理`not
    found`条件；如果`fetch`语句找不到更多行，过程将执行`set done = true`语句，这将把`done`变量的值从`false`改为`true`，告诉你没有更多行可获取。
- en: When you declare a condition handler, you can choose for it to `continue`—keep
    running the procedure—or `exit` after the condition has been handled. You choose
    `continue` in [Listing 11-6](#listing11-6).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个条件处理程序时，你可以选择让它`continue`—继续执行过程，或者在处理完条件后`exit`。你在[列表11-6](#listing11-6)中选择了`continue`。
- en: Next, you `open` the `county_cursor` that you declared earlier to prepare it
    to be used ❺. You create a `fetch_loop` loop that will fetch and iterate through
    each row of the `county_cursor`, one row at a time ❻. After this, you fetch the
    state, county, and population values for a row from the cursor to your `v_state`,
    `v_county`, and `v_population` variables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你`open`之前声明的`county_cursor`，准备开始使用 ❺。你创建一个`fetch_loop`循环，每次从`county_cursor`中获取一行并进行迭代
    ❻。之后，你将游标中的一行的州、县和人口值获取到`v_state`、`v_county`和`v_population`变量中。
- en: You check your `done` variable ❼. If all the rows have been fetched from the
    cursor, you exit the `fetch_loop` and control flows to the line after the `end
    loop` statement. Then you close your cursor and exit the procedure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你检查`done`变量 ❼。如果所有行都已从游标中获取，你将退出`fetch_loop`，控制流转到`end loop`语句之后的行。然后，你关闭游标并退出过程。
- en: If you aren’t done fetching rows from the cursor, set a user variable called
    `@cnt` to `1` ❽. Then you enter a loop called `split_loop` that will do the work
    of splitting the county into two ❾.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有完成从游标中获取所有行，设置一个用户变量`@cnt`为`1` ❽。然后，你进入一个名为`split_loop`的循环，负责将县分割成两个部分
    ❾。
- en: In `split_loop`, you insert a row into the `county_population` table that has
    a county name with a `-1` or `-2` appended and a `population` that is half of
    the original county’s population. The `-1` or `-2` suffix is controlled by your
    `@cnt` user variable. You start `@cnt` as `1` and each time you loop through the
    `split_loop` loop, you add 1 to it. Then you concatenate the original county name
    to a dash and the `@cnt` variable. You halve the population by dividing your original
    population that is saved in the `v_population` variable by 2.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`split_loop`中，你向`county_population`表插入了一行数据，其中县名加上了`-1`或`-2`后缀，`population`值是原县人口的一半。`-1`或`-2`后缀由你的`@cnt`用户变量控制。你将`@cnt`初始化为`1`，每次循环通过`split_loop`时，你会将它加1。然后，你将原县名与一个短横线和`@cnt`变量拼接。通过将原人口（保存在`v_population`变量中）除以2，你就得到了新的县的半人口。
- en: You can call functions from procedures; for example, you use `concat()` to add
    the suffix to the county name and you use `round()` to make sure the new `population`
    value doesn’t have a fractional part. If there were an odd number of people in
    your original county, you wouldn’t want the population of the new county to be
    a number like 1368036.5.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从过程调用函数；例如，你可以使用`concat()`将后缀添加到县名，使用`round()`确保新的`population`值没有小数部分。如果原县的人口是一个奇数，你不希望新县的人口是像1368036.5这样的小数。
- en: When the `@cnt` variable is more than 2, your work splitting this county is
    done, so you `leave` the `split_loop` and control flows to the line after your
    `end loop split_loop` statement. Then you delete the row for the original county
    from the database ❿.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@cnt`变量大于2时，你的分割县工作的任务完成，此时你`离开`了`split_loop`，控制流跳转到`end loop split_loop`语句之后的那一行。然后，你从数据库中删除原县的记录❿。
- en: You reach the end of your `fetch_loop`, which concludes your work for this county.
    Control flows back to the beginning of the `fetch_loop` where you fetch and begin
    processing for the next county.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你到达了`fetch_loop`的结束，这也标志着你完成了这个县的工作。控制流返回到`fetch_loop`的开头，开始获取并处理下一个县的数据。
- en: Now you can call your procedure
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以调用你的过程了
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'and then look at the largest counties in New York in the database like so:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像这样查看数据库中纽约州最大的人口县：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The results are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Your procedure worked! You now have `Kings-1`, `Kings-2`, `Queens-1`, and `Queens-2`
    counties that are half the size of the original `Kings` and `Queens` counties.
    There are no counties with more than 2 million people, and the original `Kings`
    and `Queens` rows have been removed from the table.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你的过程成功了！你现在拥有`Kings-1`、`Kings-2`、`Queens-1`和`Queens-2`这几个县，它们的规模是原始`Kings`和`Queens`县的一半。没有县的人口超过200万，原始的`Kings`和`Queens`记录已从表中删除。
- en: Declaring Output Parameters
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明输出参数
- en: So far, all the parameters you’ve used in your procedures have been input, but
    procedures also allow you to use output parameters, which pass a value back to
    the procedure caller. As mentioned earlier, this caller may be a person using
    a tool like MySQL Workbench, a program written in another programming language
    like Python or PHP, or another MySQL procedure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在过程里使用的所有参数都是输入参数，但过程也允许你使用输出参数，将值传回给过程调用者。如前所述，调用者可以是使用像MySQL Workbench这样的工具的人员，或是用其他编程语言如Python或PHP编写的程序，或者是另一个MySQL过程。
- en: If the caller of the procedure is an end user who just needs to see some values
    but doesn’t need to do any further processing with them, you can use a `select`
    statement to display the values. But if the caller needs to use the values, you
    can pass them back from your procedure as output parameters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程的调用者是一个仅需查看某些值但不需要进一步处理这些值的最终用户，你可以使用`select`语句来显示这些值。但如果调用者需要使用这些值，你可以通过输出参数将它们从过程传递回来。
- en: 'This procedure, called `p_return_state_population()`, returns the population
    of a state back to the procedure caller using an output parameter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程，叫做`p_return_state_population()`，通过输出参数将一个州的人口返回给过程调用者：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the procedure, you declare an `in` (input) parameter named `state_param`
    as `varchar(100)`, a string of up to 100 characters ❶. Then you define an `out`
    (output) parameter named `current_pop_param` as an `int` ❷. You select the population
    of the state into your output parameter, `current_pop_param`, which will be automatically
    returned to the caller because you declared it as an `out` parameter ❸.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程内，你声明了一个名为`state_param`的`in`（输入）参数，其类型为`varchar(100)`，即一个最多包含100个字符的字符串❶。然后，你定义了一个名为`current_pop_param`的`out`（输出）参数，其类型为`int`❷。你将州的人口选入输出参数`current_pop_param`，因为你将其声明为`out`参数，所以它会自动返回给调用者❸。
- en: 'Now call the procedure using a `call` statement and send `New York` as an input
    parameter. Declare that you want the procedure’s output parameter to be returned
    to you as a new user variable called `@pop_ny`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`call`语句调用过程并传递`New York`作为输入参数。声明你希望将过程的输出参数作为一个新的用户变量`@pop_ny`返回：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The order of the arguments you send to the procedure matches the order of the
    parameters that you defined when you created the procedure. The procedure was
    defined to accept two parameters: `state_param` and `current_pop_param`. When
    you call the procedure, you supply the value of `New York` for the `state_param`
    input parameter. Then you supply `@pop_ny`, which is the name of the variable
    that will accept the procedure’s `current_pop_param` output parameter value.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给过程的参数顺序与创建过程时定义的参数顺序匹配。该过程被定义为接受两个参数：`state_param`和`current_pop_param`。当你调用该过程时，你为`state_param`输入参数提供`New
    York`的值。然后，你提供`@pop_ny`，这是将接受过程的`current_pop_param`输出参数值的变量名称。
- en: 'You can see the results of the procedure by writing a `select` statement that
    displays the value of the `@pop_ny` variable:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写`select`语句来查看过程的结果，该语句显示`@pop_ny`变量的值：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result is:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The population of New York is saved for you in the `@pop_ny` user variable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 纽约的人口已保存至`@pop_ny`用户变量中。
- en: Writing Procedures That Call Other Procedures
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写调用其他过程的过程
- en: 'Procedures can call other procedures. For example, here you create a procedure
    named `p_population_caller()` that calls `p_return_state_population()`, gets the
    value of the `@pop_ny` variable, and does some additional processing with it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 过程可以调用其他过程。例如，这里你创建了一个名为`p_population_caller()`的过程，它调用`p_return_state_population()`，获取`@pop_ny`变量的值，并对其进行一些额外处理：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `p_population_caller()` procedure calls the `p_return_state_population()`
    procedure twice: once with an input parameter of `New York`, which returns a value
    to the `@pop_ny` variable, and once with an input parameter of `New Jersey`, which
    returns a value to the `@pop_nj` variable.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_population_caller()`过程调用了`p_return_state_population()`过程两次：一次使用`New York`作为输入参数，返回值给`@pop_ny`变量，另一次使用`New
    Jersey`作为输入参数，返回值给`@pop_nj`变量。'
- en: You then create a new user variable called `@pop_ny_and_nj` and use it to hold
    the combined populations of New York and New Jersey, by adding `@pop_ny` and `@pop_nj`.
    Then you display the value of the `@pop_ny_and_nj` variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建了一个新的用户变量`@pop_ny_and_nj`，并用它保存纽约和新泽西的合并人口，将`@pop_ny`和`@pop_nj`相加。接着，你显示`@pop_ny_and_nj`变量的值。
- en: 'Run your caller procedure using the `call` statement:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`call`语句运行你的调用过程：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result is:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The total population displayed from the caller procedure is 29,468,379, which
    is the sum of 20,201,249 people in New York and 9,267,130 in New Jersey.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用过程显示的总人口为29,468,379人，这是20,201,249名纽约人和9,267,130名新泽西人之和。
- en: Listing the Stored Routines in a Database
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出数据库中的存储过程
- en: 'To get a list of the functions and procedures stored in a database, you can
    query the `routines` table in the `information_schema` database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取存储在数据库中的函数和过程列表，可以查询`information_schema`数据库中的`routines`表：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The results are:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, this query returns a list of functions and procedures in the
    `population` database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，此查询返回了`population`数据库中的函数和过程列表。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to create and call procedures and functions. You
    used `if` statements, `case` statements, and repeatedly executed functionality
    with loops. You also saw the benefit of using cursors to process one row at a
    time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了创建和调用过程及函数。你使用了`if`语句、`case`语句，并通过循环反复执行功能。你还看到了使用游标逐行处理数据的好处。
- en: In the next chapter, you’ll create triggers to automatically fire and perform
    processing for you based on events like rows getting inserted or deleted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将创建触发器，以便根据诸如行插入或删除等事件自动触发并执行处理。
