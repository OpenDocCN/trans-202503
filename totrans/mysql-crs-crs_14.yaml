- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Functions and Procedures
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 8](c08.xhtml), you learned how to call built-in MySQL functions;
    in this chapter, you’ll write your own. You’ll also learn to write procedures
    and explore the key differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll add logic to your functions and procedures using `if` statements, loops,
    cursors, and `case` statements to perform different tasks based on the value of
    your data. Lastly, you’ll practice accepting values in your functions and procedures
    and returning values.
  prefs: []
  type: TYPE_NORMAL
- en: Functions vs. Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions and procedures are programs you can call by name. Because they’re
    saved in your MySQL database, they are sometimes called *stored* functions and
    procedures. Collectively, they are referred to as *stored routines* or *stored
    programs*. When you write a complex SQL statement or a group of statements with
    several steps, you should save it as a function or procedure so you can easily
    call it by name later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between a function and a procedure is that a function gets
    called from a SQL statement and always returns one value. A procedure, on the
    other hand, gets called explicitly using a `call` statement. Procedures also pass
    values back to the caller differently than functions. (Note that the caller may
    be a person using a tool like MySQL Workbench, a program written in a programming
    language like Python or PHP, or another MySQL procedure.) While procedures may
    return no values, one value, or many values, a function accepts arguments, performs
    some task, and returns a single value. For example, you might find the population
    of New York by calling the `f_get_state_population()` function from a `select`
    statement, passing in the state name as an argument to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You pass an argument to a function by putting it between the parentheses. To
    pass more than one argument, separate them by commas. The function accepts the
    argument, does some processing that you defined when you created the function,
    and returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `f_get_state_population()` function took the text `New York` as an argument,
    did a lookup in your database to find the population, and returned `19299981`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also call functions in the `where` clause of SQL statements, such as
    the following example that returns every `state_population` greater than New York’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you called the function `f_get_state_population()` with an argument of
    `New York`. The function returned the value `19299981`, which caused your query
    to evaluate to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your query returned data from the `state` table for states with a population
    greater than 19,299,981:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Procedures, on the other hand, are not called from SQL queries, but instead
    via the `call` statement. You pass in any arguments the procedure has been designed
    to accept, the procedure performs the tasks you defined, and then control returns
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you call a procedure named `p_set_state_population()` and pass
    it an argument of `New York` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see how to create the `p_set_state_population()` procedure and define
    its tasks in [Listing 11-2](#listing11-2). For now, just know that this is the
    syntax for calling a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures are often used to execute business logic by updating, inserting,
    and deleting records in tables, and they can also be used to display a dataset
    from the database. Functions are used for smaller tasks, like getting one piece
    of data from the database or formatting a value. Sometimes you can implement the
    same functionality as either a procedure or a function.
  prefs: []
  type: TYPE_NORMAL
- en: Like tables and views, functions and procedures are saved in the database where
    you created them. You can set the current database with the `use` command; then,
    when you define a procedure or function, it will be created in that database.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to call functions and procedures, let’s look at how
    to create them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Listing 11-1](#listing11-1) defines the `f_get_state_population()` function,
    which accepts a state’s name and returns the population of the state.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: Creating the `f_get_state_population()` function'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, you set the current database to `population` with the `use`
    command ❶ so your function will be created in that database.
  prefs: []
  type: TYPE_NORMAL
- en: Before you create the function, you use the `drop function` statement in case
    there’s already a version of this function. If you try to create a function and
    an old version already exists, MySQL will send a `function already exists` error
    and won’t create the function. Similarly, if you try to drop a function that doesn’t
    already exist, MySQL will also send an error. To prevent that error from appearing,
    you add `if exists` after `drop function` ❷, which will drop the function if it
    already exists, but won’t send an error if it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: The function itself is defined between the `create function` ❸ and `end` statements
    ❹. We’ll walk through its components in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Redefining the Delimiter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function definition also includes lines of code to redefine and then reset
    your delimiter. A *delimiter* is one or more characters that separate one SQL
    statement from another and mark the end of each statement. Typically, you’ll use
    a semicolon as the delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-1](#listing11-1), you temporarily set the MySQL delimiter to
    `//` using the `delimiter //` statement because your function is made up of multiple
    SQL statements that end in a semicolon. For example, `f_get_state_population()`
    has three semicolons, located after the `declare` statement, the `select` statement,
    and the `return` statement. To ensure that MySQL creates your function starting
    with the `create function` statement and ending with the `end` statement, you
    need a way to tell it not to interpret any semicolons between those two statements
    as the end of your function. This is why you’ve redefined the delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at what would happen if you didn’t redefine your delimiter.
    If you remove or comment out the `delimiter //` statement at the beginning of
    your code and look at it in MySQL Workbench, you’ll notice some red X markers
    on lines 12 and 19, indicating errors ([Figure 11-1](#figure11-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c11/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: MySQL Workbench showing errors on lines 12 and 19'
  prefs: []
  type: TYPE_NORMAL
- en: You commented out the `delimiter` statement on line 5 by adding two hyphens
    and a space (`--` ) in front of it; this caused MySQL Workbench to report errors
    on lines 12 and 19 because the semicolon has become the delimiter character. Thus,
    every time MySQL encounters a semicolon, it assumes that is the end of a SQL statement.
    MySQL Workbench tries to help you by showing error markers with a red X to let
    you know the statements ending in semicolons aren’t valid.
  prefs: []
  type: TYPE_NORMAL
- en: Redefining the delimiter to `//` (or something other than `;`) informs MySQL
    Workbench that the statements creating your function aren’t over until it hits
    `//` at the end of line 21\. You can fix the errors by uncommenting line 5 (removing
    the two hyphens and a space, `--` , at the beginning of the line), thereby reinserting
    the `delimiter //` command.
  prefs: []
  type: TYPE_NORMAL
- en: After the function has been created, you set the delimiter back to the semicolon
    on line 23.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although redefining the delimiter to `//` is necessary here because your function
    body contains three semicolons, there are other situations where you don’t need
    to redefine your delimiter. For example, you can simplify the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `begin` and `end` keywords group statements that are part of the function
    body. Since this function body has only one SQL statement, returning the world
    population, you don’t need to use `begin` and `end` here. And you don’t need to
    redefine your delimiter, either, because there’s only one semicolon—at the end
    of the `return` statement. You can remove the code that redefines and resets the
    delimiter and simplify your function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While this is a more concise way to write the function, you might want to keep
    the `begin` and `end` statements and redefine the delimiter because it makes it
    easier to add a second SQL statement in the future. The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Parameters and Returning a Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both built-in functions and custom functions can accept parameters. You created
    the `f_get_state_population()` function in [Listing 11-1](#listing11-1) to accept
    one parameter named `state_param`, which has a `varchar(100)` data type. You can
    define parameters with the data types in [Chapter 4](c04.xhtml), including `int`,
    `date`, `decimal`, and `text`, to define a table’s columns.
  prefs: []
  type: TYPE_NORMAL
- en: Because functions return a value to the caller of the function, you use the
    `returns` keyword in [Listing 11-1](#listing11-1) to let MySQL know the data type
    of the value that your function will return. In this case, the function will return
    an integer, representing the population of a state.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Characteristics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Listing 11-1](#listing11-1), once you establish that your function returns
    an integer, you specify some characteristics of your function. A *characteristic*
    is an attribute or property of the function. In this example, you used the `deterministic`
    and `reads sql data` characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list the characteristics on one line, or you can list each characteristic
    on its own line, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to choose from two sets of characteristics: `deterministic` or `not
    deterministic`, and `reads sql data`, `modifies sql data`, `contains sql`, or
    `no sql`. You must specify at least one of these three characteristics for all
    of your functions: `deterministic`, `no sql`, or `reads sql data`. If you don’t,
    MySQL will send an error message and won’t create your function.'
  prefs: []
  type: TYPE_NORMAL
- en: deterministic or not deterministic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Choosing `deterministic` means the function will return the same value given
    the same arguments and the same state of the database. This is usually the case.
    The `f_get_state_population()` function is deterministic because, unless the data
    in the database changes, every time you call `f_get_state_population()` with an
    argument of `New York`, the function will return the value `19299981`.
  prefs: []
  type: TYPE_NORMAL
- en: The `not deterministic` characteristic means that the function may not return
    the same value given the same arguments and the same state of the database. This
    would be the case for a function that returns the current date, for example, as
    calling it today will yield a different return value than calling it tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: If you tag a nondeterministic function as `deterministic`, you might get incorrect
    results when you call your function. If you tag a deterministic function as `not
    deterministic`, your function might run slower than necessary. If you don’t define
    a function as `deterministic` or `not deterministic`, MySQL defaults to `not deterministic`.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL uses `deterministic` or `not deterministic` for two purposes. First, MySQL
    has a query optimizer that determines the fastest way to execute queries. Specifying
    `deterministic` or `not deterministic` helps the query optimizer make good execution
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: Second, MySQL has a binary log that keeps track of changes to data in the database.
    The binary log is used to perform *replication*, a process in which data from
    one MySQL database server is copied to another server, known as a *replica*. Specifying
    `deterministic` or `not deterministic` helps MySQL perform this replication.
  prefs: []
  type: TYPE_NORMAL
- en: reads sql data, modifies sql data, contains sql, or no sql
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `reads sql` `data` characteristic means that the function reads from the
    database using `select` statements but doesn’t update, delete, or insert any data;
    `modifies sql data`, on the other hand, means that the function does update, delete,
    or insert data. This would be the case more for procedures than for functions
    because procedures are more commonly used for modifying data in the database than
    functions are.
  prefs: []
  type: TYPE_NORMAL
- en: The `contains sql` characteristic means the function has at least one SQL statement
    but doesn’t read or write any data from the database, and `no sql` means the function
    contains no SQL statements. An example of `no sql` would be a function that returns
    a hardcoded number, in which case it doesn’t query the database. You could, for
    example, write a function that always returns `212` so that you don’t need to
    remember the temperature at which water boils.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t specify `reads sql data`, `modifies sql data`, `contains sql`,
    or `no sql`, MySQL defaults to `contains sql`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Function Body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After listing the characteristics, you define the function body, the block of
    code that gets executed when the function is called. You use a `begin` and an
    `end` statement to mark the beginning and end of the function body.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-1](#listing11-1), you declared a variable named `population_var`
    with the `declare` keyword. Variables are named objects that can hold values.
    You can declare them with any of the MySQL data types; in this case, you used
    the `int` type. You’ll learn about different types of variables in the section
    “Defining Local Variables and User Variables” later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then you add a `select` statement that selects the population from your database
    and writes it into your `population_var` variable. This `select` statement is
    similar to those you’ve used before, except you’re now using the `into` keyword
    to select the value you got from the database into a variable.
  prefs: []
  type: TYPE_NORMAL
- en: You then return the value of `population_var` to the caller of the function
    with a `return` statement. Since functions always return one value, there must
    be a `return` statement in your function. The data type of the value being returned
    must match the `returns` statement at the beginning of the function. You use `returns`
    to declare the data type of the value you’ll return, and `return` to actually
    return the value.
  prefs: []
  type: TYPE_NORMAL
- en: Your `end` statement is followed by `//` because you redefined your delimiter
    to `//` earlier. Once you reach the `end` statement, your function body is complete,
    so you redefine your delimiter back to a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to functions, procedures accept parameters, include a code block surrounded
    by `begin` and `end`, can have defined variables, and can have a redefined delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike functions, procedures don’t use the `returns` or `return` keyword because
    procedures don’t return one value in the way that functions do. Also, you can
    display values in procedures using the `select` keyword. Additionally, while MySQL
    requires you to specify characteristics like `deterministic` or `reads sql data`
    when creating functions, this is not required for procedures.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](#listing11-2) creates a procedure called `p_set_state_population()`
    that accepts a parameter for the state’s name, gets the latest population values
    for each county in the state from the `county_population` table, sums the populations,
    and writes the total population to the `state_population` table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Creating the `p_set_state_population()` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: First, you set your current database to `population` with `use` so the procedure
    will be created in the `population` database ❶. Before creating the procedure,
    you check to see if it already exists, and if it does, the old version is deleted
    with the `drop` command ❷. Then you redefine your delimiter to `//` just as you
    did when creating functions ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you create the procedure and call it `p_set_state_population()` ❹. As
    with functions, you name the parameter `state_param` and give it a `varchar(100)`
    data type, and you also specify `in` to set `state_param` as an input parameter
    ❺. Let’s look at this step a little closer.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike functions, procedures can accept parameter values as input and also pass
    values back to the caller as output. They can also accept multiple input and output
    parameters. (You’ll explore output parameters in depth later in this chapter.)
    When you write procedures, you specify the type of parameter using the keyword
    `in` for input, `out` for output, or `inout` for parameters that are both. This
    specification isn’t necessary for functions because function parameters are always
    assumed to be input. If you don’t specify `in`, `out`, or `inout` for your procedure
    parameters, MySQL defaults to `in`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the procedure body is between the `begin` and `end` statements. In this
    body, you delete the existing row in the `state_population` table for the state
    (if one exists) ❻, then insert a new row into the `state_population` table ❼.
    If you don’t delete the existing row(s) first, the table will have a row for every
    time you run the procedure. You want to start with a clean slate before you write
    the current information to the `state_population` table.
  prefs: []
  type: TYPE_NORMAL
- en: You get the state’s population by summing the populations of the individual
    counties in that state from the `county_population` table ❽.
  prefs: []
  type: TYPE_NORMAL
- en: As you did with functions, when you’re done defining the procedure you redefine
    your delimiter to a semicolon ❾.
  prefs: []
  type: TYPE_NORMAL
- en: Using select to Display Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create procedures and functions, you can use the `select...into` syntax
    to write a value from the database into a variable. But unlike functions, procedures
    can also use `select` statements without the `into` keyword to display values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-3](#listing11-3) creates a procedure called `p_set_and_show_state_population()`
    to select the population of the state into a variable and then display a message
    to the procedure caller.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Creating the `p_set_and_show_state_population()` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: In this procedure, you declare a variable called `population_var` as an integer
    ❶ and insert the sum of the county populations into it using a `select...into`
    statement ❷. Then you insert the `state_param` parameter value and the `population_var`
    variable value into your `state_population` table ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call the procedure, it not only sets the correct population of New
    York in the `state_population` table, but also displays an informative message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The message displayed is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You used `select` to display the message, which you built by concatenating (using
    the `concat()` function), the text `Setting the population for`, the `state_param`
    value, the word `to`, and the `population_var` value ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Local Variables and User Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `population_var` variable is a local variable. *Local variables* are variables
    that you define in your procedures and functions using the `declare` command with
    a data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Local variables are only available—or *in scope*—during the execution of the
    procedure or function containing them. Because you’ve defined `population_var`
    as an `int`, it will accept only integer values.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use a *user variable*, which starts with the at sign (`@`) and
    can be used for the entire length of your session. As long as you’re connected
    to your MySQL server, the user variable will be in scope. If you create a user
    variable from MySQL Workbench, for example, it will be available until you close
    the tool.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a local variable, you must specify its data type; when creating
    a user variable, it’s not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see code in a function or procedure that uses both local variables
    and user variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You never declared the `@user_var` variable with a data type like `int`, `char`,
    or `bool`, but because it was being set to an integer value (the `local_var` value
    plus 3), MySQL automatically set it to `int` for you.
  prefs: []
  type: TYPE_NORMAL
- en: Using Logic in Procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In procedures, you can use similar programming logic to what you’d use in programming
    languages like Python, Java, or PHP. For example, you can control the flow of
    execution with conditional statements like `if` and `case` to execute parts of
    your code under specific conditions. You can also use loops to repeatedly execute
    parts of your code.
  prefs: []
  type: TYPE_NORMAL
- en: if Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `if` statement is a decision-making statement that executes particular lines
    of code if a condition is true. [Listing 11-4](#listing11-4) creates a procedure
    called `p_compare_population()` that compares the population in the `state_population`
    table to the `county_population` table. If the population values match, it returns
    one message. If they don’t, it returns another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: The `p_compare_population()` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: In the first `select` statement, you select the population for the state from
    the `state_population` table and write it into the `state_population_var` variable
    ❶. Then, in the second `select` statement, you select the sum of the populations
    for each county in the state from the `county_population` table and write it into
    the `county_population_var` variable ❷. You compare the two variables with the
    `if...then` syntax. You’re saying `if` the values match ❸, `then` execute the
    line that displays the message `The population values match`; `else` (otherwise)
    ❹, execute the next line, displaying the message `The population values are different`.
    Then you use `end if` to mark the end of the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You call the procedure using the following `call` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The procedure shows that the values in the two tables don’t match. Perhaps the
    population table for the counties contains updated data, but the `state_population`
    table hasn’t been updated yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL provides the `elseif` keyword to check for more conditions. You could
    expand your `if` statement to display one of *three* messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first condition checks whether the `state_population_var` value equals the
    `county_population_var` value. If that condition is true, the code displays the
    text `The population values match` and control flows to the `end if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If the first condition was not met, the code checks the `elseif` condition,
    which sees if `state_population_var` is greater than `county_population_var`.
    If that condition is true, your code displays the text `State population is more
    than the sum of county population` and control flows to the `end if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If neither condition is met, control flows to the `else` statement, the code
    displays `The sum of county population is more than the state population`, and
    control drops down to the `end if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: case Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `case` statement is a way to write complex conditional statements. For example,
    [Listing 11-5](#listing11-5) defines a procedure that uses a `case` statement
    to determine if a state has more than 30 million people, between 10 and 30 million
    people, or less than 10 million people.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: The `p_population_group()` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: Your `case` statement begins with `case` and ends with `end case`. It has two
    `when` conditions—which are similar to `if` statements—and an `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: When the condition `state_population_var > 30000000` is true, the procedure
    displays `Over 30 Million` ❶ and control flows to the `end case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: When the condition `state_population_var > 10000000` is true, the procedure
    displays `Between 10M and 30M` ❷ and control flows to the `end case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If neither `when` condition was met, the `else` statement is executed, the procedure
    displays `Under 10 Million` ❸, and control drops down to the `end case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call your procedure to find out which group a state falls into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Based on the population retrieved from the database for the state, the `case`
    statement displays the correct population grouping for that state.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can create *loops* in your procedures to execute parts of your code repeatedly.
    MySQL allows you to create simple loops, `repeat` loops, and `while` loops. This
    procedure uses a simple loop to display the text `Looping Again` over and over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now call the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You mark the beginning and end of your loop with the `loop` and `end loop` commands.
    The commands between them will be executed repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure displays the text `Looping Again` over and over, theoretically
    forever. This is called an *endless loop* and should be avoided. You created the
    loop but didn’t provide a way for it to stop. Whoops!
  prefs: []
  type: TYPE_NORMAL
- en: If you run this procedure in SQL Workbench, it opens a different result tab
    to display the text `Looping Again` each time you go through the loop. Thankfully,
    MySQL eventually senses that too many result tabs have been opened and gives you
    the option to stop running your procedure ([Figure 11-2](#figure11-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c11/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Running an endless loop in MySQL Workbench'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid creating endless loops, you must design loops to end when some condition
    has been met. This procedure uses a more sensible simple loop that loops 10 times
    and then stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this procedure you define a user variable called `@cnt` (short for *counter*)
    and set it to `0` ❶. You label the loop `msl` (for *more sensible loop*) by preceding
    the `loop` statement with `msl:` ❷. Each time you go around in the loop, you add
    1 to `@cnt` ❸. In order for the loop to end, the value of `@cnt` must reach `10`
    ❹. Once it does, you exit the loop using the `leave` command with the name of
    the loop you want to exit, `msl` ❺.
  prefs: []
  type: TYPE_NORMAL
- en: When you call this procedure, it runs the code between the `loop` and `end loop`
    statements 10 times, displaying `Looping Again` each time. After the code has
    been executed 10 times, the loop stops, control drops to the line after the `end
    loop` statement, and the procedure returns control to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also code a `repeat` loop with the `repeat...until` syntax, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code between `repeat` and `end repeat` is the body of your loop. The commands
    between them will be executed repeatedly until `@cnt` equals `10` and then control
    will drop down to the `end` statement. The `until` statement is at the end of
    the loop, so the commands in your loop will be executed at least once, because
    the condition `until @cnt = 10` isn’t checked until you’ve gone through the loop
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also code a `while` loop using the `while` and `end while` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Your `while` command specifies the condition that must be met in order for the
    commands in the loop to be executed. If your condition `@cnt < 10` is met, the
    procedure will `do` the commands in the loop. When the `end while` statement is
    reached, control flows back to the `while` command and you check again if `@cnt`
    is still less than `10`. Once your counter is no longer less than 10, control
    flows to the `end` command and the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: Loops are a handy way to repeat functionality when you need to perform similar
    tasks again and again. Don’t forget to give your loops a way to exit so that you
    avoid writing endless loops, and if you need your loop to execute at least one
    time, use the `repeat...until` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying Procedure Results with select
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since you can use the `select` statement in procedures, you can write procedures
    that query data from the database and display the results. When you write a query
    you’ll need to run again, you can save it as a procedure and call the procedure
    whenever you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you wrote a query that selects the populations of all counties in a state,
    formats them with commas, and orders the counties from largest to smallest. You
    might want to save your work as a procedure and name it `p_get_county_population()`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With that procedure in place, you can call it each time you need that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show all 62 counties in New York, with their populations formatted
    appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next time you want to see the latest version of this data, you can just
    call the procedure again.
  prefs: []
  type: TYPE_NORMAL
- en: Using `select` in your procedure displays your results. You can also pass values
    back to the caller of the procedure using the `output` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Cursor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While SQL is very good at quickly updating or deleting many rows in a table
    at once, you’ll occasionally need to loop through a dataset and process it one
    row at a time. You can accomplish this with a cursor.
  prefs: []
  type: TYPE_NORMAL
- en: A *cursor* is a database object that selects rows from the database, holds them
    in memory, and allows you to loop through them one at a time. To use a cursor,
    first declare the cursor, then open it, fetch each row from it, and close it.
    These steps are shown in [Figure 11-3](#figure11-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c11/f11003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Steps for using a cursor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a procedure called `p_split_big_ny_counties()` that uses a cursor. The
    procedure will use the `county_population` table, which contains the population
    of each county within a state. New York has 62 counties, the largest of which
    are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Imagine you’re a database developer working for the State of New York. You’ve
    been asked to break up counties that have over 2 million people into two smaller
    counties, each containing half of the original county’s population.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Kings County has a population of 2,736,074 people. You have been
    asked to create a county called `Kings-1` with 1,368,037 people and another called
    `Kings-2` with the remaining 1,368,037\. Then you need to delete the original
    `Kings` row that had a population of 2,736,074\. You could write the procedure
    shown in [Listing 11-6](#listing11-6) to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: Creating the `p_split_big_ny_counties()` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure uses a cursor to select the original state, county, and population
    values from the `county_population` table. You fetch one row at a time from the
    cursor and loop through your `fetch_loop` once per each row until all the rows
    have been processed. Let’s walk through it.
  prefs: []
  type: TYPE_NORMAL
- en: First you declare the `v_state`, `v_county`, and `v_population` variables that
    will hold the `state`, `county`, and `population` values for each county with
    more than 2 million people ❶. You also declare a variable named `done` that will
    recognize when there are no more rows for your cursor to fetch. You define the
    `done` variable as a boolean and set its default value to `false` ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you declare a cursor, called `county_cursor`, whose `select` statement
    gets all counties from the `county_population` table that have a population of
    over 2 million: Kings and Queens counties, in this example ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you declare a condition handler that will automatically set your `done`
    variable to `true` when your cursor has no more rows to read ❹. *Condition handlers*
    define how MySQL should respond to situations that arise in your procedures. Your
    condition handler handles the condition `not found`; if no more rows are found
    by your `fetch` statement, the procedure will execute the `set done = true` statement,
    which will change the value of your `done` variable from `false` to `true`, letting
    you know that there are no more rows to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: When you declare a condition handler, you can choose for it to `continue`—keep
    running the procedure—or `exit` after the condition has been handled. You choose
    `continue` in [Listing 11-6](#listing11-6).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you `open` the `county_cursor` that you declared earlier to prepare it
    to be used ❺. You create a `fetch_loop` loop that will fetch and iterate through
    each row of the `county_cursor`, one row at a time ❻. After this, you fetch the
    state, county, and population values for a row from the cursor to your `v_state`,
    `v_county`, and `v_population` variables.
  prefs: []
  type: TYPE_NORMAL
- en: You check your `done` variable ❼. If all the rows have been fetched from the
    cursor, you exit the `fetch_loop` and control flows to the line after the `end
    loop` statement. Then you close your cursor and exit the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t done fetching rows from the cursor, set a user variable called
    `@cnt` to `1` ❽. Then you enter a loop called `split_loop` that will do the work
    of splitting the county into two ❾.
  prefs: []
  type: TYPE_NORMAL
- en: In `split_loop`, you insert a row into the `county_population` table that has
    a county name with a `-1` or `-2` appended and a `population` that is half of
    the original county’s population. The `-1` or `-2` suffix is controlled by your
    `@cnt` user variable. You start `@cnt` as `1` and each time you loop through the
    `split_loop` loop, you add 1 to it. Then you concatenate the original county name
    to a dash and the `@cnt` variable. You halve the population by dividing your original
    population that is saved in the `v_population` variable by 2.
  prefs: []
  type: TYPE_NORMAL
- en: You can call functions from procedures; for example, you use `concat()` to add
    the suffix to the county name and you use `round()` to make sure the new `population`
    value doesn’t have a fractional part. If there were an odd number of people in
    your original county, you wouldn’t want the population of the new county to be
    a number like 1368036.5.
  prefs: []
  type: TYPE_NORMAL
- en: When the `@cnt` variable is more than 2, your work splitting this county is
    done, so you `leave` the `split_loop` and control flows to the line after your
    `end loop split_loop` statement. Then you delete the row for the original county
    from the database ❿.
  prefs: []
  type: TYPE_NORMAL
- en: You reach the end of your `fetch_loop`, which concludes your work for this county.
    Control flows back to the beginning of the `fetch_loop` where you fetch and begin
    processing for the next county.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can call your procedure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'and then look at the largest counties in New York in the database like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Your procedure worked! You now have `Kings-1`, `Kings-2`, `Queens-1`, and `Queens-2`
    counties that are half the size of the original `Kings` and `Queens` counties.
    There are no counties with more than 2 million people, and the original `Kings`
    and `Queens` rows have been removed from the table.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Output Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, all the parameters you’ve used in your procedures have been input, but
    procedures also allow you to use output parameters, which pass a value back to
    the procedure caller. As mentioned earlier, this caller may be a person using
    a tool like MySQL Workbench, a program written in another programming language
    like Python or PHP, or another MySQL procedure.
  prefs: []
  type: TYPE_NORMAL
- en: If the caller of the procedure is an end user who just needs to see some values
    but doesn’t need to do any further processing with them, you can use a `select`
    statement to display the values. But if the caller needs to use the values, you
    can pass them back from your procedure as output parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This procedure, called `p_return_state_population()`, returns the population
    of a state back to the procedure caller using an output parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the procedure, you declare an `in` (input) parameter named `state_param`
    as `varchar(100)`, a string of up to 100 characters ❶. Then you define an `out`
    (output) parameter named `current_pop_param` as an `int` ❷. You select the population
    of the state into your output parameter, `current_pop_param`, which will be automatically
    returned to the caller because you declared it as an `out` parameter ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now call the procedure using a `call` statement and send `New York` as an input
    parameter. Declare that you want the procedure’s output parameter to be returned
    to you as a new user variable called `@pop_ny`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the arguments you send to the procedure matches the order of the
    parameters that you defined when you created the procedure. The procedure was
    defined to accept two parameters: `state_param` and `current_pop_param`. When
    you call the procedure, you supply the value of `New York` for the `state_param`
    input parameter. Then you supply `@pop_ny`, which is the name of the variable
    that will accept the procedure’s `current_pop_param` output parameter value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the results of the procedure by writing a `select` statement that
    displays the value of the `@pop_ny` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The population of New York is saved for you in the `@pop_ny` user variable.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Procedures That Call Other Procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Procedures can call other procedures. For example, here you create a procedure
    named `p_population_caller()` that calls `p_return_state_population()`, gets the
    value of the `@pop_ny` variable, and does some additional processing with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `p_population_caller()` procedure calls the `p_return_state_population()`
    procedure twice: once with an input parameter of `New York`, which returns a value
    to the `@pop_ny` variable, and once with an input parameter of `New Jersey`, which
    returns a value to the `@pop_nj` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: You then create a new user variable called `@pop_ny_and_nj` and use it to hold
    the combined populations of New York and New Jersey, by adding `@pop_ny` and `@pop_nj`.
    Then you display the value of the `@pop_ny_and_nj` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your caller procedure using the `call` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The total population displayed from the caller procedure is 29,468,379, which
    is the sum of 20,201,249 people in New York and 9,267,130 in New Jersey.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the Stored Routines in a Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a list of the functions and procedures stored in a database, you can
    query the `routines` table in the `information_schema` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this query returns a list of functions and procedures in the
    `population` database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to create and call procedures and functions. You
    used `if` statements, `case` statements, and repeatedly executed functionality
    with loops. You also saw the benefit of using cursors to process one row at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll create triggers to automatically fire and perform
    processing for you based on events like rows getting inserted or deleted.
  prefs: []
  type: TYPE_NORMAL
