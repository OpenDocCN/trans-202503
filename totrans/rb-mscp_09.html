<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Metaprogramming"><div class="titlepage"><div><div><h1 class="title"><a id="metaprogramming"/>Chapter 9. Metaprogramming</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00206"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Metaprogramming becomes much easier to understand once you learn how Ruby implements it internally.</em></span></p></blockquote></div><p>One of the most confusing and daunting subjects Ruby developers face is <span class="emphasis"><em>metaprogramming</em></span>. Metaprogramming, as indicated by the prefix <span class="emphasis"><em>meta</em></span>, literally means to program at a different or higher level of abstraction. Ruby provides many different ways for you to do this, allowing your program to inspect and change itself dynamically. In Ruby, your program can change itself!</p><p>Some of Ruby’s metaprogramming features allow your program to query for information about itself—for example, information about methods, instance variables, and superclasses. Other metaprogramming features allow you to perform normal tasks, such as defining a method or a constant, in an alternative and more flexible manner. Finally, methods such as <code class="literal">eval</code> allow your program to write new Ruby code from scratch, calling the parser and compiler at run time.</p><p>In this chapter, we’ll focus on two important aspects of metaprogramming. First, we’ll look at how you can alter the standard method definition process, the most common and practical use for metaprogramming. We’ll learn what Ruby normally does to assign a method to a class and how this is related to lexical scope. Then, we’ll look at alternative ways to define methods using metaclasses and singleton classes. We’ll also learn how Ruby implements the new, experimental refinements feature, allowing you to define methods and activate them later if you wish.</p><div class="sidebar"><a id="roadmap-id00034"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch09.html#alternative_ways_to_define_methods" title="Alternative Ways to Define Methods">Alternative Ways to Define Methods</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch09.html#rubyapostrophes_normal_method_definition" title="Ruby’s Normal Method Definition Process">Ruby’s Normal Method Definition Process</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#defining_class_methods_using_an_object_p" title="Defining Class Methods Using an Object Prefix">Defining Class Methods Using an Object Prefix</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#defining_class_methods_using_a_new_lexic" title="Defining Class Methods Using a New Lexical Scope">Defining Class Methods Using a New Lexical Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#defining_methods_using_singleton_classes" title="Defining Methods Using Singleton Classes">Defining Methods Using Singleton Classes</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#defining_methods_using_singleton-id00037" title="Defining Methods Using Singleton Classes in a Lexical Scope">Defining Methods Using Singleton Classes in a Lexical Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#creating_refinements" title="Creating Refinements">Creating Refinements</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#using_refinements" title="Using Refinements">Using Refinements</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch09.html#experiment_9-1_who_am_iquestion_mark_how" title="Experiment 9-1: Who Am I? How self Changes with Lexical Scope">Experiment 9-1: Who Am I? How self Changes with Lexical Scope</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch09.html#self_in_the_top_scope" title="self in the Top Scope">self in the Top Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#self_in_a_class_scope" title="self in a Class Scope">self in a Class Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#self_in_a_metaclass_scope" title="self in a Metaclass Scope">self in a Metaclass Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#self_inside_a_class_method" title="self Inside a Class Method">self Inside a Class Method</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch09.html#metaprogramming_and_closures_evalcomma_i" title="Metaprogramming and Closures: eval, instance_eval, and binding">Metaprogramming and Closures: eval, instance_eval, and binding</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch09.html#code_that_writes_code" title="Code That Writes Code">Code That Writes Code</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#calling_eval_and_accessing_values_from_t" title="Figure 9-16. Calling eval and accessing values from the parent scope">Figure 9-16</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#instanceunderscoreeval_example" title="An instance_eval Example">An instance_eval Example</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#another_important_part_of_ruby_closures" title="Another Important Part of Ruby Closures">Another Important Part of Ruby Closures</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#instanceunderscoreeval_changes_self_to_t" title="instance_eval Changes self to the Receiver">instance_eval Changes self to the Receiver</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#instanceunderscoreeval_creates_a_singlet" title="instance_eval Creates a Singleton Class for a New Lexical Scope">instance_eval Creates a Singleton Class for a New Lexical Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#how_ruby_keeps_track_of_lexical_scope_fo" title="How Ruby Keeps Track of Lexical Scope for Blocks">How Ruby Keeps Track of Lexical Scope for Blocks</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch09.html#experiment_9-2_using_a_closure_to_define" title="Experiment 9-2: Using a Closure to Define a Method">Experiment 9-2: Using a Closure to Define a Method</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch09.html#using_defineunderscoremethod" title="Using define_method">Using define_method</a></p></li><li class="listitem"><p><a class="xref" href="ch09.html#methods_acting_as_closures" title="Methods Acting as Closures">Methods Acting as Closures</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch09.html#summary-id00038" title="Summary">Summary</a></p></li></ul></div></div><p><a class="indexterm" id="iddle1152"/><a class="indexterm" id="iddle1229"/><a class="indexterm" id="iddle1232"/><a class="indexterm" id="iddle1504"/><a class="indexterm" id="iddle1505"/><a class="indexterm" id="iddle1626"/><a class="indexterm" id="iddle1628"/><a class="indexterm" id="iddle1629"/><a class="indexterm" id="iddle1714"/><a class="indexterm" id="iddle1811"/>In the second half of this chapter, we’ll see how you can write code that writes code with the <code class="literal">eval</code> method: metaprogramming in its purest form. We’ll also see how metaprogramming and closures are related. Like blocks, lambdas, and procs, <code class="literal">eval</code> and its related metaprogramming methods create a closure when you call them. In fact, we’ll learn how you can use the same mental model we developed in <a class="xref" href="ch08.html" title="Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp">Chapter 8</a> for blocks to understand many of Ruby’s metaprogramming features.</p><div class="sect1" title="Alternative Ways to Define Methods"><div class="titlepage"><div><div><h1 class="title"><a id="alternative_ways_to_define_methods"/>Alternative Ways to Define Methods</h1></div></div></div><p>Normally we define methods in Ruby using the <code class="literal">def</code> keyword. After <code class="literal">def</code>, we specify a name for the new method followed by the method body. By using some of Ruby’s metaprogramming features, however, we can define methods in alternative ways. We can create class methods instead of normal methods; we can create methods for a single object instance; and, as we’ll see in <a class="xref" href="ch09.html#experiment_9-2_using_a_closure_to_define" title="Experiment 9-2: Using a Closure to Define a Method">Experiment 9-2: Using a Closure to Define a Method</a>, we can create methods that can access the surrounding environment using a closure.</p><p>Next, we’ll look at what happens inside Ruby when you define a method in each of these ways using metaprogramming. In each case, studying what Ruby does internally will make Ruby’s metaprogramming syntax easier to understand. But before we tackle metaprogramming, let’s learn more about how Ruby normally defines a method. This knowledge will serve as a foundation when we learn alternative ways to define a method.</p><div class="sect2" title="Ruby’s Normal Method Definition Process"><div class="titlepage"><div><div><h2 class="title"><a id="rubyapostrophes_normal_method_definition"/>Ruby’s Normal Method Definition Process</h2></div></div></div><p><a class="xref" href="ch09.html#adding_a_method_to_a_class_using_the_def" title="Example 9-1. Adding a method to a class using the def keyword">Example 9-1</a> shows a very simple Ruby class containing a single method.</p><div class="example"><a id="adding_a_method_to_a_class_using_the_def"/><p class="title">Example 9-1. Adding a method to a class using the <code class="literal">def</code> keyword</p><div class="example-contents"><pre class="programlisting">class Quote
  def display
    puts "The quick brown fox jumped over the lazy dog."
  end
end</pre></div></div><p>How does Ruby execute this small program? And how does it know to assign the <code class="literal">display</code> method to the <code class="literal">Quote</code> class?</p><p>When Ruby executes the <code class="literal">class</code> keyword, it creates a new lexical scope for the new <code class="literal">Quote</code> class (see <a class="xref" href="ch09.html#ruby_creates_a_new_lexical_scope_when_yo" title="Figure 9-1. Ruby creates a new lexical scope when you define a class.">Figure 9-1</a>). Ruby sets the <code class="literal">nd_clss</code> pointer in the lexical scope to point to an <code class="literal">RClass</code> structure for the new <code class="literal">Quote</code> class. Because it’s a new class, the <code class="literal">RClass</code> structure initially has an empty method table, as shown on the right side of the figure.</p><p>Next, Ruby executes the <code class="literal">def</code> keyword, which is used to define the <code class="literal">display</code> method. But how does Ruby create normal methods? What happens internally when you call <code class="literal">def</code>?</p><div class="figure"><a id="ruby_creates_a_new_lexical_scope_when_yo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00207"/><img alt="Ruby creates a new lexical scope when you define a class." src="httpatomoreillycomsourcenostarchimages1854229.png.jpg"/></div></div><p class="title">Figure 9-1. Ruby creates a new lexical scope when you define a class.</p></div><p>By default, when you use <code class="literal">def</code>, you provide just the name of the new method. (We’ll see in the next section that you can also specify an object prefix along with the new method name.) Providing just the name of the new method with <code class="literal">def</code> instructs Ruby to use the current lexical scope to find the target class, as shown in <a class="xref" href="ch09.html#by_defaultcomma_ruby_uses_the_current_le" title="Figure 9-2. By default, Ruby uses the current lexical scope to find the target class for a new method.">Figure 9-2</a>.</p><div class="figure"><a id="by_defaultcomma_ruby_uses_the_current_le"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00208"/><img alt="By default, Ruby uses the current lexical scope to find the target class for a new method." src="httpatomoreillycomsourcenostarchimages1854231.png.jpg"/></div></div><p class="title">Figure 9-2. By default, Ruby uses the current lexical scope to find the target class for a new method.</p></div><p>When Ruby initially compiles <a class="xref" href="ch09.html#adding_a_method_to_a_class_using_the_def" title="Example 9-1. Adding a method to a class using the def keyword">Example 9-1</a>, it creates a separate snippet of YARV code for the <code class="literal">display</code> method. Later, when executing the <code class="literal">def</code> keyword, Ruby assigns this code to the target class, <code class="literal">Quote</code>, saving the given method name in the method table (see <a class="xref" href="ch09.html#ruby_adds_new_methods_to_the_method_tabl" title="Figure 9-3. Ruby adds new methods to the method table for the target class.">Figure 9-3</a>).</p><div class="figure"><a id="ruby_adds_new_methods_to_the_method_tabl"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00209"/><img alt="Ruby adds new methods to the method table for the target class." src="httpatomoreillycomsourcenostarchimages1854233.png.jpg"/></div></div><p class="title">Figure 9-3. Ruby adds new methods to the method table for the target class.</p></div><p><a class="indexterm" id="iddle1156"/><a class="indexterm" id="iddle1227"/><a class="indexterm" id="iddle1228"/><a class="indexterm" id="iddle1742"/>When we execute this method, Ruby looks up the method as described in <a class="xref" href="ch06.html#rubyapostrophes_method_lookup_algorithm" title="Ruby’s Method Lookup Algorithm">Ruby’s Method Lookup Algorithm</a>. Because <code class="literal">display</code> now appears in the method table for <code class="literal">Quote</code>, Ruby can find the method and execute it.</p><p>In sum, to define new methods in your program using the <code class="literal">def</code> keyword, Ruby follows this three-step process:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>It compiles each method’s body into a distinct snippet of YARV instructions. (This occurs when Ruby parses and compiles your program.)</p></li><li class="listitem"><p>It uses the current lexical scope to obtain a pointer to a class or module. (This occurs when Ruby encounters a <code class="literal">def</code> keyword while executing your program.)</p></li><li class="listitem"><p>It saves the new method’s name—actually, an integer ID value that maps to the name—in the method table for that class.</p></li></ol></div></div><div class="sect2" title="Defining Class Methods Using an Object Prefix"><div class="titlepage"><div><div><h2 class="title"><a id="defining_class_methods_using_an_object_p"/>Defining Class Methods Using an Object Prefix</h2></div></div></div><p>Now that we understand how Ruby’s method definition process normally works, let’s learn alternative ways to define methods using metaprogramming. As we saw in <a class="xref" href="ch09.html#by_defaultcomma_ruby_uses_the_current_le" title="Figure 9-2. By default, Ruby uses the current lexical scope to find the target class for a new method.">Figure 9-2</a>, Ruby normally assigns new methods to the class that corresponds to the current lexical scope. However, sometimes you’ll decide to add a method to a different class—for example, when you define a class method. (Remember that Ruby saves class methods in a class’s metaclass.) <a class="xref" href="ch09.html#adding_a_class_method_using_def_self" title="Example 9-2. Adding a class method using def self">Example 9-2</a> shows an example of creating a class method.</p><div class="example"><a id="adding_a_class_method_using_def_self"/><p class="title">Example 9-2. Adding a class method using <code class="literal">def self</code></p><div class="example-contents"><pre class="programlisting">    class Quote
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   def self.display
        puts "The quick brown fox jumped over the lazy dog."
      end
    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00322"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we use <code class="literal">def</code> to define the new method, but this time we use a <code class="literal">self</code> prefix. This prefix tells Ruby to add the method to the class of the object you specify in the prefix rather than using the current lexical scope. <a class="xref" href="ch09.html#providing_an_object_prefix_to_def_instru" title="Figure 9-4. Providing an object prefix to def instructs Ruby to add the new method to the object’s class.">Figure 9-4</a> shows how Ruby does this internally.</p><p>This behavior is very different from the standard method definition process! When you provide an object prefix to <code class="literal">def</code>, Ruby uses the following algorithm to decide where to put the new method:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Ruby evaluates the prefix expression. In <a class="xref" href="ch09.html#adding_a_class_method_using_def_self" title="Example 9-2. Adding a class method using def self">Example 9-2</a> we use the <code class="literal">self</code> keyword. While Ruby is executing code inside the <code class="literal">class Quote</code> scope, <code class="literal">self</code> is set to the <code class="literal">Quote</code> class. (We could have provided any Ruby expression here instead of <code class="literal">self</code>.) In <a class="xref" href="ch09.html#providing_an_object_prefix_to_def_instru" title="Figure 9-4. Providing an object prefix to def instructs Ruby to add the new method to the object’s class.">Figure 9-4</a>, the arrow extending up from <code class="literal">self</code> to the <code class="literal">RClass</code> structure indicates the value of <code class="literal">self</code> is <code class="literal">Quote</code>.</p><div class="figure"><a id="providing_an_object_prefix_to_def_instru"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00210"/><img alt="Providing an object prefix to def instructs Ruby to add the new method to the object’s class." src="httpatomoreillycomsourcenostarchimages1854235.png.jpg"/></div></div><p class="title">Figure 9-4. Providing an object prefix to <code class="literal">def</code> instructs Ruby to add the new method to the object’s class.</p></div></li><li class="listitem"><p><a class="indexterm" id="iddle1155"/><a class="indexterm" id="iddle1226"/>Ruby finds the class of this object. In <a class="xref" href="ch09.html#adding_a_class_method_using_def_self" title="Example 9-2. Adding a class method using def self">Example 9-2</a>, because <code class="literal">self</code> is a class itself (<code class="literal">Quote</code>), the class of the object is actually the metaclass for <code class="literal">Quote</code>. <a class="xref" href="ch09.html#providing_an_object_prefix_to_def_instru" title="Figure 9-4. Providing an object prefix to def instructs Ruby to add the new method to the object’s class.">Figure 9-4</a> indicates this with the arrow extending to the right from the <code class="literal">RClass</code> structure for <code class="literal">Quote</code>.</p></li><li class="listitem"><p>Ruby saves the new method in that class’s method table. In this case, Ruby places the <code class="literal">display</code> method in the metaclass for <code class="literal">Quote</code>, making <code class="literal">display</code> a new class method.</p></li></ol></div><div class="note" title="Note"><h3 class="title"><a id="ch09note01"/>Note</h3><p><span class="emphasis"><em>If you call <code class="literal">Quote.class</code>, Ruby will return <code class="literal">Class</code>. All classes are officially instances of the <code class="literal">Class</code> class. Metaclasses are an internal concept, normally hidden from your Ruby program. To see the metaclass for <code class="literal">Quote</code>, you can call <code class="literal">Quote.singleton_class</code> instead, which will return <code class="literal">#&lt;Class:Quote&gt;</code>.</em></span></p></div></div><div class="sect2" title="Defining Class Methods Using a New Lexical Scope"><div class="titlepage"><div><div><h2 class="title"><a id="defining_class_methods_using_a_new_lexic"/>Defining Class Methods Using a New Lexical Scope</h2></div></div></div><p><a class="xref" href="ch09.html#defining_a_class_method_using_cl-id00035" title="Example 9-3. Defining a class method using class &lt;&lt; self">Example 9-3</a> shows a different way to assign <code class="literal">display</code> as a class method of <code class="literal">Quote</code>.</p><div class="example"><a id="defining_a_class_method_using_cl-id00035"/><p class="title">Example 9-3. Defining a class method using <code class="literal">class &lt;&lt; self</code></p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> class Quote
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   class &lt;&lt; self
        def display
          puts "The quick brown fox jumped over the lazy dog."
        end
      end
    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00325"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> <code class="literal">class &lt;&lt; self</code> declares a new lexical scope, just as <code class="literal">class Quote</code> does at <span class="inlinemediaobject"><a id="inline_id00326"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. In <a class="xref" href="ch09.html#rubyapostrophes_normal_method_definition" title="Ruby’s Normal Method Definition Process">Ruby’s Normal Method Definition Process</a>, we saw that using <code class="literal">def</code> in the scope created by <code class="literal">class Quote</code> assigns new methods to <a class="indexterm" id="iddle1121"/><code class="literal">Quote</code>. But what class does Ruby assign methods to inside the scope created by <code class="literal">class &lt;&lt; self</code>? The answer is <code class="literal">self</code>’s class. Because at <span class="inlinemediaobject"><a id="inline_id00327"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> <code class="literal">self</code> is set to <code class="literal">Quote</code>, <code class="literal">self</code>’s class is the metaclass of <code class="literal">Quote</code>.</p><p><a class="xref" href="ch09.html#ruby_creates_a_new_lexical_scope_for_a_c" title="Figure 9-5. Ruby creates a new lexical scope for a class’s metaclass when you use class &lt;&lt; self.">Figure 9-5</a> shows how <code class="literal">class &lt;&lt; self</code> creates a new lexical scope for the metaclass of <code class="literal">Quote</code>.</p><div class="figure"><a id="ruby_creates_a_new_lexical_scope_for_a_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00211"/><img alt="Ruby creates a new lexical scope for a class’s metaclass when you use class &lt;&lt; self." src="httpatomoreillycomsourcenostarchimages1854237.png.jpg"/></div></div><p class="title">Figure 9-5. Ruby creates a new lexical scope for a class’s metaclass when you use <code class="literal">class &lt;&lt; self</code>.</p></div><p>In this figure, Ruby’s <code class="literal">class &lt;&lt;</code> metaprogramming syntax functions as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Ruby first evaluates the expression that appears after <code class="literal">class &lt;&lt;</code>. In <a class="xref" href="ch09.html#defining_a_class_method_using_cl-id00035" title="Example 9-3. Defining a class method using class &lt;&lt; self">Example 9-3</a> this is the expression <code class="literal">self</code>, which evaluates to the <code class="literal">Quote</code> class, just as it did using the object prefix syntax in <a class="xref" href="ch09.html#adding_a_class_method_using_def_self" title="Example 9-2. Adding a class method using def self">Example 9-2</a>. The long arrow extending to the right from <code class="literal">self</code> to the <code class="literal">RClass</code> structure indicates the value of <code class="literal">self</code> is the <code class="literal">Quote</code> class.</p></li><li class="listitem"><p>Ruby finds the class for the object the expression evaluates to. In <a class="xref" href="ch09.html#defining_a_class_method_using_cl-id00035" title="Example 9-3. Defining a class method using class &lt;&lt; self">Example 9-3</a> this will be the class of <code class="literal">Quote</code>, or <code class="literal">Quote</code>’s metaclass, indicated by the arrow extending down from <code class="literal">Quote</code> to the metaclass for <code class="literal">Quote</code> on the right side of the figure.</p></li><li class="listitem"><p>Ruby creates a new lexical scope for this class. In this example, the lexical scope uses the metaclass of <code class="literal">Quote</code>, indicated by the arrow extending to the right from <code class="literal">nd_clss</code> in the new scope.</p></li></ol></div><p>Now we can use the new lexical scope to define a series of class methods using <code class="literal">def</code> as usual. In <a class="xref" href="ch09.html#defining_a_class_method_using_cl-id00035" title="Example 9-3. Defining a class method using class &lt;&lt; self">Example 9-3</a> Ruby will assign the <code class="literal">display</code> method directly to the metaclass of <code class="literal">Quote</code>. This is a different way of defining a class method for <code class="literal">Quote</code>. You might find <code class="literal">class &lt;&lt; self</code> a bit more confusing than <code class="literal">def self</code>, but it is a convenient way to create a series of class methods by declaring them all inside the inner, metaclass lexical scope.</p></div><div class="sect2" title="Defining Methods Using Singleton Classes"><div class="titlepage"><div><div><h2 class="title"><a id="defining_methods_using_singleton_classes"/>Defining Methods Using Singleton Classes</h2></div></div></div><p><a class="indexterm" id="iddle1148"/><a class="indexterm" id="iddle1230"/><a class="indexterm" id="iddle1588"/><a class="indexterm" id="iddle1994"/>We’ve seen how metaprogramming allows you to declare class methods by adding methods to the class’s class or metaclass. Ruby also allows you to add methods to a single object instance, as shown in <a class="xref" href="ch09.html#adding_a_method_to_a_single_object_insta" title="Example 9-4. Adding a method to a single object instance">Example 9-4</a>.</p><div class="example"><a id="adding_a_method_to_a_single_object_insta"/><p class="title">Example 9-4. Adding a method to a single object instance</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> class Quote
    end

<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> some_quote = Quote.new
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> def some_quote.display
      puts "The quick brown fox jumped over the lazy dog."
    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00331"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we declare the <code class="literal">Quote</code> class; then, at <span class="inlinemediaobject"><a id="inline_id00332"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we create an instance of <code class="literal">Quote</code>: <code class="literal">some_quote</code>. At <span class="inlinemediaobject"><a id="inline_id00333"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> this time, however, we create a new method for the <code class="literal">some_quote</code> instance, not the <code class="literal">Quote</code> class. As a result, only <code class="literal">some_quote</code> will have the <code class="literal">display</code> method; no other instances of <code class="literal">Quote</code> will have it.</p><p>Internally, Ruby implements this behavior using a hidden class called the <span class="emphasis"><em>singleton class</em></span>, which is like a metaclass for a single object. Here’s the difference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>singleton class</em></span> is a special hidden class that Ruby creates internally to hold methods defined only for a particular object.</p></li><li class="listitem"><p>A <span class="emphasis"><em>metaclass</em></span> is a singleton class in the case when that object is itself a class.</p></li></ul></div><p>All metaclasses are singleton classes, but not all singleton classes are metaclasses. Ruby automatically creates a metaclass for every class you create and uses it to hold class methods that you might declare later. On the other hand, Ruby creates a singleton class only when you define a method on a single object, as shown in <a class="xref" href="ch09.html#adding_a_method_to_a_single_object_insta" title="Example 9-4. Adding a method to a single object instance">Example 9-4</a>. Ruby also creates a singleton class when you use <code class="literal">instance_eval</code> or related methods.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note02"/>Note</h3><p><span class="emphasis"><em>Most Ruby developers use the terms</em></span> singleton class <span class="emphasis"><em>and</em></span> metaclass <span class="emphasis"><em>interchangeably, and when you call the <code class="literal">singleton_class</code> method, Ruby will return either a singleton class or a metaclass. However, internally Ruby’s C source code does make a distinction between singleton classes and metaclasses.</em></span></p></div><p><a class="xref" href="ch09.html#providing_an_object_prefix_to_de-id00036" title="Figure 9-6. Providing an object prefix to def instructs Ruby to add the new method to the object’s singleton class.">Figure 9-6</a> shows how Ruby creates a singleton class when executing <a class="xref" href="ch09.html#adding_a_method_to_a_single_object_insta" title="Example 9-4. Adding a method to a single object instance">Example 9-4</a>. Ruby evaluates the expression provided as a prefix to <code class="literal">def</code>: <code class="literal">some_quote</code>. Because <code class="literal">some_quote</code> is an object instance, Ruby creates a new singleton class for <code class="literal">some_quote</code> and then assigns the new method to this singleton class. Using the <code class="literal">def</code> keyword with an object prefix instructs Ruby either to use a metaclass (if the prefix is a class) or to create a singleton class (if the prefix is some other object).</p><div class="figure"><a id="providing_an_object_prefix_to_de-id00036"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00212"/><img alt="Providing an object prefix to def instructs Ruby to add the new method to the object’s singleton class." src="httpatomoreillycomsourcenostarchimages1854239.png.jpg"/></div></div><p class="title">Figure 9-6. Providing an object prefix to <code class="literal">def</code> instructs Ruby to add the new method to the object’s singleton class.</p></div></div><div class="sect2" title="Defining Methods Using Singleton Classes in a Lexical Scope"><div class="titlepage"><div><div><h2 class="title"><a id="defining_methods_using_singleton-id00037"/>Defining Methods Using Singleton Classes in a Lexical Scope</h2></div></div></div><p><a class="indexterm" id="iddle1231"/>You can also declare a new lexical scope for adding methods to a single object instance using the <code class="literal">class &lt;&lt;</code> syntax, as shown in <a class="xref" href="ch09.html#adding_a_singleton_method_using_class_le" title="Example 9-5. Adding a singleton method using class &lt;&lt;">Example 9-5</a>.</p><div class="example"><a id="adding_a_singleton_method_using_class_le"/><p class="title">Example 9-5. Adding a singleton method using <code class="literal">class &lt;&lt;</code></p><div class="example-contents"><pre class="programlisting">    class Quote
    end

    some_quote = Quote.new
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> class &lt;&lt; some_quote
      def display
        puts "The quick brown fox jumped over the lazy dog."
      end
    end</pre></div></div><p>The difference between this code and that in <a class="xref" href="ch09.html#adding_a_method_to_a_single_object_insta" title="Example 9-4. Adding a method to a single object instance">Example 9-4</a> appears at <span class="inlinemediaobject"><a id="inline_id00335"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, when we use the <code class="literal">class &lt;&lt;</code> syntax with the expression <code class="literal">some_quote</code>, which evaluates to a single object instance. As shown in <a class="xref" href="ch09.html#ruby_creates_a_new_singleton_class_and_l" title="Figure 9-7. Ruby creates a new singleton class and lexical scope for some_quote.">Figure 9-7</a>, <code class="literal">class &lt;&lt; some_quote</code> instructs Ruby to create a new singleton class along with a new lexical scope.</p><p>On the left side of <a class="xref" href="ch09.html#ruby_creates_a_new_singleton_class_and_l" title="Figure 9-7. Ruby creates a new singleton class and lexical scope for some_quote.">Figure 9-7</a>, you can see some of the code from <a class="xref" href="ch09.html#adding_a_singleton_method_using_class_le" title="Example 9-5. Adding a singleton method using class &lt;&lt;">Example 9-5</a>. Ruby first evaluates the expression <code class="literal">some_quote</code> and finds it is an object, not a class. <a class="xref" href="ch09.html#ruby_creates_a_new_singleton_class_and_l" title="Figure 9-7. Ruby creates a new singleton class and lexical scope for some_quote.">Figure 9-7</a> indicates this with the long arrow pointing to the <code class="literal">RObject</code> structure for <code class="literal">some_quote</code>. Because it is not a class, Ruby creates a new singleton class for <code class="literal">some_quote</code> and also creates a new lexical scope. Next, it sets the class for the new scope to be the new singleton class. If a singleton class for <code class="literal">some_quote</code> already exists, Ruby will reuse it.</p><div class="figure"><a id="ruby_creates_a_new_singleton_class_and_l"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00213"/><img alt="Ruby creates a new singleton class and lexical scope for some_quote." src="httpatomoreillycomsourcenostarchimages1854241.png.jpg"/></div></div><p class="title">Figure 9-7. Ruby creates a new singleton class and lexical scope for <code class="literal">some_quote</code>.</p></div></div><div class="sect2" title="Creating Refinements"><div class="titlepage"><div><div><h2 class="title"><a id="creating_refinements"/>Creating Refinements</h2></div></div></div><p><a class="indexterm" id="iddle1215"/><a class="indexterm" id="iddle1900"/>Ruby 2.0’s <span class="emphasis"><em>refinements</em></span> feature gave us the ability to define methods and add them to a class later if we wish. To see how this works, we’ll use the same <code class="literal">Quote</code> class and <code class="literal">display</code> method we used in <a class="xref" href="ch09.html#adding_a_method_to_a_class_using_the_def" title="Example 9-1. Adding a method to a class using the def keyword">Example 9-1</a>, repeated here for convenience.</p><a id="pro_id00059"/><pre class="programlisting">class Quote
  def display
    puts "The quick brown fox jumped over the lazy dog."
  end
end</pre><p>Now suppose elsewhere in our Ruby application we want to override or change what <code class="literal">display</code> does without changing the <code class="literal">Quote</code> class everywhere. Ruby provides an elegant way to do this, as shown in <a class="xref" href="ch09.html#refining_a_class_inside_a_module" title="Example 9-6. Refining a class inside a module">Example 9-6</a>.</p><div class="example"><a id="refining_a_class_inside_a_module"/><p class="title">Example 9-6. Refining a class inside a module</p><div class="example-contents"><pre class="programlisting">module AllCaps
  refine Quote do
    def display
      puts "THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG."
    end
  end
end</pre></div></div><p>In <code class="literal">refine Quote do</code>, we use the <code class="literal">refine</code> method and pass the <code class="literal">Quote</code> class as a parameter. This defines new behavior for <code class="literal">Quote</code> that we can activate later. <a class="xref" href="ch09.html#ruby_creates_a_special_module_when_you_c" title="Figure 9-8. Ruby creates a special module when you call refine and updates the type of the target class’s methods.">Figure 9-8</a> shows what happens internally when we call <code class="literal">refine</code>.</p><div class="figure"><a id="ruby_creates_a_special_module_when_you_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00214"/><img alt="Ruby creates a special module when you call refine and updates the type of the target class’s methods." src="httpatomoreillycomsourcenostarchimages1854243.png.jpg"/></div></div><p class="title">Figure 9-8. Ruby creates a special module when you call <code class="literal">refine</code> and updates the type of the target class’s methods.</p></div><p><a class="indexterm" id="iddle1658"/><a class="indexterm" id="iddle2065"/><a class="indexterm" id="iddle2100"/>Working our way through <a class="xref" href="ch09.html#ruby_creates_a_special_module_when_you_c" title="Figure 9-8. Ruby creates a special module when you call refine and updates the type of the target class’s methods.">Figure 9-8</a> from the top-left corner down, we see the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">refine</code> method creates a new lexical scope (the shaded rectangle).</p></li><li class="listitem"><p>Ruby creates a new “refinement” module and uses that as the class for this new scope.</p></li><li class="listitem"><p>Ruby saves a pointer to the <code class="literal">Quote</code> class in <code class="literal">refined_class</code> inside the new refinement module.</p></li></ul></div><p>As you define new methods in the refine block, Ruby saves them in the refinement module. But it also follows the <code class="literal">refined_class</code> pointer and updates the same methods in the target class to use the method type <code class="literal">VM_METHOD_TYPE_REFINED</code>.</p></div><div class="sect2" title="Using Refinements"><div class="titlepage"><div><div><h2 class="title"><a id="using_refinements"/>Using Refinements</h2></div></div></div><p>You can decide to activate these “refined” methods in a specific part of your program with the <code class="literal">using</code> method, as shown in <a class="xref" href="ch09.html#activating_a_refined_method" title="Example 9-7. Activating a refined method">Example 9-7</a>.</p><div class="example"><a id="activating_a_refined_method"/><p class="title">Example 9-7. Activating a refined method</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> Quote.new.display
     =&gt; The quick brown...

<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> using AllCaps

<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> Quote.new.display
     =&gt; THE QUICK BROWN...</pre></div></div><p><a class="indexterm" id="iddle1716"/><a class="indexterm" id="iddle1813"/>When we first call display at <span class="inlinemediaobject"><a id="inline_id00339"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, Ruby uses the original method. Then, at <span class="inlinemediaobject"><a id="inline_id00340"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we activate the refinement with <code class="literal">using</code>, which causes Ruby to use the updated method when we call display again at <span class="inlinemediaobject"><a id="inline_id00341"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>.</p><p>The <code class="literal">using</code> method attaches the refinements from the specified module to the current lexical scope. As I write this, the current version of Ruby, 2.0, allows you to use refinements only in the top-level scope, as in this example; <code class="literal">using</code> is a method of the top-level <code class="literal">main</code> object. (Future versions may allow you to use refinements in any lexical scope in your program.) <a class="xref" href="ch09.html#using_method_associates_a_moduleapos" title="Figure 9-9. The using method associates a module’s refinements with the top-level lexical scope.">Figure 9-9</a> shows how Ruby internally associates the refinement with the top-level lexical scope.</p><div class="figure"><a id="using_method_associates_a_moduleapos"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00215"/><img alt="The using method associates a module’s refinements with the top-level lexical scope." src="httpatomoreillycomsourcenostarchimages1854245.png.jpg"/></div></div><p class="title">Figure 9-9. The <code class="literal">using</code> method associates a module’s refinements with the top-level lexical scope.</p></div><p>Notice how each lexical scope contains an <code class="literal">nd_refinements</code> pointer, which tracks the refinements active in that scope. The <code class="literal">using</code> method sets <code class="literal">nd_refinements</code>, which would otherwise be <code class="literal">nil</code>.</p><p>And finally, <a class="xref" href="ch09.html#ruby_looks_for_a_method_in_the_refine_bl" title="Figure 9-10. Ruby looks for a method in the refine block when the original method is marked with VM_METHOD_TYPE_REFINED.">Figure 9-10</a> shows how Ruby’s method dispatch algorithm finds the updated method when I call it.</p><p>Ruby uses a complex method dispatch process when you call methods. One portion of this algorithm looks for <code class="literal">VM_METHOD_TYPE_REFINED</code> methods. When it encounters a refined method, Ruby looks in the current lexical scope for any active refinements. If it finds an active refinement, Ruby calls the refined method; otherwise, it calls the original method.</p><div class="figure"><a id="ruby_looks_for_a_method_in_the_refine_bl"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00216"/><img alt="Ruby looks for a method in the refine block when the original method is marked with VM_METHOD_TYPE_REFINED." src="httpatomoreillycomsourcenostarchimages1854247.png.jpg"/></div></div><p class="title">Figure 9-10. Ruby looks for a method in the refine block when the original method is marked with <code class="literal">VM_METHOD_TYPE_REFINED</code>.</p></div></div></div><div class="sect1" title="Experiment 9-1: Who Am I? How self Changes with Lexical Scope"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_9-1_who_am_iquestion_mark_how"/>Experiment 9-1: Who Am I? How self Changes with Lexical Scope</h1></div></div></div><p><a class="indexterm" id="iddle1138"/><a class="indexterm" id="iddle1285"/><a class="indexterm" id="iddle1541"/><a class="indexterm" id="iddle1645"/><a class="indexterm" id="iddle1691"/><a class="indexterm" id="iddle1740"/><a class="indexterm" id="iddle1820"/><a class="indexterm" id="iddle1975"/><a class="indexterm" id="iddle1977"/><a class="indexterm" id="iddle1981"/>We’ve seen various ways to define methods in Ruby. We created methods in the usual way using the <code class="literal">def</code> keyword. Then, we looked at how to create methods on a metaclass and on a singleton class and how to use refinements.</p><p>While each technique adds the method to a different class, each also follows a simple rule: Ruby adds the new method to the class corresponding to the current lexical scope for each technique. (The <code class="literal">def</code> keyword, however, assigns the method to a different class when you use a prefix.) With refinements, the current scope’s class is actually the special module created to hold the refined methods. In fact, this is one of the important roles lexical scope plays in Ruby: It identifies which class or module we are currently adding methods to.</p><p>We also know that the <code class="literal">self</code> keyword returns the current object—the receiver of the method currently being executed by Ruby. Recall that YARV saves the current value of <code class="literal">self</code> for each level of your Ruby call stack in the <code class="literal">rb_control_frame_t</code> structure. Is this object the same as the class for the current lexical scope?</p><div class="sect2" title="self in the Top Scope"><div class="titlepage"><div><div><h2 class="title"><a id="self_in_the_top_scope"/>self in the Top Scope</h2></div></div></div><p>Let’s see how the value of <code class="literal">self</code> changes as we run a simple program beginning with <a class="xref" href="ch09.html#simple_ruby_program_with_only_one_lexi" title="Example 9-8. A simple Ruby program with only one lexical scope">Example 9-8</a>.</p><div class="example"><a id="simple_ruby_program_with_only_one_lexi"/><p class="title">Example 9-8. A simple Ruby program with only one lexical scope</p><div class="example-contents"><pre class="programlisting">p self
 =&gt; main
p Module.nesting
 =&gt; []</pre></div></div><p><a class="indexterm" id="iddle1162"/><a class="indexterm" id="iddle1973"/><a class="indexterm" id="iddle2050"/>To keep things simple, I’ve shown the output from the console inline. You can see that Ruby creates a <code class="literal">top self</code> object before it starts to execute your code. This object serves as the receiver for method calls in the top-level scope. Ruby represents this object with the string <code class="literal">main</code>.</p><p>The <code class="literal">Module.nesting</code> call returns an array showing the lexical scope stack—that is, which modules are “nested” until that point in the code. This array will contain an element for each lexical scope in the lexical scope stack. Because we’re at the top level of the script, Ruby returns an empty array.</p><p><a class="xref" href="ch09.html#at_the_top_levelcomma_ruby_sets_self_to" title="Figure 9-11. At the top level, Ruby sets self to the main object and has a single entry in the lexical scope stack.">Figure 9-11</a> shows the lexical scope stack and the value <code class="literal">self</code> for this simple program.</p><div class="figure"><a id="at_the_top_levelcomma_ruby_sets_self_to"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00217"/><img alt="At the top level, Ruby sets self to the main object and has a single entry in the lexical scope stack." src="httpatomoreillycomsourcenostarchimages1854249.png.jpg"/></div></div><p class="title">Figure 9-11. At the top level, Ruby sets <code class="literal">self</code> to the <code class="literal">main</code> object and has a single entry in the lexical scope stack.</p></div><p>On the right of this figure, you see the <code class="literal">main</code> object: the current value of <code class="literal">self</code>. On the left side is the lexical scope stack, which contains just a single entry for the top-level scope. Ruby sets the class of the top scope to the class of the <code class="literal">main</code> object, which is the <code class="literal">Object</code> class.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note03"/>Note</h3><p><span class="emphasis"><em>Recall when you declare a new method using the <code class="literal">def</code> keyword, Ruby adds the method to the class for the current lexical scope. We’ve just seen the class for the top-level lexical scope is <code class="literal">Object</code>. Therefore, we can conclude that when you define a method at the top level of your script, outside of any class or module, Ruby adds the method to the <code class="literal">Object</code> class. You can call methods you define at the top level from anywhere because <code class="literal">Object</code> is a superclass of every other class.</em></span></p></div></div><div class="sect2" title="self in a Class Scope"><div class="titlepage"><div><div><h2 class="title"><a id="self_in_a_class_scope"/>self in a Class Scope</h2></div></div></div><p>Now let’s define a new class and see what happens to the value of <code class="literal">self</code> and the lexical scope stack, as shown in <a class="xref" href="ch09.html#declaring_a_new_class_changes_self_and_c" title="Example 9-9. Declaring a new class changes self and creates a new entry in the lexical scope stack.">Example 9-9</a>.</p><div class="example"><a id="declaring_a_new_class_changes_self_and_c"/><p class="title">Example 9-9. Declaring a new class changes <code class="literal">self</code> and creates a new entry in the lexical scope stack.</p><div class="example-contents"><pre class="programlisting">    p self
    p Module.nesting

    class Quote
      p self
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>    =&gt; Quote
      p Module.nesting
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>    =&gt; [Quote]
    end</pre></div></div><p><a class="indexterm" id="iddle1976"/><a class="indexterm" id="iddle2047"/>The output from the print statements is shown inline. We see at <span class="inlinemediaobject"><a id="inline_id00344"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> that Ruby has changed <code class="literal">self</code> to <code class="literal">Quote</code>—the new class—and we see at <span class="inlinemediaobject"><a id="inline_id00345"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> that there’s a new level added to the lexical scope stack. <a class="xref" href="ch09.html#now_self_is_the_same_as_the_class_for_th" title="Figure 9-12. Now self is the same as the class for the current lexical scope.">Figure 9-12</a> shows a summary.</p><div class="figure"><a id="now_self_is_the_same_as_the_class_for_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00218"/><img alt="Now self is the same as the class for the current lexical scope." src="httpatomoreillycomsourcenostarchimages1854251.png.jpg"/></div></div><p class="title">Figure 9-12. Now <code class="literal">self</code> is the same as the class for the current lexical scope.</p></div><p>On the left side of this figure, we see the lexical scope stack. The top scope is on the top left, and under it we see the new lexical scope created by the <code class="literal">class</code> keyword. Meanwhile, on the right side of the figure, we see how the value of <code class="literal">self</code> changes when we call <code class="literal">class</code>. On the top level, <code class="literal">self</code> was set to the <code class="literal">main</code> object, but when we call <code class="literal">class</code>, Ruby changes <code class="literal">self</code> to the new class.</p></div><div class="sect2" title="self in a Metaclass Scope"><div class="titlepage"><div><div><h2 class="title"><a id="self_in_a_metaclass_scope"/>self in a Metaclass Scope</h2></div></div></div><p>Let’s use the <code class="literal">class &lt;&lt; self</code> syntax to create a new metaclass scope. <a class="xref" href="ch09.html#declaring_a_metaclass_scope" title="Example 9-10. Declaring a metaclass scope">Example 9-10</a> shows the same program with a few more lines of code.</p><div class="example"><a id="declaring_a_metaclass_scope"/><p class="title">Example 9-10. Declaring a metaclass scope</p><div class="example-contents"><pre class="programlisting">    p self
    p Module.nesting

    class Quote
      p self
      p Module.nesting

      class &lt;&lt; self
        p self
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>      =&gt; #&lt;Class:Quote&gt;
        p Module.nesting
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>      =&gt; [#&lt;Class:Quote&gt;, Quote]
      end
    end</pre></div></div><p><a class="indexterm" id="iddle1972"/>At <span class="inlinemediaobject"><a id="inline_id00348"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we see that Ruby has changed the value of <code class="literal">self</code> again. The syntax <code class="literal">#&lt;Class:Quote&gt;</code> indicates that <code class="literal">self</code> was set to <code class="literal">Quote</code>’s metaclass. At <span class="inlinemediaobject"><a id="inline_id00349"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we see that Ruby has also added another level to the lexical scope stack. <a class="xref" href="ch09.html#new_lexical_scope_is_created_for_the_m" title="Figure 9-13. A new lexical scope is created for the metaclass.">Figure 9-13</a> shows the next level in the stack.</p><div class="figure"><a id="new_lexical_scope_is_created_for_the_m"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00219"/><img alt="A new lexical scope is created for the metaclass." src="httpatomoreillycomsourcenostarchimages1854253.png.jpg"/></div></div><p class="title">Figure 9-13. A new lexical scope is created for the metaclass.</p></div><p>On the left, we can see that Ruby created a new scope when it executed <code class="literal">class &lt;&lt; self</code>. The right side of the figure shows the value of <code class="literal">self</code> in the new scope, the metaclass for <code class="literal">Quote</code>.</p></div><div class="sect2" title="self Inside a Class Method"><div class="titlepage"><div><div><h2 class="title"><a id="self_inside_a_class_method"/>self Inside a Class Method</h2></div></div></div><p>Now for one more test. Suppose we add a class method to the <code class="literal">Quote</code> class and then call it as shown in <a class="xref" href="ch09.html#declaring_and_calling_a_class_method" title="Example 9-11. Declaring and calling a class method">Example 9-11</a>. (The output is at the bottom because the <code class="literal">p</code> statements aren’t called until we call <code class="literal">class_method</code>.)</p><div class="example"><a id="declaring_and_calling_a_class_method"/><p class="title">Example 9-11. Declaring and calling a class method</p><div class="example-contents"><pre class="programlisting">    p self
    p Module.nesting

    class Quote
      p self
      p Module.nesting

      class &lt;&lt; self
        p self
        p Module.nesting

        def class_method
          p self
          p Module.nesting
        end
      end
    end

    Quote.class_method
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; Quote
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>  =&gt; [#&lt;Class:Quote&gt;, Quote]</pre></div></div><p><a class="indexterm" id="iddle1589"/>At <span class="inlinemediaobject"><a id="inline_id00352"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we see that Ruby sets <code class="literal">self</code> back to the <code class="literal">Quote</code> class when we call <code class="literal">class_method</code>. This makes sense: When we call a method on a receiver, Ruby always sets <code class="literal">self</code> to be the receiver. Because we call a class method in this case, Ruby sets the receiver to that class.</p><p>At <span class="inlinemediaobject"><a id="inline_id00353"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we see that Ruby hasn’t changed the lexical scope stack. It’s still set to <code class="literal">[#&lt;Class:Quote&gt;, Quote]</code>, as shown in <a class="xref" href="ch09.html#when_you_call_a_methodcomma_ruby_changes" title="Figure 9-14. When you call a method, Ruby changes self but doesn’t create a new scope.">Figure 9-14</a>.</p><div class="figure"><a id="when_you_call_a_methodcomma_ruby_changes"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00220"/><img alt="When you call a method, Ruby changes self but doesn’t create a new scope." src="httpatomoreillycomsourcenostarchimages1854255.png.jpg"/></div></div><p class="title">Figure 9-14. When you call a method, Ruby changes <code class="literal">self</code> but doesn’t create a new scope.</p></div><p>Notice that the lexical scope hasn’t changed but <code class="literal">self</code> has been changed to <code class="literal">Quote</code>, the receiver of the method call.</p><p><a class="indexterm" id="iddle1157"/><a class="indexterm" id="iddle1171"/><a class="indexterm" id="iddle1174"/><a class="indexterm" id="iddle1255"/><a class="indexterm" id="iddle1590"/><a class="indexterm" id="iddle1621"/><a class="indexterm" id="iddle1634"/>You can use these general rules to keep track of <code class="literal">self</code> and lexical scope:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Inside a class or module scope, <code class="literal">self</code> will always be set to that class or module. Ruby creates a new lexical scope when you use the <code class="literal">class</code> or <code class="literal">module</code> keywords and sets the class for that scope to the new class or module.</p></li><li class="listitem"><p>Inside a method (including a class method), Ruby will set <code class="literal">self</code> to the receiver of that method call.</p></li></ul></div></div></div><div class="sect1" title="Metaprogramming and Closures: eval, instance_eval, and binding"><div class="titlepage"><div><div><h1 class="title"><a id="metaprogramming_and_closures_evalcomma_i"/>Metaprogramming and Closures: eval, instance_eval, and binding</h1></div></div></div><p>In <a class="xref" href="ch08.html" title="Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp">Chapter 8</a> we learned that blocks are Ruby’s implementation of closures, and we saw how blocks bring together a function with the environment where that function was referenced. In Ruby, metaprogramming and closures are closely related. Many of Ruby’s metaprogramming constructs also act as closures, giving the code inside them access to the referencing environment. We’ll learn about three important metaprogramming features and how each gives you access to the referencing environment by acting as a closure in just the way blocks do.</p><div class="sect2" title="Code That Writes Code"><div class="titlepage"><div><div><h2 class="title"><a id="code_that_writes_code"/>Code That Writes Code</h2></div></div></div><p>In Ruby, the <code class="literal">eval</code> method is metaprogramming in its purest form: You pass a string to <code class="literal">eval</code>, and Ruby immediately parses, compiles, and executes the code, as shown in <a class="xref" href="ch09.html#parsing_and_compiling_code_using_eval" title="Example 9-12. Parsing and compiling code using eval">Example 9-12</a>.</p><div class="example"><a id="parsing_and_compiling_code_using_eval"/><p class="title">Example 9-12. Parsing and compiling code using <code class="literal">eval</code></p><div class="example-contents"><pre class="programlisting">str = "puts"
str += " 2"
str += " +"
str += " 2"
eval(str)</pre></div></div><p>We dynamically construct the string <code class="literal">puts 2+2</code> and pass it to <code class="literal">eval</code>. Ruby then evaluates the string. That is, it tokenizes, parses, and compiles it using the same Bison grammar rules and parse engine that it did when it first processed the primary Ruby script. Once this process is finished and Ruby has another new set of YARV bytecode instructions, it executes the new code.</p><p>But one very important detail about <code class="literal">eval</code> isn’t obvious in <a class="xref" href="ch09.html#parsing_and_compiling_code_using_eval" title="Example 9-12. Parsing and compiling code using eval">Example 9-12</a>. Specifically, Ruby evaluates the new code string in the same context from where you called <code class="literal">eval</code>. To see what I mean, look at <a class="xref" href="ch09.html#it_isnapostrophet_obvious_herecomma_but" title="Example 9-13. It isn’t obvious here, but eval accesses the surrounding scope via a closure, too.">Example 9-13</a>.</p><div class="example"><a id="it_isnapostrophet_obvious_herecomma_but"/><p class="title">Example 9-13. It isn’t obvious here, but <code class="literal">eval</code> accesses the surrounding scope via a closure, too.</p><div class="example-contents"><pre class="programlisting">    a = 2
    b = 3
    str = "puts"
    str += " a"
    str += " +"
    str += " b"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> eval(str)</pre></div></div><p>You would expect the result from running this code to be 5, but notice the difference between <a class="xref" href="ch09.html#parsing_and_compiling_code_using_eval" title="Example 9-12. Parsing and compiling code using eval">Example 9-12</a> and <a class="xref" href="ch09.html#it_isnapostrophet_obvious_herecomma_but" title="Example 9-13. It isn’t obvious here, but eval accesses the surrounding scope via a closure, too.">Example 9-13</a>. <a class="xref" href="ch09.html#it_isnapostrophet_obvious_herecomma_but" title="Example 9-13. It isn’t obvious here, but eval accesses the surrounding scope via a closure, too.">Example 9-13</a> refers to the local variables <code class="literal">a</code> and <code class="literal">b</code> from the surrounding scope, and Ruby can access their values. <a class="xref" href="ch09.html#ruby_saves_the_local_variables_acomma_bc" title="Figure 9-15. Ruby saves the local variables a, b, and str on YARV’s internal stack as usual.">Figure 9-15</a> shows how YARV’s internal stack looks just before calling <code class="literal">eval</code> at <span class="inlinemediaobject"><a id="inline_id00355"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>.</p><div class="figure"><a id="ruby_saves_the_local_variables_acomma_bc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00221"/><img alt="Ruby saves the local variables a, b, and str on YARV’s internal stack as usual." src="httpatomoreillycomsourcenostarchimages1854257.png.jpg"/></div></div><p class="title">Figure 9-15. Ruby saves the local variables <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">str</code> on YARV’s internal stack as usual.</p></div><p>As expected, we see that Ruby has saved the values of <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">str</code> on the stack to the left. On the right, we have the <code class="literal">rb_control_frame_t</code> structure, which represents the outer, or main, scope of this script.</p><p><a class="xref" href="ch09.html#calling_eval_and_accessing_values_from_t" title="Figure 9-16. Calling eval and accessing values from the parent scope">Figure 9-16</a> shows what happens when we call the <code class="literal">eval</code> method.</p><div class="figure"><a id="calling_eval_and_accessing_values_from_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00222"/><img alt="Calling eval and accessing values from the parent scope" src="httpatomoreillycomsourcenostarchimages1854259.png.jpg"/></div></div><p class="title">Figure 9-16. Calling <code class="literal">eval</code> and accessing values from the parent scope</p></div><p><a class="indexterm" id="iddle1072"/><a class="indexterm" id="iddle1105"/><a class="indexterm" id="iddle1503"/>Calling <code class="literal">eval</code> invokes the parser and compiler on the text we pass it. When the compiler finishes, Ruby creates a new stack frame (<code class="literal">rb_control_frame_t</code>) for use in running the new compiled code (as shown at the top). Notice, however, that Ruby sets the <code class="literal">EP</code> in this new stack frame to point to the lower stack frame where the variables <code class="literal">a</code> and <code class="literal">b</code> are. This pointer allows the code passed to <code class="literal">eval</code> to access these values.</p><p>Ruby’s use of <code class="literal">EP</code> here should look familiar. Aside from parsing and compiling the code dynamically, <code class="literal">eval</code> works the same way as if we had passed a block to some function, as in <a class="xref" href="ch09.html#code_inside_a_block_can_access_variables" title="Example 9-14. Code inside a block can access variables from the surrounding scope.">Example 9-14</a>.</p><div class="example"><a id="code_inside_a_block_can_access_variables"/><p class="title">Example 9-14. Code inside a block can access variables from the surrounding scope.</p><div class="example-contents"><pre class="programlisting">a = 2
b = 3
10.times do
  puts a+b
end</pre></div></div><p>In other words, the <code class="literal">eval</code> method creates a closure: the combination of a function and the environment where that function was referenced. In this case, the function is the newly compiled code, and the environment is where we call <code class="literal">eval</code> from.</p></div><div class="sect2" title="Calling eval with binding"><div class="titlepage"><div><div><h2 class="title"><a id="calling_eval_with_binding"/>Calling eval with binding</h2></div></div></div><p>The <code class="literal">eval</code> method can take a second parameter: a <span class="emphasis"><em>binding</em></span>. A binding is a closure without a function—that is, it’s just the referencing environment. Think of bindings as a pointer to a YARV stack frame. Passing a binding value to Ruby indicates that you don’t want to use the current context as the closure’s environment but instead want to use some other referencing environment. <a class="xref" href="ch09.html#using_binding_to_access_variables_from_s" title="Example 9-15. Using binding to access variables from some other environment">Example 9-15</a> shows an example.</p><div class="example"><a id="using_binding_to_access_variables_from_s"/><p class="title">Example 9-15. Using <code class="literal">binding</code> to access variables from some other environment</p><div class="example-contents"><pre class="programlisting">    def get_binding
      a = 2
      b = 3
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   binding
    end
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> eval("puts a+b", get_binding)</pre></div></div><p>The function <code class="literal">get_binding</code> contains the local variables <code class="literal">a</code> and <code class="literal">b</code>, but it also returns a binding at <span class="inlinemediaobject"><a id="inline_id00358"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. At the bottom of the listing, we again want Ruby to dynamically compile and execute the code string and print out the result. By passing the binding returned by <code class="literal">get_binding</code> to <code class="literal">eval</code>, we tell Ruby to evaluate <code class="literal">puts a+b</code> in the context of the <code class="literal">get_binding</code> function. If we had called <code class="literal">eval</code> without the binding, it would have created new, empty local variables <code class="literal">a</code> and <code class="literal">b</code>.</p><p>Ruby makes a persistent copy of this environment in the heap because you might call <code class="literal">eval</code> long after the current frame has been popped off the <a class="indexterm" id="iddle1856"/><a class="indexterm" id="iddle1869"/>stack. Even though <code class="literal">get_binding</code> has already returned in this example, Ruby can still access the values of <code class="literal">a</code> and <code class="literal">b</code> when it executes the code parsed and compiled by <code class="literal">eval</code> at <span class="inlinemediaobject"><a id="inline_id00359"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p><p><a class="xref" href="ch09.html#calling_binding_saves_a_copy_of_the_curr" title="Figure 9-17. Calling binding saves a copy of the current stack frame in the heap.">Figure 9-17</a> shows what happens internally when we call <code class="literal">binding</code>.</p><div class="figure"><a id="calling_binding_saves_a_copy_of_the_curr"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00223"/><img alt="Calling binding saves a copy of the current stack frame in the heap." src="httpatomoreillycomsourcenostarchimages1854261.png.jpg"/></div></div><p class="title">Figure 9-17. Calling <code class="literal">binding</code> saves a copy of the current stack frame in the heap.</p></div><p>This figure resembles what Ruby does when you call <code class="literal">lambda</code> (see <a class="xref" href="ch08.html#once_messageunderscorefunction_returnsco" title="Figure 8-18. Once message_function returns, the surrounding code holds a reference to the proc object.">Figure 8-18</a>), except that Ruby creates an <code class="literal">rb_binding_t</code> C structure instead of an <code class="literal">rb_proc_t</code> structure. The binding structure is simply a wrapper around the internal environment structure—the heap copy of the stack frame. The binding structure also contains the file name and line number of the location from where you called <code class="literal">binding</code>.</p><p>As with the proc object, Ruby uses the <code class="literal">RTypedData</code> structure to wrap a Ruby object around the <code class="literal">rb_binding_t</code> C structure (see <a class="xref" href="ch09.html#ruby_uses_rtypeddata_to_wrap_a_ruby_obje" title="Figure 9-18. Ruby uses RTypedData to wrap a Ruby object around the rb_binding_t structure.">Figure 9-18</a>).</p><p>The binding object allows you to create a closure and then obtain and treat its environment as a data value. However, the closure created by the binding doesn’t contain any code; it has no function. You might think of the binding object as an indirect way to access, save, and pass around Ruby’s internal <code class="literal">rb_env_t</code> structure.</p><div class="figure"><a id="ruby_uses_rtypeddata_to_wrap_a_ruby_obje"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00224"/><img alt="Ruby uses RTypedData to wrap a Ruby object around the rb_binding_t structure." src="httpatomoreillycomsourcenostarchimages1854263.png.jpg"/></div></div><p class="title">Figure 9-18. Ruby uses <code class="literal">RTypedData</code> to wrap a Ruby object around the <code class="literal">rb_binding_t</code> structure.</p></div></div><div class="sect2" title="An instance_eval Example"><div class="titlepage"><div><div><h2 class="title"><a id="instanceunderscoreeval_example"/>An instance_eval Example</h2></div></div></div><p><a class="indexterm" id="iddle1257"/><a class="indexterm" id="iddle1423"/><a class="indexterm" id="iddle1427"/>Now for a variation on the <code class="literal">eval</code> method: <code class="literal">instance_eval</code> is shown in action in <a class="xref" href="ch09.html#code_inside_instanceunderscoreeval_h" title="Example 9-16. The code inside instance_eval has access to obj’s instance variable.">Example 9-16</a>.</p><div class="example"><a id="code_inside_instanceunderscoreeval_h"/><p class="title">Example 9-16. The code inside <code class="literal">instance_eval</code> has access to <code class="literal">obj</code>’s instance variable.</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> class Quote
      def initialize
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     @str = "The quick brown fox"
      end
    end
    str2 = "jumps over the lazy dog."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> obj = Quote.new
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/> obj.instance_eval do
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>   puts "#{@str} #{str2}"
    end</pre></div></div><p>Here’s what’s going on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>At <span class="inlinemediaobject"><a id="inline_id00365"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we create a Ruby class called <code class="literal">Quote</code> that saves the first half of the string in an instance variable in <code class="literal">initialize</code> at <span class="inlinemediaobject"><a id="inline_id00366"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p></li><li class="listitem"><p><a class="indexterm" id="iddle1169"/><a class="indexterm" id="iddle1974"/>At <span class="inlinemediaobject"><a id="inline_id00367"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> we create an instance of the <code class="literal">Quote</code> class and then call <code class="literal">instance_eval</code> at <span class="inlinemediaobject"><a id="inline_id00368"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>, passing a block. The <code class="literal">instance_eval</code> method is similar to <code class="literal">eval</code>, except that it evaluates the given string in the context of the receiver, or the object we call it on. As shown here, we can pass a block to <code class="literal">instance_eval</code> instead of a string if we don’t want to dynamically parse and compile code.</p></li><li class="listitem"><p>The block we pass to <code class="literal">instance_eval</code> prints out the string at <span class="inlinemediaobject"><a id="inline_id00369"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span>, accessing the first half of the string from the <code class="literal">obj</code>’s instance variable and the second half from the surrounding scope, or environment.</p></li></ul></div><p>How can this possibly work? It seems that the block passed to <code class="literal">instance_eval</code> has two environments: the quote instance and the surrounding code environment. In other words, the <code class="literal">@str</code> variable comes from one place and <code class="literal">str2</code> from another.</p></div><div class="sect2" title="Another Important Part of Ruby Closures"><div class="titlepage"><div><div><h2 class="title"><a id="another_important_part_of_ruby_closures"/>Another Important Part of Ruby Closures</h2></div></div></div><p>This example highlights another important part of closure environments in Ruby: the current value of <code class="literal">self</code>. Recall that the <code class="literal">rb_control_frame_t</code> structure for each stack frame, or level, in your Ruby call stack contains a <code class="literal">self</code> pointer, along with the <code class="literal">PC</code>, <code class="literal">SP</code>, and <code class="literal">EP</code> pointers and other values (see <a class="xref" href="ch09.html#rbunderscorecontrolunderscoreframeun" title="Figure 9-19. The rb_control_frame_t structure">Figure 9-19</a>).</p><div class="figure"><a id="rbunderscorecontrolunderscoreframeun"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00225"/><img alt="The rb_control_frame_t structure" src="httpatomoreillycomsourcenostarchimages1854265.png.jpg"/></div></div><p class="title">Figure 9-19. The <code class="literal">rb_control_frame_t</code> structure</p></div><p>The <code class="literal">self</code> pointer records the current value of <code class="literal">self</code> in your Ruby project; it indicates which object is the owner of the method Ruby is currently executing at that time. Each level in your Ruby call stack can contain a different value for <code class="literal">self</code>.</p><p>Recall that whenever you create a closure Ruby sets the <code class="literal">EP</code>, or environment pointer, in the <code class="literal">rb_block_t</code> structure to the referencing environment, giving the code inside the block access to the surrounding variables. And, as it turns out, Ruby also copies the value of <code class="literal">self</code> into <code class="literal">rb_block_t</code>. This means that the current object is also a part of closures in Ruby. <a class="xref" href="ch09.html#in_rubycomma_closure_environments_includ" title="Figure 9-20. In Ruby, closure environments include both the stack frame and the current object from the referencing code.">Figure 9-20</a> looks at what closures contain in Ruby.</p><div class="figure"><a id="in_rubycomma_closure_environments_includ"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00226"/><img alt="In Ruby, closure environments include both the stack frame and the current object from the referencing code." src="httpatomoreillycomsourcenostarchimages1854267.png.jpg"/></div></div><p class="title">Figure 9-20. In Ruby, closure environments include both the stack frame and the current object from the referencing code.</p></div><p><a class="indexterm" id="iddle1429"/>Because the <code class="literal">rb_block_t</code> structure contains the value of <code class="literal">self</code> from the referencing environment, code inside a block can access the values and methods of the object that was active when the closure was created or referenced. This ability probably seems obvious for a block: The current object before and after you call a block doesn’t change. However, if you use a lambda, proc, or binding, Ruby will remember what the current object was when you created it. And, as we’ll see shortly with <code class="literal">instance_eval</code>, Ruby can sometimes change <code class="literal">self</code> when you create a closure, giving your code access to a different object’s values and methods.</p></div><div class="sect2" title="instance_eval Changes self to the Receiver"><div class="titlepage"><div><div><h2 class="title"><a id="instanceunderscoreeval_changes_self_to_t"/>instance_eval Changes self to the Receiver</h2></div></div></div><p>When you call <code class="literal">instance_eval</code> at <span class="inlinemediaobject"><a id="inline_id00370"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> in <a class="xref" href="ch09.html#code_inside_instanceunderscoreeval_h" title="Example 9-16. The code inside instance_eval has access to obj’s instance variable.">Example 9-16</a>, Ruby creates both a closure and a new lexical scope. For example, as you can see in <a class="xref" href="ch09.html#stack_frame_created_by_running_insta" title="Figure 9-21. The stack frame created by running instance_eval has a new value for self.">Figure 9-21</a>, the new stack frame for the code inside <code class="literal">instance_eval</code> uses new values for both <code class="literal">EP</code> and <code class="literal">self</code>.</p><p>On the left of the figure, we see that executing <code class="literal">instance_eval</code> creates a closure. This result should be no surprise. Passing a block to <code class="literal">instance_eval</code> at <span class="inlinemediaobject"><a id="inline_id00371"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> in <a class="xref" href="ch09.html#code_inside_instanceunderscoreeval_h" title="Example 9-16. The code inside instance_eval has access to obj’s instance variable.">Example 9-16</a> creates a new level on the stack and sets <code class="literal">EP</code> to the referencing environment, giving the code inside the block access to the variables <code class="literal">str2</code> and <code class="literal">obj</code>.</p><div class="figure"><a id="stack_frame_created_by_running_insta"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00227"/><img alt="The stack frame created by running instance_eval has a new value for self." src="httpatomoreillycomsourcenostarchimages1854269.png.jpg"/></div></div><p class="title">Figure 9-21. The stack frame created by running <code class="literal">instance_eval</code> has a new value for <code class="literal">self</code>.</p></div><p><a class="indexterm" id="iddle1426"/><a class="indexterm" id="iddle1428"/><a class="indexterm" id="iddle1540"/>However, as you can see on the right of the figure, <code class="literal">instance_eval</code> also changes the value of <code class="literal">self</code> in the new closure. When the code inside the <code class="literal">instance_eval</code> block runs, <code class="literal">self</code> points to the receiver of <code class="literal">instance_eval</code>, or <code class="literal">obj</code>, in <a class="xref" href="ch09.html#code_inside_instanceunderscoreeval_h" title="Example 9-16. The code inside instance_eval has access to obj’s instance variable.">Example 9-16</a>. This allows the code inside <code class="literal">instance_eval</code> to access the values inside the receiver. In <a class="xref" href="ch09.html#code_inside_instanceunderscoreeval_h" title="Example 9-16. The code inside instance_eval has access to obj’s instance variable.">Example 9-16</a>, the code at <span class="inlinemediaobject"><a id="inline_id00372"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span> can access both <code class="literal">@str</code> from inside <code class="literal">obj</code> and <code class="literal">str2</code> from the surrounding code.</p></div><div class="sect2" title="instance_eval Creates a Singleton Class for a New Lexical Scope"><div class="titlepage"><div><div><h2 class="title"><a id="instanceunderscoreeval_creates_a_singlet"/>instance_eval Creates a Singleton Class for a New Lexical Scope</h2></div></div></div><p>The <code class="literal">instance_eval</code> method also creates a new singleton class and sets it as the class for a new lexical scope, as shown in <a class="xref" href="ch09.html#instanceunderscoreeval_creates_a_lexical" title="Figure 9-22. instance_eval creates a lexical scope for a new singleton class.">Figure 9-22</a>.</p><div class="figure"><a id="instanceunderscoreeval_creates_a_lexical"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00228"/><img alt="instance_eval creates a lexical scope for a new singleton class." src="httpatomoreillycomsourcenostarchimages1854271.png.jpg"/></div></div><p class="title">Figure 9-22. <code class="literal">instance_eval</code> creates a lexical scope for a new singleton class.</p></div><p>While executing <code class="literal">instance_eval</code>, Ruby creates a new lexical scope, as shown by the shaded rectangle inside the <code class="literal">instance_eval</code> block. If we had passed a string to <code class="literal">instance_eval</code>, Ruby would have parsed and compiled the string and then created a new lexical scope in the same way.</p><p><a class="indexterm" id="iddle1084"/><a class="indexterm" id="iddle1150"/><a class="indexterm" id="iddle1217"/><a class="indexterm" id="iddle1424"/><a class="indexterm" id="iddle1539"/><a class="indexterm" id="iddle1619"/><a class="indexterm" id="iddle1644"/><a class="indexterm" id="iddle1690"/>Along with the new lexical scope, Ruby creates a singleton class for the receiver, <code class="literal">obj</code>. The singleton class allows you to define new methods for the receiver object (see <a class="xref" href="ch09.html#instanceunderscoreeval_creates_a_lexical" title="Figure 9-22. instance_eval creates a lexical scope for a new singleton class.">Figure 9-22</a>): The <code class="literal">def new_method</code> call inside the <code class="literal">instance_eval</code> block adds <code class="literal">new_method</code> to the singleton class for <code class="literal">obj</code>. As a singleton class, <code class="literal">obj</code> will have the new method, but no other objects or classes in the program will have access to it. (The metaprogramming methods <code class="literal">class_eval</code> and <code class="literal">module_eval</code> work in a similar way and also create a new lexical scope; however, they just use the target class or module for the new scope and don’t create a metaclass or singleton class.)</p><div class="sidebar"><a id="how_ruby_keeps_track_of_lexical_scope_fo"/><p class="title">How Ruby Keeps Track of Lexical Scope for Blocks</p><p>Let’s take a closer look at how Ruby represents lexical scopes internally. <a class="xref" href="ch09.html#rubyapostrophes_c_source_code_internally" title="Figure 9-23. Ruby’s C source code internally uses a separate structure called cref to track lexical scopes.">Figure 9-23</a> shows the lexical scope Ruby creates for the <code class="literal">Quote</code> class.</p><div class="figure"><a id="rubyapostrophes_c_source_code_internally"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00229"/><img alt="Ruby’s C source code internally uses a separate structure called cref to track lexical scopes." src="httpatomoreillycomsourcenostarchimages1854273.png.jpg"/></div></div><p class="title">Figure 9-23. Ruby’s C source code internally uses a separate structure called <code class="literal">cref</code> to track lexical scopes.</p></div><p>You can see the <code class="literal">display</code> method’s code snippet represented as a rectangle on the left side of the figure, inside the class <code class="literal">Quote</code> declaration. On the right side of the rectangle, you can see a small arrow pointing to a structure labeled <code class="literal">cref</code>, which is the actual lexical scope. This, in turn, contains a pointer to the <code class="literal">Quote</code> class (<code class="literal">nd_clss</code>) and to the parent lexical scope (<code class="literal">nd_next</code>).</p><p>As indicated by the figure, Ruby’s C source code internally represents lexical scopes using these <code class="literal">cref</code> structures. The small arrow on the left shows that each piece of code in your program refers to a <code class="literal">cref</code> structure with a pointer. This pointer keeps track of which lexical scope that piece of code belongs to.</p><p>Notice one important detail about <a class="xref" href="ch09.html#rubyapostrophes_c_source_code_internally" title="Figure 9-23. Ruby’s C source code internally uses a separate structure called cref to track lexical scopes.">Figure 9-23</a>: Both the code snippet and lexical scope inside the <code class="literal">class Quote</code> declaration refer to a single <code class="literal">RClass</code> structure. There’s a one-to-one correspondence between code, lexical scope, and class. Every time Ruby executes the code inside the <code class="literal">class Quote</code> declaration, it uses the same copy of the <code class="literal">RClass</code> structure, the one for <code class="literal">Quote</code>. This behavior seems obvious; the code inside a class declaration always refers to the same class.</p><p>For blocks, however, things aren’t so simple. Using metaprogramming methods such as <code class="literal">instance_eval</code>, you can specify a different lexical scope for the same piece of code—a block, for example—to use each time it is executed. <a class="xref" href="ch09.html#blockapostrophes_code_canapostrophet" title="Figure 9-24. The block’s code can’t refer to a single lexical scope because the scope’s class depends on the value of obj.">Figure 9-24</a> shows the problem.</p><div class="figure"><a id="blockapostrophes_code_canapostrophet"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00230"/><img alt="The block’s code can’t refer to a single lexical scope because the scope’s class depends on the value of obj." src="httpatomoreillycomsourcenostarchimages1854275.png.jpg"/></div></div><p class="title">Figure 9-24. The block’s code can’t refer to a single lexical scope because the scope’s class depends on the value of <code class="literal">obj</code>.</p></div><p><a class="indexterm" id="iddle1218"/><a class="indexterm" id="iddle1425"/>We learned in the previous section that Ruby creates a singleton class for the lexical scope created by <code class="literal">instance_eval</code>. However, this code might be run many times for different values of <code class="literal">obj</code>. In fact, your program might execute this code at the same time in different threads. This requirement means that Ruby can’t keep a pointer to a single <code class="literal">cref</code> structure for the block as it does for a class definition. This block scope will refer to different classes at different times.</p><p>Ruby solves this problem by saving a pointer to the lexical scope used by blocks in a different place: as an entry on YARV’s internal stack (see <a class="xref" href="ch09.html#ruby_tracks_lexical_scope_for_blocks_usi" title="Figure 9-25. Ruby tracks lexical scope for blocks using the svar/cref entry on the stack, not using the block’s code snippet.">Figure 9-25</a>).</p><div class="figure"><a id="ruby_tracks_lexical_scope_for_blocks_usi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00231"/><img alt="Ruby tracks lexical scope for blocks using the svar/cref entry on the stack, not using the block’s code snippet." src="httpatomoreillycomsourcenostarchimages1854277.png.jpg"/></div></div><p class="title">Figure 9-25. Ruby tracks lexical scope for blocks using the <code class="literal">svar/cref</code> entry on the stack, not using the block’s code snippet.</p></div><p>On the left side of the figure, you can see the call to <code class="literal">instance_eval</code> and the code snippet for the block inside. In the center of the figure is the <code class="literal">cref</code> structure for the lexical scope. On the right side, you can see YARV saves a pointer to the scope in the second entry on its stack, labeled <code class="literal">svar/cref</code>.</p><p>Recall from <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a> that the second entry on YARV’s internal stack contains one of two values: <code class="literal">svar</code> or <code class="literal">cref</code>. As we saw in <a class="xref" href="ch03.html#experiment_3-2_exploring_special_variabl" title="Experiment 3-2: Exploring Special Variables">Experiment 3-2: Exploring Special Variables</a>, <code class="literal">svar</code> saves a pointer to a table of special variables, such as the result of the last regular expression match, while executing a method. But while executing a block, YARV saves the <code class="literal">cref</code> value here instead. Usually this value isn’t important because blocks normally use the lexical scope of the surrounding code. But when executing <code class="literal">instance_eval</code> and a few other metaprogramming features, such as <code class="literal">module_eval</code> and <code class="literal">instance_exec</code>, Ruby sets <code class="literal">cref</code> in this way to the current lexical scope.</p></div></div></div><div class="sect1" title="Experiment 9-2: Using a Closure to Define a Method"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_9-2_using_a_closure_to_define"/>Experiment 9-2: Using a Closure to Define a Method</h1></div></div></div><p><a class="indexterm" id="iddle1170"/><a class="indexterm" id="iddle1225"/><a class="indexterm" id="iddle1268"/><a class="indexterm" id="iddle1627"/>Another common metaprogramming pattern in Ruby is to dynamically define methods in a class using <code class="literal">define_method</code>. For example, <a class="xref" href="ch09.html#ruby_class_that_displays_a_string_from" title="Example 9-17. A Ruby class that displays a string from an instance variable">Example 9-17</a> shows a simple Ruby class that prints out a string when you call <code class="literal">display</code>.</p><div class="example"><a id="ruby_class_that_displays_a_string_from"/><p class="title">Example 9-17. A Ruby class that displays a string from an instance variable</p><div class="example-contents"><pre class="programlisting">class Quote
  def initialize
    @str = "The quick brown fox jumps over the lazy dog"
  end
  def display
    puts @str
  end
end
Quote.new.display
 =&gt; The quick brown fox jumps over the lazy dog</pre></div></div><p>This code is similar to that in <a class="xref" href="ch09.html#adding_a_method_to_a_class_using_the_def" title="Example 9-1. Adding a method to a class using the def keyword">Example 9-1</a>, except that we use an instance variable <code class="literal">@str</code> to hold the string value.</p><div class="sect2" title="Using define_method"><div class="titlepage"><div><div><h2 class="title"><a id="using_defineunderscoremethod"/>Using define_method</h2></div></div></div><p>We could have used metaprogramming to define <code class="literal">display</code> in a more verbose but dynamic way, as shown in <a class="xref" href="ch09.html#using_defineunderscoremethod_to_create_a" title="Example 9-18. Using define_method to create a method">Example 9-18</a>.</p><div class="example"><a id="using_defineunderscoremethod_to_create_a"/><p class="title">Example 9-18. Using <code class="literal">define_method</code> to create a method</p><div class="example-contents"><pre class="programlisting">    class Quote
      def initialize
        @str = "The quick brown fox jumps over the lazy dog"
      end
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   define_method :display do
        puts @str
      end
    end</pre></div></div><p>We call <code class="literal">define_method</code> at <span class="inlinemediaobject"><a id="inline_id00374"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> instead of the normal <code class="literal">def</code> keyword. Because the name of the new method is passed as the argument <code class="literal">:display</code>, we can dynamically construct the method name from some data values or iterate over an array of method names, calling <code class="literal">define_method</code> for each one.</p><p>But there is another subtle difference between <code class="literal">def</code> and <code class="literal">define_method</code>. For <code class="literal">define_method</code> we provide the body of the method as a block; that is, we use a <code class="literal">do</code> keyword at <span class="inlinemediaobject"><a id="inline_id00375"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. This syntax difference may seem minor, but remember that blocks are actually closures. Adding <code class="literal">do</code> introduces a closure, meaning that the code inside the new method has access to the environment outside. This is not the case with the <code class="literal">def</code> keyword.</p><p>There are no local variables present in <a class="xref" href="ch09.html#using_defineunderscoremethod_to_create_a" title="Example 9-18. Using define_method to create a method">Example 9-18</a> when we call <code class="literal">define_method</code>, but suppose that another place in our application did have <a class="indexterm" id="iddle1603"/><a class="indexterm" id="iddle1984"/><a class="indexterm" id="iddle2128"/>values that we wanted to use inside our new method. By using a closure, Ruby makes an internal copy of the surrounding environment on the heap, which the new method will be able to access.</p></div><div class="sect2" title="Methods Acting as Closures"><div class="titlepage"><div><div><h2 class="title"><a id="methods_acting_as_closures"/>Methods Acting as Closures</h2></div></div></div><p>Now for another test. <a class="xref" href="ch09.html#now_commercial_atstr_has_only_the_first" title="Example 9-19. Now @str has only the first half of the string.">Example 9-19</a> stores only the first half of the string in the instance variable. In a moment, we’ll write a new method for the <code class="literal">Quote</code> class to access this.</p><div class="example"><a id="now_commercial_atstr_has_only_the_first"/><p class="title">Example 9-19. Now <code class="literal">@str</code> has only the first half of the string.</p><div class="example-contents"><pre class="programlisting">class Quote
  def initialize
    @str = "The quick brown fox"
  end
end</pre></div></div><p><a class="xref" href="ch09.html#using_a_closure_with_defineunderscoremet" title="Example 9-20. Using a closure with define_method">Example 9-20</a> shows how we can use a closure to access both the instance variable and the surrounding environment.</p><div class="example"><a id="using_a_closure_with_defineunderscoremet"/><p class="title">Example 9-20. Using a closure with <code class="literal">define_method</code></p><div class="example-contents"><pre class="programlisting">    def create_method_using_a_closure
      str2 = "jumps over the lazy dog."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   Quote.send(:define_method, :display) do
        puts "#{@str} #{str2}"
      end
    end</pre></div></div><p>Because <code class="literal">define_method</code> is a private method in the <code class="literal">Module</code> class, we need to use the confusing <code class="literal">send</code> syntax at <span class="inlinemediaobject"><a id="inline_id00377"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Earlier, at <span class="inlinemediaobject"><a id="inline_id00378"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in <a class="xref" href="ch09.html#using_defineunderscoremethod_to_create_a" title="Example 9-18. Using define_method to create a method">Example 9-18</a>, we were able to call <code class="literal">define_method</code> directly because we used it inside the class’s scope. We can’t do that from other places in the application. By using <code class="literal">send</code>, the <code class="literal">create_method_using_a_closure</code> method can call a private method that it wouldn’t normally have had access to.</p><p>But more importantly, notice that the <code class="literal">str2</code> variable is preserved in the heap for the new method to use even after <code class="literal">create_method_using_a_closure</code> returns:</p><a id="pro_id00060"/><pre class="programlisting">create_method_using_a_closure
Quote.new.display
 =&gt; The quick brown fox jumps over the lazy dog.</pre><p>Internally, Ruby treats this as a call to <code class="literal">lambda</code>. That is, this code functions the same way as if I had written the code in <a class="xref" href="ch09.html#passing_a_proc_to_defineunderscoremethod" title="Example 9-21. Passing a proc to define_method">Example 9-21</a>.</p><div class="example"><a id="passing_a_proc_to_defineunderscoremethod"/><p class="title">Example 9-21. Passing a proc to <code class="literal">define_method</code></p><div class="example-contents"><pre class="programlisting">    class Quote
      def initialize
        @str = "The quick brown fox"
      end
    end
    def create_method_using_a_closure
      str2 = "jumps over the lazy dog."
      lambda do
        puts "#{@str} #{str2}"
      end
    end
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> Quote.send(:define_method, :display, create_method_using_a_closure)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> Quote.new.display</pre></div></div><p><a class="xref" href="ch09.html#passing_a_proc_to_defineunderscoremethod" title="Example 9-21. Passing a proc to define_method">Example 9-21</a> separates the code that creates the closure and defines the method. Because at <span class="inlinemediaobject"><a id="inline_id00381"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we pass three arguments to <code class="literal">define_method</code>, Ruby expects the third to be a proc object. While this is an even more verbose way to write this code, it’s a bit less confusing because calling <code class="literal">lambda</code> makes it clear that Ruby will create a closure.</p><p>Finally, when we call the <code class="literal">new</code> method at <span class="inlinemediaobject"><a id="inline_id00382"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, Ruby resets the <code class="literal">self</code> pointer from the closure to receiver object, similar to the way that <code class="literal">instance_eval</code> works. This allows the new method to access <code class="literal">@str</code> as you would expect.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00038"/>Summary</h1></div></div></div><p>In this chapter we’ve seen how the concept of closures—the idea central to the way blocks, lambdas, and procs work in Ruby—also applies to methods such as <code class="literal">eval</code>, <code class="literal">instance_eval</code>, and <code class="literal">define_method</code>. The same underlying concept explains how these different Ruby methods work. In a similar way, the concept of lexical scope underpins all of the ways that Ruby allows you to create a method and assign it to a class. Understanding the concept of lexical scope should make the different uses of Ruby’s <code class="literal">def</code> keyword and <code class="literal">class &lt;&lt;</code> syntax easier to understand.</p><p>While metaprogramming might seem complex at first, learning how Ruby works internally can help us understand what Ruby’s metaprogramming features actually do. What seems initially like a large set of different, unrelated methods in a confusing API turn out to be related by a few important ideas. Studying Ruby internals allows us to see these concepts and to understand what they mean.</p></div></div></body></html>