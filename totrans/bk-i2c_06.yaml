- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I²C Variants
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter briefly describes several variants of the I²C bus, including the
    System Management Bus (SMBus), VESA DDC and E-DDC, ACCESS.bus, and two-wire interface.
    For the most part, these variants apply a protocol on top of the physical two-wire
    interface of the I²C bus, defining messages and other data flowing across the
    bus.
  prefs: []
  type: TYPE_NORMAL
- en: Going into detail on such protocol extensions is generally beyond the scope
    of this book. Nevertheless, this chapter gives an overview of those protocols
    (and information for other specific bus variants) and explains where you can find
    more information about these variants. We begin with the SMBus protocol, which
    deserves the most in-depth discussion, since it is widely used in computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 SMBus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *SMBus* was originally developed by Intel and Duracell as a means for managing
    battery power in computer-based systems. SMBus v1.0 and v1.1 dealt with low-power
    devices such as battery power management systems, while SMBus v2.0 added high-power
    devices to the specification.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem unnecessary to devote a whole section to the SMBus implementation
    of the I²C bus, since there are few SMBus peripherals and most embedded software
    designers don’t spend much time on battery management, the SMBus’s main use. However,
    Linux I²C support, including the Raspberry Pi, provides API functions based on
    the SMBus protocol. For that reason alone, this slightly more-than-brief coverage
    of the SMBus is worthwhile. Furthermore, of all the I²C extensions and variants,
    the SMBus is by far the most common.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the few peripheral ICs that support the SMBus protocol will behave like
    standard I²C peripherals if you ignore the information in this chapter and simply
    program them according to their datasheets. Many devices support some aspects
    of the SMBus protocol even though they do not support the full protocol. Many
    of the MCP23017 GPIO expander’s command sequences, for example, follow the SMBus
    protocol in this chapter (see Chapter 13). Therefore, having an understanding
    of the SMBus can help you with many peripherals out there, even if they don’t
    fully support the SMBus specification.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 Differences Between SMBus and Standard I²C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though it’s based on the I²C bus, the SMBus places some additional requirements
    on the I²C signals:'
  prefs: []
  type: TYPE_NORMAL
- en: The clock—SMBCLK, the SMBus name for SCL—must be between 10 kHz and 100 kHz.
    In particular, note that SMBus does not support arbitrary clock stretching (below
    10 kHz). Later versions of the SMBus specification also support 400-kHz and 1-MHz
    signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMBus v3.0 supports signal voltages in the range of 1.8 V to 5 V. Also, SMBus
    explicitly states that a logic 0 is less than 0.8 V and a logic 1 is greater than
    1.35 V.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMBus specifies a clock low timeout of 35 msec (about 15 Hz, assuming a 50 percent
    duty cycle). The I²C standard specifies no such timeout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMBus specifies both rise and fall times for bus signals; the I²C standard provides
    no such specifications (other than bus capacitance, which affects rise and fall
    times).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NAK behavior is different between I²C and SMBus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMBus devices must always acknowledge the receipt of their address on the I²C
    bus; standard I²C protocol doesn’t require this (for example, if the device is
    busy doing something else).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SMBus supports three types of devices on the bus: controllers, peripherals,
    and a single, special version of a controller known as the *host*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All devices on the SMBus must have a unique ID associated with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMBus v2.0 introduced the concept of a dynamically assigned device address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMBus supports optional hardware signals, SMBAlert and SMBSuspend, that can
    create interrupts or suspend operations for low-power operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SMBus also reserves certain device addresses for purposes such as prototype
    devices, far beyond the number that the I²C bus reserves for special use. The
    SMBus also supports dynamically specified device addresses, allowing devices to
    choose their addresses during operation.
  prefs: []
  type: TYPE_NORMAL
- en: On top of the hardware differences, the SMBus specification calls out several
    protocol changes, including features for transferring blocks of data, bus-specific
    commands, and device enumeration. The SMBus specification provides more details
    (link provided in “For More Information” at the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2 SMBus Electrical Specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted previously, the SMBus SMBCLK signal must operate between 10 kHz and
    maximum bus speed (100 kHz, 400 kHz, or 1 MHz). In reality, most modern SMBus
    implementations operate at 50 kHz or faster. NXP’s documentation (see the SMBus
    quick start guide in “For More Information”) states that a system must not reduce
    the clock frequency to the minimum speed even in response to clock stretching
    on the part of peripheral devices. In addition, SMBus devices must be ready to
    operate within 500 msec after power is applied.
  prefs: []
  type: TYPE_NORMAL
- en: The SMBus has better electrical specifications than the standard I²C bus. It
    defines a logic 0 on the clock or data lines as 0.8 V or less and a logic 1 as
    1.35 V or greater.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3 SMBus Reserved Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SMBus reserves several addresses above and beyond the I²C reserved addresses
    (see section 2.5, “Special Addresses,” in Chapter 2). In addition to these addresses,
    the SMBus reserves 7-bit addresses 0x08 for SMBus host devices, 0x0C for SMBus
    alert responses, and 0x61 for the SMBus device default address. The SMBus specification
    also reserves certain device address for specific purposes, as described in [Table
    5-1](#table5-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: Reserved SMBus Device Addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '| Address bits | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0001-000 | SMBus host |'
  prefs: []
  type: TYPE_TB
- en: '| 0001-001 | Smart battery charger |'
  prefs: []
  type: TYPE_TB
- en: '| 0001-010 | Smart battery selector or smart battery system manager |'
  prefs: []
  type: TYPE_TB
- en: '| Address bits | Description |'
  prefs: []
  type: TYPE_TB
- en: '| 0001-011 | Smart battery |'
  prefs: []
  type: TYPE_TB
- en: '| 0001-100 | SMBus alert response |'
  prefs: []
  type: TYPE_TB
- en: '| 0101-000 | ACCESS.bus host |'
  prefs: []
  type: TYPE_TB
- en: '| 0101-100 | Originally reserved for LCD contrast controllers (may be reassigned
    in future versions of the SMBus) |'
  prefs: []
  type: TYPE_TB
- en: '| 0101-101 | Originally reserved for CCFL backlight controllers (may be reassigned
    in future versions of the SMBus) |'
  prefs: []
  type: TYPE_TB
- en: '| 0110-111 | ACCESS.bus default address |'
  prefs: []
  type: TYPE_TB
- en: '| 1000-0xx | Originally reserved for PCMCIA socket controllers (may be reassigned
    in future versions of the SMBus) |'
  prefs: []
  type: TYPE_TB
- en: '| 1000-100 | Originally reserved for VGA graphics controllers (may be reassigned
    in future versions of the SMBus) |'
  prefs: []
  type: TYPE_TB
- en: '| 1001-0xx | Unrestricted addresses |'
  prefs: []
  type: TYPE_TB
- en: '| 1100-001 | SMBus device default address |'
  prefs: []
  type: TYPE_TB
- en: Please consult the SMBus documentation to see if there are any additions to
    this list. Later versions of the SMBus standard may add device addresses to this
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4 SMBus Protocol Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard I²C bus protocol specifies only the address byte, and R/W bit,
    format. It does not define any further data appearing on the bus. In contrast,
    the SMBus protocol defines several different command formats including Quick Command,
    Send Byte, Receive Byte, Write Byte, Write Word, Read Byte, Read Word, Process
    Call, Block Read, and Block Write.
  prefs: []
  type: TYPE_NORMAL
- en: SMBus devices do not have to implement all the SMBus protocol commands—only
    those that are relevant to the particular device. If a device supports the Quick
    Command, it likely supports only that command. Similarly, if the device supports
    the Read Byte command and the Send Byte command, it likely supports only those
    two commands. The remaining SMBus protocol commands include an extra *command
    byte*; this byte can specify the particular command protocol to use. The following
    subsections define each of these command types.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.1 SMBus Quick Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SMBus Quick Commands are simple 1-bit commands built into the R/W bit of the
    address byte (see [Figure 5-1](#figure5-1)). The Quick Commands transmit a single
    bit to the peripheral device that can be used to turn the device on or off or
    perform some other operation based on a single bit of binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Quick Command format'
  prefs: []
  type: TYPE_NORMAL
- en: There is no additional data beyond the address byte sent to the device with
    a Quick Command.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.2 SMBus Send Byte and Read Byte Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SMBus Send Byte and Read Byte commands include 1 byte of data after the
    address byte. The R/W bit of the address byte specifies the particular command
    (read or write; see [Figure 5-2](#figure5-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: Send or Read Byte command format'
  prefs: []
  type: TYPE_NORMAL
- en: With a Send Byte command, the host/controller device transmits the second byte
    to the peripheral; with the Read Byte command, the peripheral places the data
    on the SMBDAT (SDA) line to be read by the host/controller device.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.3 SMBus Read Byte and Read Word Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SMBus Read Byte command allows you to read a single byte of data from a
    peripheral device with no way to specify what byte data you’re reading. That command
    is useful for simple devices that return a single byte value, such as reading
    a single set of eight digital I/O pins. The SMBus Read Byte and Word commands,
    on the other hand, include a special command byte that allows you to specify parameter
    information to select the particular byte you want to read. This could be, for
    example, a register or memory address or other selection or control information.
    The sequence for a Read Byte command appears in [Figure 5-3](#figure5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: Read Byte command format'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence for a Read Word command appears in [Figure 5-4](#figure5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Read Word command format'
  prefs: []
  type: TYPE_NORMAL
- en: Because the controller must first write the command byte to the peripheral device,
    the Read Byte and Read Word commands begin with a write operation (bit 0 of the
    address byte contains a 0). Then the sequence must include a restart operation
    followed by a second address byte with bit 0 containing a 1 (for read). Then the
    controller reads the next byte or word (depending on the command) from the peripheral
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Not all devices support both Read Byte and Read Word commands. The peripheral
    device’s design determines whether the controller can read a single byte, a word,
    or both. If the device supports reading both bytes and words using this command,
    then the controller must somehow specify whether it wants to read a byte or a
    word from the device, typically using a bit within the command byte.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.4 SMBus Write Byte and Write Word Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SMBus Write Byte and Write Word commands also include a command byte that
    allows you to specify parameter information to select the particular byte or word
    you want to write to the peripheral. This could be a register or memory address
    or other selection or control information. The sequence for a Write Byte command
    appears in [Figure 5-5](#figure5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: Write Byte command format'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence for a Write Word command appears in [Figure 5-6](#figure5-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Write Word command format'
  prefs: []
  type: TYPE_NORMAL
- en: Because the controller is strictly writing to the peripheral device, there is
    no need for the restart command and the extra address-R/W byte in these sequences.
    As for the Read Byte and Read Word commands, the device’s design determines whether
    it supports the Write Byte, Write Word, or both commands. If the device supports
    both byte and word writes, then presumably the controller must somehow specify
    the size to write within the command byte.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.5 SMBus Block Read Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although most SMBus transactions involve reading or writing a single byte or
    word, a few devices support larger data transfers. The SMBus Block Read command
    handles reading blocks of data. As for the Read Byte and Read Word command, the
    controller transmits an address byte (with the LO bit equal to 0 to denote a write
    operation) followed by a command byte. Then the controller sends a repeated start
    operation followed by an address byte with the LO bit equal to 1 (to denote a
    read). The peripheral responds by sending a byte containing the byte count followed
    by that many data bytes, as shown in [Figure 5-7](#figure5-7).
  prefs: []
  type: TYPE_NORMAL
- en: The peripheral specifies how many bytes it is returning in the byte count value.
    In theory, it is possible for the controller to specify how many bytes it wants
    to read by providing this count as part of the command byte field. However, the
    peripheral’s design determines who specifies the number of bytes returned; it
    could be a fixed value or a programmed value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Block Read sequence'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.6 SMBus Block Write Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Of course, the SMBus provides a Block Write complement to the Block Read command.
    The command is a bit simpler than the Block Read command, as you don’t have to
    reverse the data direction after sending the command byte. [Figure 5-8](#figure5-8)
    provides the write sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Block Write sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no need to resend the device address with a new R/W bit, this
    sequence is shorter (and more efficient) than the Block Read command operation.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 VESA DDC and E-DDC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The VESA DDC (obsolete) and E-DDC (modern) interfaces allow communication between
    a host (computer) system and a display monitor (the VESA device). The DDC/E-DDC
    (hereafter E-DDC) is a two-wire communication bus built on the I²C bus. The E-DDC
    protocol allows the host system to determine monitor information, set display
    parameters such as brightness, and perform other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Displays that are compatible with VESA E-DDC look like I²C peripherals on the
    I²C bus. In particular, compatible devices can respond to the (8-bit) addresses
    0xA0, 0xA1, 0xA4, or 0xA5 and a command register at address 0x60\. The host (computer)
    exchanges information with the display through these addresses. For the most part,
    this is display identification and parameter information.
  prefs: []
  type: TYPE_NORMAL
- en: VESA specifies I²C signaling only in the VGA, HDMI, and DVI interfaces. DisplayPort
    interfaces use a different mechanism for transferring data between the host computer
    and the display device. See the VESA E-DDC specifications for more details (link
    in “For More Information”).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 ACCESS.bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ACCESS.bus system was an early, pre-USB attempt to allow the attachment
    of low-speed peripheral devices such as keyboards and mice to a computer system.
    The intent was to support hot-pluggable devices that could be attached and removed
    without powering down the system, unlike AT and PS-2 keyboards of that era. ACCESS.bus
    was based on the I²C bus, supporting up to 125 devices.
  prefs: []
  type: TYPE_NORMAL
- en: As USB arrived about a year later, interest in ACCESS.bus quickly diminished,
    though it did become the basis for the VESA DDC communication system (and the
    obsolete Apple Desktop Bus).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Two-Wire Interface and Two-Wire Serial Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Two-wire interface (TWI)* and *two-wire serial interface (TWSI)* are names
    that various manufacturers use to avoid trademark and compliance issues with I²C.
    Some manufacturers will often use TWI when their devices don’t completely support
    the full I²C standard—if a device doesn’t support the START byte, for example.
    Some people use this term if the bus doesn’t support multiple controllers, clock
    stretching, or other I²C features. In general, if you see this term being used,
    you can probably assume that the device doesn’t fully support the I²C standard,
    though it will likely work fine in your application if you aren’t relying on cutting-edge
    features.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter briefly covered various protocol extensions to the I²C bus including
    the SMBus, VESA (DDC and E-DDC), ACCESS.bus, and the TWI. Of these, the SMBus
    and VESA bus are commonly used today. The SMBus is largely employed for system
    power management, and the VESA variants are used to control video displays.
  prefs: []
  type: TYPE_NORMAL
- en: The SMBus protocol is significant because Linux’s I²C support is based on it.
    Therefore, this chapter spent considerable time discussing several SMBus commands,
    including Quick Commands, Send and Read Byte commands, Read Byte and Read Word
    commands, Write Byte and Write Word commands, and Block Read and Block Write commands.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you are dealing with the specific device categories these higher-level
    protocols support, it’s unlikely you’ll need more than a passing familiarity with
    these protocols. Nevertheless, it is important to understand that, at their core,
    these protocols are still based on the venerable I²C bus.
  prefs: []
  type: TYPE_NORMAL
