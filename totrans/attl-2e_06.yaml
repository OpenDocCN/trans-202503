- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: AUTOMATIC MAKEFILES WITH AUTOMAKE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Automake自动生成Makefile
- en: '*If you understand, things are just as they are; if you do not understand,
    things are just as they are.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你理解了，事情就是它们本来的样子；如果你不理解，事情就是它们本来的样子。'
- en: —Zen proverb*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —禅宗格言*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'Shortly after Autoconf began its journey to success, David MacKenzie started
    working on a new tool for automatically generating makefiles for a GNU project:
    Automake. During early development of the *GNU Coding Standards (GCS)*, it became
    apparent to MacKenzie that because the *GCS* is fairly specific about how and
    where a project’s products should be built, tested, and installed, much of a GNU
    project makefile was boilerplate material. Automake takes advantage of this fact
    to make maintainers’ lives easier and to make the user’s experience more consistent.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Autoconf开始走向成功后不久，David MacKenzie开始着手开发一个用于自动生成GNU项目makefile的新工具：Automake。在*GNU编码标准（GCS）*的早期开发中，MacKenzie意识到，因为*GCS*对项目产品的构建、测试和安装的要求非常具体，很多GNU项目的makefile实际上是模板内容。Automake利用这一点，使得维护者的工作更加轻松，并且让用户的体验更加一致。
- en: MacKenzie’s work on Automake lasted almost a year, ending around November 1994\.
    A year later, in November 1995, Tom Tromey (of Red Hat and Cygnus fame) took over
    the Automake project and played a significant role in its development. Although
    MacKenzie had written the initial version of Automake in Bourne shell script,
    Tromey completely rewrote the tool in Perl and continued to maintain and enhance
    Automake over the next five years.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MacKenzie在Automake上的工作持续了近一年，直到1994年11月左右结束。一年后，即1995年11月，Tom Tromey（来自Red Hat和Cygnus）接管了Automake项目，并在其发展中发挥了重要作用。尽管MacKenzie最初用Bourne
    shell脚本编写了Automake的版本，Tromey完全用Perl重写了这个工具，并在接下来的五年中继续维护和增强Automake。
- en: By the end of 2000, Alexandre Duret-Lutz had essentially taken over maintenance
    of the Automake project. His role as project lead lasted until about mid-2007,
    at which point Ralf Wildenhues^([1](footnote.xhtml#ch06fn1)) took the wheel, with
    occasional input from Akim Demaille and Jim Meyering. From 2012 to early 2017,
    Automake was maintained by Stefano Lattarini while he worked for Google in Switzerland.
    The current maintainer is Mathieu Lirzin, a computer science master’s student
    at the University of Bordeaux in France.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到2000年底，Alexandre Duret-Lutz几乎接管了Automake项目的维护工作。他作为项目负责人一直持续到大约2007年中期，此时Ralf
    Wildenhues^([1](footnote.xhtml#ch06fn1))接手了项目，偶尔有Akim Demaille和Jim Meyering的参与。从2012年到2017年初，Stefano
    Lattarini在为Google瑞士分部工作期间负责Automake的维护。现任维护者是Mathieu Lirzin，他是法国波尔多大学计算机科学硕士生。
- en: 'Most of the complaints I’ve seen about the Autotools are ultimately associated
    with Automake. The reasons are simple: Automake provides the highest level of
    abstraction over the build system and imposes a fairly rigid structure on projects
    that use it. Automake’s syntax is concise—in fact, it’s terse, almost to a fault.
    One Automake statement represents a *lot* of functionality. But once you understand
    it, you can get a fairly complete, complex, and functionally correct build system
    up and running in short order—that is, in minutes, not hours or days.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我所见到的大多数关于Autotools的抱怨最终都与Automake有关。原因很简单：Automake为构建系统提供了最高级别的抽象，并且对使用它的项目强加了一个相当严格的结构。Automake的语法简洁——实际上，它是简练的，几乎到了极致。一个Automake语句代表了*大量*功能。但是，一旦你理解了它，你就能在短时间内（也就是几分钟，而不是几个小时或几天）建立起一个相对完整、复杂且功能正确的构建系统。
- en: In this chapter, I provide you with some insight into the inner workings of
    Automake. With such insight, you’ll begin to feel comfortable not only with what
    Automake can do for you but also with extending it in areas where its automation
    falls short.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将为你提供一些关于Automake内部工作原理的见解。通过这些见解，你将不仅对Automake能为你做什么感到熟悉，而且会开始在其自动化不足的领域进行扩展。
- en: Getting Down to Business
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始正式工作
- en: Let’s face it—getting a makefile right is often difficult. The devil, as they
    say, is in the details. Consider the following changes to the files in our project
    directory structure as we continue to improve the project build system for Jupiter.
    Let’s start by cleaning up our work area. You can do this using `make distclean`,
    or if you’re building from a GitHub repository work area, you can use a form of
    the `git clean` command:^([2](footnote.xhtml#ch06fn2))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实吧——正确编写 Makefile 通常很难。正如人们所说，魔鬼藏在细节中。考虑在我们继续改进 Jupiter 项目的构建系统时，对项目目录结构中的文件进行以下更改。让我们从清理工作区开始。你可以使用
    `make distclean` 来完成这项工作，或者如果你是从 GitHub 仓库工作区构建的，也可以使用 `git clean` 命令的某种形式：^([2](footnote.xhtml#ch06fn2))
- en: Git tag 6.0
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 6.0
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `rm` command at ➊ deletes our hand-coded *Makefile.in* templates and the
    `bootstrap.sh` script we wrote to ensure that all the support scripts and files
    are copied into the root of our project directory. We won’t need this script anymore
    because we’re upgrading Jupiter to Automake proper. (For the sake of brevity,
    I used `echo` statements at ➋ and ➌ to write the new *Makefile.am* files; you
    can use a text editor if you wish.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `rm` 命令删除了我们手动编写的 *Makefile.in* 模板和我们为确保所有支持脚本和文件被复制到项目根目录中而编写的 `bootstrap.sh`
    脚本。由于我们正在将 Jupiter 升级为正式的 Automake，因此不再需要这个脚本。（为了简洁起见，我在 ➋ 和 ➌ 使用了 `echo` 语句来写入新的
    *Makefile.am* 文件；如果你愿意，可以使用文本编辑器。）
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is a hard carriage return at the end of the line at ➌. The shell will
    continue to accept input after the carriage return until the quotation is closed*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 ➌ 处的行末有一个硬回车符。Shell 会继续接受输入，直到引号关闭为止。*'
- en: I used the `touch` command at ➍ to create new, empty versions of the *NEWS*,
    *README*, *AUTHORS*, and *ChangeLog* files in the project root directory. (The
    *INSTALL* and *COPYING* files are added by `autoreconf -i`.) These files are required
    by the *GCS* for all GNU projects. And although they’re not required for non-GNU
    projects, they’ve become something of an institution in the OSS world; users have
    come to expect them.^([3](footnote.xhtml#ch06fn3))
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➍ 使用了 `touch` 命令来创建项目根目录中新的、空的 *NEWS*、*README*、*AUTHORS* 和 *ChangeLog* 文件。（*INSTALL*
    和 *COPYING* 文件是通过 `autoreconf -i` 添加的。）这些文件是 *GCS* 对所有 GNU 项目所要求的。尽管它们对于非 GNU
    项目并非必需，但它们已经成为开源世界中的一种惯例；用户已经习惯了这些文件的存在。^([3](footnote.xhtml#ch06fn3))
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* GCS *covers the format and contents of these files. Sections 6.7 and
    6.8 cover the* NEWS *and* ChangeLog *files, respectively, and Section 7.3 covers
    the* README, INSTALL, *and* COPYING *files. The* AUTHORS *file is a list of people
    (names and optional email addresses) to whom attribution should be given.^([4](footnote.xhtml#ch06fn4))*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS* 覆盖了这些文件的格式和内容。第 6.7 和 6.8 节分别讲解了 *NEWS* 和 *ChangeLog* 文件，第 7.3 节则涵盖了
    *README*、*INSTALL* 和 *COPYING* 文件。*AUTHORS* 文件是一个列出需要给与归属的人员（姓名和可选的电子邮件地址）清单。^([4](footnote.xhtml#ch06fn4))'
- en: It can be a little painful to maintain a *ChangeLog* file—especially since you’ve
    already done it once as you added commit messages to your repository commits.
    To simplify the process, consider using a shell script to scrape your repository
    log into *ChangeLog* before you make a new release. There are existing scripts
    available on the internet; for example, *gnulib* (see [Chapter 13](ch13.xhtml))
    provides the `gitlog-to-changelog` script, which can be used to import a git repository’s
    log information into *ChangeLog* prior to release.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 维护 *ChangeLog* 文件可能有点痛苦——特别是因为你已经在为你的仓库提交添加提交信息时做过一次了。为了简化这个过程，考虑使用一个 shell
    脚本在你做新版本发布之前，将仓库日志抓取到 *ChangeLog* 中。网络上有现成的脚本可供使用；例如，*gnulib*（见 [第13章](ch13.xhtml)）提供了
    `gitlog-to-changelog` 脚本，可以用来在发布之前将 git 仓库的日志信息导入 *ChangeLog* 中。
- en: '*Enabling Automake in configure.ac*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在 configure.ac 中启用 Automake*'
- en: 'To enable Automake within the build system, I’ve added a single line to *configure.ac*:
    a call to `AM_INIT_AUTOMAKE` between the calls to `AC_INIT` and `AC_CONFIG_SRCDIR`,
    as shown in [Listing 6-1](ch06.xhtml#ch06ex1).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在构建系统中启用 Automake，我向 *configure.ac* 添加了一行代码：在 `AC_INIT` 和 `AC_CONFIG_SRCDIR`
    之间调用 `AM_INIT_AUTOMAKE`，如 [列表 6-1](ch06.xhtml#ch06ex1) 所示。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-1: Adding Automake functionality to* configure.ac'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：向 configure.ac 添加 Automake 功能*'
- en: 'If your project has already been configured with Autoconf, this is the *only*
    line that’s required to enable Automake in a working *configure.ac* file. The
    `AM_INIT_AUTOMAKE` macro accepts an optional argument: a whitespace-separated
    list of option tags, which can be passed into this macro to modify the general
    behavior of Automake. For a detailed description of each option, see [Chapter
    17](ch17.xhtml) of the *GNU Automake Manual*.^([5](footnote.xhtml#ch06fn5)) I
    will, however, point out a few of the most useful options here.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目已经使用Autoconf进行了配置，这将是启用Automake的*唯一*必要行，前提是配置文件`configure.ac`有效。`AM_INIT_AUTOMAKE`宏接受一个可选参数：一个由空格分隔的选项标签列表，可以将这些标签传递给此宏，以修改Automake的通用行为。有关每个选项的详细描述，请参阅*GNU
    Automake手册*的[第17章](ch17.xhtml)。^([5](footnote.xhtml#ch06fn5)) 但是，我将在这里指出一些最有用的选项。
- en: gnits, gnu, foreign
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: gnits, gnu, foreign
- en: These options set Automake’s strictness checks. The default is `gnu`. The `gnits`
    option makes Automake even more pedantic than it already is, and the `foreign`
    option loosens things up a bit—with `foreign`, you aren’t required to have the
    obligatory *INSTALL*, *README*, and *ChangeLog* files normally required for GNU
    projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项设置Automake的严格性检查。默认值为`gnu`。`gnits`选项使Automake变得比原来更加挑剔，而`foreign`选项则稍微放宽一些——使用`foreign`时，你不需要像GNU项目那样强制要求*INSTALL*、*README*和*ChangeLog*文件。
- en: check-news
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: check-news
- en: The `check-news` option causes `make dist` to fail if the project’s current
    version (from *configure.ac*) doesn’t show up in the first few lines of the *NEWS*
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-news`选项会导致如果项目的当前版本（来自*configure.ac*）没有出现在*NEWS*文件的前几行中，`make dist`命令失败。'
- en: dist-bzip2, dist-lzip, dist-xz, dist-shar, dist-zip, dist-tarZ
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: dist-bzip2, dist-lzip, dist-xz, dist-shar, dist-zip, dist-tarZ
- en: You can use the `dist-*` options to change the default distribution package
    type. By default, `make dist` builds a *.tar.gz* file, but developers often want
    to distribute, for example, *.tar.xz* packages instead. These options make the
    change quite easy. (Even without the `dist-xz` option, you can override the current
    default by using `make dist-xz`, but using the option is simpler if you always
    want to build *.xz* packages.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`dist-*`选项来更改默认的分发包类型。默认情况下，`make dist`会生成一个*.tar.gz*文件，但开发者常常希望分发例如*.tar.xz*格式的包。这些选项使得更改变得非常简单。（即使没有`dist-xz`选项，你也可以通过使用`make
    dist-xz`来覆盖当前的默认设置，但如果你总是希望构建*.xz*包，使用该选项会更简单。）
- en: readme-alpha
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: readme-alpha
- en: The `readme-alpha` option temporarily alters the behavior of the build and distribution
    processes during alpha releases of a project. Using this option causes a file
    named *README-alpha*, found in the project root directory, to be distributed automatically.
    The use of this option also alters the expected versioning scheme of the project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`readme-alpha`选项会在项目的Alpha版本发布期间临时更改构建和分发过程的行为。使用此选项会自动分发项目根目录中的名为*README-alpha*的文件。使用此选项还会更改项目的版本控制方案。'
- en: -W category, --warnings=category
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: -W category, --warnings=category
- en: The `-W` *`category`* and `--warnings=`*`category`* options indicate that the
    project would like to use Automake with various warning categories enabled. Multiple
    such options can be used with different category tags. Refer to the *GNU Automake
    Manual* to find a list of valid categories.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`-W` *`category`* 和 `--warnings=`*`category`* 选项表示项目希望使用Automake并启用各种警告类别。可以使用多个这样的选项，每个选项可以有不同的类别标签。请参考*GNU
    Automake手册*，查找有效类别的列表。'
- en: parallel-tests
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: parallel-tests
- en: The `parallel-tests` feature allows checks to be executed in parallel in order
    to take advantage of multiprocessor machines during execution of the `check` target.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel-tests`功能允许在执行`check`目标时并行执行检查，以便在多处理器机器上利用并行执行。'
- en: subdir-objects
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: subdir-objects
- en: The `subdir-objects` option is required when you intend to reference sources
    from directories other than the current directory. Using this option causes Automake
    to generate `make` commands that cause object and intermediate files to be generated
    into the same directory as the source file. For more information on this option,
    see “Nonrecursive Automake” on [page 175](ch06.xhtml#page_175).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`subdir-objects`选项在你打算引用当前目录以外的目录中的源代码时是必需的。使用此选项会导致Automake生成`make`命令，使得目标文件和中间文件与源文件生成在同一目录下。有关此选项的更多信息，请参阅“非递归Automake”部分，见[第175页](ch06.xhtml#page_175)。'
- en: version
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: version
- en: The *`version`* option is actually a placeholder for a version number that represents
    the lowest version of Automake that is acceptable for this project. For instance,
    if `1.11` is passed as an option tag, Automake will fail while processing *configure.ac*
    if its version is earlier than 1.11\. This can be useful if you’re trying to use
    features that only exist in later versions of Automake.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*`version`* 选项实际上是一个占位符，用于表示此项目接受的最低版本的 Automake 版本号。例如，如果传入 `1.11` 作为选项标记，如果
    Automake 的版本低于 1.11，则在处理 *configure.ac* 时会失败。如果你打算使用只有较新版本的 Automake 才支持的功能，这会非常有用。'
- en: 'With the new *Makefile.am* files in place and Automake enabled in *configure.ac*,
    let’s run `autoreconf` with the `-i` option in order to add any new utility files
    that Automake may require for our project:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经有了新的 *Makefile.am* 文件，并且在 *configure.ac* 中启用了 Automake，接下来我们可以运行 `autoreconf`
    并使用 `-i` 选项，以便为我们的项目添加 Automake 可能需要的任何新工具文件：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Adding the `AM_INIT_AUTOMAKE` macro to *configure.ac* causes `autoreconf -i`
    to now execute `automake -i`, which includes a few additional utility files: *aclocal.m4*,
    *install-sh*, *compile*, *missing*, and *depcomp*. Also, Automake now generates
    *Makefile.in* from *Makefile.am*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `AM_INIT_AUTOMAKE` 宏添加到 *configure.ac* 中，会导致 `autoreconf -i` 现在执行 `automake
    -i`，这将包括一些额外的工具文件：*aclocal.m4*、*install-sh*、*compile*、*missing* 和 *depcomp*。此外，Automake
    现在会从 *Makefile.am* 生成 *Makefile.in*。
- en: I mentioned *aclocal.m4* in [Chapter 2](ch02.xhtml) and `install-sh` in [Chapter
    4](ch04.xhtml). The `missing` script is a little utility helper script that prints
    a nicely formatted message when a tool specified on its command line is not available.
    More detail than this is not really required; if you’re curious, execute `./missing
    --help` in your project directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第 2 章](ch02.xhtml)中提到过 *aclocal.m4*，在[第 4 章](ch04.xhtml)中提到过 `install-sh`。`missing`
    脚本是一个小的辅助工具脚本，当命令行上指定的工具不可用时，它会打印一个格式化的错误信息。其实没有必要了解更多细节；如果你感兴趣，可以在项目目录中执行 `./missing
    --help`。
- en: We’ll talk about the `depcomp` script shortly, but I’d like to mention the purpose
    of the `compile` script here. This script is a wrapper around some older compilers
    that do not understand the concurrent use of the `-c` and `-o` command line options.
    When you use product-specific flags, which we’ll discuss shortly, Automake has
    to generate code that may compile source files multiple times with different flags
    for each file. Thus, it has to name the object files differently for each set
    of flags it uses. The `compile` script facilitates this process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会谈到 `depcomp` 脚本，但在此我想提一下 `compile` 脚本的目的。这个脚本是一些旧编译器的包装器，它们不理解同时使用 `-c`
    和 `-o` 命令行选项。当你使用特定产品的标志（我们稍后会讨论）时，Automake 必须生成代码，这些代码可能会多次编译源文件，每次编译使用不同的标志。因此，它必须为每组标志命名不同的目标文件。`compile`
    脚本简化了这个过程。
- en: Automake also adds default *INSTALL* and *COPYING* text files containing boilerplate
    text that pertains specifically to the GNU project. You can modify these files
    for your projects as you see fit. I find the default *INSTALL* file text to be
    useful for general-purpose instructions related to Autotools-built projects, but
    I like to prepend some project-specific information to the top of this file before
    committing it to my repository. Automake’s `-i` option won’t overwrite these text
    files in a project that already contains them, so feel free to modify the default
    files as you see fit, once they’ve been added by `autoreconf -i`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 还会添加默认的 *INSTALL* 和 *COPYING* 文本文件，这些文件包含与 GNU 项目相关的模板文本。你可以根据需要修改这些文件以适应你的项目。我发现默认的
    *INSTALL* 文件内容对于与 Autotools 构建项目相关的通用指令非常有用，但在将其提交到我的代码库之前，我喜欢在文件顶部添加一些项目特定的信息。Automake
    的 `-i` 选项在项目中已经包含这些文本文件时不会覆盖它们，因此，一旦通过 `autoreconf -i` 添加了这些文件，你可以根据需要修改这些默认文件。
- en: The *COPYING* file contains the text of the GPL, which may or may not apply
    to your project. If your project is released under GPL, just leave the text as
    is. If you’re releasing under another license, such as the BSD, MIT, or Apache
    Commons licenses, replace the default text with text appropriate for that license.^([6](footnote.xhtml#ch06fn6))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*COPYING* 文件包含 GPL 许可证的文本，可能适用于或不适用于你的项目。如果你的项目是根据 GPL 许可发布的，只需保留该文本不变。如果你是根据其他许可证（如
    BSD、MIT 或 Apache Commons 许可证）发布的，请将默认文本替换为适合该许可证的文本。^([6](footnote.xhtml#ch06fn6))'
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You only need to use the *`-i`* option once in a newly checked-out work area
    or a newly created project. Once the missing utility files have been added, you
    can drop the *`-i`* option in future calls to *`autoreconf`* unless you add certain
    macros to* configure.ac, *which may then cause the use of the *`-i`* option to
    add more missing files. We’ll see some of this sort of thing in later chapters.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*你只需要在新检出的工作区或新创建的项目中使用一次*`-i`*选项。添加缺失的工具文件后，除非你向*configure.ac*中添加某些宏，否则你可以在以后调用*`autoreconf`*时省略*`-i`*选项，添加的宏可能会导致使用*`-i`*选项以添加更多缺失的文件。我们将在后面的章节中看到这类情况。*'
- en: The preceding commands create an Automake-based build system that contains everything
    (with the minor exception of `check` functionality, which we’ll get to shortly)
    that we wrote into our original *Makefile.in* templates, except that this system
    is more correct and functionally complete according to the *GCS*. A glance at
    the resulting generated *Makefile.in* template shows that Automake has done a
    significant amount of work for us. The resulting top-level *Makefile.in* template
    is nearly 24KB, while the original, hand-coded makefiles were only a few hundred
    bytes long.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一个基于Automake的构建系统，包含了我们在原始*Makefile.in*模板中编写的所有内容（除了稍后会提到的`check`功能之外），但是这个系统在功能上更加完整，且符合*GCS*的规范。查看生成的*Makefile.in*模板，我们可以看到Automake为我们做了大量工作。生成的顶层*Makefile.in*模板几乎有24KB，而原来的手工编写的makefile只有几百字节。
- en: 'An Automake build system supports the following important `make` targets (derived
    from an Automake-generated *Makefile*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Automake构建系统支持以下重要的`make`目标（从Automake生成的*Makefile*派生）：
- en: '| `all` | `check` | `clean` | `ctags` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `all` | `check` | `clean` | `ctags` |'
- en: '| `dist` | `dist-bzip2` | `dist-gzip` | `dist-lzip` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `dist` | `dist-bzip2` | `dist-gzip` | `dist-lzip` |'
- en: '| `dist-shar` | `dist-tarZ` | `dist-xz` | `dist-zip` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `dist-shar` | `dist-tarZ` | `dist-xz` | `dist-zip` |'
- en: '| `distcheck` | `distclean` | `distdir` | `dvi` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `distcheck` | `distclean` | `distdir` | `dvi` |'
- en: '| `html` | `info` | `install` | `install-data` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `html` | `info` | `install` | `install-data` |'
- en: '| `install-dvi` | `install-exec` | `install-html` | `install-info` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `install-dvi` | `install-exec` | `install-html` | `install-info` |'
- en: '| `install-pdf` | `install-ps` | `install-strip` | `installcheck` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `install-pdf` | `install-ps` | `install-strip` | `installcheck` |'
- en: '| `installdirs` | `maintainer-clean` | `mostlyclean` | `pdf` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `installdirs` | `maintainer-clean` | `mostlyclean` | `pdf` |'
- en: '| `ps` | `tags` | `ininstall` |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | `tags` | `ininstall` |  |'
- en: As you can see, this goes far beyond what we could provide in our hand-coded
    *Makefile.in* templates. Automake writes this base functionality into every project
    that uses it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这远远超出了我们在手动编写的*Makefile.in*模板中能提供的功能。Automake将这些基础功能写入每个使用它的项目中。
- en: '*A Hidden Benefit: Automatic Dependency Tracking*'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一个隐藏的好处：自动依赖关系跟踪*'
- en: In “Dependency Rules” on [page 46](ch03.xhtml#page_46), we discussed `make`
    dependency rules. These are rules we define in makefiles so that `make` is aware
    of the hidden relationships between C-language source files and included header
    files. Automake goes to a lot of trouble to ensure that you don’t have to write
    such dependency rules for languages it understands, like C, C++, and Fortran.
    This is an important feature for projects containing more than a few source files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在《依赖规则》一节中（见[第46页](ch03.xhtml#page_46)），我们讨论了`make`依赖规则。这些规则是我们在makefile中定义的，以便`make`能够意识到C语言源文件与包含的头文件之间的隐含关系。Automake花费了大量精力来确保你不需要为它能够理解的语言（如C、C++和Fortran）编写这些依赖规则。这是对于包含多个源文件的项目来说非常重要的一个特性。
- en: Writing dependency rules by hand for dozens or hundreds of source files is both
    tedious and error prone. In fact, it’s such a problem that compiler writers often
    provide a mechanism that enables the compiler to write these rules automatically
    based on its internal knowledge of the source files and the language. The GNU
    compilers, among others, support a family of `-M` options (`-M`, `-MM`, `-MF`,
    `-MG`, and so on) on the command line. These options tell the compiler to generate
    a `make` dependency rule for the specified source file. (Some of these options
    can be used on the normal compiler command line, so the dependency rule can be
    generated when the source file is being compiled.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 手动为数十或数百个源文件编写依赖规则既繁琐又容易出错。事实上，这已经成为一个问题，以至于编译器作者经常提供一种机制，使编译器能够根据其对源文件和语言的内部知识自动编写这些规则。GNU编译器等支持一系列`-M`选项（`-M`、`-MM`、`-MF`、`-MG`等）。这些选项告诉编译器为指定的源文件生成一个`make`依赖规则。（其中一些选项可以在正常的编译命令行中使用，因此可以在源文件被编译时生成依赖规则。）
- en: The simplest of these options is the basic `-M` option, which causes the compiler
    to generate a dependency rule for the specified source file on `stdout` and then
    terminate. This rule can be captured in a file, which is then included by the
    makefile so that the dependency information within this rule is incorporated into
    the directed graph that `make` builds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中最简单的是基本的 `-M` 选项，它使编译器为指定的源文件在 `stdout` 上生成一个依赖关系规则，然后终止。这个规则可以被捕获到一个文件中，随后由
    makefile 包含，从而将该规则中的依赖关系信息纳入到 `make` 构建的有向图中。
- en: 'But what happens on systems where the native compilers don’t provide dependency
    generation options, or where they don’t work together with the compilation process?
    In such cases, Automake provides a wrapper script called *depcomp* that executes
    the compiler twice: once for dependency information and again to compile the source
    file. When the compiler lacks the options to generate *any* dependency information,
    another tool may be used to recursively determine which header files affect a
    given source file. On systems where none of these options is available, automatic
    dependency generation fails.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当系统中的本地编译器不提供依赖关系生成选项，或者它们与编译过程无法配合工作时，会发生什么情况呢？在这种情况下，Automake 提供了一个名为*depcomp*的包装脚本，该脚本会执行两次编译：第一次生成依赖关系信息，第二次编译源文件。当编译器缺少生成*任何*依赖关系信息的选项时，可以使用另一个工具递归地确定哪些头文件会影响给定的源文件。在没有这些选项可用的系统上，自动依赖关系生成将失败。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For a more detailed description of the dependency-generating compiler options,
    see “Item 10: Using Generated Source Code” on [page 529](ch18.xhtml#page_529).
    For more on Automake dependency management, see the relevant sections of the*
    GNU Automake Manual.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于依赖关系生成编译器选项的更详细描述，请参阅[第529页](ch18.xhtml#page_529)的“项目 10：使用生成的源代码”。关于 Automake
    依赖关系管理的更多内容，请参阅* GNU Automake 手册的相关章节。'
- en: It’s time now to bite the bullet and give it a try. As with our build system
    from the previous chapter, run `autoreconf` (optional since we ran `autoreconf
    -i` earlier, but harmless), followed by `./configure` and `make`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候咬紧牙关，尝试一下了。和上一章的构建系统一样，运行 `autoreconf`（由于我们之前运行过 `autoreconf -i`，所以这是可选的，但没有害处），接着运行
    `./configure` 和 `make`。
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can’t truly appreciate what Automake has done here without trying a few
    of the other `make` targets we’ve become familiar with. Try out the `install`,
    `dist`, and `distcheck` targets on your own to assure yourself that you still
    have all the functionality you had before you deleted your handwritten *Makefile.in*
    templates.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不尝试我们已经熟悉的其他 `make` 目标，你是无法真正体会到 Automake 所做的工作。自己尝试 `install`、`dist` 和 `distcheck`
    目标，以确认你在删除手写的 *Makefile.in* 模板之后，仍然拥有之前的所有功能。
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The *`check`* target exists as a do-nothing target at this point, but we need
    to dive into Automake constructs in a bit more detail before we can add our test
    back in. When we get to it, you’ll see that it’s even simpler than the code we
    originally wrote*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*`check`* 目标目前作为一个无操作的目标存在，但在我们能将测试加回来之前，我们需要更详细地研究 Automake 构造。当我们深入到这一部分时，你会发现它甚至比我们最初编写的代码更简单。'
- en: What’s Actually in a Makefile.am File?
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Makefile.am 文件实际上包含了什么？
- en: In [Chapter 4](ch04.xhtml), we discussed how Autoconf accepts as input a shell
    script sprinkled with M4 macros and then generates the same shell script with
    those macros fully expanded. Likewise, Automake accepts as input a makefile sprinkled
    with Automake commands. Just as Autoconf’s input files are simply enhanced shell
    scripts, Automake *Makefile.am* files are nothing more than standard makefiles
    with additional Automake-specific syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)中，我们讨论了 Autoconf 如何将一个包含 M4 宏的 shell 脚本作为输入，并生成同样的 shell 脚本，其中这些宏得到了完全展开。同样，Automake
    将一个包含 Automake 命令的 makefile 作为输入。正如 Autoconf 的输入文件仅仅是增强版的 shell 脚本一样，Automake
    的*Makefile.am* 文件也不过是标准的 makefile，只是额外包含了 Automake 特有的语法。
- en: One significant difference between Autoconf and Automake is that the only text
    Autoconf outputs is the existing shell script in the input file and any additional
    shell script resulting from the expansion of embedded M4 macros. Automake, on
    the other hand, assumes that all makefiles should contain a minimal infrastructure
    designed to support the *GCS*, in addition to any targets and variables that you
    specify.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 和 Automake 之间的一个显著区别是，Autoconf 输出的唯一文本是输入文件中现有的 shell 脚本，以及嵌入的 M4 宏展开后产生的任何附加
    shell 脚本。另一方面，Automake 假设所有的 makefile 都应该包含一个最小的基础设施，用于支持*GCS*，除了你指定的任何目标和变量之外。
- en: 'To illustrate this point, create a *temp* directory in the root of the Jupiter
    project and add an empty *Makefile.am* file to it. Next, add this new *Makefile.am*
    to the project’s *configure.ac* file with a text editor and reference it from
    the top-level *Makefile.am* file, like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，在 Jupiter 项目的根目录中创建一个 *temp* 目录，并向其中添加一个空的 *Makefile.am* 文件。接下来，用文本编辑器将这个新的
    *Makefile.am* 添加到项目的 *configure.ac* 文件中，并从顶层的 *Makefile.am* 文件中引用它，如下所示：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I used an `echo` statement at ➊ to rewrite a new top-level *Makefile.am* file
    that has `SUBDIRS` reference both *src* and *temp*. I used a text editor to add
    *temp/Makefile* to the list of makefiles Autoconf will generate from templates
    (➋). As you can see, there is a certain amount of support code generated into
    every makefile that Automake considers indispensable. Even an empty *Makefile.am*
    file generates a 12KB *Makefile.in* template (➍), from which `configure` generates
    a similarly sized *Makefile* (➌).^([7](footnote.xhtml#ch06fn7))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➊ 处使用了一个 `echo` 语句，重写了一个新的顶层 *Makefile.am* 文件，其中 `SUBDIRS` 同时引用 *src* 和 *temp*。我用文本编辑器将
    *temp/Makefile* 添加到 Autoconf 将从模板生成的 makefile 列表中（➋）。如您所见，每个 makefile 中生成了一些 Automake
    认为不可或缺的支持代码。即使是一个空的 *Makefile.am* 文件，也会生成一个 12KB 的 *Makefile.in* 模板（➍），然后 `configure`
    从中生成一个类似大小的 *Makefile*（➌）。^([7](footnote.xhtml#ch06fn7))
- en: 'Since the `make` utility uses a fairly rigid set of rules for processing makefiles,
    Automake takes some license with your additional `make` code. Here are some specifics:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `make` 工具使用一套相当严格的规则来处理 makefile，Automake 对你额外的 `make` 代码有一些灵活的处理。以下是一些具体内容：
- en: The `make` variables defined in *Makefile.am* files are placed at the top of
    the resulting *Makefile.in* template, immediately following any Automake-generated
    variable definitions.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Makefile.am* 文件中定义的 `make` 变量被放置在生成的 *Makefile.in* 模板的顶部，紧跟在任何 Automake 生成的变量定义之后。
- en: The `make` rules specified in *Makefile.am* files are placed at the end of the
    resulting *Makefile.in* template, immediately after any Automake-generated rules.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Makefile.am* 文件中指定的 `make` 规则被放置在生成的 *Makefile.in* 模板的末尾，紧跟在任何 Automake 生成的规则之后。
- en: Most Autoconf variables substituted by `config.status` are converted to `make`
    variables and initialized to those substitution variables.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数由 `config.status` 替换的 Autoconf 变量被转换为 `make` 变量，并初始化为那些替换变量。
- en: The `make` utility doesn’t care where rules are in relation to each other, because
    it reads every rule into an internal database before processing any of them. Variables
    are treated similarly, as long as they are defined before the rules that use them.
    In order to avoid any variable-binding issues, Automake places all variables at
    the top of the output file in the order in which they’re defined in the input
    file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 工具不关心规则之间的位置关系，因为它会在处理任何规则之前，将每条规则读取到一个内部数据库中。变量也类似，只要它们在使用之前被定义。为了避免任何变量绑定问题，Automake
    会将所有变量按定义顺序放在输出文件的顶部。'
- en: Analyzing Our New Build System
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析我们的新构建系统
- en: Now let’s look at what we put into those two simple *Makefile.am* files, beginning
    with the top-level *Makefile.am* file (shown in [Listing 6-2](ch06.xhtml#ch06ex2)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下我们在这两个简单的 *Makefile.am* 文件中放了什么，从顶层的 *Makefile.am* 文件开始（如[列表 6-2](ch06.xhtml#ch06ex2)所示）。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-2:* Makefile.am: *The top-level* Makefile.am *file contains only
    a subdirectory reference.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2:* Makefile.am: *顶层* Makefile.am *文件仅包含一个子目录引用。*'
- en: 'This single line of text tells Automake several things about our project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行文本告诉 Automake 我们项目的几个信息：
- en: One or more subdirectories contain makefiles to be processed in addition to
    this file.^([8](footnote.xhtml#ch06fn8))
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个子目录包含要处理的 makefile，除了这个文件之外。^([8](footnote.xhtml#ch06fn8))
- en: Directories in this space-delimited list should be processed in the order specified.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此空格分隔的目录列表应按指定的顺序处理。
- en: Directories in this list should be recursively processed for all primary targets.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此列表中的目录应为所有主要目标递归处理。
- en: Directories in this list should be treated as part of the project distribution,
    unless otherwise specified.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非另有说明，否则此列表中的目录应视为项目分发的一部分。
- en: As with most Automake constructs, `SUBDIRS` is simply a `make` variable that
    has special meaning for Automake. The `SUBDIRS` variable may be used to process
    *Makefile.am* files within arbitrarily complex directory structures, and the directory
    list may contain any relative directory references (not just immediate subdirectories).
    You might say that `SUBDIRS` is kind of like the glue that holds makefiles together
    in a project’s directory hierarchy, when using a recursive build system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数Automake构造一样，`SUBDIRS`只是一个`make`变量，对于Automake有特殊的含义。`SUBDIRS`变量可用于处理具有任意复杂目录结构的*Makefile.am*文件，目录列表可以包含任何相对目录引用（不仅仅是直接的子目录）。可以说，`SUBDIRS`就像是在使用递归构建系统时，将makefile连接在项目目录层次结构中的“粘合剂”。
- en: 'Automake generates recursive `make` rules that implicitly process the current
    directory after those specified in the `SUBDIRS` list, but it’s often necessary
    to build the current directory before some or all of the other directories in
    the list. You may change the default ordering by referencing the current directory
    with a dot anywhere in the `SUBDIRS` list. For example, to build the top-level
    directory before the *src* directory, you could change the `SUBDIRS` variable
    in [Listing 6-2](ch06.xhtml#ch06ex2) as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Automake生成递归的`make`规则，这些规则在处理`SUBDIRS`列表中指定的目录后，隐式地处理当前目录，但有时需要在其他某些或所有目录之前构建当前目录。可以通过在`SUBDIRS`列表中的任何位置引用当前目录（使用点符号）来更改默认的构建顺序。例如，要在*src*目录之前构建顶层目录，可以按如下方式修改[列表
    6-2](ch06.xhtml#ch06ex2)中的`SUBDIRS`变量：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let’s turn to the *Makefile.am* file in the *src* directory, shown in [Listing
    6-3](ch06.xhtml#ch06ex3).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到*src*目录中的*Makefile.am*文件，如[列表 6-3](ch06.xhtml#ch06ex3)所示。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-3:* src/Makefile.am: *The initial version of this* Makefile.am *file
    contains only two lines*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：* src/Makefile.am：*这个* Makefile.am *文件的初始版本只包含两行*'
- en: The first line is a *product list variable* specification, and the second line
    is a *product source variable* specification.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是*产品列表变量*的规范，第二行是*产品源变量*的规范。
- en: '*Product List Variables*'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*产品列表变量*'
- en: 'Products are specified in a *Makefile.am* file using a *product list variable
    (PLV)*, which (like `SUBDIRS`) is a class of `make` variables that have special
    meaning to Automake. The following template shows the general format of a PLV:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 产品在*Makefile.am*文件中通过*产品列表变量（PLV）*进行指定，像`SUBDIRS`一样，PLV是`make`变量的一类，对Automake具有特殊意义。以下模板显示了PLV的常见格式：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The PLV name in the first line of [Listing 6-3](ch06.xhtml#ch06ex3) consists
    of two components: the *prefix* (*bin*) and the *primary* (`PROGRAMS`), separated
    by an underscore (`_`). The value of the variable is a whitespace-separated list
    of products generated by this *Makefile.am* file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](ch06.xhtml#ch06ex3)中第一行的PLV名称由两部分组成：*前缀*（*bin*）和*主元素*（`PROGRAMS`），由下划线（`_`）分隔。该变量的值是由此*Makefile.am*文件生成的产品的一个以空格分隔的列表。'
- en: Installation Location Prefixes
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装位置前缀
- en: The *bin* portion of the product list variable shown in [Listing 6-3](ch06.xhtml#ch06ex3)
    is an example of an *installation location prefix*. The *GCS* defines many common
    installation locations, and most are listed in [Table 3-1](ch03.xhtml#ch03tab1)
    on [page 65](ch03.xhtml#page_65). However, any `make` variable ending in `dir`,
    whose value is a filesystem location, is a viable installation location variable
    and may be used as a prefix in an Automake PLV.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](ch06.xhtml#ch06ex3)中显示的产品列表变量的*bin*部分是一个*安装位置前缀*的示例。*GCS*定义了许多常见的安装位置，大多数在[表
    3-1](ch03.xhtml#ch03tab1)中列出，位于[第65页](ch03.xhtml#page_65)。然而，任何以`dir`结尾且值为文件系统位置的`make`变量，都是有效的安装位置变量，并且可以作为Automake
    PLV中的前缀使用。'
- en: You reference an installation location variable in a PLV prefix by omitting
    the `dir` portion of the variable name. For example, in [Listing 6-3](ch06.xhtml#ch06ex3),
    the `$(bindir)` `make` variable is referred to only as `bin` when it is used as
    an installation location prefix.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在PLV前缀中引用安装位置变量时，应省略变量名称中的`dir`部分。例如，在[列表 6-3](ch06.xhtml#ch06ex3)中，当`$(bindir)`
    `make`变量用作安装位置前缀时，只需称其为`bin`。
- en: 'Automake also recognizes four installation location variables starting with
    the special `pkg` prefix: `pkglibdir`, `pkgincludedir`, `pkgdatadir`, and `pkglibexecdir`.
    These `pkg` versions of the standard `libdir`, `includedir`, `datadir`, and `libexecdir`
    variables indicate that the listed products should be installed in a subdirectory
    of these locations named after the package. For example, in the Jupiter project,
    products listed in a PLV prefixed with `lib` would be installed into `$(libdir)`,
    while those listed in a PLV prefixed with `pkglib` would be installed into `$(libdir)`*/jupiter*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Since Automake derives the list of valid installation locations and prefixes
    from all `make` variables ending in `dir`, you may provide your own PLV prefixes
    that refer to custom installation locations. To install a set of XML files into
    an *xml* directory within the system data directory, you could use the code in
    [Listing 6-4](ch06.xhtml#ch06ex4) in your *Makefile.am* file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-4: Specifying a custom installation directory*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Installation location variables will contain default values defined either by
    Automake-generated makefiles or by you in your *Makefile.am* files, but your users
    can always override these default values on their `configure` or `make` command
    lines. If you don’t want certain products to be installed during a particular
    build, specify an empty value in an installation location variable on the command
    line; the Automake-generated rules will ensure that products intended for those
    directories aren’t installed. For example, to install only documentation and shared
    data files for a package, you could enter `make bindir='' libdir='' install`.^([9](footnote.xhtml#ch06fn9))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Prefixes Not Associated with Installation
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Certain prefixes are not related to installation locations. For example, `noinst`,
    `check`, and `EXTRA` are used (respectively) to indicate products that are not
    installed, are used only for testing, or are optionally built. Here’s a little
    more information about these three prefixes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: noinst
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Indicates that the listed products should be built but not installed. For example,
    a static so-called *convenience library* might be built as an intermediate product
    and then used in other stages of the build process to build final products. The
    `noinst` prefix tells Automake that the product should not be installed and that
    only a static library should be built. (After all, it makes no sense to build
    a shared library that won’t be installed.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: check
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Indicates products that are to be built only for testing purposes and will thus
    not need to be installed. Products listed in PLVs prefixed with `check` are built
    only if the user enters `make check`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: EXTRA
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Used to list programs that are conditionally built. Automake requires that all
    source files be specified statically within a *Makefile.am* file, as opposed to
    being calculated or derived during the build process, so that it can generate
    a *Makefile.in* template that will work for any possible command line. However,
    a project maintainer may elect to allow some products to be built conditionally
    based on configuration options given to the `configure` script. If products are
    listed in variables generated by the `configure` script, they should also be listed
    in a PLV, prefixed with `EXTRA`, within a *Makefile.am* file. This concept is
    illustrated in [Listings 6-5](ch06.xhtml#ch06ex5) and [6-6](ch06.xhtml#ch06ex6).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-5: A conditionally built program defined in a shell variable in*
    configure.ac'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-6: Using the `EXTRA` prefix to conditionally define products in*
    Makefile.am'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ in [Listing 6-5](ch06.xhtml#ch06ex5), `optprog` is appended to an Autoconf
    substitution variable called `optional_programs`. The `EXTRA_PROGRAMS` variable
    at ➋ in [Listing 6-6](ch06.xhtml#ch06ex6) lists `optprog` as a product that may
    or may not be built, based on end-user configuration choices that determine whether
    `$(optional_programs)` at ➌ is empty or contains `optprog`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: While it may appear redundant to specify `optprog` in both *configure.ac* and
    *Makefile.am*, Automake needs the information in `EXTRA_PROGRAMS` because it cannot
    attempt to interpret the possible values of `$(optional_programs)`, as defined
    in *configure.ac*. Hence, adding `optprog` to `EXTRA_PROGRAMS` in this example
    tells Automake to generate rules to build it, even if `$(optional_programs)` doesn’t
    contain `optprog` during a particular build.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Primaries
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Primaries* are like product classes, and they represent types of products
    that might be generated by a build system. A primary defines the set of steps
    required to build, test, install, and execute a particular class of products.
    For example, programs and libraries are built using different compiler and linker
    commands, Java classes require a virtual machine to execute them, and Python programs
    require an interpreter. Some product classes, such as scripts, data, and headers,
    have no build, test, or execution semantics—only installation semantics.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The list of supported primaries defines the set of product classes that can
    be built automatically by an Automake build system. Automake build systems can
    still build other product classes, but the maintainer must define the `make` rules
    explicitly within the project’s *Makefile.am* files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: A thorough understanding the Automake primaries is the key to properly using
    Automake. The current complete list of supported primaries is as follows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: PROGRAMS
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: When the `PROGRAMS` primary is used in a PLV, Automake generates `make` rules
    that use compilers and linkers to build binary executable programs for the listed
    products.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: LIBRARIES/LTLIBRARIES
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `LIBRARIES` primary causes Automake to generate rules that build
    static archives (libraries) using the system compiler and librarian. The `LTLIBRARIES`
    primary does the same thing, but the generated rules also build Libtool shared
    libraries and execute these tools (as well as the linker) through the `libtool`
    script. (I’ll discuss the Libtool package in detail in [Chapters 7](ch07.xhtml)
    and [8](ch08.xhtml).) Automake restricts the installation locations for the `LIBRARIES`
    and `LTLIBRARIES` primaries: they can only be installed in `$(libdir)` and `$(pkglibdir)`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: LISP
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The `LISP` primary was designed mainly to manage the build for Emacs Lisp programs.
    Hence, it expects to refer to a list of *.el* files. You can find details on the
    use of this primary in Section 10.1 of the Automake manual.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: PYTHON
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Python is an interpreted language; the `python` interpreter converts a Python
    script, line by line, into Python byte code, executing it as it’s converted, so
    (like shell scripts) Python source files are executable as written. The use of
    the `PYTHON` primary tells Automake to generate rules that precompile Python source
    files (*.py*) into standard (*.pyc*) and optimized (*.pyo*) byte-compiled versions
    using the `py-compile` utility. Because of the normally interpreted nature of
    Python sources, this compilation occurs at install time rather than at build time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: JAVA
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Java is a virtual machine platform; the use of the `JAVA` primary tells Automake
    to generate rules that convert Java source files (*.java*) into Java class files
    (*.class*) using the `javac` compiler. While this process is correct, it’s not
    complete. Java programs (of any consequence) generally contain more than one class
    file and are usually packaged as *.jar* or *.war* files, both of which may also
    contain several ancillary text files. The `JAVA` primary is useful, but only just.
    (I’ll discuss using—and extending—the `JAVA` primary in “Building Java Sources
    Using the Autotools” on [page 408](ch15.xhtml#page_408).)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: SCRIPTS
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '*Script*, in this context, refers to any interpreted text file—whether it’s
    shell, Perl, Python, Tcl/Tk, JavaScript, Ruby, PHP, Icon, Rexx, or some other.
    Automake allows a restricted set of installation locations for the `SCRIPTS` primary,
    including `$(bindir)`, `$(sbindir)`, `$(libexecdir)`, and `$(pkgdatadir)`. While
    Automake doesn’t generate rules to build scripts, it also doesn’t assume that
    a script is a static file in the project. Scripts are often generated by handwritten
    rules in *Makefile.am* files, sometimes by processing an input file with the `sed`
    or `awk` utility. For this reason, scripts are not distributed automatically.
    If you have a static script in your project that you’d like Automake to add to
    your distribution archive, you should prefix the `SCRIPTS` primary with the `dist`
    modifier as discussed in “PLV and PSV Modifiers” on [page 161](ch06.xhtml#page_161).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: DATA
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary data files can be installed using the `DATA` primary in a PLV. Automake
    allows a restricted set of installation locations for the `DATA` primary, including
    `$(datadir)`, `$(sysconfdir)`, `$(sharedstatedir)`, `$(localstatedir``)`, and
    `$(pkgdatadir)`. Data files are not automatically distributed, so if your project
    contains static data files, use the `dist` modifier on the `DATA` primary as discussed
    in “PLV and PSV Modifiers” on [page 161](ch06.xhtml#page_161).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: HEADERS
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Header files are a form of source file. Were it not for the fact that some header
    files are installed, they could simply be listed with the product sources. Header
    files containing the public interface for installed library products are installed
    into either the `$(includedir)` or a package-specific subdirectory defined by
    `$(pkgincludedir)`, so the most common PLVs for such installed headers are the
    `include_HEADERS` and `pkginclude_HEADERS` variables. Like other source files,
    header files are distributed automatically. If you have a generated header file,
    use the `nodist` modifier with the `HEADERS` primary as discussed in “PLV and
    PSV Modifiers” on [page 161](ch06.xhtml#page_161).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: MANS
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*Man pages* are UTF-8 text files containing `troff` markup, which is rendered
    by `man` when viewed by a user. Man pages can be installed using the `man_MANS`
    or `man`*`N`*`_MANS` product list variables, where *`N`* represents a single-digit
    section number between 0 and 9 or the letters *l* (for math library topics) or
    *n* (for Tcl/Tk topics). Files in the `man_MANS` PLV should have a numeric extension
    indicating the man section to which they belong and, therefore, their target directory.
    Files in the `man`*`N`*`_MANS` PLV may be named with either numeric extensions
    or a *.man* extension and will be renamed to the associated numeric extensions
    when they’re installed by `make install`. Project man pages are not distributed
    by default because man pages are often generated, so you should use the `dist`
    modifier as discussed in “PLV and PSV Modifiers” on [page 161](ch06.xhtml#page_161).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: TEXINFOS
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Linux or Unix documentation, Texinfo^([10](footnote.xhtml#ch06fn10))
    is the GNU project format of choice. The `makeinfo` utility accepts Texinfo source
    files (*.texinfo*, *.txi*, or *.texi*) and renders info files (*.info*) containing
    UTF-8 text annotated with Texinfo markup, which the `info` utility renders into
    formatted text for the user. The most common product list variable for use with
    Texinfo sources is `info_TEXINFOS`. The use of this PLV causes Automake to generate
    rules to build *.info*, *.dvi*, *.ps*, and *.html* documentation files. However,
    only the *.info* files are built with `make all` and installed with `make install`.
    In order to build and install the other types of files, you must specify the `dvi`,
    `ps`, `pdf`, `html`, `install-dvi`, `install-ps`, `install-pdf`, and `install-html`
    targets explicitly on the `make` command line. Since the `makeinfo` utility is
    not installed by default in many Linux distributions, the generated *.info* files
    are automatically added to distribution archives so your end users won’t have
    to go looking for `makeinfo`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '*Product Source Variables*'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The second line in [Listing 6-3](ch06.xhtml#ch06ex3) is an example of an Automake
    *product source variable* (*PSV*). PSVs conform to the following template:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Like PLVs, PSVs are composed of multiple parts: the product name (`jupiter`
    in this case) and the `SOURCES` tag. The value of a PSV is a whitespace-separated
    list of source files from which *`product`* is built. The value of the PSV in
    the second line of [Listing 6-3](ch06.xhtml#ch06ex3) is the list of source files
    used to build the `jupiter` program. Ultimately, Automake adds these files to
    various `make` rule dependency lists and commands in the generated *Makefile.in*
    templates.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Only characters that are allowed in `make` variables (letters, numbers, the
    at sign, and underscore) are allowed in the `product` tag of a PSV. As a result,
    Automake performs a transformation on product names listed in PLVs to render the
    *`product`* tags used in the associated PSVs. Automake converts illegal characters
    into underscores, as shown in [Listing 6-7](ch06.xhtml#ch06ex7).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-7: Illegal `make` variable characters are converted to underscores
    in `product` tags.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Here, Automake converts *libc++.a* in the PLV at ➊ into the PSV `product` tag
    `libc___a` (that’s three underscores) to find the associated PSV at ➋ in the *Makefile.am*
    file. You must know the transformation rules so you can write PSVs that match
    your products.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '*PLV and PSV Modifiers*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `modifier-list` portions of the PLV and PSV templates defined previously
    contain a set of optional modifiers. The following BNF-like rule defines the format
    of the `modifier-list` element of these templates:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Modifiers change the normal behavior of the variable to which they are prepended.
    The currently defined set of prefix modifiers includes `dist`, `nodist`, `nobase`,
    and `notrans`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The `dist` modifier indicates a set of files that should be distributed (that
    is, that should be included in the distribution package that’s built when `make
    dist` is executed). For example, assuming that some source files for a product
    should be distributed and some should not, the variables shown in [Listing 6-8](ch06.xhtml#ch06ex8)
    might be defined in the product’s *Makefile.am* file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-8: Using the `dist` and `nodist` modifiers in a* Makefile.am *file*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Automake normally strips relative path information from the list of header files
    in a `HEADERS` PLV. The `nobase` modifier is used to suppress the removal of path
    information from installed header files that are obtained from subdirectories
    by a *Makefile.am* file. For example, take a look at the PLV definition in [Listing
    6-9](ch06.xhtml#ch06ex9).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-9: Using the `nobase` PLV modifier in a* Makefile.am *file*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In this line we can see that *mylib.h* is in the same directory as *Makefile.am*,
    but *constants.h* is located in a subdirectory called *sys*. Normally, both files
    would be installed into `$(pkgincludedir)` by virtue of the `pkginclude` installation
    location prefix. However, since we’re using the `nobase` modifier, Automake will
    retain the *sys/* portion of the second file’s path for installation, and *constants.h*
    will be installed into `$(pkgincludedir)`*/sys*. This is useful when you want
    the installation (destination) directory structure to be the same as the project
    (source) directory structure as files are copied during installation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The `notrans` modifier may be used on man page PLVs for man pages whose names
    should not be transformed during installation. (Normally, Automake will generate
    rules to rename the extension on man pages from *.man* to *.N*—where *N* is *0*,
    *1*, . . . , *9*, *l*, *n*—as they’re installed.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `EXTRA` prefix as a modifier. When used with a product
    source variable (such as `jupiter_SOURCES`), `EXTRA` specifies extra source files
    that are directly associated with the `jupiter` product, as shown in [Listing
    6-10](ch06.xhtml#ch06ex10).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-10: Using the `EXTRA` prefix with a product `SOURCES` variable*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Here, *possibly.c* may or may not be compiled, based on some condition defined
    in *configure.ac*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit Tests: Supporting make check'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml), we added code to *src/Makefile* that executes the
    `jupiter` program and checks for the proper output string when the user makes
    the `check` target. We now have enough information to add our `check` target test
    back into our new Automake build system. I’ve duplicated the `check` target code
    in [Listing 6-11](ch06.xhtml#ch06ex11) for reference in the following discussion.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-11: The `check` target from [Chapter 3](ch03.xhtml)*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Automake has solid support for unit tests. To add our simple `grep`
    test back into the new Automake-generated build system, we can add a few lines
    to the bottom of *src/Makefile.am*, as shown in [Listing 6-12](ch06.xhtml#ch06ex12).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 6.1
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-12:* src/Makefile.am: *Additional code required to support the `check`
    target*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The `check_SCRIPTS` line at ➊ is a PLV that refers to a script generated at
    build time. Since the prefix is `check`, we know that scripts listed in this line
    will only be built when the user enters `make check`. However, we must supply
    a `make` rule for building the script as well as a rule for removing the file
    later, during execution of the `clean` target. We use the `CLEANFILES` variable
    at ➌ to extend the list of files that Automake deletes during `make clean`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The `TESTS` line at ➋ is the important one in [Listing 6-12](ch06.xhtml#ch06ex12)
    because it indicates which targets are executed when the user makes the `check`
    target. (Since the `check_SCRIPTS` variable contains a complete list of these
    targets, I simply referenced it here, as the `make` variable that it actually
    is.) Note that in this particular case, `check_SCRIPTS` is redundant, because
    Automake generates rules to ensure that all the programs listed in `TESTS` are
    built before the tests are executed. However, `check_*` PLVs become important
    when additional helper scripts or programs must be built before those listed in
    `TESTS` are executed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not necessarily obvious here, but since we added our first test, we need
    to re-execute `autoreconf -i` before running `make check` in order to add a new
    utility script: *test-driver*. You can find places in the Automake documentation
    that indicate clearly that you must do this, but it’s simpler to just let the
    build tell you when something is missing and therefore an execution of `autoreconf
    (-i)` is required. To give you a flavor for this process, let’s try it without
    running `autoreconf` first:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let’s run `autoreconf -i` first:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After running `autoreconf -i` (and noting that `test-driver` was installed into
    our project), we can see that `make check` is now successful.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Note that I didn’t have to manually invoke `configure` after running `autoreconf
    -i`. The build system is generally smart enough to know when it should re-execute
    `configure` for you.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Complexity with Convenience Libraries
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jupiter is fairly trivial as open source software projects go, so in order to
    highlight some more of Automake’s key features, let’s expand it a little. We’ll
    first add a convenience library and then modify `jupiter` to consume this library.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'A *convenience library* is a static library that’s only used within the containing
    project. Such temporary libraries are generally used when multiple binaries in
    a project need to incorporate the same source code. I’ll move the code in *main.c*
    to a library source file and call the function in the library from `jupiter`’s
    `main` routine. Begin by executing the following commands from the top-level project
    directory:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 6.2
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now add the highlighted text from [Listings 6-13](ch06.xhtml#ch06ex13) and [6-14](ch06.xhtml#ch06ex14)
    to the *.h* and *.c* files, respectively, in the new *common* directory.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-13:* common/jupcommon.h: *The initial version of this file*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-14:* common/print.c: *The initial version of this file*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, *print.c* is merely a copy of *main.c*, with a few small modifications
    (highlighted in [Listing 6-14](ch06.xhtml#ch06ex14)). First, I renamed `main`
    to `print_routine`, and then I added the inclusion of the *jupcommon.h* header
    file after the inclusion of *config.h*. The header file provides `print_routine`’s
    prototype to *src/main.c*, where it’s called from `main`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Next, we modify *src/main.c*, as shown in [Listing 6-15](ch06.xhtml#ch06ex15),
    and then add the text in [Listing 6-16](ch06.xhtml#ch06ex16) to *common/Makefile.am*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-15:* src/main.c: *Required modifications to have `main` call into
    the new library*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '*It may seem odd to include* config.h *at the top of* src/main.c *since nothing
    in that source file appears to use it. The* GCS *recommends following the standard
    practice of including* config.h *at the top of all source files, before any other
    inclusions, in case something in one of the other included header files makes
    use of definitions in* config.h. *I recommend religiously following this practice*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 6-16:* common/Makefile.am: *Initial version of this file*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine this new *Makefile.am* file. The first line indicates which products
    this file should build and install. The `noinst` prefix indicates that this library
    is designed solely to make using the source code in the *common* directory more
    convenient.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We’re creating a static library called *libjupcommon.a*, also known as an *archive*.
    Archives are like *.tar* files that only contain object files (*.o*). They can’t
    be executed or loaded into a process address space like shared libraries, but
    they can be added to a linker command line like object files. Linkers are smart
    enough to realize that such archives are merely groups of object files.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*Linkers add to the binary product every object file specified explicitly on
    the command line, but they only extract from archives those object files that
    are actually referenced in the code being linked. Therefore, if you link to a
    static library containing 97 object files, but you only call functions in two
    of them directly or indirectly, only those two object files are added to your
    program. In contrast, linking to 97 raw object files adds all 97 of those files
    to your program, regardless of whether you use any of their functionality*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The second line in [Listing 6-16](ch06.xhtml#ch06ex16) is a product source variable
    that contains the list of source files associated with this library.^([11](footnote.xhtml#ch06fn11))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*Product Option Variables*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we need to add some additional information to *src/Makefile.am* so that
    the generated *Makefile* can find the new library and header file we added to
    the *common* directory. Let’s add two more lines to the existing *Makefile.am*
    file, as shown in [Listing 6-17](ch06.xhtml#ch06ex17).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-17:* src/Makefile.am: *Adding compiler and linker directives to*
    Makefile.am *files*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Like the `jupiter_SOURCES` variable, these two new variables are derived from
    the program name. These *product option variables (POVs)* are used to specify
    product-specific options to tools that are used to build products from source
    code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The `jupiter_CPPFLAGS` variable at ➊ adds product-specific C-preprocessor flags
    to the compiler command line for all source files that are compiled for the `jupiter`
    program. The `-I$(top_srcdir)/common` directive tells the C preprocessor to add
    `$(top_srcdir)`*/common* to its list of locations in which to look for header
    file references.^([12](footnote.xhtml#ch06fn12))
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The `jupiter_LDADD` variable at ➋ adds libraries to the `jupiter` program’s
    linker command line. The file path *../common/libjupcommon.a* merely adds an object
    to the linker command line so that code in this library can become part of the
    final program.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also use *`$(top_builddir)`*/ in place of ../ to reference the location
    of the* common *directory in this path. Using *`$(top_builddir)`* has the added
    advantage of making it simpler to move this* Makefile.am *file to another location
    without having to modify it*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Adding a library to a *`program`*`_LDADD` or *`library`*`_LIBADD` variable is
    only necessary for libraries that are built as part of your own package. If you’re
    linking your program with a library that’s already installed on the user’s system,
    a call to `AC_CHECK_LIB` or `AC_SEARCH_LIBS` in *configure.ac* will cause the
    generated `configure` script to add an appropriate reference to the linker command
    line via the `LIBS` variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The set of POVs supported by Automake are derived mostly from a subset of the
    standard user variables listed in [Table 3-2](ch03.xhtml#ch03tab2) on [page 71](ch03.xhtml#page_71).
    You’ll find a complete list of program and library option variables in the *GNU
    Autoconf Manual*, but here are some of the important ones.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: product_CPPFLAGS
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Use *`product`*`_CPPFLAGS` to pass flags to the C or C++ preprocessor on the
    compiler command line.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: product_CFLAGS
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Use *`product`*`_CFLAGS` to pass C-compiler flags on the compiler command line.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: product_CXXFLAGS
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Use *`product`*`_CXXFLAGS` to pass C++-compiler flags on the compiler command
    line.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: product_LDFLAGS
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Use *`product`*`_LDFLAGS` to pass global and order-independent shared library
    and program linker configuration flags and options to the linker, including `-static`,
    `-version-info`, `-release`, and so on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: program_LDADD
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Use *`program`*`_LDADD` to add Libtool objects (*.lo*) or libraries (*.la*)
    or non-Libtool objects (*.o*) or archives (*.a*) to the linker command line when
    linking a program.^([13](footnote.xhtml#ch06fn13))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: library_LIBADD
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Use *`library`*`_LIBADD` to add non-Libtool linker objects and archives to non-Libtool
    archives on the `ar` utility command line. The `ar` utility will incorporate archives
    mentioned on the command line into the product archive, so you can use this variable
    to gather multiple archives together into one.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: ltlibrary_LIBADD
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Use *`ltlibrary`*`_LIBADD` to add Libtool linker objects (*.lo*) and Libtool
    static or shared libraries (*.la*) to a Libtool static or shared library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the last three option variables in this list to pass lists of order-dependent
    static and shared library references to the linker. You can also use these option
    variables to pass `-L` and `-l` options. The following are acceptable formats:
    `-L`*`libpath`*, `-l`*`libname`*, `[`*`relpath`*`/]`*`archive`*`.a`, `[`*`relpath`*`/]`*`objfile`*`.$(OBJEXT)`,
    `[`*`relpath`*`/]`*`ltobject`*`.lo` , and `[`*`relpath`*`/]`*`ltarchive`*`.la`.
    (Note that the term *`relpath`* indicates a relative path within the project,
    which can be in terms of either relative directory references, using dots, or
    `$(top_builddir)`.)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*Per-Makefile Option Variables*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll often see the Automake variables `AM_CPPFLAGS` and `AM_LDFLAGS` used
    in a *Makefile.am* file. These per-makefile forms of these flags are used when
    the maintainer wants to apply the same set of flags to all products specified
    in the *Makefile.am* file.^([14](footnote.xhtml#ch06fn14)) For example, if you
    need to set a group of preprocessor flags for all products in a *Makefile.am*
    file and then add additional flags for a particular product (`prog1`), you could
    use the statements shown in [Listing 6-18](ch06.xhtml#ch06ex18).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 6-18: Using both per-product and per-file flags*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The existence of a per-product variable overrides Automake’s use of the per-makefile
    variable, so you need to reference the per-makefile variable in the per-product
    variable in order to have the per-makefile variable affect that product, as shown
    in [Listing 6-18](ch06.xhtml#ch06ex18) at ➊. In order to allow per-product variables
    to override their per-makefile counterparts, it’s a good idea to reference the
    per-makefile variable first, before adding any product-specific options.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '*User variables, such as *`CFLAGS`*, are reserved for the end user and should
    never be set by configuration scripts or makefiles. Automake will always append
    them to the appropriate utility command lines, thus allowing the user to override
    the options specified in the makefile*.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Building the New Library
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we need to edit the `SUBDIRS` variable in the top-level *Makefile.am*
    file in order to include the new *common* directory we just added. We also need
    to add the new makefile that was generated in the *common* directory to the list
    of files generated from templates in the `AC_CONFIG_FILES` macro invocation in
    *configure.ac*. These changes are shown in [Listings 6-19](ch06.xhtml#ch06ex19)
    and [6-20](ch06.xhtml#ch06ex20).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-19:* Makefile.am: *Adding the common directory to the `SUBDIRS`
    variable*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-20:* configure.ac: *Adding* common/Makefile *to the `AC_CONFIG_FILES`
    macro*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: This is the largest set of changes we’ve made up to this point, but we’re reorganizing
    the entire application, so it seems reasonable. Let’s give our updated build system
    a try. Add the `-i` option to the `autoreconf` command line so that it will install
    any additional missing files that might be required after these enhancements.
    After so many changes, I like to start with a clean slate, so start with `make
    distclean`, or some form of the `git clean` command if you’re running from a git
    repository work area.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Well, it looks like we’re not quite done yet. Since we’ve added a new type of
    entity—static libraries—to our build system, `automake` (via `autoreconf`) tells
    us at ➊ that we need to add a new macro, `AC_PROG_RANLIB`, to the *configure.ac*
    file.^([15](footnote.xhtml#ch06fn15))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Add this macro to *configure.ac*, as shown in [Listing 6-21](ch06.xhtml#ch06ex21).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 6-21:* configure.ac: *Adding `AC_PROG_RANLIB`*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter `autoreconf -i` once more. Adding `-i` ensures that, if the new
    functionality we added to *configure.ac* requires any additional files to be installed,
    `autoreconf` will do so.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: No more complaints; all is well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: What Goes into a Distribution?
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automake usually determines automatically what should go into a distribution
    created with `make dist`, because it’s very aware of every file’s role in the
    build process. To this end, Automake wants to be told about every source file
    used to build a product and about every file and product installed. This means,
    of course, that all files must be specified at some point in one or more PLV and
    PSV variables.^([16](footnote.xhtml#ch06fn16))
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The Automake `EXTRA_DIST` variable contains a space-delimited list of files
    and directories that should be added to the distribution package when the `dist`
    target is made. For example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You could use the `EXTRA_DIST` variable to add a source directory to the distribution
    package that Automake would not automatically add—for example, a Windows-specific
    directory.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case*, windows *is a directory, not a file. Automake will automatically
    recursively add every file in this directory to the distribution package; this
    may include some files that you really didn’t want there, such as hidden* .svn
    *or* .CVS *status directories. See “Automake -hook and -local Rules” on [page
    389](ch14.xhtml#page_389) for a way around this problem.*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: A WORD ABOUT THE UTILITY SCRIPTS
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The Autotools have added several files to the root of our project directory
    structure: `compile`, `depcomp`, `install-sh`, and `missing`. Because `configure`
    or the generated *Makefile*s all execute these scripts at various points during
    the build process, the end user will need them; however, we can only get them
    from the Autotools, and we don’t want to require the user to have the Autotools
    installed. For this reason, these scripts are automatically added to the distribution
    archive.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: So, do you check them in to your source code repository or not? The answer is
    debatable, but generally I recommend that you don’t. Any maintainer who will be
    creating a distribution archive should have the Autotools installed and should
    be working from a repository work area. As a result, these maintainers will also
    be running `autoreconf -i` (possibly in conjunction with the `--force` option[*](#ch06sfn1))
    to ensure that they have the most up-to-date Autotools-provided utility scripts.
    If you check them in, it will only make it more probable that they become out-of-date
    as time goes by. It will also cause unnecessary churn in your repository revision
    history as contributors ping-pong back and forth between files generated from
    the different versions of the Autotools they’re using.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: I extend this sentiment to the `configure` script as well. Some people argue
    that checking the utility and `configure` scripts into the project repository
    is beneficial, because it ensures that if someone checked out a work area, they
    could build the project from the work area without having the Autotools installed.
    However, my personal philosophy is that developers and maintainers should be expected
    to have these tools installed. Occasionally, an end user will need to build a
    project from a work area, but this should be the exception rather than the typical
    case, and in these exceptional cases, the user should be willing to take on the
    role and requirements of a maintainer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[*](#ch06sfn_1) Use the `--force` option with caution; it will also overwrite
    text files such as *INSTALL*, which may have been modified for the project from
    the default text file that ships with the Autotools.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Maintainer Mode
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Occasionally, timestamps on distribution source files will be newer than the
    current time setting of a user’s system clock. Regardless of the cause, this inconsistency
    confuses `make`, causing it to think that every source file is out-of-date and
    needs to be rebuilt. As a result, it will re-execute the Autotools in an attempt
    to bring `configure` and the *Makefile.in* templates up-to-date. But as maintainers,
    we don’t really expect our users to have the Autotools installed—or at least not
    the latest versions that we’ve installed on our systems.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: This is where Automake’s *maintainer mode* comes in. By default, Automake adds
    rules to makefiles that regenerate template files, configuration scripts, and
    generated sources from maintainer source files such as *Makefile.am* and *configure.ac*,
    as well as Lex and Yacc input files. However, we can use the Automake `AM_MAINTAINER_MODE`
    macro in *configure.ac* to disable the default generation of these maintainer-level
    `make` rules.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: For maintainers who want these rules in place to keep their build system properly
    updated after build system changes, the `AM_MAINTAINER_MODE` macro provides a
    `configure` script command line option (`--enable-maintainer-mode`), which tells
    `configure` to generate *Makefile.in* templates that contain rules and commands
    to execute the Autotools as necessary.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Maintainers must be aware of the use of `AM_MAINTAINER_MODE` in their projects.
    They will need to use this command line option when running `configure` in order
    to generate full build systems that will properly rebuild Autotools-generated
    files when their sources are modified.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '*I also recommend mentioning the use of maintainer mode in the project* INSTALL
    *or* README *files so that end users are not surprised when they modify Autotools
    sources without effect.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Although Automake’s maintainer mode has its advantages, you should know that
    there are various arguments against using it. Most focus on the idea that `make`
    rules should never be purposely restricted, because doing so generates a build
    system that will always fail under certain circumstances. I will, however, state
    that later versions of the Autotools do a much better job of telling you what’s
    happening when a required tool is missing. In fact, this is exactly what the `missing`
    script is for. Most tool invocations are wrapped in the `missing` script, which
    tells you fairly clearly what’s missing and how to install it when it is missing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Another important consideration when using this macro is that you’ve now doubled
    the rows in your test matrix, as every build option has two modes—one that assumes
    the Autotools are installed and one that assumes the opposite. If you decide to
    use the macro to disable maintainer mode by default for your end users, keep these
    points in mind.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Cutting Through the Noise
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The amount of noise generated by Autotools-based build systems has been one
    of the most controversial topics on the Automake mailing list. One camp appreciates
    quiet builds that just display important information, such as warnings and errors.
    The other side argues that valuable information is often embedded in this so-called
    “noise,” so all of it is important and should be displayed. Occasionally, a new
    Autotools developer will post a question about how to reduce the amount of information
    displayed by `make`. This almost always spawns a heated debate that lasts for
    several days over a few dozen email messages. The old-timers just laugh about
    it and often joke about how “someone has turned on the switch again.”
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The truth of the matter is that both sides have valid points. The GNU project
    is all about options, so the Automake maintainers have added the ability to allow
    you to optionally make silent rules available to your users. *Silent rules* in
    Automake makefiles are not really silent; they’re just somewhat less noisy than
    traditional Automake-generated rules.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of displaying the entire compiler or linker command line, silent rules
    display a short line indicating the tool and the name of the file being processed
    by that tool. Output generated by `make` is still displayed so the user knows
    which directory and target are currently being processed. Here is Jupiter’s build
    output, with silent rules enabled (execute `make clean` first to ensure something
    actually gets built):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the use of silent rules doesn’t make a lot of difference for
    Jupiter—Jupiter’s build system spends a lot of time moving between directories
    and very little time actually building things. But in projects with hundreds of
    source files, you’d see long lists of `CC` *`filename`*`.o` lines, with an occasional
    indication that `make` is changing directories or the linker is building a product—compiler
    warnings tend to jump out at you. For instance, the `ar` warning in the output
    would have flown by unnoticed without silent rules.^([17](footnote.xhtml#ch06fn17))
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Silent rules are disabled by default. To enable silent rules by default in Automake-generated
    *Makefile.am* templates, you may call the `AM_SILENT_RULES` macro in *configure.ac*
    with a `yes` argument.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the user may always set the default verbosity for a build with
    `--enable-silent-rules` or `--disable-silent-rules` on the `configure` command
    line. The build will then either be “silent” or normal based on the configured
    default and on whether the user specifies `V=0` or `V=1` on the `make` command
    line.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '*Neither *`configure`* option is required—the actual invocation of silent rules
    is ultimately controlled by the *`V`* variable in the generated makefile. The*
    configure *option merely sets the default value of *`V`*.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'For smaller projects, I find Automake’s silent rules to be less useful than
    simply redirecting `stdout` to */dev/null* on the `make` command line, in this
    manner:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As this example shows, warnings and errors are still displayed on `stderr`,
    usually with enough information for you to determine where the problem is located
    (though not in this case). Warning-free builds are truly silent in this case.
    You should use this technique to clean up compiler warnings in your source code
    every so often. Silent rules can help because warnings stand out in the build
    output.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Nonrecursive Automake
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve changed our handwritten *Makefile.in* templates over to Automake
    *Makefile.am* files, let’s take a look at the process of converting this recursive
    build system to a nonrecursive build system. In previous chapters, we saw that
    using `make`’s `include` directive can be helpful in dividing makefiles into areas
    of responsibility relegated to the subdirectories in which they reside. With Automake,
    however, it’s just simpler to put everything in a top-level *Makefile.am* file
    because the content is so short that we can easily comprehend the entire build
    system at a glance. If further division of responsibility is required, a simple
    comment suffices.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The key here, as in our previous incarnations, is to reference the content as
    if `make` were running from the top-level directory (which—again—it is).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-22](ch06.xhtml#ch06ex22) contains the entire contents of the top-level
    *Makefile.am* file—the only makefile we’ll use in this conversion.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 6.3
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 6-22:* Makefile.am: *A nonrecursive Automake implementation for Jupiter*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, I’ve replaced the `SUBDIRS` variable in the top-level *Makefile.am*
    file with the full contents of the *Makefile.am* files in each of the directories
    referenced by this variable. I then added appropriate relative path information
    to each input object and product reference so that source files are accessed from
    the top-level directory, where they actually reside in their respective subdirectories,
    and so that products end up where they belong—with their source input files (or
    at least in their proper counterpart directories when not building in the source
    tree). I’ve highlighted the changes to each of the subdirectory *Makefile.am*
    files that I pasted into the top-level file.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Note that `common_` or `src_` was prepended to the product source variables
    because these prefixes are literally part of the product names now. Ultimately,
    these names are used to create `make` targets, which are defined as much by their
    location as their name. Usually, the location is the current directory, so the
    directory portions are silently omitted. For our nonrecursive builds, products
    are now generated into locations other than the current directory, so they must
    be stated explicitly. As with any other special characters in the product name,
    the directory-separating slashes become underscores in PSVs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: We also need to add an Automake option and remove the extra *Makefile* references
    from *configure.ac*, as shown in [Listing 6-23](ch06.xhtml#ch06ex23).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 6-23:* configure.ac: *Removing extra makefile references for nonrecursive
    builds*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The Automake `subdir-objects` option is necessary to tell Automake that you
    intend to access source files from directories other than those in which they
    reside. It’s also needed to state that you want the objects and other intermediate
    products to be generated into the same directory as the source file (or in proper
    out-of-tree build counterpart directories). This option is not required just for
    nonrecursive builds but for any situation in which you may need to build one or
    more source files outside of their own directories. If you omit this option, the
    build will often still work, but you’ll see two effects: warnings will be generated
    by `autoreconf` (or `automake`) indicating that you should probably use the option,
    and object files will be left lying in the wrong directories. The latter is only
    a problem if you happen to have more than one instance of a source file with the
    same name in different directories, in which case the second object file will
    overwrite the first, which will most probably result in a linker error when it’s
    not able to find the symbols from the now-overwritten first object.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can simply delete the *common* and *src* directories’ *Makefile.am*
    files:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve discussed how to instrument a project for Automake using
    a project that had already been instrumented for Autoconf. (Newer projects are
    typically instrumented for both Autoconf and Automake at the same time.)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: We covered the use of the `SUBDIRS` variable to tie *Makefile.am* files together,
    as well as the concepts surrounding product list, product source, and product
    option variables. Along with product list variables, I discussed Automake primaries—a
    concept at the very heart of Automake. Finally, I discussed the use of `EXTRA_DIST`
    to add additional files to distribution packages, the `AM_MAINTAINER_MODE` macro
    to ensure that users don’t need to have the Autotools installed, converting to
    a nonrecursive Automake build system, and the use of Automake silent rules.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Through all of this, we replaced our handwritten *Makefile.in* templates with
    short, concise *Makefile.am* files that provide significantly more functionality.
    I hope this exercise has begun to open your eyes to the benefits of using Automake
    rather than handwritten makefiles.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapters 7](ch07.xhtml) and [8](ch08.xhtml), we’ll examine adding Libtool
    to the Jupiter project. In [Chapter 9](ch09.xhtml), we’ll finish up our introduction
    to the Autotools proper by diving into the Autoconf’s portable testing framework—autotest.
    Then, in [Chapters 10](ch10.xhtml) through [13](ch13.xhtml), we’ll take a short
    break from the Autotools to tackle some important sideline topics, but we’ll return
    in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml), where we’ll “Autotool-ize”
    a real-world project as we explore several other important aspects of Automake.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
