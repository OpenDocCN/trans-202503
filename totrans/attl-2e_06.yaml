- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: AUTOMATIC MAKEFILES WITH AUTOMAKE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Automake自动生成Makefile
- en: '*If you understand, things are just as they are; if you do not understand,
    things are just as they are.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你理解了，事情就是它们本来的样子；如果你不理解，事情就是它们本来的样子。'
- en: —Zen proverb*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —禅宗格言*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'Shortly after Autoconf began its journey to success, David MacKenzie started
    working on a new tool for automatically generating makefiles for a GNU project:
    Automake. During early development of the *GNU Coding Standards (GCS)*, it became
    apparent to MacKenzie that because the *GCS* is fairly specific about how and
    where a project’s products should be built, tested, and installed, much of a GNU
    project makefile was boilerplate material. Automake takes advantage of this fact
    to make maintainers’ lives easier and to make the user’s experience more consistent.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Autoconf开始走向成功后不久，David MacKenzie开始着手开发一个用于自动生成GNU项目makefile的新工具：Automake。在*GNU编码标准（GCS）*的早期开发中，MacKenzie意识到，因为*GCS*对项目产品的构建、测试和安装的要求非常具体，很多GNU项目的makefile实际上是模板内容。Automake利用这一点，使得维护者的工作更加轻松，并且让用户的体验更加一致。
- en: MacKenzie’s work on Automake lasted almost a year, ending around November 1994\.
    A year later, in November 1995, Tom Tromey (of Red Hat and Cygnus fame) took over
    the Automake project and played a significant role in its development. Although
    MacKenzie had written the initial version of Automake in Bourne shell script,
    Tromey completely rewrote the tool in Perl and continued to maintain and enhance
    Automake over the next five years.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MacKenzie在Automake上的工作持续了近一年，直到1994年11月左右结束。一年后，即1995年11月，Tom Tromey（来自Red Hat和Cygnus）接管了Automake项目，并在其发展中发挥了重要作用。尽管MacKenzie最初用Bourne
    shell脚本编写了Automake的版本，Tromey完全用Perl重写了这个工具，并在接下来的五年中继续维护和增强Automake。
- en: By the end of 2000, Alexandre Duret-Lutz had essentially taken over maintenance
    of the Automake project. His role as project lead lasted until about mid-2007,
    at which point Ralf Wildenhues^([1](footnote.xhtml#ch06fn1)) took the wheel, with
    occasional input from Akim Demaille and Jim Meyering. From 2012 to early 2017,
    Automake was maintained by Stefano Lattarini while he worked for Google in Switzerland.
    The current maintainer is Mathieu Lirzin, a computer science master’s student
    at the University of Bordeaux in France.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到2000年底，Alexandre Duret-Lutz几乎接管了Automake项目的维护工作。他作为项目负责人一直持续到大约2007年中期，此时Ralf
    Wildenhues^([1](footnote.xhtml#ch06fn1))接手了项目，偶尔有Akim Demaille和Jim Meyering的参与。从2012年到2017年初，Stefano
    Lattarini在为Google瑞士分部工作期间负责Automake的维护。现任维护者是Mathieu Lirzin，他是法国波尔多大学计算机科学硕士生。
- en: 'Most of the complaints I’ve seen about the Autotools are ultimately associated
    with Automake. The reasons are simple: Automake provides the highest level of
    abstraction over the build system and imposes a fairly rigid structure on projects
    that use it. Automake’s syntax is concise—in fact, it’s terse, almost to a fault.
    One Automake statement represents a *lot* of functionality. But once you understand
    it, you can get a fairly complete, complex, and functionally correct build system
    up and running in short order—that is, in minutes, not hours or days.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我所见到的大多数关于Autotools的抱怨最终都与Automake有关。原因很简单：Automake为构建系统提供了最高级别的抽象，并且对使用它的项目强加了一个相当严格的结构。Automake的语法简洁——实际上，它是简练的，几乎到了极致。一个Automake语句代表了*大量*功能。但是，一旦你理解了它，你就能在短时间内（也就是几分钟，而不是几个小时或几天）建立起一个相对完整、复杂且功能正确的构建系统。
- en: In this chapter, I provide you with some insight into the inner workings of
    Automake. With such insight, you’ll begin to feel comfortable not only with what
    Automake can do for you but also with extending it in areas where its automation
    falls short.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将为你提供一些关于Automake内部工作原理的见解。通过这些见解，你将不仅对Automake能为你做什么感到熟悉，而且会开始在其自动化不足的领域进行扩展。
- en: Getting Down to Business
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始正式工作
- en: Let’s face it—getting a makefile right is often difficult. The devil, as they
    say, is in the details. Consider the following changes to the files in our project
    directory structure as we continue to improve the project build system for Jupiter.
    Let’s start by cleaning up our work area. You can do this using `make distclean`,
    or if you’re building from a GitHub repository work area, you can use a form of
    the `git clean` command:^([2](footnote.xhtml#ch06fn2))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实吧——正确编写 Makefile 通常很难。正如人们所说，魔鬼藏在细节中。考虑在我们继续改进 Jupiter 项目的构建系统时，对项目目录结构中的文件进行以下更改。让我们从清理工作区开始。你可以使用
    `make distclean` 来完成这项工作，或者如果你是从 GitHub 仓库工作区构建的，也可以使用 `git clean` 命令的某种形式：^([2](footnote.xhtml#ch06fn2))
- en: Git tag 6.0
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 6.0
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `rm` command at ➊ deletes our hand-coded *Makefile.in* templates and the
    `bootstrap.sh` script we wrote to ensure that all the support scripts and files
    are copied into the root of our project directory. We won’t need this script anymore
    because we’re upgrading Jupiter to Automake proper. (For the sake of brevity,
    I used `echo` statements at ➋ and ➌ to write the new *Makefile.am* files; you
    can use a text editor if you wish.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `rm` 命令删除了我们手动编写的 *Makefile.in* 模板和我们为确保所有支持脚本和文件被复制到项目根目录中而编写的 `bootstrap.sh`
    脚本。由于我们正在将 Jupiter 升级为正式的 Automake，因此不再需要这个脚本。（为了简洁起见，我在 ➋ 和 ➌ 使用了 `echo` 语句来写入新的
    *Makefile.am* 文件；如果你愿意，可以使用文本编辑器。）
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is a hard carriage return at the end of the line at ➌. The shell will
    continue to accept input after the carriage return until the quotation is closed*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 ➌ 处的行末有一个硬回车符。Shell 会继续接受输入，直到引号关闭为止。*'
- en: I used the `touch` command at ➍ to create new, empty versions of the *NEWS*,
    *README*, *AUTHORS*, and *ChangeLog* files in the project root directory. (The
    *INSTALL* and *COPYING* files are added by `autoreconf -i`.) These files are required
    by the *GCS* for all GNU projects. And although they’re not required for non-GNU
    projects, they’ve become something of an institution in the OSS world; users have
    come to expect them.^([3](footnote.xhtml#ch06fn3))
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➍ 使用了 `touch` 命令来创建项目根目录中新的、空的 *NEWS*、*README*、*AUTHORS* 和 *ChangeLog* 文件。（*INSTALL*
    和 *COPYING* 文件是通过 `autoreconf -i` 添加的。）这些文件是 *GCS* 对所有 GNU 项目所要求的。尽管它们对于非 GNU
    项目并非必需，但它们已经成为开源世界中的一种惯例；用户已经习惯了这些文件的存在。^([3](footnote.xhtml#ch06fn3))
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* GCS *covers the format and contents of these files. Sections 6.7 and
    6.8 cover the* NEWS *and* ChangeLog *files, respectively, and Section 7.3 covers
    the* README, INSTALL, *and* COPYING *files. The* AUTHORS *file is a list of people
    (names and optional email addresses) to whom attribution should be given.^([4](footnote.xhtml#ch06fn4))*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*GCS* 覆盖了这些文件的格式和内容。第 6.7 和 6.8 节分别讲解了 *NEWS* 和 *ChangeLog* 文件，第 7.3 节则涵盖了
    *README*、*INSTALL* 和 *COPYING* 文件。*AUTHORS* 文件是一个列出需要给与归属的人员（姓名和可选的电子邮件地址）清单。^([4](footnote.xhtml#ch06fn4))'
- en: It can be a little painful to maintain a *ChangeLog* file—especially since you’ve
    already done it once as you added commit messages to your repository commits.
    To simplify the process, consider using a shell script to scrape your repository
    log into *ChangeLog* before you make a new release. There are existing scripts
    available on the internet; for example, *gnulib* (see [Chapter 13](ch13.xhtml))
    provides the `gitlog-to-changelog` script, which can be used to import a git repository’s
    log information into *ChangeLog* prior to release.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 维护 *ChangeLog* 文件可能有点痛苦——特别是因为你已经在为你的仓库提交添加提交信息时做过一次了。为了简化这个过程，考虑使用一个 shell
    脚本在你做新版本发布之前，将仓库日志抓取到 *ChangeLog* 中。网络上有现成的脚本可供使用；例如，*gnulib*（见 [第13章](ch13.xhtml)）提供了
    `gitlog-to-changelog` 脚本，可以用来在发布之前将 git 仓库的日志信息导入 *ChangeLog* 中。
- en: '*Enabling Automake in configure.ac*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在 configure.ac 中启用 Automake*'
- en: 'To enable Automake within the build system, I’ve added a single line to *configure.ac*:
    a call to `AM_INIT_AUTOMAKE` between the calls to `AC_INIT` and `AC_CONFIG_SRCDIR`,
    as shown in [Listing 6-1](ch06.xhtml#ch06ex1).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在构建系统中启用 Automake，我向 *configure.ac* 添加了一行代码：在 `AC_INIT` 和 `AC_CONFIG_SRCDIR`
    之间调用 `AM_INIT_AUTOMAKE`，如 [列表 6-1](ch06.xhtml#ch06ex1) 所示。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-1: Adding Automake functionality to* configure.ac'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：向 configure.ac 添加 Automake 功能*'
- en: 'If your project has already been configured with Autoconf, this is the *only*
    line that’s required to enable Automake in a working *configure.ac* file. The
    `AM_INIT_AUTOMAKE` macro accepts an optional argument: a whitespace-separated
    list of option tags, which can be passed into this macro to modify the general
    behavior of Automake. For a detailed description of each option, see [Chapter
    17](ch17.xhtml) of the *GNU Automake Manual*.^([5](footnote.xhtml#ch06fn5)) I
    will, however, point out a few of the most useful options here.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目已经使用Autoconf进行了配置，这将是启用Automake的*唯一*必要行，前提是配置文件`configure.ac`有效。`AM_INIT_AUTOMAKE`宏接受一个可选参数：一个由空格分隔的选项标签列表，可以将这些标签传递给此宏，以修改Automake的通用行为。有关每个选项的详细描述，请参阅*GNU
    Automake手册*的[第17章](ch17.xhtml)。^([5](footnote.xhtml#ch06fn5)) 但是，我将在这里指出一些最有用的选项。
- en: gnits, gnu, foreign
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: gnits, gnu, foreign
- en: These options set Automake’s strictness checks. The default is `gnu`. The `gnits`
    option makes Automake even more pedantic than it already is, and the `foreign`
    option loosens things up a bit—with `foreign`, you aren’t required to have the
    obligatory *INSTALL*, *README*, and *ChangeLog* files normally required for GNU
    projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项设置Automake的严格性检查。默认值为`gnu`。`gnits`选项使Automake变得比原来更加挑剔，而`foreign`选项则稍微放宽一些——使用`foreign`时，你不需要像GNU项目那样强制要求*INSTALL*、*README*和*ChangeLog*文件。
- en: check-news
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: check-news
- en: The `check-news` option causes `make dist` to fail if the project’s current
    version (from *configure.ac*) doesn’t show up in the first few lines of the *NEWS*
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-news`选项会导致如果项目的当前版本（来自*configure.ac*）没有出现在*NEWS*文件的前几行中，`make dist`命令失败。'
- en: dist-bzip2, dist-lzip, dist-xz, dist-shar, dist-zip, dist-tarZ
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: dist-bzip2, dist-lzip, dist-xz, dist-shar, dist-zip, dist-tarZ
- en: You can use the `dist-*` options to change the default distribution package
    type. By default, `make dist` builds a *.tar.gz* file, but developers often want
    to distribute, for example, *.tar.xz* packages instead. These options make the
    change quite easy. (Even without the `dist-xz` option, you can override the current
    default by using `make dist-xz`, but using the option is simpler if you always
    want to build *.xz* packages.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`dist-*`选项来更改默认的分发包类型。默认情况下，`make dist`会生成一个*.tar.gz*文件，但开发者常常希望分发例如*.tar.xz*格式的包。这些选项使得更改变得非常简单。（即使没有`dist-xz`选项，你也可以通过使用`make
    dist-xz`来覆盖当前的默认设置，但如果你总是希望构建*.xz*包，使用该选项会更简单。）
- en: readme-alpha
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: readme-alpha
- en: The `readme-alpha` option temporarily alters the behavior of the build and distribution
    processes during alpha releases of a project. Using this option causes a file
    named *README-alpha*, found in the project root directory, to be distributed automatically.
    The use of this option also alters the expected versioning scheme of the project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`readme-alpha`选项会在项目的Alpha版本发布期间临时更改构建和分发过程的行为。使用此选项会自动分发项目根目录中的名为*README-alpha*的文件。使用此选项还会更改项目的版本控制方案。'
- en: -W category, --warnings=category
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: -W category, --warnings=category
- en: The `-W` *`category`* and `--warnings=`*`category`* options indicate that the
    project would like to use Automake with various warning categories enabled. Multiple
    such options can be used with different category tags. Refer to the *GNU Automake
    Manual* to find a list of valid categories.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`-W` *`category`* 和 `--warnings=`*`category`* 选项表示项目希望使用Automake并启用各种警告类别。可以使用多个这样的选项，每个选项可以有不同的类别标签。请参考*GNU
    Automake手册*，查找有效类别的列表。'
- en: parallel-tests
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: parallel-tests
- en: The `parallel-tests` feature allows checks to be executed in parallel in order
    to take advantage of multiprocessor machines during execution of the `check` target.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel-tests`功能允许在执行`check`目标时并行执行检查，以便在多处理器机器上利用并行执行。'
- en: subdir-objects
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: subdir-objects
- en: The `subdir-objects` option is required when you intend to reference sources
    from directories other than the current directory. Using this option causes Automake
    to generate `make` commands that cause object and intermediate files to be generated
    into the same directory as the source file. For more information on this option,
    see “Nonrecursive Automake” on [page 175](ch06.xhtml#page_175).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`subdir-objects`选项在你打算引用当前目录以外的目录中的源代码时是必需的。使用此选项会导致Automake生成`make`命令，使得目标文件和中间文件与源文件生成在同一目录下。有关此选项的更多信息，请参阅“非递归Automake”部分，见[第175页](ch06.xhtml#page_175)。'
- en: version
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: version
- en: The *`version`* option is actually a placeholder for a version number that represents
    the lowest version of Automake that is acceptable for this project. For instance,
    if `1.11` is passed as an option tag, Automake will fail while processing *configure.ac*
    if its version is earlier than 1.11\. This can be useful if you’re trying to use
    features that only exist in later versions of Automake.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*`version`* 选项实际上是一个占位符，用于表示此项目接受的最低版本的 Automake 版本号。例如，如果传入 `1.11` 作为选项标记，如果
    Automake 的版本低于 1.11，则在处理 *configure.ac* 时会失败。如果你打算使用只有较新版本的 Automake 才支持的功能，这会非常有用。'
- en: 'With the new *Makefile.am* files in place and Automake enabled in *configure.ac*,
    let’s run `autoreconf` with the `-i` option in order to add any new utility files
    that Automake may require for our project:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经有了新的 *Makefile.am* 文件，并且在 *configure.ac* 中启用了 Automake，接下来我们可以运行 `autoreconf`
    并使用 `-i` 选项，以便为我们的项目添加 Automake 可能需要的任何新工具文件：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Adding the `AM_INIT_AUTOMAKE` macro to *configure.ac* causes `autoreconf -i`
    to now execute `automake -i`, which includes a few additional utility files: *aclocal.m4*,
    *install-sh*, *compile*, *missing*, and *depcomp*. Also, Automake now generates
    *Makefile.in* from *Makefile.am*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `AM_INIT_AUTOMAKE` 宏添加到 *configure.ac* 中，会导致 `autoreconf -i` 现在执行 `automake
    -i`，这将包括一些额外的工具文件：*aclocal.m4*、*install-sh*、*compile*、*missing* 和 *depcomp*。此外，Automake
    现在会从 *Makefile.am* 生成 *Makefile.in*。
- en: I mentioned *aclocal.m4* in [Chapter 2](ch02.xhtml) and `install-sh` in [Chapter
    4](ch04.xhtml). The `missing` script is a little utility helper script that prints
    a nicely formatted message when a tool specified on its command line is not available.
    More detail than this is not really required; if you’re curious, execute `./missing
    --help` in your project directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第 2 章](ch02.xhtml)中提到过 *aclocal.m4*，在[第 4 章](ch04.xhtml)中提到过 `install-sh`。`missing`
    脚本是一个小的辅助工具脚本，当命令行上指定的工具不可用时，它会打印一个格式化的错误信息。其实没有必要了解更多细节；如果你感兴趣，可以在项目目录中执行 `./missing
    --help`。
- en: We’ll talk about the `depcomp` script shortly, but I’d like to mention the purpose
    of the `compile` script here. This script is a wrapper around some older compilers
    that do not understand the concurrent use of the `-c` and `-o` command line options.
    When you use product-specific flags, which we’ll discuss shortly, Automake has
    to generate code that may compile source files multiple times with different flags
    for each file. Thus, it has to name the object files differently for each set
    of flags it uses. The `compile` script facilitates this process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会谈到 `depcomp` 脚本，但在此我想提一下 `compile` 脚本的目的。这个脚本是一些旧编译器的包装器，它们不理解同时使用 `-c`
    和 `-o` 命令行选项。当你使用特定产品的标志（我们稍后会讨论）时，Automake 必须生成代码，这些代码可能会多次编译源文件，每次编译使用不同的标志。因此，它必须为每组标志命名不同的目标文件。`compile`
    脚本简化了这个过程。
- en: Automake also adds default *INSTALL* and *COPYING* text files containing boilerplate
    text that pertains specifically to the GNU project. You can modify these files
    for your projects as you see fit. I find the default *INSTALL* file text to be
    useful for general-purpose instructions related to Autotools-built projects, but
    I like to prepend some project-specific information to the top of this file before
    committing it to my repository. Automake’s `-i` option won’t overwrite these text
    files in a project that already contains them, so feel free to modify the default
    files as you see fit, once they’ve been added by `autoreconf -i`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 还会添加默认的 *INSTALL* 和 *COPYING* 文本文件，这些文件包含与 GNU 项目相关的模板文本。你可以根据需要修改这些文件以适应你的项目。我发现默认的
    *INSTALL* 文件内容对于与 Autotools 构建项目相关的通用指令非常有用，但在将其提交到我的代码库之前，我喜欢在文件顶部添加一些项目特定的信息。Automake
    的 `-i` 选项在项目中已经包含这些文本文件时不会覆盖它们，因此，一旦通过 `autoreconf -i` 添加了这些文件，你可以根据需要修改这些默认文件。
- en: The *COPYING* file contains the text of the GPL, which may or may not apply
    to your project. If your project is released under GPL, just leave the text as
    is. If you’re releasing under another license, such as the BSD, MIT, or Apache
    Commons licenses, replace the default text with text appropriate for that license.^([6](footnote.xhtml#ch06fn6))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*COPYING* 文件包含 GPL 许可证的文本，可能适用于或不适用于你的项目。如果你的项目是根据 GPL 许可发布的，只需保留该文本不变。如果你是根据其他许可证（如
    BSD、MIT 或 Apache Commons 许可证）发布的，请将默认文本替换为适合该许可证的文本。^([6](footnote.xhtml#ch06fn6))'
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You only need to use the *`-i`* option once in a newly checked-out work area
    or a newly created project. Once the missing utility files have been added, you
    can drop the *`-i`* option in future calls to *`autoreconf`* unless you add certain
    macros to* configure.ac, *which may then cause the use of the *`-i`* option to
    add more missing files. We’ll see some of this sort of thing in later chapters.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*你只需要在新检出的工作区或新创建的项目中使用一次*`-i`*选项。添加缺失的工具文件后，除非你向*configure.ac*中添加某些宏，否则你可以在以后调用*`autoreconf`*时省略*`-i`*选项，添加的宏可能会导致使用*`-i`*选项以添加更多缺失的文件。我们将在后面的章节中看到这类情况。*'
- en: The preceding commands create an Automake-based build system that contains everything
    (with the minor exception of `check` functionality, which we’ll get to shortly)
    that we wrote into our original *Makefile.in* templates, except that this system
    is more correct and functionally complete according to the *GCS*. A glance at
    the resulting generated *Makefile.in* template shows that Automake has done a
    significant amount of work for us. The resulting top-level *Makefile.in* template
    is nearly 24KB, while the original, hand-coded makefiles were only a few hundred
    bytes long.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一个基于Automake的构建系统，包含了我们在原始*Makefile.in*模板中编写的所有内容（除了稍后会提到的`check`功能之外），但是这个系统在功能上更加完整，且符合*GCS*的规范。查看生成的*Makefile.in*模板，我们可以看到Automake为我们做了大量工作。生成的顶层*Makefile.in*模板几乎有24KB，而原来的手工编写的makefile只有几百字节。
- en: 'An Automake build system supports the following important `make` targets (derived
    from an Automake-generated *Makefile*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Automake构建系统支持以下重要的`make`目标（从Automake生成的*Makefile*派生）：
- en: '| `all` | `check` | `clean` | `ctags` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `all` | `check` | `clean` | `ctags` |'
- en: '| `dist` | `dist-bzip2` | `dist-gzip` | `dist-lzip` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `dist` | `dist-bzip2` | `dist-gzip` | `dist-lzip` |'
- en: '| `dist-shar` | `dist-tarZ` | `dist-xz` | `dist-zip` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `dist-shar` | `dist-tarZ` | `dist-xz` | `dist-zip` |'
- en: '| `distcheck` | `distclean` | `distdir` | `dvi` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `distcheck` | `distclean` | `distdir` | `dvi` |'
- en: '| `html` | `info` | `install` | `install-data` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `html` | `info` | `install` | `install-data` |'
- en: '| `install-dvi` | `install-exec` | `install-html` | `install-info` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `install-dvi` | `install-exec` | `install-html` | `install-info` |'
- en: '| `install-pdf` | `install-ps` | `install-strip` | `installcheck` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `install-pdf` | `install-ps` | `install-strip` | `installcheck` |'
- en: '| `installdirs` | `maintainer-clean` | `mostlyclean` | `pdf` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `installdirs` | `maintainer-clean` | `mostlyclean` | `pdf` |'
- en: '| `ps` | `tags` | `ininstall` |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | `tags` | `ininstall` |  |'
- en: As you can see, this goes far beyond what we could provide in our hand-coded
    *Makefile.in* templates. Automake writes this base functionality into every project
    that uses it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这远远超出了我们在手动编写的*Makefile.in*模板中能提供的功能。Automake将这些基础功能写入每个使用它的项目中。
- en: '*A Hidden Benefit: Automatic Dependency Tracking*'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一个隐藏的好处：自动依赖关系跟踪*'
- en: In “Dependency Rules” on [page 46](ch03.xhtml#page_46), we discussed `make`
    dependency rules. These are rules we define in makefiles so that `make` is aware
    of the hidden relationships between C-language source files and included header
    files. Automake goes to a lot of trouble to ensure that you don’t have to write
    such dependency rules for languages it understands, like C, C++, and Fortran.
    This is an important feature for projects containing more than a few source files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在《依赖规则》一节中（见[第46页](ch03.xhtml#page_46)），我们讨论了`make`依赖规则。这些规则是我们在makefile中定义的，以便`make`能够意识到C语言源文件与包含的头文件之间的隐含关系。Automake花费了大量精力来确保你不需要为它能够理解的语言（如C、C++和Fortran）编写这些依赖规则。这是对于包含多个源文件的项目来说非常重要的一个特性。
- en: Writing dependency rules by hand for dozens or hundreds of source files is both
    tedious and error prone. In fact, it’s such a problem that compiler writers often
    provide a mechanism that enables the compiler to write these rules automatically
    based on its internal knowledge of the source files and the language. The GNU
    compilers, among others, support a family of `-M` options (`-M`, `-MM`, `-MF`,
    `-MG`, and so on) on the command line. These options tell the compiler to generate
    a `make` dependency rule for the specified source file. (Some of these options
    can be used on the normal compiler command line, so the dependency rule can be
    generated when the source file is being compiled.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 手动为数十或数百个源文件编写依赖规则既繁琐又容易出错。事实上，这已经成为一个问题，以至于编译器作者经常提供一种机制，使编译器能够根据其对源文件和语言的内部知识自动编写这些规则。GNU编译器等支持一系列`-M`选项（`-M`、`-MM`、`-MF`、`-MG`等）。这些选项告诉编译器为指定的源文件生成一个`make`依赖规则。（其中一些选项可以在正常的编译命令行中使用，因此可以在源文件被编译时生成依赖规则。）
- en: The simplest of these options is the basic `-M` option, which causes the compiler
    to generate a dependency rule for the specified source file on `stdout` and then
    terminate. This rule can be captured in a file, which is then included by the
    makefile so that the dependency information within this rule is incorporated into
    the directed graph that `make` builds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中最简单的是基本的 `-M` 选项，它使编译器为指定的源文件在 `stdout` 上生成一个依赖关系规则，然后终止。这个规则可以被捕获到一个文件中，随后由
    makefile 包含，从而将该规则中的依赖关系信息纳入到 `make` 构建的有向图中。
- en: 'But what happens on systems where the native compilers don’t provide dependency
    generation options, or where they don’t work together with the compilation process?
    In such cases, Automake provides a wrapper script called *depcomp* that executes
    the compiler twice: once for dependency information and again to compile the source
    file. When the compiler lacks the options to generate *any* dependency information,
    another tool may be used to recursively determine which header files affect a
    given source file. On systems where none of these options is available, automatic
    dependency generation fails.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当系统中的本地编译器不提供依赖关系生成选项，或者它们与编译过程无法配合工作时，会发生什么情况呢？在这种情况下，Automake 提供了一个名为*depcomp*的包装脚本，该脚本会执行两次编译：第一次生成依赖关系信息，第二次编译源文件。当编译器缺少生成*任何*依赖关系信息的选项时，可以使用另一个工具递归地确定哪些头文件会影响给定的源文件。在没有这些选项可用的系统上，自动依赖关系生成将失败。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For a more detailed description of the dependency-generating compiler options,
    see “Item 10: Using Generated Source Code” on [page 529](ch18.xhtml#page_529).
    For more on Automake dependency management, see the relevant sections of the*
    GNU Automake Manual.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于依赖关系生成编译器选项的更详细描述，请参阅[第529页](ch18.xhtml#page_529)的“项目 10：使用生成的源代码”。关于 Automake
    依赖关系管理的更多内容，请参阅* GNU Automake 手册的相关章节。'
- en: It’s time now to bite the bullet and give it a try. As with our build system
    from the previous chapter, run `autoreconf` (optional since we ran `autoreconf
    -i` earlier, but harmless), followed by `./configure` and `make`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候咬紧牙关，尝试一下了。和上一章的构建系统一样，运行 `autoreconf`（由于我们之前运行过 `autoreconf -i`，所以这是可选的，但没有害处），接着运行
    `./configure` 和 `make`。
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can’t truly appreciate what Automake has done here without trying a few
    of the other `make` targets we’ve become familiar with. Try out the `install`,
    `dist`, and `distcheck` targets on your own to assure yourself that you still
    have all the functionality you had before you deleted your handwritten *Makefile.in*
    templates.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不尝试我们已经熟悉的其他 `make` 目标，你是无法真正体会到 Automake 所做的工作。自己尝试 `install`、`dist` 和 `distcheck`
    目标，以确认你在删除手写的 *Makefile.in* 模板之后，仍然拥有之前的所有功能。
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The *`check`* target exists as a do-nothing target at this point, but we need
    to dive into Automake constructs in a bit more detail before we can add our test
    back in. When we get to it, you’ll see that it’s even simpler than the code we
    originally wrote*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*`check`* 目标目前作为一个无操作的目标存在，但在我们能将测试加回来之前，我们需要更详细地研究 Automake 构造。当我们深入到这一部分时，你会发现它甚至比我们最初编写的代码更简单。'
- en: What’s Actually in a Makefile.am File?
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Makefile.am 文件实际上包含了什么？
- en: In [Chapter 4](ch04.xhtml), we discussed how Autoconf accepts as input a shell
    script sprinkled with M4 macros and then generates the same shell script with
    those macros fully expanded. Likewise, Automake accepts as input a makefile sprinkled
    with Automake commands. Just as Autoconf’s input files are simply enhanced shell
    scripts, Automake *Makefile.am* files are nothing more than standard makefiles
    with additional Automake-specific syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)中，我们讨论了 Autoconf 如何将一个包含 M4 宏的 shell 脚本作为输入，并生成同样的 shell 脚本，其中这些宏得到了完全展开。同样，Automake
    将一个包含 Automake 命令的 makefile 作为输入。正如 Autoconf 的输入文件仅仅是增强版的 shell 脚本一样，Automake
    的*Makefile.am* 文件也不过是标准的 makefile，只是额外包含了 Automake 特有的语法。
- en: One significant difference between Autoconf and Automake is that the only text
    Autoconf outputs is the existing shell script in the input file and any additional
    shell script resulting from the expansion of embedded M4 macros. Automake, on
    the other hand, assumes that all makefiles should contain a minimal infrastructure
    designed to support the *GCS*, in addition to any targets and variables that you
    specify.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 和 Automake 之间的一个显著区别是，Autoconf 输出的唯一文本是输入文件中现有的 shell 脚本，以及嵌入的 M4 宏展开后产生的任何附加
    shell 脚本。另一方面，Automake 假设所有的 makefile 都应该包含一个最小的基础设施，用于支持*GCS*，除了你指定的任何目标和变量之外。
- en: 'To illustrate this point, create a *temp* directory in the root of the Jupiter
    project and add an empty *Makefile.am* file to it. Next, add this new *Makefile.am*
    to the project’s *configure.ac* file with a text editor and reference it from
    the top-level *Makefile.am* file, like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，在 Jupiter 项目的根目录中创建一个 *temp* 目录，并向其中添加一个空的 *Makefile.am* 文件。接下来，用文本编辑器将这个新的
    *Makefile.am* 添加到项目的 *configure.ac* 文件中，并从顶层的 *Makefile.am* 文件中引用它，如下所示：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I used an `echo` statement at ➊ to rewrite a new top-level *Makefile.am* file
    that has `SUBDIRS` reference both *src* and *temp*. I used a text editor to add
    *temp/Makefile* to the list of makefiles Autoconf will generate from templates
    (➋). As you can see, there is a certain amount of support code generated into
    every makefile that Automake considers indispensable. Even an empty *Makefile.am*
    file generates a 12KB *Makefile.in* template (➍), from which `configure` generates
    a similarly sized *Makefile* (➌).^([7](footnote.xhtml#ch06fn7))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➊ 处使用了一个 `echo` 语句，重写了一个新的顶层 *Makefile.am* 文件，其中 `SUBDIRS` 同时引用 *src* 和 *temp*。我用文本编辑器将
    *temp/Makefile* 添加到 Autoconf 将从模板生成的 makefile 列表中（➋）。如您所见，每个 makefile 中生成了一些 Automake
    认为不可或缺的支持代码。即使是一个空的 *Makefile.am* 文件，也会生成一个 12KB 的 *Makefile.in* 模板（➍），然后 `configure`
    从中生成一个类似大小的 *Makefile*（➌）。^([7](footnote.xhtml#ch06fn7))
- en: 'Since the `make` utility uses a fairly rigid set of rules for processing makefiles,
    Automake takes some license with your additional `make` code. Here are some specifics:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `make` 工具使用一套相当严格的规则来处理 makefile，Automake 对你额外的 `make` 代码有一些灵活的处理。以下是一些具体内容：
- en: The `make` variables defined in *Makefile.am* files are placed at the top of
    the resulting *Makefile.in* template, immediately following any Automake-generated
    variable definitions.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Makefile.am* 文件中定义的 `make` 变量被放置在生成的 *Makefile.in* 模板的顶部，紧跟在任何 Automake 生成的变量定义之后。
- en: The `make` rules specified in *Makefile.am* files are placed at the end of the
    resulting *Makefile.in* template, immediately after any Automake-generated rules.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Makefile.am* 文件中指定的 `make` 规则被放置在生成的 *Makefile.in* 模板的末尾，紧跟在任何 Automake 生成的规则之后。
- en: Most Autoconf variables substituted by `config.status` are converted to `make`
    variables and initialized to those substitution variables.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数由 `config.status` 替换的 Autoconf 变量被转换为 `make` 变量，并初始化为那些替换变量。
- en: The `make` utility doesn’t care where rules are in relation to each other, because
    it reads every rule into an internal database before processing any of them. Variables
    are treated similarly, as long as they are defined before the rules that use them.
    In order to avoid any variable-binding issues, Automake places all variables at
    the top of the output file in the order in which they’re defined in the input
    file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 工具不关心规则之间的位置关系，因为它会在处理任何规则之前，将每条规则读取到一个内部数据库中。变量也类似，只要它们在使用之前被定义。为了避免任何变量绑定问题，Automake
    会将所有变量按定义顺序放在输出文件的顶部。'
- en: Analyzing Our New Build System
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析我们的新构建系统
- en: Now let’s look at what we put into those two simple *Makefile.am* files, beginning
    with the top-level *Makefile.am* file (shown in [Listing 6-2](ch06.xhtml#ch06ex2)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下我们在这两个简单的 *Makefile.am* 文件中放了什么，从顶层的 *Makefile.am* 文件开始（如[列表 6-2](ch06.xhtml#ch06ex2)所示）。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-2:* Makefile.am: *The top-level* Makefile.am *file contains only
    a subdirectory reference.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2:* Makefile.am: *顶层* Makefile.am *文件仅包含一个子目录引用。*'
- en: 'This single line of text tells Automake several things about our project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行文本告诉 Automake 我们项目的几个信息：
- en: One or more subdirectories contain makefiles to be processed in addition to
    this file.^([8](footnote.xhtml#ch06fn8))
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个子目录包含要处理的 makefile，除了这个文件之外。^([8](footnote.xhtml#ch06fn8))
- en: Directories in this space-delimited list should be processed in the order specified.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此空格分隔的目录列表应按指定的顺序处理。
- en: Directories in this list should be recursively processed for all primary targets.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此列表中的目录应为所有主要目标递归处理。
- en: Directories in this list should be treated as part of the project distribution,
    unless otherwise specified.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非另有说明，否则此列表中的目录应视为项目分发的一部分。
- en: As with most Automake constructs, `SUBDIRS` is simply a `make` variable that
    has special meaning for Automake. The `SUBDIRS` variable may be used to process
    *Makefile.am* files within arbitrarily complex directory structures, and the directory
    list may contain any relative directory references (not just immediate subdirectories).
    You might say that `SUBDIRS` is kind of like the glue that holds makefiles together
    in a project’s directory hierarchy, when using a recursive build system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数Automake构造一样，`SUBDIRS`只是一个`make`变量，对于Automake有特殊的含义。`SUBDIRS`变量可用于处理具有任意复杂目录结构的*Makefile.am*文件，目录列表可以包含任何相对目录引用（不仅仅是直接的子目录）。可以说，`SUBDIRS`就像是在使用递归构建系统时，将makefile连接在项目目录层次结构中的“粘合剂”。
- en: 'Automake generates recursive `make` rules that implicitly process the current
    directory after those specified in the `SUBDIRS` list, but it’s often necessary
    to build the current directory before some or all of the other directories in
    the list. You may change the default ordering by referencing the current directory
    with a dot anywhere in the `SUBDIRS` list. For example, to build the top-level
    directory before the *src* directory, you could change the `SUBDIRS` variable
    in [Listing 6-2](ch06.xhtml#ch06ex2) as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Automake生成递归的`make`规则，这些规则在处理`SUBDIRS`列表中指定的目录后，隐式地处理当前目录，但有时需要在其他某些或所有目录之前构建当前目录。可以通过在`SUBDIRS`列表中的任何位置引用当前目录（使用点符号）来更改默认的构建顺序。例如，要在*src*目录之前构建顶层目录，可以按如下方式修改[列表
    6-2](ch06.xhtml#ch06ex2)中的`SUBDIRS`变量：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let’s turn to the *Makefile.am* file in the *src* directory, shown in [Listing
    6-3](ch06.xhtml#ch06ex3).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到*src*目录中的*Makefile.am*文件，如[列表 6-3](ch06.xhtml#ch06ex3)所示。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-3:* src/Makefile.am: *The initial version of this* Makefile.am *file
    contains only two lines*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：* src/Makefile.am：*这个* Makefile.am *文件的初始版本只包含两行*'
- en: The first line is a *product list variable* specification, and the second line
    is a *product source variable* specification.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是*产品列表变量*的规范，第二行是*产品源变量*的规范。
- en: '*Product List Variables*'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*产品列表变量*'
- en: 'Products are specified in a *Makefile.am* file using a *product list variable
    (PLV)*, which (like `SUBDIRS`) is a class of `make` variables that have special
    meaning to Automake. The following template shows the general format of a PLV:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 产品在*Makefile.am*文件中通过*产品列表变量（PLV）*进行指定，像`SUBDIRS`一样，PLV是`make`变量的一类，对Automake具有特殊意义。以下模板显示了PLV的常见格式：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The PLV name in the first line of [Listing 6-3](ch06.xhtml#ch06ex3) consists
    of two components: the *prefix* (*bin*) and the *primary* (`PROGRAMS`), separated
    by an underscore (`_`). The value of the variable is a whitespace-separated list
    of products generated by this *Makefile.am* file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](ch06.xhtml#ch06ex3)中第一行的PLV名称由两部分组成：*前缀*（*bin*）和*主元素*（`PROGRAMS`），由下划线（`_`）分隔。该变量的值是由此*Makefile.am*文件生成的产品的一个以空格分隔的列表。'
- en: Installation Location Prefixes
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装位置前缀
- en: The *bin* portion of the product list variable shown in [Listing 6-3](ch06.xhtml#ch06ex3)
    is an example of an *installation location prefix*. The *GCS* defines many common
    installation locations, and most are listed in [Table 3-1](ch03.xhtml#ch03tab1)
    on [page 65](ch03.xhtml#page_65). However, any `make` variable ending in `dir`,
    whose value is a filesystem location, is a viable installation location variable
    and may be used as a prefix in an Automake PLV.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](ch06.xhtml#ch06ex3)中显示的产品列表变量的*bin*部分是一个*安装位置前缀*的示例。*GCS*定义了许多常见的安装位置，大多数在[表
    3-1](ch03.xhtml#ch03tab1)中列出，位于[第65页](ch03.xhtml#page_65)。然而，任何以`dir`结尾且值为文件系统位置的`make`变量，都是有效的安装位置变量，并且可以作为Automake
    PLV中的前缀使用。'
- en: You reference an installation location variable in a PLV prefix by omitting
    the `dir` portion of the variable name. For example, in [Listing 6-3](ch06.xhtml#ch06ex3),
    the `$(bindir)` `make` variable is referred to only as `bin` when it is used as
    an installation location prefix.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在PLV前缀中引用安装位置变量时，应省略变量名称中的`dir`部分。例如，在[列表 6-3](ch06.xhtml#ch06ex3)中，当`$(bindir)`
    `make`变量用作安装位置前缀时，只需称其为`bin`。
- en: 'Automake also recognizes four installation location variables starting with
    the special `pkg` prefix: `pkglibdir`, `pkgincludedir`, `pkgdatadir`, and `pkglibexecdir`.
    These `pkg` versions of the standard `libdir`, `includedir`, `datadir`, and `libexecdir`
    variables indicate that the listed products should be installed in a subdirectory
    of these locations named after the package. For example, in the Jupiter project,
    products listed in a PLV prefixed with `lib` would be installed into `$(libdir)`,
    while those listed in a PLV prefixed with `pkglib` would be installed into `$(libdir)`*/jupiter*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 还识别四个以特殊 `pkg` 前缀开头的安装位置变量：`pkglibdir`、`pkgincludedir`、`pkgdatadir`
    和 `pkglibexecdir`。这些 `pkg` 版本的标准 `libdir`、`includedir`、`datadir` 和 `libexecdir`
    变量表示列出的产品应安装在这些位置的子目录中，子目录名称与软件包相同。例如，在 Jupiter 项目中，带有 `lib` 前缀的 PLV 中列出的产品将安装到
    `$(libdir)` 中，而带有 `pkglib` 前缀的 PLV 中列出的产品将安装到 `$(libdir)`*/jupiter* 中。
- en: Since Automake derives the list of valid installation locations and prefixes
    from all `make` variables ending in `dir`, you may provide your own PLV prefixes
    that refer to custom installation locations. To install a set of XML files into
    an *xml* directory within the system data directory, you could use the code in
    [Listing 6-4](ch06.xhtml#ch06ex4) in your *Makefile.am* file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Automake 从所有以 `dir` 结尾的 `make` 变量中推导出有效的安装位置和前缀列表，因此您可以提供自己的 PLV 前缀，指向自定义的安装位置。要将一组
    XML 文件安装到系统数据目录中的 *xml* 目录，您可以在 [清单 6-4](ch06.xhtml#ch06ex4) 中的 *Makefile.am*
    文件中使用代码。
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-4: Specifying a custom installation directory*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：指定自定义安装目录*'
- en: Installation location variables will contain default values defined either by
    Automake-generated makefiles or by you in your *Makefile.am* files, but your users
    can always override these default values on their `configure` or `make` command
    lines. If you don’t want certain products to be installed during a particular
    build, specify an empty value in an installation location variable on the command
    line; the Automake-generated rules will ensure that products intended for those
    directories aren’t installed. For example, to install only documentation and shared
    data files for a package, you could enter `make bindir='' libdir='' install`.^([9](footnote.xhtml#ch06fn9))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 安装位置变量将包含由 Automake 生成的 makefile 或您在 *Makefile.am* 文件中定义的默认值，但用户总是可以在 `configure`
    或 `make` 命令行中覆盖这些默认值。如果您不希望在特定构建过程中安装某些产品，请在命令行中的安装位置变量中指定空值；Automake 生成的规则将确保不安装目标目录中的产品。例如，要仅为一个软件包安装文档和共享数据文件，您可以输入
    `make bindir='' libdir='' install`。^([9](footnote.xhtml#ch06fn9))
- en: Prefixes Not Associated with Installation
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与安装无关的前缀
- en: 'Certain prefixes are not related to installation locations. For example, `noinst`,
    `check`, and `EXTRA` are used (respectively) to indicate products that are not
    installed, are used only for testing, or are optionally built. Here’s a little
    more information about these three prefixes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 某些前缀与安装位置无关。例如，`noinst`、`check` 和 `EXTRA` 分别用于表示不安装的产品、仅用于测试的产品或可选构建的产品。以下是关于这三个前缀的更多信息：
- en: noinst
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: noinst
- en: Indicates that the listed products should be built but not installed. For example,
    a static so-called *convenience library* might be built as an intermediate product
    and then used in other stages of the build process to build final products. The
    `noinst` prefix tells Automake that the product should not be installed and that
    only a static library should be built. (After all, it makes no sense to build
    a shared library that won’t be installed.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表示列出的产品应该构建，但不需要安装。例如，一个所谓的静态 *便利库* 可能会作为中间产品构建，然后在构建过程的其他阶段中用于构建最终产品。`noinst`
    前缀告诉 Automake 不应安装该产品，仅构建静态库。（毕竟，构建一个不会安装的共享库是没有意义的。）
- en: check
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 检查
- en: Indicates products that are to be built only for testing purposes and will thus
    not need to be installed. Products listed in PLVs prefixed with `check` are built
    only if the user enters `make check`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表示仅为测试目的构建的产品，因此不需要安装。在 PLV 中以 `check` 为前缀列出的产品仅在用户输入 `make check` 时才会构建。
- en: EXTRA
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: EXTRA
- en: Used to list programs that are conditionally built. Automake requires that all
    source files be specified statically within a *Makefile.am* file, as opposed to
    being calculated or derived during the build process, so that it can generate
    a *Makefile.in* template that will work for any possible command line. However,
    a project maintainer may elect to allow some products to be built conditionally
    based on configuration options given to the `configure` script. If products are
    listed in variables generated by the `configure` script, they should also be listed
    in a PLV, prefixed with `EXTRA`, within a *Makefile.am* file. This concept is
    illustrated in [Listings 6-5](ch06.xhtml#ch06ex5) and [6-6](ch06.xhtml#ch06ex6).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用于列出有条件构建的程序。Automake要求所有源文件都必须在*Makefile.am*文件中静态指定，而不是在构建过程中计算或推导，以便它能够生成一个适用于任何可能命令行的*Makefile.in*模板。然而，项目维护者可以选择允许某些产品根据传递给`configure`脚本的配置选项有条件地构建。如果产品在由`configure`脚本生成的变量中列出，它们也应该在*Makefile.am*文件中的PLV中列出，并以`EXTRA`为前缀。这个概念在[清单6-5](ch06.xhtml#ch06ex5)和[6-6](ch06.xhtml#ch06ex6)中有所说明。
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-5: A conditionally built program defined in a shell variable in*
    configure.ac'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-5：在*configure.ac中定义的有条件构建的程序，存储在一个Shell变量中'
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-6: Using the `EXTRA` prefix to conditionally define products in*
    Makefile.am'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-6：在* Makefile.am中使用`EXTRA`前缀有条件地定义产品'
- en: At ➊ in [Listing 6-5](ch06.xhtml#ch06ex5), `optprog` is appended to an Autoconf
    substitution variable called `optional_programs`. The `EXTRA_PROGRAMS` variable
    at ➋ in [Listing 6-6](ch06.xhtml#ch06ex6) lists `optprog` as a product that may
    or may not be built, based on end-user configuration choices that determine whether
    `$(optional_programs)` at ➌ is empty or contains `optprog`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单6-5](ch06.xhtml#ch06ex5)中的➊处，`optprog`被附加到一个名为`optional_programs`的Autoconf替代变量中。在[清单6-6](ch06.xhtml#ch06ex6)中的➋处，`EXTRA_PROGRAMS`变量列出了`optprog`，作为一个可能构建或不构建的产品，取决于最终用户的配置选择，这些配置决定了➌处的`$(optional_programs)`是否为空或包含`optprog`。
- en: While it may appear redundant to specify `optprog` in both *configure.ac* and
    *Makefile.am*, Automake needs the information in `EXTRA_PROGRAMS` because it cannot
    attempt to interpret the possible values of `$(optional_programs)`, as defined
    in *configure.ac*. Hence, adding `optprog` to `EXTRA_PROGRAMS` in this example
    tells Automake to generate rules to build it, even if `$(optional_programs)` doesn’t
    contain `optprog` during a particular build.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在*configure.ac*和*Makefile.am*中都指定`optprog`看起来可能是冗余的，但Automake需要在`EXTRA_PROGRAMS`中提供该信息，因为它无法尝试解释在*configure.ac*中定义的`$(optional_programs)`的可能值。因此，在这个示例中将`optprog`添加到`EXTRA_PROGRAMS`中，告诉Automake生成规则来构建它，即使`$(optional_programs)`在某次构建中不包含`optprog`。
- en: Primaries
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主要产品
- en: '*Primaries* are like product classes, and they represent types of products
    that might be generated by a build system. A primary defines the set of steps
    required to build, test, install, and execute a particular class of products.
    For example, programs and libraries are built using different compiler and linker
    commands, Java classes require a virtual machine to execute them, and Python programs
    require an interpreter. Some product classes, such as scripts, data, and headers,
    have no build, test, or execution semantics—only installation semantics.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*主要产品*就像产品类别，它们代表可能由构建系统生成的产品类型。一个主要产品定义了构建、测试、安装和执行特定类别产品所需的一组步骤。例如，程序和库使用不同的编译器和链接器命令来构建，Java类需要虚拟机来执行，而Python程序需要解释器。某些产品类别，如脚本、数据和头文件，没有构建、测试或执行语义——只有安装语义。'
- en: The list of supported primaries defines the set of product classes that can
    be built automatically by an Automake build system. Automake build systems can
    still build other product classes, but the maintainer must define the `make` rules
    explicitly within the project’s *Makefile.am* files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的主要产品列表定义了可以由Automake构建系统自动构建的产品类别集合。Automake构建系统仍然可以构建其他产品类别，但维护者必须在项目的*Makefile.am*文件中显式地定义`make`规则。
- en: A thorough understanding the Automake primaries is the key to properly using
    Automake. The current complete list of supported primaries is as follows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 彻底理解Automake的主要产品是正确使用Automake的关键。目前支持的主要产品的完整列表如下。
- en: PROGRAMS
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: PROGRAMS
- en: When the `PROGRAMS` primary is used in a PLV, Automake generates `make` rules
    that use compilers and linkers to build binary executable programs for the listed
    products.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当在PLV中使用`PROGRAMS`主要产品时，Automake会生成使用编译器和链接器来构建列出产品的二进制可执行程序的`make`规则。
- en: LIBRARIES/LTLIBRARIES
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: LIBRARIES/LTLIBRARIES
- en: 'The use of the `LIBRARIES` primary causes Automake to generate rules that build
    static archives (libraries) using the system compiler and librarian. The `LTLIBRARIES`
    primary does the same thing, but the generated rules also build Libtool shared
    libraries and execute these tools (as well as the linker) through the `libtool`
    script. (I’ll discuss the Libtool package in detail in [Chapters 7](ch07.xhtml)
    and [8](ch08.xhtml).) Automake restricts the installation locations for the `LIBRARIES`
    and `LTLIBRARIES` primaries: they can only be installed in `$(libdir)` and `$(pkglibdir)`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LIBRARIES` 主项会导致 Automake 生成规则，使用系统编译器和库管理器构建静态库（库文件）。`LTLIBRARIES` 主项做同样的事情，但生成的规则还会构建
    Libtool 共享库，并通过 `libtool` 脚本执行这些工具（以及链接器）。 （我将在[第 7 章](ch07.xhtml)和[第 8 章](ch08.xhtml)中详细讨论
    Libtool 包。) Automake 限制了 `LIBRARIES` 和 `LTLIBRARIES` 主项的安装位置：它们只能安装在 `$(libdir)`
    和 `$(pkglibdir)` 中。
- en: LISP
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: LISP
- en: The `LISP` primary was designed mainly to manage the build for Emacs Lisp programs.
    Hence, it expects to refer to a list of *.el* files. You can find details on the
    use of this primary in Section 10.1 of the Automake manual.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`LISP` 主项主要用于管理 Emacs Lisp 程序的构建。因此，它期望引用一个 *.el* 文件列表。您可以在 Automake 手册第 10.1
    节中找到有关使用该主项的详细信息。'
- en: PYTHON
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHON
- en: Python is an interpreted language; the `python` interpreter converts a Python
    script, line by line, into Python byte code, executing it as it’s converted, so
    (like shell scripts) Python source files are executable as written. The use of
    the `PYTHON` primary tells Automake to generate rules that precompile Python source
    files (*.py*) into standard (*.pyc*) and optimized (*.pyo*) byte-compiled versions
    using the `py-compile` utility. Because of the normally interpreted nature of
    Python sources, this compilation occurs at install time rather than at build time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种解释型语言；`python` 解释器逐行将 Python 脚本转换为 Python 字节码，并在转换的同时执行它，因此（像 shell
    脚本一样）Python 源文件可以直接执行。使用 `PYTHON` 主项告诉 Automake 生成规则，将 Python 源文件 (*.py*) 预编译为标准
    (*.pyc*) 和优化 (*.pyo*) 字节编译版本，使用 `py-compile` 工具进行编译。由于 Python 源代码通常是解释执行的，这种编译发生在安装时，而不是在构建时。
- en: JAVA
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: JAVA
- en: Java is a virtual machine platform; the use of the `JAVA` primary tells Automake
    to generate rules that convert Java source files (*.java*) into Java class files
    (*.class*) using the `javac` compiler. While this process is correct, it’s not
    complete. Java programs (of any consequence) generally contain more than one class
    file and are usually packaged as *.jar* or *.war* files, both of which may also
    contain several ancillary text files. The `JAVA` primary is useful, but only just.
    (I’ll discuss using—and extending—the `JAVA` primary in “Building Java Sources
    Using the Autotools” on [page 408](ch15.xhtml#page_408).)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一个虚拟机平台；使用 `JAVA` 主项会告诉 Automake 生成规则，使用 `javac` 编译器将 Java 源文件 (*.java*)
    转换为 Java 类文件 (*.class*)。虽然这个过程是正确的，但并不完整。Java 程序（有实际意义的程序）通常包含多个类文件，通常以 *.jar*
    或 *.war* 文件打包，这些文件可能还包含多个附带的文本文件。`JAVA` 主项是有用的，但仅此而已。（我将在《使用 Autotools 构建 Java
    源代码》一章中详细讨论如何使用——以及扩展——`JAVA` 主项，详情请见 [第 408 页](ch15.xhtml#page_408)。）
- en: SCRIPTS
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本
- en: '*Script*, in this context, refers to any interpreted text file—whether it’s
    shell, Perl, Python, Tcl/Tk, JavaScript, Ruby, PHP, Icon, Rexx, or some other.
    Automake allows a restricted set of installation locations for the `SCRIPTS` primary,
    including `$(bindir)`, `$(sbindir)`, `$(libexecdir)`, and `$(pkgdatadir)`. While
    Automake doesn’t generate rules to build scripts, it also doesn’t assume that
    a script is a static file in the project. Scripts are often generated by handwritten
    rules in *Makefile.am* files, sometimes by processing an input file with the `sed`
    or `awk` utility. For this reason, scripts are not distributed automatically.
    If you have a static script in your project that you’d like Automake to add to
    your distribution archive, you should prefix the `SCRIPTS` primary with the `dist`
    modifier as discussed in “PLV and PSV Modifiers” on [page 161](ch06.xhtml#page_161).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，*脚本* 指任何解释型文本文件——无论是 shell、Perl、Python、Tcl/Tk、JavaScript、Ruby、PHP、Icon、Rexx
    还是其他任何类型的文件。Automake 允许为 `SCRIPTS` 主项设置受限的安装位置，包括 `$(bindir)`、`$(sbindir)`、`$(libexecdir)`
    和 `$(pkgdatadir)`。虽然 Automake 不会生成构建脚本的规则，但它也不假设脚本是项目中的静态文件。脚本通常由 *Makefile.am*
    文件中的手写规则生成，有时通过使用 `sed` 或 `awk` 工具处理输入文件。因此，脚本不会自动分发。如果您项目中有一个静态脚本，并希望 Automake
    将其添加到您的分发归档中，则应像“PLV 和 PSV 修饰符”中所讨论的那样，在 `SCRIPTS` 主项前添加 `dist` 修饰符，详情请参见 [第 161
    页](ch06.xhtml#page_161)。
- en: DATA
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据
- en: Arbitrary data files can be installed using the `DATA` primary in a PLV. Automake
    allows a restricted set of installation locations for the `DATA` primary, including
    `$(datadir)`, `$(sysconfdir)`, `$(sharedstatedir)`, `$(localstatedir``)`, and
    `$(pkgdatadir)`. Data files are not automatically distributed, so if your project
    contains static data files, use the `dist` modifier on the `DATA` primary as discussed
    in “PLV and PSV Modifiers” on [page 161](ch06.xhtml#page_161).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任意数据文件可以通过 PLV 中的 `DATA` 主项进行安装。Automake 允许 `DATA` 主项的限制安装位置，包括 `$(datadir)`、`$(sysconfdir)`、`$(sharedstatedir)`、`$(localstatedir)`
    和 `$(pkgdatadir)`。数据文件不会自动分发，因此如果你的项目包含静态数据文件，请在 `DATA` 主项上使用 `dist` 修饰符，如在 [第
    161 页](ch06.xhtml#page_161)的《PLV 和 PSV 修饰符》中所讨论的那样。
- en: HEADERS
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: HEADERS
- en: Header files are a form of source file. Were it not for the fact that some header
    files are installed, they could simply be listed with the product sources. Header
    files containing the public interface for installed library products are installed
    into either the `$(includedir)` or a package-specific subdirectory defined by
    `$(pkgincludedir)`, so the most common PLVs for such installed headers are the
    `include_HEADERS` and `pkginclude_HEADERS` variables. Like other source files,
    header files are distributed automatically. If you have a generated header file,
    use the `nodist` modifier with the `HEADERS` primary as discussed in “PLV and
    PSV Modifiers” on [page 161](ch06.xhtml#page_161).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是一种源文件形式。如果不是因为某些头文件已经被安装，它们本可以直接列在产品源代码中。包含已安装库产品公共接口的头文件会被安装到 `$(includedir)`
    或由 `$(pkgincludedir)` 定义的包特定子目录中，因此此类已安装头文件的最常见 PLV 是 `include_HEADERS` 和 `pkginclude_HEADERS`
    变量。像其他源文件一样，头文件会自动分发。如果你有一个生成的头文件，请使用 `nodist` 修饰符与 `HEADERS` 主项一起使用，具体如在 [第 161
    页](ch06.xhtml#page_161)的《PLV 和 PSV 修饰符》中所讨论的那样。
- en: MANS
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MANS
- en: '*Man pages* are UTF-8 text files containing `troff` markup, which is rendered
    by `man` when viewed by a user. Man pages can be installed using the `man_MANS`
    or `man`*`N`*`_MANS` product list variables, where *`N`* represents a single-digit
    section number between 0 and 9 or the letters *l* (for math library topics) or
    *n* (for Tcl/Tk topics). Files in the `man_MANS` PLV should have a numeric extension
    indicating the man section to which they belong and, therefore, their target directory.
    Files in the `man`*`N`*`_MANS` PLV may be named with either numeric extensions
    or a *.man* extension and will be renamed to the associated numeric extensions
    when they’re installed by `make install`. Project man pages are not distributed
    by default because man pages are often generated, so you should use the `dist`
    modifier as discussed in “PLV and PSV Modifiers” on [page 161](ch06.xhtml#page_161).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*Man 页面* 是包含 `troff` 标记的 UTF-8 文本文件，用户查看时由 `man` 渲染。Man 页面可以通过 `man_MANS` 或
    `man`*`N`*`_MANS` 产品列表变量安装，其中 *`N`* 代表介于 0 到 9 之间的单数字节或字母 *l*（用于数学库主题）或 *n*（用于
    Tcl/Tk 主题）。`man_MANS` PLV 中的文件应具有表示其所属 man 部分的数字扩展名，从而指示其目标目录。`man`*`N`*`_MANS`
    PLV 中的文件可以使用数字扩展名或 *.man* 扩展名命名，并将在 `make install` 安装时重命名为相关的数字扩展名。项目的 man 页面默认不进行分发，因为
    man 页面通常是生成的，因此你应该使用 `dist` 修饰符，如在 [第 161 页](ch06.xhtml#page_161)的《PLV 和 PSV 修饰符》中所讨论的那样。'
- en: TEXINFOS
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: TEXINFOS
- en: When it comes to Linux or Unix documentation, Texinfo^([10](footnote.xhtml#ch06fn10))
    is the GNU project format of choice. The `makeinfo` utility accepts Texinfo source
    files (*.texinfo*, *.txi*, or *.texi*) and renders info files (*.info*) containing
    UTF-8 text annotated with Texinfo markup, which the `info` utility renders into
    formatted text for the user. The most common product list variable for use with
    Texinfo sources is `info_TEXINFOS`. The use of this PLV causes Automake to generate
    rules to build *.info*, *.dvi*, *.ps*, and *.html* documentation files. However,
    only the *.info* files are built with `make all` and installed with `make install`.
    In order to build and install the other types of files, you must specify the `dvi`,
    `ps`, `pdf`, `html`, `install-dvi`, `install-ps`, `install-pdf`, and `install-html`
    targets explicitly on the `make` command line. Since the `makeinfo` utility is
    not installed by default in many Linux distributions, the generated *.info* files
    are automatically added to distribution archives so your end users won’t have
    to go looking for `makeinfo`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或Unix文档中，Texinfo^([10](footnote.xhtml#ch06fn10))是GNU项目的首选格式。`makeinfo`工具接受Texinfo源文件（*.texinfo*、*.txi*或*.texi*），并渲染包含UTF-8文本的info文件（*.info*），这些文本用Texinfo标记注释，`info`工具将其渲染为格式化文本供用户使用。与Texinfo源一起使用的最常见的产品列表变量是`info_TEXINFOS`。使用此PLV会导致Automake生成构建*.info*、*.dvi*、*.ps*和*.html*文档文件的规则。然而，只有*.info*文件会在`make
    all`时构建，并通过`make install`安装。为了构建和安装其他类型的文件，必须在`make`命令行中明确指定`dvi`、`ps`、`pdf`、`html`、`install-dvi`、`install-ps`、`install-pdf`和`install-html`目标。由于许多Linux发行版默认未安装`makeinfo`工具，生成的*.info*文件会自动添加到分发归档中，以便最终用户不必去寻找`makeinfo`。
- en: '*Product Source Variables*'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*产品源变量*'
- en: 'The second line in [Listing 6-3](ch06.xhtml#ch06ex3) is an example of an Automake
    *product source variable* (*PSV*). PSVs conform to the following template:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-3](ch06.xhtml#ch06ex3)中的第二行是一个Automake *产品源变量*（*PSV*）的示例。PSV符合以下模板：'
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Like PLVs, PSVs are composed of multiple parts: the product name (`jupiter`
    in this case) and the `SOURCES` tag. The value of a PSV is a whitespace-separated
    list of source files from which *`product`* is built. The value of the PSV in
    the second line of [Listing 6-3](ch06.xhtml#ch06ex3) is the list of source files
    used to build the `jupiter` program. Ultimately, Automake adds these files to
    various `make` rule dependency lists and commands in the generated *Makefile.in*
    templates.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 和PLV一样，PSV由多个部分组成：产品名称（此处为`jupiter`）和`SOURCES`标签。PSV的值是一个由空格分隔的源文件列表，这些文件用于构建*`product`*。在[清单6-3](ch06.xhtml#ch06ex3)的第二行中，PSV的值是用于构建`jupiter`程序的源文件列表。最终，Automake将这些文件添加到生成的*Makefile.in*模板中的各种`make`规则依赖列表和命令中。
- en: Only characters that are allowed in `make` variables (letters, numbers, the
    at sign, and underscore) are allowed in the `product` tag of a PSV. As a result,
    Automake performs a transformation on product names listed in PLVs to render the
    *`product`* tags used in the associated PSVs. Automake converts illegal characters
    into underscores, as shown in [Listing 6-7](ch06.xhtml#ch06ex7).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`make`变量中允许的字符（字母、数字、@符号和下划线）才允许出现在PSV的`product`标签中。因此，Automake会对PLV中列出的产品名称进行转换，以呈现关联PSV中使用的*`product`*标签。Automake将非法字符转换为下划线，如[清单6-7](ch06.xhtml#ch06ex7)所示。
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-7: Illegal `make` variable characters are converted to underscores
    in `product` tags.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-7：非法的`make`变量字符在`product`标签中转换为下划线。*'
- en: Here, Automake converts *libc++.a* in the PLV at ➊ into the PSV `product` tag
    `libc___a` (that’s three underscores) to find the associated PSV at ➋ in the *Makefile.am*
    file. You must know the transformation rules so you can write PSVs that match
    your products.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Automake将PLV中的*libc++.a*（在➊处）转换为PSV的`product`标签`libc___a`（即三个下划线），以在*Makefile.am*文件中找到关联的PSV（在➋处）。你必须了解这些转换规则，以便能够编写与产品匹配的PSV。
- en: '*PLV and PSV Modifiers*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*PLV和PSV修饰符*'
- en: 'The `modifier-list` portions of the PLV and PSV templates defined previously
    contain a set of optional modifiers. The following BNF-like rule defines the format
    of the `modifier-list` element of these templates:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的PLV和PSV模板中的`modifier-list`部分包含一组可选的修饰符。以下类似BNF的规则定义了这些模板中`modifier-list`元素的格式：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Modifiers change the normal behavior of the variable to which they are prepended.
    The currently defined set of prefix modifiers includes `dist`, `nodist`, `nobase`,
    and `notrans`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符改变了它们前置的变量的正常行为。当前定义的前缀修饰符集包括`dist`、`nodist`、`nobase`和`notrans`。
- en: The `dist` modifier indicates a set of files that should be distributed (that
    is, that should be included in the distribution package that’s built when `make
    dist` is executed). For example, assuming that some source files for a product
    should be distributed and some should not, the variables shown in [Listing 6-8](ch06.xhtml#ch06ex8)
    might be defined in the product’s *Makefile.am* file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist` 修饰符表示一组应该分发的文件（即应该包含在通过执行 `make dist` 时生成的分发包中）。例如，假设某些产品的源文件应该被分发，而某些不应该被分发，[清单
    6-8](ch06.xhtml#ch06ex8) 中展示的变量可能在产品的 *Makefile.am* 文件中定义。'
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-8: Using the `dist` and `nodist` modifiers in a* Makefile.am *file*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-8：在 `Makefile.am` 文件中使用 `dist` 和 `nodist` 修饰符*'
- en: Automake normally strips relative path information from the list of header files
    in a `HEADERS` PLV. The `nobase` modifier is used to suppress the removal of path
    information from installed header files that are obtained from subdirectories
    by a *Makefile.am* file. For example, take a look at the PLV definition in [Listing
    6-9](ch06.xhtml#ch06ex9).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 通常会从 `HEADERS` PLV 中的头文件列表中去除相对路径信息。`nobase` 修饰符用于抑制从子目录中通过 *Makefile.am*
    文件获取的安装头文件路径信息的去除。例如，查看 [清单 6-9](ch06.xhtml#ch06ex9) 中的 PLV 定义。
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-9: Using the `nobase` PLV modifier in a* Makefile.am *file*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-9：在 `Makefile.am` 文件中使用 `nobase` PLV 修饰符*'
- en: In this line we can see that *mylib.h* is in the same directory as *Makefile.am*,
    but *constants.h* is located in a subdirectory called *sys*. Normally, both files
    would be installed into `$(pkgincludedir)` by virtue of the `pkginclude` installation
    location prefix. However, since we’re using the `nobase` modifier, Automake will
    retain the *sys/* portion of the second file’s path for installation, and *constants.h*
    will be installed into `$(pkgincludedir)`*/sys*. This is useful when you want
    the installation (destination) directory structure to be the same as the project
    (source) directory structure as files are copied during installation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们可以看到 *mylib.h* 与 *Makefile.am* 位于同一目录下，而 *constants.h* 位于名为 *sys* 的子目录中。通常，两个文件都会通过
    `pkginclude` 安装位置前缀安装到 `$(pkgincludedir)` 中。然而，由于我们使用了 `nobase` 修饰符，Automake 将保留第二个文件路径中的
    *sys/* 部分进行安装，*constants.h* 将被安装到 `$(pkgincludedir)`*/sys* 中。当你希望安装（目标）目录结构与项目（源代码）目录结构相同，并且文件在安装过程中被复制时，这非常有用。
- en: The `notrans` modifier may be used on man page PLVs for man pages whose names
    should not be transformed during installation. (Normally, Automake will generate
    rules to rename the extension on man pages from *.man* to *.N*—where *N* is *0*,
    *1*, . . . , *9*, *l*, *n*—as they’re installed.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`notrans` 修饰符可以用于 man 页面 PLV，针对那些在安装过程中不应被转换的 man 页面（通常，Automake 会生成规则，将 man
    页面扩展名从 *.man* 重命名为 *.N*，其中 *N* 为 *0*、*1*、...、*9*、*l*、*n*，当它们被安装时）。'
- en: You can also use the `EXTRA` prefix as a modifier. When used with a product
    source variable (such as `jupiter_SOURCES`), `EXTRA` specifies extra source files
    that are directly associated with the `jupiter` product, as shown in [Listing
    6-10](ch06.xhtml#ch06ex10).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `EXTRA` 前缀作为修饰符。当与产品源变量（例如 `jupiter_SOURCES`）一起使用时，`EXTRA` 指定与 `jupiter`
    产品直接关联的额外源文件，如 [清单 6-10](ch06.xhtml#ch06ex10) 中所示。
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-10: Using the `EXTRA` prefix with a product `SOURCES` variable*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：与产品 `SOURCES` 变量一起使用 `EXTRA` 前缀*'
- en: Here, *possibly.c* may or may not be compiled, based on some condition defined
    in *configure.ac*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*possibly.c* 是否被编译取决于在 *configure.ac* 中定义的一些条件。
- en: 'Unit Tests: Supporting make check'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试：支持 `make check`
- en: In [Chapter 3](ch03.xhtml), we added code to *src/Makefile* that executes the
    `jupiter` program and checks for the proper output string when the user makes
    the `check` target. We now have enough information to add our `check` target test
    back into our new Automake build system. I’ve duplicated the `check` target code
    in [Listing 6-11](ch06.xhtml#ch06ex11) for reference in the following discussion.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.xhtml)，我们向 *src/Makefile* 中添加了代码，执行 `jupiter` 程序并检查当用户执行 `check`
    目标时是否有正确的输出字符串。现在我们有足够的信息将我们的 `check` 目标测试重新添加到新的 Automake 构建系统中。我已经在 [清单 6-11](ch06.xhtml#ch06ex11)
    中复制了 `check` 目标代码，以供接下来的讨论参考。
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-11: The `check` target from [Chapter 3](ch03.xhtml)*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：来自 [第 3 章](ch03.xhtml) 的 `check` 目标*'
- en: Fortunately, Automake has solid support for unit tests. To add our simple `grep`
    test back into the new Automake-generated build system, we can add a few lines
    to the bottom of *src/Makefile.am*, as shown in [Listing 6-12](ch06.xhtml#ch06ex12).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Automake 对单元测试有很好的支持。为了将我们简单的 `grep` 测试重新添加到新的 Automake 生成的构建系统中，我们可以在
    *src/Makefile.am* 的底部添加几行，如 [Listing 6-12](ch06.xhtml#ch06ex12) 所示。
- en: Git tag 6.1
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 6.1
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-12:* src/Makefile.am: *Additional code required to support the `check`
    target*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-12:* src/Makefile.am: *支持 `check` 目标所需的额外代码*'
- en: The `check_SCRIPTS` line at ➊ is a PLV that refers to a script generated at
    build time. Since the prefix is `check`, we know that scripts listed in this line
    will only be built when the user enters `make check`. However, we must supply
    a `make` rule for building the script as well as a rule for removing the file
    later, during execution of the `clean` target. We use the `CLEANFILES` variable
    at ➌ to extend the list of files that Automake deletes during `make clean`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `check_SCRIPTS` 行是一个 PLV，它指向一个在构建时生成的脚本。由于前缀是 `check`，我们知道此行列出的脚本只有在用户输入
    `make check` 时才会被构建。然而，我们必须提供一个 `make` 规则来构建脚本，并在执行 `clean` 目标时删除该文件。我们在 ➌ 处使用
    `CLEANFILES` 变量，来扩展 Automake 在执行 `make clean` 时删除的文件列表。
- en: The `TESTS` line at ➋ is the important one in [Listing 6-12](ch06.xhtml#ch06ex12)
    because it indicates which targets are executed when the user makes the `check`
    target. (Since the `check_SCRIPTS` variable contains a complete list of these
    targets, I simply referenced it here, as the `make` variable that it actually
    is.) Note that in this particular case, `check_SCRIPTS` is redundant, because
    Automake generates rules to ensure that all the programs listed in `TESTS` are
    built before the tests are executed. However, `check_*` PLVs become important
    when additional helper scripts or programs must be built before those listed in
    `TESTS` are executed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 处的 `TESTS` 行是 [Listing 6-12](ch06.xhtml#ch06ex12) 中的重要部分，因为它指示在用户执行 `check`
    目标时会执行哪些目标。（由于 `check_SCRIPTS` 变量包含了这些目标的完整列表，我在这里简单引用了它，作为实际的 `make` 变量。）请注意，在这个特定的例子中，`check_SCRIPTS`
    是多余的，因为 Automake 会生成规则，确保在执行测试之前，所有在 `TESTS` 中列出的程序都已经构建完毕。然而，当需要在执行 `TESTS` 列表中的程序之前构建额外的帮助脚本或程序时，`check_*`
    PLV 就变得重要了。
- en: 'It’s not necessarily obvious here, but since we added our first test, we need
    to re-execute `autoreconf -i` before running `make check` in order to add a new
    utility script: *test-driver*. You can find places in the Automake documentation
    that indicate clearly that you must do this, but it’s simpler to just let the
    build tell you when something is missing and therefore an execution of `autoreconf
    (-i)` is required. To give you a flavor for this process, let’s try it without
    running `autoreconf` first:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能不是很明显，但由于我们添加了第一个测试，在运行 `make check` 之前，我们需要重新执行 `autoreconf -i` 以添加一个新的实用程序脚本：*test-driver*。你可以在
    Automake 文档中找到明确说明必须这样做的地方，但更简单的方法是让构建系统告诉你在缺少某些内容时，必须执行 `autoreconf (-i)`。为了让你感受一下这个过程，让我们先不运行
    `autoreconf` 来试试：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let’s run `autoreconf -i` first:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们先运行 `autoreconf -i`：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After running `autoreconf -i` (and noting that `test-driver` was installed into
    our project), we can see that `make check` is now successful.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `autoreconf -i` 后（并且注意到 `test-driver` 已经安装到我们的项目中），我们可以看到 `make check` 现在成功运行了。
- en: Note that I didn’t have to manually invoke `configure` after running `autoreconf
    -i`. The build system is generally smart enough to know when it should re-execute
    `configure` for you.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运行 `autoreconf -i` 后，我不需要手动调用 `configure`。构建系统通常足够智能，知道何时应该为你重新执行 `configure`。
- en: Reducing Complexity with Convenience Libraries
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用便捷库减少复杂性
- en: Jupiter is fairly trivial as open source software projects go, so in order to
    highlight some more of Automake’s key features, let’s expand it a little. We’ll
    first add a convenience library and then modify `jupiter` to consume this library.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter 作为开源软件项目来说相当简单，因此为了突出 Automake 的一些关键特性，我们将稍微扩展它。我们将首先添加一个便捷库，然后修改 `jupiter`
    来使用这个库。
- en: 'A *convenience library* is a static library that’s only used within the containing
    project. Such temporary libraries are generally used when multiple binaries in
    a project need to incorporate the same source code. I’ll move the code in *main.c*
    to a library source file and call the function in the library from `jupiter`’s
    `main` routine. Begin by executing the following commands from the top-level project
    directory:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*便利库*是一个静态库，仅在包含它的项目中使用。这种临时库通常用于当一个项目中的多个二进制文件需要集成相同的源代码时。我将把*main.c*中的代码移动到一个库源文件，并从`jupiter`的`main`例程中调用这个库中的函数。首先，从项目的顶级目录执行以下命令：'
- en: Git tag 6.2
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 6.2
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now add the highlighted text from [Listings 6-13](ch06.xhtml#ch06ex13) and [6-14](ch06.xhtml#ch06ex14)
    to the *.h* and *.c* files, respectively, in the new *common* directory.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将[列表 6-13](ch06.xhtml#ch06ex13)和[6-14](ch06.xhtml#ch06ex14)中的高亮文本分别添加到新建的*common*目录中的*.h*和*.c*文件中。
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-13:* common/jupcommon.h: *The initial version of this file*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-13:* common/jupcommon.h: *这个文件的初始版本*'
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-14:* common/print.c: *The initial version of this file*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-14:* common/print.c: *这个文件的初始版本*'
- en: As you can see, *print.c* is merely a copy of *main.c*, with a few small modifications
    (highlighted in [Listing 6-14](ch06.xhtml#ch06ex14)). First, I renamed `main`
    to `print_routine`, and then I added the inclusion of the *jupcommon.h* header
    file after the inclusion of *config.h*. The header file provides `print_routine`’s
    prototype to *src/main.c*, where it’s called from `main`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*print.c*仅仅是*main.c*的一个副本，经过了几个小的修改（在[列表 6-14](ch06.xhtml#ch06ex14)中高亮显示）。首先，我将`main`重命名为`print_routine`，然后在包含*config.h*之后添加了对*jupcommon.h*头文件的包含。这个头文件将`print_routine`的原型提供给*src/main.c*，在那里它从`main`中被调用。
- en: Next, we modify *src/main.c*, as shown in [Listing 6-15](ch06.xhtml#ch06ex15),
    and then add the text in [Listing 6-16](ch06.xhtml#ch06ex16) to *common/Makefile.am*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按[列表 6-15](ch06.xhtml#ch06ex15)所示修改*src/main.c*，然后将[列表 6-16](ch06.xhtml#ch06ex16)中的文本添加到*common/Makefile.am*中。
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-15:* src/main.c: *Required modifications to have `main` call into
    the new library*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-15:* src/main.c: *修改以让`main`调用新库*'
- en: '**NOTE**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It may seem odd to include* config.h *at the top of* src/main.c *since nothing
    in that source file appears to use it. The* GCS *recommends following the standard
    practice of including* config.h *at the top of all source files, before any other
    inclusions, in case something in one of the other included header files makes
    use of definitions in* config.h. *I recommend religiously following this practice*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*将* config.h *包含在* src/main.c *的顶部可能显得有些奇怪，因为在那个源文件中似乎没有什么地方使用它。*GCS*建议遵循标准做法，将*config.h*包含在所有源文件的顶部，所有其他包含语句之前，以防其他包含的头文件中的某些内容使用了*config.h*中的定义。*我建议严格遵循这个做法*。'
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 6-16:* common/Makefile.am: *Initial version of this file*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-16:* common/Makefile.am: *这个文件的初始版本*'
- en: Let’s examine this new *Makefile.am* file. The first line indicates which products
    this file should build and install. The `noinst` prefix indicates that this library
    is designed solely to make using the source code in the *common* directory more
    convenient.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个新的*Makefile.am*文件。第一行指示了这个文件应该构建和安装哪些产品。`noinst`前缀表示这个库仅仅是为了方便在*common*目录中使用源代码。
- en: We’re creating a static library called *libjupcommon.a*, also known as an *archive*.
    Archives are like *.tar* files that only contain object files (*.o*). They can’t
    be executed or loaded into a process address space like shared libraries, but
    they can be added to a linker command line like object files. Linkers are smart
    enough to realize that such archives are merely groups of object files.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为*libjupcommon.a*的静态库，也叫做*归档*。归档类似于*.tar*文件，只包含目标文件（*.o*）。它们不能像共享库那样被执行或加载到进程地址空间中，但可以像目标文件一样被添加到链接命令行中。链接器足够聪明，能够识别出这些归档只是目标文件的集合。
- en: '**NOTE**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Linkers add to the binary product every object file specified explicitly on
    the command line, but they only extract from archives those object files that
    are actually referenced in the code being linked. Therefore, if you link to a
    static library containing 97 object files, but you only call functions in two
    of them directly or indirectly, only those two object files are added to your
    program. In contrast, linking to 97 raw object files adds all 97 of those files
    to your program, regardless of whether you use any of their functionality*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*链接器会将命令行中显式指定的每个目标文件添加到二进制产物中，但它们只从库中提取实际在链接的代码中引用的目标文件。因此，如果你链接到一个包含97个目标文件的静态库，但你只直接或间接调用其中两个文件的函数，那么只有这两个目标文件会被添加到你的程序中。相反，链接到97个原始目标文件则会将所有97个文件添加到你的程序中，无论你是否使用其中的任何功能*。'
- en: The second line in [Listing 6-16](ch06.xhtml#ch06ex16) is a product source variable
    that contains the list of source files associated with this library.^([11](footnote.xhtml#ch06fn11))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6-16](ch06.xhtml#ch06ex16)中的第二行是一个产品源变量，包含与该库关联的源文件列表。^([11](footnote.xhtml#ch06fn11))'
- en: '*Product Option Variables*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*产品选项变量*'
- en: Now we need to add some additional information to *src/Makefile.am* so that
    the generated *Makefile* can find the new library and header file we added to
    the *common* directory. Let’s add two more lines to the existing *Makefile.am*
    file, as shown in [Listing 6-17](ch06.xhtml#ch06ex17).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向*src/Makefile.am*中添加一些额外的信息，以便生成的*Makefile*能够找到我们添加到*common*目录中的新库和头文件。让我们向现有的*Makefile.am*文件中再添加两行，如[列表6-17](ch06.xhtml#ch06ex17)所示。
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-17:* src/Makefile.am: *Adding compiler and linker directives to*
    Makefile.am *files*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-17：* src/Makefile.am：*向* Makefile.am *文件中添加编译器和链接器指令*'
- en: Like the `jupiter_SOURCES` variable, these two new variables are derived from
    the program name. These *product option variables (POVs)* are used to specify
    product-specific options to tools that are used to build products from source
    code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 像`jupiter_SOURCES`变量一样，这两个新变量是从程序名称派生的。这些*产品选项变量（POVs）*用于指定构建工具所使用的与产品相关的选项，这些工具从源代码构建产品。
- en: The `jupiter_CPPFLAGS` variable at ➊ adds product-specific C-preprocessor flags
    to the compiler command line for all source files that are compiled for the `jupiter`
    program. The `-I$(top_srcdir)/common` directive tells the C preprocessor to add
    `$(top_srcdir)`*/common* to its list of locations in which to look for header
    file references.^([12](footnote.xhtml#ch06fn12))
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`jupiter_CPPFLAGS`变量在➊处将产品特定的C预处理器标志添加到`jupiter`程序的所有源文件的编译器命令行中。`-I$(top_srcdir)/common`指令告诉C预处理器将`$(top_srcdir)`*/common*添加到其查找头文件引用的位置列表中。^([12](footnote.xhtml#ch06fn12))'
- en: The `jupiter_LDADD` variable at ➋ adds libraries to the `jupiter` program’s
    linker command line. The file path *../common/libjupcommon.a* merely adds an object
    to the linker command line so that code in this library can become part of the
    final program.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`jupiter_LDADD`变量在➋处将库添加到`jupiter`程序的链接器命令行中。文件路径*../common/libjupcommon.a*仅仅是将一个目标文件添加到链接器命令行，以便该库中的代码能够成为最终程序的一部分。'
- en: '**NOTE**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also use *`$(top_builddir)`*/ in place of ../ to reference the location
    of the* common *directory in this path. Using *`$(top_builddir)`* has the added
    advantage of making it simpler to move this* Makefile.am *file to another location
    without having to modify it*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还可以使用*`$(top_builddir)`*代替../来引用此路径中*common*目录的位置。使用*`$(top_builddir)`*的附加优势在于，它使得将这个*Makefile.am*文件移动到另一个位置时无需修改它变得更加简单*。'
- en: Adding a library to a *`program`*`_LDADD` or *`library`*`_LIBADD` variable is
    only necessary for libraries that are built as part of your own package. If you’re
    linking your program with a library that’s already installed on the user’s system,
    a call to `AC_CHECK_LIB` or `AC_SEARCH_LIBS` in *configure.ac* will cause the
    generated `configure` script to add an appropriate reference to the linker command
    line via the `LIBS` variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 向*`program`*`_LDADD`或*`library`*`_LIBADD`变量中添加一个库仅在该库作为你自己包的一部分构建时才需要。如果你正在将程序与已经安装在用户系统上的库进行链接，则在*configure.ac*中调用`AC_CHECK_LIB`或`AC_SEARCH_LIBS`将使生成的`configure`脚本通过`LIBS`变量将适当的引用添加到链接器命令行中。
- en: The set of POVs supported by Automake are derived mostly from a subset of the
    standard user variables listed in [Table 3-2](ch03.xhtml#ch03tab2) on [page 71](ch03.xhtml#page_71).
    You’ll find a complete list of program and library option variables in the *GNU
    Autoconf Manual*, but here are some of the important ones.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 支持的 POV 集合主要来源于 [Table 3-2](ch03.xhtml#ch03tab2) 中列出的标准用户变量的子集，见 [第71页](ch03.xhtml#page_71)。你可以在
    *GNU Autoconf Manual* 中找到程序和库选项变量的完整列表，但这里列出了一些重要的变量。
- en: product_CPPFLAGS
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: product_CPPFLAGS
- en: Use *`product`*`_CPPFLAGS` to pass flags to the C or C++ preprocessor on the
    compiler command line.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`product`*`_CPPFLAGS` 将标志传递给 C 或 C++ 预处理器，添加到编译器命令行中。
- en: product_CFLAGS
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: product_CFLAGS
- en: Use *`product`*`_CFLAGS` to pass C-compiler flags on the compiler command line.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`product`*`_CFLAGS` 将 C 编译器标志传递到编译器命令行中。
- en: product_CXXFLAGS
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: product_CXXFLAGS
- en: Use *`product`*`_CXXFLAGS` to pass C++-compiler flags on the compiler command
    line.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`product`*`_CXXFLAGS` 将 C++ 编译器标志传递到编译器命令行中。
- en: product_LDFLAGS
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: product_LDFLAGS
- en: Use *`product`*`_LDFLAGS` to pass global and order-independent shared library
    and program linker configuration flags and options to the linker, including `-static`,
    `-version-info`, `-release`, and so on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`product`*`_LDFLAGS` 将全局和与顺序无关的共享库与程序链接器配置标志和选项传递给链接器，包括 `-static`、`-version-info`、`-release`
    等。
- en: program_LDADD
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: program_LDADD
- en: Use *`program`*`_LDADD` to add Libtool objects (*.lo*) or libraries (*.la*)
    or non-Libtool objects (*.o*) or archives (*.a*) to the linker command line when
    linking a program.^([13](footnote.xhtml#ch06fn13))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`program`*`_LDADD` 将 Libtool 对象（*.lo*）或库（*.la*）或非 Libtool 对象（*.o*）或档案（*.a*）添加到链接命令行中，进行程序链接。^([13](footnote.xhtml#ch06fn13))
- en: library_LIBADD
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: library_LIBADD
- en: Use *`library`*`_LIBADD` to add non-Libtool linker objects and archives to non-Libtool
    archives on the `ar` utility command line. The `ar` utility will incorporate archives
    mentioned on the command line into the product archive, so you can use this variable
    to gather multiple archives together into one.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`library`*`_LIBADD` 将非 Libtool 链接器对象和档案添加到非 Libtool 档案的 `ar` 工具命令行中。`ar`
    工具将把命令行中提到的档案并入产品档案，因此你可以使用此变量将多个档案合并成一个。
- en: ltlibrary_LIBADD
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ltlibrary_LIBADD
- en: Use *`ltlibrary`*`_LIBADD` to add Libtool linker objects (*.lo*) and Libtool
    static or shared libraries (*.la*) to a Libtool static or shared library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *`ltlibrary`*`_LIBADD` 将 Libtool 链接器对象（*.lo*）和 Libtool 静态或共享库（*.la*）添加到 Libtool
    静态或共享库中。
- en: 'You can use the last three option variables in this list to pass lists of order-dependent
    static and shared library references to the linker. You can also use these option
    variables to pass `-L` and `-l` options. The following are acceptable formats:
    `-L`*`libpath`*, `-l`*`libname`*, `[`*`relpath`*`/]`*`archive`*`.a`, `[`*`relpath`*`/]`*`objfile`*`.$(OBJEXT)`,
    `[`*`relpath`*`/]`*`ltobject`*`.lo` , and `[`*`relpath`*`/]`*`ltarchive`*`.la`.
    (Note that the term *`relpath`* indicates a relative path within the project,
    which can be in terms of either relative directory references, using dots, or
    `$(top_builddir)`.)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此列表中的最后三个选项变量，将依赖顺序的静态和共享库引用传递给链接器。你也可以使用这些选项变量来传递 `-L` 和 `-l` 选项。以下是可接受的格式：`-L`*`libpath`*，`-l`*`libname`*，`[`*`relpath`*`/]`*`archive`*`.a`，`[`*`relpath`*`/]`*`objfile`*`.$(OBJEXT)`，`[`*`relpath`*`/]`*`ltobject`*`.lo`，以及
    `[`*`relpath`*`/]`*`ltarchive`*`.la`。（请注意，术语 *`relpath`* 表示项目中的相对路径，可以是相对目录引用，使用点，或
    `$(top_builddir)`。）
- en: '*Per-Makefile Option Variables*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*每个 Makefile 的选项变量*'
- en: You’ll often see the Automake variables `AM_CPPFLAGS` and `AM_LDFLAGS` used
    in a *Makefile.am* file. These per-makefile forms of these flags are used when
    the maintainer wants to apply the same set of flags to all products specified
    in the *Makefile.am* file.^([14](footnote.xhtml#ch06fn14)) For example, if you
    need to set a group of preprocessor flags for all products in a *Makefile.am*
    file and then add additional flags for a particular product (`prog1`), you could
    use the statements shown in [Listing 6-18](ch06.xhtml#ch06ex18).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会看到 Automake 变量 `AM_CPPFLAGS` 和 `AM_LDFLAGS` 被用在 *Makefile.am* 文件中。这些每个 Makefile
    的形式用于当维护者想要将相同的标志集应用于 *Makefile.am* 文件中所有指定的产品时。^([14](footnote.xhtml#ch06fn14))
    例如，如果你需要为 *Makefile.am* 文件中的所有产品设置一组预处理器标志，然后为特定产品（`prog1`）添加额外的标志，你可以使用 [Listing
    6-18](ch06.xhtml#ch06ex18) 中展示的语句。
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 6-18: Using both per-product and per-file flags*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-18: 同时使用每个产品和每个文件的标志*'
- en: The existence of a per-product variable overrides Automake’s use of the per-makefile
    variable, so you need to reference the per-makefile variable in the per-product
    variable in order to have the per-makefile variable affect that product, as shown
    in [Listing 6-18](ch06.xhtml#ch06ex18) at ➊. In order to allow per-product variables
    to override their per-makefile counterparts, it’s a good idea to reference the
    per-makefile variable first, before adding any product-specific options.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品变量的存在会覆盖 Automake 对每个 makefile 变量的使用，因此您需要在每个产品变量中引用每个 makefile 变量，以便让 makefile
    变量影响该产品，如[清单 6-18](ch06.xhtml#ch06ex18)中的 ➊ 所示。为了允许每个产品变量覆盖它们对应的 makefile 变量，最好首先引用
    makefile 变量，然后再添加任何特定于产品的选项。
- en: '**NOTE**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*User variables, such as *`CFLAGS`*, are reserved for the end user and should
    never be set by configuration scripts or makefiles. Automake will always append
    them to the appropriate utility command lines, thus allowing the user to override
    the options specified in the makefile*.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户变量，例如*`CFLAGS`*，是为最终用户保留的，配置脚本或 makefile 不应设置这些变量。Automake 会始终将它们附加到适当的工具命令行，从而允许用户覆盖
    makefile 中指定的选项*。'
- en: Building the New Library
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建新库
- en: Next, we need to edit the `SUBDIRS` variable in the top-level *Makefile.am*
    file in order to include the new *common* directory we just added. We also need
    to add the new makefile that was generated in the *common* directory to the list
    of files generated from templates in the `AC_CONFIG_FILES` macro invocation in
    *configure.ac*. These changes are shown in [Listings 6-19](ch06.xhtml#ch06ex19)
    and [6-20](ch06.xhtml#ch06ex20).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编辑顶级 *Makefile.am* 文件中的 `SUBDIRS` 变量，以包括我们刚刚添加的新的 *common* 目录。我们还需要将
    *common* 目录中生成的新 makefile 添加到 *configure.ac* 中 `AC_CONFIG_FILES` 宏调用生成的文件列表中。这些更改如[清单
    6-19](ch06.xhtml#ch06ex19)和[清单 6-20](ch06.xhtml#ch06ex20)所示。
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-19:* Makefile.am: *Adding the common directory to the `SUBDIRS`
    variable*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-19:* Makefile.am: *将公共目录添加到 `SUBDIRS` 变量*'
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-20:* configure.ac: *Adding* common/Makefile *to the `AC_CONFIG_FILES`
    macro*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-20:* configure.ac: *将* common/Makefile *添加到 `AC_CONFIG_FILES` 宏*'
- en: This is the largest set of changes we’ve made up to this point, but we’re reorganizing
    the entire application, so it seems reasonable. Let’s give our updated build system
    a try. Add the `-i` option to the `autoreconf` command line so that it will install
    any additional missing files that might be required after these enhancements.
    After so many changes, I like to start with a clean slate, so start with `make
    distclean`, or some form of the `git clean` command if you’re running from a git
    repository work area.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们到目前为止所做的最大一组更改，但我们正在重新组织整个应用程序，因此这是合理的。让我们尝试一下更新后的构建系统。将 `-i` 选项添加到 `autoreconf`
    命令行中，以便在这些增强之后安装可能需要的任何额外缺失文件。经过这么多更改后，我喜欢从一个干净的环境开始，因此可以先执行 `make distclean`，或者如果你是从
    Git 仓库的工作区运行，则使用某种形式的 `git clean` 命令。
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Well, it looks like we’re not quite done yet. Since we’ve added a new type of
    entity—static libraries—to our build system, `automake` (via `autoreconf`) tells
    us at ➊ that we need to add a new macro, `AC_PROG_RANLIB`, to the *configure.ac*
    file.^([15](footnote.xhtml#ch06fn15))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们还没有完全完成。由于我们向构建系统中添加了一种新的实体——静态库，`automake`（通过 `autoreconf`）在 ➊ 告诉我们，我们需要向
    *configure.ac* 文件中添加一个新的宏 `AC_PROG_RANLIB`。^([15](footnote.xhtml#ch06fn15))
- en: Add this macro to *configure.ac*, as shown in [Listing 6-21](ch06.xhtml#ch06ex21).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 6-21](ch06.xhtml#ch06ex21)所示，将此宏添加到 *configure.ac* 文件中。
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 6-21:* configure.ac: *Adding `AC_PROG_RANLIB`*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-21:* configure.ac: *添加 `AC_PROG_RANLIB`*'
- en: Finally, enter `autoreconf -i` once more. Adding `-i` ensures that, if the new
    functionality we added to *configure.ac* requires any additional files to be installed,
    `autoreconf` will do so.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次输入 `autoreconf -i`。添加 `-i` 确保如果我们在 *configure.ac* 中添加的新功能需要安装任何额外的文件，`autoreconf`
    会执行安装。
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: No more complaints; all is well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多的抱怨；一切顺利。
- en: What Goes into a Distribution?
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么应该包含在发布包中？
- en: Automake usually determines automatically what should go into a distribution
    created with `make dist`, because it’s very aware of every file’s role in the
    build process. To this end, Automake wants to be told about every source file
    used to build a product and about every file and product installed. This means,
    of course, that all files must be specified at some point in one or more PLV and
    PSV variables.^([16](footnote.xhtml#ch06fn16))
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 通常会自动确定在使用`make dist`创建的分发包中应该包含哪些文件，因为它非常清楚每个文件在构建过程中的作用。为此，Automake
    需要知道每个用于构建产品的源文件以及每个安装的文件和产品。这意味着，当然，所有文件必须在某个时刻通过一个或多个 PLV 和 PSV 变量来指定。^([16](footnote.xhtml#ch06fn16))
- en: 'The Automake `EXTRA_DIST` variable contains a space-delimited list of files
    and directories that should be added to the distribution package when the `dist`
    target is made. For example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 的 `EXTRA_DIST` 变量包含一个以空格分隔的文件和目录列表，这些文件和目录应当在执行 `dist` 目标时添加到分发包中。例如：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You could use the `EXTRA_DIST` variable to add a source directory to the distribution
    package that Automake would not automatically add—for example, a Windows-specific
    directory.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `EXTRA_DIST` 变量将一个源代码目录添加到分发包中，而 Automake 并不会自动添加它——例如，一个特定于 Windows 的目录。
- en: '**NOTE**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case*, windows *is a directory, not a file. Automake will automatically
    recursively add every file in this directory to the distribution package; this
    may include some files that you really didn’t want there, such as hidden* .svn
    *or* .CVS *status directories. See “Automake -hook and -local Rules” on [page
    389](ch14.xhtml#page_389) for a way around this problem.*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下*，windows *是一个目录，而不是文件。Automake 会自动递归地将该目录中的每个文件添加到分发包中；这可能包括一些你其实并不想要的文件，比如隐藏的*
    .svn *或* .CVS *状态目录。请参阅 [第389页](ch14.xhtml#page_389)上的“Automake -hook 和 -local
    规则”，了解如何解决这个问题。*'
- en: A WORD ABOUT THE UTILITY SCRIPTS
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实用工具脚本
- en: 'The Autotools have added several files to the root of our project directory
    structure: `compile`, `depcomp`, `install-sh`, and `missing`. Because `configure`
    or the generated *Makefile*s all execute these scripts at various points during
    the build process, the end user will need them; however, we can only get them
    from the Autotools, and we don’t want to require the user to have the Autotools
    installed. For this reason, these scripts are automatically added to the distribution
    archive.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 已经在我们的项目目录结构根目录下添加了几个文件：`compile`、`depcomp`、`install-sh` 和 `missing`。因为
    `configure` 或生成的 *Makefile* 会在构建过程中不同的阶段执行这些脚本，最终用户将需要它们；然而，我们只能从 Autotools 获取这些脚本，我们不希望用户必须安装
    Autotools。因此，这些脚本会自动添加到分发包中。
- en: So, do you check them in to your source code repository or not? The answer is
    debatable, but generally I recommend that you don’t. Any maintainer who will be
    creating a distribution archive should have the Autotools installed and should
    be working from a repository work area. As a result, these maintainers will also
    be running `autoreconf -i` (possibly in conjunction with the `--force` option[*](#ch06sfn1))
    to ensure that they have the most up-to-date Autotools-provided utility scripts.
    If you check them in, it will only make it more probable that they become out-of-date
    as time goes by. It will also cause unnecessary churn in your repository revision
    history as contributors ping-pong back and forth between files generated from
    the different versions of the Autotools they’re using.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你是否应该将它们提交到源代码仓库中呢？这个问题的答案是有争议的，但通常我推荐你不要这样做。任何需要创建分发包的维护者应该已经安装了 Autotools，并且应该从一个仓库工作区中进行工作。因此，这些维护者也会运行
    `autoreconf -i`（可能与 `--force` 选项[*](#ch06sfn1)）一起使用，以确保他们拥有最新的 Autotools 提供的实用工具脚本。如果你将它们提交到仓库中，这只会增加它们随着时间推移变得过时的可能性。它还会导致你的仓库修订历史中出现不必要的波动，因为贡献者在使用不同版本的
    Autotools 生成的文件之间反复切换。
- en: I extend this sentiment to the `configure` script as well. Some people argue
    that checking the utility and `configure` scripts into the project repository
    is beneficial, because it ensures that if someone checked out a work area, they
    could build the project from the work area without having the Autotools installed.
    However, my personal philosophy is that developers and maintainers should be expected
    to have these tools installed. Occasionally, an end user will need to build a
    project from a work area, but this should be the exception rather than the typical
    case, and in these exceptional cases, the user should be willing to take on the
    role and requirements of a maintainer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我也将这种观点扩展到`configure`脚本。有些人认为将工具和`configure`脚本检查到项目代码库中是有益的，因为这可以确保如果有人从工作区检出了项目，他们可以从工作区构建项目，而无需安装Autotools。然而，我个人的观点是，开发者和维护者应该预期安装这些工具。偶尔，最终用户可能需要从工作区构建项目，但这应该是例外情况，而不是典型的情况，在这些特殊情况下，用户应愿意承担维护者的角色和要求。
- en: '[*](#ch06sfn_1) Use the `--force` option with caution; it will also overwrite
    text files such as *INSTALL*, which may have been modified for the project from
    the default text file that ships with the Autotools.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](#ch06sfn_1) 小心使用`--force`选项；它也会覆盖文本文件，如*INSTALL*，这些文件可能已根据项目修改，且与Autotools随附的默认文本文件不同。'
- en: Maintainer Mode
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护者模式
- en: Occasionally, timestamps on distribution source files will be newer than the
    current time setting of a user’s system clock. Regardless of the cause, this inconsistency
    confuses `make`, causing it to think that every source file is out-of-date and
    needs to be rebuilt. As a result, it will re-execute the Autotools in an attempt
    to bring `configure` and the *Makefile.in* templates up-to-date. But as maintainers,
    we don’t really expect our users to have the Autotools installed—or at least not
    the latest versions that we’ve installed on our systems.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，分发源文件的时间戳会比用户系统时钟的当前时间更晚。无论原因如何，这种不一致性会使`make`感到困惑，导致它认为每个源文件都过时了，需要重新构建。因此，它会重新执行Autotools，以尝试更新`configure`和*Makefile.in*模板。但是作为维护者，我们并不真正期望我们的用户安装Autotools——或者至少没有安装我们系统中最新版本的Autotools。
- en: This is where Automake’s *maintainer mode* comes in. By default, Automake adds
    rules to makefiles that regenerate template files, configuration scripts, and
    generated sources from maintainer source files such as *Makefile.am* and *configure.ac*,
    as well as Lex and Yacc input files. However, we can use the Automake `AM_MAINTAINER_MODE`
    macro in *configure.ac* to disable the default generation of these maintainer-level
    `make` rules.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Automake的*维护者模式*的作用。默认情况下，Automake会在makefile中添加规则，重新生成模板文件、配置脚本和从维护者源文件（如*Makefile.am*和*configure.ac*）以及Lex和Yacc输入文件生成的源文件。然而，我们可以在*configure.ac*中使用Automake的`AM_MAINTAINER_MODE`宏来禁用这些维护者级别的`make`规则的默认生成。
- en: For maintainers who want these rules in place to keep their build system properly
    updated after build system changes, the `AM_MAINTAINER_MODE` macro provides a
    `configure` script command line option (`--enable-maintainer-mode`), which tells
    `configure` to generate *Makefile.in* templates that contain rules and commands
    to execute the Autotools as necessary.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望这些规则在构建系统发生变化后保持其构建系统适当更新的维护者，`AM_MAINTAINER_MODE`宏提供了一个`configure`脚本命令行选项（`--enable-maintainer-mode`），它告诉`configure`生成包含必要规则和命令以执行Autotools的*Makefile.in*模板。
- en: Maintainers must be aware of the use of `AM_MAINTAINER_MODE` in their projects.
    They will need to use this command line option when running `configure` in order
    to generate full build systems that will properly rebuild Autotools-generated
    files when their sources are modified.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 维护者必须意识到在他们的项目中使用`AM_MAINTAINER_MODE`。在运行`configure`时，他们需要使用这个命令行选项，以生成完整的构建系统，这样当源代码被修改时，能够正确地重建由Autotools生成的文件。
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I also recommend mentioning the use of maintainer mode in the project* INSTALL
    *or* README *files so that end users are not surprised when they modify Autotools
    sources without effect.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*我还建议在项目的*INSTALL*或*README*文件中提及使用维护者模式，以便最终用户在修改Autotools源文件时不会感到意外，且这些修改没有效果。*'
- en: Although Automake’s maintainer mode has its advantages, you should know that
    there are various arguments against using it. Most focus on the idea that `make`
    rules should never be purposely restricted, because doing so generates a build
    system that will always fail under certain circumstances. I will, however, state
    that later versions of the Autotools do a much better job of telling you what’s
    happening when a required tool is missing. In fact, this is exactly what the `missing`
    script is for. Most tool invocations are wrapped in the `missing` script, which
    tells you fairly clearly what’s missing and how to install it when it is missing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Automake 的维护者模式有其优势，但你应该知道，也有各种反对使用它的观点。大多数观点集中在 `make` 规则不应被故意限制的想法上，因为这样做会生成一个在某些情况下总是失败的构建系统。不过，我要声明的是，后来的
    Autotools 版本在告知你缺少所需工具时做得要好得多。事实上，这正是 `missing` 脚本的作用。大多数工具调用都被封装在 `missing` 脚本中，脚本会相当清晰地告诉你缺少什么，以及如何安装它。
- en: Another important consideration when using this macro is that you’ve now doubled
    the rows in your test matrix, as every build option has two modes—one that assumes
    the Autotools are installed and one that assumes the opposite. If you decide to
    use the macro to disable maintainer mode by default for your end users, keep these
    points in mind.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个宏时的另一个重要考虑因素是，你现在已经将测试矩阵中的行数翻倍了，因为每个构建选项都有两种模式——一种假设 Autotools 已经安装，另一种假设没有安装。如果你决定使用该宏默认禁用维护者模式以供最终用户使用，请牢记这些要点。
- en: Cutting Through the Noise
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打破噪音
- en: The amount of noise generated by Autotools-based build systems has been one
    of the most controversial topics on the Automake mailing list. One camp appreciates
    quiet builds that just display important information, such as warnings and errors.
    The other side argues that valuable information is often embedded in this so-called
    “noise,” so all of it is important and should be displayed. Occasionally, a new
    Autotools developer will post a question about how to reduce the amount of information
    displayed by `make`. This almost always spawns a heated debate that lasts for
    several days over a few dozen email messages. The old-timers just laugh about
    it and often joke about how “someone has turned on the switch again.”
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Autotools 的构建系统产生的噪音量一直是 Automake 邮件列表上最具争议的话题之一。一方喜欢安静的构建，只显示重要的信息，如警告和错误。另一方则认为有价值的信息通常嵌入在所谓的“噪音”中，因此所有信息都很重要，应该显示出来。偶尔，新的
    Autotools 开发者会发帖询问如何减少 `make` 显示的信息量。这几乎总会引发一场激烈的辩论，持续好几天，几乎上百封邮件。老手们只是笑笑，常开玩笑说“有人又把开关打开了”。
- en: The truth of the matter is that both sides have valid points. The GNU project
    is all about options, so the Automake maintainers have added the ability to allow
    you to optionally make silent rules available to your users. *Silent rules* in
    Automake makefiles are not really silent; they’re just somewhat less noisy than
    traditional Automake-generated rules.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 事情的真相是，双方都有其合理的观点。GNU 项目本身就是关于选项的，因此 Automake 的维护者们增加了一个功能，允许你可选地将静默规则提供给用户。**静默规则**在
    Automake 的 makefile 中并不是真正的静默，它们只是比传统的 Automake 生成的规则稍微安静一些。
- en: 'Instead of displaying the entire compiler or linker command line, silent rules
    display a short line indicating the tool and the name of the file being processed
    by that tool. Output generated by `make` is still displayed so the user knows
    which directory and target are currently being processed. Here is Jupiter’s build
    output, with silent rules enabled (execute `make clean` first to ensure something
    actually gets built):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 静默规则不会显示整个编译器或链接器的命令行，而是显示一行简短的信息，指示正在处理该工具的工具和文件名。`make` 生成的输出仍然会显示，用户可以知道当前正在处理哪个目录和目标。这是启用了静默规则后的
    Jupiter 构建输出（首先执行 `make clean` 确保有东西被构建）：
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the use of silent rules doesn’t make a lot of difference for
    Jupiter—Jupiter’s build system spends a lot of time moving between directories
    and very little time actually building things. But in projects with hundreds of
    source files, you’d see long lists of `CC` *`filename`*`.o` lines, with an occasional
    indication that `make` is changing directories or the linker is building a product—compiler
    warnings tend to jump out at you. For instance, the `ar` warning in the output
    would have flown by unnoticed without silent rules.^([17](footnote.xhtml#ch06fn17))
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用静默规则对 Jupiter 并没有太大影响——Jupiter 的构建系统花费大量时间在目录之间切换，实际构建的时间非常短。然而，在包含数百个源文件的项目中，你会看到一长串
    `CC` *`filename`*`.o` 行，有时还会显示 `make` 切换目录或链接器正在构建产品的信息——编译器警告往往会引起注意。例如，输出中的
    `ar` 警告如果没有静默规则的话，可能会被忽视。^([17](footnote.xhtml#ch06fn17))
- en: Silent rules are disabled by default. To enable silent rules by default in Automake-generated
    *Makefile.am* templates, you may call the `AM_SILENT_RULES` macro in *configure.ac*
    with a `yes` argument.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 静默规则默认是禁用的。要在 Automake 生成的 *Makefile.am* 模板中默认启用静默规则，可以在 *configure.ac* 中调用
    `AM_SILENT_RULES` 宏，并传递 `yes` 参数。
- en: In any case, the user may always set the default verbosity for a build with
    `--enable-silent-rules` or `--disable-silent-rules` on the `configure` command
    line. The build will then either be “silent” or normal based on the configured
    default and on whether the user specifies `V=0` or `V=1` on the `make` command
    line.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，用户始终可以通过在 `configure` 命令行中使用 `--enable-silent-rules` 或 `--disable-silent-rules`
    来设置构建的默认详细程度。然后，构建将根据配置的默认值以及用户是否在 `make` 命令行中指定 `V=0` 或 `V=1` 来决定是“静默”构建还是正常构建。
- en: '**NOTE**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Neither *`configure`* option is required—the actual invocation of silent rules
    is ultimately controlled by the *`V`* variable in the generated makefile. The*
    configure *option merely sets the default value of *`V`*.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*`configure`* 选项并不是必须的——静默规则的实际调用最终是由生成的 makefile 中的 *`V`* 变量控制的。*configure*
    选项仅仅设置 *`V`* 的默认值。'
- en: 'For smaller projects, I find Automake’s silent rules to be less useful than
    simply redirecting `stdout` to */dev/null* on the `make` command line, in this
    manner:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的项目，我发现 Automake 的静默规则比起在 `make` 命令行中简单地将 `stdout` 重定向到 */dev/null* 更不实用，可以按以下方式操作：
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As this example shows, warnings and errors are still displayed on `stderr`,
    usually with enough information for you to determine where the problem is located
    (though not in this case). Warning-free builds are truly silent in this case.
    You should use this technique to clean up compiler warnings in your source code
    every so often. Silent rules can help because warnings stand out in the build
    output.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本示例所示，警告和错误仍然会显示在 `stderr` 上，通常会提供足够的信息，帮助你确定问题所在（尽管在此例中并未显示）。在这种情况下，无警告构建才是真正的静默构建。你应当定期使用这种技巧来清理源代码中的编译器警告。静默规则非常有用，因为警告在构建输出中很突出。
- en: Nonrecursive Automake
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非递归 Automake
- en: Now that we’ve changed our handwritten *Makefile.in* templates over to Automake
    *Makefile.am* files, let’s take a look at the process of converting this recursive
    build system to a nonrecursive build system. In previous chapters, we saw that
    using `make`’s `include` directive can be helpful in dividing makefiles into areas
    of responsibility relegated to the subdirectories in which they reside. With Automake,
    however, it’s just simpler to put everything in a top-level *Makefile.am* file
    because the content is so short that we can easily comprehend the entire build
    system at a glance. If further division of responsibility is required, a simple
    comment suffices.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将手写的 *Makefile.in* 模板转换为 Automake 的 *Makefile.am* 文件，让我们看看如何将这个递归构建系统转换为非递归构建系统。在前面的章节中，我们看到使用
    `make` 的 `include` 指令有助于将 makefile 分割为各个子目录负责的部分。然而，在 Automake 中，将所有内容放入顶层的 *Makefile.am*
    文件更加简单，因为内容非常简短，我们可以一眼看出整个构建系统。如果需要进一步划分责任，只需简单的注释即可。
- en: The key here, as in our previous incarnations, is to reference the content as
    if `make` were running from the top-level directory (which—again—it is).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，和我们之前提到的一样，参考内容时要假设 `make` 是从顶层目录运行的（再说一次，它确实是）。
- en: '[Listing 6-22](ch06.xhtml#ch06ex22) contains the entire contents of the top-level
    *Makefile.am* file—the only makefile we’ll use in this conversion.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-22](ch06.xhtml#ch06ex22) 包含了顶层 *Makefile.am* 文件的全部内容——这是我们在此转换中唯一使用的
    makefile。'
- en: Git tag 6.3
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 6.3
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 6-22:* Makefile.am: *A nonrecursive Automake implementation for Jupiter*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-22:* Makefile.am: *Jupiter 的非递归 Automake 实现*'
- en: As you can see here, I’ve replaced the `SUBDIRS` variable in the top-level *Makefile.am*
    file with the full contents of the *Makefile.am* files in each of the directories
    referenced by this variable. I then added appropriate relative path information
    to each input object and product reference so that source files are accessed from
    the top-level directory, where they actually reside in their respective subdirectories,
    and so that products end up where they belong—with their source input files (or
    at least in their proper counterpart directories when not building in the source
    tree). I’ve highlighted the changes to each of the subdirectory *Makefile.am*
    files that I pasted into the top-level file.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我已经将`SUBDIRS`变量从顶级*Makefile.am*文件中替换为每个目录中*Makefile.am*文件的完整内容。这些目录是由该变量引用的。我接着为每个输入对象和产品引用添加了适当的相对路径信息，以便源文件可以从顶级目录访问，而这些文件实际上位于各自的子目录中，并且产品也能最终被放到正确的位置——与其源输入文件一起（或者至少在源树外构建时，放到正确的对应目录）。我已在顶级文件中粘贴了每个子目录*Makefile.am*文件的更改部分。
- en: Note that `common_` or `src_` was prepended to the product source variables
    because these prefixes are literally part of the product names now. Ultimately,
    these names are used to create `make` targets, which are defined as much by their
    location as their name. Usually, the location is the current directory, so the
    directory portions are silently omitted. For our nonrecursive builds, products
    are now generated into locations other than the current directory, so they must
    be stated explicitly. As with any other special characters in the product name,
    the directory-separating slashes become underscores in PSVs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`common_`或`src_`被加到了产品源变量的前面，因为这些前缀现在确实是产品名称的一部分。最终，这些名称用于创建`make`目标，这些目标的定义不仅依赖于名称，还依赖于它们的位置。通常，位置是当前目录，因此目录部分通常会被省略。对于我们的非递归构建，产品现在会生成到除当前目录以外的位置，因此必须明确指出这些位置。和产品名称中的其他特殊字符一样，目录分隔的斜杠在PSV中会变成下划线。
- en: We also need to add an Automake option and remove the extra *Makefile* references
    from *configure.ac*, as shown in [Listing 6-23](ch06.xhtml#ch06ex23).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个Automake选项，并从*configure.ac*中移除多余的*Makefile*引用，如[清单6-23](ch06.xhtml#ch06ex23)所示。
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 6-23:* configure.ac: *Removing extra makefile references for nonrecursive
    builds*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-23:* configure.ac: *移除非递归构建中的额外Makefile引用*'
- en: 'The Automake `subdir-objects` option is necessary to tell Automake that you
    intend to access source files from directories other than those in which they
    reside. It’s also needed to state that you want the objects and other intermediate
    products to be generated into the same directory as the source file (or in proper
    out-of-tree build counterpart directories). This option is not required just for
    nonrecursive builds but for any situation in which you may need to build one or
    more source files outside of their own directories. If you omit this option, the
    build will often still work, but you’ll see two effects: warnings will be generated
    by `autoreconf` (or `automake`) indicating that you should probably use the option,
    and object files will be left lying in the wrong directories. The latter is only
    a problem if you happen to have more than one instance of a source file with the
    same name in different directories, in which case the second object file will
    overwrite the first, which will most probably result in a linker error when it’s
    not able to find the symbols from the now-overwritten first object.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Automake的`subdir-objects`选项是必要的，它告诉Automake你打算访问来自其他目录的源文件，而这些源文件并非位于当前目录。它还需要声明你希望目标文件和其他中间产品生成到与源文件相同的目录中（或者生成到正确的外部构建对应目录）。这个选项不仅对于非递归构建是必须的，还适用于任何需要在源文件所在目录外构建一个或多个源文件的情况。如果省略了这个选项，构建通常仍然会工作，但你会看到两个效果：`autoreconf`（或`automake`）会生成警告，提示你应该使用这个选项；而目标文件会被错误地放在不正确的目录下。如果你恰好在不同目录中有多个同名的源文件，那么第二个目标文件会覆盖第一个，这通常会导致链接错误，因为链接器找不到第一个被覆盖的目标中的符号。
- en: 'Finally, we can simply delete the *common* and *src* directories’ *Makefile.am*
    files:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以简单地删除*common*和*src*目录中的*Makefile.am*文件：
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve discussed how to instrument a project for Automake using
    a project that had already been instrumented for Autoconf. (Newer projects are
    typically instrumented for both Autoconf and Automake at the same time.)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用已经为Autoconf做过准备的项目来为Automake做准备。（较新的项目通常同时为Autoconf和Automake做准备。）
- en: We covered the use of the `SUBDIRS` variable to tie *Makefile.am* files together,
    as well as the concepts surrounding product list, product source, and product
    option variables. Along with product list variables, I discussed Automake primaries—a
    concept at the very heart of Automake. Finally, I discussed the use of `EXTRA_DIST`
    to add additional files to distribution packages, the `AM_MAINTAINER_MODE` macro
    to ensure that users don’t need to have the Autotools installed, converting to
    a nonrecursive Automake build system, and the use of Automake silent rules.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何使用`SUBDIRS`变量将*Makefile.am*文件连接起来，以及围绕产品列表、产品源和产品选项变量的相关概念。除了产品列表变量外，我还介绍了Automake的主要概念——这也是Automake的核心概念。最后，我讲解了如何使用`EXTRA_DIST`将附加文件添加到分发包中，使用`AM_MAINTAINER_MODE`宏确保用户不需要安装Autotools，如何转换为非递归的Automake构建系统，以及如何使用Automake的静默规则。
- en: Through all of this, we replaced our handwritten *Makefile.in* templates with
    short, concise *Makefile.am* files that provide significantly more functionality.
    I hope this exercise has begun to open your eyes to the benefits of using Automake
    rather than handwritten makefiles.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一切，我们用简短、简洁的*Makefile.am*文件替换了手写的*Makefile.in*模板，这些文件提供了显著更多的功能。我希望这个练习能让你开始意识到使用Automake而不是手写makefile的好处。
- en: In [Chapters 7](ch07.xhtml) and [8](ch08.xhtml), we’ll examine adding Libtool
    to the Jupiter project. In [Chapter 9](ch09.xhtml), we’ll finish up our introduction
    to the Autotools proper by diving into the Autoconf’s portable testing framework—autotest.
    Then, in [Chapters 10](ch10.xhtml) through [13](ch13.xhtml), we’ll take a short
    break from the Autotools to tackle some important sideline topics, but we’ll return
    in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml), where we’ll “Autotool-ize”
    a real-world project as we explore several other important aspects of Automake.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml)和[第8章](ch08.xhtml)中，我们将研究如何将Libtool添加到Jupiter项目中。在[第9章](ch09.xhtml)中，我们将通过深入探讨Autoconf的便携式测试框架——autotest，完成对Autotools的介绍。接着，在[第10章](ch10.xhtml)至[第13章](ch13.xhtml)中，我们将暂时从Autotools中抽离，处理一些重要的旁支话题，但我们将在[第14章](ch14.xhtml)和[第15章](ch15.xhtml)中回归，带着“Autotool化”一个真实项目，同时探索Automake的其他几个重要方面。
