- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FRUIT LOOT: CREATING A SIMPLE ANIMATED GAME**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll create a simple game called “Fruit Loot” that uses components
    from the Drawing and Animation, Sensors, and Media drawers to let players catch
    falling fruit.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll program these components with App Inventor’s built-in Math and Variables
    blocks and component-specific blocks so that the game will use *animation*, or
    movement, with corresponding sound effects; unpredictability to make the game
    challenging; and the ability to keep score so players can see how well they’re
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s explore the key components and underlying programming concepts
    that you’ll use to create the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**ANIMATING AND MOVING RANDOMLY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To play the game, a player moves a fruit picker character back and forth across
    the screen trying to catch pieces of falling fruit. The pieces of fruit fall continuously
    at random speeds from random points at the top of the screen. Because of this
    random animation, players won’t know exactly where to move the picker to catch
    the fruit. This unpredictability should challenge players and keep them engaged.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROGRAMMING MOVING IMAGES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use the `Canvas` and `ImageSprite` components from the Drawing and Animation
    drawer to create the moveable game character and constantly dropping fruit. The
    `Canvas` component is a layer or sheet that we place on the app’s screen so users
    can draw. The `Canvas` is also where *sprites*, which are flat images, can move
    around. The game character and different pieces of fruit are all `ImageSprite`s,
    which we’ll place on a `Canvas` to make them move, collide with other sprites,
    and bounce off the edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The height and width of the `Canvas` are measured in *pixels*, a unit of measurement
    used in computer graphics, and App Inventor uses a common computer screen coordinate
    system to determine the exact location of an `ImageSprite` on the `Canvas`. In
    that coordinate system, the top-left point of the `ImageSprite` is located at
    the point represented by its x- and y-coordinates or properties (`X`,`Y`). The
    `X` property is the image’s distance in pixels from the `Canvas`’s left edge,
    and the `Y` property is the picture’s distance from the `Canvas`’s top edge.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In math class, you may have plotted points on a coordinate plane that contains
    four quadrants. App Inventor’s coordinate system is like the lower-right quadrant
    in that coordinate plane, where the point of origin (0, 0) is at the top left,
    and the size of the x-coordinate increases from left to right, while the size
    of the y-coordinate increases from top to bottom. The difference is that, in the
    math plane, the increasing y-coordinate numbers are negative, while they’re positive
    in App Inventor.*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 3-1](ch03.xhtml#ch3fig1), in App Inventor’s coordinate system,
    an `ImageSprite`’s `X` property value increases as the graphic moves to the right,
    and its `Y` property value increases as it moves down.
  prefs: []
  type: TYPE_NORMAL
- en: When adding an `ImageSprite` to the `Canvas`, we set its initial `X` and `Y`
    property values to the point where we place it or to other values we enter into
    the Designer window’s Property pane. To move the `ImageSprite`, we use program
    blocks to change either property value.
  prefs: []
  type: TYPE_NORMAL
- en: For this game, you’ll program button click event handlers to let players move
    the fruit picker. Also, to constantly animate the fruit, you’ll program the `Clock`
    so the fruit moves automatically at a time interval you’ll set. JavaScript and
    other programming languages handle animation the same way, by having images change
    location in response to user or automated actions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: The Viewer screen with a 300×300 pixel `Canvas` showing the point
    of origin and X and Y property values of different points*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP RANDOM APPEARANCE, SPEED, AND LOCATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like other games that deal with chance, this game relies on randomness to keep
    players from plotting exactly how, when, or where to make their next moves. Because
    of the need for randomness in games and other applications, such as simulations,
    most traditional programming languages include *pseudorandom number generators*,
    which are functions based on mathematical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In its built-in Math blocks, App Inventor provides two pseudorandom number generators.
    The blocks also include *arithmetic operators* that perform multiplication, division,
    addition, and subtraction functions on *operands* or values, just like similar
    operators in other programming languages. In your game, you’ll combine one of
    App Inventor’s pseudorandom number generators, called the *random integer block*,
    with arithmetic operator blocks to develop simple formulas to ensure that the
    appearance, speed, and location of each piece of falling fruit will be determined
    randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to these formulas, although our players will quickly realize that fruit
    drops constantly, they won’t know where and at what speed it will fall, keeping
    them from scoring points too easily.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECLARING AND INITIALIZING VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As players earn points, we’ll need a way to let them know their score. We’ll
    do this by declaring and initializing a couple of *variables*—uniquely named containers
    of memory that programmers create to hold values that can change, or vary. Variables
    allow us to store necessary information that we can update from time to time as
    conditions in the app change. We can use the unique variable name to refer to
    that changing information throughout our code and perform operations on the information
    as the app runs, no matter what value the variable holds at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in your game, you’ll store the score in a variable and compute
    and display the changing score during the game. To compute the score, you’ll use
    a Math addition operator block to *increment* the score, or increase it by a fixed
    number—in this case, 1—whenever a player earns a point.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional programming languages, you must follow specific syntactical rules
    to *declare*, or create, a variable and to *initialize* it, or assign its first
    value. In some languages, you also have to identify the type of data the variable
    will hold when you create it. In App Inventor, you must declare and initialize
    variables using the built-in Variables blocks, and you can store *strings* (sets
    of characters that can include letters, numbers, and other characters), individual
    numbers, Boolean values, and lists by snapping in blocks from the Text, Math,
    Logic, and Lists drawers.
  prefs: []
  type: TYPE_NORMAL
- en: As you work with variables, you’ll notice that they’re a lot like component
    properties in that both variables and properties hold data that can be set, reset,
    and accessed by the blocks used in an app. In fact, as soon as you create a variable,
    App Inventor creates getter and setter blocks for it, similar to those available
    for properties, and adds them to the Variables blocks drawer.
  prefs: []
  type: TYPE_NORMAL
- en: In your game, you’ll create variables that have a *global scope*, which means
    you can use them in all of your event handlers. In later chapters, you’ll experiment
    with *local* variables, which you’ll create within an event handler or procedure
    for use only within that handler or procedure. All programming languages use global
    and local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILDING THE “FRUIT LOOT” APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand how to create variables and program animation and randomness
    in App Inventor, you’re ready to create “Fruit Loot.”
  prefs: []
  type: TYPE_NORMAL
- en: To get started, log into App Inventor following the instructions outlined in
    “Getting Started with App Inventor” on [page xviii](intro.xhtml#page_xviii). In
    the dialog for the project name, enter FruitLoot without any spaces, and then
    click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECOMPOSING “FRUIT LOOT”**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In “Fruit Loot,” the player moves a fruit picker across the screen to catch
    rapidly and randomly dropping fruit. The player earns a point for each fruit caught
    and sees the score on the screen. We can decompose the game activity into five
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When a player presses the start button, start the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `Clock` timer fires, drop fruit from the top of the Canvas at different
    speeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a fruit hits the bottom of the Canvas, return it to a random point at the
    top of the Canvas and display another fruit at random. Increase the total fruits
    dropped by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a player clicks the left and right buttons, move the picker left and right
    to catch the falling fruit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the picker catches a fruit, play a sound, increase the player’s score by
    one, display the score, and hide the fruit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the components you’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: Button (3) for the player to click to manually start the action and play the
    game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas to enable use of `ImageSprites` and game animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock to fire after the player clicks the start button and move `ImageSprites`
    at a set interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HorizontalArrangement (2) to hold start button, score label, and play buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageSprite (4) to display moving images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Label to display `Variable` values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound to play the game sound effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable (2) to store game data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LAYING OUT “FRUIT LOOT” IN THE DESIGNER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s lay out the app in the Designer. First, change the Screen’s horizontal
    alignment so that everything we place on it will be centered. Click Screen1 in
    the Components pane, click the drop-down arrow under AlignHorizontal in the Properties
    pane, and select **Center: 3**.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add a background image to the Screen by clicking the text box under
    BackgroundImage in the Properties pane. Follow the image upload instructions outlined
    in “Uploading a Picture” on [page 27](ch02.xhtml#page_27) to upload *fence-tree.png*,
    which comes with the resources for this book. You can download the resources from
    *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s change the screen *orientation*, which generally means whether the
    screen displays vertically (in *portrait* mode) or horizontally (in *landscape*
    mode). By default, `ScreenOrientation` is set to `Unspecified`, which means that
    the orientation changes depending on how a user rotates the device.
  prefs: []
  type: TYPE_NORMAL
- en: To give our picker `ImageSprite` a wider screen area to move across to catch
    fruit, let’s change the orientation to landscape mode to make sure the screen
    displays horizontally regardless of how the device is held. Click the drop-down
    arrow under ScreenOrientation and select **Landscape**. Also, unclick the checkbox
    under both ShowStatusBar and TitleVisible to keep the device status bar and Screen
    title from showing and taking up space when the game displays on a device.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING AND ARRANGING USER INTERFACE COMPONENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we have limited vertical screen space in landscape orientation mode, we
    need to take up as little of that space as possible with our user interface components.
    But we still need to make sure those components are easy for players to see and
    use. To accomplish this, let’s place our `Button`s and `Label` in two `HorizontalArrangement`s,
    one across the top of the screen and one across the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag two HorizontalArrangements from the Layout drawer onto the Viewer. Then,
    click each in the Components pane, and rename the first one TopArrangement and
    the second BottomArrangement. Then, in the Properties pane, center both of their
    horizontal alignments by clicking the drop-down arrow under AlignHorizontal and
    selecting **Center: 3**, which should center all the components we place inside.
    Next, make BottomArrangement’s width **Fill parent**, the same way you did with
    components in [Chapters 1](ch01.xhtml#ch01) and [2](ch02.xhtml#ch02), so that
    it stretches all the way across the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now drag a Button and a Label from the User Interface drawer into TopArrangement.
    Then, in the Components pane, click Button1 and rename it StartBtn, and in the
    Properties pane, change its text size to 18 point by clicking the text box under
    FontSize, deleting the current number, and entering 18. Also change the default
    text showing on `StartBtn` by clicking the text box under **Text**, deleting the
    current text, and entering Start the Fruit Loot Game. Then, in the Components
    pane, click Label1, and in the Properties pane, remove the `Label`’s default text
    by clicking the text box under **Text** and deleting the current text so no text
    will show until the game starts. Then, center the text by clicking the drop-down
    arrow under TextAlignment and selecting **Center: 1**.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, drag the remaining two Buttons from the User Interface drawer into BottomArrangement,
    click each in the Components pane, and rename the one on the left LeftBtn and
    the other RightBtn. Also make the width for each `Button` **Fill parent**, which
    makes each take up half the width of `BottomArrangement`. Now change the text
    showing on `LeftBtn` to <<<< Left and `RightBtn` to Right >>>>.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make the background color orange for all three `Button`s and the `Label`
    by clicking the box under BackgroundColor and selecting Orange from the color
    list dialog. Also make the text displaying on the `Button`s and `Label` bold by
    clicking the checkbox under FontBold. Next, update the font size on all but `StartBtn`
    by clicking the text box under FontSize and entering 10 to replace the existing
    number. Finally, for BottomArrangement, unclick the checkbox under **Visible**
    so `LeftBtn` and `RightBtn` won’t show when the app opens.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE CANVAS AND IMAGESPRITES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, click the **Drawing and Animation** drawer and drag a Canvas onto the Viewer
    between `TopArrangement` and `BottomArrangement`. Remember that you must place
    a `Canvas` on the Screen before you can add any other Drawing and Animation component.
    In the Properties pane, make the `Canvas` transparent so it doesn’t hide the background
    image by clicking the box under BackgroundColor and then clicking **None** when
    the color list dialog opens. Then make its height and width **Fill parent**.
  prefs: []
  type: TYPE_NORMAL
- en: Now drag four ImageSprites from the Drawing and Animation drawer onto the `Canvas`,
    click the ImageSprites in the Components pane, and rename the first three FruitSprite1,
    FruitSprite2, and FruitSprite3 and the last PickerSprite. Next, under **Picture**
    in the Properties pane, for the fruit `ImageSprite`s, upload *1.png*, *2.png*,
    and *3.png*, and for the picker `ImageSprite`, upload *picker.png*. (All of these
    images come with the resources for this book.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can either drag the `ImageSprite`s around the `Canvas` or enter
    numbers in the text boxes under their `X` and `Y` properties to position them
    on the `Canvas` the way they should appear when the game starts. We want the fruit
    `ImageSprite`s spread out evenly across the top of the `Canvas` and `PickerSprite`
    in the center at the bottom. To place the components this way on a screen that’s
    approximately 450 pixels wide, enter the numbers in [Table 3-1](ch03.xhtml#ch03tab1)
    into the Property pane text boxes under X and Y for each `ImageSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Initial `X` and `Y` Property Values for “Fruit Loot” `ImageSprite`s
    on a 450-pixel-wide screen'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ImageSprite** | **X property** | **Y property** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FruitSprite1` | 10 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `FruitSprite2` | 230 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `FruitSprite3` | 440 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `PickerSprite` | 180 | 150 |'
  prefs: []
  type: TYPE_TB
- en: Now you’re ready to add and adjust the non-visible components.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING AND PREPARING NON-VISIBLE COMPONENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From the Media drawer, drag in a Sound component, and from the Sensors drawer,
    drag in a Clock component. In the Components pane, click the Sound component,
    and in the Properties pane, set the media clip that it will play by clicking the
    text box under **Source** and uploading the *clunk.mp3* file that comes with the
    book resources.
  prefs: []
  type: TYPE_NORMAL
- en: Then click the Clock, replace its default `TimerInterval` property by entering
    150, and unclick the checkbox under TimerEnabled so the timer won’t start when
    the app opens. Shortly, we’ll program the blocks to enable the timer once the
    player clicks `StartBtn`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your screen should look like [Figure 3-2](ch03.xhtml#ch3fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: The Viewer and Component panes after we lay out “Fruit Loot”*'
  prefs: []
  type: TYPE_NORMAL
- en: Once your screen looks like it should, click the Canvas in the Components pane,
    and unclick the checkbox under **Visible**. This way, none of the `ImageSprite`s
    should show when the app opens. Next, we’ll program the blocks to make these components,
    `LeftBtn` and `RightBtn`, visible once the player clicks `StartBtn`.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROGRAMMING “FRUIT LOOT” IN THE BLOCKS EDITOR**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve laid out all the components, you can move to the Blocks Editor
    to program the app. For “Fruit Loot” we’ll program 10 event handlers. Three respond
    to events generated by the user’s button clicks. One directs the app’s action
    after a timer goes off at the time interval we’ve set. The rest respond to `ImageSprite`s
    reaching the edge of the `Canvas` or colliding with one another.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that most of the event handlers contain duplicate code. We’re
    programming them this way because you haven’t yet learned the advanced programming
    structures that would eliminate the repetition. As you learn about those structures
    in later chapters, we’ll be able to revisit the “Fruit Loot” code and *refactor*
    it, which means to restructure and improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Blocks** button to switch to the Blocks Editor, and let’s begin
    programming the five steps of “Fruit Loot” in order.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 1: STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We start by telling the app what to do when the player clicks `StartBtn`. That’s
    when we want the `StartBtn` to disappear, the `Canvas` with its `ImageSprite`s
    and `BottomArrangement` with its `Button`s to appear, and the `Clock`’s timer
    to begin to fire.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the button click event handler with its four setter blocks that do what
    we want in step 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0045-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Blocks pane, click StartBtn and, when the blocks for the component appear,
    drag the whenStartBtn.Click event handler block ➊ to the Viewer. Then, in the
    Blocks pane, click StartBtn again, and drag its setStartBtn.Visibleto block ➋
    into the whenStartBtn.Click block next to the word `do`. Next, in the Blocks pane,
    click the **Logic** blocks drawer, drag the false block ➌ to the Viewer, and snap
    it to the right side of the setStartBtn.Visibleto block. These blocks set `StartBtn`’s
    `Visible` property to `false` so that it disappears after the player clicks the
    start button.
  prefs: []
  type: TYPE_NORMAL
- en: Next, click Canvas1, drag the setCanvas1.Visibleto block ➍ to the Viewer, and
    snap it inside the whenStartBtn.Click block under the `setStartBtn.Visibleto`
    block. Then, in the Blocks pane, click the **Logic** blocks drawer again, drag
    the true block ➎ to the Viewer, and snap it to the right side of the setCanvas1.Visibleto
    block. These blocks set the `Visible` property for `Canvas1` and its contents
    to `true` so the `ImageSprite`s will appear after the player clicks the start
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Then, click BottomArrangement in the Blocks pane, drag the setBottomArrangement.Visibleto
    block ➏ to the Viewer, and snap it inside the whenStartBtn.Click block under the
    `setCanvas1.Visibleto` block. Then click the **Logic** blocks drawer again, drag
    another true block ➐ to the Viewer, and snap it to the right side of the setBottomArrangement.Visibleto
    block. These blocks set the `Visible` property for `BottomArrangement` to `true`,
    making the buttons inside of it appear after the player clicks the start button.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click Clock1, drag the setClock1.TimerEnabledto block ➑ to the Viewer,
    and snap it inside the whenStartBtn.Click block under the `setBottomArrangement.Visibleto`
    block. Then, in the Blocks pane, drag another true block ➒ from the **Logic**
    blocks drawer, and snap it to the right side of the setClock1.TimerEnabledto block.
    These blocks set the value of `Clock1`’s `TimerEnabled` property to `true`. This
    starts `Clock1`’s timer, which will move the fruit `ImageSprite`s down the `Canvas`
    the entire time the game is in play.
  prefs: []
  type: TYPE_NORMAL
- en: Together, the blocks for step 1 start the game. In sum, when the player clicks
    the start button, the blocks set `StartBtn`’s `Visible` property to `false`, set
    the `Visible` properties of the `Canvas` with `ImageSprite`s and the `HorizontalArrangement`
    with play buttons to `true`, and set the `Clock`’s `TimerEnabled` property to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: To see how these blocks work, live-test with a device, as outlined in “Live-Testing
    Your Apps” on [page xxii](intro.xhtml#page_xxii). Once you click **Connect** ▸
    **AI Companion** in the top menu bar and scan the QR code with your device’s Companion
    app, your “Fruit Loot” game should open on your device. As long as your blocks
    are placed as shown in the code examples, you should see the start button until
    you click it, when it disappears as the other game components appear. For now,
    nothing else should happen. Leave the game open on your device to keep live-testing.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 2: MAKING FRUIT DROP AT RANDOM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s program step 2 of the app and tell it what to do each time the `Clock`’s
    timer fires. This is when we want the fruit to drop at varying speeds every 150
    milliseconds—the `TimerInterval` we set in the Property pane in the Designer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0046-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Blocks pane, click Clock1 and, when the blocks for the component appear,
    drag the whenClock1.Timer block ➊ to the Viewer. Then, in the Blocks pane, click
    FruitSprite1, drag the callFruitSprite1.MoveTo method block ➋ to the Viewer, and
    snap it inside the whenClock1.Timer block next to the word `do`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In both the Components pane in the Designer and the Blocks pane in the Blocks
    Editor, if you don’t see a component that you’ve nested within a parent component—for
    example, an ImageSprite placed on a Canvas or a Button dragged within a HorizontalArrangement—you’ll
    find it by clicking the plus sign to the left of the parent.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting X and Y Values for FruitSprite1**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look closer at the `callFruitSprite1.MoveTo` method block we’ve placed
    within the `Clock1 Timer` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0047-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ll notice that the block requires us to insert values for its `x` and `y`
    *method parameters*, which are pieces of information the method must have to operate.
    This means the `ImageSprite`’s `MoveTo` method cannot move `FruitSprite1` until
    we supply *arguments*, or values, for the x- and y-coordinates of the point where
    we want the `ImageSprite` to move.
  prefs: []
  type: TYPE_NORMAL
- en: For our “Fruit Loot” game, we want the fruit `ImageSprite`s to move down only,
    meaning we’ll change their y-coordinates but not their x-coordinates. To keep
    the same `X` value, click FruitSprite1, drag its FruitSprite1.X getter block ➊
    to the Viewer, and snap it into the method block’s x socket. This tells the app
    that, when it moves `FruitSprite1`, it should get the current `X` value for `FruitSprite1`
    and keep that `X` value the same.
  prefs: []
  type: TYPE_NORMAL
- en: To provide the argument for the y-coordinate of the point where we want `FruitSprite1`
    to move, click the **Math** blocks drawer, drag out an addition operator block
    ➋, and snap it into the method block’s y socket. Then, click FruitSprite1 and
    drag its FruitSprite1.Y getter block ➌ into the addition block’s left socket,
    and click the **Math** blocks drawer and drag a `random integer` block ➍ into
    the addition block’s right socket. This tells the app that, when it moves `FruitSprite1`,
    it should increase the current value of its y-coordinate by a random number of
    pixels to move the `ImageSprite` down the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dropping FruitSprite1 at Random Speeds**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `random integer` block generates the random number of pixels—from between
    the specified range of 15 to 50—that we want `FruitSprite1` to fall.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0047-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To set that range of numbers in the `random integer` block, click the default
    1 in its left socket and replace it by entering 15, and click the default 100
    in its right socket and replace it by entering 50.
  prefs: []
  type: TYPE_NORMAL
- en: Now, altogether, our `callFruitSprite1.MoveTo` method block with the `x` and
    `y` parameters we’ve set tells the app that, when it moves `FruitSprite1`, we
    want the `ImageSprite`’s `X` value to stay the same and its `Y` value to move
    from its current y-coordinate down a random number of pixels between 15 and 50\.
    This randomness ensures that the `ImageSprite`’s speed will be unpredictable,
    because, when the `Clock`’s timer fires every 150 milliseconds, `FruitSprite1`
    will travel at a speed anywhere from a slower 15 pixels per 150 milliseconds (100
    pixels per second) to a faster 50 pixels per 150 milliseconds (333 pixels per
    second).
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying Blocks for FruitSprite2 and FruitSprite3**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To complete the blocks for step 2, we now can copy the `callFruitSprite1.MoveTo`
    block and adjust it for `FruitSprite2` and `FruitSprite3`. Right-click the callFruitSprite1.MoveTo
    method block to duplicate it for FruitSprite2, and snap the duplicate in under
    the original.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0048-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the duplicate blocks, use the drop-down arrows ➊ in the callFruitSprite1.MoveTo,
    FruitSprite1.X, and FruitSprite1.Y blocks to change to FruitSprite2. Also change
    the number in the left `random integer` block socket to 5. These blocks now program
    `FruitSprite2` to move down some unknown number of pixels between 5 and 50 when
    the `Clock`’s timer fires every 150 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Next, right-click the callFruitSprite1.MoveTo block, make another copy to use
    for `FruitSprite3`, and snap the duplicate in under the callFruitSprite2.MoveTo
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0048-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the duplicate, use the drop-down arrows ➋ in the callFruitSprite1.MoveTo,
    FruitSprite1.X, and FruitSprite1.Y blocks to change to FruitSprite3, and change
    the number in the `random integer` block’s left socket to 25. These blocks program
    `FruitSprite3` to move down a random number of pixels between 25 and 50 every
    150 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Now the blocks for step 2 should move the three fruit `ImageSprite`s down the
    `Canvas` every 150 milliseconds at random speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Live-test to see how these blocks work. When you click `StartBtn`, you should
    see the three fruit `ImageSprite`s drop to the bottom of the screen, where they
    stay and all movement stops. If any `ImageSprite` fails to move, you need to debug.
    In this instance, you may not have changed your references to the correct `ImageSprite`
    when you duplicated the `MoveTo` blocks. Make any necessary corrections, and test
    again. Once step 2 is working, move to the next step, where we’ll tell the game
    what to do when the fruit `ImageSprite`s reach the bottom of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 3: CREATING MORE FALLING FRUIT AND COUNTING DROPPED FRUIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now program step 3 of the app. In this part, when a fruit `ImageSprite`
    reaches the bottom edge of the `Canvas`, we want the app to move the `ImageSprite`
    back up to a random point along the very top of the `Canvas`, have the `ImageSprite`
    display a random picture of fruit, and add 1 to the total number of times an `ImageSprite`
    hits the edge.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use a global variable to store and update that total number, and we’ll
    start our code for this step by creating and initializing that variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0049-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click the **Variables** blocks drawer and drag an initialize global name block
    to the Viewer. Click name and replace it with the name of our variable, fruitsDropped.
    Then drag a 0 number block from the **Math** drawer and snap it to the right side
    of the initialize global fruitsDropped block. This declares and initializes the
    variable you’ll use to store and update the total number of pieces of fruit dropped
    in your game. Because the variable is global and can be used by all your event
    handlers, it stands alone in the code, outside of all your event handler blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s program the event handler for this step. Here are the blocks that
    handle this `EdgeReached` event for `FruitSprite1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0049-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Blocks pane, click FruitSprite1 and, when the blocks for the component
    appear, drag the whenFruitSprite1.EdgeReached block ➊ to the Viewer. Then, in
    the Blocks pane, click FruitSprite1 again, drag the setFruitSprite1.Y block ➋
    to the Viewer, and snap it inside the whenFruitSprite1.EdgeReached block next
    to the word `do`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, click the **Math** blocks drawer, drag a 0 number block ➌ to the Viewer,
    and snap it to the right of the setFruitSprite1.Y block. So far, once `FruitSprite1`
    reaches the edge of the `Canvas`, these blocks move `FruitSprite1` right back
    up to y-coordinate 0, which is the very top of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moving Fallen Fruit Back Up to a Random Place**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We now need to make sure the code also moves `FruitSprite1` to an unpredictable
    x-coordinate using setter blocks, which keeps your game interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0049-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Blocks pane, click the FruitSprite1 component, drag the setFruitSprite1.X
    block ➊ to the Viewer, and snap it inside the whenFruitSprite1.EdgeReached block
    under the `setFruitSprite1.Y` block. Then, click the **Math** blocks drawer, snap
    a `random integer` block ➋ to the right of the setFruitSprite1.X block, and click
    the default 1 in the `random integer` block’s left socket and replace it by entering
    10. Then, delete the default 100 in the `random integer` block’s right socket,
    and replace it with a multiplication operator block ➌, also from the Math drawer.
    Next, in the Blocks pane, click the Canvas1 component, drag the Canvas1.Width
    getter block ➍ to the Viewer, and snap it into the multiplication block’s left
    socket; then, drag a 0 number block ➎ from the **Math** drawer to the Viewer,
    click its default 0, replace it by entering 0.3, and then snap the 0.3 number
    block into the multiplication block’s right socket.
  prefs: []
  type: TYPE_NORMAL
- en: These blocks set the `X` value for `FruitSprite1` once it reaches the edge of
    the `Canvas`. To avoid collisions with other fruit `ImageSprite`s, we want this
    first fruit `ImageSprite` to drop somewhere in the left third of the `Canvas`
    only. These blocks ensure that by setting the new `X` position to a random number
    of pixels between 10 and the width of the `Canvas` multiplied by 0.3, which is
    a little less than one-third of the `Canvas` width. For instance, if the width
    of the `Canvas` is 450 pixels, the new `X` position will be anywhere between 10
    and (450 × 0.3) pixels, which equals 135 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dropping Random Fruit Images**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, to keep your game unpredictable, you need to make sure the code randomly
    changes the type of fruit dropped after `FruitSprite1` moves back up to the top
    of the `Canvas`. To do this, you’ll use setter blocks that set the `Picture` property
    for `FruitSprite1` to a random image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0050-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click the FruitSprite1 component in the Blocks pane, drag the setFruitSprite1.Picture
    block ➊ to the Viewer, and snap it inside the whenFruitSprite1.EdgeReached block
    under the `setFruitSprite1.X` block. Then, click the **Text** blocks drawer, drag
    a `join` block ➋ to the Viewer, and snap it to the right of the setFruitSprite1.Picture
    block, which will allow you to set the name for the picture by joining two strings.
  prefs: []
  type: TYPE_NORMAL
- en: For the `join` block’s top input, drag in another `random integer` block ➌ from
    the Math blocks drawer, click the default 100 in its right socket, and replace
    it by entering 3. For the `join` block’s second input, drag in an empty string
    block ➍, the first block in the Text blocks drawer. Then click the string block’s
    text area and enter .png.
  prefs: []
  type: TYPE_NORMAL
- en: These blocks set the name of the image to use as the picture source for `FruitSprite1`
    after it reaches the `Canvas` edge. Since we’ve named the three uploaded fruit
    images *1.png*, *2.png*, and *3.png*, we can use the `random integer` block to
    generate the number 1, 2, or 3 that is part of the image name. This should make
    the app continually display a randomly selected image on `FruitSprite1` each time
    it drops from the top of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making Sure Fruit is Visible**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We also need to make sure `FruitSprite1` and the other fruit `ImageSprite`s
    are visible once they move back up to the top of the `Canvas`, because later we’ll
    make them invisible if they hit the picker `ImageSprite`. Here is the setter block
    that turns the `Visible` property on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0051-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click FruitSprite1, drag the setFruitSprite1.Visibleto block ➊ to the Viewer,
    and snap it inside the whenFruitSprite1.EdgeReached block under the `setFruitSprite1.Pictureto`
    block. Then, in the Blocks pane, click the **Logic** blocks drawer, drag the true
    block ➋ to the Viewer, and snap it to the right side of the setFruitSprite1.Visibleto
    block. These blocks reset the `ImageSprite`’s `Visible` property to `true` in
    case it collides with the picker `ImageSprite`, after which our blocks in step
    5 will set it to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Counting the Number of Fruits Dropped**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we need to program the app to keep track of how many fruits are dropped.
    Each time a fruit `ImageSprite` hits the bottom of the `Canvas`, the game should
    add 1 to the value of `fruitsDropped`, which is the variable that keeps track
    of the number of times an `ImageSprite` hits the edge. The following blocks increment
    the value of `fruitsDropped`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0051-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mouse over the initialize global fruitsDropped block that we placed at the beginning
    of this step, drag the set global fruitsDropped block ➊ to the Viewer, and snap
    it inside the whenFruitSprite1.EdgeReached block under the `setFruitSprite1.Visibleto`
    block. Then drag an addition operator block ➋ from the Math drawer and snap it
    to the right of the set global fruitsDropped block. Fill that addition block’s
    sockets by mousing over the initialize global fruitsDropped block, dragging the
    get global fruitsDropped block ➌ into the addition block’s left socket, and dragging
    a 1 number block ➍ from the Math drawer into the addition block’s right socket.
    These blocks keep track of the game’s total number of fruits dropped by adding
    1 to the current value of the `fruitsDropped` variable each time `FruitSprite1`
    reaches the edge of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying Blocks for FruitSprite2 and FruitSprite3**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our final task for step 3 is to duplicate our code to program similar `EdgeReached`
    event handlers for `FruitSprite2` and `FruitSprite3`.
  prefs: []
  type: TYPE_NORMAL
- en: For `FruitSprite2`, right-click the whenFruitSprite1.EdgeReached block and select
    **duplicate**. When you make this duplicate, you’ll see a red X appear to the
    left of the word `when` in both the original and duplicate event handlers. This
    red X warns you that you have two event handlers for the same event, which is
    not allowed. Once you change the duplicate handler’s event, the red X should disappear.
    To change the event, use the drop-down arrow in every block where you see `FruitSprite1`
    and change to FruitSprite2.
  prefs: []
  type: TYPE_NORMAL
- en: The only other adjustment we need to make is to set an `X` property for `FruitSprite2`
    that avoids collisions with the other fruit `ImageSprite`s when it moves down
    the `Canvas`. To accomplish this, make sure this second fruit `ImageSprite` consistently
    drops somewhere in the middle third of the `Canvas` by changing the `FruitSprite2
    X` value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0052-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*App Inventor provides a way for you to display the random integer, join, and
    other blocks that require multiple inputs with either inline inputs, as shown
    in the random integer block inside the FruitSprite1 setter, or external inputs,
    as shown in the random integer block inside the figure’s FruitSprite2 setter,
    which takes up less horizontal space. You can right-click a block to switch between
    inline and external inputs.*'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the 10 number block in the random integer block’s top socket with a
    multiplication operator block ➊ from the Math drawer. Then fill the multiplication
    block’s sockets by clicking the Canvas1 component in the Blocks pane, dragging
    the Canvas1.Width block ➋ into its left socket, and dragging a 0.35 number block
    ➌ from the Math drawer into its right socket. Then, in the `random integer` block’s
    bottom socket, change the 0.3 number block to a 0.65 number block ➍.
  prefs: []
  type: TYPE_NORMAL
- en: These blocks set the new `X` position for `FruitSprite2` to a random number
    of pixels between the width of the `Canvas` multiplied by 0.35 and the width of
    the `Canvas` multiplied by 0.65, which is some random point in the middle third
    of the `Canvas`. For instance, if the width of the `Canvas` is 450 pixels, the
    new `X` position will be anywhere between 450 × 0.35 pixels, which equals 158
    pixels, and 450 × 0.65 pixels, which equals 293 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to create the `EdgeReached` event handler for `FruitSprite3`, right-click
    the whenFruitSprite2.EdgeReached block and select **duplicate**. In the duplicate
    blocks, be sure to use the drop-down arrow in every block where you see `FruitSprite2`
    and change to FruitSprite3.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid collisions with the other fruit `ImageSprite`s, we’ll also need to
    change the `FruitSprite3 X` value so this third fruit `ImageSprite` consistently
    drops somewhere in the right third of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0053-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To do this, replace the 0.35 number block in the right socket of the first multiplication
    block with a 0.7 number block ➊. Also, replace the second multiplication block
    with a subtraction operator block ➋ from the Math blocks drawer, and fill the
    subtraction block by dragging the Canvas1.Width block ➌ into its left socket and
    a 20 number block ➍ into its right socket.
  prefs: []
  type: TYPE_NORMAL
- en: These blocks set the new `X` position of `FruitSprite3` to a random number of
    pixels between the width of the `Canvas` multiplied by 0.7 and the width of the
    `Canvas` minus 20 pixels, which is some random point in the right third of the
    `Canvas`. For instance, if the width of the `Canvas` is 450 pixels, the new `X`
    position will be anywhere between 450 × 0.7 pixels, which equals 315 pixels, and
    450 – 20 pixels, which equals 430 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Altogether, the blocks for step 3 move each fruit `ImageSprite` to a random
    point at the very top of the `Canvas`, have that `ImageSprite` display a random
    picture of fruit, and increase the count of total fruits dropped by 1 each time
    an `ImageSprite` hits the bottom of the `Canvas`, just as we planned.
  prefs: []
  type: TYPE_NORMAL
- en: Now live-test the game again. This time, when you click `StartBtn`, you should
    see the three fruit `ImageSprite`s drop to the bottom of the screen continuously,
    randomly changing the image displayed. You’ll also notice that the speed at which
    each `ImageSprite` drops and its `X` location changes with each drop.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the `ImageSprite`s fail to move, or if two or more appear to drop
    in the same third of the `Canvas`, debug your code. Here again, you may not have
    made the correct changes to your duplicate blocks. Make any necessary corrections,
    and test again. Once step 3 is working, let’s move to the next part, where we’ll
    program `PickerSprite`’s movement.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 4: LETTING PLAYERS MOVE THE PICKER TO CATCH THE FRUIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s program step 4 of the app, telling it what to do when the player clicks
    the left and right play buttons. When the player clicks `LeftBtn`, we want `PickerSprite`
    to move to the left 50 pixels, and when the player clicks `RightBtn`, we want
    `PickerSprite` to move 50 pixels to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0054-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Blocks pane, click LeftBtn and, when the blocks for the component appear,
    drag the whenLeftBtn.Click block ➊ to the Viewer. Then, in the Blocks pane, click
    PickerSprite, drag the callPickerSprite.MoveTo block ➋ to the Viewer, and snap
    it inside the whenLeftBtn.Click block next to the word `do`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to provide the `MoveTo` block’s method parameters to tell the app
    where we want to move `PickerSprite`, keeping in mind that, for this game, we
    want `PickerSprite` to move from side to side only, along the very bottom of the
    `Canvas`. That means we want to change its x-coordinate but leave its y-coordinate
    at the bottom. To do this, click the **Math** blocks drawer, drag a subtraction
    operator block ➌ to the Viewer, and snap it to the right of x. Then, click PickerSprite
    and drag its PickerSprite.X block ➍ into the subtraction block’s left socket,
    and drag a 50 number block ➎ from the Math drawer into the subtraction block’s
    right socket.
  prefs: []
  type: TYPE_NORMAL
- en: These blocks tell our app to move `PickerSprite`’s x-coordinate left to its
    current location minus 50 pixels whenever the `Button` is clicked. For instance,
    if `PickerSprite`’s x-coordinate is at 240 pixels, when the player clicks `LeftBtn`,
    the x-coordinate should move 50 pixels to the left to 190 pixels, since 240 pixels
    – 50 pixels = 190 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Next, click Canvas1, drag its Canvas.Height block ➏ to the viewer, and snap
    it into the callPickerSprite.MoveTo block’s y socket. This tells the app that,
    when it moves `PickerSprite`, we want the `ImageSprite`’s `Y` value to stay the
    value that equals the height of the `Canvas`, positioned at the bottom. For instance,
    if the `Canvas` is 300 pixels in height, these blocks will keep `PickerSprite`’s
    y-coordinate at the `Canvas`’s bottommost point, 300 pixels, when `LeftBtn` is
    clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Now copy the LeftBtn event handler and modify the duplicate blocks to program
    RightBtn. First, in the duplicate event handler, be sure to use the drop-down
    arrow to change LeftBtn to RightBtn. Then replace the subtraction block after
    the letter `x` with an addition block ➐ from the Math drawer, click PickerSprite
    and drag its PickerSprite.X block ➑ into the addition block’s left socket, and
    drag a 50 number block ➒ from the Math drawer into the addition block’s right
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: These blocks say move `PickerSprite`’s x-coordinate to its current location
    plus 50 pixels when the button is clicked. So, if `PickerSprite`’s x-coordinate
    is at 240 pixels when the player clicks `RightBtn`, the x-coordinate should move
    50 pixels to the right to 290 pixels, since 240 pixels + 50 pixels = 290 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Now live-test the game again, and if `LeftBtn` and `RightBtn` don’t work correctly
    after you click `StartBtn`, try debugging. `LeftBtn` and `RightBtn` should move
    `PickerSprite` back and forth across the screen, while fruit `ImageSprite`s occasionally
    collide with `PickerSprite`. Since the player’s goal in the game is to collide
    with, or “catch,” the fruit, we need to program quite a bit of activity to take
    place when those fruit `ImageSprite`s hit `PickerSprite`. We’ll program that action
    in the next, and final, step.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 5: HIDING CAUGHT FRUIT AND KEEPING SCORE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll program the last part of the game so that each time a fruit `ImageSprite`
    hits `PickerSprite`, the player “catches” the piece of fruit, hears a noise that
    sounds like the fruit hitting the picker’s bucket, earns a point, and sees the
    total score displayed on the screen. We’ll also hide the `ImageSprite` that hit
    `PickerSprite` so that, instead of continuing to fall to the bottom of the `Canvas`,
    the fruit looks like it landed in the picker’s bucket.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the player’s score, we’ll use a variable to store and update that information.
    Let’s start our code for this step by creating and initializing the `score` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0055-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click the **Variables** block drawer and drag an initialize global name block
    to the Viewer. Click name, and replace it with the name of our variable, score.
    Then drag a 0 number block from the Math drawer and snap it to the right side
    of the initialize global score block. This declares and initializes the global
    variable we’ll use to store and update the player’s game score.
  prefs: []
  type: TYPE_NORMAL
- en: '**Playing a Sound When Fruit Hits the Picker**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now program the event handler for when a fruit `ImageSprite` hits `PickerSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0055-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Blocks pane, click PickerSprite and, when the blocks for the component
    appear, drag the whenPickerSprite.CollidedWith block ➊ to the Viewer. Then, in
    the Blocks pane, click Sound1, drag the callSound1.Play block ➋ to the Viewer,
    and snap it inside the whenPickerSprite.CollidedWith block next to the word `do`.
    This should play our clunking sound each time an `ImageSprite` hits `PickerSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Increasing and Displaying the Score**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, let’s place the blocks that increment and display the game score each
    time a fruit `ImageSprite` hits the picker.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0056-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mouse over the initialize global score block, drag the set global score to block
    ➊ to the Viewer, and snap it inside the whenPickerSprite.CollidedWith block under
    the `callSound1.Play` block. Then drag an addition operator block ➋ from the Math
    drawer and snap it to the right of the set global score to block. Next, mouse
    over the initialize global score block again, and drag the get global score block
    ➌ into the addition block’s left socket and a 1 number block ➍ from the Math drawer
    into its right socket. These blocks add 1 to the current value of the `score`
    variable each time a fruit `ImageSprite` collides with `PickerSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: To display the score and also let the player know how many of the total number
    of dropped fruits `PickerSprite` has caught, click Label1, drag the setLabel1.Textto
    block ➎ to the Viewer, and snap it inside the whenPickerSprite.CollidedWith block
    under the `set global score to` block. Then, click the **Text** blocks drawer,
    drag a join block ➏ to the Viewer, and snap it to the right of the setLabel1.Textto
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll join four strings to set the text and numbers we want `Label1` to
    display, although by default the `join` block allows us to combine only two strings.
    [Figure 3-3](ch03.xhtml#ch3fig3) shows how to change the block to create space
    for the additional inputs we’ll need.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Adding inputs to the `join` block*'
  prefs: []
  type: TYPE_NORMAL
- en: Click the blue *mutator* icon to the left of the word `join`, and drag additional
    string blocks to the `join` block in the dialog that opens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can snap our four strings into the `join` block inputs. In the top input,
    drag in an empty string block ➐ from the Text blocks drawer and enter Score: ,
    making sure to include the space after the colon so that, when the strings combine,
    the characters won’t run together without proper spacing. Then mouse over the
    initialize global score block and drag the get global score block ➑ into the `join`
    block’s second input. In the `join` block’s third input, drag in another empty
    string block ➒ and enter out of , leaving a space before `out` and after `of`.
    Then mouse over the initialize global fruitsDropped block and drag the get global
    fruitsDropped block ➓ into the `join` block’s last input. These blocks display
    the number of points and total number of fruits dropped on `Label1` for the player
    to see at the top of the screen. For instance, if the player’s score is 6 points
    and a total of 20 fruits have dropped, the label should display “Score: 6 out
    of 20.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding Caught Fruit**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, let’s add the blocks that will make the fruit `ImageSprite`s disappear
    after they collide with `PickerSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0057-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click FruitSprite1 and, when the blocks for the component appear, drag the whenFruitSprite1.CollidedWith
    block ➊ to the Viewer. Then, click FruitSprite1, drag the setFruitSprite1.Visibleto
    block ➋ to the Viewer, and snap it inside the whenFruitSprite1.CollidedWith block
    next to the word `do`. Next, in the Blocks pane, click the **Logic** blocks drawer,
    drag the false block ➌ to the Viewer, and snap it to the right side of the setFruitSprite1.Visibleto
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Now duplicate these blocks for `FruitSprite2`, taking care to use the drop-down
    arrows both places you see `FruitSprite1` to change to FruitSprite2. Then duplicate
    the blocks again, and be sure to change to FruitSprite3. These three event handlers
    hide the fruit `ImageSprite`s when they hit `PickerSprite` so it looks like the
    picker successfully caught the fruit in the bucket. In the next chapter, you’ll
    learn how to eliminate these duplicate blocks and accomplish the same task using
    a more sophisticated programming structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, following the plan for step 5, each time a fruit `ImageSprite` touches
    `PickerSprite`, the app should play a sound, increase the player’s score by 1,
    display the score and the total pieces of fruit, and hide the fruit `ImageSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to test the completed game! Open the app on your device, and you should
    see `StartBtn` at the top of the screen. Click it, and when it disappears, you
    should see the other game components appear. Now the fruit starts to randomly
    drop, and you can click `LeftBtn` and `RightBtn` to move `PickerSprite` back and
    forth across the screen to try to catch it. Whenever `PickerSprite` catches a
    piece of fruit, you should hear a sound and see your score increase. If you placed
    your blocks correctly, the game should work as described, and you’ll have successfully
    created the “Fruit Loot” game!
  prefs: []
  type: TYPE_NORMAL
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you built the animated “Fruit Loot” app, a game where a player
    moves a fruit picker back and forth across the screen and earns points when the
    picker catches rapidly and randomly dropping fruit.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how programmers animate an object by moving its x- and y-coordinates;
    use pseudorandom number generators to add randomness in games, simulators, and
    other applications; and work with arithmetic operators to manipulate data. You
    also practiced declaring and initializing variables to store and change information,
    and you learned how to provide required arguments for built-in methods with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll do more with math operators and random number blocks
    and begin to make selections in your code using Control blocks. You’ll use those
    tools to create part 1 of the “Multiplication Station” quiz app, which generates
    random, timed multiplication problems, evaluates solutions the user inputs, and
    then speaks to declare those answers right or wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '**ON YOUR OWN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Save new versions of “Fruit Loot” as you modify and extend it working on these
    exercises. You can find solutions online at *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Change the app so that it calculates and keeps track of how many pieces of fruit
    the picker fails to catch during a game. How can you calculate, store, and display
    this information using the existing event handlers and adding the smallest number
    of additional blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the game so that the frustrated owner of the fruit trees, who can’t keep
    the fruit from falling over the fence, drops rocks down the fence to try to keep
    the picker from attempting to catch the falling fruit. Reduce the player’s score
    each time the rock hits another sprite. What components and blocks will you add?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the game even further so that the score label displays the number of
    times the rock hits another sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
