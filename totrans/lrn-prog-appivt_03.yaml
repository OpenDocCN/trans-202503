- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: 'FRUIT LOOT: CREATING A SIMPLE ANIMATED GAME**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'FRUIT LOOT: 创建一个简单的动画游戏**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, you’ll create a simple game called “Fruit Loot” that uses components
    from the Drawing and Animation, Sensors, and Media drawers to let players catch
    falling fruit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将创建一个简单的游戏，叫做“水果大盗”，它使用来自绘图与动画、传感器和媒体模块的组件，让玩家捕捉掉落的水果。
- en: You’ll program these components with App Inventor’s built-in Math and Variables
    blocks and component-specific blocks so that the game will use *animation*, or
    movement, with corresponding sound effects; unpredictability to make the game
    challenging; and the ability to keep score so players can see how well they’re
    doing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 App Inventor 内置的数学和变量模块，以及特定组件的模块来编程这些组件，使得游戏能够使用*动画*或运动，并配有相应的音效；具有不可预测性以增加游戏的挑战性；并且能够记录分数，玩家可以查看自己的表现。
- en: First, let’s explore the key components and underlying programming concepts
    that you’ll use to create the game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索你将在创建游戏时使用的关键组件和基础编程概念。
- en: '**ANIMATING AND MOVING RANDOMLY**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动画与随机移动**'
- en: To play the game, a player moves a fruit picker character back and forth across
    the screen trying to catch pieces of falling fruit. The pieces of fruit fall continuously
    at random speeds from random points at the top of the screen. Because of this
    random animation, players won’t know exactly where to move the picker to catch
    the fruit. This unpredictability should challenge players and keep them engaged.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，玩家需要将水果采摘器角色在屏幕上左右移动，试图捕捉掉落的水果。水果片会以随机速度从屏幕顶部的随机位置不断掉落。由于这种随机动画，玩家无法准确知道该移动采摘器到哪里才能捕捉到水果。这种不可预测性将挑战玩家并保持他们的参与感。
- en: '**PROGRAMMING MOVING IMAGES**'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编程移动图像**'
- en: We’ll use the `Canvas` and `ImageSprite` components from the Drawing and Animation
    drawer to create the moveable game character and constantly dropping fruit. The
    `Canvas` component is a layer or sheet that we place on the app’s screen so users
    can draw. The `Canvas` is also where *sprites*, which are flat images, can move
    around. The game character and different pieces of fruit are all `ImageSprite`s,
    which we’ll place on a `Canvas` to make them move, collide with other sprites,
    and bounce off the edge of the screen.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自绘图与动画模块的 `Canvas` 和 `ImageSprite` 组件来创建可移动的游戏角色和不断掉落的水果。`Canvas` 组件是我们放置在应用屏幕上的一层或纸张，用户可以在上面绘图。`Canvas`
    也是*精灵*（即平面图像）可以移动的地方。游戏角色和不同的水果片都是 `ImageSprite`，我们将它们放置在 `Canvas` 上使其移动、与其他精灵碰撞并从屏幕边缘反弹。
- en: The height and width of the `Canvas` are measured in *pixels*, a unit of measurement
    used in computer graphics, and App Inventor uses a common computer screen coordinate
    system to determine the exact location of an `ImageSprite` on the `Canvas`. In
    that coordinate system, the top-left point of the `ImageSprite` is located at
    the point represented by its x- and y-coordinates or properties (`X`,`Y`). The
    `X` property is the image’s distance in pixels from the `Canvas`’s left edge,
    and the `Y` property is the picture’s distance from the `Canvas`’s top edge.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` 的高度和宽度以 *像素* 为单位进行测量，像素是计算机图形学中常用的测量单位，App Inventor 使用一个常见的计算机屏幕坐标系统来确定
    `ImageSprite` 在 `Canvas` 上的确切位置。在该坐标系统中，`ImageSprite` 的左上角位于由其 x 和 y 坐标或属性（`X`，`Y`）表示的点上。`X`
    属性表示图像距离 `Canvas` 左边缘的像素距离，`Y` 属性表示图像距离 `Canvas` 上边缘的像素距离。'
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In math class, you may have plotted points on a coordinate plane that contains
    four quadrants. App Inventor’s coordinate system is like the lower-right quadrant
    in that coordinate plane, where the point of origin (0, 0) is at the top left,
    and the size of the x-coordinate increases from left to right, while the size
    of the y-coordinate increases from top to bottom. The difference is that, in the
    math plane, the increasing y-coordinate numbers are negative, while they’re positive
    in App Inventor.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*在数学课上，你可能会在包含四个象限的坐标平面上绘制点。App Inventor 的坐标系统就像该坐标平面中的右下象限，原点 (0, 0) 位于左上角，x
    坐标从左到右增大，而 y 坐标则从上到下增大。不同之处在于，在数学平面中，y 坐标值是负数，而在 App Inventor 中是正数。*'
- en: As shown in [Figure 3-1](ch03.xhtml#ch3fig1), in App Inventor’s coordinate system,
    an `ImageSprite`’s `X` property value increases as the graphic moves to the right,
    and its `Y` property value increases as it moves down.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 3-1](ch03.xhtml#ch3fig1) 所示，在 App Inventor 的坐标系统中，`ImageSprite` 的 `X` 属性值随着图形向右移动而增大，`Y`
    属性值则随着图形向下移动而增大。
- en: When adding an `ImageSprite` to the `Canvas`, we set its initial `X` and `Y`
    property values to the point where we place it or to other values we enter into
    the Designer window’s Property pane. To move the `ImageSprite`, we use program
    blocks to change either property value.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`ImageSprite`添加到`画布`时，我们将其初始的`X`和`Y`属性值设置为放置它的位置，或者设置为我们在设计窗口的属性面板中输入的其他值。要移动`ImageSprite`，我们可以使用程序模块来改变任一属性值。
- en: For this game, you’ll program button click event handlers to let players move
    the fruit picker. Also, to constantly animate the fruit, you’ll program the `Clock`
    so the fruit moves automatically at a time interval you’ll set. JavaScript and
    other programming languages handle animation the same way, by having images change
    location in response to user or automated actions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你将编程按钮点击事件处理程序，让玩家移动水果采摘器。而且，为了不断地动画化水果，你还需要编程`时钟`，让水果在你设定的时间间隔内自动移动。JavaScript和其他编程语言处理动画的方式相同，都是通过让图像在响应用户或自动化动作时改变位置。
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig01.jpg)'
- en: '*Figure 3-1: The Viewer screen with a 300×300 pixel `Canvas` showing the point
    of origin and X and Y property values of different points*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：带有300×300像素`画布`的查看器屏幕，显示原点以及不同点的X和Y属性值*'
- en: '**SETTING UP RANDOM APPEARANCE, SPEED, AND LOCATION**'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**设置随机出现、速度和位置**'
- en: Like other games that deal with chance, this game relies on randomness to keep
    players from plotting exactly how, when, or where to make their next moves. Because
    of the need for randomness in games and other applications, such as simulations,
    most traditional programming languages include *pseudorandom number generators*,
    which are functions based on mathematical algorithms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他依赖运气的游戏一样，这个游戏依赖于随机性，防止玩家精确计算出如何、何时或在哪里进行下一步操作。由于游戏和其他应用程序（如模拟）中对随机性的需求，大多数传统编程语言都包括*伪随机数生成器*，这是一种基于数学算法的函数。
- en: In its built-in Math blocks, App Inventor provides two pseudorandom number generators.
    The blocks also include *arithmetic operators* that perform multiplication, division,
    addition, and subtraction functions on *operands* or values, just like similar
    operators in other programming languages. In your game, you’ll combine one of
    App Inventor’s pseudorandom number generators, called the *random integer block*,
    with arithmetic operator blocks to develop simple formulas to ensure that the
    appearance, speed, and location of each piece of falling fruit will be determined
    randomly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在其内置的数学模块中，App Inventor提供了两个伪随机数生成器。这些模块还包括*算术运算符*，对*操作数*或值执行乘法、除法、加法和减法功能，就像其他编程语言中的类似运算符一样。在你的游戏中，你将把App
    Inventor的一个伪随机数生成器（称为*随机整数模块*）与算术运算符模块结合使用，开发简单的公式，以确保每个下落的水果的出现、速度和位置都是随机确定的。
- en: Thanks to these formulas, although our players will quickly realize that fruit
    drops constantly, they won’t know where and at what speed it will fall, keeping
    them from scoring points too easily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些公式，虽然我们的玩家很快就会发现水果会不断掉落，但他们不会知道水果会掉在哪里以及以什么速度掉落，从而避免了他们轻松得分。
- en: '**DECLARING AND INITIALIZING VARIABLES**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**声明并初始化变量**'
- en: As players earn points, we’ll need a way to let them know their score. We’ll
    do this by declaring and initializing a couple of *variables*—uniquely named containers
    of memory that programmers create to hold values that can change, or vary. Variables
    allow us to store necessary information that we can update from time to time as
    conditions in the app change. We can use the unique variable name to refer to
    that changing information throughout our code and perform operations on the information
    as the app runs, no matter what value the variable holds at any given time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着玩家得分，我们需要一种方式来让他们知道自己的分数。我们将通过声明并初始化几个*变量*来做到这一点——变量是程序员创建的具有唯一名称的内存容器，用来存储可以变化的值。变量允许我们存储必要的信息，并在应用程序条件变化时随时更新这些信息。我们可以使用唯一的变量名称来在代码中引用这些变化的信息，并在应用程序运行时对信息执行操作，无论该变量在任何时刻持有什么值。
- en: For instance, in your game, you’ll store the score in a variable and compute
    and display the changing score during the game. To compute the score, you’ll use
    a Math addition operator block to *increment* the score, or increase it by a fixed
    number—in this case, 1—whenever a player earns a point.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你的游戏中，你将把分数存储在一个变量中，并在游戏过程中计算并显示变化的分数。为了计算分数，你会使用一个数学加法运算符模块来*增加*分数，或者每当玩家得分时，将分数增加一个固定数值——在这种情况下是1。
- en: In traditional programming languages, you must follow specific syntactical rules
    to *declare*, or create, a variable and to *initialize* it, or assign its first
    value. In some languages, you also have to identify the type of data the variable
    will hold when you create it. In App Inventor, you must declare and initialize
    variables using the built-in Variables blocks, and you can store *strings* (sets
    of characters that can include letters, numbers, and other characters), individual
    numbers, Boolean values, and lists by snapping in blocks from the Text, Math,
    Logic, and Lists drawers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的编程语言中，你必须遵循特定的语法规则来*声明*或创建变量，并*初始化*它，或者赋予它第一个值。在某些语言中，你还需要在创建变量时确定它将存储的数据类型。在
    App Inventor 中，你必须使用内置的变量积木来声明和初始化变量，并且可以通过拖入文本、数学、逻辑和列表抽屉中的积木来存储*字符串*（由字母、数字和其他字符组成的字符集）、单个数字、布尔值和列表。
- en: As you work with variables, you’ll notice that they’re a lot like component
    properties in that both variables and properties hold data that can be set, reset,
    and accessed by the blocks used in an app. In fact, as soon as you create a variable,
    App Inventor creates getter and setter blocks for it, similar to those available
    for properties, and adds them to the Variables blocks drawer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用变量时，你会发现它们和组件属性很相似，因为变量和属性都存储数据，这些数据可以被设置、重置，并且可以通过应用程序中的积木进行访问。事实上，一旦你创建了一个变量，App
    Inventor 就会为其创建 getter 和 setter 积木，类似于属性的积木，并将它们添加到变量积木抽屉中。
- en: In your game, you’ll create variables that have a *global scope*, which means
    you can use them in all of your event handlers. In later chapters, you’ll experiment
    with *local* variables, which you’ll create within an event handler or procedure
    for use only within that handler or procedure. All programming languages use global
    and local variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，你将创建具有*全局作用域*的变量，这意味着你可以在所有的事件处理程序中使用它们。在后续的章节中，你将实验使用*局部*变量，这些变量只在某个事件处理程序或过程内创建并使用。所有编程语言都使用全局和局部变量。
- en: '**BUILDING THE “FRUIT LOOT” APP**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建“FRUIT LOOT”应用**'
- en: Now that you understand how to create variables and program animation and randomness
    in App Inventor, you’re ready to create “Fruit Loot.”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了如何在 App Inventor 中创建变量、编程动画和随机性，你已准备好创建“Fruit Loot”。
- en: To get started, log into App Inventor following the instructions outlined in
    “Getting Started with App Inventor” on [page xviii](intro.xhtml#page_xviii). In
    the dialog for the project name, enter FruitLoot without any spaces, and then
    click **OK**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照[第 xviii 页](intro.xhtml#page_xviii)中《App Inventor 入门》一章的说明登录 App Inventor。在项目名称对话框中，输入没有空格的“FruitLoot”，然后点击**确定**。
- en: '**DECOMPOSING “FRUIT LOOT”**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分解“FRUIT LOOT”**'
- en: 'In “Fruit Loot,” the player moves a fruit picker across the screen to catch
    rapidly and randomly dropping fruit. The player earns a point for each fruit caught
    and sees the score on the screen. We can decompose the game activity into five
    steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Fruit Loot”中，玩家控制一个水果挑选器在屏幕上左右移动，快速随机地捕捉掉落的水果。每捕捉到一个水果，玩家就能获得一点分数，并在屏幕上看到得分。我们可以将游戏活动分解成五个步骤：
- en: When a player presses the start button, start the game.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家按下开始按钮时，开始游戏。
- en: When the `Clock` timer fires, drop fruit from the top of the Canvas at different
    speeds.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Clock`定时器触发时，从画布顶部以不同的速度掉落水果。
- en: When a fruit hits the bottom of the Canvas, return it to a random point at the
    top of the Canvas and display another fruit at random. Increase the total fruits
    dropped by one.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当水果碰到画布底部时，将其返回到画布顶部的随机位置，并随机显示另一个水果。增加掉落的水果总数。
- en: When a player clicks the left and right buttons, move the picker left and right
    to catch the falling fruit.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家点击左侧和右侧按钮时，左右移动挑选器来捕捉掉落的水果。
- en: When the picker catches a fruit, play a sound, increase the player’s score by
    one, display the score, and hide the fruit.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当挑选器捕捉到水果时，播放声音、增加玩家的分数、显示得分并隐藏水果。
- en: 'Here are the components you’ll need:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下组件：
- en: Button (3) for the player to click to manually start the action and play the
    game
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Button (3) 让玩家点击手动开始游戏并进行游戏
- en: Canvas to enable use of `ImageSprites` and game animation
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Canvas 启用 `ImageSprites` 和游戏动画
- en: Clock to fire after the player clicks the start button and move `ImageSprites`
    at a set interval
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器在玩家点击开始按钮后触发，并在设定的时间间隔内移动`ImageSprites`
- en: HorizontalArrangement (2) to hold start button, score label, and play buttons
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HorizontalArrangement (2) 来放置开始按钮、得分标签和游戏按钮
- en: ImageSprite (4) to display moving images
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ImageSprite (4) 来显示移动的图像
- en: Label to display `Variable` values
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签显示`Variable`值
- en: Sound to play the game sound effect
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放游戏音效
- en: Variable (2) to store game data
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（2）用于存储游戏数据
- en: '**LAYING OUT “FRUIT LOOT” IN THE DESIGNER**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在设计器中布局“水果抢夺”**'
- en: 'Now let’s lay out the app in the Designer. First, change the Screen’s horizontal
    alignment so that everything we place on it will be centered. Click Screen1 in
    the Components pane, click the drop-down arrow under AlignHorizontal in the Properties
    pane, and select **Center: 3**.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们在设计器中布局应用。首先，改变屏幕的水平对齐方式，使我们放置的所有内容居中。点击组件面板中的Screen1，点击属性面板中的AlignHorizontal下拉箭头，选择**Center:
    3**。'
- en: Next, let’s add a background image to the Screen by clicking the text box under
    BackgroundImage in the Properties pane. Follow the image upload instructions outlined
    in “Uploading a Picture” on [page 27](ch02.xhtml#page_27) to upload *fence-tree.png*,
    which comes with the resources for this book. You can download the resources from
    *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过点击属性面板中BackgroundImage下的文本框为屏幕添加背景图像。按照《上传图片》一节中的说明，在[第27页](ch02.xhtml#page_27)上传*fence-tree.png*，该图片附带本书的资源。你可以从*[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*下载这些资源。
- en: Now let’s change the screen *orientation*, which generally means whether the
    screen displays vertically (in *portrait* mode) or horizontally (in *landscape*
    mode). By default, `ScreenOrientation` is set to `Unspecified`, which means that
    the orientation changes depending on how a user rotates the device.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更改屏幕的*方向*，这通常指的是屏幕是垂直显示（*纵向*模式）还是水平显示（*横向*模式）。默认情况下，`ScreenOrientation`设置为`Unspecified`，这意味着屏幕的方向会根据用户旋转设备的方式而改变。
- en: To give our picker `ImageSprite` a wider screen area to move across to catch
    fruit, let’s change the orientation to landscape mode to make sure the screen
    displays horizontally regardless of how the device is held. Click the drop-down
    arrow under ScreenOrientation and select **Landscape**. Also, unclick the checkbox
    under both ShowStatusBar and TitleVisible to keep the device status bar and Screen
    title from showing and taking up space when the game displays on a device.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的选择器`ImageSprite`提供更宽的屏幕区域来移动并捕捉水果，我们将屏幕方向改为横向模式，以确保无论设备如何持握，屏幕都横向显示。点击ScreenOrientation下方的下拉箭头，选择**Landscape**。同时，取消选中ShowStatusBar和TitleVisible下的复选框，以避免在游戏显示时设备的状态栏和屏幕标题占用空间。
- en: '**ADDING AND ARRANGING USER INTERFACE COMPONENTS**'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加和排列用户界面组件**'
- en: Since we have limited vertical screen space in landscape orientation mode, we
    need to take up as little of that space as possible with our user interface components.
    But we still need to make sure those components are easy for players to see and
    use. To accomplish this, let’s place our `Button`s and `Label` in two `HorizontalArrangement`s,
    one across the top of the screen and one across the bottom.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在横向模式下我们有有限的垂直屏幕空间，我们需要尽可能少地占用这些空间来放置用户界面组件。但我们仍然需要确保这些组件对玩家来说容易看见和使用。为此，我们将`Button`和`Label`分别放置在两个`HorizontalArrangement`中，一个放在屏幕顶部，另一个放在屏幕底部。
- en: 'Drag two HorizontalArrangements from the Layout drawer onto the Viewer. Then,
    click each in the Components pane, and rename the first one TopArrangement and
    the second BottomArrangement. Then, in the Properties pane, center both of their
    horizontal alignments by clicking the drop-down arrow under AlignHorizontal and
    selecting **Center: 3**, which should center all the components we place inside.
    Next, make BottomArrangement’s width **Fill parent**, the same way you did with
    components in [Chapters 1](ch01.xhtml#ch01) and [2](ch02.xhtml#ch02), so that
    it stretches all the way across the screen.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '从布局抽屉中拖动两个HorizontalArrangement到查看器中。然后，点击每一个组件，在组件面板中重命名第一个为TopArrangement，第二个为BottomArrangement。接着，在属性面板中，通过点击AlignHorizontal下拉箭头并选择**Center:
    3**，将它们的水平对齐方式都设为居中，这样我们放置的所有组件都将居中。接下来，将BottomArrangement的宽度设为**填充父容器**，就像你在[第1章](ch01.xhtml#ch01)和[第2章](ch02.xhtml#ch02)中对组件所做的那样，这样它就会拉伸填满整个屏幕。'
- en: 'Now drag a Button and a Label from the User Interface drawer into TopArrangement.
    Then, in the Components pane, click Button1 and rename it StartBtn, and in the
    Properties pane, change its text size to 18 point by clicking the text box under
    FontSize, deleting the current number, and entering 18. Also change the default
    text showing on `StartBtn` by clicking the text box under **Text**, deleting the
    current text, and entering Start the Fruit Loot Game. Then, in the Components
    pane, click Label1, and in the Properties pane, remove the `Label`’s default text
    by clicking the text box under **Text** and deleting the current text so no text
    will show until the game starts. Then, center the text by clicking the drop-down
    arrow under TextAlignment and selecting **Center: 1**.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，从用户界面抽屉中拖动一个按钮和一个标签到“TopArrangement”中。然后，在“组件”面板中点击Button1并将其重命名为StartBtn，在“属性”面板中通过点击“FontSize”下的文本框，删除当前数字并输入18，将其文本大小更改为18点。同时，通过点击“**Text**”下的文本框，删除当前文本并输入“Start
    the Fruit Loot Game”来更改`StartBtn`上显示的默认文本。接着，在“组件”面板中点击Label1，在“属性”面板中，通过点击“**Text**”下的文本框并删除当前文本，将`Label`的默认文本移除，这样直到游戏开始时就不会显示任何文本。然后，通过点击“TextAlignment”下拉箭头并选择**Center:
    1**来居中文本。'
- en: Next, drag the remaining two Buttons from the User Interface drawer into BottomArrangement,
    click each in the Components pane, and rename the one on the left LeftBtn and
    the other RightBtn. Also make the width for each `Button` **Fill parent**, which
    makes each take up half the width of `BottomArrangement`. Now change the text
    showing on `LeftBtn` to <<<< Left and `RightBtn` to Right >>>>.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从用户界面抽屉中拖动剩余的两个按钮到“BottomArrangement”中，点击组件面板中的每个按钮，将左侧的按钮重命名为LeftBtn，右侧的按钮重命名为RightBtn。还需要将每个`Button`的宽度设置为**Fill
    parent**，这会让每个按钮占据`BottomArrangement`的一半宽度。现在，将`LeftBtn`上显示的文本更改为<<<< Left，将`RightBtn`上显示的文本更改为Right
    >>>>。
- en: Finally, make the background color orange for all three `Button`s and the `Label`
    by clicking the box under BackgroundColor and selecting Orange from the color
    list dialog. Also make the text displaying on the `Button`s and `Label` bold by
    clicking the checkbox under FontBold. Next, update the font size on all but `StartBtn`
    by clicking the text box under FontSize and entering 10 to replace the existing
    number. Finally, for BottomArrangement, unclick the checkbox under **Visible**
    so `LeftBtn` and `RightBtn` won’t show when the app opens.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过点击“BackgroundColor”下的框并在颜色列表对话框中选择橙色，将所有三个`Button`和`Label`的背景颜色设置为橙色。同时，通过点击“FontBold”下的复选框，将显示在`Button`和`Label`上的文字设置为粗体。接着，通过点击“FontSize”下的文本框并输入10，更新除`StartBtn`外所有按钮的字体大小，将现有数字替换为10。最后，对于“BottomArrangement”，取消选中**Visible**下的复选框，这样`LeftBtn`和`RightBtn`在应用打开时就不会显示。
- en: '**SETTING UP THE CANVAS AND IMAGESPRITES**'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**设置Canvas和ImageSprite**'
- en: Now, click the **Drawing and Animation** drawer and drag a Canvas onto the Viewer
    between `TopArrangement` and `BottomArrangement`. Remember that you must place
    a `Canvas` on the Screen before you can add any other Drawing and Animation component.
    In the Properties pane, make the `Canvas` transparent so it doesn’t hide the background
    image by clicking the box under BackgroundColor and then clicking **None** when
    the color list dialog opens. Then make its height and width **Fill parent**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**Drawing and Animation**抽屉并将一个Canvas拖到`TopArrangement`和`BottomArrangement`之间的查看器中。记住，在添加任何其他绘图和动画组件之前，必须先在屏幕上放置一个`Canvas`。在“属性”面板中，通过点击“BackgroundColor”下的框并在颜色列表对话框中选择**None**，将`Canvas`设置为透明，这样它就不会遮挡背景图像。然后将其高度和宽度设置为**Fill
    parent**。
- en: Now drag four ImageSprites from the Drawing and Animation drawer onto the `Canvas`,
    click the ImageSprites in the Components pane, and rename the first three FruitSprite1,
    FruitSprite2, and FruitSprite3 and the last PickerSprite. Next, under **Picture**
    in the Properties pane, for the fruit `ImageSprite`s, upload *1.png*, *2.png*,
    and *3.png*, and for the picker `ImageSprite`, upload *picker.png*. (All of these
    images come with the resources for this book.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从“绘图和动画”抽屉中拖动四个`ImageSprite`到`Canvas`上，点击“组件”面板中的`ImageSprite`，将前三个重命名为FruitSprite1、FruitSprite2和FruitSprite3，最后一个重命名为PickerSprite。接着，在“属性”面板的**Picture**下，对于水果`ImageSprite`，上传*1.png*、*2.png*和*3.png*，对于挑选器`ImageSprite`，上传*picker.png*。（这些图片都来自本书的资源包。）
- en: Finally, you can either drag the `ImageSprite`s around the `Canvas` or enter
    numbers in the text boxes under their `X` and `Y` properties to position them
    on the `Canvas` the way they should appear when the game starts. We want the fruit
    `ImageSprite`s spread out evenly across the top of the `Canvas` and `PickerSprite`
    in the center at the bottom. To place the components this way on a screen that’s
    approximately 450 pixels wide, enter the numbers in [Table 3-1](ch03.xhtml#ch03tab1)
    into the Property pane text boxes under X and Y for each `ImageSprite`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以拖动 `ImageSprite` 到画布（Canvas）上，或者在其 `X` 和 `Y` 属性的文本框中输入数字，以便将它们放置在游戏开始时应显示的位置。我们希望果实
    `ImageSprite` 均匀地分布在画布的顶部，`PickerSprite` 放置在底部的中心位置。为了在大约 450 像素宽的屏幕上将组件放置成这种方式，请在
    [表 3-1](ch03.xhtml#ch03tab1) 中输入的数字填入每个 `ImageSprite` 的 X 和 Y 属性文本框中。
- en: '**Table 3-1:** Initial `X` and `Y` Property Values for “Fruit Loot” `ImageSprite`s
    on a 450-pixel-wide screen'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 450 像素宽屏幕上“Fruit Loot” `ImageSprite` 的初始 `X` 和 `Y` 属性值'
- en: '| **ImageSprite** | **X property** | **Y property** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **ImageSprite** | **X 属性** | **Y 属性** |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `FruitSprite1` | 10 | 0 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `FruitSprite1` | 10 | 0 |'
- en: '| `FruitSprite2` | 230 | 0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `FruitSprite2` | 230 | 0 |'
- en: '| `FruitSprite3` | 440 | 0 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `FruitSprite3` | 440 | 0 |'
- en: '| `PickerSprite` | 180 | 150 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `PickerSprite` | 180 | 150 |'
- en: Now you’re ready to add and adjust the non-visible components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好添加和调整非可见组件了。
- en: '**ADDING AND PREPARING NON-VISIBLE COMPONENTS**'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加和准备非可见组件**'
- en: From the Media drawer, drag in a Sound component, and from the Sensors drawer,
    drag in a Clock component. In the Components pane, click the Sound component,
    and in the Properties pane, set the media clip that it will play by clicking the
    text box under **Source** and uploading the *clunk.mp3* file that comes with the
    book resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从媒体抽屉中拖入一个声音组件，从传感器抽屉中拖入一个时钟组件。在组件面板中点击声音组件，然后在属性面板中，通过点击 **Source** 下的文本框，上传与书本资源一同提供的
    *clunk.mp3* 文件，设置它播放的媒体剪辑。
- en: Then click the Clock, replace its default `TimerInterval` property by entering
    150, and unclick the checkbox under TimerEnabled so the timer won’t start when
    the app opens. Shortly, we’ll program the blocks to enable the timer once the
    player clicks `StartBtn`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击时钟（Clock），将其默认的 `TimerInterval` 属性替换为 150，并取消选中 TimerEnabled 下的复选框，以便定时器在应用程序打开时不会启动。稍后，我们将编写代码块，在玩家点击
    `StartBtn` 后启用定时器。
- en: At this point, your screen should look like [Figure 3-2](ch03.xhtml#ch3fig2).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的屏幕应该像 [图 3-2](ch03.xhtml#ch3fig2) 那样显示。
- en: '![Image](../images/03fig02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig02.jpg)'
- en: '*Figure 3-2: The Viewer and Component panes after we lay out “Fruit Loot”*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：我们布局“Fruit Loot”后的查看器和组件面板*'
- en: Once your screen looks like it should, click the Canvas in the Components pane,
    and unclick the checkbox under **Visible**. This way, none of the `ImageSprite`s
    should show when the app opens. Next, we’ll program the blocks to make these components,
    `LeftBtn` and `RightBtn`, visible once the player clicks `StartBtn`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的屏幕看起来正常，点击组件面板中的画布（Canvas），然后取消选中 **Visible** 下的复选框。这样，应用程序打开时，`ImageSprite`
    将不会显示。接下来，我们将编写代码块，使得玩家点击 `StartBtn` 后，`LeftBtn` 和 `RightBtn` 这两个组件变得可见。
- en: '**PROGRAMMING “FRUIT LOOT” IN THE BLOCKS EDITOR**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在代码块编辑器中编程“Fruit Loot”**'
- en: Now that you’ve laid out all the components, you can move to the Blocks Editor
    to program the app. For “Fruit Loot” we’ll program 10 event handlers. Three respond
    to events generated by the user’s button clicks. One directs the app’s action
    after a timer goes off at the time interval we’ve set. The rest respond to `ImageSprite`s
    reaching the edge of the `Canvas` or colliding with one another.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经布局好了所有组件，可以转到代码块编辑器编程应用程序了。对于“Fruit Loot”，我们将编写 10 个事件处理程序。三个处理由用户点击按钮产生的事件。一个在定时器按照我们设定的时间间隔触发后，控制应用程序的行为。其余的则响应
    `ImageSprite` 到达画布边缘或相互碰撞的事件。
- en: You’ll notice that most of the event handlers contain duplicate code. We’re
    programming them this way because you haven’t yet learned the advanced programming
    structures that would eliminate the repetition. As you learn about those structures
    in later chapters, we’ll be able to revisit the “Fruit Loot” code and *refactor*
    it, which means to restructure and improve it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，大多数事件处理程序都包含重复的代码。我们之所以这样编程，是因为你还没有学习到能够消除重复的高级编程结构。当你在后续章节中学习这些结构时，我们可以重新审视“Fruit
    Loot”代码并进行 *重构*，即重新组织并改进它。
- en: Click the **Blocks** button to switch to the Blocks Editor, and let’s begin
    programming the five steps of “Fruit Loot” in order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Blocks**按钮切换到块编辑器，然后按照顺序开始编写“Fruit Loot”的五个步骤。
- en: '**STEP 1: STARTING THE GAME**'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤1：开始游戏**'
- en: We start by telling the app what to do when the player clicks `StartBtn`. That’s
    when we want the `StartBtn` to disappear, the `Canvas` with its `ImageSprite`s
    and `BottomArrangement` with its `Button`s to appear, and the `Clock`’s timer
    to begin to fire.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先告诉应用程序当玩家点击`StartBtn`时要做什么。这时我们希望`StartBtn`消失，包含`ImageSprite`的`Canvas`以及包含`Button`的`BottomArrangement`出现，并且`Clock`的计时器开始触发。
- en: Here is the button click event handler with its four setter blocks that do what
    we want in step 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按钮点击事件处理程序及其四个设置块，它们在步骤1中执行我们需要的操作。
- en: '![Image](../images/f0045-01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0045-01.jpg)'
- en: In the Blocks pane, click StartBtn and, when the blocks for the component appear,
    drag the whenStartBtn.Click event handler block ➊ to the Viewer. Then, in the
    Blocks pane, click StartBtn again, and drag its setStartBtn.Visibleto block ➋
    into the whenStartBtn.Click block next to the word `do`. Next, in the Blocks pane,
    click the **Logic** blocks drawer, drag the false block ➌ to the Viewer, and snap
    it to the right side of the setStartBtn.Visibleto block. These blocks set `StartBtn`’s
    `Visible` property to `false` so that it disappears after the player clicks the
    start button.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在块面板中，点击StartBtn，当该组件的块出现时，将whenStartBtn.Click事件处理程序块➊拖到查看器中。然后，在块面板中再次点击StartBtn，将其setStartBtn.Visibleto块➋拖到`whenStartBtn.Click`块中的`do`一词旁边。接下来，在块面板中点击**Logic**块抽屉，将false块➌拖到查看器中，并将其放在setStartBtn.Visibleto块的右侧。这些块将`StartBtn`的`Visible`属性设置为`false`，使得在玩家点击开始按钮后它消失。
- en: Next, click Canvas1, drag the setCanvas1.Visibleto block ➍ to the Viewer, and
    snap it inside the whenStartBtn.Click block under the `setStartBtn.Visibleto`
    block. Then, in the Blocks pane, click the **Logic** blocks drawer again, drag
    the true block ➎ to the Viewer, and snap it to the right side of the setCanvas1.Visibleto
    block. These blocks set the `Visible` property for `Canvas1` and its contents
    to `true` so the `ImageSprite`s will appear after the player clicks the start
    button.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击Canvas1，将setCanvas1.Visibleto块➍拖到查看器中，并将其放入`setStartBtn.Visibleto`块下的whenStartBtn.Click块内。然后，在块面板中再次点击**Logic**块抽屉，将true块➎拖到查看器中，并将其放在setCanvas1.Visibleto块的右侧。这些块将`Canvas1`及其内容的`Visible`属性设置为`true`，以便在玩家点击开始按钮后，`ImageSprite`会出现。
- en: Then, click BottomArrangement in the Blocks pane, drag the setBottomArrangement.Visibleto
    block ➏ to the Viewer, and snap it inside the whenStartBtn.Click block under the
    `setCanvas1.Visibleto` block. Then click the **Logic** blocks drawer again, drag
    another true block ➐ to the Viewer, and snap it to the right side of the setBottomArrangement.Visibleto
    block. These blocks set the `Visible` property for `BottomArrangement` to `true`,
    making the buttons inside of it appear after the player clicks the start button.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在块面板中点击BottomArrangement，将setBottomArrangement.Visibleto块➏拖到查看器中，并将其放入`whenStartBtn.Click`块下的`setCanvas1.Visibleto`块内。然后再次点击**Logic**块抽屉，将另一个true块➐拖到查看器中，并将其放在setBottomArrangement.Visibleto块的右侧。这些块将`BottomArrangement`的`Visible`属性设置为`true`，使得其中的按钮在玩家点击开始按钮后显示出来。
- en: Finally, click Clock1, drag the setClock1.TimerEnabledto block ➑ to the Viewer,
    and snap it inside the whenStartBtn.Click block under the `setBottomArrangement.Visibleto`
    block. Then, in the Blocks pane, drag another true block ➒ from the **Logic**
    blocks drawer, and snap it to the right side of the setClock1.TimerEnabledto block.
    These blocks set the value of `Clock1`’s `TimerEnabled` property to `true`. This
    starts `Clock1`’s timer, which will move the fruit `ImageSprite`s down the `Canvas`
    the entire time the game is in play.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击Clock1，将setClock1.TimerEnabledto块➑拖到查看器中，并将其放入`whenStartBtn.Click`块下的`setBottomArrangement.Visibleto`块内。然后，在块面板中，从**Logic**块抽屉中再拖动一个true块➒，将其放在setClock1.TimerEnabledto块的右侧。这些块将`Clock1`的`TimerEnabled`属性的值设置为`true`。这将启动`Clock1`的计时器，在游戏进行时，`ImageSprite`的水果会沿着`Canvas`移动。
- en: Together, the blocks for step 1 start the game. In sum, when the player clicks
    the start button, the blocks set `StartBtn`’s `Visible` property to `false`, set
    the `Visible` properties of the `Canvas` with `ImageSprite`s and the `HorizontalArrangement`
    with play buttons to `true`, and set the `Clock`’s `TimerEnabled` property to
    `true`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一起使用的第1步模块启动游戏。总的来说，当玩家点击开始按钮时，这些模块将`StartBtn`的`Visible`属性设置为`false`，将包含`ImageSprite`的`Canvas`和包含播放按钮的`HorizontalArrangement`的`Visible`属性设置为`true`，并将`Clock`的`TimerEnabled`属性设置为`true`。
- en: To see how these blocks work, live-test with a device, as outlined in “Live-Testing
    Your Apps” on [page xxii](intro.xhtml#page_xxii). Once you click **Connect** ▸
    **AI Companion** in the top menu bar and scan the QR code with your device’s Companion
    app, your “Fruit Loot” game should open on your device. As long as your blocks
    are placed as shown in the code examples, you should see the start button until
    you click it, when it disappears as the other game components appear. For now,
    nothing else should happen. Leave the game open on your device to keep live-testing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些模块如何工作，请按照“实时测试您的应用程序”中[第xxii页](intro.xhtml#page_xxii)的说明，使用设备进行实时测试。一旦你点击顶部菜单栏中的**连接**
    ▸ **AI伴侣**并用设备的伴侣应用扫描二维码，你的“水果战利品”游戏应该会在设备上打开。只要你的模块按代码示例中的方式放置，你应该能看到开始按钮，直到你点击它，按钮会消失，其他游戏组件随之出现。现在，暂时不应该有其他事情发生。保持游戏在你的设备上打开，以继续实时测试。
- en: '**STEP 2: MAKING FRUIT DROP AT RANDOM**'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第2步：让水果随机掉落**'
- en: Now let’s program step 2 of the app and tell it what to do each time the `Clock`’s
    timer fires. This is when we want the fruit to drop at varying speeds every 150
    milliseconds—the `TimerInterval` we set in the Property pane in the Designer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编程应用程序的第2步，并告诉它每次`Clock`计时器触发时应该做什么。这是我们希望水果以不同速度每150毫秒掉落一次——这是我们在设计器的属性面板中设置的`TimerInterval`。
- en: '![Image](../images/f0046-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0046-01.jpg)'
- en: In the Blocks pane, click Clock1 and, when the blocks for the component appear,
    drag the whenClock1.Timer block ➊ to the Viewer. Then, in the Blocks pane, click
    FruitSprite1, drag the callFruitSprite1.MoveTo method block ➋ to the Viewer, and
    snap it inside the whenClock1.Timer block next to the word `do`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块面板中，点击Clock1，当该组件的模块出现时，拖动whenClock1.Timer块 ➊到查看器中。然后，在模块面板中，点击FruitSprite1，拖动调用FruitSprite1.MoveTo方法块
    ➋到查看器中，并将其固定在whenClock1.Timer块的`do`旁边。
- en: '**NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In both the Components pane in the Designer and the Blocks pane in the Blocks
    Editor, if you don’t see a component that you’ve nested within a parent component—for
    example, an ImageSprite placed on a Canvas or a Button dragged within a HorizontalArrangement—you’ll
    find it by clicking the plus sign to the left of the parent.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*在设计器中的组件面板和模块编辑器中的模块面板中，如果你没有看到你嵌套在父组件中的组件——例如，放置在画布上的ImageSprite或拖动到水平排列中的按钮——你可以通过点击父组件左侧的加号来找到它。*'
- en: '**Setting X and Y Values for FruitSprite1**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为FruitSprite1设置X和Y值**'
- en: Let’s look closer at the `callFruitSprite1.MoveTo` method block we’ve placed
    within the `Clock1 Timer` event handler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们放置在`Clock1 Timer`事件处理程序中的`callFruitSprite1.MoveTo`方法块。
- en: '![Image](../images/f0047-01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-01.jpg)'
- en: You’ll notice that the block requires us to insert values for its `x` and `y`
    *method parameters*, which are pieces of information the method must have to operate.
    This means the `ImageSprite`’s `MoveTo` method cannot move `FruitSprite1` until
    we supply *arguments*, or values, for the x- and y-coordinates of the point where
    we want the `ImageSprite` to move.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，块要求我们为它的`x`和`y`*方法参数*插入值，这些是方法操作所必需的信息。这意味着，`ImageSprite`的`MoveTo`方法在我们提供*参数*或值，指定我们希望`ImageSprite`移动到的坐标点的x和y坐标之前，不能移动`FruitSprite1`。
- en: For our “Fruit Loot” game, we want the fruit `ImageSprite`s to move down only,
    meaning we’ll change their y-coordinates but not their x-coordinates. To keep
    the same `X` value, click FruitSprite1, drag its FruitSprite1.X getter block ➊
    to the Viewer, and snap it into the method block’s x socket. This tells the app
    that, when it moves `FruitSprite1`, it should get the current `X` value for `FruitSprite1`
    and keep that `X` value the same.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的“水果战利品”游戏，我们希望水果`ImageSprite`只向下移动，这意味着我们将改变它们的y坐标，但不改变它们的x坐标。为了保持相同的`X`值，点击FruitSprite1，拖动它的FruitSprite1.X获取块
    ➊到查看器中，并将其固定到方法块的x插槽中。这告诉应用程序，在移动`FruitSprite1`时，它应该获取`FruitSprite1`的当前`X`值，并保持该`X`值不变。
- en: To provide the argument for the y-coordinate of the point where we want `FruitSprite1`
    to move, click the **Math** blocks drawer, drag out an addition operator block
    ➋, and snap it into the method block’s y socket. Then, click FruitSprite1 and
    drag its FruitSprite1.Y getter block ➌ into the addition block’s left socket,
    and click the **Math** blocks drawer and drag a `random integer` block ➍ into
    the addition block’s right socket. This tells the app that, when it moves `FruitSprite1`,
    it should increase the current value of its y-coordinate by a random number of
    pixels to move the `ImageSprite` down the `Canvas`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们希望 `FruitSprite1` 移动到的点的 y 坐标提供参数，请点击 **Math** 块抽屉，拖出一个加法运算符块 ➋，并将其插入方法块的
    y 插槽。然后，点击 `FruitSprite1` 并将其 `FruitSprite1.Y` 获取器块 ➌ 拖到加法块的左插槽，再点击 **Math** 块抽屉并将一个
    `random integer` 块 ➍ 拖到加法块的右插槽。这告诉应用，当它移动 `FruitSprite1` 时，应将其当前的 y 坐标值增加一个随机数量的像素，以便将
    `ImageSprite` 向下移动。
- en: '**Dropping FruitSprite1 at Random Speeds**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**以随机速度下落 `FruitSprite1`**'
- en: The `random integer` block generates the random number of pixels—from between
    the specified range of 15 to 50—that we want `FruitSprite1` to fall.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`random integer` 块生成我们希望 `FruitSprite1` 下落的随机像素数——在指定的范围15到50之间。'
- en: '![Image](../images/f0047-02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-02.jpg)'
- en: To set that range of numbers in the `random integer` block, click the default
    1 in its left socket and replace it by entering 15, and click the default 100
    in its right socket and replace it by entering 50.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `random integer` 块中设置这个数字范围，点击其左插槽中的默认值1并替换为15，然后点击其右插槽中的默认值100并替换为50。
- en: Now, altogether, our `callFruitSprite1.MoveTo` method block with the `x` and
    `y` parameters we’ve set tells the app that, when it moves `FruitSprite1`, we
    want the `ImageSprite`’s `X` value to stay the same and its `Y` value to move
    from its current y-coordinate down a random number of pixels between 15 and 50\.
    This randomness ensures that the `ImageSprite`’s speed will be unpredictable,
    because, when the `Clock`’s timer fires every 150 milliseconds, `FruitSprite1`
    will travel at a speed anywhere from a slower 15 pixels per 150 milliseconds (100
    pixels per second) to a faster 50 pixels per 150 milliseconds (333 pixels per
    second).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，总的来说，我们的 `callFruitSprite1.MoveTo` 方法块和我们设置的 `x` 和 `y` 参数告诉应用，当它移动 `FruitSprite1`
    时，我们希望 `ImageSprite` 的 `X` 值保持不变，而其 `Y` 值从当前的 y 坐标向下移动一个随机数量的像素，范围在15到50之间。这种随机性确保了
    `ImageSprite` 的速度是不可预测的，因为每当 `Clock` 的定时器每150毫秒触发时，`FruitSprite1` 将以一个从较慢的15像素/150毫秒（100像素/秒）到较快的50像素/150毫秒（333像素/秒）之间的速度移动。
- en: '**Copying Blocks for FruitSprite2 and FruitSprite3**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复制 `FruitSprite2` 和 `FruitSprite3` 的块**'
- en: To complete the blocks for step 2, we now can copy the `callFruitSprite1.MoveTo`
    block and adjust it for `FruitSprite2` and `FruitSprite3`. Right-click the callFruitSprite1.MoveTo
    method block to duplicate it for FruitSprite2, and snap the duplicate in under
    the original.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成步骤2的块，我们现在可以复制 `callFruitSprite1.MoveTo` 块并调整它用于 `FruitSprite2` 和 `FruitSprite3`。右键点击
    `callFruitSprite1.MoveTo` 方法块以复制它用于 `FruitSprite2`，并将复制块插入到原始块的下方。
- en: '![Image](../images/f0048-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0048-01.jpg)'
- en: In the duplicate blocks, use the drop-down arrows ➊ in the callFruitSprite1.MoveTo,
    FruitSprite1.X, and FruitSprite1.Y blocks to change to FruitSprite2. Also change
    the number in the left `random integer` block socket to 5. These blocks now program
    `FruitSprite2` to move down some unknown number of pixels between 5 and 50 when
    the `Clock`’s timer fires every 150 milliseconds.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制的块中，使用 `callFruitSprite1.MoveTo`、`FruitSprite1.X` 和 `FruitSprite1.Y` 块中的下拉箭头
    ➊ 来切换为 `FruitSprite2`。同时，将左侧 `random integer` 块插槽中的数字更改为5。这些块现在将 `FruitSprite2`
    编程为在 `Clock` 的定时器每150毫秒触发时，向下移动一个在5到50之间的未知像素数。
- en: Next, right-click the callFruitSprite1.MoveTo block, make another copy to use
    for `FruitSprite3`, and snap the duplicate in under the callFruitSprite2.MoveTo
    block.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，右键点击 `callFruitSprite1.MoveTo` 块，再次复制它以供 `FruitSprite3` 使用，并将复制块插入到 `callFruitSprite2.MoveTo`
    块的下方。
- en: '![Image](../images/f0048-02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0048-02.jpg)'
- en: In the duplicate, use the drop-down arrows ➋ in the callFruitSprite1.MoveTo,
    FruitSprite1.X, and FruitSprite1.Y blocks to change to FruitSprite3, and change
    the number in the `random integer` block’s left socket to 25. These blocks program
    `FruitSprite3` to move down a random number of pixels between 25 and 50 every
    150 milliseconds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制块中，使用 `callFruitSprite1.MoveTo`、`FruitSprite1.X` 和 `FruitSprite1.Y` 块中的下拉箭头
    ➋ 来切换为 `FruitSprite3`，并将 `random integer` 块左插槽中的数字更改为25。这些块将 `FruitSprite3` 编程为每150毫秒下落一个在25到50之间的随机像素数。
- en: Now the blocks for step 2 should move the three fruit `ImageSprite`s down the
    `Canvas` every 150 milliseconds at random speeds.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第二步的模块应该使三个水果 `ImageSprite` 每隔 150 毫秒以随机速度向下移动 `Canvas`。
- en: Live-test to see how these blocks work. When you click `StartBtn`, you should
    see the three fruit `ImageSprite`s drop to the bottom of the screen, where they
    stay and all movement stops. If any `ImageSprite` fails to move, you need to debug.
    In this instance, you may not have changed your references to the correct `ImageSprite`
    when you duplicated the `MoveTo` blocks. Make any necessary corrections, and test
    again. Once step 2 is working, move to the next step, where we’ll tell the game
    what to do when the fruit `ImageSprite`s reach the bottom of the `Canvas`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进行实时测试，看看这些模块如何工作。当你点击 `StartBtn` 时，你应该能看到三个水果 `ImageSprite` 下落到屏幕底部，然后停在那里，所有的运动停止。如果任何
    `ImageSprite` 没有移动，你需要进行调试。在这种情况下，当你复制 `MoveTo` 模块时，可能没有将其引用更改为正确的 `ImageSprite`。做出必要的更正后，再次测试。一旦第二步工作正常，继续进行下一步，我们将告诉游戏当水果
    `ImageSprite` 到达 `Canvas` 底部时该怎么办。
- en: '**STEP 3: CREATING MORE FALLING FRUIT AND COUNTING DROPPED FRUIT**'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 3：创建更多下落的水果并计算掉落的水果**'
- en: Let’s now program step 3 of the app. In this part, when a fruit `ImageSprite`
    reaches the bottom edge of the `Canvas`, we want the app to move the `ImageSprite`
    back up to a random point along the very top of the `Canvas`, have the `ImageSprite`
    display a random picture of fruit, and add 1 to the total number of times an `ImageSprite`
    hits the edge.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写应用程序的第三步。在这部分，当水果 `ImageSprite` 到达 `Canvas` 底边时，我们希望应用将 `ImageSprite`
    移动到 `Canvas` 顶部的一个随机位置，并显示一个随机的水果图片，同时将水果碰到边缘的次数加 1。
- en: We’ll use a global variable to store and update that total number, and we’ll
    start our code for this step by creating and initializing that variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个全局变量来存储和更新该总数，并通过创建和初始化该变量来开始编写此步骤的代码。
- en: '![Image](../images/f0049-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0049-01.jpg)'
- en: Click the **Variables** blocks drawer and drag an initialize global name block
    to the Viewer. Click name and replace it with the name of our variable, fruitsDropped.
    Then drag a 0 number block from the **Math** drawer and snap it to the right side
    of the initialize global fruitsDropped block. This declares and initializes the
    variable you’ll use to store and update the total number of pieces of fruit dropped
    in your game. Because the variable is global and can be used by all your event
    handlers, it stands alone in the code, outside of all your event handler blocks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**变量**模块抽屉，拖动一个初始化全局名称块到查看器中。点击名称并将其替换为我们的变量名 fruitsDropped。然后，从**数学**模块中拖动一个数字
    0 块，将其固定在初始化全局 fruitsDropped 块的右侧。这声明并初始化了你将用于存储和更新游戏中掉落的水果总数的变量。因为该变量是全局的，可以被所有事件处理程序使用，所以它独立存在于代码中，位于所有事件处理程序块之外。
- en: Now let’s program the event handler for this step. Here are the blocks that
    handle this `EdgeReached` event for `FruitSprite1`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写此步骤的事件处理程序。以下是处理 `FruitSprite1` 的 `EdgeReached` 事件的模块。
- en: '![Image](../images/f0049-02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0049-02.jpg)'
- en: In the Blocks pane, click FruitSprite1 and, when the blocks for the component
    appear, drag the whenFruitSprite1.EdgeReached block ➊ to the Viewer. Then, in
    the Blocks pane, click FruitSprite1 again, drag the setFruitSprite1.Y block ➋
    to the Viewer, and snap it inside the whenFruitSprite1.EdgeReached block next
    to the word `do`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块窗格中，点击 FruitSprite1，当该组件的模块出现时，将 whenFruitSprite1.EdgeReached 块 ➊ 拖到查看器中。然后，在模块窗格中再次点击
    FruitSprite1，拖动 setFruitSprite1.Y 块 ➋ 到查看器，并将其固定在 whenFruitSprite1.EdgeReached
    块的 `do` 旁边。
- en: Then, click the **Math** blocks drawer, drag a 0 number block ➌ to the Viewer,
    and snap it to the right of the setFruitSprite1.Y block. So far, once `FruitSprite1`
    reaches the edge of the `Canvas`, these blocks move `FruitSprite1` right back
    up to y-coordinate 0, which is the very top of the `Canvas`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击**数学**模块抽屉，拖动一个数字 0 块 ➌ 到查看器，并将其固定在 setFruitSprite1.Y 块的右侧。到目前为止，一旦 `FruitSprite1`
    到达 `Canvas` 的边缘，这些块会将 `FruitSprite1` 向右移动到 y 坐标 0，这正是 `Canvas` 的顶部。
- en: '**Moving Fallen Fruit Back Up to a Random Place**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将掉落的水果移回到随机位置**'
- en: We now need to make sure the code also moves `FruitSprite1` to an unpredictable
    x-coordinate using setter blocks, which keeps your game interesting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要确保代码还会使用设置器块将 `FruitSprite1` 移动到一个不可预测的 x 坐标，这样可以保持游戏的趣味性。
- en: '![Image](../images/f0049-03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0049-03.jpg)'
- en: In the Blocks pane, click the FruitSprite1 component, drag the setFruitSprite1.X
    block ➊ to the Viewer, and snap it inside the whenFruitSprite1.EdgeReached block
    under the `setFruitSprite1.Y` block. Then, click the **Math** blocks drawer, snap
    a `random integer` block ➋ to the right of the setFruitSprite1.X block, and click
    the default 1 in the `random integer` block’s left socket and replace it by entering
    10. Then, delete the default 100 in the `random integer` block’s right socket,
    and replace it with a multiplication operator block ➌, also from the Math drawer.
    Next, in the Blocks pane, click the Canvas1 component, drag the Canvas1.Width
    getter block ➍ to the Viewer, and snap it into the multiplication block’s left
    socket; then, drag a 0 number block ➎ from the **Math** drawer to the Viewer,
    click its default 0, replace it by entering 0.3, and then snap the 0.3 number
    block into the multiplication block’s right socket.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在“积木”面板中，点击 FruitSprite1 组件，将 setFruitSprite1.X 积木 ➊ 拖到视图区，并将其放置在 `setFruitSprite1.Y`
    积木下的 whenFruitSprite1.EdgeReached 积木内部。接着，点击 **数学** 积木抽屉，将一个 `random integer`
    积木 ➋ 拖到 setFruitSprite1.X 积木的右侧，并点击 `random integer` 积木左侧插槽中的默认值 1，将其替换为 10。然后，删除
    `random integer` 积木右侧插槽中的默认值 100，替换为一个乘法运算符积木 ➌，该积木同样来自数学抽屉。接下来，在“积木”面板中，点击 Canvas1
    组件，将 Canvas1.Width 获取器积木 ➍ 拖到视图区，并将其插入到乘法积木的左侧插槽；然后，从 **数学** 积木抽屉拖入一个数字 0 积木 ➎
    到视图区，点击其默认值 0，替换为输入 0.3，并将 0.3 数字积木插入乘法积木的右侧插槽。
- en: These blocks set the `X` value for `FruitSprite1` once it reaches the edge of
    the `Canvas`. To avoid collisions with other fruit `ImageSprite`s, we want this
    first fruit `ImageSprite` to drop somewhere in the left third of the `Canvas`
    only. These blocks ensure that by setting the new `X` position to a random number
    of pixels between 10 and the width of the `Canvas` multiplied by 0.3, which is
    a little less than one-third of the `Canvas` width. For instance, if the width
    of the `Canvas` is 450 pixels, the new `X` position will be anywhere between 10
    and (450 × 0.3) pixels, which equals 135 pixels.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些积木设置了当 `FruitSprite1` 到达 `Canvas` 边缘时的 `X` 值。为了避免与其他水果 `ImageSprite` 发生碰撞，我们希望第一个水果
    `ImageSprite` 只会掉落在 `Canvas` 的左三分之一区域。通过这些积木，我们确保了这一点，它们将新的 `X` 位置设置为一个随机数，这个随机数介于
    10 和 `Canvas` 宽度乘以 0.3 之间，这个值略小于 `Canvas` 宽度的三分之一。例如，如果 `Canvas` 的宽度是 450 像素，那么新的
    `X` 位置将介于 10 和 (450 × 0.3) 像素之间，即 135 像素。
- en: '**Dropping Random Fruit Images**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**掉落随机水果图片**'
- en: Next, to keep your game unpredictable, you need to make sure the code randomly
    changes the type of fruit dropped after `FruitSprite1` moves back up to the top
    of the `Canvas`. To do this, you’ll use setter blocks that set the `Picture` property
    for `FruitSprite1` to a random image.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了保持游戏的不可预测性，你需要确保代码在 `FruitSprite1` 移动回 `Canvas` 顶部后随机改变掉落的水果类型。为此，你将使用设置器积木，将
    `FruitSprite1` 的 `Picture` 属性设置为一张随机图片。
- en: '![Image](../images/f0050-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0050-01.jpg)'
- en: Click the FruitSprite1 component in the Blocks pane, drag the setFruitSprite1.Picture
    block ➊ to the Viewer, and snap it inside the whenFruitSprite1.EdgeReached block
    under the `setFruitSprite1.X` block. Then, click the **Text** blocks drawer, drag
    a `join` block ➋ to the Viewer, and snap it to the right of the setFruitSprite1.Picture
    block, which will allow you to set the name for the picture by joining two strings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在“积木”面板中，点击 FruitSprite1 组件，将 setFruitSprite1.Picture 积木 ➊ 拖到视图区，并将其放置在 `setFruitSprite1.X`
    积木下的 whenFruitSprite1.EdgeReached 积木内部。接着，点击 **文本** 积木抽屉，拖入一个 `join` 积木 ➋ 到视图区，并将其放置在
    setFruitSprite1.Picture 积木的右侧，这样你就可以通过连接两个字符串来设置图片的名称。
- en: For the `join` block’s top input, drag in another `random integer` block ➌ from
    the Math blocks drawer, click the default 100 in its right socket, and replace
    it by entering 3. For the `join` block’s second input, drag in an empty string
    block ➍, the first block in the Text blocks drawer. Then click the string block’s
    text area and enter .png.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `join` 积木的第一个输入，将另一个 `random integer` 积木 ➌ 从数学积木抽屉拖入，点击其右侧插槽中的默认值 100，将其替换为
    3。对于 `join` 积木的第二个输入，将一个空字符串积木 ➍ 从文本积木抽屉中拖入。然后点击字符串积木的文本区域，输入 .png。
- en: These blocks set the name of the image to use as the picture source for `FruitSprite1`
    after it reaches the `Canvas` edge. Since we’ve named the three uploaded fruit
    images *1.png*, *2.png*, and *3.png*, we can use the `random integer` block to
    generate the number 1, 2, or 3 that is part of the image name. This should make
    the app continually display a randomly selected image on `FruitSprite1` each time
    it drops from the top of the `Canvas`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块在`FruitSprite1`到达`Canvas`边缘后，设置使用的图片源的名称。由于我们上传的三张水果图片分别命名为*1.png*、*2.png*和*3.png*，我们可以使用`random
    integer`块来生成数字1、2或3，作为图片名称的一部分。这样，应用程序每次水果从`Canvas`的顶部掉下时，都会随机选择一张图片显示在`FruitSprite1`上。
- en: '**Making Sure Fruit is Visible**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**确保水果可见**'
- en: We also need to make sure `FruitSprite1` and the other fruit `ImageSprite`s
    are visible once they move back up to the top of the `Canvas`, because later we’ll
    make them invisible if they hit the picker `ImageSprite`. Here is the setter block
    that turns the `Visible` property on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保`FruitSprite1`和其他水果`ImageSprite`在它们返回到`Canvas`顶部时可见，因为稍后如果它们与选择器`ImageSprite`碰撞，我们会让它们变得不可见。以下是设置`Visible`属性为可见的设置块。
- en: '![Image](../images/f0051-01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0051-01.jpg)'
- en: Click FruitSprite1, drag the setFruitSprite1.Visibleto block ➊ to the Viewer,
    and snap it inside the whenFruitSprite1.EdgeReached block under the `setFruitSprite1.Pictureto`
    block. Then, in the Blocks pane, click the **Logic** blocks drawer, drag the true
    block ➋ to the Viewer, and snap it to the right side of the setFruitSprite1.Visibleto
    block. These blocks reset the `ImageSprite`’s `Visible` property to `true` in
    case it collides with the picker `ImageSprite`, after which our blocks in step
    5 will set it to `false`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 点击FruitSprite1，将setFruitSprite1.Visibleto块➊拖到Viewer中，并将其嵌入到`setFruitSprite1.Pictureto`块下的whenFruitSprite1.EdgeReached块内。然后，在块面板中，点击**逻辑**块抽屉，拖动true块➋到Viewer中，并将其嵌入到setFruitSprite1.Visibleto块的右侧。这些块将在水果与选择器`ImageSprite`碰撞时将`ImageSprite`的`Visible`属性重置为`true`，然后我们的第5步中的块会将其设置为`false`。
- en: '**Counting the Number of Fruits Dropped**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算掉落的水果数量**'
- en: Finally, we need to program the app to keep track of how many fruits are dropped.
    Each time a fruit `ImageSprite` hits the bottom of the `Canvas`, the game should
    add 1 to the value of `fruitsDropped`, which is the variable that keeps track
    of the number of times an `ImageSprite` hits the edge. The following blocks increment
    the value of `fruitsDropped`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编程让应用程序跟踪掉落的水果数量。每当水果`ImageSprite`撞击到`Canvas`底部时，游戏应该将1添加到`fruitsDropped`的值中，这个变量用于跟踪`ImageSprite`撞击到边缘的次数。以下块会增加`fruitsDropped`的值。
- en: '![Image](../images/f0051-02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0051-02.jpg)'
- en: Mouse over the initialize global fruitsDropped block that we placed at the beginning
    of this step, drag the set global fruitsDropped block ➊ to the Viewer, and snap
    it inside the whenFruitSprite1.EdgeReached block under the `setFruitSprite1.Visibleto`
    block. Then drag an addition operator block ➋ from the Math drawer and snap it
    to the right of the set global fruitsDropped block. Fill that addition block’s
    sockets by mousing over the initialize global fruitsDropped block, dragging the
    get global fruitsDropped block ➌ into the addition block’s left socket, and dragging
    a 1 number block ➍ from the Math drawer into the addition block’s right socket.
    These blocks keep track of the game’s total number of fruits dropped by adding
    1 to the current value of the `fruitsDropped` variable each time `FruitSprite1`
    reaches the edge of the `Canvas`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标悬停在我们在此步骤开始时放置的初始化全局变量fruitsDropped块上，将设置全局变量fruitsDropped块➊拖动到Viewer中，并将其嵌入到`setFruitSprite1.Visibleto`块下的whenFruitSprite1.EdgeReached块内。然后，从数学抽屉中拖动一个加法运算符块➋，并将其嵌入到设置全局变量fruitsDropped块的右侧。通过将鼠标悬停在初始化全局变量fruitsDropped块上，拖动获取全局变量fruitsDropped块➌到加法块的左侧插槽，并从数学抽屉中拖动一个数字1块➍到加法块的右侧插槽。这些块通过每次`FruitSprite1`到达`Canvas`边缘时，将1添加到`fruitsDropped`变量的当前值，来跟踪游戏中掉落的水果总数。
- en: '**Copying Blocks for FruitSprite2 and FruitSprite3**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复制块以支持FruitSprite2和FruitSprite3**'
- en: Our final task for step 3 is to duplicate our code to program similar `EdgeReached`
    event handlers for `FruitSprite2` and `FruitSprite3`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步的最后任务是复制代码，为`FruitSprite2`和`FruitSprite3`编程类似的`EdgeReached`事件处理程序。
- en: For `FruitSprite2`, right-click the whenFruitSprite1.EdgeReached block and select
    **duplicate**. When you make this duplicate, you’ll see a red X appear to the
    left of the word `when` in both the original and duplicate event handlers. This
    red X warns you that you have two event handlers for the same event, which is
    not allowed. Once you change the duplicate handler’s event, the red X should disappear.
    To change the event, use the drop-down arrow in every block where you see `FruitSprite1`
    and change to FruitSprite2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `FruitSprite2`，右键点击 whenFruitSprite1.EdgeReached 块并选择 **duplicate**。当你复制该块时，你会看到在原始和复制的事件处理程序中的
    `when` 左侧出现一个红色 X，这个红色 X 警告你有两个相同事件的事件处理程序，这是不允许的。一旦你改变复制处理程序的事件，红色 X 应该会消失。要更改事件，请在每个包含
    `FruitSprite1` 的块中使用下拉箭头，并将其更改为 `FruitSprite2`。
- en: The only other adjustment we need to make is to set an `X` property for `FruitSprite2`
    that avoids collisions with the other fruit `ImageSprite`s when it moves down
    the `Canvas`. To accomplish this, make sure this second fruit `ImageSprite` consistently
    drops somewhere in the middle third of the `Canvas` by changing the `FruitSprite2
    X` value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的唯一其他调整是为`FruitSprite2`设置一个`X`属性，以避免在它沿着`Canvas`向下移动时与其他水果`ImageSprite`发生碰撞。为此，通过改变`FruitSprite2
    X`的值，确保第二个水果`ImageSprite`始终掉落在`Canvas`的中间三分之一区域。
- en: '![Image](../images/f0052-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0052-01.jpg)'
- en: '**NOTE**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*App Inventor provides a way for you to display the random integer, join, and
    other blocks that require multiple inputs with either inline inputs, as shown
    in the random integer block inside the FruitSprite1 setter, or external inputs,
    as shown in the random integer block inside the figure’s FruitSprite2 setter,
    which takes up less horizontal space. You can right-click a block to switch between
    inline and external inputs.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*App Inventor 提供了一种方式，可以让你显示随机整数、连接以及其他需要多个输入的块，通过内联输入（如在 FruitSprite1 设置器中的随机整数块）或者外部输入（如在
    FruitSprite2 设置器中的随机整数块），后者占用的水平空间较少。你可以右键点击块来切换内联输入和外部输入。*'
- en: Replace the 10 number block in the random integer block’s top socket with a
    multiplication operator block ➊ from the Math drawer. Then fill the multiplication
    block’s sockets by clicking the Canvas1 component in the Blocks pane, dragging
    the Canvas1.Width block ➋ into its left socket, and dragging a 0.35 number block
    ➌ from the Math drawer into its right socket. Then, in the `random integer` block’s
    bottom socket, change the 0.3 number block to a 0.65 number block ➍.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个乘法运算符块 ➊ 替换随机整数块顶部插槽中的数字 10 块。然后，点击 Blocks 面板中的 Canvas1 组件，将 Canvas1.Width
    块 ➋ 拖入左侧插槽，再将 Math 组件中的 0.35 数字块 ➌ 拖入右侧插槽。接着，在 `random integer` 块的底部插槽中，将 0.3
    数字块替换为 0.65 数字块 ➍。
- en: These blocks set the new `X` position for `FruitSprite2` to a random number
    of pixels between the width of the `Canvas` multiplied by 0.35 and the width of
    the `Canvas` multiplied by 0.65, which is some random point in the middle third
    of the `Canvas`. For instance, if the width of the `Canvas` is 450 pixels, the
    new `X` position will be anywhere between 450 × 0.35 pixels, which equals 158
    pixels, and 450 × 0.65 pixels, which equals 293 pixels.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块将 `FruitSprite2` 的新 `X` 位置设置为一个随机数，范围介于 `Canvas` 宽度乘以 0.35 和 `Canvas` 宽度乘以
    0.65 之间，这个范围是在 `Canvas` 中间三分之一的某个随机点。例如，如果 `Canvas` 的宽度为 450 像素，则新的 `X` 位置将在 450
    × 0.35 像素（即 158 像素）和 450 × 0.65 像素（即 293 像素）之间的任何位置。
- en: Now, to create the `EdgeReached` event handler for `FruitSprite3`, right-click
    the whenFruitSprite2.EdgeReached block and select **duplicate**. In the duplicate
    blocks, be sure to use the drop-down arrow in every block where you see `FruitSprite2`
    and change to FruitSprite3.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建 `FruitSprite3` 的 `EdgeReached` 事件处理程序，右键点击 whenFruitSprite2.EdgeReached
    块并选择 **duplicate**。在复制的块中，请确保使用下拉箭头，在每个出现 `FruitSprite2` 的块中将其更改为 `FruitSprite3`。
- en: To avoid collisions with the other fruit `ImageSprite`s, we’ll also need to
    change the `FruitSprite3 X` value so this third fruit `ImageSprite` consistently
    drops somewhere in the right third of the `Canvas`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与其他水果`ImageSprite`发生碰撞，我们还需要修改`FruitSprite3 X`的值，使得这个第三个水果`ImageSprite`始终出现在`Canvas`的右侧三分之一区域。
- en: '![Image](../images/f0053-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0053-01.jpg)'
- en: To do this, replace the 0.35 number block in the right socket of the first multiplication
    block with a 0.7 number block ➊. Also, replace the second multiplication block
    with a subtraction operator block ➋ from the Math blocks drawer, and fill the
    subtraction block by dragging the Canvas1.Width block ➌ into its left socket and
    a 20 number block ➍ into its right socket.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，将第一个乘法模块右侧插槽中的 0.35 数字模块替换为 0.7 数字模块 ➊。然后，将第二个乘法模块替换为一个减法操作符模块 ➋，该模块来自数学模块抽屉。将减法模块的左插槽填入
    `Canvas1.Width` 模块 ➌，右插槽填入 20 数字模块 ➍。
- en: These blocks set the new `X` position of `FruitSprite3` to a random number of
    pixels between the width of the `Canvas` multiplied by 0.7 and the width of the
    `Canvas` minus 20 pixels, which is some random point in the right third of the
    `Canvas`. For instance, if the width of the `Canvas` is 450 pixels, the new `X`
    position will be anywhere between 450 × 0.7 pixels, which equals 315 pixels, and
    450 – 20 pixels, which equals 430 pixels.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块将 `FruitSprite3` 的新 `X` 位置设置为一个随机的像素数，范围在 `Canvas` 宽度乘以 0.7 和 `Canvas` 宽度减去
    20 像素之间，即 `Canvas` 右侧三分之一的某个随机点。例如，如果 `Canvas` 宽度是 450 像素，那么新的 `X` 位置将介于 450 ×
    0.7 像素（即 315 像素）和 450 – 20 像素（即 430 像素）之间。
- en: Altogether, the blocks for step 3 move each fruit `ImageSprite` to a random
    point at the very top of the `Canvas`, have that `ImageSprite` display a random
    picture of fruit, and increase the count of total fruits dropped by 1 each time
    an `ImageSprite` hits the bottom of the `Canvas`, just as we planned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，步骤 3 的模块将每个水果的 `ImageSprite` 移动到 `Canvas` 顶部的随机位置，让该 `ImageSprite` 显示一个随机的水果图片，并且每当一个
    `ImageSprite` 落到 `Canvas` 底部时，水果总数会增加 1，就像我们之前计划的那样。
- en: Now live-test the game again. This time, when you click `StartBtn`, you should
    see the three fruit `ImageSprite`s drop to the bottom of the screen continuously,
    randomly changing the image displayed. You’ll also notice that the speed at which
    each `ImageSprite` drops and its `X` location changes with each drop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次进行游戏的实测。这一次，当你点击 `StartBtn` 时，你应该能看到三个水果 `ImageSprite` 不断掉落到屏幕底部，图片会随机变化。你还会注意到每个
    `ImageSprite` 掉落的速度，以及它的 `X` 坐标随着每次掉落而发生变化。
- en: If any of the `ImageSprite`s fail to move, or if two or more appear to drop
    in the same third of the `Canvas`, debug your code. Here again, you may not have
    made the correct changes to your duplicate blocks. Make any necessary corrections,
    and test again. Once step 3 is working, let’s move to the next part, where we’ll
    program `PickerSprite`’s movement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个 `ImageSprite` 无法移动，或者两个或多个 `ImageSprite` 出现在 `Canvas` 的同一三分之一区域内，请调试你的代码。在这里，你可能没有正确修改重复的模块。做出必要的修正后，再次进行测试。一旦步骤
    3 正常工作，我们就可以进入下一部分，编程 `PickerSprite` 的移动。
- en: '**STEP 4: LETTING PLAYERS MOVE THE PICKER TO CATCH THE FRUIT**'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 4：让玩家移动接水果**'
- en: Now let’s program step 4 of the app, telling it what to do when the player clicks
    the left and right play buttons. When the player clicks `LeftBtn`, we want `PickerSprite`
    to move to the left 50 pixels, and when the player clicks `RightBtn`, we want
    `PickerSprite` to move 50 pixels to the right.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编程应用的步骤 4，告诉它当玩家点击左右播放按钮时该做什么。当玩家点击 `LeftBtn` 时，我们希望 `PickerSprite` 向左移动
    50 像素；当玩家点击 `RightBtn` 时，我们希望 `PickerSprite` 向右移动 50 像素。
- en: '![Image](../images/f0054-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0054-01.jpg)'
- en: In the Blocks pane, click LeftBtn and, when the blocks for the component appear,
    drag the whenLeftBtn.Click block ➊ to the Viewer. Then, in the Blocks pane, click
    PickerSprite, drag the callPickerSprite.MoveTo block ➋ to the Viewer, and snap
    it inside the whenLeftBtn.Click block next to the word `do`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块面板中，点击 LeftBtn，当组件的模块出现时，将 `whenLeftBtn.Click` 模块 ➊ 拖到 Viewer 中。然后，在模块面板中点击
    `PickerSprite`，将 `callPickerSprite.MoveTo` 模块 ➋ 拖到 Viewer 中，并将它插入到 `whenLeftBtn.Click`
    模块中，紧挨着 `do` 这个词。
- en: Now we need to provide the `MoveTo` block’s method parameters to tell the app
    where we want to move `PickerSprite`, keeping in mind that, for this game, we
    want `PickerSprite` to move from side to side only, along the very bottom of the
    `Canvas`. That means we want to change its x-coordinate but leave its y-coordinate
    at the bottom. To do this, click the **Math** blocks drawer, drag a subtraction
    operator block ➌ to the Viewer, and snap it to the right of x. Then, click PickerSprite
    and drag its PickerSprite.X block ➍ into the subtraction block’s left socket,
    and drag a 50 number block ➎ from the Math drawer into the subtraction block’s
    right socket.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为 `MoveTo` 块提供方法参数，告诉应用程序我们希望将 `PickerSprite` 移动到哪里，记住，对于这个游戏，我们希望 `PickerSprite`
    只在 `Canvas` 的最底部沿水平方向来回移动。这意味着我们只需改变其 x 坐标，保持 y 坐标在底部。为此，点击 **Math** 块抽屉，将一个减法操作符块
    ➌ 拖到查看器中，并将其插入到 x 右侧。然后，点击 `PickerSprite` 并将其 PickerSprite.X 块 ➍ 拖到减法块的左插槽，再从
    Math 抽屉中将一个 50 数字块 ➎ 拖入减法块的右插槽。
- en: These blocks tell our app to move `PickerSprite`’s x-coordinate left to its
    current location minus 50 pixels whenever the `Button` is clicked. For instance,
    if `PickerSprite`’s x-coordinate is at 240 pixels, when the player clicks `LeftBtn`,
    the x-coordinate should move 50 pixels to the left to 190 pixels, since 240 pixels
    – 50 pixels = 190 pixels.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块告诉我们的应用程序，每当点击 `Button` 时，将 `PickerSprite` 的 x 坐标向左移动 50 像素。例如，如果 `PickerSprite`
    的 x 坐标为 240 像素，当玩家点击 `LeftBtn` 时，x 坐标应该向左移动 50 像素，变为 190 像素，因为 240 像素 - 50 像素
    = 190 像素。
- en: Next, click Canvas1, drag its Canvas.Height block ➏ to the viewer, and snap
    it into the callPickerSprite.MoveTo block’s y socket. This tells the app that,
    when it moves `PickerSprite`, we want the `ImageSprite`’s `Y` value to stay the
    value that equals the height of the `Canvas`, positioned at the bottom. For instance,
    if the `Canvas` is 300 pixels in height, these blocks will keep `PickerSprite`’s
    y-coordinate at the `Canvas`’s bottommost point, 300 pixels, when `LeftBtn` is
    clicked.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击 Canvas1，将其 Canvas.Height 块 ➏ 拖到查看器中，并将其插入到 callPickerSprite.MoveTo 块的
    y 插槽。这告诉应用程序，当移动 `PickerSprite` 时，我们希望 `ImageSprite` 的 `Y` 值保持与 `Canvas` 高度相等，并位于底部。例如，如果
    `Canvas` 的高度为 300 像素，这些块将确保当点击 `LeftBtn` 时，`PickerSprite` 的 y 坐标保持在 `Canvas` 底部的
    300 像素处。
- en: Now copy the LeftBtn event handler and modify the duplicate blocks to program
    RightBtn. First, in the duplicate event handler, be sure to use the drop-down
    arrow to change LeftBtn to RightBtn. Then replace the subtraction block after
    the letter `x` with an addition block ➐ from the Math drawer, click PickerSprite
    and drag its PickerSprite.X block ➑ into the addition block’s left socket, and
    drag a 50 number block ➒ from the Math drawer into the addition block’s right
    socket.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在复制 LeftBtn 事件处理程序，并修改副本中的块来编程 RightBtn。首先，在副本事件处理程序中，确保使用下拉箭头将 LeftBtn 更改为
    RightBtn。然后，替换字母 `x` 后面的减法块，改为从 Math 抽屉中选择一个加法块 ➐，点击 `PickerSprite` 并将其 PickerSprite.X
    块 ➑ 拖入加法块的左插槽，再从 Math 抽屉中将一个 50 数字块 ➒ 拖入加法块的右插槽。
- en: These blocks say move `PickerSprite`’s x-coordinate to its current location
    plus 50 pixels when the button is clicked. So, if `PickerSprite`’s x-coordinate
    is at 240 pixels when the player clicks `RightBtn`, the x-coordinate should move
    50 pixels to the right to 290 pixels, since 240 pixels + 50 pixels = 290 pixels.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块的作用是，当按钮被点击时，将 `PickerSprite` 的 x 坐标移动到其当前位置加上 50 像素。所以，如果 `PickerSprite`
    的 x 坐标为 240 像素，当玩家点击 `RightBtn` 时，x 坐标应该向右移动 50 像素，变为 290 像素，因为 240 像素 + 50 像素
    = 290 像素。
- en: Now live-test the game again, and if `LeftBtn` and `RightBtn` don’t work correctly
    after you click `StartBtn`, try debugging. `LeftBtn` and `RightBtn` should move
    `PickerSprite` back and forth across the screen, while fruit `ImageSprite`s occasionally
    collide with `PickerSprite`. Since the player’s goal in the game is to collide
    with, or “catch,” the fruit, we need to program quite a bit of activity to take
    place when those fruit `ImageSprite`s hit `PickerSprite`. We’ll program that action
    in the next, and final, step.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次进行实时测试，如果点击 `StartBtn` 后 `LeftBtn` 和 `RightBtn` 无法正常工作，可以尝试调试。`LeftBtn`
    和 `RightBtn` 应该能让 `PickerSprite` 在屏幕上来回移动，而水果 `ImageSprite` 偶尔与 `PickerSprite`
    碰撞。由于玩家在游戏中的目标是与水果碰撞或“抓住”水果，当这些水果 `ImageSprite` 与 `PickerSprite` 碰撞时，我们需要编程来执行一系列操作。在下一步，我们将编写这些操作。
- en: '**STEP 5: HIDING CAUGHT FRUIT AND KEEPING SCORE**'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 5：隐藏已捕获的水果并记录分数**'
- en: Now we’ll program the last part of the game so that each time a fruit `ImageSprite`
    hits `PickerSprite`, the player “catches” the piece of fruit, hears a noise that
    sounds like the fruit hitting the picker’s bucket, earns a point, and sees the
    total score displayed on the screen. We’ll also hide the `ImageSprite` that hit
    `PickerSprite` so that, instead of continuing to fall to the bottom of the `Canvas`,
    the fruit looks like it landed in the picker’s bucket.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编程游戏的最后部分，使得每当水果 `ImageSprite` 碰到 `PickerSprite` 时，玩家“抓住”水果，听到像水果落入收集器桶中的声音，获得一个积分，并在屏幕上看到总分。同时，我们还会隐藏那个碰到
    `PickerSprite` 的 `ImageSprite`，这样，水果就不会继续掉到 `Canvas` 底部，而是看起来像是落进了收集器的桶里。
- en: To keep the player’s score, we’ll use a variable to store and update that information.
    Let’s start our code for this step by creating and initializing the `score` variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存玩家的分数，我们将使用一个变量来存储并更新这些信息。让我们通过创建并初始化 `score` 变量来开始这一步的代码。
- en: '![Image](../images/f0055-01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0055-01.jpg)'
- en: Click the **Variables** block drawer and drag an initialize global name block
    to the Viewer. Click name, and replace it with the name of our variable, score.
    Then drag a 0 number block from the Math drawer and snap it to the right side
    of the initialize global score block. This declares and initializes the global
    variable we’ll use to store and update the player’s game score.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **变量** 块抽屉，拖动一个初始化全局名称块到“查看器”中。点击名称，将其替换为我们的变量名 `score`。然后，从数学抽屉中拖动一个 0 数字块，并将其放置到初始化全局分数块的右侧。这会声明并初始化我们用来存储和更新玩家游戏分数的全局变量。
- en: '**Playing a Sound When Fruit Hits the Picker**'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**当水果碰到收集器时播放声音**'
- en: Let’s now program the event handler for when a fruit `ImageSprite` hits `PickerSprite`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编程当水果 `ImageSprite` 碰到 `PickerSprite` 时的事件处理程序。
- en: '![Image](../images/f0055-02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0055-02.jpg)'
- en: In the Blocks pane, click PickerSprite and, when the blocks for the component
    appear, drag the whenPickerSprite.CollidedWith block ➊ to the Viewer. Then, in
    the Blocks pane, click Sound1, drag the callSound1.Play block ➋ to the Viewer,
    and snap it inside the whenPickerSprite.CollidedWith block next to the word `do`.
    This should play our clunking sound each time an `ImageSprite` hits `PickerSprite`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在块面板中，点击 PickerSprite，当组件的块出现时，拖动 whenPickerSprite.CollidedWith 块 ➊ 到“查看器”中。然后，在块面板中点击
    Sound1，拖动 callSound1.Play 块 ➋ 到“查看器”中，并将其嵌套到 whenPickerSprite.CollidedWith 块中的
    `do` 旁边。每当 `ImageSprite` 碰到 `PickerSprite` 时，这应该会播放我们的撞击声音。
- en: '**Increasing and Displaying the Score**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**增加和显示分数**'
- en: Next, let’s place the blocks that increment and display the game score each
    time a fruit `ImageSprite` hits the picker.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将放置那些每次水果 `ImageSprite` 碰到收集器时增加并显示游戏分数的块。
- en: '![Image](../images/f0056-01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0056-01.jpg)'
- en: Mouse over the initialize global score block, drag the set global score to block
    ➊ to the Viewer, and snap it inside the whenPickerSprite.CollidedWith block under
    the `callSound1.Play` block. Then drag an addition operator block ➋ from the Math
    drawer and snap it to the right of the set global score to block. Next, mouse
    over the initialize global score block again, and drag the get global score block
    ➌ into the addition block’s left socket and a 1 number block ➍ from the Math drawer
    into its right socket. These blocks add 1 to the current value of the `score`
    variable each time a fruit `ImageSprite` collides with `PickerSprite`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标移到初始化全局分数块上，拖动设置全局分数到块 ➊ 并放置到“查看器”中，然后将其嵌套到 `callSound1.Play` 块下的 whenPickerSprite.CollidedWith
    块内。接着，从数学抽屉中拖动一个加法运算符块 ➋ 并将其放置到设置全局分数到块的右侧。然后，再次将鼠标移到初始化全局分数块上，拖动获取全局分数块 ➌ 到加法块的左插槽，并从数学抽屉中拖动一个数字
    1 块 ➍ 到其右插槽。这些块会在每次水果 `ImageSprite` 与 `PickerSprite` 碰撞时将 `score` 变量的当前值增加 1。
- en: To display the score and also let the player know how many of the total number
    of dropped fruits `PickerSprite` has caught, click Label1, drag the setLabel1.Textto
    block ➎ to the Viewer, and snap it inside the whenPickerSprite.CollidedWith block
    under the `set global score to` block. Then, click the **Text** blocks drawer,
    drag a join block ➏ to the Viewer, and snap it to the right of the setLabel1.Textto
    block.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示分数并让玩家知道 `PickerSprite` 捕获了掉落水果中的多少个，点击 Label1，拖动 setLabel1.Textto 块 ➎ 到“查看器”中，并将其嵌套到
    whenPickerSprite.CollidedWith 块中的 `set global score to` 块下。然后，点击 **文本** 块抽屉，拖动一个连接块
    ➏ 到“查看器”中，并将其放置到 setLabel1.Textto 块的右侧。
- en: Here, we’ll join four strings to set the text and numbers we want `Label1` to
    display, although by default the `join` block allows us to combine only two strings.
    [Figure 3-3](ch03.xhtml#ch3fig3) shows how to change the block to create space
    for the additional inputs we’ll need.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将连接四个字符串来设置我们希望 `Label1` 显示的文本和数字，尽管默认情况下 `join` 块只允许我们组合两个字符串。[图 3-3](ch03.xhtml#ch3fig3)展示了如何更改该块，以为我们需要的附加输入创建空间。
- en: '![Image](../images/03fig03.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig03.jpg)'
- en: '*Figure 3-3: Adding inputs to the `join` block*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：向 `join` 块添加输入*'
- en: Click the blue *mutator* icon to the left of the word `join`, and drag additional
    string blocks to the `join` block in the dialog that opens.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `join` 词左侧的蓝色 *mutator* 图标，在弹出的对话框中将其他字符串块拖到 `join` 块内。
- en: 'Now we can snap our four strings into the `join` block inputs. In the top input,
    drag in an empty string block ➐ from the Text blocks drawer and enter Score: ,
    making sure to include the space after the colon so that, when the strings combine,
    the characters won’t run together without proper spacing. Then mouse over the
    initialize global score block and drag the get global score block ➑ into the `join`
    block’s second input. In the `join` block’s third input, drag in another empty
    string block ➒ and enter out of , leaving a space before `out` and after `of`.
    Then mouse over the initialize global fruitsDropped block and drag the get global
    fruitsDropped block ➓ into the `join` block’s last input. These blocks display
    the number of points and total number of fruits dropped on `Label1` for the player
    to see at the top of the screen. For instance, if the player’s score is 6 points
    and a total of 20 fruits have dropped, the label should display “Score: 6 out
    of 20.”'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们可以将四个字符串嵌入到 `join` 块的输入框中。在顶部输入框中，从文本块抽屉中拖入一个空字符串块 ➐，并输入 “Score:”，确保在冒号后面加上一个空格，以便字符串组合时，字符不会连在一起，缺少适当的间隔。接着，将鼠标移至初始化全局得分块上，并将获取全局得分块
    ➑ 拖入 `join` 块的第二个输入框。在 `join` 块的第三个输入框中，拖入另一个空字符串块 ➒ 并输入 “out of”，在 `out` 之前和
    `of` 之后留一个空格。然后，将鼠标移至初始化全局丢弃水果块上，并将获取全局丢弃水果块 ➓ 拖入 `join` 块的最后一个输入框。这些块将显示玩家在屏幕顶部看到的分数和丢失水果的总数。例如，如果玩家得分为
    6 分，总共有 20 个水果丢失，那么标签应该显示“Score: 6 out of 20”。'
- en: '**Hiding Caught Fruit**'
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐藏已捕获的水果**'
- en: Finally, let’s add the blocks that will make the fruit `ImageSprite`s disappear
    after they collide with `PickerSprite`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些块，使水果 `ImageSprite` 在与 `PickerSprite` 碰撞后消失。
- en: '![Image](../images/f0057-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0057-01.jpg)'
- en: Click FruitSprite1 and, when the blocks for the component appear, drag the whenFruitSprite1.CollidedWith
    block ➊ to the Viewer. Then, click FruitSprite1, drag the setFruitSprite1.Visibleto
    block ➋ to the Viewer, and snap it inside the whenFruitSprite1.CollidedWith block
    next to the word `do`. Next, in the Blocks pane, click the **Logic** blocks drawer,
    drag the false block ➌ to the Viewer, and snap it to the right side of the setFruitSprite1.Visibleto
    block.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `FruitSprite1`，当组件的块出现时，将 `whenFruitSprite1.CollidedWith` 块 ➊ 拖到查看器中。然后，点击
    `FruitSprite1`，将 `setFruitSprite1.Visibleto` 块 ➋ 拖到查看器中，并将其插入到 `whenFruitSprite1.CollidedWith`
    块内，放置在 `do` 旁边。接下来，在块面板中，点击 **逻辑** 块抽屉，将 `false` 块 ➌ 拖到查看器中，并将其插入到 `setFruitSprite1.Visibleto`
    块的右侧。
- en: Now duplicate these blocks for `FruitSprite2`, taking care to use the drop-down
    arrows both places you see `FruitSprite1` to change to FruitSprite2. Then duplicate
    the blocks again, and be sure to change to FruitSprite3. These three event handlers
    hide the fruit `ImageSprite`s when they hit `PickerSprite` so it looks like the
    picker successfully caught the fruit in the bucket. In the next chapter, you’ll
    learn how to eliminate these duplicate blocks and accomplish the same task using
    a more sophisticated programming structure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为 `FruitSprite2` 复制这些块，注意在看到 `FruitSprite1` 的位置，使用下拉箭头将其更改为 `FruitSprite2`。然后再次复制这些块，确保更改为
    `FruitSprite3`。这三个事件处理程序会在水果 `ImageSprite` 与 `PickerSprite` 碰撞时将其隐藏，这样就像是捡果子的人成功地将水果捡进了桶里。在下一章中，您将学习如何消除这些重复的块，并使用更复杂的编程结构来完成相同的任务。
- en: Now, following the plan for step 5, each time a fruit `ImageSprite` touches
    `PickerSprite`, the app should play a sound, increase the player’s score by 1,
    display the score and the total pieces of fruit, and hide the fruit `ImageSprite`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照步骤 5 的计划，每次水果 `ImageSprite` 接触到 `PickerSprite` 时，应用程序应播放声音、增加玩家的得分 1 分、显示得分和水果总数，并隐藏水果
    `ImageSprite`。
- en: It’s time to test the completed game! Open the app on your device, and you should
    see `StartBtn` at the top of the screen. Click it, and when it disappears, you
    should see the other game components appear. Now the fruit starts to randomly
    drop, and you can click `LeftBtn` and `RightBtn` to move `PickerSprite` back and
    forth across the screen to try to catch it. Whenever `PickerSprite` catches a
    piece of fruit, you should hear a sound and see your score increase. If you placed
    your blocks correctly, the game should work as described, and you’ll have successfully
    created the “Fruit Loot” game!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试完成的游戏了！在设备上打开应用，你应该会看到屏幕顶部的 `StartBtn`。点击它，消失后，你应该会看到其他游戏组件出现。现在水果开始随机掉落，你可以点击
    `LeftBtn` 和 `RightBtn` 来移动 `PickerSprite` 在屏幕上来回移动，尽量捕捉水果。每当 `PickerSprite` 捕获到一颗水果时，你应该听到声音并看到分数增加。如果你正确地放置了代码块，游戏应该按照描述正常运行，你就成功创建了“水果Loot”游戏！
- en: '**SUMMARY**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you built the animated “Fruit Loot” app, a game where a player
    moves a fruit picker back and forth across the screen and earns points when the
    picker catches rapidly and randomly dropping fruit.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你构建了一个动画“水果loot”应用，这是一个游戏，玩家控制一个水果收集器在屏幕上来回移动，当收集器捕捉到快速且随机掉落的水果时，玩家会获得积分。
- en: You learned how programmers animate an object by moving its x- and y-coordinates;
    use pseudorandom number generators to add randomness in games, simulators, and
    other applications; and work with arithmetic operators to manipulate data. You
    also practiced declaring and initializing variables to store and change information,
    and you learned how to provide required arguments for built-in methods with parameters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了程序员如何通过移动对象的 x 和 y 坐标来动画化一个对象；如何使用伪随机数生成器在游戏、模拟器和其他应用中添加随机性；以及如何使用算术运算符来处理数据。你还练习了声明和初始化变量以存储和更改信息，并学习了如何为内置方法提供带参数的必要参数。
- en: In the next chapter, you’ll do more with math operators and random number blocks
    and begin to make selections in your code using Control blocks. You’ll use those
    tools to create part 1 of the “Multiplication Station” quiz app, which generates
    random, timed multiplication problems, evaluates solutions the user inputs, and
    then speaks to declare those answers right or wrong.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于数学运算符和随机数代码块的内容，并开始使用控制代码块在代码中进行选择。你将利用这些工具创建“乘法车站”测验应用的第一部分，该应用生成随机的定时乘法题目，评估用户输入的答案，并通过语音宣布这些答案是正确还是错误。
- en: '**ON YOUR OWN**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**独立完成**'
- en: Save new versions of “Fruit Loot” as you modify and extend it working on these
    exercises. You can find solutions online at *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改和扩展“水果Loot”应用时保存新版本。你可以在 *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*
    在线找到解决方案。
- en: Change the app so that it calculates and keeps track of how many pieces of fruit
    the picker fails to catch during a game. How can you calculate, store, and display
    this information using the existing event handlers and adding the smallest number
    of additional blocks?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改应用，使其计算并记录玩家在游戏中未能捕捉到多少个水果。你如何利用现有的事件处理程序来计算、存储和显示这些信息，并且只添加最少的额外代码块？
- en: Extend the game so that the frustrated owner of the fruit trees, who can’t keep
    the fruit from falling over the fence, drops rocks down the fence to try to keep
    the picker from attempting to catch the falling fruit. Reduce the player’s score
    each time the rock hits another sprite. What components and blocks will you add?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展游戏，使得沮丧的果树主人（他无法阻止水果掉过围栏）开始把石块扔到围栏上，试图阻止收集器捕捉掉落的水果。每次石块击中另一个精灵时，减少玩家的分数。你将添加哪些组件和代码块？
- en: Extend the game even further so that the score label displays the number of
    times the rock hits another sprite.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步扩展游戏，使得得分标签显示每次石块击中另一个精灵的次数。
