- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Evaluating Your Architecture
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 评估你的架构
- en: A big red flag is raised for me when people talk about the phases of their modernization
    plans in terms of which *technologies* they are going to use rather than what
    *value* they will add. This distinction is usually a pretty clear sign that they
    assume anything new must be better and more advanced than what they already have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们谈论他们现代化计划的各个阶段时，如果是从他们将使用哪些*技术*的角度出发，而不是从他们将带来什么*价值*的角度出发，这对我来说是一个很大的警告信号。这种区分通常是一个很明显的标志，表明他们认为任何新事物都一定比他们已经拥有的更好、更先进。
- en: It may seem picky to focus on language, but communication is an essential part
    of keeping modernization on track. Teams tend to move in the direction they are
    looking. If we talk about what we’re doing in terms of technical choices, users’
    needs get lost. The best way to find value is by focusing on their needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来挑剔，但专注于语言是保持现代化进程顺利进行的一个关键部分。团队往往会朝着他们所关注的方向发展。如果我们在谈论我们所做的事情时侧重于技术选择，用户的需求就会被忽视。发现价值的最佳方式是专注于他们的需求。
- en: 'I always keep in mind three principles when developing a strategy around a
    new legacy system. The tour of history in Chapters 1 and 2 laid them out in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在围绕新的遗留系统制定战略时，我始终牢记三个原则。第一章和第二章的历史回顾详细阐述了这些原则：
- en: Modernizations should be based on adding value, not chasing new technology.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代化应基于增加价值，而非追逐新技术。
- en: Familiar interfaces help speed up adoption.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉的界面有助于加速采用。
- en: People gain awareness of interfaces and technology through their networks, not
    necessarily by popularity.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们通过他们的网络获得对界面和技术的认识，而不一定是通过流行度。
- en: But for most organizations, the conversation around modernization begins with
    failure. No one would invest the time and effort if the system were humming along
    just fine. The term *legacy modernization* itself is a little misleading. Plenty
    of old systems exist that no one gives a thought to changing because they just
    work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于大多数组织而言，关于现代化的讨论从失败开始。如果系统运行良好，没人会投入时间和精力。*遗留系统现代化*这一术语本身有些误导。许多老旧系统因为运作正常，没人考虑更换。
- en: 'So the last thing you need to consider when developing a plan of attack is
    the exact nature of the failure that is driving the desire to modernize in the
    first place. In all likelihood, you’re dealing with one or more of the following
    issues: technical debt, poor performance, or instability.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在制定攻击计划时，最后需要考虑的事情是导致最初现代化需求的故障的具体性质。很可能，你正在处理以下一个或多个问题：技术债务、性能差或不稳定性。
- en: 'Problem 1: Technical Debt'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1：技术债务
- en: Old systems don’t need to be modernized simply because they are old. Lots of
    technology has not fundamentally changed in decades. Moving to the latest and
    greatest thing can sometimes cause more problems than it solves.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 老旧系统不需要仅仅因为它们老旧而进行现代化。许多技术几十年来没有发生根本变化。迁移到最新最先进的技术有时会带来更多问题，而非解决问题。
- en: 'The following situations might warrant modernization:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情况可能需要进行现代化：
- en: The code is difficult to understand. It references decisions or architectural
    choices that are no longer relevant, and institutional memory has been lost.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码难以理解。它引用的决策或架构选择已经不再相关，且机构记忆已丧失。
- en: Qualified engineering candidates are rare.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合格的工程师候选人稀缺。
- en: Hardware replacement parts are difficult to find.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件替换零件难以找到。
- en: The technology can no longer perform its function efficiently.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该技术已经无法高效地执行其功能。
- en: The terms *legacy* and *technical debt* are frequently conflated. They are different
    concepts, although a system can show signs of both problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*遗留系统*和*技术债务*这两个术语常常被混淆。它们是不同的概念，尽管一个系统可能同时表现出这两种问题的迹象。'
- en: '*Legacy* refers to an old system. Its design patterns are relatively consistent,
    but they are out-of-date. Upgrading the capacity of the underlying infrastructure
    results in performance increases. New engineers are difficult to onboard because
    of the skills gap between the technology they know and the technology with which
    the legacy system was built.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*遗留系统*是指一个旧系统。它的设计模式相对一致，但已经过时。升级底层基础设施的能力会带来性能的提升。由于新工程师与遗留系统所使用的技术之间存在技能差距，因此他们很难适应。'
- en: '*Technical debt*, by contrast, can (and does) happen at any age. It’s a product
    of subpar trade-offs: partial migrations, quick patches, and out-of-date or unnecessary
    dependencies. Technical debt is most likely to happen when assumptions or requirements
    have changed and the organization resorts to a quick fix rather than budgeting
    the time and resources to adapt. Unlike legacy systems, performance issues in
    this case are usually a byproduct of inefficient code instead of out-of-date infrastructure.
    Upgrading the infrastructure—increasing memory and cores or adding servers—doesn’t
    always produce equal increases in performance.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，*技术债务*可以（并且确实会）在任何阶段发生。它是次优权衡的产物：部分迁移、快速修补和过时或不必要的依赖项。技术债务最有可能发生在假设或需求发生变化时，组织选择快速修复而不是预算时间和资源以适应变化。与遗留系统不同，这种情况下的性能问题通常是低效代码的副产品，而非过时的基础设施。升级基础设施——增加内存和核心或添加服务器——并不总是能带来等比例的性能提升。
- en: Systems with substantial technical debt also make it difficult to onboard new
    engineers, but in this case, the difficulty is because the application’s internal
    logic doesn’t make sense. Perhaps the documentation is out-of-date, or levels
    of abstraction are piled up on top of one another, or functions are named unintuitively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有大量技术债务的系统还会使得新工程师的加入变得困难，但在这种情况下，困难在于应用程序的内部逻辑没有意义。也许文档已经过时，或者抽象层次堆积在一起，或者函数命名不直观。
- en: Managing technical debt is about restoring consistency. A good way to approach
    the challenge is to run a product discovery exercise as if you were going to build
    a completely new system, but don’t actually build one! Instead, use this new vision
    to excavate and refocus the current system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 管理技术债务就是要恢复一致性。一种处理这一挑战的好方法是进行一次产品发现练习，就好像你打算构建一个全新的系统一样，但实际上并不构建一个！相反，使用这个新的愿景来挖掘并重新聚焦当前的系统。
- en: As time passes, requirements naturally change. As requirements change, usage
    patterns change, and the organization and design that is most efficient also changes.
    Use product discovery to redefine what your MVP is, and then find where that MVP
    is in the existing code. How are these sets of functions and features organized?
    How would you organize them today?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，需求自然发生变化。随着需求的变化，使用模式也会发生变化，最有效的组织和设计也会变化。使用产品发现方法重新定义你的MVP，然后找到现有代码中MVP所在的位置。这些功能和特性是如何组织的？如果今天你来组织它们，会怎么做？
- en: Another useful exercise to run when dealing with technical debt is to compare
    the technology available when the system was originally built to the technology
    we would use for those same requirements today. I employ this technique a lot
    when dealing with systems written in COBOL. For all that people talk about COBOL
    dying off, it is good at certain tasks. The problem with most old COBOL systems
    is that they were designed at a time when COBOL was the *only* option. If the
    goal is to get rid of COBOL, I start by sorting which parts of the system are
    in COBOL because COBOL is good at performing that task, and which parts are in
    COBOL because there were no other tools available. Once we have that mapping,
    we start by pulling the latter off into separate services that are written and
    designed using the technology we would choose for that task today.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个处理技术债务时有用的练习是，将系统最初构建时可用的技术与我们今天为这些相同需求使用的技术进行比较。当处理用COBOL编写的系统时，我经常采用这种方法。尽管人们常说COBOL正在消亡，但它在某些任务上确实表现得很好。大多数老旧的COBOL系统的问题在于，它们是在COBOL是*唯一*选择的时代设计的。如果目标是摆脱COBOL，我会首先整理出哪些部分的系统是用COBOL编写的，因为COBOL擅长执行这些任务，哪些部分是用COBOL编写的，因为当时没有其他工具可用。一旦我们有了这个映射，我们就可以开始将后者拆分成独立的服务，使用今天我们为这些任务选择的技术来编写和设计。
- en: 'Example: The General Ledger'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：总账
- en: One such debt-heavy system was designed as a *general ledger* for a large healthcare
    organization. It is a complex system involving multiple mainframes working together.
    It processes requests from still more mainframes that back other systems that
    need to issue payments. The general ledger’s core function is to authorize and
    issue payments from an organization to third parties. The system, therefore, must
    make sure the organization has the funds to issue the payment, that the request
    is valid, that the request is not a duplicate, and that the circumstances of the
    request comply with all relevant regulations. In addition, this system also tracks
    money owed to the organization, sends requests to remind debtors to pay, and generates
    reports for various stakeholders.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个债务负担沉重的系统被设计为一个*总账*，用于一个大型医疗保健组织。它是一个复杂的系统，涉及多个主机协同工作。它处理来自其他主机的请求，这些主机支撑着需要发放付款的其他系统。总账的核心功能是授权并发放组织向第三方的付款。因此，该系统必须确保组织有足够的资金发放付款，请求是有效的，请求不是重复的，并且请求的情况符合所有相关的规定。此外，该系统还跟踪组织欠款，发送提醒债务人付款的请求，并为各方利益相关者生成报告。
- en: The current system organizes code based on division—for example, Loans and Accounts
    Payable are different applications within the system despite having overlapping
    requirements—and is written in COBOL or the Assembly language specific to the
    mainframe that typically runs its jobs. Overall, the system looks something like
    [Figure 3-1](#figure3-1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的系统根据部门组织代码——例如，贷款和应付账款是系统内的不同应用程序，尽管它们有重叠的需求——并且是用COBOL或特定于主机的汇编语言编写的，通常运行其作业。总体而言，系统看起来像[图3-1](#figure3-1)。
- en: It’s easy to see how this system evolved this way. The organization is large
    with a lot of money to spend, and when computers were first being introduced to
    the market, it took advantage of them right away (hence, the Assembly). The organization
    migrated paper processes to digital processes largely without changing them and
    maintains the original process boundaries within the technology.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出这个系统是如何以这种方式发展的。该组织规模庞大，资金充足，在计算机首次引入市场时，它立刻利用了计算机的优势（因此有了汇编语言）。该组织将纸质流程迁移到数字流程，几乎没有做出改变，并在技术中保持了原有的流程边界。
- en: '![f03001](../Images/f03001.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](../Images/f03001.png)'
- en: 'Figure 3-1: The applications that talk to the general ledger'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：与总账交互的应用程序
- en: Back then, computers were “extras,” big experimental toys to make things faster,
    and not every business unit felt the new machines would add value to their process.
    The final system ended up divided by business unit because the adoption of technology
    was gradual, unit by unit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，计算机是“附加设备”，是为了加快工作速度而设计的实验性大玩具，并非每个业务单元都认为这些新机器能够为它们的流程增值。最终的系统按业务单元划分，因为技术的采纳是逐步进行的，逐个单元地推进。
- en: But today, computers are the default, so this is not the way we would build
    such a system. We might preserve the mapping of applications to divisions, but
    we would build shared services that reflected their shared requirements. Some
    features play to COBOL’s strengths of processing large amounts of financial data
    accurately, but COBOL doesn’t necessarily bring much to the table when generating
    reports or sending out mailings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是今天，计算机是默认选择，因此我们不会以这种方式构建系统。我们可能会保留应用程序与部门的映射关系，但我们会构建反映它们共享需求的共享服务。一些功能发挥了COBOL处理大量财务数据的优势，但在生成报告或发送邮件时，COBOL并不一定能提供太多帮助。
- en: In modernizing this system, I would identify the appropriate shared services
    and then select one to build. The ideal situation is when I can identify an application
    that needs only one of the proposed shared services. We build that service and
    rewrite that application to use it. Then we go back and find an application that
    needs that shared service plus another shared service on our list. We build the
    second shared service and rewrite the application to use both.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代化这个系统时，我会识别出合适的共享服务，然后选择一个来构建。理想的情况是，当我能识别出一个仅需要提议的共享服务之一的应用程序时。我们构建该服务并重写该应用程序以使用它。然后我们回过头来，找一个需要该共享服务加上我们清单中的另一个共享服务的应用程序。我们构建第二个共享服务，并重写该应用程序以同时使用这两者。
- en: However, rarely can applications in large systems be arranged in order of ascending
    complexity in that manner. More likely, we will have to pull out one shared service
    and rewrite each application one by one, before pulling out a second shared service
    and rewriting each application one by one. This can be frustrating, but it’s important
    not to increase load on a new service before we have enough experience with it
    to know what normal behavior looks like.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大型系统中的应用程序很少能够按复杂度的升序排列。更可能的是，我们需要先提取一个共享服务，并一一重写每个应用程序，然后再提取第二个共享服务，并一一重写每个应用程序。这可能令人沮丧，但重要的是，在我们对新服务的正常行为有足够经验之前，不能对其增加负载。
- en: 'Problem 2: Performance Issues'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2：性能问题
- en: Performance issues are actually one of the nicer problems to have with legacy
    systems. Few organizations are motivated to do anything about legacy systems until
    they start affecting the business side and work starts to slow down. Sometimes
    this is because the system itself has slowed down, but more likely, the system’s
    performance has remained pretty static and literally everything around it has
    gotten faster.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题实际上是与遗留系统相关的较为轻松的难题之一。很少有组织在遗留系统开始影响业务运作、工作开始变慢之前，会主动采取措施。有时这是因为系统本身变慢了，但更可能的是，系统的性能保持相对稳定，而它周围的所有其他事物却变得更快了。
- en: Normally, the issues of how long something should take and how many resources
    it needs to do the job are highly subjective. People tend to accept the current
    state as fine, especially if they have limited experience with other systems.
    If the organization believes its system is having performance issues, the hard
    work of figuring out what “better” is has already been done for you. A system
    cannot have performance issues unless the organization that owns it has defined
    expectations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，关于某个任务需要多久完成以及需要多少资源的问题是高度主观的。人们倾向于认为当前的状态是可以接受的，尤其是当他们对其他系统经验有限时。如果组织认为其系统存在性能问题，那么“更好”的定义工作就已经由你完成了。除非拥有该系统的组织已明确了期望，否则一个系统不可能有性能问题。
- en: This book will repeat the message of trade-offs over and over again. No changes
    made to existing systems are free. Changes that improve one characteristic of
    a system often make something else harder. Teams that are good at legacy modernization
    know how to identify the trade-offs and negotiate the best possible deal. You
    have to pick a goal or a characteristic to optimize on and set budgets for all
    other characteristics so you know how much you’re willing to give up before you
    start losing value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将一再强调权衡取舍的信息。对现有系统所做的任何更改都是有代价的。改善系统某一特性的更改通常会使其他方面变得更加困难。擅长遗留现代化的团队知道如何识别权衡取舍并协商出最佳的解决方案。你必须选择一个目标或特性来优化，并为所有其他特性设定预算，这样你才能知道在开始失去价值之前，你愿意放弃多少。
- en: Is it worth losing some accuracy to make things faster? Is it worth migrating
    to managed services when that makes testing locally more difficult? When an organization
    has decided its system has performance issues, it is easier to answer these questions.
    The organization must have some expectation of how fast performance should be
    or how much money it should spend to satisfy requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高速度，是否值得牺牲一些准确性？当迁移到托管服务使得本地测试更加困难时，是否值得迁移？当一个组织已经决定其系统存在性能问题时，回答这些问题就容易多了。组织必须对性能应该有多快或需要花费多少资金来满足要求有所预期。
- en: Once performance requirements are defined, the task of evaluating the legacy
    system and developing a strategy becomes about listing all the steps in a given
    task and identifying performance bottlenecks. With that mapped out, you can prioritize
    improvements, starting with the areas where the most gains can be realized.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了性能要求，评估遗留系统并制定策略的任务就变成了列出一个给定任务中的所有步骤，并识别性能瓶颈。将这一点列出之后，你可以优先考虑改进，先从能够获得最大收益的领域开始。
- en: Tackling each bottleneck should not require eliminating it completely. If you
    can do that, great, but in most cases, you’ll find that what you would need to
    invest to eliminate it is not worth the boost in performance. Don’t underestimate
    the power of 5 percent, 10 percent, and 20 percent performance gains. As long
    as your approach to reaching those gains moves the system toward a better overall
    state, a 5 percent gain can pay interest as the project moves forward. Other changes
    may turn that 5 percent into a 30 percent or 50 percent gain later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解决每一个瓶颈并不一定要求完全消除它。如果你能做到这一点，那很好，但在大多数情况下，你会发现为了消除它所需的投入与性能提升不成正比。不要低估5%、10%和20%性能提升的力量。只要你采取的方法能使系统朝着更好的整体状态前进，5%的提升可以随着项目的推进产生回报。其他改动可能会让这5%的提升在以后变成30%甚至50%的收益。
- en: That being said, don’t throw out engineering best practices and good architecture
    just to patch something up and get a performance boost. You can spot such solutions
    because they often avoid touching what is obviously the real problem. The people
    who propose these solutions are often frustrated by the system’s problems and
    overwhelmed by the possibility of investing months or years in incremental improvement.
    They argue against the 5 percent change that makes the system better because they
    believe a 5 percent improvement will never be enough. Instead, they propose a
    solution that offers a much larger performance gain, but that compounds the root
    cause or makes it more difficult to fix later. Here’s one example of what I mean.
    We had a system where multiple services needed access to a giant unstructured
    data store. The data had grown to a size that deleting some of it from the data
    store was such a resource-intensive process, it affected the performance of normal
    reads and writes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，不要仅仅为了修补问题并获得性能提升而抛弃工程最佳实践和良好的架构。你可以通过以下特点识别这种解决方案：它们往往避免触及显然的根本问题。提出这些解决方案的人通常对系统的问题感到沮丧，并且被逐步改进所需投入的时间（几个月或几年）压倒。它们反对那种让系统变得更好的5%的改动，因为他们认为5%的改进永远不够。因此，他们提出一种能够提供更大性能提升的解决方案，但这种方案可能会加剧根本问题或使以后修复变得更加困难。举个例子，我们有一个系统，其中多个服务需要访问一个庞大的无结构数据存储。数据的规模已经增长到，删除其中一些数据所需的过程非常消耗资源，已经影响了正常的读取和写入性能。
- en: The problem was the unstructured nature of the data and the fact that so many
    services needed to access it at one time, but that is a hard problem to solve.
    The process of breaking up the data, structuring it appropriately, and migrating
    services over would take months, if not years. Instead, the engineers on the project
    wanted to build a garbage collection service that would run deletes during low
    traffic periods when the performance hit wasn’t as big an issue.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于数据的无结构性，以及同时需要访问这些数据的众多服务，但这是一个很难解决的问题。将数据拆解、适当结构化并迁移服务将需要几个月，甚至几年时间。相反，项目中的工程师们希望构建一个垃圾回收服务，在低流量期间执行删除操作，因为此时性能影响较小。
- en: What’s the problem with this approach? To begin with, creating a new service
    is no small amount of work, and once created, it has to be maintained, monitored,
    tested, and scaled. On top of that, the new service is an abstraction to perform
    a potentially dangerous operation outside the normal flow of events. What triggers
    this service, and how do we know the job it’s running is correct? Adding a new
    service just increases the overall complexity of the system to take advantage
    of a temporary situation. As load continues to increase, those low-traffic windows
    will be smaller and harder to find.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有什么问题呢？首先，创建一个新服务不是一件小事，创建之后，它还需要维护、监控、测试和扩展。更重要的是，这个新服务是一个抽象，它在正常流程之外执行一个潜在的危险操作。是什么触发了这个服务，我们怎么知道它正在执行的任务是正确的？添加一个新服务只会增加系统的整体复杂性，目的是利用暂时的情况。随着负载的增加，这些低流量窗口将变得越来越小，越来越难以找到。
- en: Adding this system, if it worked, could produce a huge gain in performance that
    would buy the organization time to fix the real problem. Certainly that was the
    intention of the engineers who were proposing it. But it’s also possible that
    once such a bandage was in place, the organization would lose interest in fixing
    the real problem, and this team would have accomplished nothing more than resetting
    the clock on the time bomb.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个系统能够正常运行，它将带来巨大的性能提升，为组织争取到时间去解决真正的问题。当然，提出这个系统的工程师们的初衷就是如此。但也有可能，一旦这样的临时修补措施到位，组织就会失去解决真正问题的兴趣，而这个团队的工作也不过是将定时炸弹的倒计时重置了而已。
- en: The smarter thing to do would be to look for the baby steps toward breaking
    up the data that would have produced those 5 or 10 percent gains. Such gains add
    up if you find enough of them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更聪明的做法是寻找突破数据的“微小步骤”，这些步骤将产生5%或10%的提升。如果你发现足够多这样的提升，这些提升会积累起来。
- en: Large problems are always tackled by breaking them down into smaller problems.
    Solve enough small problems, and eventually the large problem collapses and can
    be resolved.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大问题总是通过将其分解为小问题来解决。解决足够多的小问题，最终大问题会崩塌并得以解决。
- en: 'Example: Case Flow Management'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：案件流管理
- en: Software built to manage an application through multistaged approval processes
    are performance battlegrounds as they age. Here’s an example of a system where
    we could increase its output just by finding enough bottlenecks that could be
    whittled down. The technology behind this application approval process is reasonably
    good, but some parts of the process are automated, and some are manual. Some parts
    are digital, and some are still on paper. Some parts were digitalized recently
    and some 20 years ago. Everyone agrees that the system would be better if the
    remaining parts that could be automated were automated, if the paper parts of
    the process were digitalized, and if the older components of the system were brought
    up to speed, but that’s a long list of improvements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用于通过多阶段审批流程管理应用程序的软件，随着时间的推移，逐渐变成了性能战场。这里有一个例子，我们可以通过找到足够多的瓶颈并逐步消除它们来提高系统的输出。这种应用审批流程背后的技术相当不错，但其中一些部分是自动化的，另一些则是手动的。有些部分是数字化的，有些仍然是纸质的。有些部分最近才数字化，而有些则是20年前数字化的。大家都同意，如果剩下的可以自动化的部分能被自动化，流程中的纸质部分能被数字化，系统中较旧的组件能得到更新，整个系统会更好，但这是一长串的改进清单。
- en: Not all of the highest priority tasks actually affect the time it takes to process
    an application. For example, at one point in the process, the applicant must sign
    a consent form authorizing the organization to run a background check. Although
    the paper form could be replaced with a simple web form or an integration with
    a third-party service, this part of the application process is often done in parallel
    with processing the rest of the application. Therefore, digitalizing that step
    does not actually speed up the total processing time of a single application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有优先级最高的任务都会影响处理申请所需的时间。例如，在流程的某个阶段，申请人必须签署一份同意书，授权组织进行背景调查。虽然纸质表单可以用简单的网页表单或与第三方服务的集成来替代，但这一部分申请流程通常与其余申请的处理是并行进行的。因此，数字化这一步骤并不会实际加速单个申请的总处理时间。
- en: Other seemingly irrelevant issues could make a much bigger difference. Cases
    were being sent to the background-check service in batches. If one application
    within that batch had a problem, all the applications in that batch had to wait
    for it to be resolved before moving on. Simply reconfiguring jobs into batches
    of one could save a lot of time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其他看似无关的问题可能会带来更大的差异。案件是批量发送到背景调查服务的。如果该批次中的一个申请出现问题，所有该批次的申请都必须等问题解决后才能继续。仅仅将作业重新配置为每次一个申请处理，就能节省大量时间。
- en: Instead of looking at the purely technical improvements to the system, the team
    decreased the processing time for an average application by tracing the application’s
    path. They had already done the hard work of determining a better system meant
    faster application turnaround, and they structured their approach around optimizing
    for that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 团队没有仅仅关注系统的纯技术改进，而是通过追踪申请的流程来减少处理每个申请的时间。他们已经做了艰苦的工作，确定一个更好的系统意味着更快的申请处理时间，并且他们围绕这一目标优化了他们的方法。
- en: 'Problem 3: Stability Issues'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3：稳定性问题
- en: On the other hand, some legacy systems perform their core functions within the
    parameters the organization needs to be successful, but they are unstable. They
    are not too slow; they produce the correct result and within the resources the
    organizations has available for the task, but there are frequent “surprises,”
    such as outages with bizarre black-swan-style root causes or routine upgrades
    that sometimes go very poorly. Ongoing development work is stopped because unforeseen
    technical conflicts pop up and need to be resolved.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一些遗留系统能够在组织成功所需的参数范围内执行核心功能，但它们不稳定。它们并不太慢；它们能产生正确的结果，并且在组织可用资源范围内完成任务，但经常会有“意外”发生，比如出现奇怪的黑天鹅式根本原因的停机事件，或者常规升级有时会失败得很严重。因为不可预见的技术冲突出现并需要解决，正在进行的开发工作被迫停止。
- en: In 1983, Charles Perrow coined the term *normal accidents* to describe systems
    that were so prone to failure, no amount of safety procedures could eliminate
    accidents entirely. According to Perrow, normal accidents are not the product
    of bad technology or incompetent staff. Systems that experience normal accidents
    display two important characteristics.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 1983年，查尔斯·佩罗（Charles Perrow）创造了*正常事故*这一术语，用来描述那些极易发生故障的系统，即使采取再多的安全措施，也无法完全消除事故。根据佩罗的说法，正常事故并非由不良技术或无能的员工所导致。经历正常事故的系统展现出两个重要特征。
- en: '**They are tightly coupled**. When two separate components are dependent on
    each other, they are said to be coupled. In tightly coupled situations, there’s
    a high probability that changes with one component will affect the other. For
    example, if a change to one code base requires a corresponding change to another
    code base, the two repositories are tightly coupled. Loosely coupled components,
    on the other hand, are ones where changes made to one component don’t necessarily
    affect the other.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**它们是紧密耦合的**。当两个独立的组件彼此依赖时，称之为耦合。在紧密耦合的情况下，一个组件的变化很可能会影响另一个组件。例如，如果一个代码库的更改需要相应地更改另一个代码库，那么这两个代码库就是紧密耦合的。而松散耦合的组件则是指一个组件的变化不一定会影响到另一个组件。'
- en: Tightly coupled systems produce cascading effects. One change creates a response
    in another part of the system, which creates a response in another part of the
    system. Like a domino effect, parts of the system start executing without a human
    operator telling them to do so. If the system is simple, it is possible to anticipate
    how failure will happen and prevent it, which leads to the second characteristic
    of systems that experience normal accidents.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密耦合的系统会产生连锁反应。一处变化会在系统的另一部分引发响应，进而在系统的另一部分产生响应。就像多米诺效应一样，系统的各个部分开始执行，而无需人工操作员指示它们去做。如果系统比较简单，通常可以预测故障发生的方式并加以防范，这也是经历正常事故的系统的第二个特征。
- en: '**They are complex**. Big systems are often complex, but not all complex systems
    are big. Signs of complexity in software include the number of direct dependencies
    and the depth of the dependency tree, the number of integrations, the hierarchy
    of users and ability to delegate, the number of edge cases the system must control
    for, the amount of input from untrusted sources, the amount of legal variety in
    that input, and so on, and so forth. Computer systems naturally grow more complex
    as they age, because as they age, we tend to add more and more features to them,
    which increases at least a few of these characteristics. Computer systems also
    tend to start off tightly coupled and may in fact stay that way if priority is
    not given to refactoring the code occasionally.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**它们是复杂的**。大规模系统通常是复杂的，但并非所有复杂的系统都是庞大的。软件复杂性的迹象包括直接依赖的数量和依赖树的深度、集成的数量、用户的层级结构和委托的能力、系统必须控制的边缘情况数量、来自不可信来源的输入量、这些输入的法律差异等。计算机系统随着时间的推移自然变得更加复杂，因为随着年龄的增长，我们往往会不断为它们添加更多的功能，这会增加至少一些这样的特征。计算机系统也往往在开始时是紧密耦合的，如果不定期进行代码重构，它们实际上可能一直保持这种状态。'
- en: Tightly coupled and complex systems are prone to failure because the coupling
    produces cascading effects, and the complexity makes the direction and course
    of those cascades impossible to predict.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密耦合和复杂的系统容易发生故障，因为耦合会产生连锁反应，而复杂性使得这些连锁反应的方向和过程难以预测。
- en: 'If your goal is to reduce failures or minimize security risks, your best bet
    is to start by evaluating your system on those two characteristics: Where are
    things tightly coupled, and where are things complex? Your goal should not be
    to eliminate all complexity and all coupling; there will be trade-offs in each
    specific instance.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是减少故障或最小化安全风险，最好的方法是从这两个特征入手评估系统：哪里是紧密耦合，哪里是复杂的？你的目标不应是消除所有的复杂性和耦合；在每个具体情况下都会有权衡。
- en: Suppose you have three services that need to access the same data. If you configure
    them to talk to the same database, they are tightly coupled ([Figure 3-2](#figure3-2)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有三个服务需要访问相同的数据。如果你配置它们使用同一个数据库，它们就会形成紧密耦合（[图 3-2](#figure3-2)）。
- en: '![f03002](../Images/f03002.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](../Images/f03002.png)'
- en: 'Figure 3-2: Tightly coupled services'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：紧密耦合的服务
- en: Such coupling creates a few potential problems. To begin with, any of the three
    services could make a change to the data that breaks the other two services. Any
    changes to the database schema have to be coordinated across all three services.
    By sharing a database, you lose the scaling benefit of having three separate services,
    because as load increases on one service, it is passed down to the database, and
    the other services see a dip in performance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种耦合会带来一些潜在问题。首先，三个服务中的任何一个都可能更改数据，从而破坏另外两个服务的正常运行。任何数据库架构的更改都必须在所有三个服务之间协调。通过共享数据库，你失去了拥有三个独立服务的扩展优势，因为当一个服务的负载增加时，这个负载会传递到数据库，而其他服务的性能则会下降。
- en: However, giving each service its own database trades those problems for other
    potential problems. You now must figure out how to keep the data between the three
    separate databases consistent.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，给每个服务分配独立的数据库，会将这些问题转化为其他潜在的问题。现在你必须弄清楚如何保持这三个独立数据库之间的数据一致性。
- en: Loosening up the coupling of two components usually ends with the creation of
    additional abstraction layers, which raises complexity on the system. Minimizing
    the complexity of systems tends to mean more reuse of common components, which
    tightens couplings. It’s not about transforming your legacy system into something
    that is completely simple and uncoupled, it’s about being strategic as to where
    you are coupled and where you are complex and to what degree. Places of complexity
    are areas where the human operators make the most mistakes and have the greatest
    probability of misunderstanding. Places of tight coupling are areas of acceleration
    where effects both good and bad will move faster, which means less time for intervention.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 放松两个组件之间的耦合通常会导致创建额外的抽象层，这会增加系统的复杂性。简化系统复杂性通常意味着更多的公共组件重用，这会加剧耦合。问题不在于将你的遗留系统转变为完全简单且没有耦合的系统，而在于战略性地考虑你在哪些地方耦合、在哪些地方复杂，以及这种耦合和复杂的程度。复杂性较高的地方是人类操作员容易出错和误解的地方；紧密耦合的地方则是加速的领域，好的和坏的效果都会更快传播，这意味着干预的时间会更少。
- en: Once you have identified the parts of the system where there is tight coupling
    and where there is complexity, study the role those areas have played in past
    problems. Will changing the ratio of complexity to coupling make those problems
    better or worse?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你识别出系统中紧密耦合和复杂的部分，研究这些区域在过去问题中的作用。改变复杂性与耦合的比例会使这些问题得到改善，还是变得更糟？
- en: A helpful way to think about this is to classify the types of failures you’ve
    seen so far. Problems that are caused by human beings failing to read something,
    understand something, or check something are usually improved by minimizing complexity.
    Problems that are caused by failures in monitoring or testing are usually improved
    by loosening the coupling (and thereby creating places for automated testing).
    Remember also that an incident can include both elements, so be thoughtful in
    your analysis. A human operator may have made a mistake to trigger an incident,
    but if that mistake was impossible to discover because the logs weren’t granular
    enough, minimizing complexity will not pay off as much as changing the coupling.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的思考方式是将你目前遇到的故障类型进行分类。由人为原因引起的问题——如未能阅读、理解或检查某些内容——通常可以通过简化复杂性来改进。由监控或测试失败引起的问题，通常可以通过放松耦合来改善（从而为自动化测试创造空间）。还要记住，一个事故可能包含这两种因素，所以在分析时要有思考。一名操作员可能因为犯错触发了事故，但如果这个错误因为日志不够详细而无法被发现，那么简化复杂性所带来的效果，就不如改变耦合来得显著。
- en: 'Example: Custom Configuration'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：自定义配置
- en: Consider an organization that wanted to increase the power of custom configurations
    on its monolithic application. It built a configuration service that would allow
    its software engineers to set flags through the monolith’s code ([Figure 3-3](#figure3-3)).
    The application sends requests to the service with the identity of the user to
    fetch the appropriate configuration value. Since those values rarely change, more
    than 90 percent of the requests are handled by a cache. If the cache fails, the
    request moves on to a simple web service that immediately retries the cache before
    ultimately going back to the database to retrieve the configuration setting. The
    database is separate from the monolith’s database, but it runs on the same virtual
    machine (VM). Traffic directly from the application connects with the monolith’s
    database. The custom configuration database uses about 1 percent of the VM resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个组织希望增强其单体应用中自定义配置的功能。它构建了一个配置服务，使得软件工程师可以通过单体应用的代码设置标志（[图 3-3](#figure3-3)）。应用程序向该服务发送带有用户身份的请求，以获取相应的配置值。由于这些值很少更改，90%以上的请求通过缓存处理。如果缓存失败，请求将转发到一个简单的
    Web 服务，该服务会立即重试缓存，最终返回数据库以检索配置设置。该数据库与单体应用的数据库是分开的，但它运行在相同的虚拟机（VM）上。来自应用程序的流量直接与单体应用的数据库连接。自定义配置数据库使用约
    1% 的虚拟机资源。
- en: When the service receives the configuration value from the database, it updates
    the cache and sends the data back to the monolith. The data
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务从数据库接收到配置值时，它会更新缓存并将数据返回给单体应用。数据
- en: '![f03003](../Images/f03003.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](../Images/f03003.png)'
- en: 'Figure 3-3: Requests moving through the custom configuration service'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：请求通过自定义配置服务流动
- en: on custom configurations is stored in a key-value style, with the key being
    the identity of the user and the value being a dictionary with all relevant configuration
    settings. Because possible customizations are almost infinite, these dictionaries
    do not have standard schemas. If a user has no configuration value set for a given
    flag, it is not present at all in the dictionary. The cache preserves this structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义配置以键值对的形式存储，其中键是用户的身份，值是包含所有相关配置设置的字典。由于可能的自定义选项几乎是无限的，这些字典没有标准的模式。如果用户没有为某个标志设置配置值，该标志在字典中将完全不存在。缓存保留了这种结构。
- en: In general, this service performs well for the organization, but it has quirks
    that are difficult for engineers to reproduce and even harder to diagnose. A few
    problems have been traced back to cache stampedes. Users rarely change values
    after setting them, but in the rare cases where the cache does need to be updated,
    the whole dictionary is affected.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个服务对组织表现良好，但它有一些工程师很难重现，甚至更难诊断的怪癖。一些问题追溯到缓存雪崩。用户在设置值后很少更改它们，但在缓存确实需要更新的少数情况中，整个字典都会受到影响。
- en: How can we think of this part of the system in terms of complexity and coupling?
    The monolith’s behavior is coupled to the configuration service. If the configuration
    service goes down, the monolith either cannot fulfill requests or falls back to
    a default value that might completely change the user’s experience. If the configuration
    service experiences partial outages, the monolith’s behavior becomes wildly unpredictable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从复杂性和耦合性角度来看待系统的这一部分？单体应用的行为与配置服务耦合。如果配置服务出现故障，单体应用要么无法完成请求，要么回退到一个可能完全改变用户体验的默认值。如果配置服务发生部分故障，单体应用的行为将变得极为不可预测。
- en: Hosting the databases on the same VM creates coupling between the monolith and
    the configuration service. If the monolith’s database has performance issues,
    the configuration service’s database feels them, and vice versa. However, in this
    case, fixing that issue by moving the configuration service’s database to its
    own VM might not bring much value. If the monolith’s database is having problems,
    the product itself is likely down, making the performance of this service largely
    irrelevant. Since the service uses only 1 percent of the VM’s resources, it is
    unlikely that it will affect the monolith without first triggering pages to the
    engineer on call. We might want to separate them for the sake of right-scaling,
    but that increases the number of VMs we’re paying for and doesn’t necessarily
    buy us much more than cosmetic improvements on our architectural diagram.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库托管在同一虚拟机上会在单体应用和配置服务之间产生耦合。如果单体应用的数据库出现性能问题，配置服务的数据库也会受到影响，反之亦然。然而，在这种情况下，通过将配置服务的数据库迁移到自己的虚拟机来解决问题可能没有太大价值。如果单体应用的数据库出现问题，产品本身可能已经宕机，这使得该服务的性能几乎无关紧要。由于该服务只使用了虚拟机1%的资源，因此不太可能在不先触发值班工程师报警的情况下影响单体应用。我们可能希望出于适当扩展的考虑将它们分开，但这会增加我们支付的虚拟机数量，并不一定带来比架构图上外观改进更多的价值。
- en: On the complexity side, the data structure was probably a poor design choice.
    When the monolith makes a request, it does not need every value set for the user,
    only the value relevant at that moment. If the key in the key-value store was
    user ID plus flag ID, the data could be flat, which would mitigate the risk of
    cache stampedes. On the other hand, we could keep the data structured as is and
    change the monolith’s assumptions so that it requests the user’s dictionary only
    once and stores the data returned in memory for the lifetime of the session. That
    solution minimizes the coupling between the monolith and the service, but it increases
    complexity. We need to understand how much data we would be storing in memory
    at any one point, and at what level that becomes problematic. We need to define
    a time to live and how to implement it. Will we want to make sure all the users’
    requests are directed to the same server, or should we just assume that if a session
    is live, all servers in the application cluster will query the configuration service
    at least once and store the same data in their memory?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从复杂性角度来看，数据结构可能是一个不太理想的设计选择。当单体应用发出请求时，它并不需要为用户设置所有的值，只需要当前时刻相关的值。如果在键值存储中的键是用户ID加上标志ID，数据就可以是平坦的，这样可以减轻缓存雪崩的风险。另一方面，我们也可以保持数据结构不变，改变单体应用的假设，使其只请求一次用户的字典，并将返回的数据存储在内存中，直到会话结束。这种方案最小化了单体应用和服务之间的耦合，但却增加了复杂性。我们需要了解在任何时刻我们将存储多少数据在内存中，以及在什么级别上它会变得有问题。我们需要定义一个生存时间，并决定如何实现它。我们是否希望确保所有用户的请求都指向同一台服务器，还是应该假设如果会话仍然有效，应用集群中的所有服务器至少会查询一次配置服务，并将相同的数据存储在它们的内存中？
- en: Stages of a Modernization Plan
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代化计划的阶段
- en: One day during a one-on-one, an engineer on my team confessed to feeling that
    we had approached our work on one legacy system completely wrong. I had recently
    brought a new engineer onto the team and given her explicit instructions to tear
    through the system’s testing suites. Although the tests were comprehensive and
    the coverage was good, they were brittle, poorly organized, and difficult to make
    sense of. That was a reflection of the system’s overall design, so the new engineer
    set about refactoring huge parts of how the code was organized, making it easier
    to test and the tests more reliable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，在一次一对一会议中，我团队中的一位工程师坦言，我们在处理一个遗留系统时完全走错了方向。我最近将一位新工程师加入团队，并明确指示她彻底审查系统的测试套件。尽管这些测试是全面的，覆盖面很好，但它们脆弱、不够组织，且难以理解。这反映了系统的整体设计，因此新工程师着手重构了代码的组织方式，使其更易于测试，并让测试更可靠。
- en: Looking at the new engineer’s contributions, my engineer knew this configuration
    was better. For months, we had been working on this system. She was kicking herself
    for not looking at the problem the way the newcomer did. “We were too pragmatic,”
    she said. “We just conformed to the system’s existing patterns when we should
    have redone it.”
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看着新工程师的贡献，我的工程师知道这个配置更好。几个月来，我们一直在处理这个系统。她为自己没有像新来的人那样看待问题而懊悔。“我们太实用主义了，”她说，“我们只是顺应了系统现有的模式，而本应该重做它。”
- en: I disagreed. What my engineer had forgotten was that when we took on this system,
    it was unstable. Things would frequently go wrong silently. Errors weren’t properly
    handled or logged. Performance was an issue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我不同意。我的工程师忘记了，当我们接手这个系统时，它是不稳定的。很多事情经常悄无声息地出错。错误没有得到妥善处理或记录。性能也是一个问题。
- en: It was good to learn how to have that kind of technical vision the new engineer
    displayed. I certainly wasn’t going to discourage my team from studying her contributions,
    but it was right to be pragmatic in the beginning. When you first take on a legacy
    system, you can’t possibly understand it well enough to make big changes right
    away. As part of those pragmatic changes, we also invested a lot of time documenting
    and researching the system. Truth be told, the new engineer’s first assignment
    was a series of small, pragmatic changes designed to help her get to know the
    system too, but by that point, my engineers knew the system so well, they were
    able to onboard her much quicker. She tore through those assignments in a matter
    of days.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何拥有那种新工程师所展示的技术视野非常好。我当然不会阻止我的团队研究她的贡献，但一开始务实是正确的。当你首次接手一个遗留系统时，你根本不可能足够理解它，无法立刻进行大规模的修改。作为这些务实变动的一部分，我们还投入了大量时间来记录和研究系统。说实话，新工程师的第一个任务是一系列小的、务实的变动，旨在帮助她也能熟悉系统，但到那个时候，我的工程师们已经非常了解这个系统，他们能够更快地帮助她上手。她在几天内就完成了那些任务。
- en: “How do you think handling a major refactoring at the same time that we were
    having regular incidents would have affected you?” I asked.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “你认为如果我们在处理常规事件的同时进行一次重大重构，会对你产生什么影响？”我问。
- en: “It would have been really stressful.”
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: “那会真的很有压力。”
- en: So stressful, in fact, that it would have compromised the team’s judgment. These
    are the kinds of situations where people become frustrated and start convincing
    themselves that the best thing to do is throw the whole thing out and build it
    from scratch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，非常有压力，以至于可能会影响团队的判断。这些就是人们感到沮丧并开始说服自己最好的做法是把整个系统扔掉，从头开始重建的情形。
- en: When both observability and testing are lacking on your legacy system, observability
    comes first. Tests tell you only what *won’t* fail; monitoring tells you what
    *is* failing. Our new engineer had the freedom to alter huge swaths of the system
    because the work the team had done rolling out better monitoring meant when her
    changes were deployed, we could spot problems quickly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的遗留系统缺乏可观察性和测试时，可观察性应该放在第一位。测试只告诉你什么是*不会*失败的；监控告诉你什么是*正在*失败的。我们的新工程师能够自由地修改系统的大部分，因为团队在实施更好的监控后，意味着当她的修改被部署时，我们能迅速发现问题。
- en: But the real lesson here is that modernization plans evolve as they progress.
    The first stage is one of evaluation. This doesn’t necessarily mean you should
    stop everything and produce big complicated plans, but you should focus on low-hanging
    fruit of immediate issues with pragmatic fixes. Use these small tasks to focus
    your investigation of the system itself. Get to know it and its quirks. Where
    are your blind spots in terms of monitoring? How easy is it to change things,
    test them, and be confident that they will work? Where are the gaps where the
    official documentation says things work this way, but they don’t? How much dead
    code is there? And so on, and so forth.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里真正的教训是，现代化计划会随着进展而发展。第一阶段是评估阶段。这不一定意味着你应该停下所有工作并制定复杂的大计划，但你应该专注于立刻解决的低难度问题，并进行务实的修复。利用这些小任务来聚焦于对系统本身的调查。了解它及其独特性。你的监控盲点在哪里？修改、测试并确信它们能正常工作有多容易？官方文档说某些功能是这样做的，但实际上并非如此的地方在哪里？有多少死代码？等等，等等。
- en: When your team knows the system well enough, you can expand the scope to look
    at issues across the system. Are things organized the way they should be? Is there
    a better technology to incorporate now, perhaps a different programming language
    or a new tool?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的团队足够了解系统时，你可以扩大范围，关注系统中的整体问题。事情是否按应有的方式组织？现在是否有更好的技术可以纳入，也许是另一种编程语言或一种新工具？
- en: On particularly large systems, it is a good idea to make this an iterative multilevel
    process. In other words, pick one part of the large system and focus on that.
    Look at small pragmatic issues, and then look at more global issues within the
    component. Take a further step back and look for those global issues elsewhere
    in the system itself before deciding on an approach to them. Zoom back down to
    fix the component’s global issues and move on to the next component. Continue
    this local-global-superglobal routine until the system is where you need it to
    be.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特别大的系统，最好将此过程做成迭代式的多级过程。换句话说，选择系统中的某一部分并专注于此。先关注小的务实问题，然后关注该组件中的更全局性的问题。再进一步回顾，看看系统中的其他地方是否也存在类似的全局性问题，然后再决定如何处理它们。然后缩小视角，解决该组件的全局问题，再继续下一个组件。这样进行本地-全局-超级全局的循环，直到系统达到你需要的状态。
- en: The deeper your team understands the system and its quirks, the more predictable
    the system’s behavior is on a day-to-day basis and the easier it is to make big
    changes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 团队对系统及其特殊之处理解得越深入，系统的日常行为就越可预测，也越容易做出大规模的更改。
- en: No Silver Bullets
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有银弹
- en: The only real rule of modernizing legacy systems is that there are no silver
    bullets. The rest of this chapter outlines different styles of organizing development
    activities. You will likely use all of them at different points on a large project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化遗留系统的唯一真正规则就是没有银弹。接下来的章节将概述不同的开发活动组织方式。你很可能会在一个大型项目的不同阶段使用到它们中的所有方法。
- en: The key thing to remember is that this is a toolkit. You break down large problems
    into smaller problems, and you choose the tool that gives you the highest probability
    of success with that specific problem. Sure, you may use some methods more often
    than others, but every large-scale legacy system has at least one square peg to
    contend with. It’s impossible to finish the job if all you know how to do is solve
    for round holes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的关键点是，这是一套工具包。你将大问题拆解成小问题，并选择一个能够给你提供最高成功概率的工具来解决特定问题。当然，你可能会比其他方法更频繁地使用某些方法，但每个大规模的遗留系统都至少有一个棘手的问题需要应对。如果你只会解决圆形孔洞的问题，那么任务是无法完成的。
- en: Full Rewrite
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全重写
- en: 'A *full rewrite* is exactly what it sounds like: you start over with the intention
    of building a totally new system. The trouble with this approach is what do you
    do with the old system while you’re building the new one? Some organizations choose
    to put the old system on “maintenance mode” and give it only the resources for
    patches and fixes necessary to keep the lights on. If the new project falls behind
    schedule (and it almost certainly will), the old system continues to degrade.
    If the new project fails and is subsequently canceled, the gap between the old
    system and operational excellence has widened significantly in the meantime.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全重写*就是字面意思：你从头开始，旨在构建一个全新的系统。这种方法的问题在于，在构建新系统的同时，旧系统该如何处理？一些组织选择将旧系统置于“维护模式”，只为其提供必要的资源，用于修补和修复，以保持其正常运作。如果新项目进度落后（几乎肯定会），旧系统会继续退化。如果新项目失败并被取消，那么在此期间，旧系统和运营卓越之间的差距将显著加大。'
- en: The longer the new system takes to get up and running, the longer users and
    the business side of the organization have to wait for new features. Neglecting
    business needs breaks trust with engineering, making it more difficult for engineering
    to secure resources in the future.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统投入运行的时间越长，用户和业务方就需要等待新功能的时间越长。忽视业务需求会破坏与工程部门的信任，从而使工程部门未来更难以争取到资源。
- en: On the other hand, if you continue development on the old system while building
    a new system, keeping design decisions in sync between the two teams is a considerable
    challenge. If those systems handle data, and almost all computer systems do, migrating
    the data over from one to another poses a huge challenge.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在构建新系统的同时继续开发旧系统，那么保持两个团队之间的设计决策同步将是一个相当大的挑战。如果这些系统处理数据，而几乎所有计算机系统都会处理数据，那么将数据从一个系统迁移到另一个系统就成为了一个巨大的挑战。
- en: Another consideration is the people involved. Who gets to work on the new system,
    and who takes on the maintenance tasks of the old system? If the old system is
    written in an obsolete technology relevant only to that particular system, the
    team maintaining the old system is essentially sitting around waiting to be fired.
    And don’t kid yourself, they know it. So if the people maintaining the old system
    are not participating in the creation of the new system, you should expect that
    they are also looking for new jobs. If they leave before your new system is operational,
    you lose both their expertise and their institutional knowledge.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是参与的人。谁来负责新系统的开发，谁来承担旧系统的维护任务？如果旧系统是用一种过时的技术编写的，只对该系统本身相关，那么维护旧系统的团队实际上就是在等待被解雇。不要自欺欺人，他们知道这一点。因此，如果维护旧系统的人没有参与新系统的建设，你应该预期他们也在寻找新工作。如果他们在新系统投入运行之前离开，你不仅失去了他们的专业知识，还失去了他们的内部知识。
- en: That being said, lots of little parts within a big modernization project are
    not improved much by any kind of iteration. If you have an interface written in
    ActionScript, it’s probably better to just rewrite it and push it into production
    as a full replacement.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，大型现代化项目中的许多小部分并不会通过任何形式的迭代得到显著改进。如果你有一个用 ActionScript 编写的界面，可能最好是直接重写它，并作为完全替代版本推入生产环境。
- en: Iteration in Place
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就地迭代
- en: If you have a working system, sometimes the simplest thing to do is to iterate
    it until it looks the way you want. This works well with managing technical debt,
    but you can also use it for situations when you want to redo the architecture.
    A fair amount of prep work is necessary to make iteration in place work. You will
    need to set up monitoring. At a minimum, you should have some way to track errors
    in the application layer and search logs, but the tooling here grows more sophisticated
    every year. The better you can identify what normal looks like on your legacy
    system, the easier it is to iterate in place safely.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个正常工作的系统，有时候最简单的方法就是不断迭代它，直到它看起来符合你的需求。这在管理技术债务时效果很好，但你也可以在需要重新做架构时使用这种方法。要让就地迭代生效，必须进行一定的准备工作。你需要设置监控。至少，你应该有一种方法来跟踪应用层的错误并搜索日志，但这一工具每年都在不断变得更加复杂。你越能识别出遗留系统的正常状态，就越容易安全地进行就地迭代。
- en: Another area to make sure you have a mature approach is testing. Tests should
    run automatically, without needing a human being to follow test cases manually.
    Tests should also be multilevel, testing both the small units of code and whole
    processes end to end. Good tests take skill to write, and entire books have been
    written on the subject, so I won’t attempt to summarize them in a few paragraphs
    here. The most relevant guide for legacy modernizations is Michael Feathers’ *Working
    Effectively with Legacy Code*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要确保你有成熟方法的领域是测试。测试应该自动运行，无需人工手动跟踪测试用例。测试还应该是多层次的，既测试小的代码单元，也测试整个流程的端到端。编写好的测试需要技巧，关于这个主题的书籍已经写了整整一本，所以我不会在这里尝试用几段话来总结。对于遗留系统现代化，最相关的指南是迈克尔·费瑟斯的*《高效使用遗留代码》*。
- en: Finally, make sure your team can recover from failures quickly. This is an engineering
    best practice generally, but it’s especially important if you’re making changes
    to production systems. If you’ve never restored from a backup, you don’t actually
    have backups. If you’ve never failed over to another region, you don’t actually
    have failovers. If you’ve never rolled back a deploy, you don’t have a mature
    deploy pipeline.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保你的团队能够快速从失败中恢复。这通常是工程中的最佳实践，但如果你正在对生产系统进行更改时尤其重要。如果你从未从备份中恢复过，你实际上并没有备份。如果你从未切换到另一个区域，你实际上没有故障转移。如果你从未回滚过部署，你的部署流水线就不成熟。
- en: If you have a good monitoring strategy, have a good testing strategy, and can
    roll back changes quickly, you will be able to change almost anything about your
    legacy system with confidence.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个好的监控策略、良好的测试策略，并且能够快速回滚变更，你就能够自信地对你的遗留系统进行几乎任何修改。
- en: Although it might seem risky, consider iteration in place to be the default
    approach. It is most likely to produce successful results in the greatest number
    of situations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能看起来有风险，但应该将就地迭代视为默认方法。在大多数情况下，这最有可能产生成功的结果。
- en: Split in Place
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就地拆分
- en: '*Split in place* is a variant of iteration in place specific to breaking up
    systems. This can mean moving from a monolithic structure to a service-oriented
    one, but it can also mean taking two components that are tightly coupled and uncoupling
    them. The difference from iteration in place is that you finish splitting things
    off by integrating them back. In other words, when you pull off a service from
    a monolith, that service will likely still need to receive inputs from and send
    outputs to the monolith. So you build the separate service and ultimately connect
    it to the monolith before moving on to the next service. You keep doing this over
    and over (breaking off services and integrating them back) until you’ve broken
    the whole project into small service-based sets of code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*原地分拆*是原地迭代的一种变体，专门用于拆分系统。这可以意味着从单体结构过渡到面向服务的架构，也可以意味着将紧密耦合的两个组件解耦。与原地迭代的区别在于，你通过将拆分后的部分重新整合来完成分拆。换句话说，当你从单体系统中抽离一个服务时，该服务很可能仍然需要从单体系统中接收输入并向其发送输出。所以你构建这个独立的服务，并最终将其与单体系统连接，然后再继续拆分下一个服务。你不断地做这个（拆分服务并重新整合），直到把整个项目拆分成一组组小的基于服务的代码。'
- en: Blue-Green
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: A familiar pattern for deploys, the *blue-green technique* involves running
    two components in parallel and slowly draining traffic off from one and over to
    the other. The big benefit to doing this is that it’s easy to undo if something
    goes wrong. Often with technology, increasing load reveals problems that were
    not otherwise found in testing. Legacy systems have both the blessing and the
    curse of an existing pool of users and activity. The system that replaces them
    has a narrow grace period with which to fix those mistakes discovered under high
    load. Blue-green deployments allow the new system to ease into the full load of
    the old system gradually, and you can fix problems before the load exacerbates
    them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 部署中的一个常见模式，*蓝绿部署技术*涉及将两个组件并行运行，并逐渐将流量从一个组件转移到另一个组件。这样做的最大好处是，如果出现问题，容易撤销。通常，在技术领域，增加负载会暴露出在测试中未发现的问题。遗留系统既有现有用户和活动的优势，也有其困扰。替代它们的系统只有在高负载下发现问题的短暂宽限期。蓝绿部署允许新系统逐步承载旧系统的全部负载，你可以在负载加重之前解决问题。
- en: The Hard Cutoff
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬性截止
- en: The *hard cutoff* is a deployment strategy where the new system or component
    replaces the old all at once. It is one of the riskiest strategies in the modernization
    toolbox.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬性截止*是一种部署策略，其中新系统或组件一次性完全替代旧系统。这是现代化工具箱中最具风险的策略之一。'
- en: A hard cutoff is sometimes done in stages, usually by environment or region.
    An organization might deploy to a low-traffic region first, monitor for issues,
    and then deploy to a higher-traffic region. This gives the organization some of
    the benefits of blue-green deploys in that it can stop the update (and ideally
    roll it back) midstream, but this method is not as accurate as blue-green deploys.
    The difference between environments and regions might not be completely predictable,
    and problems might escape notice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 硬性截止通常分阶段进行，通常按环境或地区进行。一个组织可能首先在低流量地区进行部署，监控是否有问题，然后再部署到高流量地区。这为组织提供了蓝绿部署的一些好处，因为它可以在更新中途停止（并理想情况下回滚），但这种方法不如蓝绿部署精确。环境和地区之间的差异可能并不完全可预测，问题可能被忽视。
- en: If you don’t have multiple regions or are working with software designed to
    be installed by the user and have no control over how many users get access to
    the new version, you may not have a choice. Alpha and beta testing groups help
    in the latter case; making sure you can undo any change (either through restoring
    from backup or reverting/rolling back commands in the version control system)
    helps in the former case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有多个地区，或者正在使用由用户安装的软件并且无法控制有多少用户能访问新版本，那么你可能别无选择。在后一种情况下，Alpha 和 Beta 测试组有所帮助；在前一种情况下，确保你能够撤销任何更改（无论是通过恢复备份还是通过版本控制系统中的还原/回滚命令）会有所帮助。
- en: Putting It Together
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合起来
- en: 'Good planning is less about controlling every detail and more about setting
    expectations across the organization. Your plan will define what it means to modernize
    your legacy system, what the goals are, and what value will be delivered and when.
    Specifically, your plan should focus on answering the following questions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的规划更多的是关于在组织内设定预期，而不是控制每个细节。你的计划将定义现代化遗留系统的含义，目标是什么，什么时候交付什么价值。具体来说，计划应重点回答以下问题：
- en: What problem are we trying to solve by modernizing?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过现代化想要解决什么问题？
- en: What small pragmatic changes will help us learn more about the system?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些小的务实变更将帮助我们更多地了解系统？
- en: What can we iterate on?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以迭代哪些内容？
- en: How will we spot problems after we deploy changes?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署变更后，我们如何发现问题？
- en: Next, we’ll look at how to move out of the planning stage and into facing the
    problems that will make implementation hard.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何从规划阶段转向面对那些将使实施变得困难的问题。
