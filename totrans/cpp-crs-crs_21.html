<html><head></head><body>
<h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_572"/><span epub:type="pagebreak" id="page_573"/><strong><span class="big">18</span><br/>ALGORITHMS</strong></h2>&#13;
<p class="quote"><em>And that’s really the essence of programming. By the time you’ve sorted out a complicated idea into little steps that even a stupidmachine can deal with, you’ve learned something about it yourself.<br/>—Douglas Adams</em>, Dirk Gently’s Holistic Detective Agency</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">An <em>algorithm</em> is a procedure for solving a class of problems. The stdlib and Boost libraries contain a multitude of algorithms that you can use in your programs. Because many very smart people have put a lot of time into ensuring these algorithms are correct and efficient, you should usually not attempt to, for example, write your own sorting algorithm.</p>&#13;
<p class="indent">Because this chapter covers almost the entire stdlib algorithm suite, it’s lengthy; however, the individual algorithm presentations are succinct. On first reading, you should skim through each section to survey the wide range of algorithms available to you. Don’t try to memorize them. Instead, focus on getting insight into the kinds of problems you can solve with them as you write code in the future. That way, when you need to use an algorithm, you can say, “Wait, didn’t someone already invent this wheel?”</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_574"/>Before you begin working with the algorithms, you’ll need some grounding in complexity and parallelism. These two algorithmic characteristics are the main drivers behind how your code will perform.</p>&#13;
<h3 class="h3" id="ch18lev1sec1"><strong>Algorithmic Complexity</strong></h3>&#13;
<p class="noindent"><em>Algorithmic complexity</em> describes the difficulty of a computational task. One way to quantify this complexity is with <em>Bachmann-Landau</em> or <em>“Big O” nota</em><em>tion</em>. Big O notation characterizes functions according to how computation grows with respect to the size of input. This notation only includes the leading term of the complexity function. The <em>leading term</em> is the one that grows most quickly as input size increases.</p>&#13;
<p class="indent">For example, an algorithm whose complexity increases by roughly a fixed amount for each additional input element has a Big O notation of <strong>O(N)</strong>, whereas an algorithm whose complexity doesn’t change given additional input has a Big O notation of <strong>O(1)</strong>.</p>&#13;
<p class="indent">This chapter characterizes the stdlib’s algorithms that fall into five complexity classes, as outlined in the list that follows. To give you some idea of how these algorithms scale, each class is listed with its Big O notation and an idea of roughly how many additional operations would be required due to the leading term when input increases from 1,000 elements to 10,000 elements. Each example provides an operation with the given complexity class, where <em>N</em> is the number of elements involved in the operation:</p>&#13;
<p class="bq"><strong>Constant time O(1)</strong> No additional computation. An example is determining the size of a <span class="literal">std::vector</span>.</p>&#13;
<p class="bq"><strong>Logarithmic time O(log <em>N</em>)</strong> About one additional computation. An example is finding an element in a <span class="literal">std::set</span>.</p>&#13;
<p class="bq"><strong>Linear time O(<em>N</em>)</strong> About 9,000 additional computations. An example is summing all the elements in a collection.</p>&#13;
<p class="bq"><strong>Quasilinear time O(<em>N</em> log <em>N</em>)</strong> About 37,000 additional computations. An example is quicksort, a commonly used sorting algorithm.</p>&#13;
<p class="bq"><strong>Polynomial (or quadratic) time O(<em>N</em><sup>2</sup>)</strong> About 99,000,000 additional computations. An example is comparing all the elements in a collection with all the elements in another collection.</p>&#13;
<p class="indent">An entire field of computer science is dedicated to classifying computational problems according to their difficulty, so this is an involved topic. This chapter mentions each algorithm’s complexity according to how the size of the target sequence affects the amount of required work. In practice, you should profile performance to determine whether an algorithm has suitable scaling properties. But these complexity classes can give you a sense of how expensive a particular algorithm is.</p>&#13;
<h3 class="h3" id="ch18lev1sec2"><span epub:type="pagebreak" id="page_575"/><strong>Execution Policies</strong></h3>&#13;
<p class="noindent">Some algorithms, those that are commonly called <em>parallel algorithms</em>, can divide an algorithm so that independent entities can work on different parts of the problem simultaneously. Many stdlib algorithms allow you to specify parallelism with an <em>execution policy</em>. An execution policy indicates the allowed parallelism for an algorithm. From the stdlib’s perspective, an algorithm can be executed either <em>sequentially</em> or <em>in parallel</em>. A sequential algorithm can have only a single entity working on the problem at a time; a parallel algorithm can have many entities working in concert to resolve the problem.</p>&#13;
<p class="indent">In addition, parallel algorithms can either be <em>vectorized</em> or <em>non-vectorized</em>. Vectorized algorithms allow entities to perform work in an unspecified order, even allowing a single entity to work on multiple portions of the problem simultaneously. For example, an algorithm that requires synchronization among entities is usually non-vectorizable because the same entity could attempt to acquire a lock multiple times, resulting in a deadlock.</p>&#13;
<p class="indent">Three execution policies exist in the <span class="literal">&lt;execution&gt;</span> header:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::execution::seq</span> specifies sequential (not parallel) execution.</li>&#13;
<li class="noindent"><span class="literal">std::execution::par</span> specifies parallel execution.</li>&#13;
<li class="noindent"><span class="literal">std::execution::par_unseq</span> specifies parallel <em>and</em> vectorized execution.</li>&#13;
</ul>&#13;
<p class="indent">For those algorithms that support an execution policy, the default is <span class="literal">seq</span>, meaning you have to opt into parallelism and the associated performance benefits. Note that the C++ Standard doesn’t specify the precise meaning of these execution policies because different platforms handle parallelism differently. When you provide a non-sequential execution policy, you’re simply declaring that “this algorithm is safe to parallelize.”</p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch01">Chapter 1</a>9, you’ll explore execution policies in greater detail. For now, just note that some algorithms permit parallelism.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The algorithm descriptions in this chapter aren’t complete. They contain enough information to give you a good background on many algorithms available to you in the Standard library. I suggest that, once you’ve identified an algorithm that fits your needs, you look at one of the resources in the “Further Reading” section at the end of this chapter. Algorithms that accept an optional execution policy often have different requirements when non-default policies are provided, especially where iterators are concerned. For example, if an algorithm normally takes an input iterator, using an execution policy will typically cause the algorithm to require forward iterators instead. Listing these differences would lengthen an already prodigious chapter, so the descriptions omit them.</em></p>&#13;
</div>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_576"/><strong>HOW TO USE THIS CHAPTER</strong></p>&#13;
<p class="noindent">This chapter is a quick reference that contains more than 50 algorithms. Coverage of each algorithm is necessarily succinct. Each algorithm begins with a terse description. A shorthand representation of the algorithm’s function declaration follows along with an explanation of each argument. The declaration depicts optional arguments in brackets. Next, the listing displays the algorithmic complexity. The listing concludes with a non-exhaustive but illustrative example that employs the algorithm. Almost all examples in this chapter are unit tests and implicitly include the following frontmatter:</p>&#13;
<pre>#include "catch.hpp"&#13;
#include &lt;vector&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;</pre>&#13;
<p class="indent">Refer to the relevant subsection [algorithms] for algorithm details should you need them.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch18lev1sec3"><strong>Non-Modifying Sequence Operations</strong></h3>&#13;
<p class="noindent">A <em>non-modifying sequence operation</em> is an algorithm that performs computation over a sequence but doesn’t modify the sequence in any way. You can think of these as <span class="literal">const</span> algorithms. Each algorithm explained in this section is in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec1"><strong><em>all_of</em></strong></h4>&#13;
<p class="indent">The <span class="literal">all_of</span> algorithm determines whether each element in a sequence meets some user-specified criteria.</p>&#13;
<p class="indent">The algorithm returns <span class="literal">true</span> if the target sequence is empty or if <span class="literal">pred</span> is <span class="literal">true</span> for <em>all</em> elements in the sequence; otherwise, it returns <span class="literal">false</span>.</p>&#13;
<pre>bool all_of([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec1"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A unary predicate, <span class="literal">pred</span>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec2"><strong><span epub:type="pagebreak" id="page_577"/>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">pred</span> at most <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec3"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("all_of") {&#13;
  vector&lt;string&gt; words{ "Auntie", "Anne's", "alligator" }; <span class="ent">➊</span>&#13;
  const auto starts_with_a =&#13;
    [](const auto&amp; word<span class="ent">➋</span>) {&#13;
      if (word.empty()) return false; <span class="ent">➌</span>&#13;
      return word[0] == 'A' || word[0] == 'a'; <span class="ent">➍</span>&#13;
    };&#13;
  REQUIRE(all_of(words.cbegin(), words.cend(), starts_with_a)); <span class="ent">➎</span>&#13;
  const auto has_length_six = [](const auto&amp; word) {&#13;
    return word.length() == 6; <span class="ent">➏</span>&#13;
  };&#13;
  REQUIRE_FALSE(all_of(words.cbegin(), words.cend(), has_length_six)); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span>, you construct the lambda predicate <span class="literal">starts_with_a</span>, which takes a single object called <span class="literal">word</span> <span class="ent">➋</span>. If <span class="literal">word</span> is empty, <span class="literal">starts_with_a</span> returns <span class="literal">false</span> <span class="ent">➌</span>; otherwise, it returns <span class="literal">true</span> if <span class="literal">word</span> starts with either <span class="literal">a</span> or <span class="literal">A</span> <span class="ent">➍</span>. Because all of the <span class="literal">word</span> elements start with either <span class="literal">a</span> or <span class="literal">A</span>, <span class="literal">all_of</span> returns <span class="literal">true</span> when it applies <span class="literal">starts_with_a</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">In the second example, you construct the predicate <span class="literal">has_length_six</span>, which returns <span class="literal">true</span> only if <span class="literal">word</span> has length six <span class="ent">➏</span>. Because <span class="literal">alligator</span> doesn’t have length six, <span class="literal">all_of</span> returns <span class="literal">false</span> when it applies <span class="literal">has_length_six</span> to <span class="literal">words</span> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec2"><strong><em>any_of</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">any_of</span> algorithm determines whether any element in a sequence meets some user-specified criteria.</p>&#13;
<p class="indent">The algorithm returns <span class="literal">false</span> if the target sequence is empty or if <span class="literal">pred</span> is <span class="literal">true</span> for <em>any</em> element in the sequence; otherwise, it returns <span class="literal">false</span>.</p>&#13;
<pre>bool any_of([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec4"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A unary predicate, <span class="literal">pred</span>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec5"><span epub:type="pagebreak" id="page_578"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">pred</span> at most <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec6"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("any_of") {&#13;
  vector&lt;string&gt; words{ "Barber", "baby", "bubbles" }; <span class="ent">➊</span>&#13;
  const auto contains_bar = [](const auto&amp; word) {&#13;
    return word.find("Bar") != string::npos;&#13;
  }; <span class="ent">➋</span>&#13;
  REQUIRE(any_of(words.cbegin(), words.cend(), contains_bar)); <span class="ent">➌</span>&#13;
&#13;
  const auto is_empty = [](const auto&amp; word) { return word.empty(); }; <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(any_of(words.cbegin(), words.cend(), is_empty)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span>, you construct the lambda predicate <span class="literal">contains_bar</span> that takes a single object called <span class="literal">word</span> <span class="ent">➋</span>. If <span class="literal">word</span> contains the substring <span class="literal">Bar</span>, it returns <span class="literal">true</span>; otherwise, it returns <span class="literal">false</span>. Because <span class="literal">Barber</span> contains <span class="literal">Bar</span>, <span class="literal">any_of</span> returns <span class="literal">true</span> when it applies <span class="literal">contains_bar</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you construct the predicate <span class="literal">is_empty</span>, which returns <span class="literal">true</span> only if a <span class="literal">word</span> is empty <span class="ent">➍</span>. Because none of the words are empty, <span class="literal">any_of</span> returns <span class="literal">false</span> when it applies <span class="literal">is_empty</span> to <span class="literal">words</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec3"><strong><em>none_of</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">none_of</span> algorithm determines whether no element in a sequence meets some user-specified criteria.</p>&#13;
<p class="indent">The algorithm returns <span class="literal">true</span> if the target sequence is empty or if <span class="literal">pred</span> is <span class="literal">true</span> for <em>no</em> element in the sequence; otherwise, it returns <span class="literal">false</span>.</p>&#13;
<pre>bool none_of([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec7"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A unary predicate, <span class="literal">pred</span>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec8"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">pred</span> at most <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec9"><span epub:type="pagebreak" id="page_579"/><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("none_of") {&#13;
  vector&lt;string&gt; words{ "Camel", "on", "the", "ceiling" }; <span class="ent">➊</span>&#13;
  const auto is_hump_day = [](const auto&amp; word) {&#13;
    return word == "hump day";&#13;
  }; <span class="ent">➋</span>&#13;
  REQUIRE(none_of(words.cbegin(), words.cend(), is_hump_day)); <span class="ent">➌</span>&#13;
&#13;
  const auto is_definite_article = [](const auto&amp; word) {&#13;
    return word == "the" || word == "ye";&#13;
  }; <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(none_of(words.cbegin(), words.cend(), is_definite_article)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span>, you construct the lambda predicate <span class="literal">is_hump_day</span> that takes a single object called <span class="literal">word</span> <span class="ent">➋</span>. If <span class="literal">word</span> equals <span class="literal">hump day</span>, it returns <span class="literal">true</span>; otherwise, it returns <span class="literal">false</span>. Because <span class="literal">words</span> doesn’t contain <span class="literal">hump day</span>, <span class="literal">none_of</span> returns <span class="literal">true</span> when it applies <span class="literal">is_hump_day</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you construct the predicate <span class="literal">is_definite_article</span>, which returns <span class="literal">true</span> only if <span class="literal">word</span> is a definite article <span class="ent">➍</span>. Because <span class="literal">the</span> is a definite article, <span class="literal">none_of</span> returns <span class="literal">false</span> when it applies <span class="literal">is_definite_article</span> to <span class="literal">words</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec4"><strong><em>for_each</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">for_each</span> algorithm applies some user-defined function to each element in a sequence.</p>&#13;
<p class="indent">The algorithm applies <span class="literal">fn</span> to each element of the target sequence. Although <span class="literal">for_each</span> is considered a non-modifying sequence operation, if <span class="literal">ipt_begin</span> is a mutable iterator, <span class="literal">fn</span> can accept a non-<span class="literal">const</span> argument. Any values that <span class="literal">fn</span> returns are ignored.</p>&#13;
<p class="indent">If you omit <span class="literal">ep</span>, <span class="literal">for_each</span> will return <span class="literal">fn</span>. Otherwise, <span class="literal">for_each</span> returns <span class="literal">void</span>.</p>&#13;
<pre>for_each([ep], ipt_begin, ipt_end, fn);</pre>&#13;
<h5 class="h5" id="ch18lev3sec10"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A unary function, <span class="literal">fn</span>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec11"><span epub:type="pagebreak" id="page_580"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">fn</span> exactly <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec12"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">fn</span> must be movable if you omit <span class="literal">ep</span>.</li>&#13;
<li class="noindent"><span class="literal">fn</span> must be copyable if you provide <span class="literal">ep</span>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec13"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("for_each") {&#13;
  vector&lt;string&gt; words{ "David", "Donald", "Doo" }; <span class="ent">➊</span>&#13;
  size_t number_of_Ds{}; <span class="ent">➋</span>&#13;
  const auto count_Ds = [&amp;number_of_Ds<span class="ent">➌</span>](const auto&amp; word<span class="ent">➍</span>) {&#13;
    if (word.empty()) return; <span class="ent">➎</span>&#13;
    if (word[0] == 'D') ++number_of_Ds; <span class="ent">➏</span>&#13;
  };&#13;
  for_each(words.cbegin(), words.cend(), count_Ds); <span class="ent">➐</span>&#13;
  REQUIRE(3 == number_of_Ds); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span> and a counter variable <span class="literal">number_of_Ds</span> <span class="ent">➋</span>, you construct the lambda predicate <span class="literal">count_Ds</span> that captures a reference to <span class="literal">number_of_Ds</span> <span class="ent">➌</span> and takes a single object called <span class="literal">word</span> <span class="ent">➍</span>. If <span class="literal">word</span> is empty, you return <span class="ent">➎</span>; otherwise, if the first letter of <span class="literal">word</span> is <span class="literal">D</span>, you increment <span class="literal">number_of_Ds</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Next, you use <span class="literal">for_each</span> to iterate over every word, passing each to <span class="literal">count_Ds</span> <span class="ent">➐</span>. The result is that <span class="literal">number_of_Ds</span> is three <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec5"><strong><em>for_each_n</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">for_each_n</span> algorithm applies some user-defined function to each element in a sequence.</p>&#13;
<p class="indent">The algorithm applies <span class="literal">fn</span> to each element of the target sequence. Although <span class="literal">for_each_n</span> is considered a non-modifying sequence operation, if <span class="literal">ipt_begin</span> is a mutable iterator, <span class="literal">fn</span> can accept a non-<span class="literal">const</span> argument. Any values that <span class="literal">fn</span> returns are ignored. It returns <span class="literal">ipt_begin+n</span>.</p>&#13;
<pre>InputIterator for_each_n([ep], ipt_begin, n, fn);</pre>&#13;
<h5 class="h5" id="ch18lev3sec14"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">An <span class="literal">InputIterator</span> <span class="literal">ipt_begin</span> representing the target sequence’s first element</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_581"/>An integer <span class="literal">n</span> representing the desired number of iterations so that the half-open range representing the target sequence is <span class="literal">ipt_begin</span> to <span class="literal">ipt_begin+n</span> (<span class="literal">Size</span> is the templated type of <span class="literal">n</span>.)</li>&#13;
<li class="noindent">A unary function <span class="literal">fn</span> that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec15"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">fn</span> exactly <span class="literal">n</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec16"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">fn</span> must be movable if you omit <span class="literal">ep</span>.</li>&#13;
<li class="noindent"><span class="literal">fn</span> must copyable if you provide <span class="literal">ep</span>.</li>&#13;
<li class="noindent"><span class="literal">n</span> must be non-negative.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec17"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("for_each_n") {&#13;
  vector&lt;string&gt; words{ "ear", "egg", "elephant" }; <span class="ent">➊</span>&#13;
  size_t characters{}; <span class="ent">➋</span>&#13;
  const auto count_characters = [&amp;characters<span class="ent">➌</span>](const auto&amp; word<span class="ent">➍</span>) {&#13;
    characters += word.size(); <span class="ent">➎</span>&#13;
  };&#13;
  for_each_n(words.cbegin(), words.size(), count_characters); <span class="ent">➏</span>&#13;
  REQUIRE(14 == characters); <span class="ent">➐</span>&#13;
}}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span> and a counter variable <span class="literal">characters</span> <span class="ent">➋</span>, you construct the lambda predicate <span class="literal">count_characters</span> that captures a reference to <span class="literal">characters</span> <span class="ent">➌</span> and takes a single object called <span class="literal">word</span> <span class="ent">➍</span>. The lambda adds the length of <span class="literal">word</span> to <span class="literal">characters</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, you use <span class="literal">for_each_n</span> to iterate over every word, passing each to <span class="literal">count_characters</span> <span class="ent">➏</span>. The result is that <span class="literal">characters</span> is <span class="literal">14</span> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec6"><strong><em>find, find_if, and find_if_not</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">find</span>, <span class="literal">find_if</span>, and <span class="literal">find_if_not</span> algorithms find the first element in a sequence matching some user-defined criteria.</p>&#13;
<p class="indent">These algorithms return the <span class="literal">InputIterator</span> pointing to the target sequence’s first element matching <span class="literal">value</span> (<span class="literal">find</span>), resulting in a <span class="literal">true</span> result when invoked with <span class="literal">pred</span> (<span class="literal">find_if</span>), or resulting in a <span class="literal">false</span> result when invoked with <span class="literal">pred</span> (<span class="literal">find_if_not</span>).</p>&#13;
<p class="indent">If the algorithm finds no match, it returns <span class="literal">ipt_end</span>.</p>&#13;
<pre>InputIterator find([ep], ipt_begin, ipt_end, value);&#13;
InputIterator find_if([ep], ipt_begin, ipt_end, pred);&#13;
InputIterator find_if_not([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec18"><strong><span epub:type="pagebreak" id="page_582"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">const</span> reference <span class="literal">value</span> that is equality comparable to the target sequence’s underlying type (<span class="literal">find</span>) or a predicate that accepts a single argument with the target sequence’s underlying type (<span class="literal">find_if</span> and <span class="literal">find_if_not</span>)</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec19"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm makes at most <span class="literal">distance(ipt_begin, ipt_end)</span> comparisons (<span class="literal">find</span>) or invocations of <span class="literal">pred</span> (<span class="literal">find_if</span> and <span class="literal">find_if_not</span>).</p>&#13;
<h5 class="h5" id="ch18lev3sec20"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("find find_if find_if_not") {&#13;
  vector&lt;string&gt; words{ "fiffer", "feffer", "feff" }; <span class="ent">➊</span>&#13;
  const auto find_result = find(words.cbegin(), words.cend(), "feff"); <span class="ent">➋</span>&#13;
  REQUIRE(*find_result == words.back()); <span class="ent">➌</span>&#13;
&#13;
  const auto defends_digital_privacy = [](const auto&amp; word) {&#13;
    return string::npos != word.find("eff"); <span class="ent">➍</span>&#13;
  };&#13;
&#13;
  const auto find_if_result = find_if(words.cbegin(), words.cend(),&#13;
                                      defends_digital_privacy); <span class="ent">➎</span>&#13;
  REQUIRE(*find_if_result == "feffer"); <span class="ent">➏</span>&#13;
&#13;
  const auto find_if_not_result = find_if_not(words.cbegin(), words.cend(),&#13;
                                              defends_digital_privacy); <span class="ent">➐</span>&#13;
  REQUIRE(*find_if_not_result == words.front()); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span>, you use <span class="literal">find</span> to locate <span class="literal">feff</span> <span class="ent">➋</span>, which is at the end of <span class="literal">words</span> <span class="ent">➌</span>. Next, you construct the predicate <span class="literal">defends_digital_privacy</span>, which returns <span class="literal">true</span> if <span class="literal">word</span> contains the letters <span class="literal">eff</span> <span class="ent">➍</span>. You then use <span class="literal">find_if</span> to locate the first string in <span class="literal">words</span> that contains <span class="literal">eff</span> <span class="ent">➎</span>, <span class="literal">feffer</span> <span class="ent">➏</span>. Finally, you use <span class="literal">find_if_not</span> to apply <span class="literal">defends_digital_privacy</span> to <span class="literal">words</span> <span class="ent">➐</span>, which returns the first element <span class="literal">fiffer</span> (because it doesn’t contain <span class="literal">eff</span>) <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec7"><strong><em>find_end</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">find_end</span> algorithm finds the last occurrence of a subsequence.</p>&#13;
<p class="indent">If the algorithm finds no such sequence, it returns <span class="literal">fwd_end1</span>. If <span class="literal">find_end</span> does find a subsequence, it returns a <span class="literal">ForwardIterator</span> pointing to the first element of the last matching subsequence.</p>&#13;
<pre><span epub:type="pagebreak" id="page_583"/>InputIterator find_end([ep], fwd_begin1, fwd_end1,&#13;
                       fwd_begin2, fwd_end2, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec21"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">Two pairs of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin1</span> / <span class="literal">fwd_end1</span> and <span class="literal">fwd_begin2</span> / <span class="literal">fwd_end2</span>, representing the target sequences 1 and 2</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec22"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> The algorithm makes at most the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre>distance(fwd_begin2, fwd_end2) * (distance(fwd_begin1, fwd_end1) -&#13;
                                  distance(fwd_begin2, fwd_end2) + 1)</pre>&#13;
<h5 class="h5" id="ch18lev3sec23"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("find_end") {&#13;
  vector&lt;string&gt; words1{ "Goat", "girl", "googoo", "goggles" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "girl", "googoo" }; <span class="ent">➋</span>&#13;
  const auto find_end_result1 = find_end(words1.cbegin(), words1.cend(),&#13;
                                         words2.cbegin(), words2.cend()); <span class="ent">➌</span>&#13;
  REQUIRE(*find_end_result1 == words1[1]); <span class="ent">➍</span>&#13;
&#13;
  const auto has_length = [](const auto&amp; word, const auto&amp; len) {&#13;
    return word.length() == len; <span class="ent">➎</span>&#13;
  };&#13;
  vector&lt;size_t&gt; sizes{ 4, 6 }; <span class="ent">➏</span>&#13;
  const auto find_end_result2 = find_end(words1.cbegin(), words1.cend(),&#13;
                                         sizes.cbegin(), sizes.cend(),&#13;
                                         has_length); <span class="ent">➐</span>&#13;
  REQUIRE(*find_end_result2 == words1[1]); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words1</span> <span class="ent">➊</span> and another called <span class="literal">words2</span> <span class="ent">➋</span>, you invoke <span class="literal">find_end</span> to determine which element in <span class="literal">words1</span> begins the subsequence equal to <span class="literal">words2</span> <span class="ent">➌</span>. The result is <span class="literal">find_</span><span class="literal">end_result1</span>, which equals the element <span class="literal">girl</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Next, you construct the lambda <span class="literal">has_length</span>, which takes two arguments, <span class="literal">word</span> and <span class="literal">len</span>, and returns <span class="literal">true</span> if <span class="literal">word.length()</span> equals <span class="literal">len</span> <span class="ent">➎</span>. You construct a <span class="literal">vector</span> of <span class="literal">size_t</span> objects called <span class="literal">sizes</span> <span class="ent">➏</span> and invoke <span class="literal">find_end</span> with <span class="literal">words1</span>, <span class="literal">sizes</span>, <span epub:type="pagebreak" id="page_584"/>and <span class="literal">has_length</span> <span class="ent">➐</span>. The result, <span class="literal">find_end_result2</span>, points to the first element in <span class="literal">words1</span> that has length <span class="literal">4</span> with the subsequent word having length <span class="literal">6</span>. Because <span class="literal">girl</span> has length <span class="literal">4</span> and <span class="literal">googoo</span> has length <span class="literal">6</span>, <span class="literal">find_end_result2</span> points to <span class="literal">girl</span> <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec8"><strong><em>find_first</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">find_first_of</span> algorithm finds the first occurrence in sequence 1 equal to some element in sequence 2.</p>&#13;
<p class="indent">If you provide <span class="literal">pred</span>, the algorithm finds the first occurrence <span class="codestrong">i</span> in sequence 1 where, for some <span class="literal">j</span> in sequence 2, <span class="literal">pred (</span><span class="codestrong">i, j</span><span class="literal">)</span> is <span class="literal">true</span>.</p>&#13;
<p class="indent">If <span class="literal">find_first_of</span> finds no such sequence, it returns <span class="literal">ipt_end1</span>. If <span class="literal">find_first_of</span> does find a subsequence, it returns an <span class="literal">InputIterator</span> pointing to the first element of the first matching subsequence. (Note that if <span class="literal">ipt_begin1</span> is also a <span class="literal">ForwardIterator</span>, <span class="literal">find_first_of</span> instead returns a <span class="literal">ForwardIterator</span>.)</p>&#13;
<pre>InputIterator find_first_of([ep], ipt_begin1, ipt_end1,&#13;
                            fwd_begin2, fwd_end2, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec24"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin1</span> / <span class="literal">ipt_end1</span>, representing the target sequence 1</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin2</span> / <span class="literal">fwd_end2</span>, representing the target sequence 2</li>&#13;
<li class="noindent">An optional binary predicate, <span class="literal">pred</span>, to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec25"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> The algorithm makes at most the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre>distance(ipt_begin1, ipt_end1) * distance(fwd_begin2, fwd_end2)</pre>&#13;
<h5 class="h5" id="ch18lev3sec26"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("find_first_of") {&#13;
  vector&lt;string&gt; words{ "Hen", "in", "a", "hat" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; indefinite_articles{ "a", "an" }; <span class="ent">➋</span>&#13;
  const auto find_first_of_result = find_first_of(words.cbegin(),&#13;
                                                  words.cend(),&#13;
                                                  indefinite_articles.cbegin(),&#13;
                                                  indefinite_articles.cend()); <span class="ent">➌</span>&#13;
  REQUIRE(*find_first_of_result == words[2]); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_585"/>After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span> and another called <span class="literal">indefinite_articles</span> <span class="ent">➋</span>, you invoke <span class="literal">find_first_of</span> to determine which element in <span class="literal">words</span> begins the subsequence equal to <span class="literal">indefinite_articles</span> <span class="ent">➌</span>. The result is <span class="literal">find_first_of_result</span>, which equals the element <span class="literal">a</span> <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec9"><strong><em>adjacent_find</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">adjacent_find</span> algorithm finds the first repeat in a sequence.</p>&#13;
<p class="indent">The algorithm finds the first occurrence in the target sequence where two adjacent elements are equal or where, if you provide <span class="literal">pred</span>, the algorithm finds the first occurrence element <span class="codestrong">i</span> in the sequence where <span class="literal">pred (</span><span class="codestrong">i, i</span><span class="literal">+1)</span> is <span class="literal">true</span>.</p>&#13;
<p class="indent">If <span class="literal">adjacent_find</span> finds no such element, it returns <span class="literal">fwd_end</span>. If <span class="literal">adjacent_find</span> does find such an element, it returns a <span class="literal">ForwardIterator</span> pointing to it.</p>&#13;
<pre>ForwardIterator adjacent_find([ep], fwd_begin, fwd_end, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec27"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> / <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec28"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, the algorithm makes at most the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre> min(distance(fwd_begin, i)+1, distance(fwd_begin, fwd_end)-1)</pre>&#13;
<p class="indent">where <span class="codestrong">i</span> is the index of the return value.</p>&#13;
<h5 class="h5" id="ch18lev3sec29"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
TEST_CASE("adjacent_find") {&#13;
  vector&lt;string&gt; words{ "Icabod", "is", "itchy" }; <span class="ent">➊</span>&#13;
  const auto first_letters_match = [](const auto&amp; word1, const auto&amp; word2) { <span class="ent">➋</span>&#13;
    if (word1.empty() || word2.empty()) return false;&#13;
    return word1.front() == word2.front();&#13;
  };&#13;
  const auto adjacent_find_result = adjacent_find(words.cbegin(), words.cend(),&#13;
                                                  first_letters_match); <span class="ent">➌</span>&#13;
  REQUIRE(*adjacent_find_result == words[1]); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_586"/>After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span>, you construct a lambda called <span class="literal">first_letters_match</span>, which takes two words and evaluates whether they start with the first letter <span class="ent">➋</span>. You invoke <span class="literal">adjacent_find</span> to determine which element has the same first letter as the subsequent letter <span class="ent">➌</span>. The result, <span class="literal">adjacent_find_result</span> <span class="ent">➍</span>, equals <span class="literal">is</span> because it shares a first letter with <span class="literal">itchy</span> <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec10"><strong><em>count</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">count</span> algorithm counts the elements in a sequence matching some user-defined criteria.</p>&#13;
<p class="indent">The algorithm returns the number of elements <span class="literal">i</span> in the target sequence where <span class="literal">pred</span> <span class="literal">(</span><span class="codestrong">i</span><span class="literal">)</span> is <span class="literal">true</span> or where <span class="literal">value ==</span> <span class="codestrong">i</span>. Usually, <span class="literal">DifferenceType</span> is <span class="literal">size_t</span>, but it depends on the implementation of <span class="literal">InputIterator</span>. You use <span class="literal">count</span> when you want to count the occurrences of a particular value, and you use <span class="literal">count_if</span> when you have a more complicated predicate you want to use for comparison.</p>&#13;
<pre>DifferenceType count([ep], ipt_begin, ipt_end, value);&#13;
DifferenceType count_if([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec30"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> / <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">Either a <span class="literal">value</span> or a unary predicate <span class="literal">pred</span> to evaluate whether an element <span class="literal">x</span> in the target sequence should be counted</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec31"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, the algorithm makes <span class="literal">distance (ipt_begin, ipt_end)</span> comparisons or invocations of <span class="literal">pred</span>.</p>&#13;
<h5 class="h5" id="ch18lev3sec32"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
TEST_CASE("count") {&#13;
  vector&lt;string&gt; words{ "jelly", "jar", "and", "jam" }; <span class="ent">➊</span>&#13;
  const auto n_ands = count(words.cbegin(), words.cend(), "and"); <span class="ent">➋</span>&#13;
  REQUIRE(n_ands == 1); <span class="ent">➌</span>&#13;
&#13;
  const auto contains_a = [](const auto&amp; word) { <span class="ent">➍</span>&#13;
    return word.find('a') != string::npos;&#13;
  };&#13;
  const auto count_if_result = count_if(words.cbegin(), words.cend(),&#13;
                                        contains_a); <span class="ent">➎</span>&#13;
  REQUIRE(count_if_result == 3); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_587"/>After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects called <span class="literal">words</span> <span class="ent">➊</span>, you use it to invoke <span class="literal">count</span> with the value <span class="literal">and</span> <span class="ent">➋</span>. This returns <span class="literal">1</span>, because a single element equals <span class="literal">and</span> <span class="ent">➌</span>. Next, you construct a lambda called <span class="literal">contains_a</span>, which takes a word and evaluates whether it contains <span class="literal">a</span> <span class="ent">➍</span>. You invoke <span class="literal">count_if</span> to determine how many words contain <span class="literal">a</span> <span class="ent">➎</span>. The result equals <span class="literal">3</span> because three elements contain <span class="literal">a</span> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec11"><strong><em>mismatch</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">mismatch</span> algorithm finds the first mismatch in two sequences.</p>&#13;
<p class="indent">The algorithm finds the first mismatched element pair <span class="literal">i</span>, <span class="literal">j</span> from sequence 1 and sequence 2. Specifically, it finds the first index <span class="codestrong">n</span> such that <span class="codestrong">i</span> <span class="literal">= (ipt_begin1 +</span> <span class="codestrong">n</span><span class="literal">)</span>; <span class="codestrong">j</span> <span class="literal">= (ipt_begin2 +</span> <span class="codestrong">n</span><span class="literal">)</span>; and <span class="codestrong">i</span> <span class="literal">!=</span> <span class="codestrong">j</span> or <span class="literal">pred(</span><span class="codestrong">i</span><span class="literal">,</span> <span class="codestrong">j</span><span class="literal">)</span> <span class="literal">== false</span>.</p>&#13;
<p class="indent">The types of the iterators in the returned <span class="literal">pair</span> equal the types of <span class="literal">ipt_begin1</span> and <span class="literal">ipt_begin2</span>.</p>&#13;
<pre>pair&lt;Itr, Itr&gt; mismatch([ep], ipt_begin1, ipt_end1,&#13;
                        ipt_begin2, [ipt_end2], [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec33"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>).</li>&#13;
<li class="noindent">Two pairs of <span class="literal">InputIterator</span>s, <span class="literal">ipt_begin1</span> / <span class="literal">ipt_end1</span> and <span class="literal">ipt_begin2</span> / <span class="literal">ipt_end2</span>, representing the target sequences <span class="literal">1</span> and <span class="literal">2</span>. If you don’t provide <span class="literal">ipt_</span><span class="literal">end2</span>, sequence 1’s length implies sequence 2’s length.</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec34"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre>min(distance(ipt_begin1, ipt_end1), distance(ipt_begin2, ipt_end2))</pre>&#13;
<h5 class="h5" id="ch18lev3sec35"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("mismatch") {&#13;
  vector&lt;string&gt; words1{ "Kitten", "Kangaroo", "Kick" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Kitten", "bandicoot", "roundhouse" }; <span class="ent">➋</span>&#13;
  const auto mismatch_result1 = mismatch(words1.cbegin(), words1.cend(),&#13;
                                         words2.cbegin()); <span class="ent">➌</span>&#13;
  REQUIRE(*mismatch_result1.first == "Kangaroo"); <span class="ent">➍</span>&#13;
&#13;
  REQUIRE(*mismatch_result1.second == "bandicoot"); <span class="ent">➎</span>&#13;
  const auto second_letter_matches = [](const auto&amp; word1,&#13;
                                        const auto&amp; word2) { <span class="ent">➏</span>&#13;
    if (word1.size() &lt; 2) return false;&#13;
    if (word2.size() &lt; 2) return false;&#13;
    return word1[1] == word2[1];&#13;
  };&#13;
  const auto mismatch_result2 = mismatch(words1.cbegin(), words1.cend(),&#13;
                                     words2.cbegin(), second_letter_matches); <span class="ent">➐</span>&#13;
  REQUIRE(*mismatch_result2.first == "Kick"); <span class="ent">➑</span>&#13;
  REQUIRE(*mismatch_result2.second == "roundhouse"); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_588"/>After constructing two <span class="literal">vector</span>s of <span class="literal">string</span>s called <span class="literal">words1</span> <span class="ent">➊</span> and <span class="literal">words2</span> <span class="ent">➋</span>, you use them as the target sequences for <span class="literal">mismatch</span> <span class="ent">➌</span>. This returns a <span class="literal">pair</span> pointing to the elements <span class="literal">Kangaroo</span> and <span class="literal">bandicoot</span> <span class="ent">➍</span> <span class="ent">➎</span>. Next, you construct a lambda called <span class="literal">second_letter_matches</span>, which takes two words and evaluates whether their second letters match <span class="ent">➏</span>. You invoke <span class="literal">mismatch</span> to determine the first pair of elements with mismatched second letters <span class="ent">➐</span>. The result is the pair <span class="literal">Kick</span> <span class="ent">➑</span> and <span class="literal">roundhouse</span> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec12"><strong><em>equal</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">equal</span> algorithm determines whether two sequences are equal.</p>&#13;
<p class="indent">The algorithm determines whether sequence 1’s elements equal sequence 2’s.</p>&#13;
<pre>bool equal([ep], ipt_begin1, ipt_end1, ipt_begin2, [ipt_end2], [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec36"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>) .</li>&#13;
<li class="noindent">Two pairs of <span class="literal">InputIterator</span>s, <span class="literal">ipt_begin1</span> / <span class="literal">ipt_end1</span> and <span class="literal">ipt_begin2</span> / <span class="literal">ipt_end2</span>, representing the target sequences <span class="literal">1</span> and <span class="literal">2</span>. If you don’t provide <span class="literal">ipt_end2</span>, sequence 1’s length implies sequence 2’s length.</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec37"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre>min(distance(ipt_begin1, ipt_end1), distance(ipt_begin2, ipt_end2))</pre>&#13;
<h5 class="h5" id="ch18lev3sec38"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("equal") {&#13;
  vector&lt;string&gt; words1{ "Lazy", "lion", "licks" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Lazy", "lion", "kicks" }; <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_589"/>  const auto equal_result1 = equal(words1.cbegin(), words1.cend(),&#13;
                                    words2.cbegin()); <span class="ent">➌</span>&#13;
  REQUIRE_FALSE(equal_result1); <span class="ent">➍</span>&#13;
&#13;
  words2[2] = words1[2]; <span class="ent">➎</span>&#13;
  const auto equal_result2 = equal(words1.cbegin(), words1.cend(),&#13;
                                    words2.cbegin()); <span class="ent">➏</span>&#13;
  REQUIRE(equal_result2); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span>s called <span class="literal">words1</span> and <span class="literal">words2</span> <span class="ent">➊</span> <span class="ent">➋</span>, you use them as the target sequences for <span class="literal">equal</span> <span class="ent">➌</span>. Because their last elements, <span class="literal">lick</span> and <span class="literal">kick</span>, aren’t equal, <span class="literal">equal_result1</span> is <span class="literal">false</span> <span class="ent">➍</span>. After setting the third element of <span class="literal">words2</span> to the third element of <span class="literal">words1</span> <span class="ent">➎</span>, you again invoke <span class="literal">equal</span> with the same arguments <span class="ent">➏</span>. Because the sequences are now identical, <span class="literal">equal_result2</span> is <span class="literal">true</span> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec13"><strong><em>is_permutation</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">is_permutation</span> algorithm determines whether two sequences are permutations, meaning they contain the same elements but potentially in a different order.</p>&#13;
<p class="indent">The algorithm determines whether some permutation of sequence 2 exists such that sequence 1’s elements equal the permutation’s.</p>&#13;
<pre>bool is_permutation([ep], fwd_begin1, fwd_end1, fwd_begin2, [fwd_end2], [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec39"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>) .</li>&#13;
<li class="noindent">Two pairs of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin1</span> / <span class="literal">fwd_end1</span> and <span class="literal">fwd_begin2</span> / <span class="literal">fwd_end2</span>, representing the target sequences 1 and 2. If you don’t provide <span class="literal">fwd_end2</span>, sequence 1’s length implies sequence 2’s length.</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec40"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre>distance(fwd_begin1, fwd_end1) * distance(fwd_begin2, fwd_end2)</pre>&#13;
<h5 class="h5" id="ch18lev3sec41"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("is_permutation") {&#13;
  vector&lt;string&gt; words1{ "moonlight", "mighty", "nice" }; <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_590"/>  vector&lt;string&gt; words2{ "nice", "moonlight", "mighty" }; <span class="ent">➋</span>&#13;
  const auto result = is_permutation(words1.cbegin(), words1.cend(),&#13;
                                     words2.cbegin()); <span class="ent">➌</span>&#13;
  REQUIRE(result); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span>s called <span class="literal">words1</span> and <span class="literal">words2</span> <span class="ent">➊</span> <span class="ent">➋</span>, you use them as the target sequences for <span class="literal">is_permutation</span> <span class="ent">➌</span>. Because <span class="literal">words2</span> is a permutation of <span class="literal">words1</span>, <span class="literal">is_permutation</span> returns <span class="literal">true</span> <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="codeitalic">&lt;algorithm&gt;</span> header also contains <span class="codeitalic">next_permutation</span> and <span class="codeitalic">prev_permutation</span> for manipulating a range of elements so you can generate permutations. See [alg.permutation.generators].</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec14"><strong><em>search</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">search</span> algorithm locates a subsequence.</p>&#13;
<p class="indent">The algorithm locates sequence 2 within sequence 1. In other words, it returns the first iterator <span class="codestrong">i</span> in sequence 1 such that for each non-negative integer <span class="literal">n</span>, <span class="literal">*(i + n)</span> equals <span class="literal">*(ipt_begin2 + n)</span>, or if you provide a predicate <span class="literal">pred(*(i + n)</span>, <span class="literal">*(ipt_begin2 + n))</span> is <span class="literal">true</span>. The <span class="literal">search</span> algorithm returns <span class="literal">ipt_begin1</span> if sequence 2 is empty or <span class="literal">ipt_begin2</span> if no subsequence is found. This is different from <span class="literal">find</span> because it locates a subsequence rather than a single element.</p>&#13;
<pre>ForwardIterator search([ep], fwd_begin1, fwd_end1,&#13;
                             fwd_begin2, fwd_end2, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec42"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">Two pairs of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin1</span> / <span class="literal">fwd_end1</span> and <span class="literal">fwd_begin2</span> / <span class="literal">fwd_end2</span>, representing the target sequences 1 and 2</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec43"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <span class="literal">pred</span>:</p>&#13;
<pre>distance(fwd_begin1, fwd_end1) * distance(fwd_begin2, fwd_end2)</pre>&#13;
<h5 class="h5" id="ch18lev3sec44"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("search") {&#13;
<span epub:type="pagebreak" id="page_591"/>  vector&lt;string&gt; words1{ "Nine", "new", "neckties", "and",&#13;
                         "a", "nightshirt" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "and", "a", "nightshirt" }; <span class="ent">➋</span>&#13;
  const auto search_result_1 = search(words1.cbegin(), words1.cend(),&#13;
                                      words2.cbegin(), words2.cend()); <span class="ent">➌</span>&#13;
  REQUIRE(*search_result_1 == "and"); <span class="ent">➍</span>&#13;
&#13;
  vector&lt;string&gt; words3{ "and", "a", "nightpant" }; <span class="ent">➎</span>&#13;
  const auto search_result_2 = search(words1.cbegin(), words1.cend(),&#13;
                                      words3.cbegin(), words3.cend()); <span class="ent">➏</span>&#13;
  REQUIRE(search_result_2 == words1.cend()); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span>s called <span class="literal">words1</span> <span class="ent">➊</span> and <span class="literal">words2</span> <span class="ent">➋</span>, you use them as the target sequences for <span class="literal">search</span> <span class="ent">➌</span>. Because <span class="literal">words2</span> is a subsequence of <span class="literal">words1</span>, <span class="literal">search</span> returns an iterator pointing to <span class="literal">and</span> <span class="ent">➍</span>. The <span class="literal">vector</span> containing <span class="literal">string</span> objects <span class="literal">words3</span> <span class="ent">➎</span> contains the word <span class="literal">nightpant</span> instead of <span class="literal">nightshirt</span>, so invoking <span class="literal">search</span> with it instead of <span class="literal">words2</span> <span class="ent">➏</span> yields the end iterator of <span class="literal">words1</span> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec15"><strong><em>search_n</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">search_n</span> algorithm locates a subsequence containing identical, consecutive values.</p>&#13;
<p class="indent">The algorithm searches for <span class="literal">count</span> consecutive <span class="literal">values</span> in the sequence and returns an iterator pointing to the first <span class="literal">value</span>, or it returns <span class="literal">fwd_end</span> if no such subsequence is found. This is different from <span class="literal">adjacent_find</span> because it locates a subsequence rather than a single element.</p>&#13;
<pre>ForwardIterator search_n([ep], fwd_begin, fwd_end, count, value, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec45"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::</span><span class="literal">seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> / <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An integral <span class="literal">count</span> value representing the number of consecutive matches you want to find</li>&#13;
<li class="noindent">A <span class="literal">value</span> representing the element you want to find</li>&#13;
<li class="noindent">An optional binary predicate <span class="literal">pred</span> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec46"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, at worst the algorithm makes <span class="literal">distance(fwd_begin, fwd_end)</span> comparisons or invocations of <span class="literal">pred</span>.</p>&#13;
<h5 class="h5" id="ch18lev3sec47"><span epub:type="pagebreak" id="page_592"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("search_n") {&#13;
  vector&lt;string&gt; words{ "an", "orange", "owl", "owl", "owl", "today" }; <span class="ent">➊</span>&#13;
  const auto result = search_n(words.cbegin(), words.cend(), 3, "owl"); <span class="ent">➋</span>&#13;
  REQUIRE(result == words.cbegin() + 2); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> of <span class="literal">string</span>s called <span class="literal">words</span> <span class="ent">➊</span>, you use it as the target sequence for <span class="literal">search_n</span> <span class="ent">➋</span>. Because <span class="literal">words</span> contains three instances of the word <span class="literal">owl</span>, it returns an iterator pointing to the first instance <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec4"><strong>Mutating Sequence Operations</strong></h3>&#13;
<p class="noindent">A <em>mutating sequence operation</em> is an algorithm that performs computation over a sequence and is allowed to modify the sequence in some way. Each algorithm explained in this section is in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec16"><strong><em>copy</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">copy</span> algorithm copies one sequence into another.</p>&#13;
<p class="indent">The algorithm copies the target sequence into <span class="literal">result</span> and returns the receiving sequence’s end iterator. It’s your responsibility to ensure that <span class="literal">result</span> represents a sequence with enough space to store the target sequence.</p>&#13;
<pre>OutputIterator copy([ep], ipt_begin, ipt_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec48"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>,<span class="literal"> result</span>, that receives the copied sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec49"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm copies elements from the target sequence exactly <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec50"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">Sequences 1 and 2 must not overlap unless the operation is a <em>copy to the left</em>. For example, for a vector <span class="literal">v</span> with 10 elements, <span class="literal">std::copy(v.begin()+3, v.end(), v.begin())</span> is well defined, but <span class="literal">std::copy(v.begin(), v.begin()+7, v.begin()+3)</span> is not.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_593"/><em>Recall the <span class="codeitalic">back_inserter</span> in “Insert Iterators” on <a href="ch14.xhtml#page_464">page 464</a>, which returns an output iterator that converts write operations into insert operations on the underlying container.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch18lev3sec51"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("copy") {&#13;
  vector&lt;string&gt; words1{ "and", "prosper" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Live", "long" }; <span class="ent">➋</span>&#13;
  copy(words1.cbegin(), words1.cend(), <span class="ent">➌</span>&#13;
       back_inserter(words2)<span class="ent">➍</span>);&#13;
  REQUIRE(words2 == vector&lt;string&gt;{ "Live", "long", "and", "prosper" }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span> objects <span class="ent">➊</span> <span class="ent">➋</span>, you invoke <span class="literal">copy</span> with <span class="literal">words1</span> as the sequence to <span class="literal">copy</span> <span class="ent">➌</span> and <span class="literal">words2</span> as the destination sequence <span class="ent">➍</span>. The result is that <span class="literal">words2</span> contains the contents of <span class="literal">words1</span> appended to the original contents <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec17"><strong><em>copy_n</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">copy_n</span> algorithm copies one sequence into another.</p>&#13;
<p class="indent">The algorithm copies the target sequence into <span class="literal">result</span> and returns the receiving sequence’s end iterator. It’s your responsibility to ensure that <span class="literal">result</span> represents a sequence with enough space to store the target sequence and that <span class="literal">n</span> represents the correct length of the target sequence.</p>&#13;
<pre>OutputIterator copy_n([ep], ipt_begin, n, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec52"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A begin iterator, <span class="literal">ipt_begin</span>, representing the beginning of the target sequence</li>&#13;
<li class="noindent">The size of the target sequence, <span class="literal">n</span></li>&#13;
<li class="noindent">An <span class="literal">OutputIterator result</span> that receives the copied sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec53"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm copies elements from the target sequence exactly <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec54"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">Sequences 1 and 2 must not contain the same objects unless the operation is a <em>copy to the left</em>.</p>&#13;
<h5 class="h5" id="ch18lev3sec55"><span epub:type="pagebreak" id="page_594"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("copy_n") {&#13;
  vector&lt;string&gt; words1{ "on", "the", "wind" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "I'm", "a", "leaf" }; <span class="ent">➋</span>&#13;
  copy_n(words1.cbegin(), words1.size(), <span class="ent">➌</span>&#13;
         back_inserter(words2)); <span class="ent">➍</span>&#13;
  REQUIRE(words2 == vector&lt;string&gt;{ "I'm", "a", "leaf",&#13;
                                    "on", "the", "wind" }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span> objects <span class="ent">➊</span><span class="ent">➋</span>, you invoke <span class="literal">copy_n</span> with <span class="literal">words1</span> as the sequence to <span class="literal">copy_n</span> <span class="ent">➌</span> and <span class="literal">words2</span> as the destination sequence <span class="ent">➍</span>. The result is that <span class="literal">words2</span> contains the contents of <span class="literal">words1</span> appended to the original contents <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec18"><strong><em>copy_backward</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">copy_backward</span> algorithm copies the reverse of one sequence into another.</p>&#13;
<p class="indent">The algorithm copies sequence 1 into sequence 2 and returns the receiving sequence’s end iterator. Elements copy backward but will appear in the target sequence in the original order. It’s your responsibility to ensure that sequence 1 represents a sequence with enough space to store sequence 2.</p>&#13;
<pre>OutputIterator copy_backward([ep], ipt_begin1, ipt_end1, ipt_end2);</pre>&#13;
<h5 class="h5" id="ch18lev3sec56"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin1</span> and <span class="literal">ipt_end1</span>, representing sequence 1</li>&#13;
<li class="noindent">An <span class="literal">InputIterator</span>, <span class="literal">ipt_end2</span>, representing 1 past the end of sequence 2</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec57"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm copies elements from the target sequence exactly <span class="literal">distance(ipt_begin1, ipt_end1)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec58"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">Sequences 1 and 2 must not overlap.</p>&#13;
<h5 class="h5" id="ch18lev3sec59"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("copy_backward") {&#13;
<span epub:type="pagebreak" id="page_595"/>  vector&lt;string&gt; words1{ "A", "man", "a", "plan", "a", "bran", "muffin" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "a", "canal", "Panama" }; <span class="ent">➋</span>&#13;
  const auto result = copy_backward(words2.cbegin(), words2.cend(), <span class="ent">➌</span>&#13;
                                    words1.end()); <span class="ent">➍</span>&#13;
  REQUIRE(words1 == vector&lt;string&gt;{ "A", "man", "a", "plan",&#13;
                                    "a", "canal", "Panama" }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span>s <span class="ent">➊</span> <span class="ent">➋</span>, you invoke <span class="literal">copy_backward</span> with <span class="literal">words2</span> as the sequence to copy <span class="ent">➌</span> and <span class="literal">words1</span> as the destination sequence <span class="ent">➍</span>. The result is that the contents of <span class="literal">word2</span> replace the last three words of <span class="literal">words1</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec19"><strong><em>move</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">move</span> algorithm moves one sequence into another.</p>&#13;
<p class="indent">The algorithm moves the target sequence and returns the receiving sequence’s end iterator. It’s your responsibility to ensure that the target sequence represents a sequence with at least as many elements as the source sequence.</p>&#13;
<pre>OutputIterator move([ep], ipt_begin, ipt_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec60"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">InputIterator</span>, <span class="literal">result</span>, representing the beginning of the sequence to move into</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec61"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm moves elements from the target sequence exactly <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec62"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Sequences must not overlap unless <em>moving to the left</em>.</li>&#13;
<li class="noindent">Types must be moveable but not necessarily copyable.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec63"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
struct MoveDetector { <span class="ent">➊</span>&#13;
  MoveDetector() : owner{ true } {} <span class="ent">➋</span>&#13;
  MoveDetector(const MoveDetector&amp;) = delete;&#13;
  MoveDetector&amp; operator=(const MoveDetector&amp;) = delete;&#13;
  MoveDetector(MoveDetector&amp;&amp; o) = delete;&#13;
  MoveDetector&amp; operator=(MoveDetector&amp;&amp;) { <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_596"/>    o.owner = false;&#13;
    owner = true;&#13;
    return *this;&#13;
  }&#13;
  bool owner;&#13;
};&#13;
&#13;
TEST_CASE("move") {&#13;
  vector&lt;MoveDetector&gt; detectors1(2); <span class="ent">➍</span>&#13;
  vector&lt;MoveDetector&gt; detectors2(2); <span class="ent">➎</span>&#13;
  move(detectors1.begin(), detectors1.end(), detectors2.begin()); <span class="ent">➏</span>&#13;
  REQUIRE_FALSE(detectors1[0].owner); <span class="ent">➐</span>&#13;
  REQUIRE_FALSE(detectors1[1].owner); <span class="ent">➑</span>&#13;
  REQUIRE(detectors2[0].owner); <span class="ent">➒</span>&#13;
  REQUIRE(detectors2[1].owner); <span class="ent">➓</span>&#13;
}</pre>&#13;
<p class="indent">First, you declare the <span class="literal">MoveDetector</span>’s class <span class="ent">➊</span>, which defines a default constructor setting its only member <span class="literal">owner</span> to <span class="literal">true</span> <span class="ent">➋</span>. It deletes the copy and move constructor and the copy assignment operator but defines a move assignment operator that swaps <span class="literal">owner</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">MoveDetector</span> objects <span class="ent">➍</span> <span class="ent">➎</span>, you invoke <span class="literal">move</span> with <span class="literal">detectors1</span> as the sequence to <span class="literal">move</span> and <span class="literal">detectors2</span> as the destination sequence <span class="ent">➏</span>. The result is that the elements of <span class="literal">detector1</span> are in a <em>moved from</em> state <span class="ent">➐</span><span class="ent">➑</span> and the elements of <span class="literal">detector2</span> are moved into <span class="literal">detectors2</span> <span class="ent">➒</span><span class="ent">➓</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec20"><strong><em>move_backward</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">move_backward</span> algorithm moves the reverse of one sequence into another.</p>&#13;
<p class="indent">The algorithm moves sequence 1 into sequence 2 and returns an iterator pointing to the last moved element. Elements move backward but will appear in the target sequence in the original order. It’s your responsibility to ensure that the target sequence represents a sequence with at least as many elements as the source sequence.</p>&#13;
<pre>OutputIterator move_backward([ep], ipt_begin, ipt_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec64"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">InputIterator</span>, <span class="literal">result</span>, representing the sequence to move into</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec65"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm moves elements from the target sequence exactly <span class="literal">distance(ipt_begin, ipt_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec66"><span epub:type="pagebreak" id="page_597"/><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Sequences must not overlap.</li>&#13;
<li class="noindent">Types must be moveable but not necessarily copyable.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec67"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
struct MoveDetector { <span class="ent">➊</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
};&#13;
&#13;
TEST_CASE("move_backward") {&#13;
  vector&lt;MoveDetector&gt; detectors1(2); <span class="ent">➋</span>&#13;
  vector&lt;MoveDetector&gt; detectors2(2); <span class="ent">➌</span>&#13;
  move_backward(detectors1.begin(), detectors1.end(), detectors2.end()); <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(detectors1[0].owner); <span class="ent">➎</span>&#13;
  REQUIRE_FALSE(detectors1[1].owner); <span class="ent">➏</span>&#13;
  REQUIRE(detectors2[0].owner); <span class="ent">➐</span>&#13;
  REQUIRE(detectors2[1].owner); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">First, you declare the <span class="literal">MoveDetector</span> class <span class="ent">➊</span> (see “<span class="literal">move</span>” back on <a href="ch18.xhtml#page_595">page 595</a> for the implementation).</p>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">MoveDetector</span> objects <span class="ent">➋</span> <span class="ent">➌</span>, you invoke <span class="literal">move</span> with <span class="literal">detectors1</span> as the sequence to <span class="literal">move</span> and <span class="literal">detectors2</span> as the destination sequence <span class="ent">➍</span>. The result is that the elements of <span class="literal">detector1</span> are in a <em>moved from</em> state <span class="ent">➎</span><span class="ent">➏</span> and the elements of <span class="literal">detector2</span> are <em>moved into</em> <span class="ent">➐</span><span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec21"><strong><em>swap_ranges</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">swap_ranges</span> algorithm exchanges elements from one sequence into another.</p>&#13;
<p class="indent">The algorithm calls <span class="literal">swap</span> on each element of sequence 1 and sequence 2, and it returns the receiving sequence’s end iterator. It’s your responsibility to ensure that the target sequence represents a sequence with at least as many elements as the source sequence.</p>&#13;
<pre>OutputIterator swap_ranges([ep], ipt_begin1, ipt_end1, ipt_begin2);</pre>&#13;
<h5 class="h5" id="ch18lev3sec68"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">ipt_begin1</span> and <span class="literal">ipt_end1</span>, representing sequence 1</li>&#13;
<li class="noindent">A <span class="literal">ForwardIterator</span>, <span class="literal">ipt_begin2</span>, representing the beginning of sequence 2</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec69"><span epub:type="pagebreak" id="page_598"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm calls <span class="literal">swap</span> exactly <span class="literal">distance(ipt_begin1, ipt_end1)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec70"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements contained in each sequence must be swappable.</p>&#13;
<h5 class="h5" id="ch18lev3sec71"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("swap_ranges") {&#13;
  vector&lt;string&gt; words1{ "The", "king", "is", "dead." }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Long", "live", "the", "king." }; <span class="ent">➋</span>&#13;
  swap_ranges(words1.begin(), words1.end(), words2.begin()); <span class="ent">➌</span>&#13;
  REQUIRE(words1 == vector&lt;string&gt;{ "Long", "live", "the", "king." }); <span class="ent">➍</span>&#13;
  REQUIRE(words2 == vector&lt;string&gt;{ "The", "king", "is", "dead." }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <span class="literal">vector</span>s of <span class="literal">string</span>s <span class="ent">➊</span> <span class="ent">➋</span>, you invoke <span class="literal">swap</span> with <span class="literal">words1</span> and <span class="literal">words2</span> as the sequences to swap <span class="ent">➌</span>. The result is that <span class="literal">words1</span> and <span class="literal">words2</span> swap contents <span class="ent">➍</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec22"><strong><em>transform</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">transform</span> algorithm modifies the elements of one sequence and writes them into another.</p>&#13;
<p class="indent">The algorithm invokes <span class="literal">unary_op</span> on each element of the target sequence and outputs it into the output sequence, or it invokes <span class="literal">binary_op</span> on corresponding elements of each target sequence.</p>&#13;
<pre>OutputIterator transform([ep], ipt_begin1, ipt_end1, result, unary_op);&#13;
OutputIterator transform([ep], ipt_begin1, ipt_end1, ipt_begin2,&#13;
                         result, binary_op);</pre>&#13;
<h5 class="h5" id="ch18lev3sec72"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>).</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin1</span> and <span class="literal">ipt_end1</span>, representing the target sequence.</li>&#13;
<li class="noindent">An optional <span class="literal">InputIterator</span>, <span class="literal">ipt_begin2</span>, representing a second target sequence. You must ensure that this second target sequence has at least as many elements as the first target sequence.</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">result</span>, representing the beginning of the output sequence.</li>&#13;
<li class="noindent">A unary operation, <span class="literal">unary_op</span>, that transforms elements of the target sequence into elements of the output sequence. If you supply two <span epub:type="pagebreak" id="page_599"/>target sequences, you instead provide a binary operation, <span class="literal">binary_op</span>, which accepts an element from each target sequence and transforms each into an element of the output sequence.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec73"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">unary_op</span> or <span class="literal">binary_op</span> exactly <span class="literal">distance(ipt_begin1, ipt_end1)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec74"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
&#13;
TEST_CASE("transform") {&#13;
  vector&lt;string&gt; words1{ "farewell", "hello", "farewell", "hello" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; result1;&#13;
  auto upper = [](string x) { <span class="ent">➋</span>&#13;
    boost::algorithm::to_upper(x);&#13;
    return x;&#13;
  };&#13;
  transform(words1.begin(), words1.end(), back_inserter(result1), upper); <span class="ent">➌</span>&#13;
  REQUIRE(result1 == vector&lt;string&gt;{ "FAREWELL", "HELLO",&#13;
                                     "FAREWELL", "HELLO" }); <span class="ent">➍</span>&#13;
&#13;
  vector&lt;string&gt; words2{ "light", "human", "bro", "quantum" }; <span class="ent">➎</span>&#13;
  vector&lt;string&gt; words3{ "radar", "robot", "pony", "bit" }; <span class="ent">➏</span>&#13;
  vector&lt;string&gt; result2;&#13;
  auto portmantize = [](const auto &amp;x, const auto &amp;y) { <span class="ent">➐</span>&#13;
    const auto x_letters = min(size_t{ 2 }, x.size());&#13;
    string result{ x.begin(), x.begin() + x_letters };&#13;
    const auto y_letters = min(size_t{ 3 }, y.size());&#13;
    result.insert(result.end(), y.end() - y_letters, y.end() );&#13;
    return result;&#13;
  };&#13;
  transform(words2.begin(), words2.end(), words3.begin(),&#13;
            back_inserter(result2), portmantize); <span class="ent">➑</span>&#13;
  REQUIRE(result2 == vector&lt;string&gt;{ "lidar", "hubot", "brony", "qubit" }); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects <span class="ent">➊</span>, you construct a lambda called <span class="literal">upper</span>, which takes a <span class="literal">string</span> by value and converts it to uppercase using the Boost <span class="literal">to_upper</span> algorithm discussed in <a href="ch15.xhtml#ch15">Chapter 15</a> <span class="ent">➋</span>. You invoke transform with <span class="literal">words1</span> as the target sequence, a <span class="literal">back_inserter</span> for an empty <span class="literal">results1</span> vector, and <span class="literal">upper</span> as the unary operation <span class="ent">➌</span>. After <span class="literal">transform</span>, <span class="literal">results1</span> contains the uppercase version of <span class="literal">words1</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">In the second example, you construct two <span class="literal">vector</span>s of <span class="literal">string</span> objects <span class="ent">➎</span><span class="ent">➏</span>. You also construct a lambda called <span class="literal">portmantize</span> that accepts two <span class="literal">string</span> objects <span class="ent">➐</span>. The lambda returns a new <span class="literal">string</span> containing up to two letters from the beginning of the first argument and up to three letters from <span epub:type="pagebreak" id="page_600"/>the end of the second argument. You pass the two target sequences, a <span class="literal">back_inserter</span> to an empty <span class="literal">vector</span> called <span class="literal">results2</span> and <span class="literal">portmantize</span> <span class="ent">➑</span>. The <span class="literal">result2</span> contains portmanteaus of the contents of <span class="literal">words1</span> and <span class="literal">words2</span> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec23"><strong><em>replace</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">replace</span> algorithm replaces certain elements of a sequence with some new element.</p>&#13;
<p class="indent">The algorithm searches for target sequence elements <span class="codestrong">x</span> for which either <span class="codestrong">x</span> <span class="literal">== old_ref</span> or <span class="literal">pred(</span><span class="codestrong">x</span><span class="literal">) == true</span> and assigns them to <span class="literal">new_ref</span>.</p>&#13;
<pre>void replace([ep], fwd_begin, fwd_end, old_ref, new_ref);&#13;
void replace_if([ep], fwd_begin, fwd_end, pred, new_ref);&#13;
void replace_copy([ep], fwd_begin, fwd_end, result, old_ref, new_ref);&#13;
void replace_copy_if([ep], fwd_begin, fwd_end, result, pred, new_ref);</pre>&#13;
<h5 class="h5" id="ch18lev3sec75"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">result</span>, representing the beginning of the output sequence</li>&#13;
<li class="noindent">An <span class="literal">old</span> <span class="literal">const</span> reference representing the element to find</li>&#13;
<li class="noindent">A unary predicate, <span class="literal">pred</span>, that determines whether an element meets the criteria for replacement</li>&#13;
<li class="noindent">A <span class="literal">new_ref</span> <span class="literal">const</span> reference that represents the element to replace</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec76"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">pred</span> exactly <span class="literal">distance(fwd_begin, fwd_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec77"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">The elements contained in each sequence must be comparable to <span class="literal">old_ref</span> and assignable to <span class="literal">new_ref</span>.</p>&#13;
<h5 class="h5" id="ch18lev3sec78"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;string_view&gt;&#13;
&#13;
TEST_CASE("replace") {&#13;
  using namespace std::literals; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words1{ "There", "is", "no", "try" }; <span class="ent">➋</span>&#13;
  replace(words1.begin(), words1.end(), "try"sv, "spoon"sv); <span class="ent">➌</span>&#13;
  REQUIRE(words1 == vector&lt;string&gt;{ "There", "is", "no", "spoon" }); <span class="ent">➍</span>&#13;
&#13;
  const vector&lt;string&gt; words2{ "There", "is", "no", "spoon" }; <span class="ent">➎</span>&#13;
<span epub:type="pagebreak" id="page_601"/>  vector&lt;string&gt; words3{ "There", "is", "no", "spoon" }; <span class="ent">➏</span>&#13;
  auto has_two_os = [](const auto&amp; x) { <span class="ent">➐</span>&#13;
    return count(x.begin(), x.end(), 'o') == 2;&#13;
  };&#13;
  replace_copy_if(words2.begin(), words2.end(), words3.begin(), <span class="ent">➑</span>&#13;
                  has_two_os, "try"sv);&#13;
  REQUIRE(words3 == vector&lt;string&gt;{ "There", "is", "no", "try" }); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="indent">You first bring in the <span class="literal">std::literals</span> namespace <span class="ent">➊</span> so you can employ the <span class="literal">string_view</span> literal later on. After constructing a <span class="literal">vector</span> containing <span class="literal">string</span> objects <span class="ent">➋</span>, you invoke <span class="literal">replace</span> with the <span class="literal">vector</span> <span class="ent">➌</span> to replace all instances of <span class="literal">try</span> with <span class="literal">spoon</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">In the second example, you construct two <span class="literal">vector</span>s of <span class="literal">string</span> objects <span class="ent">➎</span><span class="ent">➏</span> and a lambda called <span class="literal">has_two_os</span>, which accepts a string and returns <span class="literal">true</span> if it contains exactly two <span class="literal">o</span>s <span class="ent">➐</span>. You then pass <span class="literal">words2</span> as the target sequence and <span class="literal">words3</span> as the destination sequence to <span class="literal">replace_copy_if</span>, which applies <span class="literal">has_two_os</span> to each element of <span class="literal">words2</span> and replaces elements that evaluate to <span class="literal">true</span> with <span class="literal">try</span> <span class="ent">➑</span>. The result is that <span class="literal">words2</span> is unaffected and <span class="literal">words3</span> has the element <span class="literal">spoon</span> replaced with <span class="literal">try</span> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec24"><strong><em>fill</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">fill</span> algorithm fills a sequence with some value.</p>&#13;
<p class="indent">The algorithm writes a value into each element of the target sequence. The <span class="literal">fill_n</span> function returns <span class="literal">opt_begin+n</span>.</p>&#13;
<pre>void fill([ep], fwd_begin, fwd_end, value);&#13;
OutputIterator fill_n([ep], opt_begin, n, value);</pre>&#13;
<h5 class="h5" id="ch18lev3sec79"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A <span class="literal">ForwardIterator</span>, <span class="literal">fwd_begin</span>, representing the target sequence’s beginning</li>&#13;
<li class="noindent">A <span class="literal">ForwardIterator</span>, <span class="literal">fwd_end</span>, representing one past the sequence’s end</li>&#13;
<li class="noindent">A <span class="literal">Size n</span> representing the number of elements</li>&#13;
<li class="noindent">A <span class="literal">value</span> to write into each element of the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec80"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm assigns <span class="literal">value</span> exactly <span class="literal">distance(fwd_begin, fwd_end)</span> or <span class="literal">n</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec81"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">value</span> parameter must be writable into the sequence.</li>&#13;
<li class="noindent">Objects of type <span class="literal">Size</span> must be convertible into an integral type.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec82"><span epub:type="pagebreak" id="page_602"/><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
// If police police police police, who polices the police police?&#13;
TEST_CASE("fill") {&#13;
  vector&lt;string&gt; answer1(6); <span class="ent">➊</span>&#13;
  fill(answer1.begin(), answer1.end(), "police"); <span class="ent">➋</span>&#13;
  REQUIRE(answer1 == vector&lt;string&gt;{ "police", "police", "police",&#13;
                                     "police", "police", "police" }); <span class="ent">➌</span>&#13;
&#13;
  vector&lt;string&gt; answer2; <span class="ent">➍</span>&#13;
  fill_n(back_inserter(answer2), 6, "police"); <span class="ent">➎</span>&#13;
  REQUIRE(answer2 == vector&lt;string&gt;{ "police", "police", "police",&#13;
                                     "police", "police", "police" }); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <span class="literal">vector</span> containing <span class="literal">string</span> objects containing six empty elements <span class="ent">➊</span>. Next, you invoke <span class="literal">fill</span> using this <span class="literal">vector</span> as the target sequence and <span class="literal">police</span> as the value <span class="ent">➋</span>. The result is that your <span class="literal">vector</span> contains six <span class="literal">police</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you initialize an empty <span class="literal">vector</span> containing <span class="literal">string</span> objects <span class="ent">➍</span>. You then invoke <span class="literal">fill_n</span> with a <span class="literal">back_inserter</span> pointing to the empty vector, a length of 6, and <span class="literal">police</span> as the value <span class="ent">➎</span>. The result is the same as before: your <span class="literal">vector</span> contains six <span class="literal">police</span> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec25"><strong><em>generate</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">generate</span> algorithm fills a sequence by invoking a function object.</p>&#13;
<p class="indent">The algorithm invokes <span class="literal">generator</span> and assigns the result into the target sequence. The <span class="literal">generate_n</span> function returns <span class="literal">opt_begin+n</span>.</p>&#13;
<pre>void generate([ep], fwd_begin, fwd_end, generator);&#13;
OutputIterator generate_n([ep], opt_begin, n, generator);</pre>&#13;
<h5 class="h5" id="ch18lev3sec83"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A <span class="literal">ForwardIterator</span>, <span class="literal">fwd_begin</span>, representing the target sequence’s beginning</li>&#13;
<li class="noindent">A <span class="literal">ForwardIterator</span>, <span class="literal">fwd_end</span>, representing 1 past the sequence’s end</li>&#13;
<li class="noindent">A <span class="literal">Size n</span> representing the number of elements</li>&#13;
<li class="noindent">A <span class="literal">generator</span> that, when invoked with no arguments, produces an element to write into the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec84"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">generator</span> exactly <span class="literal">distance(fwd_begin, fwd_end)</span> or <span class="literal">n</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec85"><strong><span epub:type="pagebreak" id="page_603"/>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">value</span> parameter must be writable into the sequence.</li>&#13;
<li class="noindent">Objects of type <span class="literal">Size</span> must be convertible into an integral type.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec86"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("generate") {&#13;
  auto i{ 1 }; <span class="ent">➊</span>&#13;
  auto pow_of_2 = [&amp;i]() { <span class="ent">➋</span>&#13;
    const auto tmp = i;&#13;
    i *= 2;&#13;
    return tmp;&#13;
  };&#13;
  vector&lt;int&gt; series1(6); <span class="ent">➌</span>&#13;
  generate(series1.begin(), series1.end(), pow_of_2); <span class="ent">➍</span>&#13;
  REQUIRE(series1 == vector&lt;int&gt;{ 1, 2, 4, 8, 16, 32 }); <span class="ent">➎</span>&#13;
&#13;
  vector&lt;int&gt; series2; <span class="ent">➏</span>&#13;
  generate_n(back_inserter(series2), 6, pow_of_2); <span class="ent">➐</span>&#13;
  REQUIRE(series2 == vector&lt;int&gt;{ 64, 128, 256, 512, 1024, 2048 }); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize an <span class="literal">int</span> called <span class="literal">i</span> to 1 <span class="ent">➊</span>. Next, you create a lambda called <span class="literal">pow_of_2</span>, which takes <span class="literal">i</span> by reference <span class="ent">➋</span>. Each time you invoke <span class="literal">pow_of_2</span>, it doubles <span class="literal">i</span> and returns its value just before the doubling. Next, you initialize a <span class="literal">vector</span> of <span class="literal">int</span> objects with six elements <span class="ent">➌</span>. You then invoke <span class="literal">generate</span> with the <span class="literal">vector</span> as the target sequence and <span class="literal">pow_of_2</span> as the generator <span class="ent">➍</span>. The result is that the <span class="literal">vector</span> contains the first six powers of two <span class="ent">➎</span>.</p>&#13;
<p class="indent">In the second example, you initialize an empty <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➏</span>. Next, you invoke <span class="literal">generate_n</span> using a <span class="literal">back_inserter</span> to your empty <span class="literal">vector</span>, a size of 6, and <span class="literal">pow_of_2</span> as your generator <span class="ent">➐</span>. The <span class="literal">result</span> is the next six powers of two <span class="ent">➑</span>. Notice that <span class="literal">pow_of_2</span> has state because it captures <span class="literal">i</span> by reference.</p>&#13;
<h4 class="h4" id="ch18lev2sec26"><strong><em>remove</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">remove</span> algorithm removes certain elements from a sequence.</p>&#13;
<p class="indent">The algorithm moves all elements where <span class="literal">pred</span> evaluates to <span class="literal">true</span> or where the element equals <span class="literal">value</span> in such a way that the remaining elements’ order is preserved, and it returns an iterator pointing to the first moved element. This iterator is called the resulting sequence’s <em>logical end</em>. The sequence’s physical size remains unchanged, and a call to <span class="literal">remove</span> is typically followed by a call to a container’s <span class="literal">erase</span> method.</p>&#13;
<pre>ForwardIterator remove([ep], fwd_begin, fwd_end, value);&#13;
ForwardIterator remove_if([ep], fwd_begin, fwd_end, pred);&#13;
ForwardIterator remove_copy([ep], fwd_begin, fwd_end, result, value);&#13;
ForwardIterator remove_copy_if([ep], fwd_begin, fwd_end, result, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec87"><span epub:type="pagebreak" id="page_604"/><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">result</span>, representing the destination sequence (if copying)</li>&#13;
<li class="noindent">A <span class="literal">value</span> representing the element to remove</li>&#13;
<li class="noindent">A unary predicate, <span class="literal">pred</span>, that determines whether an element meets the criteria for removal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec88"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">pred</span> or compares with <span class="literal">value</span> exactly <span class="literal">distance(fwd_begin, fwd_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec89"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The elements of the target sequence must be moveable.</li>&#13;
<li class="noindent">If copying, the elements must be copyable, and the target and destination sequences must not overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec90"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("remove") {&#13;
  auto is_vowel = [](char x) { <span class="ent">➊</span>&#13;
    const static string vowels{ "aeiouAEIOU" };&#13;
    return vowels.find(x) != string::npos;&#13;
  };&#13;
  string pilgrim = "Among the things Billy Pilgrim could not change "&#13;
                   "were the past, the present, and the future."; <span class="ent">➋</span>&#13;
  const auto new_end = remove_if(pilgrim.begin(), pilgrim.end(), is_vowel); <span class="ent">➌</span>&#13;
  REQUIRE(pilgrim == "mng th thngs Blly Plgrm cld nt chng wr th pst, "&#13;
                     "th prsnt, nd th ftr.present, and the future."); <span class="ent">➍</span>&#13;
&#13;
  pilgrim.erase(new_end, pilgrim.end()); <span class="ent">➎</span>&#13;
  REQUIRE(pilgrim == "mng th thngs Blly Plgrm cld nt chng wr th "&#13;
                     "pst, th prsnt, nd th ftr."); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first create a lambda called <span class="literal">is_vowel</span> that returns <span class="literal">true</span> if the given <span class="literal">char</span> is a vowel <span class="ent">➊</span>. Next, you construct a <span class="literal">string</span> called <span class="literal">pilgrim</span> containing a sentence <span class="ent">➋</span>. You then invoke <span class="literal">remove_if</span> with <span class="literal">pilgrim</span> as the target sentence and <span class="literal">is_vowel</span> as the predicate <span class="ent">➌</span>. This eliminates all the vowels in the sentence by shifting the remaining characters to the left each time <span class="literal">remove_if</span> <span epub:type="pagebreak" id="page_605"/>encounters a vowel. The result is that <span class="literal">pilgrim</span> contains the original sentence with vowels removed plus the phrase <span class="literal">present, and the future.</span> <span class="ent">➍</span>. This phrase contains 24 characters, which is exactly the number of vowels that <span class="literal">remove_if</span> removed from the original sentence. The phrase <span class="literal">present, and the future.</span> is the detritus from shifting the remaining string during removal.</p>&#13;
<p class="indent">To eliminate these leftovers, you save the iterator <span class="literal">new_end</span>, which <span class="literal">remove_if</span> returns. This points to 1 past the last character in the new target sequence, the <span class="literal">p</span> in <span class="literal">present, and the future.</span> To eliminate, you simply use the <span class="literal">erase</span> method on <span class="literal">pilgrim</span>, which has an overload that accepts a half-open range. You pass the logical end returned by <span class="literal">remove_if</span>, <span class="literal">new_end</span>, as the begin iterator. You also pass <span class="literal">pilgrim.end()</span> as the end iterator <span class="ent">➎</span>. The result is that <span class="literal">pilgrim</span> is now equal to the original sentence with vowels removed <span class="ent">➏</span>.</p>&#13;
<p class="indent">This combination of <span class="literal">remove</span> (or <span class="literal">remove_if</span>) and the <span class="literal">erase</span> method, which is called the <em>erase-remove idiom</em>, is widely used.</p>&#13;
<h4 class="h4" id="ch18lev2sec27"><strong><em>unique</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">unique</span> algorithm removes redundant elements from a sequence.</p>&#13;
<p class="indent">The algorithm moves all repeat elements where <span class="literal">pred</span> evaluates to <span class="literal">true</span> or where the elements are equal such that the remaining elements are unique from their neighbors and original ordering is preserved. It returns an iterator pointing to the new logical end. As with <span class="literal">std::remove</span>, the physical storage doesn’t change.</p>&#13;
<pre>ForwardIterator unique([ep], fwd_begin, fwd_end, [pred]);&#13;
ForwardIterator unique_copy([ep], fwd_begin, fwd_end, result, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec91"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">result</span>, representing the destination sequence (if copying)</li>&#13;
<li class="noindent">A binary predicate, <span class="literal">pred</span>, that determines whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec92"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">pred</span> exactly <span class="literal">distance(fwd_begin, fwd_end) - 1</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec93"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The elements of the target sequence must be moveable.</li>&#13;
<li class="noindent">If copying, elements of the target sequence must by copyable, and the target and destination ranges cannot overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec94"><span epub:type="pagebreak" id="page_606"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("unique") {&#13;
  string without_walls = "Wallless"; <span class="ent">➊</span>&#13;
  const auto new_end = unique(without_walls.begin(), without_walls.end()); <span class="ent">➋</span>&#13;
  without_walls.erase(new_end, without_walls.end()); <span class="ent">➌</span>&#13;
  REQUIRE(without_walls == "Wales"); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">string</span> containing a word with multiple repeated characters <span class="ent">➊</span>. You then invoke <span class="literal">unique</span> with the <span class="literal">string</span> as the target sequence <span class="ent">➋</span>. This returns the logical end, which you assign to <span class="literal">new_end</span>. Next, you erase the range beginning with <span class="literal">new_end</span> and ending with <span class="literal">without_walls.end()</span> <span class="ent">➌</span>. This is a corollary to the erase-remove idiom: you’re left with the contents <span class="literal">Wales</span>, which contains consecutively unique characters <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec28"><strong><em>reverse</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">reverse</span> algorithm reverses the order of a sequence.</p>&#13;
<p class="indent">The algorithm reverses a sequence by either swapping its elements or copying them into a target sequence.</p>&#13;
<pre>void reverse([ep], bi_begin, bi_end);&#13;
OutputIterator reverse_copy([ep], bi_begin, bi_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec95"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">BidirectionalIterator</span>s, <span class="literal">bi_begin</span> and <span class="literal">bi_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">result</span>, representing the destination sequence (if copying)</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec96"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <span class="literal">swap</span> exactly <span class="literal">distance(bi_begin, bi_end)/2</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec97"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The elements of the target sequence must be swappable.</li>&#13;
<li class="noindent">If copying, elements of the target sequence must by copyable, and the target and destination ranges cannot overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec98"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("reverse") {&#13;
<span epub:type="pagebreak" id="page_607"/>  string stinky = "diaper"; <span class="ent">➊</span>&#13;
  reverse(stinky.begin(), stinky.end()); <span class="ent">➋</span>&#13;
  REQUIRE(stinky == "repaid"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">string</span> containing the word <span class="literal">diaper</span> <span class="ent">➊</span>. Next, you invoke reverse with this <span class="literal">string</span> as the target sequence <span class="ent">➋</span>. The result is the word <span class="literal">repaid</span> <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec29"><strong><em>sample</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">sample</span> algorithm generates random, stable subsequences.</p>&#13;
<p class="indent">The algorithm samples <span class="literal">min(pop_end - pop_begin, n)</span> elements from the population sequence. Somewhat unintuitively, the sample will be sorted if and only if <span class="literal">ipt_begin</span> is a forward iterator. It returns the resulting destination sequence’s end.</p>&#13;
<pre>OutputIterator sample([ep], ipt_begin, ipt_end, result, n, urb_generator);</pre>&#13;
<h5 class="h5" id="ch18lev3sec99"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the population sequence (the sequence to sample from)</li>&#13;
<li class="noindent">A <span class="literal">OutputIterator</span>, <span class="literal">result</span>, representing the destination sequence</li>&#13;
<li class="noindent">A <span class="literal">Distance</span> <span class="literal">n</span> representing the number of elements to sample</li>&#13;
<li class="noindent">A <span class="literal">UniformRandomBitGenerator</span> <span class="literal">urb_generator</span>, such as the Mersenne Twister <span class="literal">std::mt19937_64</span> introduced in <a href="ch12.xhtml#ch12">Chapter 12</a></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec100"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm’s complexity scales with <span class="literal">distance(ipt_begin, ipt_end)</span>.</p>&#13;
<h5 class="h5" id="ch18lev3sec101"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;map&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;iomanip&gt;&#13;
#include &lt;random&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const string population = "ABCD"; <span class="ent">➊</span>&#13;
const size_t n_samples{ 1'000'000 }; <span class="ent">➋</span>&#13;
mt19937_64 urbg; <span class="ent">➌</span>&#13;
&#13;
void sample_length(size_t n) { <span class="ent">➍</span>&#13;
  cout &lt;&lt; "-- Length " &lt;&lt; n &lt;&lt; " --\n";&#13;
<span epub:type="pagebreak" id="page_608"/>  map&lt;string, size_t&gt; counts; <span class="ent">➎</span>&#13;
  for (size_t i{}; i &lt; n_samples; i++) {&#13;
    string result;&#13;
    sample(population.begin(), population.end(),&#13;
           back_inserter(result), n, urbg); <span class="ent">➏</span>&#13;
    counts[result]++;&#13;
  }&#13;
  for (const auto[sample, n] : counts) { <span class="ent">➐</span>&#13;
    const auto percentage = 100 * n / static_cast&lt;double&gt;(n_samples);&#13;
    cout &lt;&lt; percentage &lt;&lt; " '" &lt;&lt; sample &lt;&lt; "'\n"; <span class="ent">➑</span>&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; fixed &lt;&lt; setprecision(1); <span class="ent">➒</span>&#13;
  sample_length(0); <span class="ent">➓</span>&#13;
  sample_length(1);&#13;
  sample_length(2);&#13;
  sample_length(3);&#13;
  sample_length(4);&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">-- Length 0 --</span>&#13;
<span class="color1">100.0 ''</span>&#13;
<span class="color1">-- Length 1 --</span>&#13;
<span class="color1">25.1 'A'</span>&#13;
<span class="color1">25.0 'B'</span>&#13;
<span class="color1">25.0 'C'</span>&#13;
<span class="color1">24.9 'D'</span>&#13;
<span class="color1">-- Length 2 --</span>&#13;
<span class="color1">16.7 'AB'</span>&#13;
<span class="color1">16.7 'AC'</span>&#13;
<span class="color1">16.6 'AD'</span>&#13;
<span class="color1">16.6 'BC'</span>&#13;
<span class="color1">16.7 'BD'</span>&#13;
<span class="color1">16.7 'CD'</span>&#13;
<span class="color1">-- Length 3 --</span>&#13;
<span class="color1">25.0 'ABC'</span>&#13;
<span class="color1">25.0 'ABD'</span>&#13;
<span class="color1">25.0 'ACD'</span>&#13;
<span class="color1">25.0 'BCD'</span>&#13;
<span class="color1">-- Length 4 --</span>&#13;
<span class="color1">100.0 'ABCD'</span></pre>&#13;
<p class="indent">You first construct a <span class="literal">const string</span> called <span class="literal">population</span> containing the letters <span class="literal">ABCD</span> <span class="ent">➊</span>. You also initialize a <span class="literal">const size_t</span> called <span class="literal">n_samples</span> equal to a million <span class="ent">➋</span> and a Mersenne Twister called <span class="literal">urbg</span> <span class="ent">➌</span>. All of these objects have static storage duration.</p>&#13;
<p class="indent">In addition, you initialize the function <span class="literal">sample_length</span>, which takes a single <span class="literal">size_t</span> argument called <span class="literal">n</span> <span class="ent">➍</span>. Within the function, you construct a <span class="literal">map</span> of <span class="literal">string</span> to <span class="literal">size_t</span> objects <span class="ent">➎</span> that will count the frequency of each <span class="literal">sample</span> invocation. Within a <span class="literal">for</span> loop, you invoke <span class="literal">sample</span> with <span class="literal">population</span> as the population <span epub:type="pagebreak" id="page_609"/>sequence, a <span class="literal">back_inserter</span> to a <span class="literal">result</span> string as the destination sequence, <span class="literal">n</span> as the sample length, and <span class="literal">urbg</span> as the random bit generator <span class="ent">➏</span>.</p>&#13;
<p class="indent">After a million iterations, you iterate over each element of <span class="literal">counts</span> <span class="ent">➐</span> and print the probability distribution of each sample for the given length <span class="literal">n</span> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you configure floating-point formatting with <span class="literal">fixed</span> and <span class="literal">setprecision</span> <span class="ent">➒</span>. Finally, you invoke <span class="literal">sample_length</span> with each value from <span class="literal">0</span> to <span class="literal">4</span> inclusive <span class="ent">➓</span>.</p>&#13;
<p class="indent">Because <span class="literal">string</span> provides random access iterators, <span class="literal">sample</span> provides <em>stable</em> (sorted) samples.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Notice that the output doesn’t contain any unsorted samples like <span class="codeitalic">DC</span> or <span class="codeitalic">CAB</span>. This sorting behavior isn’t necessarily obvious from the algorithm’s name, so be careful!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec30"><strong><em>shuffle</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">shuffle</span> algorithm generates random permutations.</p>&#13;
<p class="indent">The algorithm randomizes the target sequence such that each possible permutation of those elements has equal probability of appearance.</p>&#13;
<pre>void shuffle(rnd_begin, rnd_end, urb_generator);</pre>&#13;
<h5 class="h5" id="ch18lev3sec102"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <span class="literal">RandomAccessIterator</span>s, <span class="literal">rnd_begin</span> and <span class="literal">rnd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">UniformRandomBitGenerator</span> <span class="literal">urb_generator</span>, such as the Mersenne Twister <span class="literal">std::mt19937_64</span> introduced in <a href="ch12.xhtml#ch12">Chapter 12</a></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec103"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm swaps exactly <span class="literal">distance(rnd_begin, rnd_end) - 1</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec104"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable.</p>&#13;
<h5 class="h5" id="ch18lev3sec105"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;map&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;random&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  const string population = "ABCD"; <span class="ent">➊</span>&#13;
  const size_t n_samples{ 1'000'000 }; <span class="ent">➋</span>&#13;
  mt19937_64 urbg; <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_610"/>  map&lt;string, size_t&gt; samples; <span class="ent">➍</span>&#13;
  cout &lt;&lt; fixed &lt;&lt; setprecision(1); <span class="ent">➎</span>&#13;
  for (size_t i{}; i &lt; n_samples; i++) {&#13;
    string result{ population }; <span class="ent">➏</span>&#13;
    shuffle(result.begin(), result.end(), urbg); <span class="ent">➐</span>&#13;
    samples[result]++; <span class="ent">➑</span>&#13;
  }&#13;
  for (const auto[sample, n] : samples) { <span class="ent">➒</span>&#13;
    const auto percentage = 100 * n / static_cast&lt;double&gt;(n_samples);&#13;
    cout &lt;&lt; percentage &lt;&lt; " '" &lt;&lt; sample &lt;&lt; "'\n"; <span class="ent">➓</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">4.2 'ABCD'</span>&#13;
<span class="color1">4.2 'ABDC'</span>&#13;
<span class="color1">4.1 'ACBD'</span>&#13;
<span class="color1">4.2 'ACDB'</span>&#13;
<span class="color1">4.2 'ADBC'</span>&#13;
<span class="color1">4.2 'ADCB'</span>&#13;
<span class="color1">4.2 'BACD'</span>&#13;
<span class="color1">4.2 'BADC'</span>&#13;
<span class="color1">4.1 'BCAD'</span>&#13;
<span class="color1">4.2 'BCDA'</span>&#13;
<span class="color1">4.1 'BDAC'</span>&#13;
<span class="color1">4.2 'BDCA'</span>&#13;
<span class="color1">4.2 'CABD'</span>&#13;
<span class="color1">4.2 'CADB'</span>&#13;
<span class="color1">4.1 'CBAD'</span>&#13;
<span class="color1">4.1 'CBDA'</span>&#13;
<span class="color1">4.2 'CDAB'</span>&#13;
<span class="color1">4.1 'CDBA'</span>&#13;
<span class="color1">4.2 'DABC'</span>&#13;
<span class="color1">4.2 'DACB'</span>&#13;
<span class="color1">4.2 'DBAC'</span>&#13;
<span class="color1">4.1 'DBCA'</span>&#13;
<span class="color1">4.2 'DCAB'</span>&#13;
<span class="color1">4.2 'DCBA'</span></pre>&#13;
<p class="indent">You first construct a <span class="literal">const string</span> called <span class="literal">population</span> containing the letters <span class="literal">ABCD</span> <span class="ent">➊</span>. You also initialize a <span class="literal">const size_t</span> called <span class="literal">n_samples</span> equal to a million <span class="ent">➋</span>, a Mersenne Twister called <span class="literal">urbg</span> <span class="ent">➌</span>, and a <span class="literal">map</span> of <span class="literal">string</span> to <span class="literal">size_t</span> objects <span class="ent">➍</span> that will count the frequencies of each <span class="literal">shuffle</span> sample. In addition, you configure floating-point formatting with <span class="literal">fixed</span> and <span class="literal">setprecision</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Within a <span class="literal">for</span> loop, you copy <span class="literal">population</span> into a new string called <span class="literal">sample</span> because <span class="literal">shuffle</span> modifies the target sequence <span class="ent">➏</span>. You then invoke <span class="literal">shuffle</span> with <span class="literal">result</span> as the target sequence and <span class="literal">urbg</span> as the random bit generator <span class="ent">➐</span>, and you record the result within <span class="literal">samples</span> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Finally, you iterate over each element in <span class="literal">samples</span> <span class="ent">➒</span> and print the probability distribution of each sample <span class="ent">➓</span>.</p>&#13;
<p class="indent">Notice that, unlike with <span class="literal">sample</span>, <span class="literal">shuffle</span> always produces an <em>unordered</em> distribution of elements.</p>&#13;
<h3 class="h3" id="ch18lev1sec5"><span epub:type="pagebreak" id="page_611"/><strong>Sorting and Related Operations</strong></h3>&#13;
<p class="noindent">A <em>sorting operation</em> is an algorithm that reorders a sequence in some desired way.</p>&#13;
<p class="indent">Each sorting algorithm has two versions: one that takes a function object called a <em>comparison operator</em> and one that uses <span class="literal">operator&lt;</span>. A comparison operator is a function object that is invokable with two objects to compare. It returns <span class="literal">true</span> if the first argument is <em>less than</em> the second argument; otherwise, it returns <span class="literal">false</span>. The sort interpretation of <span class="literal">x &lt; y</span> is that <span class="literal">x</span> is sorted before <span class="literal">y</span>. All the algorithms explained in this section are in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Notice that <span class="codeitalic">operator&lt;</span> is a valid comparison operator.</em></p>&#13;
</div>&#13;
<p class="indent">Comparison operators must be transitive. This means that for any elements <span class="literal">a</span>, <span class="literal">b</span>, and <span class="literal">c</span> the comparison operator <span class="literal">comp</span> must preserve the following relationship: if <span class="literal">comp(a, b)</span> and <span class="literal">comp(b, c)</span>, then <span class="literal">comp(a, c)</span>. This should make sense: if <span class="literal">a</span> is ordered before <span class="literal">b</span> and <span class="literal">b</span> is ordered before <span class="literal">c</span>, then <span class="literal">a</span> must be ordered before <span class="literal">c</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec31"><strong><em>sort</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">sort</span> algorithm sorts a sequence (unstably).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A stable sort retains the relative, pre-sort ordering of equal elements, whereas an unstable sort might reorder them.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm sorts the target sequence in place.</p>&#13;
<pre>void sort([ep], rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec106"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">RandomAccessIterator</span>s, <span class="literal">rnd_begin</span> and <span class="literal">rnd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec107"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quasilinear</strong> O(N log N) where N = <span class="literal">distance(rnd_begin, rnd_end)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec108"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec109"><span epub:type="pagebreak" id="page_612"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("sort") {&#13;
  string goat_grass{ "spoilage" }; <span class="ent">➊</span>&#13;
  sort(goat_grass.begin(), goat_grass.end()); <span class="ent">➋</span>&#13;
  REQUIRE(goat_grass == "aegilops"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">string</span> containing the word <span class="literal">spoilage</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">sort</span> with this <span class="literal">string</span> as the target sequence <span class="ent">➋</span>. The result is that <span class="literal">goat_</span><span class="literal">grass</span> now contains the word <span class="literal">aegilops</span> (a genus of invasive weeds) <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec32"><strong><em>stable_sort</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">stable_sort</span> algorithm sorts a sequence stably.</p>&#13;
<p class="indent">The algorithm sorts the target sequence in place. Equal elements retain their original ordering.</p>&#13;
<pre>void stable_sort([ep], rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec110"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">RandomAccessIterator</span>s, <span class="literal">rnd_begin</span> and <span class="literal">rnd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec111"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Polylog-linear</strong> O(N log<sup>2</sup> N) where N = <span class="literal">distance(rnd_begin, rnd_end)</span>. If additional memory is available, complexity reduces to quasilinear.</p>&#13;
<h5 class="h5" id="ch18lev3sec112"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec113"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
enum class CharCategory { <span class="ent">➊</span>&#13;
  Ascender,&#13;
  Normal,&#13;
  Descender&#13;
};&#13;
&#13;
CharCategory categorize(char x) { <span class="ent">➋</span>&#13;
  switch (x) {&#13;
<span epub:type="pagebreak" id="page_613"/>    case 'g':&#13;
    case 'j':&#13;
    case 'p':&#13;
    case 'q':&#13;
    case 'y':&#13;
      return CharCategory::Descender;&#13;
    case 'b':&#13;
    case 'd':&#13;
    case 'f':&#13;
    case 'h':&#13;
    case 'k':&#13;
    case 'l':&#13;
    case 't':&#13;
      return CharCategory::Ascender;&#13;
  }&#13;
  return CharCategory::Normal;&#13;
}&#13;
&#13;
bool ascension_compare(char x, char y) { <span class="ent">➌</span>&#13;
  return categorize(x) &lt; categorize(y);&#13;
}&#13;
&#13;
TEST_CASE("stable_sort") {&#13;
  string word{ "outgrin" }; <span class="ent">➍</span>&#13;
  stable_sort(word.begin(), word.end(), ascension_compare); <span class="ent">➎</span>&#13;
  REQUIRE(word == "touring"); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">This example sorts a <span class="literal">string</span> using the <em>ascenders</em> and <em>descenders</em>. In typography, an ascender is a letter with a portion that extends above what is known as the mean line of a font. A descender is a letter with a portion that extends below what is known as the baseline. Letters commonly typed with descenders are <em>g</em>, <em>j</em>, <em>p</em>, <em>q</em>, and <em>y</em>. Letters commonly typed with ascenders are <em>b</em>, <em>d</em>, <em>f</em>, <em>h</em>, <em>k</em>, <em>l</em>, and <em>t</em>. This example seeks a <span class="literal">stable_sort</span> so that all letters with ascenders appear before all other letters and letters with descenders appear after all other letters. Letters with neither an ascender nor a descender lie in the middle. As a <span class="literal">stable_sort</span>, the relative ordering of letters with common ascender/descender categorization must not change.</p>&#13;
<p class="indent">You first define an <span class="literal">enum class</span> called <span class="literal">CharCategory</span> that takes on three possible values: <span class="literal">Ascender</span>, <span class="literal">Normal</span>, or <span class="literal">Descender</span> <span class="ent">➊</span>. Next, you define a function that categorizes a given char into a <span class="literal">CharCategory</span> <span class="ent">➋</span>. (Recall from “Switch Statements” on <a href="ch02.xhtml#page_50">page 50</a> that labels “fall through” if you don’t include a <span class="literal">break</span>.) You also define an <span class="literal">ascension_compare</span> function that converts two given <span class="literal">char</span> objects into <span class="literal">CharCategory</span> objects and compares them with <span class="literal">operator&lt;</span> <span class="ent">➌</span>. Because <span class="literal">enum class</span> objects convert implicitly to <span class="literal">int</span> objects and because you define <span class="literal">CharCategory</span> with its values in the intended order, this will sort letters with ascenders ahead of normal letters ahead of letters with descenders.</p>&#13;
<p class="indent">Within the test case, you initialize a <span class="literal">string</span> containing the word <span class="literal">outgrin</span> <span class="ent">➍</span>. Next, you invoke <span class="literal">stable_sort</span> with this <span class="literal">string</span> as the target sequence and <span class="literal">ascension_compare</span> as the comparison operator <span class="ent">➎</span>. The result is that <span class="literal">word</span> now <span epub:type="pagebreak" id="page_614"/>contains <span class="literal">touring</span> <span class="ent">➏</span>. Notice that <span class="literal">t</span>, the only ascender, appears before all the normal characters (which are in the same order as in <span class="literal">outgrin</span>), which appear before <span class="literal">g</span>, the only descender.</p>&#13;
<h4 class="h4" id="ch18lev2sec33"><strong><em>partial_sort</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">partial_sort</span> algorithm sorts a sequence into two groups.</p>&#13;
<p class="indent">If modifying, the algorithm sorts the first <span class="literal">(rnd_middle – rnd_first)</span> elements in the target sequence so all elements in <span class="literal">rnd_begin</span> to <span class="literal">rnd_middle</span> are less than the rest of the elements. If copying, the algorithm places the first <span class="literal">min(distance(ipt_begin, ipt_end), distance(rnd_begin, rnd_end))</span> sorted elements into the destination sequence, and it returns an iterator pointing to the end of the destination sequence.</p>&#13;
<p class="indent">Basically, a partial sort allows you to find the first few elements of a sorted sequence without having to sort the entire sequence. For example, if you had the sequence D C B A, you could partial sort the first two elements and obtain the result A B D C. The first two elements are the same as if you’d sorted the entire sequence, but the remaining elements aren’t.</p>&#13;
<pre>void partial_sort([ep], rnd_begin, rnd_middle, rnd_end, [comp]);&#13;
RandomAccessIterator partial_sort_copy([ep], ipt_begin, ipt_end,&#13;
                                       rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec114"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">If modifying, a trio of <span class="literal">RandomAccessIterator</span>s, <span class="literal">rnd_begin</span>, <span class="literal">rnd_middle</span>, and <span class="literal">rnd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">If copying, a pair <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span> representing the target sequence and a pair <span class="literal">rnd_begin</span> and <span class="literal">rnd_end</span> representing the destination sequence</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec115"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quasilinear</strong> O(N log N) where N = <span class="literal">distance(rnd_begin, rnd_end) * log(distance(rnd_begin, rnd_middle)</span> or <span class="literal">distance(rnd_begin, rnd_end) * log(min(distance(rnd_begin, rnd_end), distance(ipt_begin, ipt_end))</span> for the copy variant</p>&#13;
<h5 class="h5" id="ch18lev3sec116"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec117"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
bool ascension_compare(char x, char y) {&#13;
<span class="codeitalic1">--snip--</span>&#13;
<span epub:type="pagebreak" id="page_615"/>}&#13;
&#13;
TEST_CASE("partial_sort") {&#13;
  string word1{ "nectarous" }; <span class="ent">➊</span>&#13;
  partial_sort(word1.begin(), word1.begin() + 4, word1.end()); <span class="ent">➋</span>&#13;
  REQUIRE(word1 == "acentrous"); <span class="ent">➌</span>&#13;
&#13;
  string word2{ "pretanning" }; <span class="ent">➍</span>&#13;
  partial_sort(word2.begin(), word2.begin() + 3, <span class="ent">➎</span>&#13;
               word2.end(), ascension_compare);&#13;
  REQUIRE(word2 == "trepanning"); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <span class="literal">string</span> containing the word <span class="literal">nectarous</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">partial_sort</span> with this <span class="literal">string</span> as the target sequence and the fifth letter (<span class="literal">a</span>) as the second argument to <span class="literal">partial_sort</span> <span class="ent">➋</span>. The result is that the sequence now contains the word <span class="literal">acentrous</span> <span class="ent">➌</span>. Notice that the first four letters of <span class="literal">acentrous</span> are sorted and that they’re less than the remaining characters in the sequence.</p>&#13;
<p class="indent">In the second example, you initialize a <span class="literal">string</span> containing the word <span class="literal">pretanning</span> <span class="ent">➍</span>, which you use as the target sequence for <span class="literal">partial_sort</span> <span class="ent">➎</span>. In this example, you specify the fourth character (<span class="literal">t</span>) as the second argument to <span class="literal">partial_sort</span>, and you use the <span class="literal">ascension_compare</span> function from the <span class="literal">stable_sort</span> example as the comparison operator. The result is that the sequence now contains the word <span class="literal">trepanning</span> <span class="ent">➏</span>. Notice that the first three letters are sorted according to <span class="literal">ascension_compare</span> and none of the remaining characters in the second argument to <span class="literal">partial_sort</span> to <span class="literal">z</span> is less than the first three characters.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Technically, the <span class="codeitalic">REQUIRE</span> statements in the preceding example might fail on some standard library implementations. Because <span class="codeitalic">std::partial_sort</span> isn’t guaranteed to be stable, results may vary.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec34"><strong><em>is_sorted</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">is_sorted</span> algorithm determines whether a sequence is sorted.</p>&#13;
<p class="indent">The algorithm returns true if the target sequence is sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span>, if given. The <span class="literal">is_sorted_until</span> algorithm returns an iterator pointing to the first unsorted element or <span class="literal">rnd_end</span> if the target sequence is sorted.</p>&#13;
<pre>bool is_sorted([ep], rnd_begin, rnd_end, [comp]);&#13;
ForwardIterator is_sorted_until([ep], rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec118"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">RandomAccessIterator</span>s, <span class="literal">rnd_begin</span> and <span class="literal">rnd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec119"><span epub:type="pagebreak" id="page_616"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm compares <span class="literal">distance(rnd_begin, rnd_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec120"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
bool ascension_compare(char x, char y) {&#13;
<span class="codeitalic1">--snip--</span>&#13;
}&#13;
&#13;
TEST_CASE("is_sorted") {&#13;
  string word1{ "billowy" }; <span class="ent">➊</span>&#13;
  REQUIRE(is_sorted(word1.begin(), word1.end())); <span class="ent">➋</span>&#13;
&#13;
  string word2{ "floppy" }; <span class="ent">➌</span>&#13;
  REQUIRE(word2.end() == is_sorted_until(word2.begin(), <span class="ent">➍</span>&#13;
                                         word2.end(), ascension_compare));&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">string</span> containing the word <span class="literal">billowy</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">is_sort</span> with this <span class="literal">string</span> as the target sequence, which returns <span class="literal">true</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">In the second example, you construct a <span class="literal">string</span> containing the word <span class="literal">floppy</span> <span class="ent">➌</span>. You then invoke <span class="literal">is_sorted_until</span> with this <span class="literal">string</span> as the target sequence, which returns <span class="literal">rnd_end</span> because the sequence is sorted <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec35"><strong><em>nth_element</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">nth_element</span> algorithm places a particular element in a sequence into its correct sorted position.</p>&#13;
<p class="indent">This partial sorting algorithm modifies the target sequence in the following way: the element in the position pointed to by <span class="literal">rnd_nth</span> is in that position as if the whole range were sorted. All elements from <span class="literal">rnd_begin</span> to <span class="literal">rnd_nth-1</span> will be less than <span class="literal">rnd_nth</span>. If <span class="literal">rnd_nth == rnd_end</span>, the function performs no operation.</p>&#13;
<pre>bool nth_element([ep], rnd_begin, rnd_nth, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec121"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::</span><span class="literal">seq</span>)</li>&#13;
<li class="noindent">A trio of <span class="literal">RandomAccessIterator</span>s, <span class="literal">rnd_begin</span>, <span class="literal">rnd_nth</span>, and <span class="literal">rnd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec122"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm compares <span class="literal">distance(rnd_begin, rnd_end)</span> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec123"><span epub:type="pagebreak" id="page_617"/><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec124"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("nth_element") {&#13;
  vector&lt;int&gt; numbers{ 1, 9, 2, 8, 3, 7, 4, 6, 5 }; <span class="ent">➊</span>&#13;
  nth_element(numbers.begin(), numbers.begin() + 5, numbers.end()); <span class="ent">➋</span>&#13;
  auto less_than_6th_elem = [&amp;elem=numbers[5]](int x) { <span class="ent">➌</span>&#13;
    return x &lt; elem;&#13;
  };&#13;
  REQUIRE(all_of(numbers.begin(), numbers.begin() + 5, less_than_6th_elem)); <span class="ent">➍</span>&#13;
  REQUIRE(numbers[5] == 6 ); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">vector</span> of <span class="literal">int</span> objects containing the number sequence 1 to 10 inclusive <span class="ent">➊</span>. Next, you invoke <span class="literal">nth_element</span> with this <span class="literal">vector</span> as the target sequence <span class="ent">➋</span>. You then initialize a lambda named <span class="literal">less_than_6th_elem</span>, which compares an <span class="literal">int</span> with the sixth element of <span class="literal">numbers</span> with <span class="literal">operator&lt;</span> <span class="ent">➌</span>. This allows you to check that all elements before the sixth element are less than the sixth element <span class="ent">➍</span>. The sixth element is 6 <span class="ent">➎</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec6"><strong>Binary Search</strong></h3>&#13;
<p class="noindent"><em>Binary search algorithms</em> assume that a target sequence is already sorted. These algorithms have desirable complexity characteristics compared with generic search over an unspecified sequence. Each algorithm explained in this section is in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec36"><strong><em>lower_bound</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">lower_bound</span> algorithm finds a partition in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns an iterator corresponding to the element <span class="literal">result</span>, which partitions the sequence so the elements before <span class="literal">result</span> are less than <span class="literal">value</span>, whereas <span class="literal">result</span> and all elements after it aren’t less than <span class="literal">value</span>.</p>&#13;
<pre>ForwardIterator lower_bound(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec125"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">value</span> to partition the target sequence with</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec126"><span epub:type="pagebreak" id="page_618"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <span class="literal">O(log N)</span> where <span class="literal">N = distance (fwd_begin, fwd_end</span>); otherwise, <span class="literal">O(N)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec127"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec128"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("lower_bound") {&#13;
  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  const auto result = lower_bound(numbers.begin(), numbers.end(), 5); <span class="ent">➋</span>&#13;
  REQUIRE(result == numbers.begin() + 2); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➊</span>. Next, you invoke <span class="literal">lower_bound</span> with this <span class="literal">vector</span> as the target sequence and a <span class="literal">value</span> of <span class="literal">5</span> <span class="ent">➋</span>. The result is the third element, <span class="literal">5</span> <span class="ent">➌</span>. The elements <span class="literal">2</span> and <span class="literal">4</span> are less than <span class="literal">5</span>, whereas the elements <span class="literal">5</span>, <span class="literal">6</span>, <span class="literal">6</span>, and <span class="literal">9</span> are not.</p>&#13;
<h4 class="h4" id="ch18lev2sec37"><strong><em>upper_bound</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">upper_bound</span> algorithm finds a partition in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns an iterator corresponding to the element <span class="literal">result</span>, which is the first element in the target sequence greater than <span class="literal">value</span>.</p>&#13;
<pre>ForwardIterator upper_bound(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec129"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">value</span> to partition the target sequence with</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec130"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <span class="literal">O(log N)</span> where <span class="literal">N = distance (fwd_begin, fwd_end</span>); otherwise, <span class="literal">O(N)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec131"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec132"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("upper_bound") {&#13;
<span epub:type="pagebreak" id="page_619"/>  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  const auto result = upper_bound(numbers.begin(), numbers.end(), 5); <span class="ent">➋</span>&#13;
  REQUIRE(result == numbers.begin() + 3); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➊</span>. Next, you invoke <span class="literal">upper_bound</span> with this <span class="literal">vector</span> as the target sequence and a <span class="literal">value</span> of <span class="literal">5</span> <span class="ent">➋</span>. The result is the fourth element, <span class="literal">6</span>, which is the first element in the target sequence greater than <span class="literal">value</span> <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec38"><strong><em>equal_range</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">equal_range</span> algorithm finds a range of certain elements in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns a <span class="literal">std::pair</span> of iterators corresponding to the half-open range equal to <span class="literal">value</span>.</p>&#13;
<pre>ForwardIteratorPair equal_range(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec133"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">value</span> to seek</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec134"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <span class="literal">O(log N)</span> where <span class="literal">N = distance (fwd_begin, fwd_end)</span>; otherwise, <span class="literal">O(N)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec135"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec136"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("equal_range") {&#13;
  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  const auto[rbeg, rend] = equal_range(numbers.begin(), numbers.end(), 6); <span class="ent">➋</span>&#13;
  REQUIRE(rbeg == numbers.begin() + 3); <span class="ent">➌</span>&#13;
  REQUIRE(rend == numbers.begin() + 5); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➊</span>. Next, you invoke <span class="literal">equal_range</span> with this <span class="literal">vector</span> as the target sequence and a <span class="literal">value</span> of <span class="literal">6</span> <span class="ent">➋</span>. The result is an iterator pair representing the matching range. The begin iterator points to the fourth element <span class="ent">➌</span>, and the second iterator points to the sixth element <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec39"><strong><em><span epub:type="pagebreak" id="page_620"/>binary_search</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">binary_search</span> algorithm finds a particular element in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns <span class="literal">true</span> if the range contains <span class="literal">value</span>. Specifically, it returns <span class="literal">true</span> if the target sequence contains an element <span class="literal">x</span> such that neither <span class="literal">x &lt; value</span> nor <span class="literal">value &lt; x</span>. If <span class="literal">comp</span> is provided, it returns <span class="literal">true</span> if the target sequence contains an element <span class="literal">x</span> such that neither <span class="literal">comp(x, value)</span> nor <span class="literal">comp(value, x)</span>.</p>&#13;
<pre>bool binary_search(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec137"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">value</span> to seek</li>&#13;
<li class="noindent">An optional comparison operator, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec138"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <span class="literal">O(log N)</span> where <span class="literal">N = distance (fwd_begin, fwd_end)</span>; otherwise, <span class="literal">O(N)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec139"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec140"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("binary_search") {&#13;
  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  REQUIRE(binary_search(numbers.begin(), numbers.end(), 6)); <span class="ent">➋</span>&#13;
  REQUIRE_FALSE(binary_search(numbers.begin(), numbers.end(), 7)); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➊</span>. Next, you invoke <span class="literal">binary_search</span> with this <span class="literal">vector</span> as the target sequence and a value of <span class="literal">6</span>. Because the sequence contains 6, <span class="literal">binary_search</span> returns <span class="literal">true</span> <span class="ent">➋</span>. When you invoke <span class="literal">binary_search</span> with <span class="literal">7</span>, it returns <span class="literal">false</span> because the target sequence doesn’t contain <span class="literal">7</span> <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec7"><strong>Partitioning Algorithms</strong></h3>&#13;
<p class="noindent">A <em>partitioned sequence</em> contains two contiguous, distinct groups of elements. These groups don’t mix, and the first element of the second distinct group is called the <em>partition point</em>. The stdlib contains algorithms to partition sequences, determine whether a sequence is partitioned, and find partition points. Each algorithm explained in this section is in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec40"><strong><em><span epub:type="pagebreak" id="page_621"/>is_partitioned</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">is_partitioned</span>    algorithm determines whether a sequence is partitioned.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A sequence is partitioned if all elements with some attribute appear before the elements that don’t.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm returns <span class="literal">true</span> if every element in the target sequence for which <span class="literal">pred</span> evaluates to <span class="literal">true</span> appears before the other elements.</p>&#13;
<pre>bool is_partitioned([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec141"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A predicate, <span class="literal">pred</span>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec142"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> At most <span class="literal">distance(ipt_begin, ipt_end)</span> evaluations of <span class="literal">pred</span></p>&#13;
<h5 class="h5" id="ch18lev3sec143"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("is_partitioned") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
&#13;
  vector&lt;int&gt; numbers1{ 9, 5, 9, 6, 4, 2 }; <span class="ent">➋</span>&#13;
  REQUIRE(is_partitioned(numbers1.begin(), numbers1.end(), is_odd)); <span class="ent">➌</span>&#13;
&#13;
  vector&lt;int&gt; numbers2{ 9, 4, 9, 6, 4, 2 }; <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(is_partitioned(numbers2.begin(), numbers2.end(), is_odd)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <span class="literal">is_odd</span>, which returns <span class="literal">true</span> if the given number is odd <span class="ent">➊</span>. Next, you construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➋</span> and invoke <span class="literal">is_partitioned</span> with this <span class="literal">vector</span> as the target sequence and <span class="literal">is_odd</span> as the predicate. Because the sequence contains all its odd numbers placed before its even numbers, <span class="literal">is_partitioned</span> returns <span class="literal">true</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You then construct another <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➍</span> and again invoke <span class="literal">is_partitioned</span> with this <span class="literal">vector</span> as the target sequence and <span class="literal">is_odd</span> as the predicate. Because the sequence doesn’t contain all its odd numbers placed before its even numbers (4 is even and before the second 9), <span class="literal">is_partitioned</span> returns <span class="literal">false</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec41"><strong><em><span epub:type="pagebreak" id="page_622"/>partition</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">partition</span> algorithm partitions a sequence.</p>&#13;
<p class="indent">The algorithm mutates the target sequence so it’s partitioned according to <span class="literal">pred</span>. It returns the partition point. The elements’ original ordering isn’t necessarily preserved.</p>&#13;
<pre>ForwardIterator partition([ep], fwd_begin, fwd_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec144"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A predicate, <span class="literal">pred</span>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec145"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> At most <span class="literal">distance(fwd_begin, fwd_end)</span> evaluations of <span class="literal">pred</span></p>&#13;
<h5 class="h5" id="ch18lev3sec146"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence’s elements must be swappable.</p>&#13;
<h5 class="h5" id="ch18lev3sec147"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("partition") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; numbers{ 1, 2, 3, 4, 5 }; <span class="ent">➋</span>&#13;
  const auto partition_point = partition(numbers.begin(),&#13;
                                         numbers.end(), is_odd); <span class="ent">➌</span>&#13;
  REQUIRE(is_partitioned(numbers.begin(), numbers.end(), is_odd)); <span class="ent">➍</span>&#13;
  REQUIRE(partition_point == numbers.begin() + 3); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <span class="literal">is_odd</span>, which returns <span class="literal">true</span> if the given number is <span class="literal">odd</span> <span class="ent">➊</span>. Next, you construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➋</span> and invoke <span class="literal">partition</span> with this <span class="literal">vector</span> as the target sequence and <span class="literal">is_odd</span> as the predicate. You assign the resulting partition point into <span class="literal">partition_point</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">When you invoke <span class="literal">is_partitioned</span> on the target sequence with <span class="literal">is_odd</span> as the predicate, it returns <span class="literal">true</span> <span class="ent">➍</span>. Per the specification of the algorithm, <em>you cannot rely on the ordering within the groups</em>, but the <span class="literal">partition_point</span> will always be the fourth element, because the target sequence contains three odd numbers <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec42"><strong><em>partition_copy</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">partition_copy</span> algorithm partitions a sequence.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_623"/>The algorithm partitions the target sequence by evaluating <span class="literal">pred</span> on each element. All true elements copy into <span class="literal">opt_true</span>, and all false elements copy into <span class="literal">opt_false</span>.</p>&#13;
<pre>ForwardIteratorPair partition_copy([ep], ipt_begin, ipt_end,&#13;
                                         opt_true, opt_false, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec148"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">InputIterator</span> objects, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">opt_true</span>, to receive copies of <span class="literal">true</span> elements</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">opt_false</span>, to receive copies of <span class="literal">false</span> elements</li>&#13;
<li class="noindent">A predicate, <span class="literal">pred</span>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec149"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> Exactly <span class="literal">distance(ipt_begin, ipt_end)</span> evaluations of <span class="literal">pred</span></p>&#13;
<h5 class="h5" id="ch18lev3sec150"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The target sequence’s elements must be copy assignable.</li>&#13;
<li class="noindent">The input and output ranges must not overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec151"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("partition_copy") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; numbers{ 1, 2, 3, 4, 5 }, odds, evens; <span class="ent">➋</span>&#13;
  partition_copy(numbers.begin(), numbers.end(),&#13;
                 back_inserter(odds), back_inserter(evens), is_odd); <span class="ent">➌</span>&#13;
  REQUIRE(all_of(odds.begin(), odds.end(), is_odd)); <span class="ent">➍</span>&#13;
  REQUIRE(none_of(evens.begin(), evens.end(), is_odd)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <span class="literal">is_odd</span>, which returns <span class="literal">true</span> if the given number is <span class="literal">odd</span> <span class="ent">➊</span>. Next, you construct a <span class="literal">vector</span> of <span class="literal">int</span> objects containing the <span class="literal">numbers</span> from 1 to 5 and two empty <span class="literal">vector</span> objects called <span class="literal">odds</span> and <span class="literal">evens</span> <span class="ent">➋</span>. Next, you invoke <span class="literal">partition_copy</span> with <span class="literal">numbers</span> as the target sequence, a <span class="literal">back_inserter</span> to <span class="literal">odds</span> as the output for true elements, a <span class="literal">back_inserter</span> to <span class="literal">evens</span> as the output for false elements, and <span class="literal">is_odd</span> as the predicate <span class="ent">➌</span>. The result is that all of the elements in <span class="literal">odds</span> are odd <span class="ent">➍</span> and none of the elements in <span class="literal">evens</span> are odd <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec43"><strong><em><span epub:type="pagebreak" id="page_624"/>stable_partition</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">stable_partition</span> algorithm partitions a sequence stably.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A stable partition might take more computation than an unstable partition, so the user is given the choice.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm mutates the target sequence so it’s partitioned according to <span class="literal">pred</span>. It returns the partition point. The elements’ original ordering is preserved.</p>&#13;
<pre>BidirectionalIterator stable_partition([ep], bid_begin, bid_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec152"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">BidirectionalIterator</span>s, <span class="literal">bid_begin</span> and <span class="literal">bid_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A predicate, <span class="literal">pred</span>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec153"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quasilinear</strong> <span class="literal">O(N log N)</span> swaps where    <span class="literal">N = distance(bid_begin, bid_end)</span>, or <span class="literal">O(N)</span> swaps if sufficient memory is available.</p>&#13;
<h5 class="h5" id="ch18lev3sec154"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence’s elements must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec155"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("stable_partition") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; numbers{ 1, 2, 3, 4, 5 }; <span class="ent">➋</span>&#13;
  stable_partition(numbers.begin(), numbers.end(), is_odd); <span class="ent">➌</span>&#13;
  REQUIRE(numbers == vector&lt;int&gt;{ 1, 3, 5, 2, 4 }); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <span class="literal">is_odd</span>, which returns <span class="literal">true</span> if the given number is <span class="literal">odd</span> <span class="ent">➊</span>. Next, you construct a <span class="literal">vector</span> of <span class="literal">int</span> objects <span class="ent">➋</span> and invoke <span class="literal">stable_partition</span> with this <span class="literal">vector</span> as the target sequence and <span class="literal">is_odd</span> as the predicate <span class="ent">➌</span>. The result is that the <span class="literal">vector</span> contains the elements 1, 3, 5, 2, 4 because this is the only way to partition these numbers while preserving their original within-group order <span class="ent">➍</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec8"><span epub:type="pagebreak" id="page_625"/><strong>Merging Algorithms</strong></h3>&#13;
<p class="noindent"><em>Merging algorithms</em> merge two sorted target sequences such that the resulting sequence contains copies of both target sequences and is also sorted. Each algorithm explained in this section is in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec44"><strong><em>merge</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">merge</span> algorithm merges two sorted sequences.</p>&#13;
<p class="indent">The algorithm copies both target sequences into the destination sequence. The destination sequence is sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span> if provided.</p>&#13;
<pre>OutputIterator merge([ep], ipt_begin1, ipt_end1,&#13;
                     ipt_begin2, ipt_end2, opt_result, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec156"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">Two pairs of <span class="literal">InputIterator</span>s, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequences</li>&#13;
<li class="noindent">An <span class="literal">OutputIterator</span>, <span class="literal">opt_result</span>, representing the destination sequence</li>&#13;
<li class="noindent">A predicate, <span class="literal">pred</span>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec157"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> At most <span class="literal">N-1</span> comparisons where <span class="literal">N = distance(ipt_begin1, ipt_end1) + distance(ipt_begin2, ipt_end2)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec158"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequences must be sorted according to <span class="literal">operator&lt;</span> or <span class="literal">comp</span> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec159"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("merge") {&#13;
  vector&lt;int&gt; numbers1{ 1, 4, 5 }, numbers2{ 2, 3, 3, 6 }, result; <span class="ent">➊</span>&#13;
  merge(numbers1.begin(), numbers1.end(),&#13;
        numbers2.begin(), numbers2.end(),&#13;
        back_inserter(result)); <span class="ent">➋</span>&#13;
  REQUIRE(result == vector&lt;int&gt;{ 1, 2, 3, 3, 4, 5, 6 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You construct three <span class="literal">vector</span> objects: two containing sorted <span class="literal">int</span> objects and another that is empty <span class="ent">➊</span>. Next, you merge the non-empty <span class="literal">vector</span> and <span epub:type="pagebreak" id="page_626"/>use the empty <span class="literal">vector</span> as the destination sequence via a <span class="literal">back_inserter</span> <span class="ent">➋</span>. The <span class="literal">result</span> contains copies of all the elements from the original sequences, and it too is sorted <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec9"><strong>Extreme-Value Algorithms</strong></h3>&#13;
<p class="noindent">Several algorithms, called <em>extreme-value algorithms</em>, determine minimum and maximum elements or place limits on the minimum or maximum value of an element. Each algorithm explained in this section is in the <span class="literal">&lt;algorithm&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec45"><strong><em>min and max</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">min</span> or <span class="literal">max</span> algorithm determines a sequence’s extrema.</p>&#13;
<p class="indent">The algorithms use <span class="literal">operator&lt;</span> or <span class="literal">comp</span> and return the minimum (<span class="literal">min</span>) or maximum (<span class="literal">max</span>) object. The <span class="literal">minmax</span> algorithm returns both as a <span class="literal">std::pair</span> with <span class="literal">first</span> as the minimum and <span class="literal">second</span> as the maximum.</p>&#13;
<pre>T min(obj1, obj2, [comp]);&#13;
T min(init_list, [comp]);&#13;
T max(obj1, obj2, [comp]);&#13;
T max(init_list, [comp]);&#13;
Pair minmax(obj1, obj2, [comp]);&#13;
Pair minmax(init_list, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec160"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Two objects, <span class="literal">obj1</span> and <span class="literal">obj2</span>, or</li>&#13;
<li class="noindent">An initializer list, <span class="literal">init_list</span>, representing the objects to compare</li>&#13;
<li class="noindent">An optional comparison function, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec161"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Constant or Linear</strong> For the overloads taking <span class="literal">obj1</span> and <span class="literal">obj2</span>, exactly one comparison. For the initializer list, at most <span class="literal">N-1</span> comparisons where <span class="literal">N</span> is the length of the initializer list. In the case of <span class="literal">minmax</span>, given an initializer list, this grows to <span class="literal">3/2 N</span>.</p>&#13;
<h5 class="h5" id="ch18lev3sec162"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements must be copy constructible and comparable using the given comparison.</p>&#13;
<h5 class="h5" id="ch18lev3sec163"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("max and min") {&#13;
<span epub:type="pagebreak" id="page_627"/>  auto length_compare = [](const auto&amp; x1, const auto&amp; x2) { <span class="ent">➊</span>&#13;
    return x1.length() &lt; x2.length();&#13;
  };&#13;
&#13;
string undisc="undiscriminativeness", vermin="vermin";&#13;
  REQUIRE(min(undisc, vermin, length_compare) == "vermin"); <span class="ent">➋</span>&#13;
&#13;
string maxim="maxim", ultra="ultramaximal";&#13;
  REQUIRE(max(maxim, ultra, length_compare) == "ultramaximal"); <span class="ent">➌</span>&#13;
&#13;
string mini="minimaxes", maxi="maximin";&#13;
  const auto result = minmax(mini, maxi, length_compare); <span class="ent">➍</span>&#13;
  REQUIRE(result.first == maxi); <span class="ent">➎</span>&#13;
  REQUIRE(result.second == mini); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a lambda called <span class="literal">length_compare</span>, which uses <span class="literal">operator&lt;</span> to compare the lengths of two inputs <span class="ent">➊</span>. Next, you use <span class="literal">min</span> to determine whether <em>undiscriminativeness</em> or <em>vermin</em> has lesser length <span class="ent">➋</span>, and you use <span class="literal">max</span> to determine whether <em>maxim</em> or <em>ultramaximal</em> has greater length <span class="ent">➌</span>. Finally, you use <span class="literal">minmax</span> to determine which of <em>minimaxes</em> and <em>maximin</em> has minimum and maximum length <span class="ent">➍</span>.    The result is a pair <span class="ent">➎</span><span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec46"><strong><em>min_element and max_element</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">min_element</span> or <span class="literal">max_element</span> algorithm determines a sequence’s extrema.</p>&#13;
<p class="indent">The algorithms use <span class="literal">operator&lt;</span> or <span class="literal">comp</span> and return an iterator pointing to the minimum (<span class="literal">min_element</span>) or maximum (<span class="literal">max_element</span>) object. The <span class="literal">minimax_element</span> algorithm returns both as a <span class="literal">std::pair</span> with <span class="literal">first</span> as the minimum and <span class="literal">second</span> as the maximum.</p>&#13;
<pre>ForwardIterator min_element([ep], fwd_begin, fwd_end, [comp]);&#13;
ForwardIterator max_element([ep], fwd_begin, fwd_end, [comp]);&#13;
Pair minmax_element([ep], fwd_begin, fwd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec164"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of <span class="literal">ForwardIterator</span>s, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison function, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec165"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> For <span class="literal">max</span> and <span class="literal">min</span>, at most <span class="literal">N-1</span> comparisons where <span class="literal">N=distance(fwd_begin, fwd_end)</span>; for <span class="literal">minmax</span>, <span class="literal">3/2 N</span></p>&#13;
<h5 class="h5" id="ch18lev3sec166"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements must be comparable using the given operation.</p>&#13;
<h5 class="h5" id="ch18lev3sec167"><span epub:type="pagebreak" id="page_628"/><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("min and max element") {&#13;
  auto length_compare = [](const auto&amp; x1, const auto&amp; x2) { <span class="ent">➊</span>&#13;
    return x1.length() &lt; x2.length();&#13;
  };&#13;
&#13;
  vector&lt;string&gt; words{ "civic", "deed", "kayak",  "malayalam" }; <span class="ent">➋</span>&#13;
&#13;
  REQUIRE(*min_element(words.begin(), words.end(),&#13;
                       length_compare) == "deed"); <span class="ent">➌</span>&#13;
  REQUIRE(*max_element(words.begin(), words.end(),&#13;
                       length_compare) == "malayalam"); <span class="ent">➍</span>&#13;
&#13;
  const auto result = minmax_element(words.begin(), words.end(),&#13;
                                     length_compare); <span class="ent">➎</span>&#13;
  REQUIRE(*result.first == "deed"); <span class="ent">➏</span>&#13;
  REQUIRE(*result.second == "malayalam"); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a lambda called <span class="literal">length_compare</span>, which uses <span class="literal">operator&lt;</span> to compare the lengths of two inputs <span class="ent">➊</span>. Next, you initialize a <span class="literal">vector</span> of <span class="literal">string</span> objects called <span class="literal">words</span> containing four words <span class="ent">➋</span>. You use <span class="literal">min_element</span> to determine the smallest of these words by passing it as the target sequence and <span class="literal">length_compare</span> as the comparison function (<span class="literal">deed</span>) <span class="ent">➌</span>, and you use <span class="literal">max_element</span> to determine the largest (<span class="literal">malayalam</span>) <span class="ent">➍</span>. Finally, you use <span class="literal">minmax_element</span>, which returns both as a <span class="literal">std::pair</span> <span class="ent">➎</span>. The <span class="literal">first</span> element refers to the shortest <span class="literal">word</span> <span class="ent">➏</span>, and <span class="literal">second</span> refers to the longest <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec47"><strong><em>clamp</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">clamp</span> algorithm bounds a value.</p>&#13;
<p class="indent">The algorithm uses <span class="literal">operator&lt;</span> or <span class="literal">comp</span> to determine whether <span class="literal">obj</span> is inside the bounds from <span class="literal">low</span> to <span class="literal">high</span>. If it is, the algorithm simply returns <span class="literal">obj</span>; otherwise, if <span class="literal">obj</span> is less than <span class="literal">low</span>, it returns <span class="literal">low</span>. If <span class="literal">obj</span> is greater than <span class="literal">high</span>, it returns <span class="literal">high</span>.</p>&#13;
<pre>T&amp; clamp(obj, low, high, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec168"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An object, <span class="literal">obj</span></li>&#13;
<li class="noindent">A <span class="literal">low</span> and <span class="literal">high</span> object</li>&#13;
<li class="noindent">An optional comparison function, <span class="literal">comp</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec169"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Constant</strong> At most two comparisons</p>&#13;
<h5 class="h5" id="ch18lev3sec170"><span epub:type="pagebreak" id="page_629"/><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">The objects must be comparable using the given operation.</p>&#13;
<h5 class="h5" id="ch18lev3sec171"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("clamp") {&#13;
  REQUIRE(clamp(9000, 0, 100) == 100); <span class="ent">➊</span>&#13;
  REQUIRE(clamp(-123, 0, 100) == 0); <span class="ent">➋</span>&#13;
  REQUIRE(clamp(3.14, 0., 100.) == Approx(3.14)); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">In the first example, you clamp <span class="literal">9000</span> to the interval from 0 to 100 inclusive. Because 9,000 &gt; 100, the result is <span class="literal">100</span> <span class="ent">➊</span>. In the second example, you clamp <span class="literal">-123</span> to the same interval. Because −123 &lt; 0, the result is <span class="literal">0</span> <span class="ent">➋</span>. Finally, you clamp <span class="literal">3.14</span> and because it’s within the interval, the result is <span class="literal">3.14</span> <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec10"><strong>Numeric Operations</strong></h3>&#13;
<p class="noindent">The <span class="literal">&lt;numeric&gt;</span> header was discussed in <a href="ch12.xhtml#ch12">Chapter 12</a> when you learned about its mathematical types and functions. It also provides algorithms well suited to numeric operations. This section introduces many of them. Each algorithm explained in this section is in the <span class="literal">&lt;numeric&gt;</span> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec48"><strong><em>Useful Operators</em></strong></h4>&#13;
<p class="noindent">Some stdlib numeric operations permit you to pass an operator to customize behavior. For convenience, the <span class="literal">&lt;functional&gt;</span> header provides the following class templates that expose various binary arithmetic operations through <span class="literal">operator(T x, T y)</span>:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">plus&lt;T&gt;</span> implements addition <span class="literal">x + y</span>.</li>&#13;
<li class="noindent"><span class="literal">minus&lt;T&gt;</span> implements subtraction <span class="literal">x - y</span>.</li>&#13;
<li class="noindent"><span class="literal">multiplies&lt;T&gt;</span> implements multiplication <span class="literal">x * y</span>.</li>&#13;
<li class="noindent"><span class="literal">divides&lt;T&gt;</span> implements division <span class="literal">x / y</span>.</li>&#13;
<li class="noindent"><span class="literal">modulus&lt;T&gt;</span> implements addition <span class="literal">x % y</span>.</li>&#13;
</ul>&#13;
<p class="indent">For example, you could add two numbers using the <span class="literal">plus</span> template, like this:</p>&#13;
<pre>#include &lt;functional&gt;&#13;
&#13;
TEST_CASE("plus") {&#13;
  plus&lt;short&gt; adder; <span class="ent">➊</span>&#13;
  REQUIRE(3 == adder(1, 2)); <span class="ent">➋</span>&#13;
  REQUIRE(3 == plus&lt;short&gt;{}(1,2)); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_630"/>You first instantiate a <span class="literal">plus</span> called <span class="literal">adder</span> <span class="ent">➊</span>, and then you invoke it with the values <span class="literal">1</span> and <span class="literal">2</span>, which yields <span class="literal">3</span> <span class="ent">➋</span>. You can also skip the variable entirely and simply use a newly constructed <span class="literal">plus</span> directly to achieve the same result <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You generally wouldn’t use these operator types unless you were using generic code that required them.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec49"><strong><em>iota</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">iota</span> algorithm fills a sequence with incremental values.</p>&#13;
<p class="indent">The algorithm assigns incremental values beginning with <span class="literal">start</span> to the target sequence.</p>&#13;
<pre>void iota(fwd_begin, fwd_end, start);</pre>&#13;
<h5 class="h5" id="ch18lev3sec172"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <span class="literal">fwd_begin</span> and <span class="literal">fwd_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">start</span> value</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec173"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <span class="literal">N</span> increments and assignments, where <span class="literal">N=distance(fwd_begin, fwd_end)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec174"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The objects must be assignable to <span class="literal">start</span>.</p>&#13;
<h5 class="h5" id="ch18lev3sec175"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
#include &lt;array&gt;&#13;
&#13;
TEST_CASE("iota") {&#13;
  array&lt;int, 3&gt; easy_as; <span class="ent">➊</span>&#13;
  iota(easy_as.begin(), easy_as.end(), 1); <span class="ent">➋</span>&#13;
  REQUIRE(easy_as == array&lt;int, 3&gt;{ 1, 2, 3 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize an <span class="literal">array</span> of <span class="literal">int</span> objects with length <span class="literal">3</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">iota</span> with the <span class="literal">array</span> as the target sequence and <span class="literal">1</span> as the <span class="literal">start</span> value <span class="ent">➋</span>. The result is that <span class="literal">array</span> contains the elements 1, 2, and 3 <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec50"><strong><em>accumulate</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">accumulate</span> algorithm folds a sequence (in order).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Folding a sequence means to apply a particular operation over the elements of a sequence while passing the cumulative result along to the next operation.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_631"/>The algorithm applies <span class="literal">op</span> to <span class="literal">start</span> and the target sequence’s first element. It takes the result and the target sequence’s next element and again applies <span class="literal">op</span>, proceeding in this fashion until it visits each element in the target sequence. Loosely, this algorithm adds the target sequence elements and the <span class="literal">start</span> value, and it returns the result.</p>&#13;
<pre>T accumulate(ipt_begin, ipt_end, start, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec176"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">start</span> value</li>&#13;
<li class="noindent">An optional binary operator, <span class="literal">op</span>, that defaults to <span class="literal">plus</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec177"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <span class="literal">N</span> applications of <span class="literal">op</span>, where <span class="literal">N=distance(ipt_begin, ipt_end)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec178"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence’s elements must be copyable.</p>&#13;
<h5 class="h5" id="ch18lev3sec179"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("accumulate") {&#13;
  vector&lt;int&gt; nums{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  const auto result1 = accumulate(nums.begin(), nums.end(), -1); <span class="ent">➋</span>&#13;
  REQUIRE(result1 == 5); <span class="ent">➌</span>&#13;
&#13;
  const auto result2 = accumulate(nums.begin(), nums.end(),&#13;
                                  2, multiplies&lt;&gt;()); <span class="ent">➍</span>&#13;
  REQUIRE(result2 == 12); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <span class="literal">vector</span> of <span class="literal">int</span> objects with length <span class="literal">3</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">accumulate</span> with the <span class="literal">vector</span> as the target sequence and <span class="literal">-1</span> as the <span class="literal">start</span> value <span class="ent">➋</span>. The result is −1 + 1 + 2 + 3 = 5 <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you use the same target sequence but a start value of <span class="literal">2</span> and the <span class="literal">multiplies</span> operator instead <span class="ent">➍</span>. The result is 2 * 1 * 2 * 3 = 12 <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec51"><strong><em>reduce</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">reduce</span> algorithm folds a sequence (not necessarily in order).</p>&#13;
<p class="indent">The algorithm is identical to <span class="literal">accumulate</span> except it accepts an optional <span class="literal">execution</span> and doesn’t guarantee the order of operator applications.</p>&#13;
<pre>T reduce([ep], ipt_begin, ipt_end, start, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec180"><strong><span epub:type="pagebreak" id="page_632"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <span class="literal">std::execution</span> execution policy, <span class="literal">ep</span> (default: <span class="literal">std::execution::seq</span>)</li>&#13;
<li class="noindent">A pair of iterators, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">A <span class="literal">start</span> value</li>&#13;
<li class="noindent">An optional binary operator, <span class="literal">op</span>, that defaults to <span class="literal">plus</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec181"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <span class="literal">N</span> applications of <span class="literal">op</span>, where <span class="literal">N=distance(ipt_begin, ipt_end)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec182"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Elements must be movable if you omit <span class="literal">ep</span>.</li>&#13;
<li class="noindent">Elements must copyable if you provide <span class="literal">ep</span>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec183"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("reduce") {&#13;
  vector&lt;int&gt; nums{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  const auto result1 = reduce(nums.begin(), nums.end(), -1); <span class="ent">➋</span>&#13;
  REQUIRE(result1 == 5); <span class="ent">➌</span>&#13;
&#13;
  const auto result2 = reduce(nums.begin(), nums.end(),&#13;
                                  2, multiplies&lt;&gt;()); <span class="ent">➍</span>&#13;
  REQUIRE(result2 == 12); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <span class="literal">vector</span> of <span class="literal">int</span> objects with length <span class="literal">3</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">reduce</span> with the <span class="literal">vector</span> as the target sequence and <span class="literal">-1</span> as the <span class="literal">start</span> value <span class="ent">➋</span>. The result is −1 + 1 + 2 + 3 = 5 <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you use the same target sequence but a start value of <span class="literal">2</span> and the <span class="literal">multiplies</span> operator instead <span class="ent">➍</span>. The result is 2 * 1 * 2 * 3 = 12 <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec52"><strong><em>inner_product</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">inner_product</span> algorithm computes the inner product of two sequences.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An inner product (or dot product) is a scalar value associated with a pair of sequences.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm applies <span class="literal">op2</span> to each pair of corresponding elements in the target sequence and sums them together with <span class="literal">start</span> using <span class="literal">op1</span>.</p>&#13;
<pre>T inner_product([ep], ipt_begin1, ipt_end1, ipt_begin2, start, [op1], [op2]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec184"><strong><span epub:type="pagebreak" id="page_633"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <span class="literal">ipt_begin1</span> and <span class="literal">ipt_end1</span>, representing target sequence 1</li>&#13;
<li class="noindent">An iterator, <span class="literal">ipt_begin2</span>, representing target sequence 2</li>&#13;
<li class="noindent">A <span class="literal">start</span> value</li>&#13;
<li class="noindent">Two optional binary operators, <span class="literal">op1</span> and <span class="literal">op2</span>, that default to <span class="literal">plus</span> and <span class="literal">multiply</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec185"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <span class="literal">N</span> applications of <span class="literal">op1</span> and <span class="literal">op2</span>, where <span class="literal">N=distance(ipt_begin1, ipt_end1)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec186"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">Elements must be copyable.</p>&#13;
<h5 class="h5" id="ch18lev3sec187"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("inner_product") {&#13;
  vector&lt;int&gt; nums1{ 1, 2, 3, 4, 5 }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; nums2{ 1, 0,-1, 0, 1 }; <span class="ent">➋</span>&#13;
  const auto result = inner_product(nums1.begin(), nums1.end(),&#13;
                                    nums2.begin(), 10); <span class="ent">➌</span>&#13;
  REQUIRE(result == 13); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize two <span class="literal">vector</span>s of <span class="literal">int</span> objects <span class="ent">➊</span> <span class="ent">➋</span>. Next, you invoke <span class="literal">inner_product</span> with the two <span class="literal">vector</span> objects as the target sequences and <span class="literal">10</span> as the <span class="literal">start</span> value <span class="ent">➌</span>. The result is 10 + 1 * 1 + 2 * 0 + 3 * 1 + 4 * 0 + 4 * 1 = 13 <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec53"><strong><em>adjacent_difference</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">adjacent_difference</span> algorithm generates adjacent differences.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An adjacent difference is the result of applying some operation to each pair of neighboring elements.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm sets the first element of the destination sequence equal to the first element of the target sequence. For each subsequent element, it applies <span class="literal">op</span> to the prior element and the current element and writes the return value into <span class="literal">result</span>. The algorithm returns the end of the destination sequence.</p>&#13;
<pre>OutputIterator adjacent_difference([ep], ipt_begin, ipt_end, result, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec188"><strong><span epub:type="pagebreak" id="page_634"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing target sequence</li>&#13;
<li class="noindent">An iterator, <span class="literal">result</span>, representing the destination sequence</li>&#13;
<li class="noindent">An optional binary operator, <span class="literal">op</span>, that defaults to <span class="literal">minus</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec189"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <span class="literal">N-1</span> applications of <span class="literal">op</span>, where <span class="literal">N=distance(ipt_begin, ipt_end)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec190"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Elements must be movable if you omit <span class="literal">ep</span>.</li>&#13;
<li class="noindent">Elements must copyable if you provide <span class="literal">ep</span>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec191"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("adjacent_difference") {&#13;
  vector&lt;int&gt; fib{ 1, 1, 2, 3, 5, 8 }, fib_diff; <span class="ent">➊</span>&#13;
  adjacent_difference(fib.begin(), fib.end(), back_inserter(fib_diff)); <span class="ent">➋</span>&#13;
  REQUIRE(fib_diff == vector&lt;int&gt;{ 1, 0, 1, 1, 2, 3 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first two initialize a <span class="literal">vector</span> of <span class="literal">int</span> objects, one containing the first six numbers of the Fibonacci sequence and another that is empty <span class="ent">➊</span>. Next, you invoke <span class="literal">adjacent_difference</span> with the two <span class="literal">vector</span> objects as the target sequences <span class="ent">➋</span>. The result is as expected: the first element equals the first element of the Fibonacci sequence, and the following elements are the adjacent differences (1 – 1 = 0), (2 – 1 = 1), (3 – 2 = 1), (5 – 3 = 2), (8 – 5 = 3) <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec54"><strong><em>partial_sum</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">partial_sum</span> algorithm generates partial sums.</p>&#13;
<p class="indent">The algorithm sets an accumulator equal to the first element of the target sequence. For each subsequent element of the target sequence, the algorithm adds that element to the accumulator and then writes the accumulator into the destination sequence. The algorithm returns the end of the destination sequence.</p>&#13;
<pre>OutputIterator partial_sum(ipt_begin, ipt_end, result, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec192"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <span class="literal">ipt_begin</span> and <span class="literal">ipt_end</span>, representing the target sequence</li>&#13;
<li class="noindent">An iterator, <span class="literal">result</span>, representing the destination sequence</li>&#13;
<li class="noindent">An optional binary operator, <span class="literal">op</span>, that defaults to <span class="literal">plus</span></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec193"><span epub:type="pagebreak" id="page_635"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <span class="literal">N-1</span> applications of <span class="literal">op</span>, where <span class="literal">N=distance(ipt_begin, ipt_end)</span></p>&#13;
<h5 class="h5" id="ch18lev3sec194"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("partial_sum") {&#13;
  vector&lt;int&gt; num{ 1, 2, 3, 4 }, result; <span class="ent">➊</span>&#13;
  partial_sum(num.begin(), num.end(), back_inserter(result)); <span class="ent">➋</span>&#13;
  REQUIRE(result == vector&lt;int&gt;{ 1, 3, 6, 10 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize two <span class="literal">vector</span> of <span class="literal">int</span> objects, one called <span class="literal">num</span> containing the first four counting and an empty one called <span class="literal">result</span> <span class="ent">➊</span>. Next, you invoke <span class="literal">partial_sum</span> with <span class="literal">num</span> as the target sequence and <span class="literal">result</span> as the destination <span class="ent">➋</span>. The first element equals the first element of the target sequence, and the following elements are the partial sums (1 + 2 = 3), (3 + 3 = 6), (6 + 4 = 10) <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec55"><strong><em>Other Algorithms</em></strong></h4>&#13;
<p class="noindent">To keep a long chapter from getting much longer, many algorithms are omitted. This section provides a survey of them.</p>&#13;
<h5 class="h5" id="ch18lev3sec195"><strong>(Max) Heap Operations</strong></h5>&#13;
<p class="noindent">A range of length <em>N</em> is a max heap if for all 0 &lt; <em>i</em> &lt; <em>N</em>, the <img src="../images/fig635_1.jpg" alt="Image"/>-th element (rounded down) doesn’t compare less than the <em>i</em>-th element. These structures have strong performance properties in situations where maximum element lookup and insertions must be fast.</p>&#13;
<p class="indent">The <span class="literal">&lt;algorithm&gt;</span> header contains functions that are useful for handling such ranges, such as those in <a href="ch18.xhtml#ch18tab01">Table 18-1</a>. See [alg.heap.operations] for details.</p>&#13;
<p class="tabcap" id="ch18tab01"><strong>Table 18-1:</strong> Heap-Related Algorithms in the <span class="literal">&lt;algorithm&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_heap</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Checks whether a range is a max heap</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_heap_until</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Finds the largest subrange that is a max heap</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">make_heap</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a max heap</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">push_heap</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Adds an element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">pop_heap</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the largest element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">sort_heap</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Transforms a max heap into a sorted range</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch18lev3sec196"><strong>Set Operations on Sorted Ranges</strong></h5>&#13;
<p class="noindent">The <span class="literal">&lt;algorithm&gt;</span> header contains functions that perform set operations on sorted ranges, such as those in <a href="ch18.xhtml#ch18tab02">Table 18-2</a>. See [alg.set.operations] for details.</p>&#13;
<p class="tabcap" id="ch18tab02"><span epub:type="pagebreak" id="page_636"/><strong>Table 18-2:</strong> Set-Related Algorithms in the <span class="literal">&lt;algorithm&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">includes</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if one range is a subset of another range</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">set_difference</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Computes the difference between two sets</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">set_intersection</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Computes the intersection of two sets</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">set_symmetric_difference</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Computes the symmetric difference between two sets</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">set_union</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Computes the union of two sets</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch18lev3sec197"><strong>Other Numeric Algorithms</strong></h5>&#13;
<p class="noindent">The <span class="literal">&lt;numeric&gt;</span> header contains several more functions in addition to those introduced in the “Numeric Operations” section. <a href="ch18.xhtml#ch18tab03">Table 18-3</a> lists them. See [numeric.ops] for details.</p>&#13;
<p class="tabcap" id="ch18tab03"><strong>Table 18-3:</strong> Additional Numerical Algorithms in the <span class="literal">&lt;numeric&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">exclusive_scan</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Like <span class="literal">partial_sum</span> but excludes the <span class="literal">i</span>-th element from the <span class="literal">i</span>-th sum</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">inclusive_scan</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Like <span class="literal">partial_sum</span> but executes out of order and requires an associative operation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">transform_reduce</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Applies a function object; then reduces out of order</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">transform_exclusive_scan</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Applies a function object; then calculates an exclusive scan</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">transform_inclusive_scan</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Applies a function object; then calculates an inclusive scan</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch18lev3sec198"><strong>Memory Operations</strong></h5>&#13;
<p class="noindent">The <span class="literal">&lt;memory&gt;</span> header contains a number of low-level functions for handling uninitialized memory. <a href="ch18.xhtml#ch18tab04">Table 18-4</a> lists them. See [memory.syn] for details.</p>&#13;
<p class="tabcap" id="ch18tab04"><strong>Table 18-4:</strong> Operations for Uninitialized Memory in the <span class="literal">&lt;memory&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">uninitialized_copy</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_copy_n</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_fill</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_fill_n</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy objects into uninitialized memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">uninitialized_move</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_move_n</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Move objects into uninitialized memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">uninitialized_default_construct</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_default_construct_n</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_value_construct</span></p>&#13;
<p class="taba"><span class="literal">uninitialized_value_construct_n</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Construct objects in uninitialized memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">destroy_at</span></p>&#13;
<p class="taba"><span class="literal">destroy</span></p>&#13;
<p class="taba"><span class="literal">destroy_n</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Destroy objects</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch18lev1sec11"><strong><span epub:type="pagebreak" id="page_637"/>Boost Algorithm</strong></h3>&#13;
<p class="noindent">Boost Algorithm is a large algorithm library that overlaps partially with the standard library. For space reasons, <a href="ch18.xhtml#ch18tab05">Table 18-5</a> lists only a quick reference to those algorithms not already contained in the standard library. Refer to the Boost Algorithm documentation for further information.</p>&#13;
<p class="tabcap" id="ch18tab05"><strong>Table 18-5:</strong> Additional Algorithms Available in Boost Algorithm</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boyer_moore</span></p>&#13;
<p class="taba"><span class="literal">boyer_moore_horspool</span></p>&#13;
<p class="taba"><span class="literal">knuth_morris_pratt</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Fast algorithms for searching sequences of values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">hex</span></p>&#13;
<p class="taba"><span class="literal">unhex</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes/reads hexadecimal characters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">gather</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Takes a sequence and moves elements satisfying a predicate into a given position</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">find_not</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Finds the first element in a sequence not equal to a value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">find_backward</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Like <span class="literal">find</span> but works backward</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_partitioned_until</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the end iterator for the largest partitioned subsequence that begins with the target sequence’s first element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">apply_permutation</span></p>&#13;
<p class="taba"><span class="literal">apply_reverse_permutation</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Takes an item sequence and an order sequence and reshuffles the item sequence according to the order sequence</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">is_palindrome</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns <span class="literal">true</span> if a sequence is a palindrome</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><strong>A NOTE ON RANGES</strong></p>&#13;
<p class="noindent"><a href="ch08.xhtml">Chapter 8</a> introduced range expressions as part of the range-based <span class="literal">for</span> loop. Recall from this discussion that a range is a concept that exposes <span class="literal">begin</span> and <span class="literal">end</span> methods that return iterators. Because you can place requirements on iterators to support certain operations, you can place transitive requirements on ranges so they provide certain iterators. Each algorithm has certain operational requirements, and these are reflected in the sorts of iterators they require. Because you can encapsulate an algorithm’s input sequence requirements in terms of ranges, you must understand the various range types to understand each algorithm’s constraints.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_638"/>Like concepts, ranges are not yet formally part of C++. Although you’ll still get tremendous benefit from understanding the relationship among ranges, iterators, and algorithms, there are two drawbacks. First, algorithms still require iterators as input arguments, so even if a range is at hand, you’ll need to extract iterators manually (for example, with <span class="literal">begin</span> and <span class="literal">end</span>). Second, as with other function templates, you’ll sometimes get spectacularly poor error messages when you violate an algorithm’s operational requirements.</p>&#13;
<p class="indent">Work is underway to introduce ranges into the language formally. In fact, concepts and ranges will likely enter the C++ Standard simultaneously because they dovetail so nicely.</p>&#13;
<p class="indent">If you want to experiment with one possible implementation of ranges, refer to Boost Range.</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
<li class="noindent">“Algorithmic Complexity” by Victor Adamchik (<a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html"><em>https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html</em></a>)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>