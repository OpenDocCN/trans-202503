<html><head></head><body>
<h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_572"/><span epub:type="pagebreak" id="page_573"/><strong><span class="big">18</span><br/>ALGORITHMS</strong></h2>&#13;
<p class="quote"><em>And that’s really the essence of programming. By the time you’ve sorted out a complicated idea into little steps that even a stupidmachine can deal with, you’ve learned something about it yourself.<br/>—Douglas Adams</em>, Dirk Gently’s Holistic Detective Agency</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">An <em>algorithm</em> is a procedure for solving a class of problems. The stdlib and Boost libraries contain a multitude of algorithms that you can use in your programs. Because many very smart people have put a lot of time into ensuring these algorithms are correct and efficient, you should usually not attempt to, for example, write your own sorting algorithm.</p>&#13;
<p class="indent">Because this chapter covers almost the entire stdlib algorithm suite, it’s lengthy; however, the individual algorithm presentations are succinct. On first reading, you should skim through each section to survey the wide range of algorithms available to you. Don’t try to memorize them. Instead, focus on getting insight into the kinds of problems you can solve with them as you write code in the future. That way, when you need to use an algorithm, you can say, “Wait, didn’t someone already invent this wheel?”</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_574"/>Before you begin working with the algorithms, you’ll need some grounding in complexity and parallelism. These two algorithmic characteristics are the main drivers behind how your code will perform.</p>&#13;
<h3 class="h3" id="ch18lev1sec1"><strong>Algorithmic Complexity</strong></h3>&#13;
<p class="noindent"><em>Algorithmic complexity</em> describes the difficulty of a computational task. One way to quantify this complexity is with <em>Bachmann-Landau</em> or <em>“Big O” nota</em><em>tion</em>. Big O notation characterizes functions according to how computation grows with respect to the size of input. This notation only includes the leading term of the complexity function. The <em>leading term</em> is the one that grows most quickly as input size increases.</p>&#13;
<p class="indent">For example, an algorithm whose complexity increases by roughly a fixed amount for each additional input element has a Big O notation of <strong>O(N)</strong>, whereas an algorithm whose complexity doesn’t change given additional input has a Big O notation of <strong>O(1)</strong>.</p>&#13;
<p class="indent">This chapter characterizes the stdlib’s algorithms that fall into five complexity classes, as outlined in the list that follows. To give you some idea of how these algorithms scale, each class is listed with its Big O notation and an idea of roughly how many additional operations would be required due to the leading term when input increases from 1,000 elements to 10,000 elements. Each example provides an operation with the given complexity class, where <em>N</em> is the number of elements involved in the operation:</p>&#13;
<p class="bq"><strong>Constant time O(1)</strong> No additional computation. An example is determining the size of a <code>std::vector</code>.</p>&#13;
<p class="bq"><strong>Logarithmic time O(log <em>N</em>)</strong> About one additional computation. An example is finding an element in a <code>std::set</code>.</p>&#13;
<p class="bq"><strong>Linear time O(<em>N</em>)</strong> About 9,000 additional computations. An example is summing all the elements in a collection.</p>&#13;
<p class="bq"><strong>Quasilinear time O(<em>N</em> log <em>N</em>)</strong> About 37,000 additional computations. An example is quicksort, a commonly used sorting algorithm.</p>&#13;
<p class="bq"><strong>Polynomial (or quadratic) time O(<em>N</em><sup>2</sup>)</strong> About 99,000,000 additional computations. An example is comparing all the elements in a collection with all the elements in another collection.</p>&#13;
<p class="indent">An entire field of computer science is dedicated to classifying computational problems according to their difficulty, so this is an involved topic. This chapter mentions each algorithm’s complexity according to how the size of the target sequence affects the amount of required work. In practice, you should profile performance to determine whether an algorithm has suitable scaling properties. But these complexity classes can give you a sense of how expensive a particular algorithm is.</p>&#13;
<h3 class="h3" id="ch18lev1sec2"><span epub:type="pagebreak" id="page_575"/><strong>Execution Policies</strong></h3>&#13;
<p class="noindent">Some algorithms, those that are commonly called <em>parallel algorithms</em>, can divide an algorithm so that independent entities can work on different parts of the problem simultaneously. Many stdlib algorithms allow you to specify parallelism with an <em>execution policy</em>. An execution policy indicates the allowed parallelism for an algorithm. From the stdlib’s perspective, an algorithm can be executed either <em>sequentially</em> or <em>in parallel</em>. A sequential algorithm can have only a single entity working on the problem at a time; a parallel algorithm can have many entities working in concert to resolve the problem.</p>&#13;
<p class="indent">In addition, parallel algorithms can either be <em>vectorized</em> or <em>non-vectorized</em>. Vectorized algorithms allow entities to perform work in an unspecified order, even allowing a single entity to work on multiple portions of the problem simultaneously. For example, an algorithm that requires synchronization among entities is usually non-vectorizable because the same entity could attempt to acquire a lock multiple times, resulting in a deadlock.</p>&#13;
<p class="indent">Three execution policies exist in the <code>&lt;execution&gt;</code> header:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::execution::seq</code> specifies sequential (not parallel) execution.</li>&#13;
<li class="noindent"><code>std::execution::par</code> specifies parallel execution.</li>&#13;
<li class="noindent"><code>std::execution::par_unseq</code> specifies parallel <em>and</em> vectorized execution.</li>&#13;
</ul>&#13;
<p class="indent">For those algorithms that support an execution policy, the default is <code>seq</code>, meaning you have to opt into parallelism and the associated performance benefits. Note that the C++ Standard doesn’t specify the precise meaning of these execution policies because different platforms handle parallelism differently. When you provide a non-sequential execution policy, you’re simply declaring that “this algorithm is safe to parallelize.”</p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch01">Chapter 1</a>9, you’ll explore execution policies in greater detail. For now, just note that some algorithms permit parallelism.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The algorithm descriptions in this chapter aren’t complete. They contain enough information to give you a good background on many algorithms available to you in the Standard library. I suggest that, once you’ve identified an algorithm that fits your needs, you look at one of the resources in the “Further Reading” section at the end of this chapter. Algorithms that accept an optional execution policy often have different requirements when non-default policies are provided, especially where iterators are concerned. For example, if an algorithm normally takes an input iterator, using an execution policy will typically cause the algorithm to require forward iterators instead. Listing these differences would lengthen an already prodigious chapter, so the descriptions omit them.</em></p>&#13;
</div>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_576"/><strong>HOW TO USE THIS CHAPTER</strong></p>&#13;
<p class="noindent">This chapter is a quick reference that contains more than 50 algorithms. Coverage of each algorithm is necessarily succinct. Each algorithm begins with a terse description. A shorthand representation of the algorithm’s function declaration follows along with an explanation of each argument. The declaration depicts optional arguments in brackets. Next, the listing displays the algorithmic complexity. The listing concludes with a non-exhaustive but illustrative example that employs the algorithm. Almost all examples in this chapter are unit tests and implicitly include the following frontmatter:</p>&#13;
<pre>#include "catch.hpp"&#13;
#include &lt;vector&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;</pre>&#13;
<p class="indent">Refer to the relevant subsection [algorithms] for algorithm details should you need them.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch18lev1sec3"><strong>Non-Modifying Sequence Operations</strong></h3>&#13;
<p class="noindent">A <em>non-modifying sequence operation</em> is an algorithm that performs computation over a sequence but doesn’t modify the sequence in any way. You can think of these as <code>const</code> algorithms. Each algorithm explained in this section is in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec1"><strong><em>all_of</em></strong></h4>&#13;
<p class="indent">The <code>all_of</code> algorithm determines whether each element in a sequence meets some user-specified criteria.</p>&#13;
<p class="indent">The algorithm returns <code>true</code> if the target sequence is empty or if <code>pred</code> is <code>true</code> for <em>all</em> elements in the sequence; otherwise, it returns <code>false</code>.</p>&#13;
<pre>bool all_of([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec1"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A unary predicate, <code>pred</code>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec2"><strong><span epub:type="pagebreak" id="page_577"/>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>pred</code> at most <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec3"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("all_of") {&#13;
  vector&lt;string&gt; words{ "Auntie", "Anne's", "alligator" }; <span class="ent">➊</span>&#13;
  const auto starts_with_a =&#13;
    [](const auto&amp; word<span class="ent">➋</span>) {&#13;
      if (word.empty()) return false; <span class="ent">➌</span>&#13;
      return word[0] == 'A' || word[0] == 'a'; <span class="ent">➍</span>&#13;
    };&#13;
  REQUIRE(all_of(words.cbegin(), words.cend(), starts_with_a)); <span class="ent">➎</span>&#13;
  const auto has_length_six = [](const auto&amp; word) {&#13;
    return word.length() == 6; <span class="ent">➏</span>&#13;
  };&#13;
  REQUIRE_FALSE(all_of(words.cbegin(), words.cend(), has_length_six)); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span>, you construct the lambda predicate <code>starts_with_a</code>, which takes a single object called <code>word</code> <span class="ent">➋</span>. If <code>word</code> is empty, <code>starts_with_a</code> returns <code>false</code> <span class="ent">➌</span>; otherwise, it returns <code>true</code> if <code>word</code> starts with either <code>a</code> or <code>A</code> <span class="ent">➍</span>. Because all of the <code>word</code> elements start with either <code>a</code> or <code>A</code>, <code>all_of</code> returns <code>true</code> when it applies <code>starts_with_a</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">In the second example, you construct the predicate <code>has_length_six</code>, which returns <code>true</code> only if <code>word</code> has length six <span class="ent">➏</span>. Because <code>alligator</code> doesn’t have length six, <code>all_of</code> returns <code>false</code> when it applies <code>has_length_six</code> to <code>words</code> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec2"><strong><em>any_of</em></strong></h4>&#13;
<p class="noindent">The <code>any_of</code> algorithm determines whether any element in a sequence meets some user-specified criteria.</p>&#13;
<p class="indent">The algorithm returns <code>false</code> if the target sequence is empty or if <code>pred</code> is <code>true</code> for <em>any</em> element in the sequence; otherwise, it returns <code>false</code>.</p>&#13;
<pre>bool any_of([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec4"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A unary predicate, <code>pred</code>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec5"><span epub:type="pagebreak" id="page_578"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>pred</code> at most <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec6"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("any_of") {&#13;
  vector&lt;string&gt; words{ "Barber", "baby", "bubbles" }; <span class="ent">➊</span>&#13;
  const auto contains_bar = [](const auto&amp; word) {&#13;
    return word.find("Bar") != string::npos;&#13;
  }; <span class="ent">➋</span>&#13;
  REQUIRE(any_of(words.cbegin(), words.cend(), contains_bar)); <span class="ent">➌</span>&#13;
&#13;
  const auto is_empty = [](const auto&amp; word) { return word.empty(); }; <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(any_of(words.cbegin(), words.cend(), is_empty)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span>, you construct the lambda predicate <code>contains_bar</code> that takes a single object called <code>word</code> <span class="ent">➋</span>. If <code>word</code> contains the substring <code>Bar</code>, it returns <code>true</code>; otherwise, it returns <code>false</code>. Because <code>Barber</code> contains <code>Bar</code>, <code>any_of</code> returns <code>true</code> when it applies <code>contains_bar</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you construct the predicate <code>is_empty</code>, which returns <code>true</code> only if a <code>word</code> is empty <span class="ent">➍</span>. Because none of the words are empty, <code>any_of</code> returns <code>false</code> when it applies <code>is_empty</code> to <code>words</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec3"><strong><em>none_of</em></strong></h4>&#13;
<p class="noindent">The <code>none_of</code> algorithm determines whether no element in a sequence meets some user-specified criteria.</p>&#13;
<p class="indent">The algorithm returns <code>true</code> if the target sequence is empty or if <code>pred</code> is <code>true</code> for <em>no</em> element in the sequence; otherwise, it returns <code>false</code>.</p>&#13;
<pre>bool none_of([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec7"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A unary predicate, <code>pred</code>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec8"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>pred</code> at most <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec9"><span epub:type="pagebreak" id="page_579"/><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("none_of") {&#13;
  vector&lt;string&gt; words{ "Camel", "on", "the", "ceiling" }; <span class="ent">➊</span>&#13;
  const auto is_hump_day = [](const auto&amp; word) {&#13;
    return word == "hump day";&#13;
  }; <span class="ent">➋</span>&#13;
  REQUIRE(none_of(words.cbegin(), words.cend(), is_hump_day)); <span class="ent">➌</span>&#13;
&#13;
  const auto is_definite_article = [](const auto&amp; word) {&#13;
    return word == "the" || word == "ye";&#13;
  }; <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(none_of(words.cbegin(), words.cend(), is_definite_article)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span>, you construct the lambda predicate <code>is_hump_day</code> that takes a single object called <code>word</code> <span class="ent">➋</span>. If <code>word</code> equals <code>hump day</code>, it returns <code>true</code>; otherwise, it returns <code>false</code>. Because <code>words</code> doesn’t contain <code>hump day</code>, <code>none_of</code> returns <code>true</code> when it applies <code>is_hump_day</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you construct the predicate <code>is_definite_article</code>, which returns <code>true</code> only if <code>word</code> is a definite article <span class="ent">➍</span>. Because <code>the</code> is a definite article, <code>none_of</code> returns <code>false</code> when it applies <code>is_definite_article</code> to <code>words</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec4"><strong><em>for_each</em></strong></h4>&#13;
<p class="noindent">The <code>for_each</code> algorithm applies some user-defined function to each element in a sequence.</p>&#13;
<p class="indent">The algorithm applies <code>fn</code> to each element of the target sequence. Although <code>for_each</code> is considered a non-modifying sequence operation, if <code>ipt_begin</code> is a mutable iterator, <code>fn</code> can accept a non-<code>const</code> argument. Any values that <code>fn</code> returns are ignored.</p>&#13;
<p class="indent">If you omit <code>ep</code>, <code>for_each</code> will return <code>fn</code>. Otherwise, <code>for_each</code> returns <code>void</code>.</p>&#13;
<pre>for_each([ep], ipt_begin, ipt_end, fn);</pre>&#13;
<h5 class="h5" id="ch18lev3sec10"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A unary function, <code>fn</code>, that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec11"><span epub:type="pagebreak" id="page_580"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>fn</code> exactly <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec12"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent"><code>fn</code> must be movable if you omit <code>ep</code>.</li>&#13;
<li class="noindent"><code>fn</code> must be copyable if you provide <code>ep</code>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec13"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("for_each") {&#13;
  vector&lt;string&gt; words{ "David", "Donald", "Doo" }; <span class="ent">➊</span>&#13;
  size_t number_of_Ds{}; <span class="ent">➋</span>&#13;
  const auto count_Ds = [&amp;number_of_Ds<span class="ent">➌</span>](const auto&amp; word<span class="ent">➍</span>) {&#13;
    if (word.empty()) return; <span class="ent">➎</span>&#13;
    if (word[0] == 'D') ++number_of_Ds; <span class="ent">➏</span>&#13;
  };&#13;
  for_each(words.cbegin(), words.cend(), count_Ds); <span class="ent">➐</span>&#13;
  REQUIRE(3 == number_of_Ds); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span> and a counter variable <code>number_of_Ds</code> <span class="ent">➋</span>, you construct the lambda predicate <code>count_Ds</code> that captures a reference to <code>number_of_Ds</code> <span class="ent">➌</span> and takes a single object called <code>word</code> <span class="ent">➍</span>. If <code>word</code> is empty, you return <span class="ent">➎</span>; otherwise, if the first letter of <code>word</code> is <code>D</code>, you increment <code>number_of_Ds</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Next, you use <code>for_each</code> to iterate over every word, passing each to <code>count_Ds</code> <span class="ent">➐</span>. The result is that <code>number_of_Ds</code> is three <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec5"><strong><em>for_each_n</em></strong></h4>&#13;
<p class="noindent">The <code>for_each_n</code> algorithm applies some user-defined function to each element in a sequence.</p>&#13;
<p class="indent">The algorithm applies <code>fn</code> to each element of the target sequence. Although <code>for_each_n</code> is considered a non-modifying sequence operation, if <code>ipt_begin</code> is a mutable iterator, <code>fn</code> can accept a non-<code>const</code> argument. Any values that <code>fn</code> returns are ignored. It returns <code>ipt_begin+n</code>.</p>&#13;
<pre>InputIterator for_each_n([ep], ipt_begin, n, fn);</pre>&#13;
<h5 class="h5" id="ch18lev3sec14"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">An <code>InputIterator</code> <code>ipt_begin</code> representing the target sequence’s first element</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_581"/>An integer <code>n</code> representing the desired number of iterations so that the half-open range representing the target sequence is <code>ipt_begin</code> to <code>ipt_begin+n</code> (<code>Size</code> is the templated type of <code>n</code>.)</li>&#13;
<li class="noindent">A unary function <code>fn</code> that accepts an element from the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec15"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>fn</code> exactly <code>n</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec16"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent"><code>fn</code> must be movable if you omit <code>ep</code>.</li>&#13;
<li class="noindent"><code>fn</code> must copyable if you provide <code>ep</code>.</li>&#13;
<li class="noindent"><code>n</code> must be non-negative.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec17"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("for_each_n") {&#13;
  vector&lt;string&gt; words{ "ear", "egg", "elephant" }; <span class="ent">➊</span>&#13;
  size_t characters{}; <span class="ent">➋</span>&#13;
  const auto count_characters = [&amp;characters<span class="ent">➌</span>](const auto&amp; word<span class="ent">➍</span>) {&#13;
    characters += word.size(); <span class="ent">➎</span>&#13;
  };&#13;
  for_each_n(words.cbegin(), words.size(), count_characters); <span class="ent">➏</span>&#13;
  REQUIRE(14 == characters); <span class="ent">➐</span>&#13;
}}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span> and a counter variable <code>characters</code> <span class="ent">➋</span>, you construct the lambda predicate <code>count_characters</code> that captures a reference to <code>characters</code> <span class="ent">➌</span> and takes a single object called <code>word</code> <span class="ent">➍</span>. The lambda adds the length of <code>word</code> to <code>characters</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, you use <code>for_each_n</code> to iterate over every word, passing each to <code>count_characters</code> <span class="ent">➏</span>. The result is that <code>characters</code> is <code>14</code> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec6"><strong><em>find, find_if, and find_if_not</em></strong></h4>&#13;
<p class="noindent">The <code>find</code>, <code>find_if</code>, and <code>find_if_not</code> algorithms find the first element in a sequence matching some user-defined criteria.</p>&#13;
<p class="indent">These algorithms return the <code>InputIterator</code> pointing to the target sequence’s first element matching <code>value</code> (<code>find</code>), resulting in a <code>true</code> result when invoked with <code>pred</code> (<code>find_if</code>), or resulting in a <code>false</code> result when invoked with <code>pred</code> (<code>find_if_not</code>).</p>&#13;
<p class="indent">If the algorithm finds no match, it returns <code>ipt_end</code>.</p>&#13;
<pre>InputIterator find([ep], ipt_begin, ipt_end, value);&#13;
InputIterator find_if([ep], ipt_begin, ipt_end, pred);&#13;
InputIterator find_if_not([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec18"><strong><span epub:type="pagebreak" id="page_582"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>const</code> reference <code>value</code> that is equality comparable to the target sequence’s underlying type (<code>find</code>) or a predicate that accepts a single argument with the target sequence’s underlying type (<code>find_if</code> and <code>find_if_not</code>)</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec19"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm makes at most <code>distance(ipt_begin, ipt_end)</code> comparisons (<code>find</code>) or invocations of <code>pred</code> (<code>find_if</code> and <code>find_if_not</code>).</p>&#13;
<h5 class="h5" id="ch18lev3sec20"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("find find_if find_if_not") {&#13;
  vector&lt;string&gt; words{ "fiffer", "feffer", "feff" }; <span class="ent">➊</span>&#13;
  const auto find_result = find(words.cbegin(), words.cend(), "feff"); <span class="ent">➋</span>&#13;
  REQUIRE(*find_result == words.back()); <span class="ent">➌</span>&#13;
&#13;
  const auto defends_digital_privacy = [](const auto&amp; word) {&#13;
    return string::npos != word.find("eff"); <span class="ent">➍</span>&#13;
  };&#13;
&#13;
  const auto find_if_result = find_if(words.cbegin(), words.cend(),&#13;
                                      defends_digital_privacy); <span class="ent">➎</span>&#13;
  REQUIRE(*find_if_result == "feffer"); <span class="ent">➏</span>&#13;
&#13;
  const auto find_if_not_result = find_if_not(words.cbegin(), words.cend(),&#13;
                                              defends_digital_privacy); <span class="ent">➐</span>&#13;
  REQUIRE(*find_if_not_result == words.front()); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span>, you use <code>find</code> to locate <code>feff</code> <span class="ent">➋</span>, which is at the end of <code>words</code> <span class="ent">➌</span>. Next, you construct the predicate <code>defends_digital_privacy</code>, which returns <code>true</code> if <code>word</code> contains the letters <code>eff</code> <span class="ent">➍</span>. You then use <code>find_if</code> to locate the first string in <code>words</code> that contains <code>eff</code> <span class="ent">➎</span>, <code>feffer</code> <span class="ent">➏</span>. Finally, you use <code>find_if_not</code> to apply <code>defends_digital_privacy</code> to <code>words</code> <span class="ent">➐</span>, which returns the first element <code>fiffer</code> (because it doesn’t contain <code>eff</code>) <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec7"><strong><em>find_end</em></strong></h4>&#13;
<p class="noindent">The <code>find_end</code> algorithm finds the last occurrence of a subsequence.</p>&#13;
<p class="indent">If the algorithm finds no such sequence, it returns <code>fwd_end1</code>. If <code>find_end</code> does find a subsequence, it returns a <code>ForwardIterator</code> pointing to the first element of the last matching subsequence.</p>&#13;
<pre><span epub:type="pagebreak" id="page_583"/>InputIterator find_end([ep], fwd_begin1, fwd_end1,&#13;
                       fwd_begin2, fwd_end2, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec21"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">Two pairs of <code>ForwardIterator</code>s, <code>fwd_begin1</code> / <code>fwd_end1</code> and <code>fwd_begin2</code> / <code>fwd_end2</code>, representing the target sequences 1 and 2</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec22"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> The algorithm makes at most the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre>distance(fwd_begin2, fwd_end2) * (distance(fwd_begin1, fwd_end1) -&#13;
                                  distance(fwd_begin2, fwd_end2) + 1)</pre>&#13;
<h5 class="h5" id="ch18lev3sec23"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("find_end") {&#13;
  vector&lt;string&gt; words1{ "Goat", "girl", "googoo", "goggles" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "girl", "googoo" }; <span class="ent">➋</span>&#13;
  const auto find_end_result1 = find_end(words1.cbegin(), words1.cend(),&#13;
                                         words2.cbegin(), words2.cend()); <span class="ent">➌</span>&#13;
  REQUIRE(*find_end_result1 == words1[1]); <span class="ent">➍</span>&#13;
&#13;
  const auto has_length = [](const auto&amp; word, const auto&amp; len) {&#13;
    return word.length() == len; <span class="ent">➎</span>&#13;
  };&#13;
  vector&lt;size_t&gt; sizes{ 4, 6 }; <span class="ent">➏</span>&#13;
  const auto find_end_result2 = find_end(words1.cbegin(), words1.cend(),&#13;
                                         sizes.cbegin(), sizes.cend(),&#13;
                                         has_length); <span class="ent">➐</span>&#13;
  REQUIRE(*find_end_result2 == words1[1]); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects called <code>words1</code> <span class="ent">➊</span> and another called <code>words2</code> <span class="ent">➋</span>, you invoke <code>find_end</code> to determine which element in <code>words1</code> begins the subsequence equal to <code>words2</code> <span class="ent">➌</span>. The result is <code>find_</code><code>end_result1</code>, which equals the element <code>girl</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Next, you construct the lambda <code>has_length</code>, which takes two arguments, <code>word</code> and <code>len</code>, and returns <code>true</code> if <code>word.length()</code> equals <code>len</code> <span class="ent">➎</span>. You construct a <code>vector</code> of <code>size_t</code> objects called <code>sizes</code> <span class="ent">➏</span> and invoke <code>find_end</code> with <code>words1</code>, <code>sizes</code>, <span epub:type="pagebreak" id="page_584"/>and <code>has_length</code> <span class="ent">➐</span>. The result, <code>find_end_result2</code>, points to the first element in <code>words1</code> that has length <code>4</code> with the subsequent word having length <code>6</code>. Because <code>girl</code> has length <code>4</code> and <code>googoo</code> has length <code>6</code>, <code>find_end_result2</code> points to <code>girl</code> <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec8"><strong><em>find_first</em></strong></h4>&#13;
<p class="noindent">The <code>find_first_of</code> algorithm finds the first occurrence in sequence 1 equal to some element in sequence 2.</p>&#13;
<p class="indent">If you provide <code>pred</code>, the algorithm finds the first occurrence <span class="codestrong">i</span> in sequence 1 where, for some <code>j</code> in sequence 2, <code>pred (</code><span class="codestrong">i, j</span><code>)</code> is <code>true</code>.</p>&#13;
<p class="indent">If <code>find_first_of</code> finds no such sequence, it returns <code>ipt_end1</code>. If <code>find_first_of</code> does find a subsequence, it returns an <code>InputIterator</code> pointing to the first element of the first matching subsequence. (Note that if <code>ipt_begin1</code> is also a <code>ForwardIterator</code>, <code>find_first_of</code> instead returns a <code>ForwardIterator</code>.)</p>&#13;
<pre>InputIterator find_first_of([ep], ipt_begin1, ipt_end1,&#13;
                            fwd_begin2, fwd_end2, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec24"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin1</code> / <code>ipt_end1</code>, representing the target sequence 1</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin2</code> / <code>fwd_end2</code>, representing the target sequence 2</li>&#13;
<li class="noindent">An optional binary predicate, <code>pred</code>, to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec25"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> The algorithm makes at most the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre>distance(ipt_begin1, ipt_end1) * distance(fwd_begin2, fwd_end2)</pre>&#13;
<h5 class="h5" id="ch18lev3sec26"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("find_first_of") {&#13;
  vector&lt;string&gt; words{ "Hen", "in", "a", "hat" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; indefinite_articles{ "a", "an" }; <span class="ent">➋</span>&#13;
  const auto find_first_of_result = find_first_of(words.cbegin(),&#13;
                                                  words.cend(),&#13;
                                                  indefinite_articles.cbegin(),&#13;
                                                  indefinite_articles.cend()); <span class="ent">➌</span>&#13;
  REQUIRE(*find_first_of_result == words[2]); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_585"/>After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span> and another called <code>indefinite_articles</code> <span class="ent">➋</span>, you invoke <code>find_first_of</code> to determine which element in <code>words</code> begins the subsequence equal to <code>indefinite_articles</code> <span class="ent">➌</span>. The result is <code>find_first_of_result</code>, which equals the element <code>a</code> <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec9"><strong><em>adjacent_find</em></strong></h4>&#13;
<p class="noindent">The <code>adjacent_find</code> algorithm finds the first repeat in a sequence.</p>&#13;
<p class="indent">The algorithm finds the first occurrence in the target sequence where two adjacent elements are equal or where, if you provide <code>pred</code>, the algorithm finds the first occurrence element <span class="codestrong">i</span> in the sequence where <code>pred (</code><span class="codestrong">i, i</span><code>+1)</code> is <code>true</code>.</p>&#13;
<p class="indent">If <code>adjacent_find</code> finds no such element, it returns <code>fwd_end</code>. If <code>adjacent_find</code> does find such an element, it returns a <code>ForwardIterator</code> pointing to it.</p>&#13;
<pre>ForwardIterator adjacent_find([ep], fwd_begin, fwd_end, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec27"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> / <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec28"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, the algorithm makes at most the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre> min(distance(fwd_begin, i)+1, distance(fwd_begin, fwd_end)-1)</pre>&#13;
<p class="indent">where <span class="codestrong">i</span> is the index of the return value.</p>&#13;
<h5 class="h5" id="ch18lev3sec29"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
TEST_CASE("adjacent_find") {&#13;
  vector&lt;string&gt; words{ "Icabod", "is", "itchy" }; <span class="ent">➊</span>&#13;
  const auto first_letters_match = [](const auto&amp; word1, const auto&amp; word2) { <span class="ent">➋</span>&#13;
    if (word1.empty() || word2.empty()) return false;&#13;
    return word1.front() == word2.front();&#13;
  };&#13;
  const auto adjacent_find_result = adjacent_find(words.cbegin(), words.cend(),&#13;
                                                  first_letters_match); <span class="ent">➌</span>&#13;
  REQUIRE(*adjacent_find_result == words[1]); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_586"/>After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span>, you construct a lambda called <code>first_letters_match</code>, which takes two words and evaluates whether they start with the first letter <span class="ent">➋</span>. You invoke <code>adjacent_find</code> to determine which element has the same first letter as the subsequent letter <span class="ent">➌</span>. The result, <code>adjacent_find_result</code> <span class="ent">➍</span>, equals <code>is</code> because it shares a first letter with <code>itchy</code> <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec10"><strong><em>count</em></strong></h4>&#13;
<p class="noindent">The <code>count</code> algorithm counts the elements in a sequence matching some user-defined criteria.</p>&#13;
<p class="indent">The algorithm returns the number of elements <code>i</code> in the target sequence where <code>pred</code> <code>(</code><span class="codestrong">i</span><code>)</code> is <code>true</code> or where <code>value ==</code> <span class="codestrong">i</span>. Usually, <code>DifferenceType</code> is <code>size_t</code>, but it depends on the implementation of <code>InputIterator</code>. You use <code>count</code> when you want to count the occurrences of a particular value, and you use <code>count_if</code> when you have a more complicated predicate you want to use for comparison.</p>&#13;
<pre>DifferenceType count([ep], ipt_begin, ipt_end, value);&#13;
DifferenceType count_if([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec30"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> / <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">Either a <code>value</code> or a unary predicate <code>pred</code> to evaluate whether an element <code>x</code> in the target sequence should be counted</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec31"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, the algorithm makes <code>distance (ipt_begin, ipt_end)</code> comparisons or invocations of <code>pred</code>.</p>&#13;
<h5 class="h5" id="ch18lev3sec32"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
TEST_CASE("count") {&#13;
  vector&lt;string&gt; words{ "jelly", "jar", "and", "jam" }; <span class="ent">➊</span>&#13;
  const auto n_ands = count(words.cbegin(), words.cend(), "and"); <span class="ent">➋</span>&#13;
  REQUIRE(n_ands == 1); <span class="ent">➌</span>&#13;
&#13;
  const auto contains_a = [](const auto&amp; word) { <span class="ent">➍</span>&#13;
    return word.find('a') != string::npos;&#13;
  };&#13;
  const auto count_if_result = count_if(words.cbegin(), words.cend(),&#13;
                                        contains_a); <span class="ent">➎</span>&#13;
  REQUIRE(count_if_result == 3); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_587"/>After constructing a <code>vector</code> containing <code>string</code> objects called <code>words</code> <span class="ent">➊</span>, you use it to invoke <code>count</code> with the value <code>and</code> <span class="ent">➋</span>. This returns <code>1</code>, because a single element equals <code>and</code> <span class="ent">➌</span>. Next, you construct a lambda called <code>contains_a</code>, which takes a word and evaluates whether it contains <code>a</code> <span class="ent">➍</span>. You invoke <code>count_if</code> to determine how many words contain <code>a</code> <span class="ent">➎</span>. The result equals <code>3</code> because three elements contain <code>a</code> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec11"><strong><em>mismatch</em></strong></h4>&#13;
<p class="noindent">The <code>mismatch</code> algorithm finds the first mismatch in two sequences.</p>&#13;
<p class="indent">The algorithm finds the first mismatched element pair <code>i</code>, <code>j</code> from sequence 1 and sequence 2. Specifically, it finds the first index <span class="codestrong">n</span> such that <span class="codestrong">i</span> <code>= (ipt_begin1 +</code> <span class="codestrong">n</span><code>)</code>; <span class="codestrong">j</span> <code>= (ipt_begin2 +</code> <span class="codestrong">n</span><code>)</code>; and <span class="codestrong">i</span> <code>!=</code> <span class="codestrong">j</span> or <code>pred(</code><span class="codestrong">i</span><code>,</code> <span class="codestrong">j</span><code>)</code> <code>== false</code>.</p>&#13;
<p class="indent">The types of the iterators in the returned <code>pair</code> equal the types of <code>ipt_begin1</code> and <code>ipt_begin2</code>.</p>&#13;
<pre>pair&lt;Itr, Itr&gt; mismatch([ep], ipt_begin1, ipt_end1,&#13;
                        ipt_begin2, [ipt_end2], [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec33"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>).</li>&#13;
<li class="noindent">Two pairs of <code>InputIterator</code>s, <code>ipt_begin1</code> / <code>ipt_end1</code> and <code>ipt_begin2</code> / <code>ipt_end2</code>, representing the target sequences <code>1</code> and <code>2</code>. If you don’t provide <code>ipt_</code><code>end2</code>, sequence 1’s length implies sequence 2’s length.</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec34"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre>min(distance(ipt_begin1, ipt_end1), distance(ipt_begin2, ipt_end2))</pre>&#13;
<h5 class="h5" id="ch18lev3sec35"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("mismatch") {&#13;
  vector&lt;string&gt; words1{ "Kitten", "Kangaroo", "Kick" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Kitten", "bandicoot", "roundhouse" }; <span class="ent">➋</span>&#13;
  const auto mismatch_result1 = mismatch(words1.cbegin(), words1.cend(),&#13;
                                         words2.cbegin()); <span class="ent">➌</span>&#13;
  REQUIRE(*mismatch_result1.first == "Kangaroo"); <span class="ent">➍</span>&#13;
&#13;
  REQUIRE(*mismatch_result1.second == "bandicoot"); <span class="ent">➎</span>&#13;
  const auto second_letter_matches = [](const auto&amp; word1,&#13;
                                        const auto&amp; word2) { <span class="ent">➏</span>&#13;
    if (word1.size() &lt; 2) return false;&#13;
    if (word2.size() &lt; 2) return false;&#13;
    return word1[1] == word2[1];&#13;
  };&#13;
  const auto mismatch_result2 = mismatch(words1.cbegin(), words1.cend(),&#13;
                                     words2.cbegin(), second_letter_matches); <span class="ent">➐</span>&#13;
  REQUIRE(*mismatch_result2.first == "Kick"); <span class="ent">➑</span>&#13;
  REQUIRE(*mismatch_result2.second == "roundhouse"); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_588"/>After constructing two <code>vector</code>s of <code>string</code>s called <code>words1</code> <span class="ent">➊</span> and <code>words2</code> <span class="ent">➋</span>, you use them as the target sequences for <code>mismatch</code> <span class="ent">➌</span>. This returns a <code>pair</code> pointing to the elements <code>Kangaroo</code> and <code>bandicoot</code> <span class="ent">➍</span> <span class="ent">➎</span>. Next, you construct a lambda called <code>second_letter_matches</code>, which takes two words and evaluates whether their second letters match <span class="ent">➏</span>. You invoke <code>mismatch</code> to determine the first pair of elements with mismatched second letters <span class="ent">➐</span>. The result is the pair <code>Kick</code> <span class="ent">➑</span> and <code>roundhouse</code> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec12"><strong><em>equal</em></strong></h4>&#13;
<p class="noindent">The <code>equal</code> algorithm determines whether two sequences are equal.</p>&#13;
<p class="indent">The algorithm determines whether sequence 1’s elements equal sequence 2’s.</p>&#13;
<pre>bool equal([ep], ipt_begin1, ipt_end1, ipt_begin2, [ipt_end2], [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec36"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>) .</li>&#13;
<li class="noindent">Two pairs of <code>InputIterator</code>s, <code>ipt_begin1</code> / <code>ipt_end1</code> and <code>ipt_begin2</code> / <code>ipt_end2</code>, representing the target sequences <code>1</code> and <code>2</code>. If you don’t provide <code>ipt_end2</code>, sequence 1’s length implies sequence 2’s length.</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec37"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre>min(distance(ipt_begin1, ipt_end1), distance(ipt_begin2, ipt_end2))</pre>&#13;
<h5 class="h5" id="ch18lev3sec38"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("equal") {&#13;
  vector&lt;string&gt; words1{ "Lazy", "lion", "licks" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Lazy", "lion", "kicks" }; <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_589"/>  const auto equal_result1 = equal(words1.cbegin(), words1.cend(),&#13;
                                    words2.cbegin()); <span class="ent">➌</span>&#13;
  REQUIRE_FALSE(equal_result1); <span class="ent">➍</span>&#13;
&#13;
  words2[2] = words1[2]; <span class="ent">➎</span>&#13;
  const auto equal_result2 = equal(words1.cbegin(), words1.cend(),&#13;
                                    words2.cbegin()); <span class="ent">➏</span>&#13;
  REQUIRE(equal_result2); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code>s called <code>words1</code> and <code>words2</code> <span class="ent">➊</span> <span class="ent">➋</span>, you use them as the target sequences for <code>equal</code> <span class="ent">➌</span>. Because their last elements, <code>lick</code> and <code>kick</code>, aren’t equal, <code>equal_result1</code> is <code>false</code> <span class="ent">➍</span>. After setting the third element of <code>words2</code> to the third element of <code>words1</code> <span class="ent">➎</span>, you again invoke <code>equal</code> with the same arguments <span class="ent">➏</span>. Because the sequences are now identical, <code>equal_result2</code> is <code>true</code> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec13"><strong><em>is_permutation</em></strong></h4>&#13;
<p class="noindent">The <code>is_permutation</code> algorithm determines whether two sequences are permutations, meaning they contain the same elements but potentially in a different order.</p>&#13;
<p class="indent">The algorithm determines whether some permutation of sequence 2 exists such that sequence 1’s elements equal the permutation’s.</p>&#13;
<pre>bool is_permutation([ep], fwd_begin1, fwd_end1, fwd_begin2, [fwd_end2], [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec39"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>) .</li>&#13;
<li class="noindent">Two pairs of <code>ForwardIterator</code>s, <code>fwd_begin1</code> / <code>fwd_end1</code> and <code>fwd_begin2</code> / <code>fwd_end2</code>, representing the target sequences 1 and 2. If you don’t provide <code>fwd_end2</code>, sequence 1’s length implies sequence 2’s length.</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec40"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre>distance(fwd_begin1, fwd_end1) * distance(fwd_begin2, fwd_end2)</pre>&#13;
<h5 class="h5" id="ch18lev3sec41"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("is_permutation") {&#13;
  vector&lt;string&gt; words1{ "moonlight", "mighty", "nice" }; <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_590"/>  vector&lt;string&gt; words2{ "nice", "moonlight", "mighty" }; <span class="ent">➋</span>&#13;
  const auto result = is_permutation(words1.cbegin(), words1.cend(),&#13;
                                     words2.cbegin()); <span class="ent">➌</span>&#13;
  REQUIRE(result); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code>s called <code>words1</code> and <code>words2</code> <span class="ent">➊</span> <span class="ent">➋</span>, you use them as the target sequences for <code>is_permutation</code> <span class="ent">➌</span>. Because <code>words2</code> is a permutation of <code>words1</code>, <code>is_permutation</code> returns <code>true</code> <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="codeitalic">&lt;algorithm&gt;</span> header also contains <span class="codeitalic">next_permutation</span> and <span class="codeitalic">prev_permutation</span> for manipulating a range of elements so you can generate permutations. See [alg.permutation.generators].</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec14"><strong><em>search</em></strong></h4>&#13;
<p class="noindent">The <code>search</code> algorithm locates a subsequence.</p>&#13;
<p class="indent">The algorithm locates sequence 2 within sequence 1. In other words, it returns the first iterator <span class="codestrong">i</span> in sequence 1 such that for each non-negative integer <code>n</code>, <code>*(i + n)</code> equals <code>*(ipt_begin2 + n)</code>, or if you provide a predicate <code>pred(*(i + n)</code>, <code>*(ipt_begin2 + n))</code> is <code>true</code>. The <code>search</code> algorithm returns <code>ipt_begin1</code> if sequence 2 is empty or <code>ipt_begin2</code> if no subsequence is found. This is different from <code>find</code> because it locates a subsequence rather than a single element.</p>&#13;
<pre>ForwardIterator search([ep], fwd_begin1, fwd_end1,&#13;
                             fwd_begin2, fwd_end2, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec42"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">Two pairs of <code>ForwardIterator</code>s, <code>fwd_begin1</code> / <code>fwd_end1</code> and <code>fwd_begin2</code> / <code>fwd_end2</code>, representing the target sequences 1 and 2</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec43"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quadratic</strong> When no execution policy is given, at worst the algorithm makes the following number of comparisons or invocations of <code>pred</code>:</p>&#13;
<pre>distance(fwd_begin1, fwd_end1) * distance(fwd_begin2, fwd_end2)</pre>&#13;
<h5 class="h5" id="ch18lev3sec44"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("search") {&#13;
<span epub:type="pagebreak" id="page_591"/>  vector&lt;string&gt; words1{ "Nine", "new", "neckties", "and",&#13;
                         "a", "nightshirt" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "and", "a", "nightshirt" }; <span class="ent">➋</span>&#13;
  const auto search_result_1 = search(words1.cbegin(), words1.cend(),&#13;
                                      words2.cbegin(), words2.cend()); <span class="ent">➌</span>&#13;
  REQUIRE(*search_result_1 == "and"); <span class="ent">➍</span>&#13;
&#13;
  vector&lt;string&gt; words3{ "and", "a", "nightpant" }; <span class="ent">➎</span>&#13;
  const auto search_result_2 = search(words1.cbegin(), words1.cend(),&#13;
                                      words3.cbegin(), words3.cend()); <span class="ent">➏</span>&#13;
  REQUIRE(search_result_2 == words1.cend()); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code>s called <code>words1</code> <span class="ent">➊</span> and <code>words2</code> <span class="ent">➋</span>, you use them as the target sequences for <code>search</code> <span class="ent">➌</span>. Because <code>words2</code> is a subsequence of <code>words1</code>, <code>search</code> returns an iterator pointing to <code>and</code> <span class="ent">➍</span>. The <code>vector</code> containing <code>string</code> objects <code>words3</code> <span class="ent">➎</span> contains the word <code>nightpant</code> instead of <code>nightshirt</code>, so invoking <code>search</code> with it instead of <code>words2</code> <span class="ent">➏</span> yields the end iterator of <code>words1</code> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec15"><strong><em>search_n</em></strong></h4>&#13;
<p class="noindent">The <code>search_n</code> algorithm locates a subsequence containing identical, consecutive values.</p>&#13;
<p class="indent">The algorithm searches for <code>count</code> consecutive <code>values</code> in the sequence and returns an iterator pointing to the first <code>value</code>, or it returns <code>fwd_end</code> if no such subsequence is found. This is different from <code>adjacent_find</code> because it locates a subsequence rather than a single element.</p>&#13;
<pre>ForwardIterator search_n([ep], fwd_begin, fwd_end, count, value, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec45"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::</code><code>seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> / <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An integral <code>count</code> value representing the number of consecutive matches you want to find</li>&#13;
<li class="noindent">A <code>value</code> representing the element you want to find</li>&#13;
<li class="noindent">An optional binary predicate <code>pred</code> to compare whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec46"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> When no execution policy is given, at worst the algorithm makes <code>distance(fwd_begin, fwd_end)</code> comparisons or invocations of <code>pred</code>.</p>&#13;
<h5 class="h5" id="ch18lev3sec47"><span epub:type="pagebreak" id="page_592"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("search_n") {&#13;
  vector&lt;string&gt; words{ "an", "orange", "owl", "owl", "owl", "today" }; <span class="ent">➊</span>&#13;
  const auto result = search_n(words.cbegin(), words.cend(), 3, "owl"); <span class="ent">➋</span>&#13;
  REQUIRE(result == words.cbegin() + 2); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> of <code>string</code>s called <code>words</code> <span class="ent">➊</span>, you use it as the target sequence for <code>search_n</code> <span class="ent">➋</span>. Because <code>words</code> contains three instances of the word <code>owl</code>, it returns an iterator pointing to the first instance <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec4"><strong>Mutating Sequence Operations</strong></h3>&#13;
<p class="noindent">A <em>mutating sequence operation</em> is an algorithm that performs computation over a sequence and is allowed to modify the sequence in some way. Each algorithm explained in this section is in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec16"><strong><em>copy</em></strong></h4>&#13;
<p class="noindent">The <code>copy</code> algorithm copies one sequence into another.</p>&#13;
<p class="indent">The algorithm copies the target sequence into <code>result</code> and returns the receiving sequence’s end iterator. It’s your responsibility to ensure that <code>result</code> represents a sequence with enough space to store the target sequence.</p>&#13;
<pre>OutputIterator copy([ep], ipt_begin, ipt_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec48"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>OutputIterator</code>,<code> result</code>, that receives the copied sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec49"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm copies elements from the target sequence exactly <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec50"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">Sequences 1 and 2 must not overlap unless the operation is a <em>copy to the left</em>. For example, for a vector <code>v</code> with 10 elements, <code>std::copy(v.begin()+3, v.end(), v.begin())</code> is well defined, but <code>std::copy(v.begin(), v.begin()+7, v.begin()+3)</code> is not.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_593"/><em>Recall the <span class="codeitalic">back_inserter</span> in “Insert Iterators” on <a href="ch14.xhtml#page_464">page 464</a>, which returns an output iterator that converts write operations into insert operations on the underlying container.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch18lev3sec51"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("copy") {&#13;
  vector&lt;string&gt; words1{ "and", "prosper" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Live", "long" }; <span class="ent">➋</span>&#13;
  copy(words1.cbegin(), words1.cend(), <span class="ent">➌</span>&#13;
       back_inserter(words2)<span class="ent">➍</span>);&#13;
  REQUIRE(words2 == vector&lt;string&gt;{ "Live", "long", "and", "prosper" }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code> objects <span class="ent">➊</span> <span class="ent">➋</span>, you invoke <code>copy</code> with <code>words1</code> as the sequence to <code>copy</code> <span class="ent">➌</span> and <code>words2</code> as the destination sequence <span class="ent">➍</span>. The result is that <code>words2</code> contains the contents of <code>words1</code> appended to the original contents <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec17"><strong><em>copy_n</em></strong></h4>&#13;
<p class="noindent">The <code>copy_n</code> algorithm copies one sequence into another.</p>&#13;
<p class="indent">The algorithm copies the target sequence into <code>result</code> and returns the receiving sequence’s end iterator. It’s your responsibility to ensure that <code>result</code> represents a sequence with enough space to store the target sequence and that <code>n</code> represents the correct length of the target sequence.</p>&#13;
<pre>OutputIterator copy_n([ep], ipt_begin, n, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec52"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A begin iterator, <code>ipt_begin</code>, representing the beginning of the target sequence</li>&#13;
<li class="noindent">The size of the target sequence, <code>n</code></li>&#13;
<li class="noindent">An <code>OutputIterator result</code> that receives the copied sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec53"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm copies elements from the target sequence exactly <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec54"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">Sequences 1 and 2 must not contain the same objects unless the operation is a <em>copy to the left</em>.</p>&#13;
<h5 class="h5" id="ch18lev3sec55"><span epub:type="pagebreak" id="page_594"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("copy_n") {&#13;
  vector&lt;string&gt; words1{ "on", "the", "wind" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "I'm", "a", "leaf" }; <span class="ent">➋</span>&#13;
  copy_n(words1.cbegin(), words1.size(), <span class="ent">➌</span>&#13;
         back_inserter(words2)); <span class="ent">➍</span>&#13;
  REQUIRE(words2 == vector&lt;string&gt;{ "I'm", "a", "leaf",&#13;
                                    "on", "the", "wind" }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code> objects <span class="ent">➊</span><span class="ent">➋</span>, you invoke <code>copy_n</code> with <code>words1</code> as the sequence to <code>copy_n</code> <span class="ent">➌</span> and <code>words2</code> as the destination sequence <span class="ent">➍</span>. The result is that <code>words2</code> contains the contents of <code>words1</code> appended to the original contents <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec18"><strong><em>copy_backward</em></strong></h4>&#13;
<p class="noindent">The <code>copy_backward</code> algorithm copies the reverse of one sequence into another.</p>&#13;
<p class="indent">The algorithm copies sequence 1 into sequence 2 and returns the receiving sequence’s end iterator. Elements copy backward but will appear in the target sequence in the original order. It’s your responsibility to ensure that sequence 1 represents a sequence with enough space to store sequence 2.</p>&#13;
<pre>OutputIterator copy_backward([ep], ipt_begin1, ipt_end1, ipt_end2);</pre>&#13;
<h5 class="h5" id="ch18lev3sec56"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin1</code> and <code>ipt_end1</code>, representing sequence 1</li>&#13;
<li class="noindent">An <code>InputIterator</code>, <code>ipt_end2</code>, representing 1 past the end of sequence 2</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec57"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm copies elements from the target sequence exactly <code>distance(ipt_begin1, ipt_end1)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec58"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">Sequences 1 and 2 must not overlap.</p>&#13;
<h5 class="h5" id="ch18lev3sec59"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("copy_backward") {&#13;
<span epub:type="pagebreak" id="page_595"/>  vector&lt;string&gt; words1{ "A", "man", "a", "plan", "a", "bran", "muffin" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "a", "canal", "Panama" }; <span class="ent">➋</span>&#13;
  const auto result = copy_backward(words2.cbegin(), words2.cend(), <span class="ent">➌</span>&#13;
                                    words1.end()); <span class="ent">➍</span>&#13;
  REQUIRE(words1 == vector&lt;string&gt;{ "A", "man", "a", "plan",&#13;
                                    "a", "canal", "Panama" }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code>s <span class="ent">➊</span> <span class="ent">➋</span>, you invoke <code>copy_backward</code> with <code>words2</code> as the sequence to copy <span class="ent">➌</span> and <code>words1</code> as the destination sequence <span class="ent">➍</span>. The result is that the contents of <code>word2</code> replace the last three words of <code>words1</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec19"><strong><em>move</em></strong></h4>&#13;
<p class="noindent">The <code>move</code> algorithm moves one sequence into another.</p>&#13;
<p class="indent">The algorithm moves the target sequence and returns the receiving sequence’s end iterator. It’s your responsibility to ensure that the target sequence represents a sequence with at least as many elements as the source sequence.</p>&#13;
<pre>OutputIterator move([ep], ipt_begin, ipt_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec60"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>InputIterator</code>, <code>result</code>, representing the beginning of the sequence to move into</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec61"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm moves elements from the target sequence exactly <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec62"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Sequences must not overlap unless <em>moving to the left</em>.</li>&#13;
<li class="noindent">Types must be moveable but not necessarily copyable.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec63"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
struct MoveDetector { <span class="ent">➊</span>&#13;
  MoveDetector() : owner{ true } {} <span class="ent">➋</span>&#13;
  MoveDetector(const MoveDetector&amp;) = delete;&#13;
  MoveDetector&amp; operator=(const MoveDetector&amp;) = delete;&#13;
  MoveDetector(MoveDetector&amp;&amp; o) = delete;&#13;
  MoveDetector&amp; operator=(MoveDetector&amp;&amp;) { <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_596"/>    o.owner = false;&#13;
    owner = true;&#13;
    return *this;&#13;
  }&#13;
  bool owner;&#13;
};&#13;
&#13;
TEST_CASE("move") {&#13;
  vector&lt;MoveDetector&gt; detectors1(2); <span class="ent">➍</span>&#13;
  vector&lt;MoveDetector&gt; detectors2(2); <span class="ent">➎</span>&#13;
  move(detectors1.begin(), detectors1.end(), detectors2.begin()); <span class="ent">➏</span>&#13;
  REQUIRE_FALSE(detectors1[0].owner); <span class="ent">➐</span>&#13;
  REQUIRE_FALSE(detectors1[1].owner); <span class="ent">➑</span>&#13;
  REQUIRE(detectors2[0].owner); <span class="ent">➒</span>&#13;
  REQUIRE(detectors2[1].owner); <span class="ent">➓</span>&#13;
}</pre>&#13;
<p class="indent">First, you declare the <code>MoveDetector</code>’s class <span class="ent">➊</span>, which defines a default constructor setting its only member <code>owner</code> to <code>true</code> <span class="ent">➋</span>. It deletes the copy and move constructor and the copy assignment operator but defines a move assignment operator that swaps <code>owner</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>MoveDetector</code> objects <span class="ent">➍</span> <span class="ent">➎</span>, you invoke <code>move</code> with <code>detectors1</code> as the sequence to <code>move</code> and <code>detectors2</code> as the destination sequence <span class="ent">➏</span>. The result is that the elements of <code>detector1</code> are in a <em>moved from</em> state <span class="ent">➐</span><span class="ent">➑</span> and the elements of <code>detector2</code> are moved into <code>detectors2</code> <span class="ent">➒</span><span class="ent">➓</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec20"><strong><em>move_backward</em></strong></h4>&#13;
<p class="noindent">The <code>move_backward</code> algorithm moves the reverse of one sequence into another.</p>&#13;
<p class="indent">The algorithm moves sequence 1 into sequence 2 and returns an iterator pointing to the last moved element. Elements move backward but will appear in the target sequence in the original order. It’s your responsibility to ensure that the target sequence represents a sequence with at least as many elements as the source sequence.</p>&#13;
<pre>OutputIterator move_backward([ep], ipt_begin, ipt_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec64"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>InputIterator</code>, <code>result</code>, representing the sequence to move into</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec65"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm moves elements from the target sequence exactly <code>distance(ipt_begin, ipt_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec66"><span epub:type="pagebreak" id="page_597"/><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Sequences must not overlap.</li>&#13;
<li class="noindent">Types must be moveable but not necessarily copyable.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec67"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
struct MoveDetector { <span class="ent">➊</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
};&#13;
&#13;
TEST_CASE("move_backward") {&#13;
  vector&lt;MoveDetector&gt; detectors1(2); <span class="ent">➋</span>&#13;
  vector&lt;MoveDetector&gt; detectors2(2); <span class="ent">➌</span>&#13;
  move_backward(detectors1.begin(), detectors1.end(), detectors2.end()); <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(detectors1[0].owner); <span class="ent">➎</span>&#13;
  REQUIRE_FALSE(detectors1[1].owner); <span class="ent">➏</span>&#13;
  REQUIRE(detectors2[0].owner); <span class="ent">➐</span>&#13;
  REQUIRE(detectors2[1].owner); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">First, you declare the <code>MoveDetector</code> class <span class="ent">➊</span> (see “<code>move</code>” back on <a href="ch18.xhtml#page_595">page 595</a> for the implementation).</p>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>MoveDetector</code> objects <span class="ent">➋</span> <span class="ent">➌</span>, you invoke <code>move</code> with <code>detectors1</code> as the sequence to <code>move</code> and <code>detectors2</code> as the destination sequence <span class="ent">➍</span>. The result is that the elements of <code>detector1</code> are in a <em>moved from</em> state <span class="ent">➎</span><span class="ent">➏</span> and the elements of <code>detector2</code> are <em>moved into</em> <span class="ent">➐</span><span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec21"><strong><em>swap_ranges</em></strong></h4>&#13;
<p class="noindent">The <code>swap_ranges</code> algorithm exchanges elements from one sequence into another.</p>&#13;
<p class="indent">The algorithm calls <code>swap</code> on each element of sequence 1 and sequence 2, and it returns the receiving sequence’s end iterator. It’s your responsibility to ensure that the target sequence represents a sequence with at least as many elements as the source sequence.</p>&#13;
<pre>OutputIterator swap_ranges([ep], ipt_begin1, ipt_end1, ipt_begin2);</pre>&#13;
<h5 class="h5" id="ch18lev3sec68"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>ipt_begin1</code> and <code>ipt_end1</code>, representing sequence 1</li>&#13;
<li class="noindent">A <code>ForwardIterator</code>, <code>ipt_begin2</code>, representing the beginning of sequence 2</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec69"><span epub:type="pagebreak" id="page_598"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm calls <code>swap</code> exactly <code>distance(ipt_begin1, ipt_end1)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec70"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements contained in each sequence must be swappable.</p>&#13;
<h5 class="h5" id="ch18lev3sec71"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("swap_ranges") {&#13;
  vector&lt;string&gt; words1{ "The", "king", "is", "dead." }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words2{ "Long", "live", "the", "king." }; <span class="ent">➋</span>&#13;
  swap_ranges(words1.begin(), words1.end(), words2.begin()); <span class="ent">➌</span>&#13;
  REQUIRE(words1 == vector&lt;string&gt;{ "Long", "live", "the", "king." }); <span class="ent">➍</span>&#13;
  REQUIRE(words2 == vector&lt;string&gt;{ "The", "king", "is", "dead." }); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">After constructing two <code>vector</code>s of <code>string</code>s <span class="ent">➊</span> <span class="ent">➋</span>, you invoke <code>swap</code> with <code>words1</code> and <code>words2</code> as the sequences to swap <span class="ent">➌</span>. The result is that <code>words1</code> and <code>words2</code> swap contents <span class="ent">➍</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec22"><strong><em>transform</em></strong></h4>&#13;
<p class="noindent">The <code>transform</code> algorithm modifies the elements of one sequence and writes them into another.</p>&#13;
<p class="indent">The algorithm invokes <code>unary_op</code> on each element of the target sequence and outputs it into the output sequence, or it invokes <code>binary_op</code> on corresponding elements of each target sequence.</p>&#13;
<pre>OutputIterator transform([ep], ipt_begin1, ipt_end1, result, unary_op);&#13;
OutputIterator transform([ep], ipt_begin1, ipt_end1, ipt_begin2,&#13;
                         result, binary_op);</pre>&#13;
<h5 class="h5" id="ch18lev3sec72"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>).</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin1</code> and <code>ipt_end1</code>, representing the target sequence.</li>&#13;
<li class="noindent">An optional <code>InputIterator</code>, <code>ipt_begin2</code>, representing a second target sequence. You must ensure that this second target sequence has at least as many elements as the first target sequence.</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>result</code>, representing the beginning of the output sequence.</li>&#13;
<li class="noindent">A unary operation, <code>unary_op</code>, that transforms elements of the target sequence into elements of the output sequence. If you supply two <span epub:type="pagebreak" id="page_599"/>target sequences, you instead provide a binary operation, <code>binary_op</code>, which accepts an element from each target sequence and transforms each into an element of the output sequence.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec73"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>unary_op</code> or <code>binary_op</code> exactly <code>distance(ipt_begin1, ipt_end1)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec74"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
&#13;
TEST_CASE("transform") {&#13;
  vector&lt;string&gt; words1{ "farewell", "hello", "farewell", "hello" }; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; result1;&#13;
  auto upper = [](string x) { <span class="ent">➋</span>&#13;
    boost::algorithm::to_upper(x);&#13;
    return x;&#13;
  };&#13;
  transform(words1.begin(), words1.end(), back_inserter(result1), upper); <span class="ent">➌</span>&#13;
  REQUIRE(result1 == vector&lt;string&gt;{ "FAREWELL", "HELLO",&#13;
                                     "FAREWELL", "HELLO" }); <span class="ent">➍</span>&#13;
&#13;
  vector&lt;string&gt; words2{ "light", "human", "bro", "quantum" }; <span class="ent">➎</span>&#13;
  vector&lt;string&gt; words3{ "radar", "robot", "pony", "bit" }; <span class="ent">➏</span>&#13;
  vector&lt;string&gt; result2;&#13;
  auto portmantize = [](const auto &amp;x, const auto &amp;y) { <span class="ent">➐</span>&#13;
    const auto x_letters = min(size_t{ 2 }, x.size());&#13;
    string result{ x.begin(), x.begin() + x_letters };&#13;
    const auto y_letters = min(size_t{ 3 }, y.size());&#13;
    result.insert(result.end(), y.end() - y_letters, y.end() );&#13;
    return result;&#13;
  };&#13;
  transform(words2.begin(), words2.end(), words3.begin(),&#13;
            back_inserter(result2), portmantize); <span class="ent">➑</span>&#13;
  REQUIRE(result2 == vector&lt;string&gt;{ "lidar", "hubot", "brony", "qubit" }); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="indent">After constructing a <code>vector</code> containing <code>string</code> objects <span class="ent">➊</span>, you construct a lambda called <code>upper</code>, which takes a <code>string</code> by value and converts it to uppercase using the Boost <code>to_upper</code> algorithm discussed in <a href="ch15.xhtml#ch15">Chapter 15</a> <span class="ent">➋</span>. You invoke transform with <code>words1</code> as the target sequence, a <code>back_inserter</code> for an empty <code>results1</code> vector, and <code>upper</code> as the unary operation <span class="ent">➌</span>. After <code>transform</code>, <code>results1</code> contains the uppercase version of <code>words1</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">In the second example, you construct two <code>vector</code>s of <code>string</code> objects <span class="ent">➎</span><span class="ent">➏</span>. You also construct a lambda called <code>portmantize</code> that accepts two <code>string</code> objects <span class="ent">➐</span>. The lambda returns a new <code>string</code> containing up to two letters from the beginning of the first argument and up to three letters from <span epub:type="pagebreak" id="page_600"/>the end of the second argument. You pass the two target sequences, a <code>back_inserter</code> to an empty <code>vector</code> called <code>results2</code> and <code>portmantize</code> <span class="ent">➑</span>. The <code>result2</code> contains portmanteaus of the contents of <code>words1</code> and <code>words2</code> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec23"><strong><em>replace</em></strong></h4>&#13;
<p class="noindent">The <code>replace</code> algorithm replaces certain elements of a sequence with some new element.</p>&#13;
<p class="indent">The algorithm searches for target sequence elements <span class="codestrong">x</span> for which either <span class="codestrong">x</span> <code>== old_ref</code> or <code>pred(</code><span class="codestrong">x</span><code>) == true</code> and assigns them to <code>new_ref</code>.</p>&#13;
<pre>void replace([ep], fwd_begin, fwd_end, old_ref, new_ref);&#13;
void replace_if([ep], fwd_begin, fwd_end, pred, new_ref);&#13;
void replace_copy([ep], fwd_begin, fwd_end, result, old_ref, new_ref);&#13;
void replace_copy_if([ep], fwd_begin, fwd_end, result, pred, new_ref);</pre>&#13;
<h5 class="h5" id="ch18lev3sec75"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>result</code>, representing the beginning of the output sequence</li>&#13;
<li class="noindent">An <code>old</code> <code>const</code> reference representing the element to find</li>&#13;
<li class="noindent">A unary predicate, <code>pred</code>, that determines whether an element meets the criteria for replacement</li>&#13;
<li class="noindent">A <code>new_ref</code> <code>const</code> reference that represents the element to replace</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec76"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>pred</code> exactly <code>distance(fwd_begin, fwd_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec77"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">The elements contained in each sequence must be comparable to <code>old_ref</code> and assignable to <code>new_ref</code>.</p>&#13;
<h5 class="h5" id="ch18lev3sec78"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;string_view&gt;&#13;
&#13;
TEST_CASE("replace") {&#13;
  using namespace std::literals; <span class="ent">➊</span>&#13;
  vector&lt;string&gt; words1{ "There", "is", "no", "try" }; <span class="ent">➋</span>&#13;
  replace(words1.begin(), words1.end(), "try"sv, "spoon"sv); <span class="ent">➌</span>&#13;
  REQUIRE(words1 == vector&lt;string&gt;{ "There", "is", "no", "spoon" }); <span class="ent">➍</span>&#13;
&#13;
  const vector&lt;string&gt; words2{ "There", "is", "no", "spoon" }; <span class="ent">➎</span>&#13;
<span epub:type="pagebreak" id="page_601"/>  vector&lt;string&gt; words3{ "There", "is", "no", "spoon" }; <span class="ent">➏</span>&#13;
  auto has_two_os = [](const auto&amp; x) { <span class="ent">➐</span>&#13;
    return count(x.begin(), x.end(), 'o') == 2;&#13;
  };&#13;
  replace_copy_if(words2.begin(), words2.end(), words3.begin(), <span class="ent">➑</span>&#13;
                  has_two_os, "try"sv);&#13;
  REQUIRE(words3 == vector&lt;string&gt;{ "There", "is", "no", "try" }); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="indent">You first bring in the <code>std::literals</code> namespace <span class="ent">➊</span> so you can employ the <code>string_view</code> literal later on. After constructing a <code>vector</code> containing <code>string</code> objects <span class="ent">➋</span>, you invoke <code>replace</code> with the <code>vector</code> <span class="ent">➌</span> to replace all instances of <code>try</code> with <code>spoon</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">In the second example, you construct two <code>vector</code>s of <code>string</code> objects <span class="ent">➎</span><span class="ent">➏</span> and a lambda called <code>has_two_os</code>, which accepts a string and returns <code>true</code> if it contains exactly two <code>o</code>s <span class="ent">➐</span>. You then pass <code>words2</code> as the target sequence and <code>words3</code> as the destination sequence to <code>replace_copy_if</code>, which applies <code>has_two_os</code> to each element of <code>words2</code> and replaces elements that evaluate to <code>true</code> with <code>try</code> <span class="ent">➑</span>. The result is that <code>words2</code> is unaffected and <code>words3</code> has the element <code>spoon</code> replaced with <code>try</code> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec24"><strong><em>fill</em></strong></h4>&#13;
<p class="noindent">The <code>fill</code> algorithm fills a sequence with some value.</p>&#13;
<p class="indent">The algorithm writes a value into each element of the target sequence. The <code>fill_n</code> function returns <code>opt_begin+n</code>.</p>&#13;
<pre>void fill([ep], fwd_begin, fwd_end, value);&#13;
OutputIterator fill_n([ep], opt_begin, n, value);</pre>&#13;
<h5 class="h5" id="ch18lev3sec79"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A <code>ForwardIterator</code>, <code>fwd_begin</code>, representing the target sequence’s beginning</li>&#13;
<li class="noindent">A <code>ForwardIterator</code>, <code>fwd_end</code>, representing one past the sequence’s end</li>&#13;
<li class="noindent">A <code>Size n</code> representing the number of elements</li>&#13;
<li class="noindent">A <code>value</code> to write into each element of the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec80"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm assigns <code>value</code> exactly <code>distance(fwd_begin, fwd_end)</code> or <code>n</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec81"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The <code>value</code> parameter must be writable into the sequence.</li>&#13;
<li class="noindent">Objects of type <code>Size</code> must be convertible into an integral type.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec82"><span epub:type="pagebreak" id="page_602"/><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
// If police police police police, who polices the police police?&#13;
TEST_CASE("fill") {&#13;
  vector&lt;string&gt; answer1(6); <span class="ent">➊</span>&#13;
  fill(answer1.begin(), answer1.end(), "police"); <span class="ent">➋</span>&#13;
  REQUIRE(answer1 == vector&lt;string&gt;{ "police", "police", "police",&#13;
                                     "police", "police", "police" }); <span class="ent">➌</span>&#13;
&#13;
  vector&lt;string&gt; answer2; <span class="ent">➍</span>&#13;
  fill_n(back_inserter(answer2), 6, "police"); <span class="ent">➎</span>&#13;
  REQUIRE(answer2 == vector&lt;string&gt;{ "police", "police", "police",&#13;
                                     "police", "police", "police" }); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <code>vector</code> containing <code>string</code> objects containing six empty elements <span class="ent">➊</span>. Next, you invoke <code>fill</code> using this <code>vector</code> as the target sequence and <code>police</code> as the value <span class="ent">➋</span>. The result is that your <code>vector</code> contains six <code>police</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you initialize an empty <code>vector</code> containing <code>string</code> objects <span class="ent">➍</span>. You then invoke <code>fill_n</code> with a <code>back_inserter</code> pointing to the empty vector, a length of 6, and <code>police</code> as the value <span class="ent">➎</span>. The result is the same as before: your <code>vector</code> contains six <code>police</code> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec25"><strong><em>generate</em></strong></h4>&#13;
<p class="noindent">The <code>generate</code> algorithm fills a sequence by invoking a function object.</p>&#13;
<p class="indent">The algorithm invokes <code>generator</code> and assigns the result into the target sequence. The <code>generate_n</code> function returns <code>opt_begin+n</code>.</p>&#13;
<pre>void generate([ep], fwd_begin, fwd_end, generator);&#13;
OutputIterator generate_n([ep], opt_begin, n, generator);</pre>&#13;
<h5 class="h5" id="ch18lev3sec83"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A <code>ForwardIterator</code>, <code>fwd_begin</code>, representing the target sequence’s beginning</li>&#13;
<li class="noindent">A <code>ForwardIterator</code>, <code>fwd_end</code>, representing 1 past the sequence’s end</li>&#13;
<li class="noindent">A <code>Size n</code> representing the number of elements</li>&#13;
<li class="noindent">A <code>generator</code> that, when invoked with no arguments, produces an element to write into the target sequence</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec84"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>generator</code> exactly <code>distance(fwd_begin, fwd_end)</code> or <code>n</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec85"><strong><span epub:type="pagebreak" id="page_603"/>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The <code>value</code> parameter must be writable into the sequence.</li>&#13;
<li class="noindent">Objects of type <code>Size</code> must be convertible into an integral type.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec86"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("generate") {&#13;
  auto i{ 1 }; <span class="ent">➊</span>&#13;
  auto pow_of_2 = [&amp;i]() { <span class="ent">➋</span>&#13;
    const auto tmp = i;&#13;
    i *= 2;&#13;
    return tmp;&#13;
  };&#13;
  vector&lt;int&gt; series1(6); <span class="ent">➌</span>&#13;
  generate(series1.begin(), series1.end(), pow_of_2); <span class="ent">➍</span>&#13;
  REQUIRE(series1 == vector&lt;int&gt;{ 1, 2, 4, 8, 16, 32 }); <span class="ent">➎</span>&#13;
&#13;
  vector&lt;int&gt; series2; <span class="ent">➏</span>&#13;
  generate_n(back_inserter(series2), 6, pow_of_2); <span class="ent">➐</span>&#13;
  REQUIRE(series2 == vector&lt;int&gt;{ 64, 128, 256, 512, 1024, 2048 }); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize an <code>int</code> called <code>i</code> to 1 <span class="ent">➊</span>. Next, you create a lambda called <code>pow_of_2</code>, which takes <code>i</code> by reference <span class="ent">➋</span>. Each time you invoke <code>pow_of_2</code>, it doubles <code>i</code> and returns its value just before the doubling. Next, you initialize a <code>vector</code> of <code>int</code> objects with six elements <span class="ent">➌</span>. You then invoke <code>generate</code> with the <code>vector</code> as the target sequence and <code>pow_of_2</code> as the generator <span class="ent">➍</span>. The result is that the <code>vector</code> contains the first six powers of two <span class="ent">➎</span>.</p>&#13;
<p class="indent">In the second example, you initialize an empty <code>vector</code> of <code>int</code> objects <span class="ent">➏</span>. Next, you invoke <code>generate_n</code> using a <code>back_inserter</code> to your empty <code>vector</code>, a size of 6, and <code>pow_of_2</code> as your generator <span class="ent">➐</span>. The <code>result</code> is the next six powers of two <span class="ent">➑</span>. Notice that <code>pow_of_2</code> has state because it captures <code>i</code> by reference.</p>&#13;
<h4 class="h4" id="ch18lev2sec26"><strong><em>remove</em></strong></h4>&#13;
<p class="noindent">The <code>remove</code> algorithm removes certain elements from a sequence.</p>&#13;
<p class="indent">The algorithm moves all elements where <code>pred</code> evaluates to <code>true</code> or where the element equals <code>value</code> in such a way that the remaining elements’ order is preserved, and it returns an iterator pointing to the first moved element. This iterator is called the resulting sequence’s <em>logical end</em>. The sequence’s physical size remains unchanged, and a call to <code>remove</code> is typically followed by a call to a container’s <code>erase</code> method.</p>&#13;
<pre>ForwardIterator remove([ep], fwd_begin, fwd_end, value);&#13;
ForwardIterator remove_if([ep], fwd_begin, fwd_end, pred);&#13;
ForwardIterator remove_copy([ep], fwd_begin, fwd_end, result, value);&#13;
ForwardIterator remove_copy_if([ep], fwd_begin, fwd_end, result, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec87"><span epub:type="pagebreak" id="page_604"/><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>result</code>, representing the destination sequence (if copying)</li>&#13;
<li class="noindent">A <code>value</code> representing the element to remove</li>&#13;
<li class="noindent">A unary predicate, <code>pred</code>, that determines whether an element meets the criteria for removal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec88"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>pred</code> or compares with <code>value</code> exactly <code>distance(fwd_begin, fwd_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec89"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The elements of the target sequence must be moveable.</li>&#13;
<li class="noindent">If copying, the elements must be copyable, and the target and destination sequences must not overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec90"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("remove") {&#13;
  auto is_vowel = [](char x) { <span class="ent">➊</span>&#13;
    const static string vowels{ "aeiouAEIOU" };&#13;
    return vowels.find(x) != string::npos;&#13;
  };&#13;
  string pilgrim = "Among the things Billy Pilgrim could not change "&#13;
                   "were the past, the present, and the future."; <span class="ent">➋</span>&#13;
  const auto new_end = remove_if(pilgrim.begin(), pilgrim.end(), is_vowel); <span class="ent">➌</span>&#13;
  REQUIRE(pilgrim == "mng th thngs Blly Plgrm cld nt chng wr th pst, "&#13;
                     "th prsnt, nd th ftr.present, and the future."); <span class="ent">➍</span>&#13;
&#13;
  pilgrim.erase(new_end, pilgrim.end()); <span class="ent">➎</span>&#13;
  REQUIRE(pilgrim == "mng th thngs Blly Plgrm cld nt chng wr th "&#13;
                     "pst, th prsnt, nd th ftr."); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first create a lambda called <code>is_vowel</code> that returns <code>true</code> if the given <code>char</code> is a vowel <span class="ent">➊</span>. Next, you construct a <code>string</code> called <code>pilgrim</code> containing a sentence <span class="ent">➋</span>. You then invoke <code>remove_if</code> with <code>pilgrim</code> as the target sentence and <code>is_vowel</code> as the predicate <span class="ent">➌</span>. This eliminates all the vowels in the sentence by shifting the remaining characters to the left each time <code>remove_if</code> <span epub:type="pagebreak" id="page_605"/>encounters a vowel. The result is that <code>pilgrim</code> contains the original sentence with vowels removed plus the phrase <code>present, and the future.</code> <span class="ent">➍</span>. This phrase contains 24 characters, which is exactly the number of vowels that <code>remove_if</code> removed from the original sentence. The phrase <code>present, and the future.</code> is the detritus from shifting the remaining string during removal.</p>&#13;
<p class="indent">To eliminate these leftovers, you save the iterator <code>new_end</code>, which <code>remove_if</code> returns. This points to 1 past the last character in the new target sequence, the <code>p</code> in <code>present, and the future.</code> To eliminate, you simply use the <code>erase</code> method on <code>pilgrim</code>, which has an overload that accepts a half-open range. You pass the logical end returned by <code>remove_if</code>, <code>new_end</code>, as the begin iterator. You also pass <code>pilgrim.end()</code> as the end iterator <span class="ent">➎</span>. The result is that <code>pilgrim</code> is now equal to the original sentence with vowels removed <span class="ent">➏</span>.</p>&#13;
<p class="indent">This combination of <code>remove</code> (or <code>remove_if</code>) and the <code>erase</code> method, which is called the <em>erase-remove idiom</em>, is widely used.</p>&#13;
<h4 class="h4" id="ch18lev2sec27"><strong><em>unique</em></strong></h4>&#13;
<p class="noindent">The <code>unique</code> algorithm removes redundant elements from a sequence.</p>&#13;
<p class="indent">The algorithm moves all repeat elements where <code>pred</code> evaluates to <code>true</code> or where the elements are equal such that the remaining elements are unique from their neighbors and original ordering is preserved. It returns an iterator pointing to the new logical end. As with <code>std::remove</code>, the physical storage doesn’t change.</p>&#13;
<pre>ForwardIterator unique([ep], fwd_begin, fwd_end, [pred]);&#13;
ForwardIterator unique_copy([ep], fwd_begin, fwd_end, result, [pred]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec91"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>result</code>, representing the destination sequence (if copying)</li>&#13;
<li class="noindent">A binary predicate, <code>pred</code>, that determines whether two elements are equal</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec92"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>pred</code> exactly <code>distance(fwd_begin, fwd_end) - 1</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec93"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The elements of the target sequence must be moveable.</li>&#13;
<li class="noindent">If copying, elements of the target sequence must by copyable, and the target and destination ranges cannot overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec94"><span epub:type="pagebreak" id="page_606"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("unique") {&#13;
  string without_walls = "Wallless"; <span class="ent">➊</span>&#13;
  const auto new_end = unique(without_walls.begin(), without_walls.end()); <span class="ent">➋</span>&#13;
  without_walls.erase(new_end, without_walls.end()); <span class="ent">➌</span>&#13;
  REQUIRE(without_walls == "Wales"); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>string</code> containing a word with multiple repeated characters <span class="ent">➊</span>. You then invoke <code>unique</code> with the <code>string</code> as the target sequence <span class="ent">➋</span>. This returns the logical end, which you assign to <code>new_end</code>. Next, you erase the range beginning with <code>new_end</code> and ending with <code>without_walls.end()</code> <span class="ent">➌</span>. This is a corollary to the erase-remove idiom: you’re left with the contents <code>Wales</code>, which contains consecutively unique characters <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec28"><strong><em>reverse</em></strong></h4>&#13;
<p class="noindent">The <code>reverse</code> algorithm reverses the order of a sequence.</p>&#13;
<p class="indent">The algorithm reverses a sequence by either swapping its elements or copying them into a target sequence.</p>&#13;
<pre>void reverse([ep], bi_begin, bi_end);&#13;
OutputIterator reverse_copy([ep], bi_begin, bi_end, result);</pre>&#13;
<h5 class="h5" id="ch18lev3sec95"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>BidirectionalIterator</code>s, <code>bi_begin</code> and <code>bi_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>result</code>, representing the destination sequence (if copying)</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec96"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm invokes <code>swap</code> exactly <code>distance(bi_begin, bi_end)/2</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec97"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The elements of the target sequence must be swappable.</li>&#13;
<li class="noindent">If copying, elements of the target sequence must by copyable, and the target and destination ranges cannot overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec98"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("reverse") {&#13;
<span epub:type="pagebreak" id="page_607"/>  string stinky = "diaper"; <span class="ent">➊</span>&#13;
  reverse(stinky.begin(), stinky.end()); <span class="ent">➋</span>&#13;
  REQUIRE(stinky == "repaid"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>string</code> containing the word <code>diaper</code> <span class="ent">➊</span>. Next, you invoke reverse with this <code>string</code> as the target sequence <span class="ent">➋</span>. The result is the word <code>repaid</code> <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec29"><strong><em>sample</em></strong></h4>&#13;
<p class="noindent">The <code>sample</code> algorithm generates random, stable subsequences.</p>&#13;
<p class="indent">The algorithm samples <code>min(pop_end - pop_begin, n)</code> elements from the population sequence. Somewhat unintuitively, the sample will be sorted if and only if <code>ipt_begin</code> is a forward iterator. It returns the resulting destination sequence’s end.</p>&#13;
<pre>OutputIterator sample([ep], ipt_begin, ipt_end, result, n, urb_generator);</pre>&#13;
<h5 class="h5" id="ch18lev3sec99"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the population sequence (the sequence to sample from)</li>&#13;
<li class="noindent">A <code>OutputIterator</code>, <code>result</code>, representing the destination sequence</li>&#13;
<li class="noindent">A <code>Distance</code> <code>n</code> representing the number of elements to sample</li>&#13;
<li class="noindent">A <code>UniformRandomBitGenerator</code> <code>urb_generator</code>, such as the Mersenne Twister <code>std::mt19937_64</code> introduced in <a href="ch12.xhtml#ch12">Chapter 12</a></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec100"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm’s complexity scales with <code>distance(ipt_begin, ipt_end)</code>.</p>&#13;
<h5 class="h5" id="ch18lev3sec101"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;map&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;iomanip&gt;&#13;
#include &lt;random&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
const string population = "ABCD"; <span class="ent">➊</span>&#13;
const size_t n_samples{ 1'000'000 }; <span class="ent">➋</span>&#13;
mt19937_64 urbg; <span class="ent">➌</span>&#13;
&#13;
void sample_length(size_t n) { <span class="ent">➍</span>&#13;
  cout &lt;&lt; "-- Length " &lt;&lt; n &lt;&lt; " --\n";&#13;
<span epub:type="pagebreak" id="page_608"/>  map&lt;string, size_t&gt; counts; <span class="ent">➎</span>&#13;
  for (size_t i{}; i &lt; n_samples; i++) {&#13;
    string result;&#13;
    sample(population.begin(), population.end(),&#13;
           back_inserter(result), n, urbg); <span class="ent">➏</span>&#13;
    counts[result]++;&#13;
  }&#13;
  for (const auto[sample, n] : counts) { <span class="ent">➐</span>&#13;
    const auto percentage = 100 * n / static_cast&lt;double&gt;(n_samples);&#13;
    cout &lt;&lt; percentage &lt;&lt; " '" &lt;&lt; sample &lt;&lt; "'\n"; <span class="ent">➑</span>&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; fixed &lt;&lt; setprecision(1); <span class="ent">➒</span>&#13;
  sample_length(0); <span class="ent">➓</span>&#13;
  sample_length(1);&#13;
  sample_length(2);&#13;
  sample_length(3);&#13;
  sample_length(4);&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">-- Length 0 --</span>&#13;
<span class="color1">100.0 ''</span>&#13;
<span class="color1">-- Length 1 --</span>&#13;
<span class="color1">25.1 'A'</span>&#13;
<span class="color1">25.0 'B'</span>&#13;
<span class="color1">25.0 'C'</span>&#13;
<span class="color1">24.9 'D'</span>&#13;
<span class="color1">-- Length 2 --</span>&#13;
<span class="color1">16.7 'AB'</span>&#13;
<span class="color1">16.7 'AC'</span>&#13;
<span class="color1">16.6 'AD'</span>&#13;
<span class="color1">16.6 'BC'</span>&#13;
<span class="color1">16.7 'BD'</span>&#13;
<span class="color1">16.7 'CD'</span>&#13;
<span class="color1">-- Length 3 --</span>&#13;
<span class="color1">25.0 'ABC'</span>&#13;
<span class="color1">25.0 'ABD'</span>&#13;
<span class="color1">25.0 'ACD'</span>&#13;
<span class="color1">25.0 'BCD'</span>&#13;
<span class="color1">-- Length 4 --</span>&#13;
<span class="color1">100.0 'ABCD'</span></pre>&#13;
<p class="indent">You first construct a <code>const string</code> called <code>population</code> containing the letters <code>ABCD</code> <span class="ent">➊</span>. You also initialize a <code>const size_t</code> called <code>n_samples</code> equal to a million <span class="ent">➋</span> and a Mersenne Twister called <code>urbg</code> <span class="ent">➌</span>. All of these objects have static storage duration.</p>&#13;
<p class="indent">In addition, you initialize the function <code>sample_length</code>, which takes a single <code>size_t</code> argument called <code>n</code> <span class="ent">➍</span>. Within the function, you construct a <code>map</code> of <code>string</code> to <code>size_t</code> objects <span class="ent">➎</span> that will count the frequency of each <code>sample</code> invocation. Within a <code>for</code> loop, you invoke <code>sample</code> with <code>population</code> as the population <span epub:type="pagebreak" id="page_609"/>sequence, a <code>back_inserter</code> to a <code>result</code> string as the destination sequence, <code>n</code> as the sample length, and <code>urbg</code> as the random bit generator <span class="ent">➏</span>.</p>&#13;
<p class="indent">After a million iterations, you iterate over each element of <code>counts</code> <span class="ent">➐</span> and print the probability distribution of each sample for the given length <code>n</code> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you configure floating-point formatting with <code>fixed</code> and <code>setprecision</code> <span class="ent">➒</span>. Finally, you invoke <code>sample_length</code> with each value from <code>0</code> to <code>4</code> inclusive <span class="ent">➓</span>.</p>&#13;
<p class="indent">Because <code>string</code> provides random access iterators, <code>sample</code> provides <em>stable</em> (sorted) samples.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Notice that the output doesn’t contain any unsorted samples like <span class="codeitalic">DC</span> or <span class="codeitalic">CAB</span>. This sorting behavior isn’t necessarily obvious from the algorithm’s name, so be careful!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec30"><strong><em>shuffle</em></strong></h4>&#13;
<p class="noindent">The <code>shuffle</code> algorithm generates random permutations.</p>&#13;
<p class="indent">The algorithm randomizes the target sequence such that each possible permutation of those elements has equal probability of appearance.</p>&#13;
<pre>void shuffle(rnd_begin, rnd_end, urb_generator);</pre>&#13;
<h5 class="h5" id="ch18lev3sec102"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <code>RandomAccessIterator</code>s, <code>rnd_begin</code> and <code>rnd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>UniformRandomBitGenerator</code> <code>urb_generator</code>, such as the Mersenne Twister <code>std::mt19937_64</code> introduced in <a href="ch12.xhtml#ch12">Chapter 12</a></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec103"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm swaps exactly <code>distance(rnd_begin, rnd_end) - 1</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec104"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable.</p>&#13;
<h5 class="h5" id="ch18lev3sec105"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
#include &lt;map&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;random&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  const string population = "ABCD"; <span class="ent">➊</span>&#13;
  const size_t n_samples{ 1'000'000 }; <span class="ent">➋</span>&#13;
  mt19937_64 urbg; <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_610"/>  map&lt;string, size_t&gt; samples; <span class="ent">➍</span>&#13;
  cout &lt;&lt; fixed &lt;&lt; setprecision(1); <span class="ent">➎</span>&#13;
  for (size_t i{}; i &lt; n_samples; i++) {&#13;
    string result{ population }; <span class="ent">➏</span>&#13;
    shuffle(result.begin(), result.end(), urbg); <span class="ent">➐</span>&#13;
    samples[result]++; <span class="ent">➑</span>&#13;
  }&#13;
  for (const auto[sample, n] : samples) { <span class="ent">➒</span>&#13;
    const auto percentage = 100 * n / static_cast&lt;double&gt;(n_samples);&#13;
    cout &lt;&lt; percentage &lt;&lt; " '" &lt;&lt; sample &lt;&lt; "'\n"; <span class="ent">➓</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">4.2 'ABCD'</span>&#13;
<span class="color1">4.2 'ABDC'</span>&#13;
<span class="color1">4.1 'ACBD'</span>&#13;
<span class="color1">4.2 'ACDB'</span>&#13;
<span class="color1">4.2 'ADBC'</span>&#13;
<span class="color1">4.2 'ADCB'</span>&#13;
<span class="color1">4.2 'BACD'</span>&#13;
<span class="color1">4.2 'BADC'</span>&#13;
<span class="color1">4.1 'BCAD'</span>&#13;
<span class="color1">4.2 'BCDA'</span>&#13;
<span class="color1">4.1 'BDAC'</span>&#13;
<span class="color1">4.2 'BDCA'</span>&#13;
<span class="color1">4.2 'CABD'</span>&#13;
<span class="color1">4.2 'CADB'</span>&#13;
<span class="color1">4.1 'CBAD'</span>&#13;
<span class="color1">4.1 'CBDA'</span>&#13;
<span class="color1">4.2 'CDAB'</span>&#13;
<span class="color1">4.1 'CDBA'</span>&#13;
<span class="color1">4.2 'DABC'</span>&#13;
<span class="color1">4.2 'DACB'</span>&#13;
<span class="color1">4.2 'DBAC'</span>&#13;
<span class="color1">4.1 'DBCA'</span>&#13;
<span class="color1">4.2 'DCAB'</span>&#13;
<span class="color1">4.2 'DCBA'</span></pre>&#13;
<p class="indent">You first construct a <code>const string</code> called <code>population</code> containing the letters <code>ABCD</code> <span class="ent">➊</span>. You also initialize a <code>const size_t</code> called <code>n_samples</code> equal to a million <span class="ent">➋</span>, a Mersenne Twister called <code>urbg</code> <span class="ent">➌</span>, and a <code>map</code> of <code>string</code> to <code>size_t</code> objects <span class="ent">➍</span> that will count the frequencies of each <code>shuffle</code> sample. In addition, you configure floating-point formatting with <code>fixed</code> and <code>setprecision</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Within a <code>for</code> loop, you copy <code>population</code> into a new string called <code>sample</code> because <code>shuffle</code> modifies the target sequence <span class="ent">➏</span>. You then invoke <code>shuffle</code> with <code>result</code> as the target sequence and <code>urbg</code> as the random bit generator <span class="ent">➐</span>, and you record the result within <code>samples</code> <span class="ent">➑</span>.</p>&#13;
<p class="indent">Finally, you iterate over each element in <code>samples</code> <span class="ent">➒</span> and print the probability distribution of each sample <span class="ent">➓</span>.</p>&#13;
<p class="indent">Notice that, unlike with <code>sample</code>, <code>shuffle</code> always produces an <em>unordered</em> distribution of elements.</p>&#13;
<h3 class="h3" id="ch18lev1sec5"><span epub:type="pagebreak" id="page_611"/><strong>Sorting and Related Operations</strong></h3>&#13;
<p class="noindent">A <em>sorting operation</em> is an algorithm that reorders a sequence in some desired way.</p>&#13;
<p class="indent">Each sorting algorithm has two versions: one that takes a function object called a <em>comparison operator</em> and one that uses <code>operator&lt;</code>. A comparison operator is a function object that is invokable with two objects to compare. It returns <code>true</code> if the first argument is <em>less than</em> the second argument; otherwise, it returns <code>false</code>. The sort interpretation of <code>x &lt; y</code> is that <code>x</code> is sorted before <code>y</code>. All the algorithms explained in this section are in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Notice that <span class="codeitalic">operator&lt;</span> is a valid comparison operator.</em></p>&#13;
</div>&#13;
<p class="indent">Comparison operators must be transitive. This means that for any elements <code>a</code>, <code>b</code>, and <code>c</code> the comparison operator <code>comp</code> must preserve the following relationship: if <code>comp(a, b)</code> and <code>comp(b, c)</code>, then <code>comp(a, c)</code>. This should make sense: if <code>a</code> is ordered before <code>b</code> and <code>b</code> is ordered before <code>c</code>, then <code>a</code> must be ordered before <code>c</code>.</p>&#13;
<h4 class="h4" id="ch18lev2sec31"><strong><em>sort</em></strong></h4>&#13;
<p class="noindent">The <code>sort</code> algorithm sorts a sequence (unstably).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A stable sort retains the relative, pre-sort ordering of equal elements, whereas an unstable sort might reorder them.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm sorts the target sequence in place.</p>&#13;
<pre>void sort([ep], rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec106"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>RandomAccessIterator</code>s, <code>rnd_begin</code> and <code>rnd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec107"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quasilinear</strong> O(N log N) where N = <code>distance(rnd_begin, rnd_end)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec108"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec109"><span epub:type="pagebreak" id="page_612"/><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("sort") {&#13;
  string goat_grass{ "spoilage" }; <span class="ent">➊</span>&#13;
  sort(goat_grass.begin(), goat_grass.end()); <span class="ent">➋</span>&#13;
  REQUIRE(goat_grass == "aegilops"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>string</code> containing the word <code>spoilage</code> <span class="ent">➊</span>. Next, you invoke <code>sort</code> with this <code>string</code> as the target sequence <span class="ent">➋</span>. The result is that <code>goat_</code><code>grass</code> now contains the word <code>aegilops</code> (a genus of invasive weeds) <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec32"><strong><em>stable_sort</em></strong></h4>&#13;
<p class="noindent">The <code>stable_sort</code> algorithm sorts a sequence stably.</p>&#13;
<p class="indent">The algorithm sorts the target sequence in place. Equal elements retain their original ordering.</p>&#13;
<pre>void stable_sort([ep], rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec110"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>RandomAccessIterator</code>s, <code>rnd_begin</code> and <code>rnd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec111"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Polylog-linear</strong> O(N log<sup>2</sup> N) where N = <code>distance(rnd_begin, rnd_end)</code>. If additional memory is available, complexity reduces to quasilinear.</p>&#13;
<h5 class="h5" id="ch18lev3sec112"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec113"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
enum class CharCategory { <span class="ent">➊</span>&#13;
  Ascender,&#13;
  Normal,&#13;
  Descender&#13;
};&#13;
&#13;
CharCategory categorize(char x) { <span class="ent">➋</span>&#13;
  switch (x) {&#13;
<span epub:type="pagebreak" id="page_613"/>    case 'g':&#13;
    case 'j':&#13;
    case 'p':&#13;
    case 'q':&#13;
    case 'y':&#13;
      return CharCategory::Descender;&#13;
    case 'b':&#13;
    case 'd':&#13;
    case 'f':&#13;
    case 'h':&#13;
    case 'k':&#13;
    case 'l':&#13;
    case 't':&#13;
      return CharCategory::Ascender;&#13;
  }&#13;
  return CharCategory::Normal;&#13;
}&#13;
&#13;
bool ascension_compare(char x, char y) { <span class="ent">➌</span>&#13;
  return categorize(x) &lt; categorize(y);&#13;
}&#13;
&#13;
TEST_CASE("stable_sort") {&#13;
  string word{ "outgrin" }; <span class="ent">➍</span>&#13;
  stable_sort(word.begin(), word.end(), ascension_compare); <span class="ent">➎</span>&#13;
  REQUIRE(word == "touring"); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">This example sorts a <code>string</code> using the <em>ascenders</em> and <em>descenders</em>. In typography, an ascender is a letter with a portion that extends above what is known as the mean line of a font. A descender is a letter with a portion that extends below what is known as the baseline. Letters commonly typed with descenders are <em>g</em>, <em>j</em>, <em>p</em>, <em>q</em>, and <em>y</em>. Letters commonly typed with ascenders are <em>b</em>, <em>d</em>, <em>f</em>, <em>h</em>, <em>k</em>, <em>l</em>, and <em>t</em>. This example seeks a <code>stable_sort</code> so that all letters with ascenders appear before all other letters and letters with descenders appear after all other letters. Letters with neither an ascender nor a descender lie in the middle. As a <code>stable_sort</code>, the relative ordering of letters with common ascender/descender categorization must not change.</p>&#13;
<p class="indent">You first define an <code>enum class</code> called <code>CharCategory</code> that takes on three possible values: <code>Ascender</code>, <code>Normal</code>, or <code>Descender</code> <span class="ent">➊</span>. Next, you define a function that categorizes a given char into a <code>CharCategory</code> <span class="ent">➋</span>. (Recall from “Switch Statements” on <a href="ch02.xhtml#page_50">page 50</a> that labels “fall through” if you don’t include a <code>break</code>.) You also define an <code>ascension_compare</code> function that converts two given <code>char</code> objects into <code>CharCategory</code> objects and compares them with <code>operator&lt;</code> <span class="ent">➌</span>. Because <code>enum class</code> objects convert implicitly to <code>int</code> objects and because you define <code>CharCategory</code> with its values in the intended order, this will sort letters with ascenders ahead of normal letters ahead of letters with descenders.</p>&#13;
<p class="indent">Within the test case, you initialize a <code>string</code> containing the word <code>outgrin</code> <span class="ent">➍</span>. Next, you invoke <code>stable_sort</code> with this <code>string</code> as the target sequence and <code>ascension_compare</code> as the comparison operator <span class="ent">➎</span>. The result is that <code>word</code> now <span epub:type="pagebreak" id="page_614"/>contains <code>touring</code> <span class="ent">➏</span>. Notice that <code>t</code>, the only ascender, appears before all the normal characters (which are in the same order as in <code>outgrin</code>), which appear before <code>g</code>, the only descender.</p>&#13;
<h4 class="h4" id="ch18lev2sec33"><strong><em>partial_sort</em></strong></h4>&#13;
<p class="noindent">The <code>partial_sort</code> algorithm sorts a sequence into two groups.</p>&#13;
<p class="indent">If modifying, the algorithm sorts the first <code>(rnd_middle – rnd_first)</code> elements in the target sequence so all elements in <code>rnd_begin</code> to <code>rnd_middle</code> are less than the rest of the elements. If copying, the algorithm places the first <code>min(distance(ipt_begin, ipt_end), distance(rnd_begin, rnd_end))</code> sorted elements into the destination sequence, and it returns an iterator pointing to the end of the destination sequence.</p>&#13;
<p class="indent">Basically, a partial sort allows you to find the first few elements of a sorted sequence without having to sort the entire sequence. For example, if you had the sequence D C B A, you could partial sort the first two elements and obtain the result A B D C. The first two elements are the same as if you’d sorted the entire sequence, but the remaining elements aren’t.</p>&#13;
<pre>void partial_sort([ep], rnd_begin, rnd_middle, rnd_end, [comp]);&#13;
RandomAccessIterator partial_sort_copy([ep], ipt_begin, ipt_end,&#13;
                                       rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec114"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">If modifying, a trio of <code>RandomAccessIterator</code>s, <code>rnd_begin</code>, <code>rnd_middle</code>, and <code>rnd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">If copying, a pair <code>ipt_begin</code> and <code>ipt_end</code> representing the target sequence and a pair <code>rnd_begin</code> and <code>rnd_end</code> representing the destination sequence</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec115"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quasilinear</strong> O(N log N) where N = <code>distance(rnd_begin, rnd_end) * log(distance(rnd_begin, rnd_middle)</code> or <code>distance(rnd_begin, rnd_end) * log(min(distance(rnd_begin, rnd_end), distance(ipt_begin, ipt_end))</code> for the copy variant</p>&#13;
<h5 class="h5" id="ch18lev3sec116"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec117"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
bool ascension_compare(char x, char y) {&#13;
<span class="codeitalic1">--snip--</span>&#13;
<span epub:type="pagebreak" id="page_615"/>}&#13;
&#13;
TEST_CASE("partial_sort") {&#13;
  string word1{ "nectarous" }; <span class="ent">➊</span>&#13;
  partial_sort(word1.begin(), word1.begin() + 4, word1.end()); <span class="ent">➋</span>&#13;
  REQUIRE(word1 == "acentrous"); <span class="ent">➌</span>&#13;
&#13;
  string word2{ "pretanning" }; <span class="ent">➍</span>&#13;
  partial_sort(word2.begin(), word2.begin() + 3, <span class="ent">➎</span>&#13;
               word2.end(), ascension_compare);&#13;
  REQUIRE(word2 == "trepanning"); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <code>string</code> containing the word <code>nectarous</code> <span class="ent">➊</span>. Next, you invoke <code>partial_sort</code> with this <code>string</code> as the target sequence and the fifth letter (<code>a</code>) as the second argument to <code>partial_sort</code> <span class="ent">➋</span>. The result is that the sequence now contains the word <code>acentrous</code> <span class="ent">➌</span>. Notice that the first four letters of <code>acentrous</code> are sorted and that they’re less than the remaining characters in the sequence.</p>&#13;
<p class="indent">In the second example, you initialize a <code>string</code> containing the word <code>pretanning</code> <span class="ent">➍</span>, which you use as the target sequence for <code>partial_sort</code> <span class="ent">➎</span>. In this example, you specify the fourth character (<code>t</code>) as the second argument to <code>partial_sort</code>, and you use the <code>ascension_compare</code> function from the <code>stable_sort</code> example as the comparison operator. The result is that the sequence now contains the word <code>trepanning</code> <span class="ent">➏</span>. Notice that the first three letters are sorted according to <code>ascension_compare</code> and none of the remaining characters in the second argument to <code>partial_sort</code> to <code>z</code> is less than the first three characters.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Technically, the <span class="codeitalic">REQUIRE</span> statements in the preceding example might fail on some standard library implementations. Because <span class="codeitalic">std::partial_sort</span> isn’t guaranteed to be stable, results may vary.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec34"><strong><em>is_sorted</em></strong></h4>&#13;
<p class="noindent">The <code>is_sorted</code> algorithm determines whether a sequence is sorted.</p>&#13;
<p class="indent">The algorithm returns true if the target sequence is sorted according to <code>operator&lt;</code> or <code>comp</code>, if given. The <code>is_sorted_until</code> algorithm returns an iterator pointing to the first unsorted element or <code>rnd_end</code> if the target sequence is sorted.</p>&#13;
<pre>bool is_sorted([ep], rnd_begin, rnd_end, [comp]);&#13;
ForwardIterator is_sorted_until([ep], rnd_begin, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec118"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>RandomAccessIterator</code>s, <code>rnd_begin</code> and <code>rnd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec119"><span epub:type="pagebreak" id="page_616"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm compares <code>distance(rnd_begin, rnd_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec120"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
bool ascension_compare(char x, char y) {&#13;
<span class="codeitalic1">--snip--</span>&#13;
}&#13;
&#13;
TEST_CASE("is_sorted") {&#13;
  string word1{ "billowy" }; <span class="ent">➊</span>&#13;
  REQUIRE(is_sorted(word1.begin(), word1.end())); <span class="ent">➋</span>&#13;
&#13;
  string word2{ "floppy" }; <span class="ent">➌</span>&#13;
  REQUIRE(word2.end() == is_sorted_until(word2.begin(), <span class="ent">➍</span>&#13;
                                         word2.end(), ascension_compare));&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>string</code> containing the word <code>billowy</code> <span class="ent">➊</span>. Next, you invoke <code>is_sort</code> with this <code>string</code> as the target sequence, which returns <code>true</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">In the second example, you construct a <code>string</code> containing the word <code>floppy</code> <span class="ent">➌</span>. You then invoke <code>is_sorted_until</code> with this <code>string</code> as the target sequence, which returns <code>rnd_end</code> because the sequence is sorted <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec35"><strong><em>nth_element</em></strong></h4>&#13;
<p class="noindent">The <code>nth_element</code> algorithm places a particular element in a sequence into its correct sorted position.</p>&#13;
<p class="indent">This partial sorting algorithm modifies the target sequence in the following way: the element in the position pointed to by <code>rnd_nth</code> is in that position as if the whole range were sorted. All elements from <code>rnd_begin</code> to <code>rnd_nth-1</code> will be less than <code>rnd_nth</code>. If <code>rnd_nth == rnd_end</code>, the function performs no operation.</p>&#13;
<pre>bool nth_element([ep], rnd_begin, rnd_nth, rnd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec121"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::</code><code>seq</code>)</li>&#13;
<li class="noindent">A trio of <code>RandomAccessIterator</code>s, <code>rnd_begin</code>, <code>rnd_nth</code>, and <code>rnd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec122"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> The algorithm compares <code>distance(rnd_begin, rnd_end)</code> times.</p>&#13;
<h5 class="h5" id="ch18lev3sec123"><span epub:type="pagebreak" id="page_617"/><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">The elements of the target sequence must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec124"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("nth_element") {&#13;
  vector&lt;int&gt; numbers{ 1, 9, 2, 8, 3, 7, 4, 6, 5 }; <span class="ent">➊</span>&#13;
  nth_element(numbers.begin(), numbers.begin() + 5, numbers.end()); <span class="ent">➋</span>&#13;
  auto less_than_6th_elem = [&amp;elem=numbers[5]](int x) { <span class="ent">➌</span>&#13;
    return x &lt; elem;&#13;
  };&#13;
  REQUIRE(all_of(numbers.begin(), numbers.begin() + 5, less_than_6th_elem)); <span class="ent">➍</span>&#13;
  REQUIRE(numbers[5] == 6 ); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>vector</code> of <code>int</code> objects containing the number sequence 1 to 10 inclusive <span class="ent">➊</span>. Next, you invoke <code>nth_element</code> with this <code>vector</code> as the target sequence <span class="ent">➋</span>. You then initialize a lambda named <code>less_than_6th_elem</code>, which compares an <code>int</code> with the sixth element of <code>numbers</code> with <code>operator&lt;</code> <span class="ent">➌</span>. This allows you to check that all elements before the sixth element are less than the sixth element <span class="ent">➍</span>. The sixth element is 6 <span class="ent">➎</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec6"><strong>Binary Search</strong></h3>&#13;
<p class="noindent"><em>Binary search algorithms</em> assume that a target sequence is already sorted. These algorithms have desirable complexity characteristics compared with generic search over an unspecified sequence. Each algorithm explained in this section is in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec36"><strong><em>lower_bound</em></strong></h4>&#13;
<p class="noindent">The <code>lower_bound</code> algorithm finds a partition in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns an iterator corresponding to the element <code>result</code>, which partitions the sequence so the elements before <code>result</code> are less than <code>value</code>, whereas <code>result</code> and all elements after it aren’t less than <code>value</code>.</p>&#13;
<pre>ForwardIterator lower_bound(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec125"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>value</code> to partition the target sequence with</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec126"><span epub:type="pagebreak" id="page_618"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <code>O(log N)</code> where <code>N = distance (fwd_begin, fwd_end</code>); otherwise, <code>O(N)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec127"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <code>operator&lt;</code> or <code>comp</code> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec128"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("lower_bound") {&#13;
  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  const auto result = lower_bound(numbers.begin(), numbers.end(), 5); <span class="ent">➋</span>&#13;
  REQUIRE(result == numbers.begin() + 2); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>vector</code> of <code>int</code> objects <span class="ent">➊</span>. Next, you invoke <code>lower_bound</code> with this <code>vector</code> as the target sequence and a <code>value</code> of <code>5</code> <span class="ent">➋</span>. The result is the third element, <code>5</code> <span class="ent">➌</span>. The elements <code>2</code> and <code>4</code> are less than <code>5</code>, whereas the elements <code>5</code>, <code>6</code>, <code>6</code>, and <code>9</code> are not.</p>&#13;
<h4 class="h4" id="ch18lev2sec37"><strong><em>upper_bound</em></strong></h4>&#13;
<p class="noindent">The <code>upper_bound</code> algorithm finds a partition in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns an iterator corresponding to the element <code>result</code>, which is the first element in the target sequence greater than <code>value</code>.</p>&#13;
<pre>ForwardIterator upper_bound(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec129"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>value</code> to partition the target sequence with</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec130"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <code>O(log N)</code> where <code>N = distance (fwd_begin, fwd_end</code>); otherwise, <code>O(N)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec131"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <code>operator&lt;</code> or <code>comp</code> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec132"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("upper_bound") {&#13;
<span epub:type="pagebreak" id="page_619"/>  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  const auto result = upper_bound(numbers.begin(), numbers.end(), 5); <span class="ent">➋</span>&#13;
  REQUIRE(result == numbers.begin() + 3); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>vector</code> of <code>int</code> objects <span class="ent">➊</span>. Next, you invoke <code>upper_bound</code> with this <code>vector</code> as the target sequence and a <code>value</code> of <code>5</code> <span class="ent">➋</span>. The result is the fourth element, <code>6</code>, which is the first element in the target sequence greater than <code>value</code> <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec38"><strong><em>equal_range</em></strong></h4>&#13;
<p class="noindent">The <code>equal_range</code> algorithm finds a range of certain elements in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns a <code>std::pair</code> of iterators corresponding to the half-open range equal to <code>value</code>.</p>&#13;
<pre>ForwardIteratorPair equal_range(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec133"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>value</code> to seek</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec134"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <code>O(log N)</code> where <code>N = distance (fwd_begin, fwd_end)</code>; otherwise, <code>O(N)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec135"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <code>operator&lt;</code> or <code>comp</code> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec136"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("equal_range") {&#13;
  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  const auto[rbeg, rend] = equal_range(numbers.begin(), numbers.end(), 6); <span class="ent">➋</span>&#13;
  REQUIRE(rbeg == numbers.begin() + 3); <span class="ent">➌</span>&#13;
  REQUIRE(rend == numbers.begin() + 5); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>vector</code> of <code>int</code> objects <span class="ent">➊</span>. Next, you invoke <code>equal_range</code> with this <code>vector</code> as the target sequence and a <code>value</code> of <code>6</code> <span class="ent">➋</span>. The result is an iterator pair representing the matching range. The begin iterator points to the fourth element <span class="ent">➌</span>, and the second iterator points to the sixth element <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec39"><strong><em><span epub:type="pagebreak" id="page_620"/>binary_search</em></strong></h4>&#13;
<p class="noindent">The <code>binary_search</code> algorithm finds a particular element in a sorted sequence.</p>&#13;
<p class="indent">The algorithm returns <code>true</code> if the range contains <code>value</code>. Specifically, it returns <code>true</code> if the target sequence contains an element <code>x</code> such that neither <code>x &lt; value</code> nor <code>value &lt; x</code>. If <code>comp</code> is provided, it returns <code>true</code> if the target sequence contains an element <code>x</code> such that neither <code>comp(x, value)</code> nor <code>comp(value, x)</code>.</p>&#13;
<pre>bool binary_search(fwd_begin, fwd_end, value, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec137"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>value</code> to seek</li>&#13;
<li class="noindent">An optional comparison operator, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec138"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Logarithmic</strong> If you provide a random iterator, <code>O(log N)</code> where <code>N = distance (fwd_begin, fwd_end)</code>; otherwise, <code>O(N)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec139"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence must be sorted according to <code>operator&lt;</code> or <code>comp</code> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec140"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("binary_search") {&#13;
  vector&lt;int&gt; numbers{ 2, 4, 5, 6, 6, 9 }; <span class="ent">➊</span>&#13;
  REQUIRE(binary_search(numbers.begin(), numbers.end(), 6)); <span class="ent">➋</span>&#13;
  REQUIRE_FALSE(binary_search(numbers.begin(), numbers.end(), 7)); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a <code>vector</code> of <code>int</code> objects <span class="ent">➊</span>. Next, you invoke <code>binary_search</code> with this <code>vector</code> as the target sequence and a value of <code>6</code>. Because the sequence contains 6, <code>binary_search</code> returns <code>true</code> <span class="ent">➋</span>. When you invoke <code>binary_search</code> with <code>7</code>, it returns <code>false</code> because the target sequence doesn’t contain <code>7</code> <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec7"><strong>Partitioning Algorithms</strong></h3>&#13;
<p class="noindent">A <em>partitioned sequence</em> contains two contiguous, distinct groups of elements. These groups don’t mix, and the first element of the second distinct group is called the <em>partition point</em>. The stdlib contains algorithms to partition sequences, determine whether a sequence is partitioned, and find partition points. Each algorithm explained in this section is in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec40"><strong><em><span epub:type="pagebreak" id="page_621"/>is_partitioned</em></strong></h4>&#13;
<p class="noindent">The <code>is_partitioned</code>    algorithm determines whether a sequence is partitioned.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A sequence is partitioned if all elements with some attribute appear before the elements that don’t.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm returns <code>true</code> if every element in the target sequence for which <code>pred</code> evaluates to <code>true</code> appears before the other elements.</p>&#13;
<pre>bool is_partitioned([ep], ipt_begin, ipt_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec141"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A predicate, <code>pred</code>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec142"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> At most <code>distance(ipt_begin, ipt_end)</code> evaluations of <code>pred</code></p>&#13;
<h5 class="h5" id="ch18lev3sec143"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("is_partitioned") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
&#13;
  vector&lt;int&gt; numbers1{ 9, 5, 9, 6, 4, 2 }; <span class="ent">➋</span>&#13;
  REQUIRE(is_partitioned(numbers1.begin(), numbers1.end(), is_odd)); <span class="ent">➌</span>&#13;
&#13;
  vector&lt;int&gt; numbers2{ 9, 4, 9, 6, 4, 2 }; <span class="ent">➍</span>&#13;
  REQUIRE_FALSE(is_partitioned(numbers2.begin(), numbers2.end(), is_odd)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <code>is_odd</code>, which returns <code>true</code> if the given number is odd <span class="ent">➊</span>. Next, you construct a <code>vector</code> of <code>int</code> objects <span class="ent">➋</span> and invoke <code>is_partitioned</code> with this <code>vector</code> as the target sequence and <code>is_odd</code> as the predicate. Because the sequence contains all its odd numbers placed before its even numbers, <code>is_partitioned</code> returns <code>true</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You then construct another <code>vector</code> of <code>int</code> objects <span class="ent">➍</span> and again invoke <code>is_partitioned</code> with this <code>vector</code> as the target sequence and <code>is_odd</code> as the predicate. Because the sequence doesn’t contain all its odd numbers placed before its even numbers (4 is even and before the second 9), <code>is_partitioned</code> returns <code>false</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec41"><strong><em><span epub:type="pagebreak" id="page_622"/>partition</em></strong></h4>&#13;
<p class="noindent">The <code>partition</code> algorithm partitions a sequence.</p>&#13;
<p class="indent">The algorithm mutates the target sequence so it’s partitioned according to <code>pred</code>. It returns the partition point. The elements’ original ordering isn’t necessarily preserved.</p>&#13;
<pre>ForwardIterator partition([ep], fwd_begin, fwd_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec144"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A predicate, <code>pred</code>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec145"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> At most <code>distance(fwd_begin, fwd_end)</code> evaluations of <code>pred</code></p>&#13;
<h5 class="h5" id="ch18lev3sec146"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence’s elements must be swappable.</p>&#13;
<h5 class="h5" id="ch18lev3sec147"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("partition") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; numbers{ 1, 2, 3, 4, 5 }; <span class="ent">➋</span>&#13;
  const auto partition_point = partition(numbers.begin(),&#13;
                                         numbers.end(), is_odd); <span class="ent">➌</span>&#13;
  REQUIRE(is_partitioned(numbers.begin(), numbers.end(), is_odd)); <span class="ent">➍</span>&#13;
  REQUIRE(partition_point == numbers.begin() + 3); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <code>is_odd</code>, which returns <code>true</code> if the given number is <code>odd</code> <span class="ent">➊</span>. Next, you construct a <code>vector</code> of <code>int</code> objects <span class="ent">➋</span> and invoke <code>partition</code> with this <code>vector</code> as the target sequence and <code>is_odd</code> as the predicate. You assign the resulting partition point into <code>partition_point</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">When you invoke <code>is_partitioned</code> on the target sequence with <code>is_odd</code> as the predicate, it returns <code>true</code> <span class="ent">➍</span>. Per the specification of the algorithm, <em>you cannot rely on the ordering within the groups</em>, but the <code>partition_point</code> will always be the fourth element, because the target sequence contains three odd numbers <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec42"><strong><em>partition_copy</em></strong></h4>&#13;
<p class="noindent">The <code>partition_copy</code> algorithm partitions a sequence.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_623"/>The algorithm partitions the target sequence by evaluating <code>pred</code> on each element. All true elements copy into <code>opt_true</code>, and all false elements copy into <code>opt_false</code>.</p>&#13;
<pre>ForwardIteratorPair partition_copy([ep], ipt_begin, ipt_end,&#13;
                                         opt_true, opt_false, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec148"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>InputIterator</code> objects, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>opt_true</code>, to receive copies of <code>true</code> elements</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>opt_false</code>, to receive copies of <code>false</code> elements</li>&#13;
<li class="noindent">A predicate, <code>pred</code>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec149"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> Exactly <code>distance(ipt_begin, ipt_end)</code> evaluations of <code>pred</code></p>&#13;
<h5 class="h5" id="ch18lev3sec150"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">The target sequence’s elements must be copy assignable.</li>&#13;
<li class="noindent">The input and output ranges must not overlap.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec151"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("partition_copy") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; numbers{ 1, 2, 3, 4, 5 }, odds, evens; <span class="ent">➋</span>&#13;
  partition_copy(numbers.begin(), numbers.end(),&#13;
                 back_inserter(odds), back_inserter(evens), is_odd); <span class="ent">➌</span>&#13;
  REQUIRE(all_of(odds.begin(), odds.end(), is_odd)); <span class="ent">➍</span>&#13;
  REQUIRE(none_of(evens.begin(), evens.end(), is_odd)); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <code>is_odd</code>, which returns <code>true</code> if the given number is <code>odd</code> <span class="ent">➊</span>. Next, you construct a <code>vector</code> of <code>int</code> objects containing the <code>numbers</code> from 1 to 5 and two empty <code>vector</code> objects called <code>odds</code> and <code>evens</code> <span class="ent">➋</span>. Next, you invoke <code>partition_copy</code> with <code>numbers</code> as the target sequence, a <code>back_inserter</code> to <code>odds</code> as the output for true elements, a <code>back_inserter</code> to <code>evens</code> as the output for false elements, and <code>is_odd</code> as the predicate <span class="ent">➌</span>. The result is that all of the elements in <code>odds</code> are odd <span class="ent">➍</span> and none of the elements in <code>evens</code> are odd <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec43"><strong><em><span epub:type="pagebreak" id="page_624"/>stable_partition</em></strong></h4>&#13;
<p class="noindent">The <code>stable_partition</code> algorithm partitions a sequence stably.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A stable partition might take more computation than an unstable partition, so the user is given the choice.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm mutates the target sequence so it’s partitioned according to <code>pred</code>. It returns the partition point. The elements’ original ordering is preserved.</p>&#13;
<pre>BidirectionalIterator stable_partition([ep], bid_begin, bid_end, pred);</pre>&#13;
<h5 class="h5" id="ch18lev3sec152"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>BidirectionalIterator</code>s, <code>bid_begin</code> and <code>bid_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A predicate, <code>pred</code>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec153"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Quasilinear</strong> <code>O(N log N)</code> swaps where    <code>N = distance(bid_begin, bid_end)</code>, or <code>O(N)</code> swaps if sufficient memory is available.</p>&#13;
<h5 class="h5" id="ch18lev3sec154"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence’s elements must be swappable, move constructible, and move assignable.</p>&#13;
<h5 class="h5" id="ch18lev3sec155"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("stable_partition") {&#13;
  auto is_odd = [](auto x) { return x % 2 == 1; }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; numbers{ 1, 2, 3, 4, 5 }; <span class="ent">➋</span>&#13;
  stable_partition(numbers.begin(), numbers.end(), is_odd); <span class="ent">➌</span>&#13;
  REQUIRE(numbers == vector&lt;int&gt;{ 1, 3, 5, 2, 4 }); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first construct a lambda called <code>is_odd</code>, which returns <code>true</code> if the given number is <code>odd</code> <span class="ent">➊</span>. Next, you construct a <code>vector</code> of <code>int</code> objects <span class="ent">➋</span> and invoke <code>stable_partition</code> with this <code>vector</code> as the target sequence and <code>is_odd</code> as the predicate <span class="ent">➌</span>. The result is that the <code>vector</code> contains the elements 1, 3, 5, 2, 4 because this is the only way to partition these numbers while preserving their original within-group order <span class="ent">➍</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec8"><span epub:type="pagebreak" id="page_625"/><strong>Merging Algorithms</strong></h3>&#13;
<p class="noindent"><em>Merging algorithms</em> merge two sorted target sequences such that the resulting sequence contains copies of both target sequences and is also sorted. Each algorithm explained in this section is in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec44"><strong><em>merge</em></strong></h4>&#13;
<p class="noindent">The <code>merge</code> algorithm merges two sorted sequences.</p>&#13;
<p class="indent">The algorithm copies both target sequences into the destination sequence. The destination sequence is sorted according to <code>operator&lt;</code> or <code>comp</code> if provided.</p>&#13;
<pre>OutputIterator merge([ep], ipt_begin1, ipt_end1,&#13;
                     ipt_begin2, ipt_end2, opt_result, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec156"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">Two pairs of <code>InputIterator</code>s, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequences</li>&#13;
<li class="noindent">An <code>OutputIterator</code>, <code>opt_result</code>, representing the destination sequence</li>&#13;
<li class="noindent">A predicate, <code>pred</code>, that determines group membership</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec157"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> At most <code>N-1</code> comparisons where <code>N = distance(ipt_begin1, ipt_end1) + distance(ipt_begin2, ipt_end2)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec158"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequences must be sorted according to <code>operator&lt;</code> or <code>comp</code> if provided.</p>&#13;
<h5 class="h5" id="ch18lev3sec159"><strong>Example</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("merge") {&#13;
  vector&lt;int&gt; numbers1{ 1, 4, 5 }, numbers2{ 2, 3, 3, 6 }, result; <span class="ent">➊</span>&#13;
  merge(numbers1.begin(), numbers1.end(),&#13;
        numbers2.begin(), numbers2.end(),&#13;
        back_inserter(result)); <span class="ent">➋</span>&#13;
  REQUIRE(result == vector&lt;int&gt;{ 1, 2, 3, 3, 4, 5, 6 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You construct three <code>vector</code> objects: two containing sorted <code>int</code> objects and another that is empty <span class="ent">➊</span>. Next, you merge the non-empty <code>vector</code> and <span epub:type="pagebreak" id="page_626"/>use the empty <code>vector</code> as the destination sequence via a <code>back_inserter</code> <span class="ent">➋</span>. The <code>result</code> contains copies of all the elements from the original sequences, and it too is sorted <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec9"><strong>Extreme-Value Algorithms</strong></h3>&#13;
<p class="noindent">Several algorithms, called <em>extreme-value algorithms</em>, determine minimum and maximum elements or place limits on the minimum or maximum value of an element. Each algorithm explained in this section is in the <code>&lt;algorithm&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec45"><strong><em>min and max</em></strong></h4>&#13;
<p class="noindent">The <code>min</code> or <code>max</code> algorithm determines a sequence’s extrema.</p>&#13;
<p class="indent">The algorithms use <code>operator&lt;</code> or <code>comp</code> and return the minimum (<code>min</code>) or maximum (<code>max</code>) object. The <code>minmax</code> algorithm returns both as a <code>std::pair</code> with <code>first</code> as the minimum and <code>second</code> as the maximum.</p>&#13;
<pre>T min(obj1, obj2, [comp]);&#13;
T min(init_list, [comp]);&#13;
T max(obj1, obj2, [comp]);&#13;
T max(init_list, [comp]);&#13;
Pair minmax(obj1, obj2, [comp]);&#13;
Pair minmax(init_list, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec160"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Two objects, <code>obj1</code> and <code>obj2</code>, or</li>&#13;
<li class="noindent">An initializer list, <code>init_list</code>, representing the objects to compare</li>&#13;
<li class="noindent">An optional comparison function, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec161"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Constant or Linear</strong> For the overloads taking <code>obj1</code> and <code>obj2</code>, exactly one comparison. For the initializer list, at most <code>N-1</code> comparisons where <code>N</code> is the length of the initializer list. In the case of <code>minmax</code>, given an initializer list, this grows to <code>3/2 N</code>.</p>&#13;
<h5 class="h5" id="ch18lev3sec162"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements must be copy constructible and comparable using the given comparison.</p>&#13;
<h5 class="h5" id="ch18lev3sec163"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("max and min") {&#13;
<span epub:type="pagebreak" id="page_627"/>  auto length_compare = [](const auto&amp; x1, const auto&amp; x2) { <span class="ent">➊</span>&#13;
    return x1.length() &lt; x2.length();&#13;
  };&#13;
&#13;
string undisc="undiscriminativeness", vermin="vermin";&#13;
  REQUIRE(min(undisc, vermin, length_compare) == "vermin"); <span class="ent">➋</span>&#13;
&#13;
string maxim="maxim", ultra="ultramaximal";&#13;
  REQUIRE(max(maxim, ultra, length_compare) == "ultramaximal"); <span class="ent">➌</span>&#13;
&#13;
string mini="minimaxes", maxi="maximin";&#13;
  const auto result = minmax(mini, maxi, length_compare); <span class="ent">➍</span>&#13;
  REQUIRE(result.first == maxi); <span class="ent">➎</span>&#13;
  REQUIRE(result.second == mini); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a lambda called <code>length_compare</code>, which uses <code>operator&lt;</code> to compare the lengths of two inputs <span class="ent">➊</span>. Next, you use <code>min</code> to determine whether <em>undiscriminativeness</em> or <em>vermin</em> has lesser length <span class="ent">➋</span>, and you use <code>max</code> to determine whether <em>maxim</em> or <em>ultramaximal</em> has greater length <span class="ent">➌</span>. Finally, you use <code>minmax</code> to determine which of <em>minimaxes</em> and <em>maximin</em> has minimum and maximum length <span class="ent">➍</span>.    The result is a pair <span class="ent">➎</span><span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec46"><strong><em>min_element and max_element</em></strong></h4>&#13;
<p class="noindent">The <code>min_element</code> or <code>max_element</code> algorithm determines a sequence’s extrema.</p>&#13;
<p class="indent">The algorithms use <code>operator&lt;</code> or <code>comp</code> and return an iterator pointing to the minimum (<code>min_element</code>) or maximum (<code>max_element</code>) object. The <code>minimax_element</code> algorithm returns both as a <code>std::pair</code> with <code>first</code> as the minimum and <code>second</code> as the maximum.</p>&#13;
<pre>ForwardIterator min_element([ep], fwd_begin, fwd_end, [comp]);&#13;
ForwardIterator max_element([ep], fwd_begin, fwd_end, [comp]);&#13;
Pair minmax_element([ep], fwd_begin, fwd_end, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec164"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of <code>ForwardIterator</code>s, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An optional comparison function, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec165"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> For <code>max</code> and <code>min</code>, at most <code>N-1</code> comparisons where <code>N=distance(fwd_begin, fwd_end)</code>; for <code>minmax</code>, <code>3/2 N</code></p>&#13;
<h5 class="h5" id="ch18lev3sec166"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The elements must be comparable using the given operation.</p>&#13;
<h5 class="h5" id="ch18lev3sec167"><span epub:type="pagebreak" id="page_628"/><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("min and max element") {&#13;
  auto length_compare = [](const auto&amp; x1, const auto&amp; x2) { <span class="ent">➊</span>&#13;
    return x1.length() &lt; x2.length();&#13;
  };&#13;
&#13;
  vector&lt;string&gt; words{ "civic", "deed", "kayak",  "malayalam" }; <span class="ent">➋</span>&#13;
&#13;
  REQUIRE(*min_element(words.begin(), words.end(),&#13;
                       length_compare) == "deed"); <span class="ent">➌</span>&#13;
  REQUIRE(*max_element(words.begin(), words.end(),&#13;
                       length_compare) == "malayalam"); <span class="ent">➍</span>&#13;
&#13;
  const auto result = minmax_element(words.begin(), words.end(),&#13;
                                     length_compare); <span class="ent">➎</span>&#13;
  REQUIRE(*result.first == "deed"); <span class="ent">➏</span>&#13;
  REQUIRE(*result.second == "malayalam"); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a lambda called <code>length_compare</code>, which uses <code>operator&lt;</code> to compare the lengths of two inputs <span class="ent">➊</span>. Next, you initialize a <code>vector</code> of <code>string</code> objects called <code>words</code> containing four words <span class="ent">➋</span>. You use <code>min_element</code> to determine the smallest of these words by passing it as the target sequence and <code>length_compare</code> as the comparison function (<code>deed</code>) <span class="ent">➌</span>, and you use <code>max_element</code> to determine the largest (<code>malayalam</code>) <span class="ent">➍</span>. Finally, you use <code>minmax_element</code>, which returns both as a <code>std::pair</code> <span class="ent">➎</span>. The <code>first</code> element refers to the shortest <code>word</code> <span class="ent">➏</span>, and <code>second</code> refers to the longest <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec47"><strong><em>clamp</em></strong></h4>&#13;
<p class="noindent">The <code>clamp</code> algorithm bounds a value.</p>&#13;
<p class="indent">The algorithm uses <code>operator&lt;</code> or <code>comp</code> to determine whether <code>obj</code> is inside the bounds from <code>low</code> to <code>high</code>. If it is, the algorithm simply returns <code>obj</code>; otherwise, if <code>obj</code> is less than <code>low</code>, it returns <code>low</code>. If <code>obj</code> is greater than <code>high</code>, it returns <code>high</code>.</p>&#13;
<pre>T&amp; clamp(obj, low, high, [comp]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec168"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An object, <code>obj</code></li>&#13;
<li class="noindent">A <code>low</code> and <code>high</code> object</li>&#13;
<li class="noindent">An optional comparison function, <code>comp</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec169"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Constant</strong> At most two comparisons</p>&#13;
<h5 class="h5" id="ch18lev3sec170"><span epub:type="pagebreak" id="page_629"/><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">The objects must be comparable using the given operation.</p>&#13;
<h5 class="h5" id="ch18lev3sec171"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;algorithm&gt;&#13;
&#13;
TEST_CASE("clamp") {&#13;
  REQUIRE(clamp(9000, 0, 100) == 100); <span class="ent">➊</span>&#13;
  REQUIRE(clamp(-123, 0, 100) == 0); <span class="ent">➋</span>&#13;
  REQUIRE(clamp(3.14, 0., 100.) == Approx(3.14)); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">In the first example, you clamp <code>9000</code> to the interval from 0 to 100 inclusive. Because 9,000 &gt; 100, the result is <code>100</code> <span class="ent">➊</span>. In the second example, you clamp <code>-123</code> to the same interval. Because −123 &lt; 0, the result is <code>0</code> <span class="ent">➋</span>. Finally, you clamp <code>3.14</code> and because it’s within the interval, the result is <code>3.14</code> <span class="ent">➌</span>.</p>&#13;
<h3 class="h3" id="ch18lev1sec10"><strong>Numeric Operations</strong></h3>&#13;
<p class="noindent">The <code>&lt;numeric&gt;</code> header was discussed in <a href="ch12.xhtml#ch12">Chapter 12</a> when you learned about its mathematical types and functions. It also provides algorithms well suited to numeric operations. This section introduces many of them. Each algorithm explained in this section is in the <code>&lt;numeric&gt;</code> header.</p>&#13;
<h4 class="h4" id="ch18lev2sec48"><strong><em>Useful Operators</em></strong></h4>&#13;
<p class="noindent">Some stdlib numeric operations permit you to pass an operator to customize behavior. For convenience, the <code>&lt;functional&gt;</code> header provides the following class templates that expose various binary arithmetic operations through <code>operator(T x, T y)</code>:</p>&#13;
<ul>&#13;
<li class="noindent"><code>plus&lt;T&gt;</code> implements addition <code>x + y</code>.</li>&#13;
<li class="noindent"><code>minus&lt;T&gt;</code> implements subtraction <code>x - y</code>.</li>&#13;
<li class="noindent"><code>multiplies&lt;T&gt;</code> implements multiplication <code>x * y</code>.</li>&#13;
<li class="noindent"><code>divides&lt;T&gt;</code> implements division <code>x / y</code>.</li>&#13;
<li class="noindent"><code>modulus&lt;T&gt;</code> implements addition <code>x % y</code>.</li>&#13;
</ul>&#13;
<p class="indent">For example, you could add two numbers using the <code>plus</code> template, like this:</p>&#13;
<pre>#include &lt;functional&gt;&#13;
&#13;
TEST_CASE("plus") {&#13;
  plus&lt;short&gt; adder; <span class="ent">➊</span>&#13;
  REQUIRE(3 == adder(1, 2)); <span class="ent">➋</span>&#13;
  REQUIRE(3 == plus&lt;short&gt;{}(1,2)); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_630"/>You first instantiate a <code>plus</code> called <code>adder</code> <span class="ent">➊</span>, and then you invoke it with the values <code>1</code> and <code>2</code>, which yields <code>3</code> <span class="ent">➋</span>. You can also skip the variable entirely and simply use a newly constructed <code>plus</code> directly to achieve the same result <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You generally wouldn’t use these operator types unless you were using generic code that required them.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch18lev2sec49"><strong><em>iota</em></strong></h4>&#13;
<p class="noindent">The <code>iota</code> algorithm fills a sequence with incremental values.</p>&#13;
<p class="indent">The algorithm assigns incremental values beginning with <code>start</code> to the target sequence.</p>&#13;
<pre>void iota(fwd_begin, fwd_end, start);</pre>&#13;
<h5 class="h5" id="ch18lev3sec172"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <code>fwd_begin</code> and <code>fwd_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>start</code> value</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec173"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <code>N</code> increments and assignments, where <code>N=distance(fwd_begin, fwd_end)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec174"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The objects must be assignable to <code>start</code>.</p>&#13;
<h5 class="h5" id="ch18lev3sec175"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
#include &lt;array&gt;&#13;
&#13;
TEST_CASE("iota") {&#13;
  array&lt;int, 3&gt; easy_as; <span class="ent">➊</span>&#13;
  iota(easy_as.begin(), easy_as.end(), 1); <span class="ent">➋</span>&#13;
  REQUIRE(easy_as == array&lt;int, 3&gt;{ 1, 2, 3 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize an <code>array</code> of <code>int</code> objects with length <code>3</code> <span class="ent">➊</span>. Next, you invoke <code>iota</code> with the <code>array</code> as the target sequence and <code>1</code> as the <code>start</code> value <span class="ent">➋</span>. The result is that <code>array</code> contains the elements 1, 2, and 3 <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec50"><strong><em>accumulate</em></strong></h4>&#13;
<p class="noindent">The <code>accumulate</code> algorithm folds a sequence (in order).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Folding a sequence means to apply a particular operation over the elements of a sequence while passing the cumulative result along to the next operation.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_631"/>The algorithm applies <code>op</code> to <code>start</code> and the target sequence’s first element. It takes the result and the target sequence’s next element and again applies <code>op</code>, proceeding in this fashion until it visits each element in the target sequence. Loosely, this algorithm adds the target sequence elements and the <code>start</code> value, and it returns the result.</p>&#13;
<pre>T accumulate(ipt_begin, ipt_end, start, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec176"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>start</code> value</li>&#13;
<li class="noindent">An optional binary operator, <code>op</code>, that defaults to <code>plus</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec177"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <code>N</code> applications of <code>op</code>, where <code>N=distance(ipt_begin, ipt_end)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec178"><strong>Additional Requirements</strong></h5>&#13;
<p class="noindent">The target sequence’s elements must be copyable.</p>&#13;
<h5 class="h5" id="ch18lev3sec179"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("accumulate") {&#13;
  vector&lt;int&gt; nums{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  const auto result1 = accumulate(nums.begin(), nums.end(), -1); <span class="ent">➋</span>&#13;
  REQUIRE(result1 == 5); <span class="ent">➌</span>&#13;
&#13;
  const auto result2 = accumulate(nums.begin(), nums.end(),&#13;
                                  2, multiplies&lt;&gt;()); <span class="ent">➍</span>&#13;
  REQUIRE(result2 == 12); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <code>vector</code> of <code>int</code> objects with length <code>3</code> <span class="ent">➊</span>. Next, you invoke <code>accumulate</code> with the <code>vector</code> as the target sequence and <code>-1</code> as the <code>start</code> value <span class="ent">➋</span>. The result is −1 + 1 + 2 + 3 = 5 <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you use the same target sequence but a start value of <code>2</code> and the <code>multiplies</code> operator instead <span class="ent">➍</span>. The result is 2 * 1 * 2 * 3 = 12 <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec51"><strong><em>reduce</em></strong></h4>&#13;
<p class="noindent">The <code>reduce</code> algorithm folds a sequence (not necessarily in order).</p>&#13;
<p class="indent">The algorithm is identical to <code>accumulate</code> except it accepts an optional <code>execution</code> and doesn’t guarantee the order of operator applications.</p>&#13;
<pre>T reduce([ep], ipt_begin, ipt_end, start, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec180"><strong><span epub:type="pagebreak" id="page_632"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">An optional <code>std::execution</code> execution policy, <code>ep</code> (default: <code>std::execution::seq</code>)</li>&#13;
<li class="noindent">A pair of iterators, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">A <code>start</code> value</li>&#13;
<li class="noindent">An optional binary operator, <code>op</code>, that defaults to <code>plus</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec181"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <code>N</code> applications of <code>op</code>, where <code>N=distance(ipt_begin, ipt_end)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec182"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Elements must be movable if you omit <code>ep</code>.</li>&#13;
<li class="noindent">Elements must copyable if you provide <code>ep</code>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec183"><strong>Examples</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("reduce") {&#13;
  vector&lt;int&gt; nums{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  const auto result1 = reduce(nums.begin(), nums.end(), -1); <span class="ent">➋</span>&#13;
  REQUIRE(result1 == 5); <span class="ent">➌</span>&#13;
&#13;
  const auto result2 = reduce(nums.begin(), nums.end(),&#13;
                                  2, multiplies&lt;&gt;()); <span class="ent">➍</span>&#13;
  REQUIRE(result2 == 12); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize a <code>vector</code> of <code>int</code> objects with length <code>3</code> <span class="ent">➊</span>. Next, you invoke <code>reduce</code> with the <code>vector</code> as the target sequence and <code>-1</code> as the <code>start</code> value <span class="ent">➋</span>. The result is −1 + 1 + 2 + 3 = 5 <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second example, you use the same target sequence but a start value of <code>2</code> and the <code>multiplies</code> operator instead <span class="ent">➍</span>. The result is 2 * 1 * 2 * 3 = 12 <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec52"><strong><em>inner_product</em></strong></h4>&#13;
<p class="noindent">The <code>inner_product</code> algorithm computes the inner product of two sequences.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An inner product (or dot product) is a scalar value associated with a pair of sequences.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm applies <code>op2</code> to each pair of corresponding elements in the target sequence and sums them together with <code>start</code> using <code>op1</code>.</p>&#13;
<pre>T inner_product([ep], ipt_begin1, ipt_end1, ipt_begin2, start, [op1], [op2]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec184"><strong><span epub:type="pagebreak" id="page_633"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <code>ipt_begin1</code> and <code>ipt_end1</code>, representing target sequence 1</li>&#13;
<li class="noindent">An iterator, <code>ipt_begin2</code>, representing target sequence 2</li>&#13;
<li class="noindent">A <code>start</code> value</li>&#13;
<li class="noindent">Two optional binary operators, <code>op1</code> and <code>op2</code>, that default to <code>plus</code> and <code>multiply</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec185"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <code>N</code> applications of <code>op1</code> and <code>op2</code>, where <code>N=distance(ipt_begin1, ipt_end1)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec186"><strong>Additional Requirements</strong></h5>&#13;
<p class="indent">Elements must be copyable.</p>&#13;
<h5 class="h5" id="ch18lev3sec187"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("inner_product") {&#13;
  vector&lt;int&gt; nums1{ 1, 2, 3, 4, 5 }; <span class="ent">➊</span>&#13;
  vector&lt;int&gt; nums2{ 1, 0,-1, 0, 1 }; <span class="ent">➋</span>&#13;
  const auto result = inner_product(nums1.begin(), nums1.end(),&#13;
                                    nums2.begin(), 10); <span class="ent">➌</span>&#13;
  REQUIRE(result == 13); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize two <code>vector</code>s of <code>int</code> objects <span class="ent">➊</span> <span class="ent">➋</span>. Next, you invoke <code>inner_product</code> with the two <code>vector</code> objects as the target sequences and <code>10</code> as the <code>start</code> value <span class="ent">➌</span>. The result is 10 + 1 * 1 + 2 * 0 + 3 * 1 + 4 * 0 + 4 * 1 = 13 <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec53"><strong><em>adjacent_difference</em></strong></h4>&#13;
<p class="noindent">The <code>adjacent_difference</code> algorithm generates adjacent differences.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An adjacent difference is the result of applying some operation to each pair of neighboring elements.</em></p>&#13;
</div>&#13;
<p class="indent">The algorithm sets the first element of the destination sequence equal to the first element of the target sequence. For each subsequent element, it applies <code>op</code> to the prior element and the current element and writes the return value into <code>result</code>. The algorithm returns the end of the destination sequence.</p>&#13;
<pre>OutputIterator adjacent_difference([ep], ipt_begin, ipt_end, result, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec188"><strong><span epub:type="pagebreak" id="page_634"/>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <code>ipt_begin</code> and <code>ipt_end</code>, representing target sequence</li>&#13;
<li class="noindent">An iterator, <code>result</code>, representing the destination sequence</li>&#13;
<li class="noindent">An optional binary operator, <code>op</code>, that defaults to <code>minus</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec189"><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <code>N-1</code> applications of <code>op</code>, where <code>N=distance(ipt_begin, ipt_end)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec190"><strong>Additional Requirements</strong></h5>&#13;
<ul>&#13;
<li class="noindent">Elements must be movable if you omit <code>ep</code>.</li>&#13;
<li class="noindent">Elements must copyable if you provide <code>ep</code>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec191"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("adjacent_difference") {&#13;
  vector&lt;int&gt; fib{ 1, 1, 2, 3, 5, 8 }, fib_diff; <span class="ent">➊</span>&#13;
  adjacent_difference(fib.begin(), fib.end(), back_inserter(fib_diff)); <span class="ent">➋</span>&#13;
  REQUIRE(fib_diff == vector&lt;int&gt;{ 1, 0, 1, 1, 2, 3 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first two initialize a <code>vector</code> of <code>int</code> objects, one containing the first six numbers of the Fibonacci sequence and another that is empty <span class="ent">➊</span>. Next, you invoke <code>adjacent_difference</code> with the two <code>vector</code> objects as the target sequences <span class="ent">➋</span>. The result is as expected: the first element equals the first element of the Fibonacci sequence, and the following elements are the adjacent differences (1 – 1 = 0), (2 – 1 = 1), (3 – 2 = 1), (5 – 3 = 2), (8 – 5 = 3) <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec54"><strong><em>partial_sum</em></strong></h4>&#13;
<p class="noindent">The <code>partial_sum</code> algorithm generates partial sums.</p>&#13;
<p class="indent">The algorithm sets an accumulator equal to the first element of the target sequence. For each subsequent element of the target sequence, the algorithm adds that element to the accumulator and then writes the accumulator into the destination sequence. The algorithm returns the end of the destination sequence.</p>&#13;
<pre>OutputIterator partial_sum(ipt_begin, ipt_end, result, [op]);</pre>&#13;
<h5 class="h5" id="ch18lev3sec192"><strong>Arguments</strong></h5>&#13;
<ul>&#13;
<li class="noindent">A pair of iterators, <code>ipt_begin</code> and <code>ipt_end</code>, representing the target sequence</li>&#13;
<li class="noindent">An iterator, <code>result</code>, representing the destination sequence</li>&#13;
<li class="noindent">An optional binary operator, <code>op</code>, that defaults to <code>plus</code></li>&#13;
</ul>&#13;
<h5 class="h5" id="ch18lev3sec193"><span epub:type="pagebreak" id="page_635"/><strong>Complexity</strong></h5>&#13;
<p class="noindent"><strong>Linear</strong> <code>N-1</code> applications of <code>op</code>, where <code>N=distance(ipt_begin, ipt_end)</code></p>&#13;
<h5 class="h5" id="ch18lev3sec194"><strong>Example</strong></h5>&#13;
<pre>#include &lt;numeric&gt;&#13;
&#13;
TEST_CASE("partial_sum") {&#13;
  vector&lt;int&gt; num{ 1, 2, 3, 4 }, result; <span class="ent">➊</span>&#13;
  partial_sum(num.begin(), num.end(), back_inserter(result)); <span class="ent">➋</span>&#13;
  REQUIRE(result == vector&lt;int&gt;{ 1, 3, 6, 10 }); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="indent">You first initialize two <code>vector</code> of <code>int</code> objects, one called <code>num</code> containing the first four counting and an empty one called <code>result</code> <span class="ent">➊</span>. Next, you invoke <code>partial_sum</code> with <code>num</code> as the target sequence and <code>result</code> as the destination <span class="ent">➋</span>. The first element equals the first element of the target sequence, and the following elements are the partial sums (1 + 2 = 3), (3 + 3 = 6), (6 + 4 = 10) <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch18lev2sec55"><strong><em>Other Algorithms</em></strong></h4>&#13;
<p class="noindent">To keep a long chapter from getting much longer, many algorithms are omitted. This section provides a survey of them.</p>&#13;
<h5 class="h5" id="ch18lev3sec195"><strong>(Max) Heap Operations</strong></h5>&#13;
<p class="noindent">A range of length <em>N</em> is a max heap if for all 0 &lt; <em>i</em> &lt; <em>N</em>, the <img src="../images/fig635_1.jpg" alt="Image"/>-th element (rounded down) doesn’t compare less than the <em>i</em>-th element. These structures have strong performance properties in situations where maximum element lookup and insertions must be fast.</p>&#13;
<p class="indent">The <code>&lt;algorithm&gt;</code> header contains functions that are useful for handling such ranges, such as those in <a href="ch18.xhtml#ch18tab01">Table 18-1</a>. See [alg.heap.operations] for details.</p>&#13;
<p class="tabcap" id="ch18tab01"><strong>Table 18-1:</strong> Heap-Related Algorithms in the <code>&lt;algorithm&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_heap</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Checks whether a range is a max heap</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_heap_until</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Finds the largest subrange that is a max heap</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>make_heap</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a max heap</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>push_heap</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Adds an element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>pop_heap</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the largest element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>sort_heap</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Transforms a max heap into a sorted range</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch18lev3sec196"><strong>Set Operations on Sorted Ranges</strong></h5>&#13;
<p class="noindent">The <code>&lt;algorithm&gt;</code> header contains functions that perform set operations on sorted ranges, such as those in <a href="ch18.xhtml#ch18tab02">Table 18-2</a>. See [alg.set.operations] for details.</p>&#13;
<p class="tabcap" id="ch18tab02"><span epub:type="pagebreak" id="page_636"/><strong>Table 18-2:</strong> Set-Related Algorithms in the <code>&lt;algorithm&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>includes</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if one range is a subset of another range</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>set_difference</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Computes the difference between two sets</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>set_intersection</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Computes the intersection of two sets</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>set_symmetric_difference</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Computes the symmetric difference between two sets</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>set_union</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Computes the union of two sets</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch18lev3sec197"><strong>Other Numeric Algorithms</strong></h5>&#13;
<p class="noindent">The <code>&lt;numeric&gt;</code> header contains several more functions in addition to those introduced in the “Numeric Operations” section. <a href="ch18.xhtml#ch18tab03">Table 18-3</a> lists them. See [numeric.ops] for details.</p>&#13;
<p class="tabcap" id="ch18tab03"><strong>Table 18-3:</strong> Additional Numerical Algorithms in the <code>&lt;numeric&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>exclusive_scan</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Like <code>partial_sum</code> but excludes the <code>i</code>-th element from the <code>i</code>-th sum</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>inclusive_scan</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Like <code>partial_sum</code> but executes out of order and requires an associative operation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>transform_reduce</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Applies a function object; then reduces out of order</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>transform_exclusive_scan</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Applies a function object; then calculates an exclusive scan</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>transform_inclusive_scan</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Applies a function object; then calculates an inclusive scan</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch18lev3sec198"><strong>Memory Operations</strong></h5>&#13;
<p class="noindent">The <code>&lt;memory&gt;</code> header contains a number of low-level functions for handling uninitialized memory. <a href="ch18.xhtml#ch18tab04">Table 18-4</a> lists them. See [memory.syn] for details.</p>&#13;
<p class="tabcap" id="ch18tab04"><strong>Table 18-4:</strong> Operations for Uninitialized Memory in the <code>&lt;memory&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>uninitialized_copy</code></p>&#13;
<p class="taba"><code>uninitialized_copy_n</code></p>&#13;
<p class="taba"><code>uninitialized_fill</code></p>&#13;
<p class="taba"><code>uninitialized_fill_n</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy objects into uninitialized memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>uninitialized_move</code></p>&#13;
<p class="taba"><code>uninitialized_move_n</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Move objects into uninitialized memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>uninitialized_default_construct</code></p>&#13;
<p class="taba"><code>uninitialized_default_construct_n</code></p>&#13;
<p class="taba"><code>uninitialized_value_construct</code></p>&#13;
<p class="taba"><code>uninitialized_value_construct_n</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Construct objects in uninitialized memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>destroy_at</code></p>&#13;
<p class="taba"><code>destroy</code></p>&#13;
<p class="taba"><code>destroy_n</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Destroy objects</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch18lev1sec11"><strong><span epub:type="pagebreak" id="page_637"/>Boost Algorithm</strong></h3>&#13;
<p class="noindent">Boost Algorithm is a large algorithm library that overlaps partially with the standard library. For space reasons, <a href="ch18.xhtml#ch18tab05">Table 18-5</a> lists only a quick reference to those algorithms not already contained in the standard library. Refer to the Boost Algorithm documentation for further information.</p>&#13;
<p class="tabcap" id="ch18tab05"><strong>Table 18-5:</strong> Additional Algorithms Available in Boost Algorithm</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boyer_moore</code></p>&#13;
<p class="taba"><code>boyer_moore_horspool</code></p>&#13;
<p class="taba"><code>knuth_morris_pratt</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Fast algorithms for searching sequences of values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>hex</code></p>&#13;
<p class="taba"><code>unhex</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes/reads hexadecimal characters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>gather</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Takes a sequence and moves elements satisfying a predicate into a given position</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>find_not</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Finds the first element in a sequence not equal to a value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>find_backward</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Like <code>find</code> but works backward</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_partitioned_until</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the end iterator for the largest partitioned subsequence that begins with the target sequence’s first element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>apply_permutation</code></p>&#13;
<p class="taba"><code>apply_reverse_permutation</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Takes an item sequence and an order sequence and reshuffles the item sequence according to the order sequence</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>is_palindrome</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns <code>true</code> if a sequence is a palindrome</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><strong>A NOTE ON RANGES</strong></p>&#13;
<p class="noindent"><a href="ch08.xhtml">Chapter 8</a> introduced range expressions as part of the range-based <code>for</code> loop. Recall from this discussion that a range is a concept that exposes <code>begin</code> and <code>end</code> methods that return iterators. Because you can place requirements on iterators to support certain operations, you can place transitive requirements on ranges so they provide certain iterators. Each algorithm has certain operational requirements, and these are reflected in the sorts of iterators they require. Because you can encapsulate an algorithm’s input sequence requirements in terms of ranges, you must understand the various range types to understand each algorithm’s constraints.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_638"/>Like concepts, ranges are not yet formally part of C++. Although you’ll still get tremendous benefit from understanding the relationship among ranges, iterators, and algorithms, there are two drawbacks. First, algorithms still require iterators as input arguments, so even if a range is at hand, you’ll need to extract iterators manually (for example, with <code>begin</code> and <code>end</code>). Second, as with other function templates, you’ll sometimes get spectacularly poor error messages when you violate an algorithm’s operational requirements.</p>&#13;
<p class="indent">Work is underway to introduce ranges into the language formally. In fact, concepts and ranges will likely enter the C++ Standard simultaneously because they dovetail so nicely.</p>&#13;
<p class="indent">If you want to experiment with one possible implementation of ranges, refer to Boost Range.</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
<li class="noindent">“Algorithmic Complexity” by Victor Adamchik (<a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html"><em>https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html</em></a>)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>