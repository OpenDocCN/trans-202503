- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving Time with Views, Functions, and Triggers
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One advantage of using a programming language is that we can automate repetitive,
    boring tasks. That’s what this chapter is about: taking the queries or steps you
    might do over and over and turning them into reusable database objects that you
    code once and can call later to let the database do the work. Programmers call
    this the DRY principle: Don’t Repeat Yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll start by learning to store queries as reusable database *views*. Next,
    you’ll explore how to create database functions you can use to operate on your
    data, the same way you’ve used built-in functions like `round()` and `upper()`.
    Then you’ll set up *triggers* to run your functions automatically when certain
    events occur on a table. All these techniques are useful not only for reducing
    repetitive work but for ensuring data integrity too.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll practice these techniques on tables created from examples in earlier chapters.
    All the code for this chapter is available for download along with the book’s
    resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Views to Simplify Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *view* is essentially a stored query with a name that you can work with as
    if it were a table. For example, a view might store a query that calculates total
    population by state. As with a table, you could query that view, join the view
    to tables (or to other views), and use the view to update or insert data into
    a table it’s based on, albeit with some caveats. The stored query in a view can
    be simple, referencing just one table, or complex, with multiple table joins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views are especially useful in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoiding duplicate effort:** They let you write a complex query once and
    access the results when needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing clutter:** They can trim the amount of information you need to wade
    through by showing only columns relevant to your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providing security:** Views can limit access to only certain columns in a
    table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we’ll look at two kinds of views. The first—a standard view—contains
    PostgreSQL syntax that’s largely in line with the ANSI SQL standard for views.
    Every time you access a standard view, the stored query runs and generates a temporary
    set of results. The second is a *materialized view*, which is specific to PostgreSQL,
    Oracle, and a limited number of other database systems. When you create a materialized
    view, the data returned by its query is stored permanently in the database like
    a table; you can refresh the view to update the stored data if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Views are easy to create and maintain. Let’s work through several examples to
    see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Querying Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll return to the census estimates table `us_counties_pop_est_2019`
    you imported in Chapter 5. [Listing 17-1](#listing17-1) creates a standard view
    that returns just the population of Nevada counties. The original table has sixteen
    columns; the view will return just four of them. This would be useful for making
    a subset of Nevada census data quickly accessible when we’re referring to it often
    or using the data in an application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-1: Creating a view that displays Nevada 2019 counties'
  prefs: []
  type: TYPE_NORMAL
- en: We define the view using the keywords `CREATE OR REPLACE VIEW` 1 followed by
    the view’s name, `nevada_counties_pop_2019`, and then `AS`. (We can name the view
    any way we’d like; I prefer a name that’s descriptive of the view’s results.)
    Next, we use a standard SQL `SELECT` 2 to fetch the 2019 population estimate (the
    `pop_est_2019` column) for each Nevada county from the `us_counties_pop_est_2019`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `OR REPLACE` keywords after `CREATE`. These are optional and tell
    the database that if a view with this name already exists, then replace it with
    the new definition. It’s helpful to include these keywords if you’re iterating
    on creating a view and want to refine the query. There is one caveat: if you’re
    replacing an existing view, the new query 2 must generate the same column names
    with the same data types and in the same order as the one it’s replacing. You
    can add columns, but they must be placed at the end of the column list. If you
    try to do otherwise, the database will respond with an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code in [Listing 17-1](#listing17-1) using pgAdmin. The database should
    respond with the message `CREATE VIEW`. To find the new view, in pgAdmin’s object
    browser, right-click the `analysis` database and click **Refresh**. Choose **Schemas**▶**public**▶**Views**
    to see all views. When you right-click your new view and click **Properties**,
    you should see a more verbose version of the query (with the table name prepended
    to each column name) on the Code tab in the dialog that opens. That’s a handy
    way to inspect views you might find in a database.
  prefs: []
  type: TYPE_NORMAL
- en: This type of view—one that isn’t materialized—holds no data at this point; instead,
    the stored `SELECT` query it contains will run when you access the view from another
    query. For example, the code in [Listing 17-2](#listing17-2) returns all columns
    in the view. As with a typical `SELECT` query, we can use `ORDER BY` to sort results,
    this time using the county’s Federal Information Processing Standards (FIPS) code—the
    standard designator the US Census Bureau and other federal agencies use to specify
    each county and state. We also add a `LIMIT` clause to display just five rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-2: Querying the `nevada_counties_pop_2010` view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the five-row limit, the result should be the same as if you had
    run the `SELECT` query used to create the view in [Listing 17-1](#listing17-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple example isn’t useful unless quickly listing Nevada county population
    is a task you’ll perform frequently. So, let’s imagine a question data-minded
    analysts in a political research organization might ask often: what was the percent
    change in population for each county in Nevada (or any other state) from 2010
    to 2019?'
  prefs: []
  type: TYPE_NORMAL
- en: We wrote a query to answer this question in Chapter 7, and though it wasn’t
    onerous to create, it did require joining tables on two columns and using a percent
    change formula that involved rounding and type casting. To avoid repeating that
    work, we can create a view that stores a query similar to the one in Chapter 7
    as a view, as shown in [Listing 17-3](#listing17-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-3: Creating a view showing population change for US counties'
  prefs: []
  type: TYPE_NORMAL
- en: We start the view definition with `CREATE OR REPLACE VIEW` 1, followed by the
    name of the view and `AS`. The `SELECT` query 2 names columns from the census
    tables and includes a column definition with a percent change calculation 3 that
    you learned about in Chapter 6. Then we join the 2019 and 2010 census tables 4
    using the state and county FIPS codes. Run the code, and the database should again
    respond with `CREATE VIEW`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the view, we can use the code in [Listing 17-4](#listing17-4)
    to run a simple query using the new view that retrieves data for Nevada counties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-4: Selecting columns from the `county_pop_change_2019_2010` view'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 17-2](#listing17-2), in the query that referenced our `nevada_counties_pop_2019`
    view, we retrieved every column in the view by using the asterisk wildcard after
    `SELECT`. [Listing 17-4](#listing17-4) shows that, as with a query on a table,
    we can name specific columns when querying a view. Here, we specify four of the
    `county_pop_change_2019_2010` view’s seven columns. One is `pct_change_2019_2010`
    1, which returns the result of the percent change calculation we’re looking for.
    As you can see, it’s much simpler to write the column name like this than the
    whole formula. We’re also filtering the results using a `WHERE` clause 2, similar
    to how we’d filter any query.
  prefs: []
  type: TYPE_NORMAL
- en: 'After querying the four columns from the view, the results should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we can revisit this view as often as we like to pull data for presentations
    or to answer questions about the percent change in population for any county in
    America from 2010 to 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at just these five rows, you can see a couple of interesting stories
    emerge: the continued rapid growth of Clark County, which includes the city of
    Las Vegas, as well as a strong percent increase in Esmeralda County, one of the
    smallest counties in the United States and home to several ghost towns.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Refreshing a Materialized View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A materialized view differs from a standard view in that upon its creation,
    the materialized view’s stored query is executed, and the results it generates
    are saved in the database. In effect, this creates a new table. The view retains
    its stored query, so you can update the saved data by issuing a command to refresh
    the view. A good use for materialized views is to preprocess complex queries that
    take a while to run and make those results available for faster querying.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s drop the `nevada_counties_pop_2019` view and re-create it as a materialized
    view using the code in [Listing 17-5](#listing17-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-5: Creating a materialized view'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a `DROP VIEW` 1 statement to remove the `nevada_counties_pop_2019`
    view from the database. Then, we run `CREATE MATERIALIZED VIEW` 2 to make the
    view. Notice that the syntax is the same as the one for making a standard view,
    except for the added `MATERIALIZED` keyword and the omission of `OR REPLACE`,
    which is not available in the materialized view syntax. After running the statement,
    the database should respond with the message `SELECT 17`, telling you that the
    view’s query produced 17 rows to be stored in the view. We can now query this
    data as with a standard view.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that the population estimates stored in `us_counties_pop_est_2019`
    are revised. To update the data stored in the materialized view, we can use the
    `REFRESH` keyword, as in [Listing 17-6](#listing17-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-6: Refreshing a materialized view'
  prefs: []
  type: TYPE_NORMAL
- en: Executing this statement reruns the query stored in the `nevada_counties_pop_2019`
    view; the server will respond with the message `REFRESH MATERIALIZED VIEW`. The
    view will now reflect any updates to the data referenced by the view’s query.
    When you have a query that takes some time to run, you can save time by storing
    its results in a materialized view that’s refreshed periodically, letting users
    quickly access the stored data rather than run a lengthy query.
  prefs: []
  type: TYPE_NORMAL
- en: To delete a materialized view, we use a `DROP MATERIALIZED VIEW` statement.
    Also, note that materialized views appear in a different part of pgAdmin’s object
    browser, under **Schemas**▶**public**▶**Materialized Views**.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, Updating, and Deleting Data Using a View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With nonmaterialized views, you can update or insert data in the underlying
    table being queried as long as the view meets certain conditions. One requirement
    is that the view must reference a single table or updatable view. If the view’s
    query joins tables, as with the population change view we just built in the previous
    section, you can’t perform inserts or updates to the original table directly.
    Also, the view’s query can’t contain `DISTINCT`, `WITH`, `GROUP BY`, or other
    clauses. (See a complete list of restrictions at [https://www.postgresql.org/docs/current/sql-createview.html](https://www.postgresql.org/docs/current/sql-createview.html).)
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to directly insert and update data on a table, so why do
    it through a view? One reason is that a view is one way you can exercise control
    over which data a user can update. Let’s work through an example to see how this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a View of Employees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the Chapter 7 lesson on joins, we created and filled the `departments` and
    `employees` tables with four rows about people and where they work (if you skipped
    that section, you can revisit [Listing 7-1](c07.xhtml#listing7-1)). Running a
    quick `SELECT * FROM employees ORDER BY emp_id;` query shows the table’s contents,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say we want to use a view to give users in the Tax Department (its `dept_id`
    is `1`) the ability to add, remove, or update their employees’ names without letting
    them change salary information or the data of employees in another department.
    To do this, we can set up a view using [Listing 17-7](#listing17-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-7: Creating a view on the `employees` table'
  prefs: []
  type: TYPE_NORMAL
- en: This view is similar to others we’ve created so far, but with a few additions.
    First, in the `CREATE OR REPLACE VIEW` statement, we add the keywords `WITH (security_barrier)`
    1. This enables a level of database security to prevent a malicious user from
    getting around restrictions that the view places on rows and columns. (See [https://www.postgresql.org/docs/current/rules-privileges.html](https://www.postgresql.org/docs/current/rules-privileges.html)
    for how someone might subvert a view if you omit this type of security.)
  prefs: []
  type: TYPE_NORMAL
- en: In the view’s `SELECT` query, we pick the columns we want to show from the `employees`
    table and use `WHERE` to filter the results on `dept_id = 1` 2 to list only Tax
    Department staff. The view itself will restrict updates or deletes to rows matching
    the condition in the `WHERE` clause. Adding the keywords `WITH LOCAL CHECK OPTION`
    3 restricts inserts as well, allowing users to add new Tax Department employees
    only (if the view definition omitted those keywords, you could use it to insert
    a row with a `dept_id` of `3`, for example). The `LOCAL CHECK OPTION` also prevents
    a user from changing an employee’s `dept_id` to a value other than `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `employees_tax_dept` view by running the code in [Listing 17-7](#listing17-7).
    Then run `SELECT * FROM employees_tax_dept ORDER BY emp_id;`, which should provide
    these two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The result shows the employees who work in the Tax Department; they’re two of
    the four rows in the entire `employees` table.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how inserts and updates work via this view.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Rows Using the employees_tax_dept View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use a view to insert or update data, but instead of using the table name
    in the `INSERT` or `UPDATE` statement, we substitute the view name. After we add
    or change data using a view, the change is applied to the underlying table, which
    in this case is `employees`. The view then reflects the change via the query it
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-8](#listing17-8) shows two examples that attempt to add new employee
    records via the `employees_tax_dept` view. The first succeeds, but the second
    fails.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-8: Successful and rejected inserts via the `employees_tax_dept`
    view'
  prefs: []
  type: TYPE_NORMAL
- en: In the first `INSERT` 1, which uses the insert syntax you learned in Chapter
    2, we supply the first and last names of Suzanne Legere plus her `emp_id` and
    `dept_id`. Because the new row will satisfy the `LOCAL CHECK` in the view—it contains
    the same columns and `dept_id` is `1`—the insert succeeds when it executes.
  prefs: []
  type: TYPE_NORMAL
- en: But when we run the second `INSERT` 2 to add an employee named Jamil White using
    a `dept_id` of `2`, the operation fails with the error message `new row violates
    check option for view "employees_tax_dept"`. The reason is that when we created
    the view, we used a `WHERE` clause to return only rows with `dept_id = 1`. The
    `dept_id` of `2` doesn’t pass the `LOCAL CHECK`, so it’s prevented from being
    inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `SELECT` statement 3 on the view to check that Suzanne Legere was successfully
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We also query the `employees` table 4 to see that, in fact, Suzanne Legere was
    added to the full table. The view queries the `employees` table each time we access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the addition of Suzanne Legere, the data we add using a
    view is also added to the underlying table. However, because the view doesn’t
    include the `salary` column, the value in her row is `NULL`. If you attempt to
    insert a salary value using this view, you would receive the error message `column
    "salary" of relation "employees_tax_dept" does not exist`. The reason is that
    even though the `salary` column exists in the underlying `employees` table, it’s
    not referenced in the view. Again, this is one way to limit access to sensitive
    data. Check the links I provided in the note in the section “Using Views to Simplify
    Queries” to learn more about granting permissions to users and adding `WITH (security_barrier)`
    if you plan to take on database administrator responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Rows Using the employees_tax_dept View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The same restrictions on accessing data in an underlying table apply when we
    update data using the `employees_tax_dept` view. [Listing 17-9](#listing17-9)
    shows a standard query to change the spelling of Suzanne’s last name using `UPDATE`
    (as a person with more than one uppercase letter in their last name, I can confirm
    such corrections aren’t unusual).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-9: Updating a row via the `employees_tax_dept` view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and the result from the `SELECT` query should show the updated
    last name, which occurs in the underlying `employees` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Suzanne’s last name is now correctly spelled as Le Gere, not Legere.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to update the name of an employee who’s not in the Tax Department,
    the query fails just as it did when we tried to insert Jamil White in [Listing
    17-8](#listing17-8). Trying to use this view to update the salary of an employee—even
    one in the Tax Department—will also fail. If the view doesn’t reference a column
    in the underlying table, you can’t access that column through the view. Again,
    the fact that updates on views are restricted in this way offers ways to secure
    and hide certain pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Rows Using the employees_tax_dept View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let’s explore how to delete rows using a view. The restrictions on which
    data you can affect apply here as well. For example, if Suzanne Le Gere gets a
    better offer from another firm and decides to leave, you could remove her from
    `employees` through the `employees_tax_dept` view. [Listing 17-10](#listing17-10)
    shows the query in the standard `DELETE` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-10: Deleting a row via the `employees_tax_dept` view'
  prefs: []
  type: TYPE_NORMAL
- en: Run the query, and PostgreSQL should respond with `DELETE 1`. However, when
    you try to delete a row for an employee in a department other than the Tax Department,
    PostgreSQL won’t allow it and will report `DELETE 0`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, views not only give you control over access to data, but also give
    you shortcuts for working with data. Next, let’s explore how to use functions
    to save keystrokes and time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Functions and Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve used functions throughout the book, such as to capitalize letters with
    `upper()` or add numbers with `sum()`. Behind these functions is a significant
    amount of (sometimes complex) programming that executes a series of actions and
    may, depending on the job of the function, return a response. We’ll avoid complicated
    code here, but we’ll build some basic functions that you can use as a launchpad
    for your own ideas. Even simple functions can help you avoid repeating code.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the syntax in this section is specific to PostgreSQL, which supports
    both user-defined functions and *procedures* (the difference between the two is
    subtle, and I’ll give examples of both). You can define functions and procedures
    using plain SQL, but you also can choose from other options. One is a PostgreSQL-specific
    *procedural language* called PL/pgSQL that adds features not found in standard
    SQL, such as logical control structures (`IF ... THEN ... ELSE`). Other options
    include PL/Python and PL/R for the Python and R programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that major database systems including Microsoft SQL Server, Oracle, and
    MySQL implement their own variations of functions and procedures. If you’re using
    another database management system, this section will be useful for understanding
    concepts related to functions, but you’ll need to check your database’s documentation
    for specifics on its implementation of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the percent_change() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function processes data and returns a value. As an example, let’s write a
    function to simplify a staple of data analysis: calculating the percent change
    between two values. In Chapter 6, you learned that we express the percent change
    formula this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Rather than writing that formula each time we need it, we can create a function
    called `percent_change()` that takes the new and old numbers as inputs and returns
    the result rounded to a user-specified number of decimal places. Let’s walk through
    the code in [Listing 17-11](#listing17-11) to see how to declare a simple function
    that uses SQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-11: Creating a `percent_change()` function'
  prefs: []
  type: TYPE_NORMAL
- en: A lot is happening in this code, but it’s not as complicated as it looks. We
    start with the command `CREATE OR REPLACE FUNCTION` 1. As with the syntax to create
    a view, the `OR REPLACE` keywords are optional. We then give the name of the function
    2 and, in parentheses, a list of *arguments* that determine the function’s inputs.
    Each argument will serve as an input to the function and gets a name and data
    type. For example, `new_value` and `old_value` are `numeric` and require that
    the user of the function supply input values matching that type, whereas `decimal_places`
    (which specifies the number of places to round results) is `integer`. For `decimal_places`,
    we specify `1` as the `DEFAULT` 3 value—this makes the argument optional and,
    if it’s omitted by the user, will set the argument to `1` by default.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the keywords `RETURNS numeric AS` 4 to tell the function to return
    its calculation as type `numeric`. If this were a function to concatenate strings,
    we might return `text`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the meat of the function that performs the calculation. Inside
    single quotes, we place a `SELECT` query 5 that includes the percent change calculation
    nested inside a `round()` function. In the formula, we use the function’s argument
    names instead of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We then supply a series of keywords that define the function’s attributes and
    behavior. The `LANGUAGE` 6 keyword specifies that we’ve written this function
    using plain SQL as opposed to one of other languages PostgreSQL supports for creating
    functions. Next, the `IMMUTABLE` keyword 7 indicates that the function cannot
    modify the database and will always return the same result for a given set of
    arguments. The line `RETURNS NULL ON NULL INPUT` 8 guarantees that the function
    will supply a `NULL` response if any input that is not supplied by default is
    a `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code using pgAdmin to create the `percent_change()` function. The server
    should respond with the message `CREATE FUNCTION`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the percent_change() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the new `percent_change()` function, run it by itself using `SELECT`,
    as shown in [Listing 17-12](#listing17-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-12: Testing the `percent_change()` function'
  prefs: []
  type: TYPE_NORMAL
- en: This example uses a value of `110` for the new number, `108` for the old number,
    and `2` as the desired number of decimal places to round the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code; the result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The result tells us there’s a 1.85 percent increase between 108 and 110\. Experiment
    with other numbers to see how the results change. Also, try changing the `decimal_places`
    argument to values including `0`, or omit it, to see how that affects the output.
    You should see results that have more or fewer numbers after the decimal point,
    based on your input.
  prefs: []
  type: TYPE_NORMAL
- en: We created this function to avoid writing the full percent change formula in
    queries. Let’s use it to calculate percent change using a version of the census
    estimates population change query we wrote in Chapter 7, as shown in [Listing
    17-13](#listing17-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-13: Testing `percent_change()` on census data'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-13](#listing17-13) modifies the original query from Chapter 7 to
    add the `percent_change()` function 1 as a column in `SELECT`. We also include
    the explicit percent change formula 2 so we can compare results. As inputs, we
    use the 2019 population estimate column (`c2019.pop_est_2019`) as the new number
    and the 2010 estimates base as the old (`c2010.estimates_base_2010`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query results should display the five counties with the greatest percent
    change in population, and the results from the function should match the results
    from the formula entered directly into the query. Note that each value in the
    `pct_chg_func` column has one decimal place, the function’s default value, because
    we didn’t provide the optional third argument. Here’s the result with both the
    function and the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know the function works as intended, we can use `percent_change()`
    any time we need to solve that calculation—and that’s much faster than writing
    out the formula!
  prefs: []
  type: TYPE_NORMAL
- en: Updating Data with a Procedure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As implemented in PostgreSQL, a *procedure* is a close relative of a function,
    albeit with some significant differences. Both procedures and functions can perform
    data operations that don’t return a value, such as an update. Procedures, on the
    other hand, don’t have a clause to return a value, while functions do. Also, procedures
    can incorporate the transaction commands we covered in Chapter 10 such as `COMMIT`
    and `ROLLBACK`, and functions cannot. Many database managers implement procedures,
    which are sometimes referred to as *stored procedures*. PostgreSQL added procedures
    as of version 11 and are part of the SQL standard, though PostgreSQL syntax is
    not fully compatible.
  prefs: []
  type: TYPE_NORMAL
- en: We can simplify routine updates to data using procedures. In this section, we’ll
    write a procedure that updates a record of the correct number of personal days
    off a teacher gets (in addition to vacation days) based on the time elapsed since
    their hire date.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we’ll return to the `teachers` table from the first lesson
    in Chapter 2. If you skipped “Creating a Table” in that chapter, create the `teachers`
    table and insert the data now using the example code in Listings 2-2 and 2-3.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a column to `teachers` to hold the teachers’ personal days using the
    code in [Listing 17-14](#listing17-14). The new column will be empty until we
    fill it later using a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-14: Adding a column to the `teachers` table and seeing the data'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-14](#listing17-14) updates the teachers table using `ALTER` and
    adds the `personal_days` column using the keywords `ADD COLUMN`. We then run the
    `SELECT` statement to view the data, in which we also include the names and hire
    dates of each teacher. When both queries finish, you should see the following
    six rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `personal_days` column contains only `NULL` values because we haven’t inserted
    anything yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a procedure called `update_personal_days()` that populates
    the `personal_days` column with their earned personal days (in addition to vacation
    days). We’ll use the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Less than 10 years since hire: 3 personal days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10 to less than 15 years since hire: 4 personal days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '15 to less than 20 years since hire: 5 personal days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '20 years to less than 25 years since hire: 6 personal days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25 years or more since hire: 7 personal days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in [Listing 17-15](#listing17-15) creates a procedure. This time, instead
    of using plain SQL, we’ll incorporate elements of the PL/pgSQL procedural language,
    which is an additional language PostgreSQL supports for writing functions. Let’s
    walk through some differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-15: Creating an `update_personal_days()` function'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with `CREATE OR REPLACE PROCEDURE` and give the procedure a name. This
    time, we provide no arguments because no user input is required—the procedure
    operates on predetermined columns with set values for calculating intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Often, when writing PL/pgSQL-based functions, the PostgreSQL convention is to
    use the non-ANSI SQL standard dollar-quote (`$$`) to mark the start 1 and end
    5 of the string that contains all the function’s commands. (As with the `percent_change()`
    SQL function earlier, you could use single quote marks to enclose the string,
    but then any single quotes in the string would need to be doubled, and that not
    only looks messy but can be confusing.) So, everything between the pair of `$$`
    is the code that does the work. You can also add some text between the dollar
    signs, like `$namestring$`, to create a unique pair of beginning and ending quotes.
    This is useful, for example, if you need to quote a query inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: Right after the first `$$` we start a `BEGIN ... END;` 2 block. This is a PL/pgSQL
    convention that delineates the start and end of a section of code within a function
    or procedure; as with dollar quotes, it is possible to nest one `BEGIN ... END;`
    inside another to facilitate logical groupings of code. Inside that block, we
    place an `UPDATE` statement that uses a `CASE` statement 3 to determine the number
    of days each teacher gets. We subtract the `hire_date` from the current date,
    which is retrieved from the server by the `now()` function. Depending on which
    range `now() - hire_date` falls into, the `CASE` statement returns the number
    of personal days corresponding to the range. We use the PL/pgSQL keywords `RAISE
    NOTICE` 4 to display a message that the procedure is done. Finally, we use the
    `LANGUAGE` keyword 6 so the database knows to interpret what we’ve written according
    to the syntax specific to PL/pgSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code in [Listing 17-15](#listing17-15) to create the `update_personal_days()`
    procedure. To invoke the procedure, we use the `CALL` command, which is part of
    the ANSI SQL standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the procedure runs, the server responds with the notice it raises, which
    is `personal_days updated!`.
  prefs: []
  type: TYPE_NORMAL
- en: When you rerun the `SELECT` statement in [Listing 17-14](#listing17-14), you
    should see that each row of the `personal_days` column is filled with the appropriate
    values. Note that results will vary depending on when you run this function, because
    calculations using `now()` change as time passes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You could use the `update_personal_days()` function to regularly update data
    manually after performing certain tasks, or you could use a task scheduler such
    as pgAgent (a separate open source tool) to run it automatically. You can learn
    about pgAgent and other tools in “PostgreSQL Utilities, Tools, and Extensions”
    in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python Language in a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, I mentioned that PL/pgSQL is the default procedural language within
    PostgreSQL, but the database also supports creating functions using open source
    languages, such as Python and R. This support allows you to take advantage of
    features and modules from those languages within functions you create. For example,
    with Python, you can use the `pandas` library for analysis. The documentation
    at [https://www.postgresql.org/docs/current/server-programming.html](https://www.postgresql.org/docs/current/server-programming.html)
    provides a comprehensive review of the languages included with PostgreSQL, but
    here I’ll show you a simple function using Python.
  prefs: []
  type: TYPE_NORMAL
- en: To enable PL/Python, you must create the extension using the code in [Listing
    17-16](#listing17-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-16: Enabling the PL/Python procedural language'
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error, such as `image not found`, that means the PL/Python extension
    is not installed on your system. Depending on the operating system, installation
    of PL/Python typically requires installation of Python and additional configuration
    beyond the basic PostgreSQL install. For this, refer to the installation instructions
    for your operating system in Chapter 1.
  prefs: []
  type: TYPE_NORMAL
- en: After enabling the extension, we can create a function using syntax similar
    to the examples you’ve tried so far, but using Python for the body of the function.
    [Listing 17-17](#listing17-17) shows how to use PL/Python to create a function
    called `trim_county()` that removes the word *County* from the end of a string.
    We’ll use this function to clean up names of counties in the census data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-17: Using PL/Python to create the `trim_county()` function'
  prefs: []
  type: TYPE_NORMAL
- en: The structure should look familiar. After naming the function and its text input,
    we use the `RETURNS` keyword 1 to specify that the function will send text back.
    After the opening `$$` quotes, we get straight to the Python code, starting with
    a statement to import the Python regular expressions module, `re` 2. Even if you
    don’t know much about Python, you can probably deduce that the next two lines
    of code 3 set a variable called `cleaned` to the results of a Python regular expression
    function called `sub()`. That function looks for a space followed by the word
    *County* in the `input_string` passed into the function and substitutes an empty
    string, which is denoted by two apostrophes. Then the function returns the content
    of the variable `cleaned`. To end, we specify `LANGUAGE plpython3u` 4 to note
    we’re writing the function with PL/Python.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code to create the function, and then execute the `SELECT` statement
    in [Listing 17-18](#listing17-18) to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-18: Testing the `trim_county()` function'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `county_name` column in the `us_counties_pop_est_2019` table as
    input to `trim_county()`. That should return these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `trim_county()` function evaluated each value in the `county_name`
    column and removed a space and the word *County* when present. Although this is
    a trivial example, it shows how easy it is to use Python—or one of the other supported
    procedural languages—inside a function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll learn how to use triggers to automate your database.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Database Actions with Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A database *trigger* executes a function whenever a specified event, such as
    an `INSERT`, `UPDATE`, or `DELETE`, occurs on a table or a view. You can set a
    trigger to fire before, after, or instead of the event, and you can also set it
    to fire once for each row affected by the event or just once per operation. For
    example, let’s say you delete 20 rows from a table. You could set the trigger
    to fire once for each of the 20 rows deleted or just one time.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll work through two examples. The first example keeps a log of changes made
    to grades at a school. The second automatically classifies temperatures each time
    we collect a reading.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Grade Updates to a Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we want to automatically track changes made to a student `grades`
    table in our school’s database. Every time a row is updated, we want to record
    the old and new grade plus the time the change occurred (search online for *David
    Lightman and grades* and you’ll see why this might be worth tracking). To handle
    this task automatically, we’ll need three items:'
  prefs: []
  type: TYPE_NORMAL
- en: A `grades_history` table to record the changes to grades in a `grades` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigger to run a function every time a change occurs in the `grades` table,
    which we’ll name `grades_update`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function the trigger will execute, which we’ll call `record_if_grade_changed()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Tables to Track Grades and Updates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by making the tables we need. [Listing 17-19](#listing17-19) includes
    the code to first create and fill `grades` and then create `grades_history`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-19: Creating the `grades` and `grades_history` tables'
  prefs: []
  type: TYPE_NORMAL
- en: These commands are straightforward. We use `CREATE` to make a `grades` table
    1 and add four rows using `INSERT` 2, where each row represents a student’s grade
    in a class. Then we use `CREATE TABLE` to make the `grades_history` table 3 to
    hold the data we log each time an existing grade is altered. The `grades_history`
    table has columns for the new grade, old grade, and the time of the change. Run
    the code to create the tables and fill the `grades` table. We insert no data into
    `grades_history` here because the trigger process will handle that task.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Function and Trigger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s write the `record_if_grade_changed()` function that the trigger
    will execute (note that the PostgreSQL documentation refers to such functions
    as *trigger procedures*). We must write the function before naming it in the trigger.
    Let’s go through the code in [Listing 17-20](#listing17-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-20: Creating the `record_if_grade_changed()` function'
  prefs: []
  type: TYPE_NORMAL
- en: The `record_if_grade_changed()` function follows the pattern of earlier examples
    but with differences specific to working with triggers. First, we specify `RETURNS
    trigger` 1 instead of a data type. We use dollar-quotes to delineate the code
    portion of the function, and because `record_if_grade_changed()` is a PL/pgSQL
    function, we also place the code to execute inside a `BEGIN ... END;` block. Next,
    we start the procedure using an `IF ... THEN` statement 2, which is one of the
    control structures PL/pgSQL provides. We use it here to run the `INSERT` statement
    only if the updated grade is different from the old grade, which we check using
    the `<>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: When a change occurs to the `grades` table, the trigger (which we’ll create
    next) will execute. For each row that’s changed, the trigger will pass two collections
    of data into `record_if_grade_changed()`. The first is the row values *before*
    they were changed, noted with the prefix `OLD`. The second is the row values *after*
    they were changed, noted with the prefix `NEW`. The function can access the original
    row values and the updated row values, which it will use for a comparison. If
    the `IF ... THEN` statement evaluates as `true`, indicating that the old and new
    `grade` values are different, we use `INSERT` to add a row to `grades_history`
    that contains both `OLD.grade` 3 and `NEW.grade` 4. Finally, we include a `RETURN`
    statement 5 with a value of `NULL`; the trigger procedure performs a database
    `INSERT`, so we do not need a value returned.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code in [Listing 17-20](#listing17-20) to create the function. Then,
    add the `grades_update` trigger to the `grades` table using [Listing 17-21](#listing17-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-21: Creating the `grades_update` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: In PostgreSQL, the syntax for creating a trigger follows the ANSI SQL standard
    (although not all aspects of the standard are supported, per the documentation
    at [https://www.postgresql.org/docs/current/sql-createtrigger.html](https://www.postgresql.org/docs/current/sql-createtrigger.html)).
    The code begins with a `CREATE TRIGGER` 1 statement, followed by clauses that
    control when the trigger runs and how it behaves. We use `AFTER UPDATE` 2 to specify
    that we want the trigger to fire after the update occurs on the `grades` row.
    We could also use the `BEFORE` or `INSTEAD OF` keywords depending on the need.
  prefs: []
  type: TYPE_NORMAL
- en: We write `FOR EACH ROW` 3 to tell the trigger to execute the procedure once
    for each row updated in the table. For example, if someone runs an update that
    affects three rows, the procedure will run three times. The alternate (and default)
    is `FOR EACH STATEMENT`, which runs the procedure once. If we didn’t care about
    capturing changes to each row and simply wanted to record that grades were changed
    at a certain time, we could use that option. Finally, we use `EXECUTE PROCEDURE`
    4 to name `record_if_grade_changed()` as the function the trigger should run.
  prefs: []
  type: TYPE_NORMAL
- en: Create the trigger by running the code in [Listing 17-21](#listing17-21) in
    pgAdmin. The database should respond with the message `CREATE TRIGGER`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Trigger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve created the trigger and the function, it should run when data
    in the `grades` table changes; let’s see what the process does. First, let’s check
    the current status of our data. When you run `SELECT * FROM grades_history;`,
    you’ll see that the table is empty because we haven’t made any changes to the
    `grades` table yet and there’s nothing to track. Next, when you run `SELECT *
    FROM grades ORDER BY student_id, course_id;`, you should see the grade data that
    you inserted in [Listing 17-19](#listing17-19), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That Biology 2 grade doesn’t look very good. Let’s update it using the code
    in [Listing 17-22](#listing17-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-22: Testing the `grades_update` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `UPDATE`, pgAdmin doesn’t display anything to let you know
    that the trigger executed in the background. It just reports `UPDATE 1`, meaning
    a row was updated. But our trigger did run, which we can confirm by examining
    columns in `grades_history` using this `SELECT` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this query, you should see that the `grades_history` table, which
    contains all changes to grades, now has one row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This row displays the old Biology 2 grade of `F`, the new value `C`, and `change_time`,
    showing the time of update (your result should reflect your date and time). Note
    that the addition of this row to `grades_history` happened in the background without
    the knowledge of the person making the update. But the `UPDATE` event on the table
    caused the trigger to fire, which executed the `record_if_grade_changed()` function.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever used a content management system, such as WordPress or Drupal,
    this sort of revision tracking might be familiar. It provides a helpful record
    of changes made to content for reference, auditing, and, unfortunately, occasional
    finger-pointing. Regardless, the ability to trigger actions on a database automatically
    gives you more control over your data.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Classifying Temperatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 13, we used the SQL `CASE` statement to reclassify temperature readings
    into descriptive categories. The `CASE` statement is also part of the PL/pgSQL
    procedural language, and we can use its capability to assign values to variables
    to automatically store those category names in a table each time we add a temperature
    reading. If we’re routinely collecting temperature readings, using this technique
    to automate the classification spares us from having to handle the task manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow the same steps we used for logging the grade changes: we first
    create a function to classify the temperatures and then create a trigger to run
    the function each time the table is updated. Use [Listing 17-23](#listing17-23)
    to create a `temperature_test` table for the exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-23: Creating a `temperature_test` table'
  prefs: []
  type: TYPE_NORMAL
- en: The `temperature_test` table contains columns to hold the name of the station
    and date of the temperature observation. Let’s imagine that we have some process
    to insert a row once a day that provides the maximum and minimum temperature for
    that location, and we need to fill the `max_temp_group` column with a descriptive
    classification of the day’s high reading to provide text to a weather forecast
    we’re distributing.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we first make a function called `classify_max_temp()`, as shown
    in [Listing 17-24](#listing17-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-24: Creating the `classify_max_temp()` function'
  prefs: []
  type: TYPE_NORMAL
- en: By now, these functions should look familiar. What’s new here is the PL/pgSQL
    version of the `CASE` syntax 1, which differs slightly from the SQL syntax. The
    PL/pgSQL syntax includes a semicolon after each `WHEN ... THEN` clause. Also new
    is the *assignment operator* `:=`, which we use to assign the descriptive name
    to the `NEW.max_temp_group` column based on the outcome of the `CASE` function.
    For example, the statement `NEW.max_temp_group := 'Cold'` assigns the string `'Cold'`
    to `NEW.max_temp_group` when the temperature value is greater than or equal to
    33 degrees but less than 50 degrees Fahrenheit. When the function returns the
    `NEW` row to be inserted in the table, it will include the string value `Cold`.
    Run the code to create the function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, using the code in [Listing 17-25](#listing17-25), create a trigger to
    execute the function each time a row is added to `temperature_test`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-25: Creating the `temperature_insert` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we classify `max_temp` and create a value for `max_temp_group`
    prior to inserting the row into the table. Doing so is more efficient than performing
    a separate update after the row is inserted. To specify that behavior, we set
    the `temperature_insert` trigger to fire `BEFORE INSERT` 1.
  prefs: []
  type: TYPE_NORMAL
- en: We also want the trigger to fire `FOR EACH ROW` 2 because we want each `max_temp`
    recorded in the table to get a descriptive classification. The final `EXECUTE
    PROCEDURE` statement names the `classify_max_temp()` function 3 we just created.
    Run the `CREATE TRIGGER` statement in pgAdmin, and then test the setup using [Listing
    17-26](#listing17-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-26: Inserting rows to test the `temperature_insert` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we insert five rows into `temperature_test`, and we expect the `temperature_insert`
    trigger to fire for each row—and it does! The `SELECT` statement in the listing
    should display these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the trigger and function, each `max_temp` inserted automatically receives
    the appropriate classification in the `max_temp_group` column—including the instance
    where we had no reading for that value. Note that the trigger’s update of the
    column will override any user-supplied values during insert.
  prefs: []
  type: TYPE_NORMAL
- en: This temperature example and the earlier grade-change auditing example are rudimentary,
    but they give you a glimpse of how useful triggers and functions can be in simplifying
    data maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the techniques you learned in this chapter begin to merge with those
    of a database administrator, you can apply the concepts to reduce the amount of
    time you spend repeating certain tasks. I hope these approaches will help you
    free up more time to find interesting stories in your data.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes our discussion of analysis techniques and the SQL language.
    The next two chapters offer workflow tips to help you increase your command of
    PostgreSQL. They include how to connect to a database and run queries from your
    computer’s command line and how to maintain your database.
  prefs: []
  type: TYPE_NORMAL
