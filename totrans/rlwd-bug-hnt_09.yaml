- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL INJECTION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When a vulnerability on a database-backed site allows an attacker to query
    or attack the site’s database using *SQL (Structured Query Language)*, it is known
    as a *SQL injection (SQLi)*. Often, SQLi attacks are highly rewarded because they
    can be devastating: attackers can manipulate or extract information or even create
    an administrator login for themselves in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Databases**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Databases store information in records and fields contained in a collection
    of tables. Tables contain one or more columns, and a row in a table represents
    a record in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Users rely on SQL to create, read, update, and delete records in a database.
    The user sends SQL commands (statements or queries) to the database, and—assuming
    the commands are accepted—the database interprets the statements and performs
    some action. Popular SQL databases include MySQL, PostgreSQL, MSSQL, and so on.
    In this chapter, we’ll use MySQL, but the general concepts apply to all SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: SQL statements are made up of keywords and functions. For example, the following
    statement tells the database to select information from the `name` column in the
    `users` table for records where the ID column is equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Many websites rely on databases to store information and use that information
    to dynamically generate content. For example, if the site *https://www.<example>.com/*
    stored your previous orders in a database that you accessed when you logged in
    with your account, your web browser would query the site’s database and generate
    HTML based on the information returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a theoretical example of a server’s PHP code to generate a
    MySQL command after a user visits *https://www.<example>.com?name=peter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code uses `$_GET[]` ➊ to access the name value from the URL parameters specified
    between its brackets and stores the value in the `$name` variable. Then the parameter
    is passed to the `$query` variable ➋ without any sanitization. The `$query` variable
    represents the query to execute and fetches all data from the `users` table where
    the `name` column matches the value in the `name` URL parameter. The query executes
    by passing the `$query` variable to the PHP function `mysql_query` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'The site expects `name` to contain regular text. But if a user enters the malicious
    input `test'' OR 1=''1` into the URL parameter, such as `https://www`.example`.com?name=test''
    OR 1=''1`, the executed query is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The malicious input closes the opening single quote (`'`) after the value `test`
    ➊ and adds the SQL code `OR 1='1` to the end of the query. The hanging single
    quote in `OR 1='1` opens the closing single quote that is hardcoded after ➋. If
    the injected query didn’t include an opening single quote, the hanging quote would
    cause SQL syntax errors, which would prevent the query from executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL uses the conditional operators `AND` and `OR`. In this case, the SQLi modifies
    the `WHERE` clause to search for records where the `name` column matches `test`
    or the equation `1=''1''` returns `true`. MySQL helpfully treats `''1''` as an
    integer, and because `1` always equals `1`, the condition is `true` and the query
    returns all records in the `users` table. But injecting `test'' OR 1=''1` won’t
    work when other parts of the query are sanitized. For example, you might use a
    query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `password` parameter is also user controlled but properly
    sanitized ➊. If you used the same payload, `test'' OR 1=''1`, as the name and
    if your password was 12345, your statement would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The query looks for all records where the `name` is `test` or `1='1'` and the
    `password` is `12345` (we’ll ignore the fact that this database stores plaintext
    passwords, which is another vulnerability). Because the password check uses an
    `AND` operator, this query won’t return data unless a record’s password is `12345`.
    Although this breaks our attempted SQLi, it doesn’t stop us from trying another
    attack method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to eliminate the `password` parameter, which we can do by adding `;--,
    test'' OR 1=''1;--`. This injection accomplishes two tasks: the semicolon (`;`)
    ends the SQL statement, and the two dashes (`--`) tell the database that the remainder
    of the text is a comment. This injected parameter changes the query to `SELECT
    * FROM users WHERE name = ''test'' OR 1=''1'';`. The `AND password = ''12345''`
    code in the statement becomes a comment, so the command returns all records from
    the table. When you’re using `--` as a comment, keep in mind that MySQL requires
    a space after the dashes and the remaining query. Otherwise, MySQL will return
    errors without executing the command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Countermeasures Against SQLi**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One protection available to prevent SQLi is the use of *prepared statements*,
    which are a database feature that executes repeated queries. The specific details
    of prepared statements are beyond the scope of this book, but they protect against
    SQLi because queries are no longer executed dynamically. The database uses the
    queries like templates by having placeholders for variables. As a result, even
    when users pass unsanitized data to a query, the injection can’t modify the database’s
    query template, thus preventing SQLi.
  prefs: []
  type: TYPE_NORMAL
- en: Web frameworks, such as Ruby on Rails, Django, Symphony, and so on, also offer
    built-in protections to help prevent SQLi. But they aren’t perfect and can’t prevent
    the vulnerability everywhere. The two simple examples of SQLi you’ve just seen
    usually won’t work on sites built with frameworks unless the site developers didn’t
    follow best practices or didn’t recognize that protections weren’t automatically
    provided. For example, the site *[https://rails-sqli.org/](https://rails-sqli.org/)*
    maintains a list of common SQLi patterns in Rails that result from developer mistakes.
    When testing for SQLi vulnerabilities, your best bet is to look for older websites
    that look custom built or use web frameworks and content management systems that
    don’t have all the built-in protections of current systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Yahoo! Sports Blind SQLi**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://sports.yahoo.com](https://sports.yahoo.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** February 16, 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $3,705'
  prefs: []
  type: TYPE_NORMAL
- en: A *blind SQLi* vulnerability occurs when you can inject SQL statements into
    a query but can’t get a query’s direct output. The key to exploiting blind injections
    is to infer information by comparing the results of unmodified and modified queries.
    For example, in February 2014, Stefano Vettorazzi found a blind SQLi when testing
    the Yahoo! sports subdomain. The page took parameters through its URL, queried
    a database for information, and returned a list of NFL players based on the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vettorazzi changed the following URL, which returned the NFL players in 2010,
    from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[sports.yahoo.com/nfl/draft?year=2010&type=20&round=2](http://sports.yahoo.com/nfl/draft?year=2010&type=20&round=2)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[sports.yahoo.com/nfl/draft?year=2010--&type=20&round=2](http://sports.yahoo.com/nfl/draft?year=2010--&type=20&round=2)*'
  prefs: []
  type: TYPE_NORMAL
- en: Vettorazzi added two dashes (`--`) to the `year` parameter in the second URL.
    [Figure 9-1](ch09.xhtml#ch09fig01) shows what the page looked like in Yahoo! before
    Vettorazzi added the two dashes. [Figure 9-2](ch09.xhtml#ch09fig02) shows the
    result after Vettorazzi added the dashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The players returned in [Figure 9-1](ch09.xhtml#ch09fig01) are different from
    those returned in [Figure 9-2](ch09.xhtml#ch09fig02). We can’t see the actual
    query because the code is on the backend of the website. But the original query
    likely passed each URL parameter to a SQL query that looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding two dashes to the `year` parameter, Vettorazzi would have altered
    the query to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Yahoo! player search results with an unmodified year parameter*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: Yahoo! player search results with a modified year parameter including
    --*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This Yahoo! bug is slightly unusual because queries must end with a semicolon
    in most, if not all, databases. Because Vettorazzi only injected two dashes and
    commented out the query’s semicolon, this query should fail and either return
    an error or no records. Some databases can accommodate queries without semicolons,
    so Yahoo! was either using this functionality or its code accommodated the error
    in some other way. Regardless, after Vettorazzi recognized the different results
    the queries returned, he tried to infer the database version the site was using
    by submitting the following code as the `year` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The MySQL database `version()` function returns the current version of the MySQL
    database in use. The `mid` function returns part of the string passed to its first
    parameter according to its second and third parameters. The second argument specifies
    the starting position of the substring that the function will return, and the
    third argument specifies the length of the substring. Vettorazzi checked whether
    the site used MySQL by calling `version()`. Then he tried to get the first digit
    in the version number by passing the `mid` function `1` as its first argument
    for the starting position and `1` as its second argument for the substring length.
    The code checks the first digit of the MySQL version using an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement takes three arguments: a logical check, the action to perform
    if the check is true, and the action to perform if the check is false. In this
    case, the code checks whether the first digit from `version` is `5`; if so, the
    query returns `true`. If not, the query returns `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then Vettorazzi connected the true/false output with the `year` parameter using
    the `and` operator, so if the major version of the MySQL database was 5, players
    in the year 2010 would be returned on the Yahoo! web page. The query works this
    way because the condition `2010 and true` would be `true`, whereas `2010 and false`
    would be `false` and return no records. Vettorazzi executed the query and received
    no records, as shown in [Figure 9-3](ch09.xhtml#ch09fig03), meaning the first
    digit of the value returned from `version` wasn’t `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: Yahoo! player search results were empty when the code checked
    whether the database version started with the number 5.*'
  prefs: []
  type: TYPE_NORMAL
- en: This bug is a blind SQLi because Vettorazzi couldn’t inject his query and see
    the output directly on the page. But Vettorazzi could still find information about
    the site. By inserting Boolean checks, such as the version-checking `if` statement,
    Vettorazzi could infer the information he needed. He could have continued to extract
    information from the Yahoo! database. But finding information about the MySQL
    version through his test query was enough to confirm to Yahoo! that the vulnerability
    existed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SQLi vulnerabilities, like other injection vulnerabilities, aren’t always difficult
    to exploit. One way to find a SQLi vulnerability is to test URL parameters and
    look for subtle changes to query results. In this case, adding the double dash
    changed the results of Vettorazzi’s baseline query, revealing the SQLi.
  prefs: []
  type: TYPE_NORMAL
- en: '**Uber Blind SQLi**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *http://sctrack.email.uber.com.cn/track/unsubscribe.do/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/150156/](https://hackerone.com/reports/150156/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** July 8, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $4,000'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to web pages, you can find blind SQLi vulnerabilities in other
    places, such as email links. In July 2016, Orange Tsai received an email advertisement
    from Uber. He noticed that the unsubscribe link included a base64-encoded string
    as a URL parameter. The link looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decoding the `p` parameter value `eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9`
    using base64 returns the JSON string `{"user_id": "5755", "receiver": "orange@mymail"}`.
    To the decoded string, Orange added the code `and sleep(12) = 1` to the encoded
    `p` URL parameter. This harmless addition makes the database take longer to respond
    to the unsubscribe action `{"user_id": "5755 and sleep(12)=1", "receiver": "orange@mymail"}`.
    If a site is vulnerable, the query execution evaluates `sleep(12)` and performs
    no action for 12 seconds before comparing the output of the `sleep` command to
    `1`. In MySQL, the `sleep` command normally returns 0, so this comparison will
    fail. But it doesn’t matter because the execution will take at least 12 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: After Orange reencoded the modified payload and passed the payload to the URL
    parameter, he visited the unsubscribe link to confirm that the HTTP response took
    at least 12 seconds. Realizing he needed more concrete proof of the SQLi to send
    to Uber, he dumped the user name, host name, and database name using brute force.
    By doing so, he demonstrated that he could extract information from the SQLi vulnerability
    without accessing confidential data.
  prefs: []
  type: TYPE_NORMAL
- en: A SQL function called `user` returns the user name and host name of a database
    in the form *<user>*@*<host>*. Because Orange couldn’t access output from his
    injected queries, he couldn’t call `user`. Instead, Orange modified his query
    to add a conditional check when the query looked up his user ID, comparing one
    character of the database’s user name and host name string at a time using the
    `mid` function. Similar to the Yahoo! Sports blind SQLi vulnerability in the previous
    bug report, Orange used a comparison statement and brute force to derive each
    character of the user name and host name string.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Orange took the first character of the value returned from the
    `user` function using the `mid` function. Then he compared whether the character
    was equal to `'a'`, then `'b'`, then `'c'`, and so on. If the comparison statement
    was true, the server would execute the unsubscribe command. This result indicated
    that the first character of the `user` function’s return value was equal to the
    character it was being compared to. If the statement was false, the server would
    not try to unsubscribe Orange. By checking each character of the `user` function’s
    return value using this method, Orange could eventually derive the entire user
    name and host name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually brute-forcing a string takes time, so Orange created a Python script
    that generated and submitted payloads to Uber on his behalf, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Python script begins with five lines of `import` statements ➊ that retrieve
    the libraries Orange needed to process HTTP requests, JSON, and string encodings.
  prefs: []
  type: TYPE_NORMAL
- en: A database user name and host name can be made up of any combination of uppercase
    letters, lowercase letters, numbers, hyphens (`-`), underscores (`_`), at symbols
    (`@`), or periods (`.`). At ➋, Orange creates the `base` variable to hold these
    characters. The code at ➌ creates a variable to hold the payload that the script
    sends to the server. The line of code at ➏ is the injection, which uses the `for`
    loops at ➍ and ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the code at ➏ in detail. Orange references his user ID, 5755,
    with the string `user_id` as defined at ➌ to create his payloads. He uses the
    `mid` function and string processing to construct a payload similar to the Yahoo!
    bug earlier in this chapter. The `%d` and `%c` in the payload are string replacement
    placeholders. The `%d` is data that represents a digit, and the `%c` is character
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The payload string starts at the first pair of double quotes (`"`) and ends
    at the second pair of double quotes before the third percent symbol at ➏. The
    third percent symbol tells Python to replace the `%d` and `%c` placeholders with
    the values following the percent symbol in the parentheses. So the code replaces
    `%d` with `l+1` (the variable `l` plus the number `1`) and `%c` with the variable
    `i`. The hash mark (`#`) is another way of commenting in MySQL and renders any
    part of the query following Orange’s injection into a comment.
  prefs: []
  type: TYPE_NORMAL
- en: The `l` and `i` variables are the loop iterators at ➍ and ➎. The first time
    the code enters `l in range (0,30)` at ➍, `l` will be `0`. The value of `l` is
    the position in the user name and host name string returned by the `user` function
    that the script is trying to brute-force. Once the script has a position in the
    user name and host name string it’s testing, the code enters a nested loop at
    ➎ that iterates over each character in the `base` string. The first time the script
    iterates through both loops, `l` will be `0` and `i` will be `a`. These values
    are passed to the `mid` function at ➏ to create the payload `"5755 and mid(user(),0,1)='a'#"`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration of the nested `for` loop, the value of `l` will still
    be `0` and `i` will be `b` to create the payload `"5755 and mid(user(),0,1)='b'#"`.
    The position `l` will remain constant as the loop iterates though each character
    in `base` to create the payload at ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a new payload is created, the code following ➐ converts the payload
    to JSON, reencodes the string using the `base64encode` function, and sends the
    HTTP request to the server. The code at ➑ checks whether the server responds with
    a message. If the character in `i` matches the user name substring at the position
    being tested, the script stops testing characters at that position and moves to
    the next position in the `user` string. The nested loop breaks and returns to
    the loop at ➍, which increments `l` by `1` to test the next position of the user
    name string.
  prefs: []
  type: TYPE_NORMAL
- en: This proof of concept allowed Orange to confirm that the database user name
    and host name were `sendcloud_w@10.9.79.210` and the database name was `sendcloud`
    (to obtain the database name, replace `user` with `database` at ➏). In response
    to the report, Uber confirmed that the SQLi hadn’t occurred on its server. The
    injection occurred on a third-party server that Uber was using, but Uber still
    paid a reward. Not all bounty programs will do the same. Uber likely paid a bounty
    because the exploit would allow an attacker to dump all of Uber’s customer email
    addresses from the `sendcloud` database.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can write your own scripts as Orange did to dump database information
    from a vulnerable website, you can also use automated tools. [Appendix A](app01.xhtml#app01)
    includes information about one such tool called sqlmap.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keep an eye out for HTTP requests that accept encoded parameters. After you
    decode and inject your query into a request, be sure to reencode your payload
    so everything still matches the encoding the server expects.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a database name, user name, and host name is generally harmless,
    but be sure it’s within the permitted actions of the bounty program you’re working
    in. In some cases, the `sleep` command is enough for a proof of concept.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drupal SQLi**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Hard'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** Any Drupal site using version 7.32 or earlier'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/31756/](https://hackerone.com/reports/31756/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** October 17, 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $3,000'
  prefs: []
  type: TYPE_NORMAL
- en: '*Drupal* is a popular open source content management system for building websites,
    similar to Joomla! and WordPress. It’s written in PHP and is *modular*, meaning
    you can install new functionality in units to a Drupal site. Every Drupal install
    contains *Drupal core*, which is a set of modules that runs the platform. These
    core modules require a connection to a database, such as MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Drupal released an urgent security update to Drupal core because all
    Drupal sites were vulnerable to a SQLi vulnerability that could easily be abused
    by anonymous users. The impact of the vulnerability would allow an attacker to
    take over any unpatched Drupal site. Stefan Horst discovered the vulnerability
    when he noticed a bug in Drupal core’s prepared statement functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The Drupal vulnerability occurred in Drupal’s database application programming
    interface (API). The Drupal API uses the PHP Data Objects (PDO) extension, which
    is an *interface* for accessing databases in PHP. An interface is a programming
    concept that guarantees inputs and outputs of a function without defining how
    the function is implemented. In other words, PDO hides the differences between
    databases so programmers can use the same functions to query and fetch data regardless
    of the database type. PDO includes support for prepared statements.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal created a database API to use the PDO functionality. The API creates
    a Drupal database abstraction layer so developers never have to query the database
    directly with their own code. But they can still use prepared statements and use
    their code with any database type. The specifics of the API are beyond the scope
    of this book. But you need to know that the API will generate the SQL statements
    to query the database and has built-in security checks to prevent SQLi vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that prepared statements prevent SQLi vulnerabilities because an attacker
    can’t modify the query structure with malicious input, even if the input is unsanitized.
    But prepared statements can’t protect against SQLi vulnerabilities if the injection
    occurs when the template is being created. If an attacker can inject malicious
    input during the template creation process, they can create their own malicious
    prepared statement. The vulnerability Horst discovered occurred because of SQL’s
    `IN` clause, which looks for values that exist in a list of values. For example,
    the code `SELECT * FROM users WHERE name IN ('peter', 'paul', 'ringo');` selects
    the data from the `users` table where the value in the `name` column is `peter`,
    `paul`, or `ringo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why the `IN` clause is vulnerable, let’s look at the code behind
    Drupal’s API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expandArguments` function is responsible for building queries that use
    the `IN` clause. After `expandArguments` builds queries, it passes them to `prepareQuery`,
    which builds the prepared statements that the `execute` function executes. To
    understand the significance of this process, let’s look at the relevant code for
    `expandArguments` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This PHP code uses arrays. PHP can use associative arrays, which explicitly
    define keys as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The keys in this array are `'red'` and `'yellow'`, and the array’s values are
    the fruits to the right of the arrow (`=>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, PHP can use a *structured array*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A structured array’s keys are implicit and based on the position of the value
    in the list. For example, the key for `'apple'` is `0` and the key for `'banana'`
    is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `foreach` PHP function iterates over an array and can separate the array
    key from its value. It can also assign each key and each value to its own variable
    and pass them to a block of code for processing. At ➊, `foreach` takes each element
    of an array and verifies the value passed to it is an array by calling `array_filter($args,
    'is_array')`. After the statement confirms it has an array value, it assigns each
    of the array’s keys to `$key` and each of the values to `$data` for each iteration
    of the `foreach` loop. The code will modify the values in the array to create
    placeholders, so the code at ➋ initializes a new empty array to later hold the
    placeholder values.
  prefs: []
  type: TYPE_NORMAL
- en: To create the placeholders, the code at ➌ iterates through the `$data` array
    by assigning each key to `$i` and each value to `$value`. Then at ➍, the `new_keys`
    array initialized at ➋ holds the first array’s key concatenated with the key at
    ➌. The code’s intended outcome is to create data placeholders that look like `name_0`,
    `name_1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what a typical query would look like using Drupal’s `db_query` function,
    which queries a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `db_query` function takes two parameters: a query that contains named placeholders
    for variables and an array of values to substitute for those placeholders. In
    this example, the placeholder is `:name` and is an array with the values `''user1''`
    and `''user2''`. In a structured array, the key for `''user1''` is `0` and the
    key for `''user2''` is `1`. When Drupal executes the `db_query` function, it calls
    the `expandArguments` function, which concatenates the keys to each value. The
    resulting query uses `name_0` and `name_1` in place of the keys, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But the problem arises when you call `db_query` using an associative array,
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `:name` is an array and its keys are `''test);--''` and `''test''`.
    When `expandArguments` receives the `:name` array and processes it to create the
    query, it generates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve injected a comment into the prepared statement. The reason this occurs
    is that `expandArguments` iterates through each array element to build placeholders
    but assumes it’s passed a structured array. In the first iteration, `$i` is assigned
    `'test);--'` and `$value` is assigned `'user1'`. The `$key` is `':name'` and combining
    that with `$i` results in `name_test);--`. In the second iteration, `$i` is assigned
    `'test'` and `$value` is `'user2'`. Combining `$key` with `$i` results in the
    value `name_test`.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior allows malicious users to inject SQL statements into Drupal queries
    that rely on the `IN` clause. The vulnerability affects Drupal login functionality,
    making the SQLi vulnerability severe because any site user, including an anonymous
    user, could exploit it. Making matters worse, PHP PDO supports the ability to
    execute multiple queries at once by default. This means an attacker could append
    additional queries to the user login query in order to execute non-`IN` clause
    SQL commands. For example, an attacker could use `INSERT` statements, which insert
    records into a database, to create an administrative user that they could then
    use to log in to the website.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This SQLi vulnerability wasn’t simply a matter of submitting a single quote
    and breaking a query. Rather, it required understanding how Drupal core’s database
    API handles the `IN` clause. The takeaway from this vulnerability is to be on
    the lookout for opportunities to alter the structure of input passed to a site.
    When a URL takes `name` as a parameter, try adding `[]` to the parameter to change
    it to an array and test how the site handles it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLi can be a significant vulnerability and dangerous for a site. If an attacker
    finds a SQLi, they might obtain full permissions to a site. In some situations,
    a SQLi vulnerability can be escalated by inserting data into the database that
    enables administrative permissions on the site, as in the Drupal example. When
    you’re looking for SQLi vulnerabilities, explore places where you can pass unescaped
    single or double quotes to a query. When you find a vulnerability, the indications
    that the vulnerability exists can be subtle, such as with blind injections. You
    should also look for places where you can pass data to a site in unexpected ways,
    such as where you can substitute array parameters in request data, as in the Uber
    bug.
  prefs: []
  type: TYPE_NORMAL
