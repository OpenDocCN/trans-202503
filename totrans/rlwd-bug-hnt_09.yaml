- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: SQL INJECTION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL注入**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'When a vulnerability on a database-backed site allows an attacker to query
    or attack the site’s database using *SQL (Structured Query Language)*, it is known
    as a *SQL injection (SQLi)*. Often, SQLi attacks are highly rewarded because they
    can be devastating: attackers can manipulate or extract information or even create
    an administrator login for themselves in the database.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库支持的网站上的漏洞允许攻击者使用*SQL（结构化查询语言）*查询或攻击该站点的数据库时，这种攻击被称为*SQL注入（SQLi）*。通常，SQLi攻击的回报极高，因为它们可能造成严重损害：攻击者可以操纵或提取信息，甚至为自己创建数据库中的管理员登录。
- en: '**SQL Databases**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SQL数据库**'
- en: Databases store information in records and fields contained in a collection
    of tables. Tables contain one or more columns, and a row in a table represents
    a record in the database.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库将信息存储在包含字段的记录中，这些记录位于一组表中。表包含一个或多个列，表中的一行代表数据库中的一条记录。
- en: Users rely on SQL to create, read, update, and delete records in a database.
    The user sends SQL commands (statements or queries) to the database, and—assuming
    the commands are accepted—the database interprets the statements and performs
    some action. Popular SQL databases include MySQL, PostgreSQL, MSSQL, and so on.
    In this chapter, we’ll use MySQL, but the general concepts apply to all SQL databases.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 用户依赖SQL来创建、读取、更新和删除数据库中的记录。用户向数据库发送SQL命令（语句或查询），然后—假设命令被接受—数据库解释语句并执行某些操作。常见的SQL数据库包括MySQL、PostgreSQL、MSSQL等。在本章中，我们将使用MySQL，但这些基本概念适用于所有SQL数据库。
- en: SQL statements are made up of keywords and functions. For example, the following
    statement tells the database to select information from the `name` column in the
    `users` table for records where the ID column is equal to `1`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句由关键字和函数组成。例如，以下语句告诉数据库从`users`表中的`name`列选择信息，条件是`ID`列的值等于`1`。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Many websites rely on databases to store information and use that information
    to dynamically generate content. For example, if the site *https://www.<example>.com/*
    stored your previous orders in a database that you accessed when you logged in
    with your account, your web browser would query the site’s database and generate
    HTML based on the information returned.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站依赖数据库来存储信息，并使用这些信息动态生成内容。例如，如果网站*https://www.<example>.com/*在数据库中存储了你以前的订单，当你使用账户登录时，你的网页浏览器将查询该网站的数据库，并根据返回的信息生成HTML。
- en: 'The following is a theoretical example of a server’s PHP code to generate a
    MySQL command after a user visits *https://www.<example>.com?name=peter*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器PHP代码的理论示例，展示了在用户访问*https://www.<example>.com?name=peter*后生成MySQL命令的过程：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code uses `$_GET[]` ➊ to access the name value from the URL parameters specified
    between its brackets and stores the value in the `$name` variable. Then the parameter
    is passed to the `$query` variable ➋ without any sanitization. The `$query` variable
    represents the query to execute and fetches all data from the `users` table where
    the `name` column matches the value in the `name` URL parameter. The query executes
    by passing the `$query` variable to the PHP function `mysql_query` ➌.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`$_GET[]` ➊来访问URL参数中指定的name值，并将该值存储在`$name`变量中。然后，该参数被传递给`$query`变量 ➋，而没有进行任何清理。`$query`变量表示要执行的查询，并从`users`表中提取所有数据，其中`name`列的值与`name`
    URL参数中的值匹配。查询通过将`$query`变量传递给PHP函数`mysql_query` ➌来执行。
- en: 'The site expects `name` to contain regular text. But if a user enters the malicious
    input `test'' OR 1=''1` into the URL parameter, such as `https://www`.example`.com?name=test''
    OR 1=''1`, the executed query is this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该站点期望`name`包含常规文本。但如果用户在URL参数中输入恶意输入`test' OR 1='1`，例如`https://www.example.com?name=test'
    OR 1='1`，执行的查询将是：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The malicious input closes the opening single quote (`'`) after the value `test`
    ➊ and adds the SQL code `OR 1='1` to the end of the query. The hanging single
    quote in `OR 1='1` opens the closing single quote that is hardcoded after ➋. If
    the injected query didn’t include an opening single quote, the hanging quote would
    cause SQL syntax errors, which would prevent the query from executing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意输入关闭了`test`值后的单引号(`'`) ➊，并在查询末尾添加了SQL代码`OR 1='1`。`OR 1='1`中的悬挂单引号打开了硬编码在➋之后的闭合单引号。如果注入的查询没有包含一个开头的单引号，悬挂的引号将导致SQL语法错误，从而阻止查询的执行。
- en: 'SQL uses the conditional operators `AND` and `OR`. In this case, the SQLi modifies
    the `WHERE` clause to search for records where the `name` column matches `test`
    or the equation `1=''1''` returns `true`. MySQL helpfully treats `''1''` as an
    integer, and because `1` always equals `1`, the condition is `true` and the query
    returns all records in the `users` table. But injecting `test'' OR 1=''1` won’t
    work when other parts of the query are sanitized. For example, you might use a
    query like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQL使用条件操作符`AND`和`OR`。在这种情况下，SQL注入修改了`WHERE`子句，搜索`name`列匹配`test`或等式`1='1'`返回`true`的记录。MySQL很贴心地将`'1'`视为整数，因为`1`总是等于`1`，所以条件为`true`，查询返回`users`表中的所有记录。但当查询的其他部分已被净化时，注入`test'
    OR 1='1`将不起作用。例如，你可能会使用像这样的查询：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, the `password` parameter is also user controlled but properly
    sanitized ➊. If you used the same payload, `test'' OR 1=''1`, as the name and
    if your password was 12345, your statement would look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`password`参数也是由用户控制的，但已正确净化➊。如果你使用相同的有效载荷，`test' OR 1='1`，作为用户名，并且密码为12345，那么你的语句将如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The query looks for all records where the `name` is `test` or `1='1'` and the
    `password` is `12345` (we’ll ignore the fact that this database stores plaintext
    passwords, which is another vulnerability). Because the password check uses an
    `AND` operator, this query won’t return data unless a record’s password is `12345`.
    Although this breaks our attempted SQLi, it doesn’t stop us from trying another
    attack method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询会查找所有记录，其中`name`为`test`或`1='1'`，并且`password`为`12345`（我们将忽略这个数据库存储明文密码的事实，这是另一个漏洞）。因为密码检查使用了`AND`操作符，所以除非某条记录的密码是`12345`，否则该查询不会返回数据。尽管这破坏了我们尝试的SQL注入攻击，但它并没有阻止我们尝试其他攻击方法。
- en: 'We need to eliminate the `password` parameter, which we can do by adding `;--,
    test'' OR 1=''1;--`. This injection accomplishes two tasks: the semicolon (`;`)
    ends the SQL statement, and the two dashes (`--`) tell the database that the remainder
    of the text is a comment. This injected parameter changes the query to `SELECT
    * FROM users WHERE name = ''test'' OR 1=''1'';`. The `AND password = ''12345''`
    code in the statement becomes a comment, so the command returns all records from
    the table. When you’re using `--` as a comment, keep in mind that MySQL requires
    a space after the dashes and the remaining query. Otherwise, MySQL will return
    errors without executing the command.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要消除`password`参数，可以通过添加`;--, test' OR 1='1;--`来实现。这次注入完成了两个任务：分号（`;`）结束了SQL语句，而两个破折号（`--`）告诉数据库后面的文本是注释。这个注入参数将查询更改为`SELECT
    * FROM users WHERE name = 'test' OR 1='1';`。语句中的`AND password = '12345'`部分变成了注释，因此该命令会返回表中的所有记录。当使用`--`作为注释时，请记住，MySQL要求在破折号后和剩余的查询之间有一个空格。否则，MySQL将返回错误并不会执行命令。
- en: '**Countermeasures Against SQLi**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SQL注入防范措施**'
- en: One protection available to prevent SQLi is the use of *prepared statements*,
    which are a database feature that executes repeated queries. The specific details
    of prepared statements are beyond the scope of this book, but they protect against
    SQLi because queries are no longer executed dynamically. The database uses the
    queries like templates by having placeholders for variables. As a result, even
    when users pass unsanitized data to a query, the injection can’t modify the database’s
    query template, thus preventing SQLi.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 防止SQL注入的一种保护措施是使用*预处理语句*，这是一种数据库特性，能够执行重复的查询。预处理语句的具体细节超出了本书的范围，但它们能防止SQL注入，因为查询不再是动态执行的。数据库像模板一样使用查询，并为变量留有占位符。因此，即使用户将未经净化的数据传递给查询，注入也无法修改数据库的查询模板，从而防止SQL注入。
- en: Web frameworks, such as Ruby on Rails, Django, Symphony, and so on, also offer
    built-in protections to help prevent SQLi. But they aren’t perfect and can’t prevent
    the vulnerability everywhere. The two simple examples of SQLi you’ve just seen
    usually won’t work on sites built with frameworks unless the site developers didn’t
    follow best practices or didn’t recognize that protections weren’t automatically
    provided. For example, the site *[https://rails-sqli.org/](https://rails-sqli.org/)*
    maintains a list of common SQLi patterns in Rails that result from developer mistakes.
    When testing for SQLi vulnerabilities, your best bet is to look for older websites
    that look custom built or use web frameworks and content management systems that
    don’t have all the built-in protections of current systems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网络框架，如Ruby on Rails、Django、Symphony等，也提供内置的保护措施来帮助防止SQL注入。但它们并不完美，无法在所有地方防止这种漏洞。你刚刚看到的两个简单的SQL注入示例通常不会在使用框架的网站上生效，除非网站开发人员没有遵循最佳实践或没有意识到保护措施并非自动提供。例如，网站*[https://rails-sqli.org/](https://rails-sqli.org/)*维护了Rails中由开发者错误导致的常见SQL注入模式列表。在测试SQL注入漏洞时，最好的办法是寻找看起来是定制开发的旧网站，或使用没有当前系统内置保护的Web框架和内容管理系统。
- en: '**Yahoo! Sports Blind SQLi**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Yahoo! Sports盲SQL注入**'
- en: '**Difficulty:** Medium'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** *[https://sports.yahoo.com](https://sports.yahoo.com)*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *[https://sports.yahoo.com](https://sports.yahoo.com)*'
- en: '**Source:** N/A'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** 无'
- en: '**Date reported:** February 16, 2014'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2014年2月16日'
- en: '**Bounty paid:** $3,705'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**赏金支付：** $3,705'
- en: A *blind SQLi* vulnerability occurs when you can inject SQL statements into
    a query but can’t get a query’s direct output. The key to exploiting blind injections
    is to infer information by comparing the results of unmodified and modified queries.
    For example, in February 2014, Stefano Vettorazzi found a blind SQLi when testing
    the Yahoo! sports subdomain. The page took parameters through its URL, queried
    a database for information, and returned a list of NFL players based on the parameters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*盲SQL注入*漏洞发生在你能够将SQL语句注入到查询中，但无法获取查询的直接输出时。利用盲注的关键是通过比较未修改和修改过的查询结果来推断信息。例如，在2014年2月，Stefano
    Vettorazzi在测试Yahoo! Sports子域时发现了盲SQL注入。该页面通过URL接收参数，查询数据库以获取信息，并根据参数返回NFL球员的列表。'
- en: 'Vettorazzi changed the following URL, which returned the NFL players in 2010,
    from this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Vettorazzi更改了以下网址，该网址返回了2010年的NFL球员，从这个：
- en: '*[sports.yahoo.com/nfl/draft?year=2010&type=20&round=2](http://sports.yahoo.com/nfl/draft?year=2010&type=20&round=2)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*[sports.yahoo.com/nfl/draft?year=2010&type=20&round=2](http://sports.yahoo.com/nfl/draft?year=2010&type=20&round=2)*'
- en: 'to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 改为如下：
- en: '*[sports.yahoo.com/nfl/draft?year=2010--&type=20&round=2](http://sports.yahoo.com/nfl/draft?year=2010--&type=20&round=2)*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*[sports.yahoo.com/nfl/draft?year=2010--&type=20&round=2](http://sports.yahoo.com/nfl/draft?year=2010--&type=20&round=2)*'
- en: Vettorazzi added two dashes (`--`) to the `year` parameter in the second URL.
    [Figure 9-1](ch09.xhtml#ch09fig01) shows what the page looked like in Yahoo! before
    Vettorazzi added the two dashes. [Figure 9-2](ch09.xhtml#ch09fig02) shows the
    result after Vettorazzi added the dashes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Vettorazzi在第二个网址的`year`参数中添加了两个连字符（`--`）。[图 9-1](ch09.xhtml#ch09fig01)显示了Vettorazzi添加两个连字符之前Yahoo!页面的样子。[图
    9-2](ch09.xhtml#ch09fig02)显示了Vettorazzi添加连字符后的结果。
- en: 'The players returned in [Figure 9-1](ch09.xhtml#ch09fig01) are different from
    those returned in [Figure 9-2](ch09.xhtml#ch09fig02). We can’t see the actual
    query because the code is on the backend of the website. But the original query
    likely passed each URL parameter to a SQL query that looked something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.xhtml#ch09fig01)中返回的球员与[图 9-2](ch09.xhtml#ch09fig02)中返回的不同。我们看不到实际的查询，因为代码在网站的后台。但原始查询很可能将每个URL参数传递给一个SQL查询，查询大致如下：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By adding two dashes to the `year` parameter, Vettorazzi would have altered
    the query to this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`year`参数中添加两个连字符，Vettorazzi将查询改为如下：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](../images/09fig01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Yahoo! player search results with an unmodified year parameter*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：Yahoo!带有未修改年份参数的球员搜索结果*'
- en: '![image](../images/09fig02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig02.jpg)'
- en: '*Figure 9-2: Yahoo! player search results with a modified year parameter including
    --*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：Yahoo!带有修改过的年份参数（包括--）的球员搜索结果*'
- en: 'This Yahoo! bug is slightly unusual because queries must end with a semicolon
    in most, if not all, databases. Because Vettorazzi only injected two dashes and
    commented out the query’s semicolon, this query should fail and either return
    an error or no records. Some databases can accommodate queries without semicolons,
    so Yahoo! was either using this functionality or its code accommodated the error
    in some other way. Regardless, after Vettorazzi recognized the different results
    the queries returned, he tried to infer the database version the site was using
    by submitting the following code as the `year` parameter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Yahoo!的漏洞略显不同，因为大多数（如果不是全部）数据库中的查询必须以分号结束。由于Vettorazzi只注入了两个破折号并将查询的分号注释掉，这个查询应该会失败，并返回错误或者没有记录。一些数据库可以处理没有分号的查询，因此Yahoo!可能在使用这种功能，或者它的代码以其他方式处理了这个错误。无论如何，在Vettorazzi意识到查询返回了不同的结果之后，他尝试通过提交以下代码作为`year`参数来推断该网站使用的数据库版本：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The MySQL database `version()` function returns the current version of the MySQL
    database in use. The `mid` function returns part of the string passed to its first
    parameter according to its second and third parameters. The second argument specifies
    the starting position of the substring that the function will return, and the
    third argument specifies the length of the substring. Vettorazzi checked whether
    the site used MySQL by calling `version()`. Then he tried to get the first digit
    in the version number by passing the `mid` function `1` as its first argument
    for the starting position and `1` as its second argument for the substring length.
    The code checks the first digit of the MySQL version using an `if` statement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库的`version()`函数返回当前使用的MySQL数据库版本。`mid`函数根据其第二和第三个参数返回传递给第一个参数的字符串的一部分。第二个参数指定子字符串的起始位置，第三个参数指定子字符串的长度。Vettorazzi通过调用`version()`函数检查该网站是否使用MySQL。然后，他通过传递`mid`函数的第一个参数为`1`（起始位置）和第二个参数为`1`（子字符串长度）来获取版本号的第一个数字。代码通过`if`语句检查MySQL版本的第一个数字。
- en: 'The `if` statement takes three arguments: a logical check, the action to perform
    if the check is true, and the action to perform if the check is false. In this
    case, the code checks whether the first digit from `version` is `5`; if so, the
    query returns `true`. If not, the query returns `false`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句有三个参数：一个逻辑检查、检查为真时执行的操作，以及检查为假时执行的操作。在这种情况下，代码检查`version`的第一个数字是否为`5`；如果是，查询返回`true`。如果不是，查询返回`false`。'
- en: Then Vettorazzi connected the true/false output with the `year` parameter using
    the `and` operator, so if the major version of the MySQL database was 5, players
    in the year 2010 would be returned on the Yahoo! web page. The query works this
    way because the condition `2010 and true` would be `true`, whereas `2010 and false`
    would be `false` and return no records. Vettorazzi executed the query and received
    no records, as shown in [Figure 9-3](ch09.xhtml#ch09fig03), meaning the first
    digit of the value returned from `version` wasn’t `5`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Vettorazzi将真/假输出与`year`参数通过`and`运算符连接，因此如果MySQL数据库的主版本是5，2010年的玩家将会出现在Yahoo!网页上。这个查询之所以有效，是因为条件`2010
    and true`会返回`true`，而`2010 and false`会返回`false`并且不返回任何记录。Vettorazzi执行查询时没有返回任何记录，如[图9-3](ch09.xhtml#ch09fig03)所示，这意味着`version`返回的值的第一个数字不是`5`。
- en: '![image](../images/09fig03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig03.jpg)'
- en: '*Figure 9-3: Yahoo! player search results were empty when the code checked
    whether the database version started with the number 5.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：当代码检查数据库版本是否以数字5开头时，Yahoo!的玩家搜索结果为空。*'
- en: This bug is a blind SQLi because Vettorazzi couldn’t inject his query and see
    the output directly on the page. But Vettorazzi could still find information about
    the site. By inserting Boolean checks, such as the version-checking `if` statement,
    Vettorazzi could infer the information he needed. He could have continued to extract
    information from the Yahoo! database. But finding information about the MySQL
    version through his test query was enough to confirm to Yahoo! that the vulnerability
    existed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞是一个盲目SQL注入（blind SQLi），因为Vettorazzi不能直接在页面上注入查询并查看输出。但Vettorazzi仍然能够找到有关该站点的信息。通过插入布尔检查，比如版本检查的`if`语句，Vettorazzi可以推断出他需要的信息。他本可以继续从Yahoo!数据库中提取更多信息。但是，通过他的测试查询找到MySQL版本信息已经足够确认Yahoo!存在这个漏洞。
- en: '***Takeaways***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: SQLi vulnerabilities, like other injection vulnerabilities, aren’t always difficult
    to exploit. One way to find a SQLi vulnerability is to test URL parameters and
    look for subtle changes to query results. In this case, adding the double dash
    changed the results of Vettorazzi’s baseline query, revealing the SQLi.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SQLi 漏洞像其他注入漏洞一样，并不总是很难利用。找到 SQLi 漏洞的一种方法是测试 URL 参数并查看查询结果是否有微妙的变化。在本例中，添加双短横线改变了
    Vettorazzi 的基准查询结果，从而暴露了 SQLi 漏洞。
- en: '**Uber Blind SQLi**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Uber Blind SQLi**'
- en: '**Difficulty:** Medium'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** *http://sctrack.email.uber.com.cn/track/unsubscribe.do/*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *http://sctrack.email.uber.com.cn/track/unsubscribe.do/*'
- en: '**Source:** *[https://hackerone.com/reports/150156/](https://hackerone.com/reports/150156/)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://hackerone.com/reports/150156/](https://hackerone.com/reports/150156/)*'
- en: '**Date reported:** July 8, 2016'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年7月8日'
- en: '**Bounty paid:** $4,000'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励金额：** $4,000'
- en: 'In addition to web pages, you can find blind SQLi vulnerabilities in other
    places, such as email links. In July 2016, Orange Tsai received an email advertisement
    from Uber. He noticed that the unsubscribe link included a base64-encoded string
    as a URL parameter. The link looked like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网页外，你还可以在其他地方发现盲 SQLi 漏洞，比如电子邮件链接。2016年7月，Orange Tsai 收到了来自 Uber 的一封电子邮件广告。他注意到取消订阅链接中包含了一个
    base64 编码的字符串作为 URL 参数。链接看起来像这样：
- en: '*http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9*'
- en: 'Decoding the `p` parameter value `eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9`
    using base64 returns the JSON string `{"user_id": "5755", "receiver": "orange@mymail"}`.
    To the decoded string, Orange added the code `and sleep(12) = 1` to the encoded
    `p` URL parameter. This harmless addition makes the database take longer to respond
    to the unsubscribe action `{"user_id": "5755 and sleep(12)=1", "receiver": "orange@mymail"}`.
    If a site is vulnerable, the query execution evaluates `sleep(12)` and performs
    no action for 12 seconds before comparing the output of the `sleep` command to
    `1`. In MySQL, the `sleep` command normally returns 0, so this comparison will
    fail. But it doesn’t matter because the execution will take at least 12 seconds.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '解码 `p` 参数值 `eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9`
    使用 base64 返回的 JSON 字符串是 `{"user_id": "5755", "receiver": "orange@mymail"}`。对于解码后的字符串，Orange
    在编码后的 `p` URL 参数中添加了代码 `and sleep(12) = 1`。这个无害的附加代码使得数据库响应取消订阅操作的时间延长至12秒 `{"user_id":
    "5755 and sleep(12)=1", "receiver": "orange@mymail"}`。如果网站存在漏洞，查询执行会评估 `sleep(12)`，并且在比较
    `sleep` 命令的输出与 `1` 之前，执行会暂停12秒。在 MySQL 中，`sleep` 命令通常返回0，因此这个比较会失败。但这并不重要，因为执行将至少延迟12秒。'
- en: After Orange reencoded the modified payload and passed the payload to the URL
    parameter, he visited the unsubscribe link to confirm that the HTTP response took
    at least 12 seconds. Realizing he needed more concrete proof of the SQLi to send
    to Uber, he dumped the user name, host name, and database name using brute force.
    By doing so, he demonstrated that he could extract information from the SQLi vulnerability
    without accessing confidential data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Orange 重新编码修改后的负载并将其传递给 URL 参数后，他访问了取消订阅链接，确认 HTTP 响应至少延迟了12秒。意识到他需要更具体的 SQLi
    证据以便发送给 Uber，他通过暴力破解导出了用户名、主机名和数据库名。通过这种方式，他证明了自己可以从 SQLi 漏洞中提取信息，而无需访问机密数据。
- en: A SQL function called `user` returns the user name and host name of a database
    in the form *<user>*@*<host>*. Because Orange couldn’t access output from his
    injected queries, he couldn’t call `user`. Instead, Orange modified his query
    to add a conditional check when the query looked up his user ID, comparing one
    character of the database’s user name and host name string at a time using the
    `mid` function. Similar to the Yahoo! Sports blind SQLi vulnerability in the previous
    bug report, Orange used a comparison statement and brute force to derive each
    character of the user name and host name string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `user` 的 SQL 函数返回数据库的用户名和主机名，形式为 *<user>*@*<host>*。由于 Orange 无法访问他注入的查询的输出，他无法直接调用
    `user`。相反，Orange 修改了查询，增加了一个条件检查，当查询查找他的用户 ID 时，使用 `mid` 函数逐一比较数据库用户名和主机名字符串的每个字符。与之前的
    Yahoo! Sports 盲 SQLi 漏洞类似，Orange 使用了比较语句和暴力破解来推导用户名和主机名字符串的每个字符。
- en: For example, Orange took the first character of the value returned from the
    `user` function using the `mid` function. Then he compared whether the character
    was equal to `'a'`, then `'b'`, then `'c'`, and so on. If the comparison statement
    was true, the server would execute the unsubscribe command. This result indicated
    that the first character of the `user` function’s return value was equal to the
    character it was being compared to. If the statement was false, the server would
    not try to unsubscribe Orange. By checking each character of the `user` function’s
    return value using this method, Orange could eventually derive the entire user
    name and host name.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Orange 使用 `mid` 函数获取 `user` 函数返回值的第一个字符。然后他比较该字符是否等于 `'a'`，然后是 `'b'`，然后是
    `'c'`，以此类推。如果比较语句为真，服务器将执行取消订阅命令。这个结果表明 `user` 函数的返回值的第一个字符与正在比较的字符相等。如果语句为假，服务器将不会尝试取消订阅
    Orange。通过使用这种方法检查 `user` 函数返回值的每个字符，Orange 最终能够推导出整个用户名和主机名。
- en: 'Manually brute-forcing a string takes time, so Orange created a Python script
    that generated and submitted payloads to Uber on his behalf, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 手动暴力破解一个字符串需要时间，因此 Orange 创建了一个 Python 脚本，代表他生成并提交有效负载给 Uber，具体如下：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Python script begins with five lines of `import` statements ➊ that retrieve
    the libraries Orange needed to process HTTP requests, JSON, and string encodings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本以五行`import`语句开始➊，这些语句加载了 Orange 需要用来处理 HTTP 请求、JSON 和字符串编码的库。
- en: A database user name and host name can be made up of any combination of uppercase
    letters, lowercase letters, numbers, hyphens (`-`), underscores (`_`), at symbols
    (`@`), or periods (`.`). At ➋, Orange creates the `base` variable to hold these
    characters. The code at ➌ creates a variable to hold the payload that the script
    sends to the server. The line of code at ➏ is the injection, which uses the `for`
    loops at ➍ and ➎.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的用户名和主机名可以由大写字母、小写字母、数字、连字符（`-`）、下划线（`_`）、@符号（`@`）或句点（`.`）的任意组合构成。在 ➋ 处，Orange
    创建了 `base` 变量来保存这些字符。 ➌ 处的代码创建了一个变量来保存脚本发送到服务器的有效负载。 ➏ 处的代码是注入部分，使用了 ➍ 和 ➎ 处的
    `for` 循环。
- en: Let’s look at the code at ➏ in detail. Orange references his user ID, 5755,
    with the string `user_id` as defined at ➌ to create his payloads. He uses the
    `mid` function and string processing to construct a payload similar to the Yahoo!
    bug earlier in this chapter. The `%d` and `%c` in the payload are string replacement
    placeholders. The `%d` is data that represents a digit, and the `%c` is character
    data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看 ➏ 处的代码。Orange 使用字符串`user_id`来引用他的用户 ID 5755，这个字符串在 ➌ 处已定义，以创建他的有效负载。他使用
    `mid` 函数和字符串处理构造了一个类似于本章前面提到的 Yahoo! 漏洞的有效负载。有效负载中的 `%d` 和 `%c` 是字符串替换占位符。`%d`
    表示一个数字数据，而 `%c` 表示字符数据。
- en: The payload string starts at the first pair of double quotes (`"`) and ends
    at the second pair of double quotes before the third percent symbol at ➏. The
    third percent symbol tells Python to replace the `%d` and `%c` placeholders with
    the values following the percent symbol in the parentheses. So the code replaces
    `%d` with `l+1` (the variable `l` plus the number `1`) and `%c` with the variable
    `i`. The hash mark (`#`) is another way of commenting in MySQL and renders any
    part of the query following Orange’s injection into a comment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载字符串从第一个双引号（`"`)开始，到第二对双引号结束，在第三个百分号符号前结束 ➏ 处。第三个百分号符号告诉 Python 替换 `%d` 和
    `%c` 占位符，并用括号中的百分号后面的值来替代它们。所以代码将 `%d` 替换为 `l+1`（变量 `l` 加上数字 `1`），将 `%c` 替换为变量
    `i`。井号（`#`）是 MySQL 中另一种注释的方式，它将 Orange 的注入部分后面的查询内容标记为注释。
- en: The `l` and `i` variables are the loop iterators at ➍ and ➎. The first time
    the code enters `l in range (0,30)` at ➍, `l` will be `0`. The value of `l` is
    the position in the user name and host name string returned by the `user` function
    that the script is trying to brute-force. Once the script has a position in the
    user name and host name string it’s testing, the code enters a nested loop at
    ➎ that iterates over each character in the `base` string. The first time the script
    iterates through both loops, `l` will be `0` and `i` will be `a`. These values
    are passed to the `mid` function at ➏ to create the payload `"5755 and mid(user(),0,1)='a'#"`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`l`和`i`变量是➍和➎处的循环迭代器。第一次进入➍处的`l in range (0,30)`时，`l`将是`0`。`l`的值是`user`函数返回的用户名和主机名字符串中的位置，脚本正在尝试暴力破解。一旦脚本确定了正在测试的用户名和主机名字符串中的位置，代码将在➎处进入一个嵌套循环，遍历`base`字符串中的每个字符。脚本第一次遍历这两个循环时，`l`将是`0`，`i`将是`a`。这些值会传递给➏处的`mid`函数，生成有效负载`"5755
    and mid(user(),0,1)=''a''#"。'
- en: In the next iteration of the nested `for` loop, the value of `l` will still
    be `0` and `i` will be `b` to create the payload `"5755 and mid(user(),0,1)='b'#"`.
    The position `l` will remain constant as the loop iterates though each character
    in `base` to create the payload at ➏.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次嵌套`for`循环的迭代中，`l`的值仍然是`0`，`i`将是`b`，以创建有效负载`"5755 and mid(user(),0,1)='b'#"。`l`的位置将保持不变，随着循环遍历`base`中的每个字符来创建➏处的有效负载。
- en: Each time a new payload is created, the code following ➐ converts the payload
    to JSON, reencodes the string using the `base64encode` function, and sends the
    HTTP request to the server. The code at ➑ checks whether the server responds with
    a message. If the character in `i` matches the user name substring at the position
    being tested, the script stops testing characters at that position and moves to
    the next position in the `user` string. The nested loop breaks and returns to
    the loop at ➍, which increments `l` by `1` to test the next position of the user
    name string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建新的有效负载时，➐处的代码将有效负载转换为JSON，使用`base64encode`函数对字符串重新编码，并发送HTTP请求到服务器。➑处的代码检查服务器是否返回消息。如果`i`中的字符与正在测试的位置的用户名子字符串匹配，脚本会停止测试该位置的字符，并继续测试`user`字符串中的下一个位置。嵌套循环会中断，并返回到➍处的循环，➍处的代码将`l`增加`1`，以测试用户名字符串的下一个位置。
- en: This proof of concept allowed Orange to confirm that the database user name
    and host name were `sendcloud_w@10.9.79.210` and the database name was `sendcloud`
    (to obtain the database name, replace `user` with `database` at ➏). In response
    to the report, Uber confirmed that the SQLi hadn’t occurred on its server. The
    injection occurred on a third-party server that Uber was using, but Uber still
    paid a reward. Not all bounty programs will do the same. Uber likely paid a bounty
    because the exploit would allow an attacker to dump all of Uber’s customer email
    addresses from the `sendcloud` database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念证明让Orange确认数据库用户名和主机名是`sendcloud_w@10.9.79.210`，数据库名是`sendcloud`（要获取数据库名，将➏处的`user`替换为`database`）。在报告回应中，Uber确认SQLi并未发生在其服务器上。注入发生在Uber使用的第三方服务器上，但Uber仍然支付了奖励。并非所有赏金项目都会这样做。Uber可能支付了赏金，因为该漏洞允许攻击者从`sendcloud`数据库中导出Uber所有客户的电子邮件地址。
- en: Although you can write your own scripts as Orange did to dump database information
    from a vulnerable website, you can also use automated tools. [Appendix A](app01.xhtml#app01)
    includes information about one such tool called sqlmap.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像Orange一样编写自己的脚本来从一个易受攻击的网站转储数据库信息是可行的，但你也可以使用自动化工具。[附录A](app01.xhtml#app01)包含了关于一种名为sqlmap的工具的信息。
- en: '***Takeaways***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: Keep an eye out for HTTP requests that accept encoded parameters. After you
    decode and inject your query into a request, be sure to reencode your payload
    so everything still matches the encoding the server expects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意接受编码参数的HTTP请求。解码后，将查询注入请求中时，请确保重新编码有效负载，以确保一切仍然符合服务器预期的编码。
- en: Extracting a database name, user name, and host name is generally harmless,
    but be sure it’s within the permitted actions of the bounty program you’re working
    in. In some cases, the `sleep` command is enough for a proof of concept.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提取数据库名、用户名和主机名通常是无害的，但请确保这些操作在你参与的赏金项目的允许范围内。在某些情况下，`sleep`命令就足以证明概念。
- en: '**Drupal SQLi**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Drupal SQLi**'
- en: '**Difficulty:** Hard'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 难'
- en: '**URL:** Any Drupal site using version 7.32 or earlier'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** 任何使用7.32版本或更早版本的Drupal站点'
- en: '**Source:** *[https://hackerone.com/reports/31756/](https://hackerone.com/reports/31756/)*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://hackerone.com/reports/31756/](https://hackerone.com/reports/31756/)*'
- en: '**Date reported:** October 17, 2014'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2014年10月17日'
- en: '**Bounty paid:** $3,000'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**赏金支付：** $3,000'
- en: '*Drupal* is a popular open source content management system for building websites,
    similar to Joomla! and WordPress. It’s written in PHP and is *modular*, meaning
    you can install new functionality in units to a Drupal site. Every Drupal install
    contains *Drupal core*, which is a set of modules that runs the platform. These
    core modules require a connection to a database, such as MySQL.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*Drupal* 是一个流行的开源内容管理系统，用于构建网站，类似于 Joomla! 和 WordPress。它是用 PHP 编写的，并且是 *模块化*
    的，这意味着你可以将新的功能单元安装到 Drupal 网站中。每个 Drupal 安装都包含 *Drupal 核心*，它是一组运行平台的模块。这些核心模块需要连接到数据库，比如
    MySQL。'
- en: In 2014, Drupal released an urgent security update to Drupal core because all
    Drupal sites were vulnerable to a SQLi vulnerability that could easily be abused
    by anonymous users. The impact of the vulnerability would allow an attacker to
    take over any unpatched Drupal site. Stefan Horst discovered the vulnerability
    when he noticed a bug in Drupal core’s prepared statement functionality.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，Drupal 发布了一个紧急安全更新，以修复 Drupal 核心的漏洞，因为所有的 Drupal 网站都容易受到 SQL 注入漏洞的攻击，匿名用户也可以轻易滥用这个漏洞。该漏洞的影响允许攻击者接管任何未修补的
    Drupal 网站。Stefan Horst 发现了这个漏洞，当时他注意到 Drupal 核心的预处理语句功能存在一个 bug。
- en: The Drupal vulnerability occurred in Drupal’s database application programming
    interface (API). The Drupal API uses the PHP Data Objects (PDO) extension, which
    is an *interface* for accessing databases in PHP. An interface is a programming
    concept that guarantees inputs and outputs of a function without defining how
    the function is implemented. In other words, PDO hides the differences between
    databases so programmers can use the same functions to query and fetch data regardless
    of the database type. PDO includes support for prepared statements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 的漏洞发生在 Drupal 的数据库应用程序编程接口（API）中。Drupal API 使用 PHP 数据对象（PDO）扩展，它是一个用于在
    PHP 中访问数据库的 *接口*。接口是一个编程概念，它保证了函数的输入和输出，但不定义函数是如何实现的。换句话说，PDO 隐藏了数据库之间的差异，因此程序员可以使用相同的函数来查询和获取数据，而不管数据库的类型。PDO
    支持预处理语句。
- en: Drupal created a database API to use the PDO functionality. The API creates
    a Drupal database abstraction layer so developers never have to query the database
    directly with their own code. But they can still use prepared statements and use
    their code with any database type. The specifics of the API are beyond the scope
    of this book. But you need to know that the API will generate the SQL statements
    to query the database and has built-in security checks to prevent SQLi vulnerabilities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 创建了一个数据库 API 来使用 PDO 功能。该 API 创建了一个 Drupal 数据库抽象层，因此开发者不必直接使用自己的代码查询数据库。但他们仍然可以使用预处理语句，并且可以将代码与任何数据库类型一起使用。API
    的具体细节超出了本书的范围。但你需要知道，API 会生成 SQL 语句来查询数据库，并且具有内建的安全检查来防止 SQL 注入漏洞。
- en: Recall that prepared statements prevent SQLi vulnerabilities because an attacker
    can’t modify the query structure with malicious input, even if the input is unsanitized.
    But prepared statements can’t protect against SQLi vulnerabilities if the injection
    occurs when the template is being created. If an attacker can inject malicious
    input during the template creation process, they can create their own malicious
    prepared statement. The vulnerability Horst discovered occurred because of SQL’s
    `IN` clause, which looks for values that exist in a list of values. For example,
    the code `SELECT * FROM users WHERE name IN ('peter', 'paul', 'ringo');` selects
    the data from the `users` table where the value in the `name` column is `peter`,
    `paul`, or `ringo`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，预处理语句可以防止 SQL 注入漏洞，因为攻击者无法通过恶意输入修改查询结构，即使输入没有经过清理。但如果注入发生在模板创建过程中，预处理语句也无法防止
    SQL 注入漏洞。如果攻击者可以在模板创建过程中注入恶意输入，他们可以创建自己的恶意预处理语句。Horst 发现的漏洞就是因为 SQL 的 `IN` 子句，它用于查找存在于一组值中的值。例如，代码
    `SELECT * FROM users WHERE name IN ('peter', 'paul', 'ringo');` 会从 `users` 表中选择
    `name` 列值为 `peter`、`paul` 或 `ringo` 的数据。
- en: 'To understand why the `IN` clause is vulnerable, let’s look at the code behind
    Drupal’s API:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么 `IN` 子句存在漏洞，我们来看看 Drupal API 背后的代码：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `expandArguments` function is responsible for building queries that use
    the `IN` clause. After `expandArguments` builds queries, it passes them to `prepareQuery`,
    which builds the prepared statements that the `execute` function executes. To
    understand the significance of this process, let’s look at the relevant code for
    `expandArguments` as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`expandArguments`函数负责构建使用`IN`子句的查询。在`expandArguments`构建查询后，它将查询传递给`prepareQuery`，后者构建准备好的语句，而`execute`函数执行这些语句。为了理解这个过程的重要性，我们再来看一下`expandArguments`的相关代码：'
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This PHP code uses arrays. PHP can use associative arrays, which explicitly
    define keys as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段PHP代码使用了数组。PHP可以使用关联数组，显式地定义键，如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The keys in this array are `'red'` and `'yellow'`, and the array’s values are
    the fruits to the right of the arrow (`=>`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该数组的键是`'red'`和`'yellow'`，而数组的值是箭头（`=>`）右侧的水果。
- en: 'Alternatively, PHP can use a *structured array*, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，PHP也可以使用*结构化数组*，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A structured array’s keys are implicit and based on the position of the value
    in the list. For example, the key for `'apple'` is `0` and the key for `'banana'`
    is `1`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化数组的键是隐式的，基于值在列表中的位置。例如，`'apple'`的键是`0`，`'banana'`的键是`1`。
- en: The `foreach` PHP function iterates over an array and can separate the array
    key from its value. It can also assign each key and each value to its own variable
    and pass them to a block of code for processing. At ➊, `foreach` takes each element
    of an array and verifies the value passed to it is an array by calling `array_filter($args,
    'is_array')`. After the statement confirms it has an array value, it assigns each
    of the array’s keys to `$key` and each of the values to `$data` for each iteration
    of the `foreach` loop. The code will modify the values in the array to create
    placeholders, so the code at ➋ initializes a new empty array to later hold the
    placeholder values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` PHP函数遍历数组，并可以将数组的键和值分开。它还可以将每个键和值分别赋给变量，并将它们传递给代码块进行处理。在➊处，`foreach`获取数组的每个元素，并通过调用`array_filter($args,
    ''is_array'')`验证传递给它的值是否为数组。经过声明确认它具有数组值后，它将每个数组的键赋值给`$key`，每个值赋给`$data`，用于`foreach`循环的每次迭代。代码会修改数组中的值以创建占位符，因此在➋处，代码初始化了一个新的空数组，用于稍后保存占位符值。'
- en: To create the placeholders, the code at ➌ iterates through the `$data` array
    by assigning each key to `$i` and each value to `$value`. Then at ➍, the `new_keys`
    array initialized at ➋ holds the first array’s key concatenated with the key at
    ➌. The code’s intended outcome is to create data placeholders that look like `name_0`,
    `name_1`, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建占位符，代码在➌处通过将每个键赋给`$i`，每个值赋给`$value`，遍历`$data`数组。然后在➍处，初始化于➋的`new_keys`数组包含了第一个数组的键与➌处的键的连接。代码的目标是创建看起来像`name_0`、`name_1`等数据占位符。
- en: 'Here is what a typical query would look like using Drupal’s `db_query` function,
    which queries a database:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用Drupal的`db_query`函数查询数据库时，一个典型查询的样子：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `db_query` function takes two parameters: a query that contains named placeholders
    for variables and an array of values to substitute for those placeholders. In
    this example, the placeholder is `:name` and is an array with the values `''user1''`
    and `''user2''`. In a structured array, the key for `''user1''` is `0` and the
    key for `''user2''` is `1`. When Drupal executes the `db_query` function, it calls
    the `expandArguments` function, which concatenates the keys to each value. The
    resulting query uses `name_0` and `name_1` in place of the keys, as shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_query`函数接受两个参数：一个包含变量命名占位符的查询和一个用于替换这些占位符的值的数组。在这个例子中，占位符是`:name`，它是一个包含`''user1''`和`''user2''`值的数组。在结构化数组中，`''user1''`的键是`0`，`''user2''`的键是`1`。当Drupal执行`db_query`函数时，它调用`expandArguments`函数，将键与每个值连接。生成的查询使用`name_0`和`name_1`替代键，如下所示：'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But the problem arises when you call `db_query` using an associative array,
    as in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你使用关联数组调用`db_query`时，就会出现问题，以下是代码示例：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, `:name` is an array and its keys are `''test);--''` and `''test''`.
    When `expandArguments` receives the `:name` array and processes it to create the
    query, it generates this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`:name`是一个数组，它的键是`'test);--'`和`'test'`。当`expandArguments`接收到`:name`数组并处理它以创建查询时，它生成了如下内容：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve injected a comment into the prepared statement. The reason this occurs
    is that `expandArguments` iterates through each array element to build placeholders
    but assumes it’s passed a structured array. In the first iteration, `$i` is assigned
    `'test);--'` and `$value` is assigned `'user1'`. The `$key` is `':name'` and combining
    that with `$i` results in `name_test);--`. In the second iteration, `$i` is assigned
    `'test'` and `$value` is `'user2'`. Combining `$key` with `$i` results in the
    value `name_test`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将注释注入到预处理语句中。之所以会发生这种情况，是因为`expandArguments`遍历每个数组元素以构建占位符，但假设传入的是结构化数组。在第一次迭代中，`$i`被赋值为`'test);--'`，`$value`被赋值为`'user1'`。`$key`为`':name'`，将其与`$i`结合后得到`name_test);--`。在第二次迭代中，`$i`被赋值为`'test'`，`$value`为`'user2'`。将`$key`与`$i`结合后得到`name_test`。
- en: This behavior allows malicious users to inject SQL statements into Drupal queries
    that rely on the `IN` clause. The vulnerability affects Drupal login functionality,
    making the SQLi vulnerability severe because any site user, including an anonymous
    user, could exploit it. Making matters worse, PHP PDO supports the ability to
    execute multiple queries at once by default. This means an attacker could append
    additional queries to the user login query in order to execute non-`IN` clause
    SQL commands. For example, an attacker could use `INSERT` statements, which insert
    records into a database, to create an administrative user that they could then
    use to log in to the website.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为允许恶意用户将SQL语句注入到依赖`IN`子句的Drupal查询中。这个漏洞影响了Drupal的登录功能，使得SQLi漏洞变得非常严重，因为任何网站用户，包括匿名用户，都可能利用它。更糟糕的是，PHP
    PDO默认支持一次执行多个查询。这意味着攻击者可以在用户登录查询中附加额外的查询，以执行非`IN`子句的SQL命令。例如，攻击者可以使用`INSERT`语句，将记录插入数据库，从而创建一个管理员用户，然后利用该用户登录网站。
- en: '***Takeaways***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点总结***'
- en: This SQLi vulnerability wasn’t simply a matter of submitting a single quote
    and breaking a query. Rather, it required understanding how Drupal core’s database
    API handles the `IN` clause. The takeaway from this vulnerability is to be on
    the lookout for opportunities to alter the structure of input passed to a site.
    When a URL takes `name` as a parameter, try adding `[]` to the parameter to change
    it to an array and test how the site handles it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQLi漏洞不仅仅是提交一个单引号并破坏查询那么简单。实际上，它需要理解Drupal核心的数据库API如何处理`IN`子句。这个漏洞的要点是要留意改变传递给网站的输入结构的机会。当URL将`name`作为参数时，可以尝试向参数添加`[]`以将其更改为数组，并测试网站如何处理它。
- en: '**Summary**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: SQLi can be a significant vulnerability and dangerous for a site. If an attacker
    finds a SQLi, they might obtain full permissions to a site. In some situations,
    a SQLi vulnerability can be escalated by inserting data into the database that
    enables administrative permissions on the site, as in the Drupal example. When
    you’re looking for SQLi vulnerabilities, explore places where you can pass unescaped
    single or double quotes to a query. When you find a vulnerability, the indications
    that the vulnerability exists can be subtle, such as with blind injections. You
    should also look for places where you can pass data to a site in unexpected ways,
    such as where you can substitute array parameters in request data, as in the Uber
    bug.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入（SQLi）可能是一个重大的漏洞，并且对网站非常危险。如果攻击者发现了SQLi漏洞，他们可能获得网站的全部权限。在某些情况下，SQLi漏洞可以通过向数据库插入数据来提升权限，从而在网站上获得管理员权限，例如Drupal的例子。当你寻找SQLi漏洞时，应该关注能够向查询中传递未转义的单引号或双引号的地方。当你发现漏洞时，漏洞存在的迹象可能很微妙，比如盲注。你还应该寻找那些可以以意外方式向网站传递数据的地方，例如你可以在请求数据中替换数组参数的地方，就像Uber的漏洞一样。
