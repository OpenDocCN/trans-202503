["```\n#[no_mangle]\npub static RS_DEBUG: bool = true;\n\nextern {\n    static FOREIGN_DEBUG: bool;\n}\n```", "```\n#[no_mangle]\npub extern fn hello_rust(i: i32) { ... }\n\nextern {\n    fn hello_foreign(i: i32);\n}\n```", "```\nenum Foo { Bar, Baz }\n```", "```\n#[repr(C)]\nenum Foo {\n    Bar = 1,\n    Baz = 2,\n}\n```", "```\n#[repr(C)]\nenum Foo {\n    Bar(i32),\n    Baz { a: bool, b: f64 }\n}\n// is represented as\n#[repr(C)]\nenum FooTag { Bar, Baz }\n#[repr(C)]\nstruct FooBar(i32);\n#[repr(C)]\nstruct FooBaz{ a: bool, b: f64 }\n#[repr(C)]\nunion FooData {\n  bar: FooBar,\n  baz: FooBaz,\n}\n#[repr(C)]\nstruct Foo {\n    tag: FooTag,\n    data: FooData\n}\n```", "```\n// One function allocates memory for a new object.\nextern fn ECDSA_SIG_new() -> *mut ECDSA_SIG;\n\n// And another accepts a pointer created by new\n// and deallocates it when the caller is done with it.\nextern fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);\n```", "```\n// An example of caller-managed memory.\n// The caller provides a pointer to a chunk of memory,\n// which the implementation then uses to instantiate its own types.\n// No free function is provided, as that happens in the caller.\nextern fn BIO_new_mem_buf(buf: *const c_void, len: c_int) -> *mut BIO\n```", "```\nextern fn start_main_loop();\nextern fn next_event() -> *mut Event;\n```", "```\npub struct EventLoop(std::marker::PhantomData<*const ()>);\npub fn start() -> EventLoop {\n    unsafe { ffi::start_main_loop() };\n    EventLoop(std::marker::PhantomData)\n}\nimpl EventLoop {\n    pub fn next_event(&self) -> Option<Event> {\n        let e = unsafe { ffi::next_event() };\n        // ...\n    }\n}\n```", "````Using `PhantomData<*const ()>` to “undo” the `Send` and `Sync` auto-traits as we do here is a bit ugly and indirect. Rust does have an unstable compiler feature that enables negative trait implementations like `impl !Send for EventLoop {}`, but it’s surprisingly difficult to get its implementation right, and it likely won’t stabilize for some time.    You may have noticed that nothing prevents the caller from invoking `start_main_loop` multiple times, either from the same thread or from another thread. How you’d handle that would depend on the semantics of the library in question, so I’ll leave it to you as an exercise.    #### Pointer Confusion    In many FFI APIs, you don’t necessarily want the caller to know the internal representation for each and every chunk of memory you give it pointers to. The type might have internal state that the caller shouldn’t fiddle with, or the state might be difficult to express in a cross-language-compatible way. For these kinds of situations, C-style APIs usually expose *void pointers*, written out as the C type `void*`, which is equivalent to `*mut std::ffi::c_void` in Rust. A type-erased pointer like this is, effectively, *just* a pointer, and does not convey anything about the thing it points to. For that reason, these kinds of pointers are often referred to as *opaque*.    Opaque pointers effectively serve the role of visibility modifiers for types across FFI boundaries—since the method signature does not say what’s being pointed to, the caller has no option but to pass around the pointer as is and use any available FFI methods to provide visibility into the referenced data. Unfortunately, since one `*mut c_void` is indistinguishable from another, there’s nothing stopping a user from taking an opaque pointer as is returned from one FFI method and supplying it to a method that expects a pointer to a *different* opaque type.    We can do better than this in Rust. To mitigate this kind of pointer type confusion, we can avoid using `*mut c_void` directly for opaque pointers in FFI, even if the actual interface calls for a `void*`, and instead construct different empty types for each distinct opaque type. For example, in [Listing 11-9](#listing11-9) I use two distinct opaque pointer types that cannot be confused.    ``` #[non_exhaustive] #[repr(transparent)] pub struct Foo(c_void); #[non_exhaustive] #[repr(transparent)] pub struct Bar(c_void); extern {     pub fn foo() -> *mut Foo;     pub fn take_foo(arg: *mut Foo);     pub fn take_bar(arg: *mut Bar); } ```    Listing 11-9: Opaque pointer types that cannot be confused    Since `Foo` and `Bar` are both zero-sized types, they can be used in place of `()` in the `extern` method signatures. Even better, since they are now distinct types, Rust won’t let you use one where the other is required, so it’s now impossible to call `take_bar` with a pointer you got back from `foo`. Adding the `#[non_exhaustive]` annotation ensures that the `Foo` and `Bar` types cannot be constructed outside of this crate.    ## bindgen and Build Scripts    Mapping out the Rust types and `extern`s for a larger external library can be quite a chore. Big libraries tend to have a large enough number of type and method signatures to match up that writing out all the Rust equivalents is time-consuming. They also have enough corner cases and C oddities that some patterns are bound to require more careful thought to translate.    Luckily, the Rust community has developed a tool called `bindgen` that significantly simplifies this process as long as you have C header files available for the library you want to interface with. `bindgen` essentially encodes all the rules and best practices we’ve discussed in this chapter, plus a number of others, and wraps them up in a configurable code generator that takes in C header files and spits out appropriate Rust equivalents.    `bindgen` provides a stand-alone binary that generates the Rust code for C headers once, which is convenient when you want to check in the bindings. This process allows you to hand-tune the generated bindings, should that be necessary. If, on the other hand, you want to generate the bindings automatically on every build and just include the C header files in your source code, `bindgen` also ships as a library that you can invoke in a custom *build script* for your package.    You declare a build script by adding `build = \"``<some-file.rs>``\"` to the `[package]` section of your *Cargo.toml*. This tells Cargo that, before compiling your crate, it should compile *<some-file.rs>* as a stand-alone Rust program and run it; only then should it compile the source code of your crate. The build script also gets its own dependencies, which you declare in the `[build-dependencies]` section of your *Cargo.toml*.    Build scripts come in very handy with FFI—they can compile a bundled C library from source, dynamically discover and declare additional build flags to be passed to the compiler, declare additional files that Cargo should check for changes for the purposes of recompilation, and, you guessed it, generate additional source files on the fly!    Though build scripts are very versatile, beware of making them too aware of the environment they run in. While you can use a build script to detect if the Rust compiler version is a prime or if it’s going to rain in Istanbul tomorrow, making your compilation dependent on such conditions may make builds fail unexpectedly for other developers, which leads to a poor development experience.    The build script can write files to a special directory supplied through the `OUT_DIR` environment variable. The same directory and environment variable are also accessible in the Rust source code at compile time so that it can pick up files generated by the build script. To generate and use Rust types from a C header, you first have your build script use the library version of `bindgen` to read in a *.h* file and turn it into a file called, say, *bindings.rs* inside `OUT_DIR`. You then add the following line to any Rust file in your crate to include *bindings.rs* at compilation time:    ``` include!(concat!(env!(\"OUT_DIR\"), \"/bindings.rs\")); ```    Since the code in *bindings.rs* is autogenerated, it’s generally best practice to place the bindings in their own crate and give the crate the same name as the library the bindings are for, with the suffix `-sys` (for example, `openssl-sys`). If you don’t follow this practice, releasing new versions of your library will be much more painful, as it is illegal for two crates that link against the same external library through the `links` key in *Cargo.toml* to coexist in a given build. You would essentially have to upgrade the entire ecosystem to the new major version of your library all at once. Separating just the bindings into their own crate allows you to issue new major versions of the wrapper crate that can be adopted incrementally. The separation also allows you to cut a breaking release of the crate with those bindings if the Rust bindings change—say, if the header files themselves are upgraded or a `bindgen` upgrade causes the generated Rust code to change slightly—without *also* having to cut a breaking release of the crate that safely wraps the FFI bindings.    If your crate instead produces a library file that you intend others to use through FFI, you should also publish a C header file for its interface to make it easier to generate native bindings to your library from other languages. However, that C header file then needs to be kept up to date as your crate changes, which can become cumbersome as your library grows in size. Fortunately, the Rust community has also developed a tool to automate this task: `cbindgen`. Like `bindgen`, `cbindgen` is a build tool, and it also comes as both a binary and a library for use in build scripts. Instead of taking in a C header file and producing Rust, it takes Rust in and produces a C header file. Since the C header file represents the main computer-readable description of your crate’s FFI, I recommend manually looking it over to make sure the autogenerated C code isn’t too unwieldy, though in general `cbindgen` tends to produce fairly reasonable code. If it doesn’t, file a bug!    ## Summary    In this chapter, we’ve covered how to use the `extern` keyword to call out of Rust into external code, as well as how to use it to make Rust code accessible to external code. We’ve also discussed how to align Rust types with types on the other side of the FFI boundary, and some of the common pitfalls in trying to get code written in two different languages to mesh well. Finally, we talked about the `bindgen` and `cbindgen` tools, which make the experience of keeping FFI bindings up to date much more pleasant. In the next chapter, we’ll look at how to use Rust in more restricted environments, like embedded devices, where the standard library may not be available and where even a simple operation like allocating memory may not be possible.````"]