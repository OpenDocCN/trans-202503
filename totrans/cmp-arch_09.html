<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_155"/><strong>7</strong></h2>&#13;
<h2 class="cht"><strong>DIGITAL CPU DESIGN</strong></h2>&#13;
<div class="image1"><img src="../images/f0155-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">We’ve been building up larger and larger components of digital electronic computers, from transistors, to logic gates, to simple machines such as decoders and adders. Now it’s time to put everything together at the top level to make a digital electronic CPU. At least until very recently, the CPU has been the heart of digital electronic computers.</p>&#13;
<p class="indent">The aim of this chapter is to overcome your fear of digital electronic CPUs. Modern CPUs are probably the second most complex device known to humanity, after the human brain. If you look at a CPU circuit under a microscope and see all the wiring without first preparing your mind, you’ll likely go crazy. As with driving, you don’t study a modern, state-of-the-art machine immediately; you start with a bicycle, then an old beat-up car, and then, as you get a feel for the systems, you progress to more powerful and modern machines. Likewise, we’ll use one of the first and simplest digital electronic CPU systems as our example for this chapter: the Manchester Baby. Contemporary CPUs are much more complicated and may vary or break many or all of the design principles covered here, but they’re still based on classical ideas. Seeing how they play out in a historical machine like the Baby will help us understand the basics.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_156"/>We’ve already seen and understood the basic structure of a CPU from Babbage’s Analytical Engine, so here we’ll focus on the digital electronic implementations of the same overall design. As with Babbage, we’ll play a bit fast and loose with the actual details and history of the Manchester Baby; the point is to use it to get a flavor of digital CPUs in general. The original Baby’s digital electronics were built from vacuum tubes rather than transistors, and didn’t necessarily use the same structures that we’d use today to re-implement its functionality. Nonetheless, the simple machines that we’ve studied can be used to build a modernized implementation of the Baby. We’ll build such an implementation here, capable of running real programs, using LogiSim. But first, we’ll learn what the Baby needs to be capable of by programming it as a user.</p>&#13;
<h3 class="h3" id="lev138">The Baby’s Programmer Interface</h3>&#13;
<p class="noindent">Unlike the Analytical Engine, von Neumann architectures such as the Baby store their instructions and data in the same RAM space. A program is thus a list of lines that are all copied into RAM. Each line has a number, and it gets copied to the RAM address of that same number. Like the Analytical Engine, a program is made up of binary <em>machine code</em> corresponding to a series of instructions from its instruction set.</p>&#13;
<p class="indent">Here’s the Baby’s complete instruction set. We’ll discuss each instruction in more detail in the following sections.</p>&#13;
<p class="block"><span class="codestrong">HLT</span> Halt the Baby and light the stop lamp</p>&#13;
<p class="block"><span class="codestrong">LDN</span> Load the negated content of the specified address</p>&#13;
<p class="block"><span class="codestrong">STO</span> Store the latest result to the specified address</p>&#13;
<p class="block"><span class="codestrong">SUB</span> Subtract the content of the specified address from the result</p>&#13;
<p class="block"><span class="codestrong">JMP</span> Jump to the line number stored in the given address</p>&#13;
<p class="block"><span class="codestrong">JRP</span> Jump forward by the number of lines stored in the given address</p>&#13;
<p class="block"><span class="codestrong">SKN</span> Compare the result: if less than 0, skip the next instruction</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>The Baby’s designers really wanted to have a regular load instruction, as in the Analytical Engine and most modern computers, to load a copy of the data stored at the address. But due to technical limitations of the time, they were forced to replace this with <code>LDN</code>, “load negated,” which also inverts each of the bits from the data as they are loaded. This is a famous quirk of the Baby that gives its programming a distinctive problem-solving flavor.</em></p>&#13;
<h4 class="h4" id="lev139"><em>Halting</em></h4>&#13;
<p class="noindent">The <code>HLT</code> instruction stops the machine. This prevents execution of any further instructions and turns on a light bulb to tell the user that the work has finished, so they know when to inspect the results. The simplest Baby program is thus:</p>&#13;
<span epub:type="pagebreak" id="page_157"/>&#13;
<pre>01: HLT</pre>&#13;
<p class="indent">The line number 01 on the left of the instruction is also the RAM address where the instruction will be stored. When this program is loaded into the Baby’s RAM, address 1 of RAM will contain the binary machine code for <code>HLT</code>. After loading the program, it can be run. The Baby begins execution from address 1 (not address 0, because the program counter is incremented just before each fetch) so the <code>HLT</code> will be executed, causing the Baby to halt.</p>&#13;
<h4 class="h4" id="lev140"><em>Constants</em></h4>&#13;
<p class="noindent">Lines with <code>NUM</code> aren’t true instructions but are used to place <em>data</em> at their address when the code is first loaded into RAM. For example, consider the following:</p>&#13;
<pre>01: HLT&#13;
02: NUM 10&#13;
03: NUM 5&#13;
04: NUM 0</pre>&#13;
<p class="noindent">When this is loaded into RAM, the constants 10, 5, and 0 will be placed into addresses 2, 3, and 4, respectively, as well as the <code>HLT</code> instruction being placed into address 1.</p>&#13;
<p class="indent">If you actually run the program it will begin at line 1, execute the <code>HLT</code> instruction, and immediately halt. The <code>HLT</code> instruction here is very important; the CPU tries to read and execute the instructions in order, starting from address 1, but the values that we’ve placed into addresses 2, 3, and 4 are intended to be used as data, not instructions. The <code>HLT</code> instruction stops the CPU from getting to address 2 and beyond, preventing the data values from being treated as instructions.</p>&#13;
<p class="indent">This method of writing the program and data together, and storing them in the same RAM together, is the defining characteristic of von Neumann architectures. When programming von Neumann machines, it’s very important that we only ever execute instruction lines, and that we don’t try to execute data lines. It’s a programming error—that is, a bug—to write code that ends up trying to execute data as if it were part of the program.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>Execution of data can have unpredictable and dangerous behavior. That’s why it’s often used as a security attack technique: if you want to break into someone else’s program and have it execute your own code, you can sometimes do this by entering your code as data to that program, then somehow trick the program into executing it.</em></p>&#13;
<h4 class="h4" id="lev141"><em>Load and Store</em></h4>&#13;
<p class="noindent">The constants in the above code never enter the CPU; rather, the whole code is loaded into the RAM locations given as the line numbers by some other mechanism before the CPU is even turned on. To make use of data <span epub:type="pagebreak" id="page_158"/>from RAM in actual computations, we need to execute load and store instructions, which copy data from RAM into the CPU, and from the CPU to RAM.</p>&#13;
<p class="indent">For example, the following Baby program loads the (negation of the) number in address 20, then stores a copy of it into address 21:</p>&#13;
<pre>01: LDN 20&#13;
02: STO 21&#13;
03: HLT&#13;
20: NUM -10&#13;
21: NUM 0</pre>&#13;
<p class="indent">In this example, the number –10 is initially placed at address 20, but it gets loaded into the CPU as +10, its inverse, due to the Baby’s automatic negation of loaded data. This number 10 is then stored to address 21, overwriting the 0 initially placed there. Note that the executable program is stored in addresses 01 through 03, and is terminated with <code>HLT</code>; higher addresses are used for data storage to avoid the risk of executing data.</p>&#13;
<h4 class="h4" id="lev142"><em>Arithmetic</em></h4>&#13;
<p class="noindent">The Baby has one arithmetic instruction: subtraction. It works like Pascal’s calculator: you first load one number into the CPU with a load instruction, then you give a <code>SUB</code> instruction that subtracts a second number from it. For example, the following program computes 10 – 3 = 7:</p>&#13;
<pre>01: LDN 20&#13;
02: SUB 21&#13;
03: STO 22&#13;
04: LDN 22&#13;
05: HLT&#13;
20: NUM -10&#13;
21: NUM 3&#13;
22: NUM 0</pre>&#13;
<p class="indent">The integers –10 and 3 are placed in addresses 20 and 21 by lines 20 and 21 when the whole program is first loaded into memory. Line 1 loads the (negated) integer from address 20 into the CPU. Line 2 subtracts the integer from address 21 from it. Line 3 stores the result in address 22, overwriting the 0 initially placed there.</p>&#13;
<h4 class="h4" id="lev143"><em>Jumps</em></h4>&#13;
<p class="noindent">The <code>JMP</code> instruction makes program execution jump to the line whose address is one plus the number stored at the address given in the instruction. This operation is called an <em>indirect jump</em>, as opposed to a <em>direct jump</em>, which would encode the target address itself as part of the instruction, instead of, as in this case, the <em>location</em> of the target address. For example, consider the following program:</p>&#13;
<span epub:type="pagebreak" id="page_159"/>&#13;
<pre>01: LDN 20&#13;
02: SUB 21&#13;
03: SUB 22&#13;
04: STO 20&#13;
05: JMP 23&#13;
06: HLT&#13;
20: NUM 0&#13;
21: NUM 0&#13;
22: NUM -1&#13;
23: NUM 0</pre>&#13;
<p class="indent">Here, the <code>JMP 23</code> instruction at line 05 will cause a jump to line 01, because the integer 0 is stored at address 23, and 1 is the number after 0. This program loops and runs forever as a result of the <code>JMP</code> instruction.</p>&#13;
<h4 class="h4" id="lev144"><em>Branches</em></h4>&#13;
<p class="noindent">Branching in the Baby is performed by the <code>SKN</code> instruction (skip next), which has no operand. <code>SKN</code> tests whether the current result is negative. If so, it skips the next instruction, moving to the one after it. <code>SKN</code> is usually paired with a jump (<code>JMP</code>) in the next instruction to create something similar to an if statement. If the result is negative, then <code>SKN</code> skips over the <code>JMP</code> instruction in the next line, and the program continues running from the line after it. If the result is positive, the jump is made and we continue running somewhere else in the program. For example, consider the following Baby program:</p>&#13;
<pre>01: LDN 20&#13;
02: STO 23&#13;
03: SKN&#13;
04: JMP 21&#13;
05: LDN 22&#13;
06: SUB 23&#13;
07: STO 23&#13;
08: HLT&#13;
20: NUM -10&#13;
21: NUM 6&#13;
22: NUM 0&#13;
23: NUM 0</pre>&#13;
<p class="indent">This program computes the absolute value of an integer input from address 20 and stores the result in address 23. That is, if the input is either –10 or 10, then the output will be 10; any negative sign is removed. Lines 03 and 04 are the <code>SKN-JMP</code> pair.</p>&#13;
<h3 class="h3" id="lev145">Assemblers</h3>&#13;
<p class="noindent">The programs we’ve been looking at for the Baby—and those seen previously for the Analytical Engine—are written using human-readable ASCII <span epub:type="pagebreak" id="page_160"/>symbols spelling out mnemonics such as <code>LDN</code> for “load negated,” and decimal or hex numerals. Such notations are known as <em>assembly languages</em> or just <em>assembly</em>. CPUs don’t understand such symbols; they require binary encodings of them, the <em>machine code</em>.</p>&#13;
<p class="indent">For the Analytical Engine, machine code takes the form of punches on punch cards, and the human programmer needs to manually translate their human-readable mnemonics into these binary punches before running their program. Similarly, for von Neumann machines such as the Baby, programs need to be translated into binary machine code and then placed into RAM before the CPU can execute them. The original Baby programmers had to do this by hand, using a pencil to work out the machine code, then a system of electronic switches to copy the machine code into RAM before turning on the CPU.</p>&#13;
<p class="indent">If you’re programming a modern implementation of the Baby—or any other computer—in assembly today, you don’t need to do the translation manually; there are other programs, called <em>assemblers</em>, that automate the process, translating human-readable assembly programs into machine code for you. A file of 0s and 1s corresponding to machine code is called an <em>executable</em>, as it can be executed directly by the CPU once copied into RAM. Multiple assembly languages are possible for the same target machine. For example, they could use different mnemonics for the instructions (as we have in this book compared to other implementations of the Baby).</p>&#13;
<p class="indent">The Baby’s machine code uses one 32-bit word per instruction. The lowest 13 bits are called the <em>operand</em> and encode the numerical value used by the instruction (or are ignored for instructions that don’t come with a number). The next 3 bits are known as the <em>opcode</em> and encode the type of instruction, obtained by direct translation of the assembler mnemonics, as in <a href="ch07.xhtml#ch07tab1">Table 7-1</a>. The remaining 16 bits are ignored.</p>&#13;
<p class="tabcap" id="ch07tab1"><strong>Table 7-1:</strong> The Manchester Baby Opcodes</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:85%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Opcode</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Mnemonic</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><code>JMP</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><code>JRP</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">2</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><code>LDN</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">3</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><code>STO</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">4</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><code>SUB</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">5</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><code>SUB</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">6</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><code>SKN</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">7</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><code>HLT</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The following listing is an assembler for the Baby written in Python. If you know Python, you’ll see how a dictionary is used to translate the instructions to opcodes, and how conversions between decimal, hex, and binary are used on the operands.</p>&#13;
<pre>import re&#13;
f = open("TuringLongDivision.asm")&#13;
for_logisim = False #change to True to output hex for logisim RAM&#13;
dct_inst = dict()&#13;
dct_inst['JMP'] = 0&#13;
dct_inst['JRP'] = 1&#13;
dct_inst['LDN'] = 2&#13;
dct_inst['STO'] = 3&#13;
dct_inst['SUB'] = 4&#13;
dct_inst['SKN'] = 6&#13;
dct_inst['HLT'] = 7&#13;
loc = 0&#13;
if for_logisim:&#13;
  print("v2.0 raw")    #header for logisim RAM image format&#13;
def sext(num, width):&#13;
    if num &lt; 0:&#13;
        return bin((1 &lt;&lt; (width + 1)) + num)[3:]&#13;
    return bin(num)[2:].zfill(width)&#13;
def out(binary):&#13;
  if for_logisim:&#13;
    print(hex(int(binary,2))[2:].zfill(8))&#13;
  else:&#13;
    print(binary[::-1]) #Baby convention: show bit 0 on the left&#13;
for line in f:&#13;
    asm = re.split('\s*--\s*', line.strip())[0]&#13;
    parts = asm.split()&#13;
    thisloc = int(parts[0][:-1])&#13;
    if parts[1] == 'NUM':      #data line&#13;
        code2 = sext(int(parts[2], 10), 32)&#13;
    else:                      #instruction line&#13;
        inst2 = bin(dct_inst[parts[1]]).zfill(3)[2:]&#13;
        if len(parts) &lt; 3:&#13;
            parts.append('0')&#13;
        operand2 = sext(int(parts[2], 10), 13)&#13;
        code2 = (inst2 + operand2).zfill(32)&#13;
    for addr in range(loc, thisloc):&#13;
      out('0'.zfill(32)) #fill in zeros where lines not given&#13;
    out(code2)&#13;
    loc = thisloc + 1</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>The following is a Baby program for long division, written by Alan Turing during his work testing and documenting the Baby at Manchester:</p>&#13;
<pre>00: NUM 19   -- jump address&#13;
01: LDN 31   -- Accumulator := -A&#13;
02: STO 31   -- Store as -A&#13;
03: LDN 31   -- Accumulator := -(-A) i.e., +A&#13;
04: SUB 30   -- Subtract B*2^n ; Accumulator = A - B*2^n&#13;
05: SKN      -- Skip if (A-B*2^n) is Negative&#13;
06: JMP 0    --   otherwise go to line 20 ( A-B*2^n &gt;= 0 )&#13;
07: LDN 31   -- Accumulator := -(-A)&#13;
08: STO 31   -- Store as +A&#13;
09: LDN 28   -- Accumulator := -Quotient&#13;
10: SUB 28   -- Accumulator := -Quotient - Quotient (up-shift)&#13;
11: STO 28   -- Store -2*Quotient as Quotient (up-shifted)&#13;
12: LDN 31   -- Accumulator := -A&#13;
13: SUB 31   -- Accumulator := -A-A (up-shift A)&#13;
14: STO 31   -- Store -2*A (up-shifted A)&#13;
15: LDN 28   -- Accumulator := -Quotient&#13;
16: STO 28   -- Store as +Quotient (restore shifted Quotient)&#13;
17: SKN      -- Skip if MSB of Quotient is 1 (at end)&#13;
18: JMP 26   --   otherwise go to line 3 (repeat)&#13;
19: HLT      -- Stop ; Quotient in line 28&#13;
20: STO 31   -- From line 6 - Store A-B*2^n as A&#13;
21: LDN 29   -- Routine to set bit d of Quotient&#13;
22: SUB 28   --   and up-shift&#13;
23: SUB 28   --   Quotient&#13;
24: STO 28   -- Store -(2*Quotient)-1 as Quotient&#13;
25: JMP 27   -- Go to line 12&#13;
26: NUM 2    -- jump address&#13;
27: NUM 11   -- jump address&#13;
28: NUM 0    -- (Answer appears here, shifted up by d bits)&#13;
29: NUM 536870912 -- 2^d where d=31-n, see line 30 for n&#13;
30: NUM 20   -- B (Divisor*2^n) (example: 5*2^2=20)&#13;
31: NUM 36   -- A (initial Dividend) (example: 36/5=7)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>The following shows the machine code for Turing’s program, as generated by the Python assembler:</p>&#13;
<pre>11001000000000000000000000000000&#13;
11111000000000100000000000000000&#13;
11111000000001100000000000000000&#13;
11111000000000100000000000000000&#13;
01111000000000010000000000000000&#13;
00000000000000110000000000000000&#13;
00000000000000000000000000000000&#13;
11111000000000100000000000000000&#13;
11111000000001100000000000000000&#13;
00111000000000100000000000000000&#13;
00111000000000010000000000000000&#13;
00111000000001100000000000000000&#13;
11111000000000100000000000000000&#13;
11111000000000010000000000000000&#13;
11111000000001100000000000000000&#13;
00111000000000100000000000000000&#13;
00111000000001100000000000000000&#13;
00000000000000110000000000000000&#13;
01011000000000000000000000000000&#13;
00000000000001110000000000000000&#13;
11111000000001100000000000000000&#13;
10111000000000100000000000000000&#13;
00111000000000010000000000000000&#13;
00111000000000010000000000000000&#13;
00111000000001100000000000000000&#13;
11011000000000000000000000000000&#13;
01000000000000000000000000000000&#13;
11010000000000000000000000000000&#13;
00000000000000000000000000000000&#13;
00000000000000000000000000000100&#13;
00101000000000000000000000000000&#13;
00100100000000000000000000000000</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_163"/>In this display of the binary machine code, the bit positions are printed with the zeroth bit on the left (contrary to modern convention), so the opcodes appear in the three bits just to the left of the middle of each word, with the operands to their left. This was the format used by the historical Baby, so our machine code could be entered using this convention.</p>&#13;
<p class="indent">The test program and the machine code each have 32 lines so that they exactly and unambiguously fill the Baby’s 32 addresses of memory. The programmer needs to put something in all 32 addresses so those that aren’t in use are explicitly filled with zeros. Note that the line numbers aren’t encoded in the machine code; rather, they specify which address the machine code will be placed at. Also note that the data lines are translated as single 32-bit numbers, as <code>NUM</code> isn’t an instruction but rather just a comment to tell the assembler that the line contains raw data. The Baby uses two’s complement, so hex values such as <code>ffff0000</code> represent negative integers.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>Until the mid-1990s, many large applications and games were written by human programmers in assembly language, including</em> Street Fighter II <em>and the RISC OS operating system. Most modern programming isn’t done in assembly language, but rather in a higher-level language such as C, C++, or Python. Programs written in these languages are first converted to assembly code by a compiler, before being assembled by an assembler.</em></p>&#13;
<h3 class="h3" id="lev146">The Baby’s Internal Structures</h3>&#13;
<p class="noindent">Now we’ll turn to the Baby’s internal structures. As we did for the Analytical Engine, we’ll first introduce the subcomponents within the digital CPU, and then consider the dynamics of how they behave and interact to execute programs. The main digital CPU substructures are exactly the same as for the Analytical Engine: registers, an arithmetic logic unit (ALU), and a control unit (CU). They have the same functions as in the Analytical Engine but are built from the digital logic simple machines we studied in the previous chapter, rather than from Babbage’s mechanical simple machines.</p>&#13;
<p class="indent">We won’t follow the exact implementation of the original Manchester Baby here; rather, I’ll show general digital logic implementations that <em>could</em> <span epub:type="pagebreak" id="page_164"/>be used to implement the Baby’s programmer interface in a more modern style. These implementations are built from simple machines of digital logic, which in turn are built from logic gates that could be implemented equally well using modern transistors or the Baby’s original vacuum tubes.</p>&#13;
<h4 class="h4" id="lev147"><em>Registers</em></h4>&#13;
<p class="noindent">Registers are fast word-length memory, usually made today as arrays of D-type flip-flops, which live inside the CPU and are readable and writable by the CU and ALU. Most CPUs include several types of register used for different purposes.</p>&#13;
<p class="indent">The sizes of the registers in a CPU are usually taken to define the CPU’s word length; for example, an 8-bit machine uses 8-bit words that are stored in 8-bit registers, and a 32-bit machine uses 32-bit words that are stored in 32-bit registers. The Baby is a 32-bit machine in this sense. The words use the data representations seen in <a href="ch02.xhtml">Chapter 2</a>, which require an array of bits to store numbers, text, and other data.</p>&#13;
<p class="indent">Like the individual flip-flops that compose them, registers must be timed to enable correct synchronization of reads and writes. An update signal can be sent to the clock inputs of all the flip-flops making up the register. Usually writes to the register are performed on the rising edge of this signal. Each register also continually outputs its latest stored value for reading as a set of parallel wires, regardless of the updates. The register structure is shown in <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>. The write is triggered when you press the button.</p>&#13;
<div class="image"><img id="ch07fig1" src="../images/f0164-01.jpg" alt="Image" width="570" height="401"/></div>&#13;
<p class="figcap"><em>Figure 7-1: A 3-bit register made from flip-flops</em></p>&#13;
<p class="indent">Registers can also be notated using a single symbol suggesting a pile of flip-flops, as in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_165"/><img id="ch07fig2" src="../images/f0165-01.jpg" alt="Image" width="462" height="270"/></div>&#13;
<p class="figcap"><em>Figure 7-2: A 4-bit register as a single symbol, connected to input switches, write update button, and output LEDs</em></p>&#13;
<p class="indent">Here, the D input and Q output are each groups of wires, shown as thick lines, then split into single wires.</p>&#13;
<h4 class="h4a"><strong>User Registers</strong></h4>&#13;
<p class="noindent"><em>User registers</em> are usually the only registers that are visible to the assembly language programmer, who can give instructions to act on their contents.</p>&#13;
<p class="indent">An <em>accumulator</em> is a user register that functions both as an input and to store the results of calculations in the same place. As we’ve seen, Pascal’s calculator is one big accumulator because it stores both one of the inputs to an addition and also its result, destroying the original representation of the input in the process. Your desktop calculator is also an accumulator: it only ever stores one number, the current result seen on the screen, which you can add to or multiply by, and which is updated to store the result. For example, if you enter 2, this is stored in the accumulator. If you then enter +3 the accumulator stores and shows the result 5. The original value 2 and the operation +3 are lost, and only the accumulated result is available.</p>&#13;
<p class="indent"><em>Accumulator architectures</em> are those that have only a single user register that acts as an accumulator. The Baby uses this simple style of architecture. This forces all computation to be done in the accumulator style because there are no other registers in which to keep inputs separate from outputs. By contrast, more complex CPUs may have other user registers, in addition to or instead of an accumulator.</p>&#13;
<h4 class="h4a"><strong>Internal Registers</strong></h4>&#13;
<p class="noindent">In addition to the user registers, most CPUs require further registers for their own internal operations. These <em>internal registers</em> may be invisible to the user, so you can’t write assembly programs that access or modify them. Rather, they’re used to make the CPU itself work, and to enable it to read and execute user programs. Let’s look at the two most important internal registers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_166"/>A CPU needs to keep track of where it currently is in the execution of its program. In the Analytical Engine, the current line of the program was stored using the mechanical state of the program card reader. Like typewriter paper, the program was mechanically fast-forwarded and rewound so that the current line was positioned on the reader. In an electronic CPU, there is no mechanically moving state, so we must instead keep track of where we are in the program by storing the current line number in a register, called the <em>program counter</em> (<em>PC</em> in the listings in this chapter). As we’ve seen, von Neumann architectures—such as the Baby and most modern computers—store the program in main memory, along with other data, so these “line numbers” are actually memory addresses that store the instructions of the program.</p>&#13;
<p class="indent">The <em>instruction register (IR)</em> stores a copy of the current instruction, copied in from its address (as kept in the program counter) in memory.</p>&#13;
<h4 class="h4" id="lev148"><em>Arithmetic Logic Unit</em></h4>&#13;
<p class="noindent">Just like the Analytical Engine’s ALU, a digital logic–based ALU consists of a collection of simple machines, each performing one kind of arithmetic operation. Due to a quirk in its hardware, the original Baby had only a subtractor, but here we’ll build a more general and powerful ALU that also includes addition, multiplication, and division. <a href="ch07.xhtml#ch07fig3">Figure 7-3</a> shows a 32-bit ALU with these operations.</p>&#13;
<div class="image"><img id="ch07fig3" src="../images/f0166-01.jpg" alt="Image" width="1100" height="505"/></div>&#13;
<p class="figcap"><em>Figure 7-3: A 32-bit, four-operation ALU</em></p>&#13;
<p class="indent">Here there are two data inputs, <em>a</em> and <em>b</em>, each containing a 32-bit, two’s complement integer. They’re both sent to all four simple arithmetic machines, a subtractor, adder, multiplier, and divider, each of which <span epub:type="pagebreak" id="page_167"/>calculates an output. Just one of these outputs is then selected and passed to the ALU’s output, <em>r</em>. To choose which arithmetic operation you want to do, place its 2-bit code on the <em>c</em> input. The decoder then activates one of the four 32-bit multiplexers, enabling the desired operation’s output to be passed to and through the 32-bit OR gate array. A copy of the final output from the OR gate array is passed into a <em>comparator</em>, which tests if the number is zero and outputs a single status flag with this Boolean.</p>&#13;
<p class="indent">The comparator can be implemented simply by NOR gating together all of the bits in the number. More advanced ALUs often test for other interesting properties of the result, such as being positive or negative, having created an overflow (which can be seen on the carry out lines of the simple machines), or division by zero; they then output a set of flags rather than just this zero test.</p>&#13;
<p class="indent">Note that we could build this ALU with less silicon by using a single multiplexer with 2-bit input to select directly between the four arithmetic machines. Duplication of digital logic could be reduced by sharing structures between operations—for example, using two’s complement enables adders to be reused as subtractors. You might also be concerned about the waste of energy from running all of the arithmetic options on each set of inputs but throwing all but one result away. You could find ways to redesign the network to reduce this energy usage. However, I’ve chosen the present structure for educational reasons, as it will help you to more easily understand CUs in the next section.</p>&#13;
<h4 class="h4" id="lev149"><em>Control Unit</em></h4>&#13;
<p class="noindent">Digital logic CUs implement the same concept as Babbage’s timing barrel, acting like a musical conductor to trigger all of the other CPU components at the right times. There are many ways to do this, so CUs vary far more than registers and ALUs. They’re usually considered to be the hardest and most central part of CPU design. We’ll choose a particular style here for ease of understanding rather than for computational or energy efficiency.</p>&#13;
<p class="indent">This style is based on two structures: first, a counter that, like Babbage’s barrel, rotates regularly, and whose value is used to time the required events; second, a switching mechanism that determines the type of event to be triggered and makes temporary connections between components—such as registers, the ALU, and RAM—in response. In Babbage’s machine, these connections were made and broken using mechanical levers. For our digital logic version, we’ll use multiplexers, as we did in the ALU. These multiplexers have two data inputs, each of word length—32 bits for the Baby. One is hardwired to zeros and the other is from the temporary input source. They have a single-bit switch that switches between relaying the temporary input onto the output and sending all zeros to the output. <a href="ch07.xhtml#ch07fig4">Figure 7-4</a> shows how this works.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_168"/><img id="ch07fig4" src="../images/f0168-01.jpg" alt="Image" width="479" height="177"/></div>&#13;
<p class="figcap"><em>Figure 7-4: A multiplexer used to enable or disable a connection of 32 wires</em></p>&#13;
<p class="indent">As in the ALU, where multiple sources can potentially connect to a destination, they each get their own multiplexer. Then an OR array combines the multiplexer outputs, allowing the non-zero output to pass through.</p>&#13;
<p class="indent">We’ll create a sequence of temporary connections between components. Some of these connections can be triggered simply by the time shown on the counter. This can be done with a decoder, taking the time as input and activating a particular trigger wire as output. Other connections need to be triggered by a combination of a time and some other value, such as the identity of the current instruction. These can be done by AND gating the appropriate trigger wire to signals representing the other required conditions. <a href="ch07.xhtml#ch07fig5">Figure 7-5</a> shows an example of this structure.</p>&#13;
<div class="image"><img id="ch07fig5" src="../images/f0168-02.jpg" alt="Image" width="1125" height="538"/></div>&#13;
<p class="figcap"><em>Figure 7-5: A minimal CU based on a 3-bit counter, a decoder, and multiplexer switches</em></p>&#13;
<p class="indent">The 3-bit counter and decoder on the left form the sequencer. Using 3 bits gives us 2<sup>3</sup> = 8 times, from 0 to 7, looping back to 0 after each 7. The figure shows triggers only at ticks 0, 1, and 7. The triggers at ticks 0 and 1 (the upper two outputs from the decoder) depend only on the time and make connections between 32-bit wire groups. At tick 7, there are two possible triggers, which depend on conditions cond1 and cond2 being met, respectively, represented by the two switches near the bottom-left of the figure. Note that either, neither, or both of these conditions (and thus <span epub:type="pagebreak" id="page_169"/>triggers) could be active at this time. The OR symbol here represents an array of 32 OR gates. It allows two different inputs to be connected to the same shared output (SO) on different triggers. (Triggers from times 2 through 6 inclusive are omitted in this figure, but you can imagine those wires from the decoder connecting to similar triggers.)</p>&#13;
<p class="indent">Let’s introduce a little extra notation at this point to help make our diagrams more readable. <a href="ch07.xhtml#ch07fig6">Figure 7-6</a> shows exactly the same minimal CU, but introduces <em>tunnels</em>, which are named points (t0 to t7 and c0 to c1) taking the place of wires. All tunnels having the same name are assumed to be connected to one another. For example, the t0 tunnel coming out of the decoder connects to the t0 tunnel going into the multiplexer near the top right of the figure.</p>&#13;
<div class="image"><img src="../images/f0169-01.jpg" alt="Image" width="1120" height="360"/></div>&#13;
<div class="image"><img id="ch07fig6" src="../images/f0169-02.jpg" alt="Image" width="1081" height="600"/></div>&#13;
<p class="figcap"><em>Figure 7-6: The same minimal CU as in <a href="ch07.xhtml#ch07fig5">Figure 7-5</a>, redrawn using tunnel notation</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>This tunnel notation avoids the need to draw the rat’s nest of wires formed as the CU sends its triggers all over the rest of the CPU. We’ve also encapsulated the 3-bit counter into a single block, CTR3, as provided off-the-shelf by LogiSim. (This block has some additional inputs and features that we don’t use here.)</p>&#13;
<h3 class="h3" id="lev150">Putting It All Together</h3>&#13;
<p class="noindent">Now that we’ve seen each of the basic ingredients of a Baby implementation, let’s put them all together—along with suitably timed CU dynamics—to build a complete, functioning Baby. We’ll do this by considering the three main stages of operation—fetch, decode, and execution—in turn, just as we did when we discussed the Analytical Engine in <a href="ch03.xhtml">Chapter 3</a>.</p>&#13;
<h4 class="h4" id="lev151"><em>Fetch</em></h4>&#13;
<p class="noindent">The aim of the fetch stage is to bring a copy of the next instruction from RAM into the IR in the CPU. Fetching assumes that the address of the next instruction is already in the program counter. When the CPU is first turned on, the program counter—like all registers—is initialized to 0, but is immediately incremented to 1, so the first instruction must be stored at address 1 and will be fetched.</p>&#13;
<p class="indent">To perform a fetch, the program counter is temporarily connected to the address lines of RAM, on tick 1. The data out lines of RAM can be permanently connected to the IR data in, but the IR takes only a copy of the word from these lines when write-enabled and clocked at tick 2. The network in <a href="ch07.xhtml#ch07fig7">Figure 7-7</a> is set to perform fetch for the Baby’s 32×32 RAM (32 = 2<sup>5</sup> addresses, each containing one 32-bit word) by making these connections on ticks 1 and 2 of its eight-count control cycle, and breaking them on the other steps. In our Baby, the program counter is a 5-bit register and the IR is a 32-bit register.</p>&#13;
<div class="image"><img id="ch07fig7" src="../images/f0170-01.jpg" alt="Image" width="817" height="348"/></div>&#13;
<p class="figcap"><em>Figure 7-7: A fetch, triggered on ticks 1 and 2</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>We can write the fetch sequence as:</p>&#13;
<pre>t1: RAM_A &lt;- PC&#13;
t2: IR &lt;- RAM_Dout</pre>&#13;
<p class="noindent">This style of notation is a form of <em>register transfer language (RTL)</em>. The symbols before the colon on each line are the triggers, which in this case are ticks 1 and 2. The arrows denote that a temporary connection from a source to a destination is made only when the trigger is active. The arrows thus correspond to the multiplexers used in our implementation style, with the triggers corresponding to the switching inputs of these multiplexers.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>RTL is not assembly language or machine code. It’s a lower-level description of how the CPU works, whose function is ultimately to execute the machine code program written by the user and stored in RAM.</em></p>&#13;
<h4 class="h4" id="lev152"><em>Decode</em></h4>&#13;
<p class="noindent">We now have a copy of the next instruction sitting in the IR. It consists of a word of machine code, with some bits specifying the opcode and the other bits possibly containing zero, one, or more operands. In the Baby, bits 13 to 15 are the opcode, bits 0 to 12 are a single operand for some instructions, and the remaining 16 bits aren’t used. This encoding now needs to be decoded. We need to split up the opcode and operand, then convert the opcode into an activation signal. <a href="ch07.xhtml#ch07fig8">Figure 7-8</a> shows our implementation.</p>&#13;
<div class="image"><img id="ch07fig8" src="../images/f0171-01.jpg" alt="Image" width="507" height="399"/></div>&#13;
<p class="figcap"><em>Figure 7-8: Decoding, triggered at tick 2</em></p>&#13;
<p class="indent">The IR output is first split into three sets of wires, for the first 13, next 3, and remaining 16 bits. The middle 3 bits, containing the opcode, are connected to a 3-bit decoder. The decoder activates one of its 2<sup>3</sup> = 8 output lines, which is connected to a tunnel and will be used as a condition to trigger multiplexers in other steps. These tunnels are named as their corresponding assembly mnemonics. The 13 operand bits of the IR are further split into the 5 lower-order bits, which are used for address selection and will <span epub:type="pagebreak" id="page_172"/>have wires connected to them later, and the 8 higher-order bits, which have nothing to address and are ignored.</p>&#13;
<p class="indent">There’s no sequential logic used here, so decoding happens roughly instantaneously once the IR content is updated on tick 2.</p>&#13;
<h4 class="h4" id="lev153"><em>Execute</em></h4>&#13;
<p class="noindent">Unlike fetching and decoding, what happens during the execute stage depends on the instruction that has been fetched and decoded. Different instructions specify the activation of different structures that do different things: load, store, arithmetic, and program flow control. We’ll look at how to execute each of these possible actions in turn.</p>&#13;
<h4 class="h4a"><strong>Load</strong></h4>&#13;
<p class="noindent">To execute a load, we temporarily connect the operand to the RAM’s address input at tick 3, and then temporarily connect the RAM’s data output to the accumulator (Acc) at tick 4. These tick numbers are chosen to take place after the previous fetch and decode. We can write this in RTL style as:</p>&#13;
<pre>t3, LDN: RAM_A &lt;- IR[operand]&#13;
t4, LDN: Acc &lt;- -RAM_Dout</pre>&#13;
<p class="indent">Note that the triggers before the colon now include both a tick and the <code>LDN</code> condition. The square brackets in <code>IR[operand]</code> indicate that only the operand bits of IR are to be used, rather than the entire register content.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig9">Figure 7-9</a> shows the digital logic for our Baby implementation’s load. (As the Baby’s load operation also negates the loaded values, we pass the RAM data out through a negator on its way to the accumulator. This would not usually be done on a modern machine.)</p>&#13;
<p class="indent">In an accumulator architecture such as the Baby, the load always places the data from RAM into the accumulator register. In more complex architectures with more user registers, an additional operand is needed to specify the target, and more digital logic is needed to connect the right register to the data line.</p>&#13;
<h4 class="h4a"><strong>Store</strong></h4>&#13;
<p class="noindent">Storing a value from the CPU into memory is similar but opposite to loading. In the Baby, the value to be stored is always taken from the accumulator.</p>&#13;
<p class="indent">At tick 3, we temporarily connect the STO instruction’s operand (the address to store at) to the RAM’s address lines. The accumulator output can be permanently connected to the RAM data input, but only write-enabled at tick 3. The RTL for this is:</p>&#13;
<pre>t3, STO: RAM_A &lt;- IR[operand]&#13;
t3, STO: RAM_Din &lt;- Acc</pre>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig10">Figure 7-10</a> shows the digital logic implementing this for our Baby.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_173"/><img id="ch07fig9" src="../images/f0173-01.jpg" alt="Image" width="1097" height="583"/></div>&#13;
<p class="figcap"><em>Figure 7-9: Executing a load, triggered at ticks 3 and 4</em></p>&#13;
<div class="image"><img id="ch07fig10" src="../images/f0173-02.jpg" alt="Image" width="906" height="422"/></div>&#13;
<p class="figcap"><em>Figure 7-10: Executing a store, triggered at tick 3</em></p>&#13;
<p class="indent">In architectures with more user registers, another operand can be used to specify which register’s contents are to be stored, and more switching logic is then needed to connect the right register to the data line.</p>&#13;
<h4 class="h4a"><strong>Arithmetic</strong></h4>&#13;
<p class="noindent">To execute an ALU operation, the CU makes temporary connections to the ALU’s inputs from CPU registers, and creates and sends an ALU command to the ALU’s command inputs. The ALU output is then temporarily connected to a destination register.</p>&#13;
<p class="indent">The Baby’s ALU is especially simple, as it contains only a subtractor. The <code>SUB</code> instruction triggers a read from RAM, similar to a load instruction, <span epub:type="pagebreak" id="page_174"/>but the RAM data is sent to the subtractor rather than to the accumulator. The subtractor takes its other input from the accumulator and writes its output back to the accumulator.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig11">Figure 7-11</a> shows our Baby ALU implementation. The RAM read is triggered on tick 3, and the accumulator update on tick 4. The subtractor is on the far left of the figure.</p>&#13;
<div class="image"><img id="ch07fig11" src="../images/f0174-01.jpg" alt="Image" width="1120" height="597"/></div>&#13;
<p class="figcap"><em>Figure 7-11: Executing an ALU operation, triggered at ticks 3 and 4</em></p>&#13;
<p class="indent">This can also be described in RTL as:</p>&#13;
<pre>t3, SUB: RAM_A &lt;- IR[operand]&#13;
t4, SUB: Acc &lt;- Acc - RAM_Dout</pre>&#13;
<p class="indent">More complex architectures having more arithmetic operations than just subtraction would package them up into a single ALU structure, with select lines to specify which to activate, as you saw in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>. The decoder would then need to recognize multiple different arithmetic opcodes, and route each one through some logic to activate the corresponding selection.</p>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_175"/><strong>Flow Control</strong></h4>&#13;
<p class="noindent">At the start of each instruction, the Baby moves to the next address (line) of the program. This can be done by incrementing (adding 1 to) the program counter at tick 0.</p>&#13;
<p class="indent">If the current instruction is a flow control instruction—that is, a jump or branch—then its execution step also needs to update the program counter to get it ready for the next instruction.</p>&#13;
<p class="indent">Modern (direct) jump instructions contain the line number to jump to in their operand, so they can be implemented by copying the operand directly into the program counter. As we’ve seen, however, the Baby uses an indirect jump instruction, <code>JMP</code>, in which the operand contains the <em>address</em> that in turn contains the actual jump target. To implement this indirect jump we thus first attach the operand to the RAM address lines at tick 4, then attach the RAM data lines to the program counter at tick 5.</p>&#13;
<p class="indent">The Baby also has a relative jump, <code>JRP</code>, which works similarly to <code>JMP</code> except that the address in the operand contains a number of lines to advance the program counter, rather than an absolute address.</p>&#13;
<p class="indent">For the branch instruction, <code>SKN</code>, we check its condition and behave as normal if it’s false, or increment the program counter an extra time if it’s true, to skip over one line of code. (Usually the skipped line will be chosen by the programmer to be a jump to another part of the code.) To implement this, we send the output of the accumulator to a comparator that tests if it’s less than zero. The truth or falsehood of this condition is then used (thanks to Boole) as an integer 0 or 1, which is added to the program counter at tick 5 when the branch instruction is active.</p>&#13;
<p class="indent">If the current instruction isn’t a control flow instruction (that is, if it’s <code>SUB</code>, <code>LDN</code>, or <code>STO</code>), then no further changes are made to the program counter. This is implemented simply by wiring the program counter’s output directly to its input at tick 5.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig12">Figure 7-12</a> shows our Baby implementation of flow control. In RTL notation, this corresponds to:</p>&#13;
<pre>t0: PC &lt;- PC + 1&#13;
t4, JMP: RAM_A &lt;- IR[operand]&#13;
t4, JRP: RAM_A &lt;- IR[operand]&#13;
t5, SKN, (Acc&lt;0): PC &lt;- PC + 1&#13;
t5, JMP: PC &lt;- RAM_Dout&#13;
t5, JRP: PC &lt;- PC + RAM_Dout</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>Once the program counter has been updated by any of the means described here, the fetch-decode-execute cycle is complete, and everything is set up for the next cycle to begin.</p>&#13;
<div class="image"><img id="ch07fig12" src="../images/f0176-01.jpg" alt="Image" width="1122" height="1015"/></div>&#13;
<p class="figcap"><em>Figure 7-12: Program flow control, triggered at ticks 0, 4, and 5</em></p>&#13;
<h4 class="h4" id="lev154"><em>Complete Baby Implementation</em></h4>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07fig13">Figure 7-13</a> shows our complete, working Baby CPU, with all of the above systems shown together. In the lower-left it adds a register and lamp that activate when the halt instruction is executed, preventing any further execution. If you get tired of manually triggering the clock, it also adds a switch connecting the clock signal to an oscillator.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_177"/><img id="ch07fig13" src="../images/f0177-01.jpg" alt="Image" width="1487" height="844"/></div>&#13;
<p class="figcap"><em>Figure 7-13: A complete, working Baby implementation, including sequencer, fetch, decode, execute, and control flow logic. The RAM contents are now shown in full.</em></p>&#13;
<span epub:type="pagebreak" id="page_178"/>&#13;
<pre>t0: PC &lt;- PC + 1&#13;
t1: RAM_A &lt;- PC&#13;
t2: IR &lt;- RAM_Dout&#13;
t3, LDN: RAM_A &lt;- IR[operand]&#13;
t3, STO: RAM_A &lt;- IR[operand]&#13;
t3, STO: RAM_Din &lt;- Acc&#13;
t3, SUB: RAM_A &lt;- IR[operand]&#13;
t4, SUB: Acc &lt;- Acc - RAM_Dout&#13;
t4, LDN: Acc &lt;- -RAM_Dout&#13;
t4, JMP: RAM_A &lt;- IR[operand]&#13;
t4, JRP: RAM_A &lt;- IR[operand]&#13;
t5, SKN, (Acc&lt;0): PC &lt;- PC + 1&#13;
t5, JMP: PC &lt;- RAM_Dout&#13;
t5, JRP: PC &lt;- PC + RAM_Dout</pre>&#13;
<p class="indent">We now have a complete computer in digital logic, able to execute machine code programs in RAM.</p>&#13;
<h3 class="h3" id="lev155">Summary</h3>&#13;
<p class="noindent">The purpose of a digital logic CPU is to execute machine code programs, which can be assembled from human-readable assembly language. These programs need to be placed into memory before the CPU starts its work. They consist of a series of instructions that are in turn read into the CPU and executed.</p>&#13;
<p class="indent">CPUs can initially scare those trying to understand them. Even a minimal example such as our Baby might take thousands of transistors; modern CPU chips can contain billions. But you’ve seen in this chapter that the basic structure isn’t so complex if you think hierarchically, like an architect. From this perspective, you already saw how to build a variety of simple machines that each perform a basic task; a basic CPU then just connects a small number of these simple machines.</p>&#13;
<p class="indent">The CU can be built from a sequencer, which triggers the fetch, decode, and execute stages. The execute stage is the hardest one to implement, as it involves different actions depending on what instruction was decoded. The sub-steps of the execute stage therefore need some additional logic to activate the different options.</p>&#13;
<p class="indent">This chapter has shown roughly how the Manchester Baby was and can be put together. The architecture we built still forms the basic plan for many modern CPUs. Pressures from Moore’s law have complicated this plan, however. They prevent modern machines from simply being clocked faster, but they allow them to use many more transistors. In the next chapter you’ll see some of the more complex uses that modern CPUs can make of these extra transistors.</p>&#13;
<h3 class="h3" id="lev156"><span epub:type="pagebreak" id="page_179"/>Exercises</h3>&#13;
<h4 class="h4a"><strong>Build a Baby</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Build the Baby design from <a href="ch07.xhtml#ch07fig13">Figure 7-13</a> in LogiSim Evolution.</li>&#13;
<li class="tm">Once you start working at this level of complexity with sequential logic, it’s very easy and common to create hardware bugs around trigger timing. Working architects spend a lot of their time debugging timing issues. The hardware equivalent of a debugger is a <em>chronogram</em> (<a href="ch07.xhtml#ch07fig14">Figure 7-14</a>), a diagram that plots the state of several wires in the system over time. LogiSim Evolution has a built-in tool for generating these (<strong>Simulate ▸ Timing diagram</strong>). Find out how to use it to test some of the sequential subcircuits from the Baby. Recall that sequential logic—write enables for RAM and registers, and RAM read addresses—is usually triggered at the <em>instant</em> the clock signal rises from 0 to 1, while combinatorial logic is active at all times. There are also hardware logic analyzers that will capture and display similar data from breadboards, either standalone or sending the data to your PC for analysis.</li>&#13;
</ol>&#13;
<div class="image"><img id="ch07fig14" src="../images/f0179-01.jpg" alt="Image" width="782" height="289"/></div>&#13;
<p class="figcap"><em>Figure 7-14: A LogiSim chronogram</em></p>&#13;
<h4 class="h4a"><strong>Programming the Baby</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Assemble the test programs—including Turing’s division program—discussed in this chapter, and run them in your LogiSim Baby. Use the Python assembler provided, with the <code>for_logisim</code> flag on line 3 set to True. Save the output in a text file and load it as a RAM image in LogiSim by right-clicking the RAM and selecting <strong>Load Image</strong>. You can step through CPU cycles manually by clicking the clock, or by setting it to tick automatically with <strong>Simulate ▸ Auto-tick</strong> in the menu bar. Turing’s program divides 36 by 5, to give result 7 (111<sub>2</sub>), which gets stored—padded with zeros—in address 28, so it appears as E000000<sub>16</sub>. Try editing lines 29 to 31 to perform different divisions.</li>&#13;
<li class="tm">Can you explain how Turing’s code works? Remember that the Baby’s two main quirks are that it negates values when loading them, and it has only a subtractor rather than an adder. These lead to a few programming idioms.</li>&#13;
</ol>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_180"/><strong>Challenging</strong></h4>&#13;
<p class="noindent">We’ve used several layers of notational abstraction in our CPU designs: packaging up transistors, gates, and simple machines into boxes. Estimate how many logic gates, then how many transistors are used in our final design. How does the number of transistors compare with those used in the actual historical designs in <a href="ch01.xhtml">Chapter 1</a>? How could these be reduced if we preferred an implementation using less silicon rather than an educationally easy-to-understand design?</p>&#13;
<h4 class="h4a"><strong>More Challenging</strong></h4>&#13;
<p class="noindent">The Baby is a very small, simple computer, but it’s possible to extend it into a fairly serious modern machine by modifying our design. Try doing this using the following steps.</p>&#13;
<ol class="number">&#13;
<li class="tm">Increase the RAM size. To do this, you’ll need to increase the size of the addresses throughout the design.</li>&#13;
<li class="tm">Replace the Baby’s LDN with a more normal LOAD instruction, which just loads without negation. Or retain LDN and create a new LOAD in addition to it, if you want to retain back-compatibility with old code. This will lead to more complexity and silicon, but will keep existing users happy, so is representative of a typical dilemma architects face.</li>&#13;
<li class="tm">Replace the single subtraction module with a full two’s complement integer ALU, including add, subtract, multiply, and divide. Create extra instructions to trigger these operations.</li>&#13;
<li class="tm">Look at the later Manchester Mark I and Ferranti Mark I machines to see how the original Baby was actually extended to commercialization. Try to emulate them in LogiSim.</li>&#13;
</ol>&#13;
<h3 class="h3" id="lev157">Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">For the nearest we have to an official modern manual for the Manchester Baby, see the University of Manchester’s current web page, <em><a href="http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html">http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html</a></em>.</li>&#13;
<li class="tm">For the original publication describing the real Baby, see F.C. Williams, T. Kilburn, and G.C. Tootill, “Universal High-Speed Digital Computers: A Small-Scale Experimental Machine,” <em>Proceedings of the IEE <a href="part02.xhtml">Part II</a>: Power Engineering</em> 98, no. 61 (1951): 13–28.</li>&#13;
<li class="tm">For details of the later Manchester Mark I, see R.B.E. Napper, “The Manchester Mark 1 Computers,” in <em>The First Computers: History and Architectures</em>, ed. Raúl Rojas and Ulf Hashagen (Cambridge, MA: MIT Press, 2000), 365–377.</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>