<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="363" id="Page_363"/>15</span><br/>
<span class="ChapterTitle">Development Tools</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Linux is very popular with programmers, not just due to the overwhelming array of tools and environments available but also because the system is exceptionally well documented and transparent. On a Linux machine, you don’t have to be a programmer to take advantage of development tools, which is good news, because they play a larger role in managing Linux systems than in other operating systems. At the very least, you should be able to identify development utilities and have some idea of how to run them. </p>
<p><span epub:type="pagebreak" title="364" id="Page_364"/>This chapter packs a lot of information into a small space, but you don’t need to master everything here. The examples will be very simple; you don’t need to know how to write code to follow along. You can also easily skim the material and come back later. The discussion of shared libraries is likely the most important thing that you need to know, but to understand where shared libraries come from, you first need some background on how to build programs.</p>
<h2 id="h1-500402c15-0001">	15.1	The C Compiler</h2>
<p class="BodyFirst">Knowing how to use the C programming language compiler can give you a great deal of insight into the origin of the programs that you see on your Linux system. Most Linux utilities and many applications on Linux systems are written in C or C++. This chapter will primarily use examples in C, but you’ll be able to carry the information over to C++.</p>
<p>C programs follow a traditional development process: you write programs, you compile them, and they run. That is, when you write C program code and want to run it, you must <em>co</em><em>mpile</em> human-readable code into a binary low-level form that the computer’s processor understands. The code that you write is called <em>source code</em>, and can encompass many files. You can compare this to the scripting languages that we’ll discuss later, where you don’t need to compile anything.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Most distributions do not include the tools necessary to compile C code by default. If you don’t see some of the tools described here, you can install the build-essential package for Debian/Ubuntu or the “Development Tools” <var>yum</var> groupinstall for Fedora/CentOS. Failing that, try a package search for “gcc” or “C compiler.”</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The C compiler executable on most Unix systems is the GNU C compiler, <code>gcc</code> (often referred to by the traditional name <code>cc</code>), though the newer <code>clang</code> compiler from the LLVM project is gaining popularity. C source code files end with <em>.c</em>. Take a look at this single, self-contained C source code file, <em>hello.c</em>, from <em>The C Programming Language</em>, 2nd edition, by Brian W. Kernighan and Dennis M. Ritchie (Prentice Hall, 1988): </p>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World.\n");
}</code></pre>
<p>Save this source code in a file called <em>hello.c</em> and then run the compiler with this command: </p>
<pre><code>$ <b>cc hello.c</b></code></pre>
<p><span epub:type="pagebreak" title="365" id="Page_365"/>The result is an executable named <em>a.out</em>, which you can run like any other executable on the system. However, you should probably give the executable another name (such as <em>hello</em>). To do this, use the compiler’s <code>-o</code> option: </p>
<pre><code>$ <b>cc -o hello hello.c</b></code></pre>
<p>For small programs, there isn’t much more to compiling than that. You might need to add an extra library or include directory, but let’s look at slightly larger programs before getting into those topics. </p>
<h3 id="h2-500402c15-0001">15.1.1	 Compiling Multiple Source Files</h3>
<p class="BodyFirst">Most C programs are too large to reasonably fit within a single source code file. Mammoth files become too disorganized for the programmer to manage, and compilers sometimes even have trouble processing large files. Therefore, developers typically separate the source code into component pieces, giving each piece its own file. </p>
<p>When compiling most <em>.c</em> files, you don’t create an executable right away. Instead, use the compiler’s <code>-c</code> option on each file to create <em>object files</em> containing binary <em>object code</em> that will eventually go into the final executable. To see how this works, let’s say you have two files, <em>main.c</em> (which gets the program started) and <em>aux.c </em>(which does the actual work), that appear as follows:</p>
<p><em>main.c</em>:</p>
<pre><code>void hello_call();

int main() {
    hello_call();
}</code></pre>
<p><em>aux.c</em>:</p>
<pre><code>#include &lt;stdio.h&gt;

void hello_call() {
    printf("Hello, World.\n");
}</code></pre>
<p>The following two compiler commands do most of the work of building the program: creating the object files.</p>
<pre><code>$ <b>cc -c main.c</b>
$ <b>cc -c aux.c</b></code></pre>
<p>After these commands complete, you’ll have two object files: <em>main.o</em> and <em>aux.o</em>.</p>
<p><span epub:type="pagebreak" title="366" id="Page_366"/>An object file is a binary file that a processor can almost understand, except that there are still a few loose ends. First, the operating system doesn’t know how to start up an object file, and second, you likely need to combine several object files and some system libraries to make a complete program. </p>
<p>To build a fully functioning executable program from one or more object files, you must run the <em>linker</em>, the <code>ld</code> command in Unix. Programmers rarely use <code>ld</code> on the command line, however, because the C compiler knows how to run the linker program. To create an executable called <code>myprog</code> from these two object files, run this command to link them:</p>
<pre><code>$ <b>cc -o myprog main.o aux.o</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Although you can compile each source file with a separate command, the preceding example already hints that it can be hard to keep track of them all during the compiling process; this challenge gets much worse as the number of source files multiplies. The <code>make</code> system described in <span class="xref" itemid="xref_target_Section 15.2">Section 15.2</span> is the traditional Unix standard for managing and automating compiles. You’ll see how important having a system like <code>make</code> is as we deal with managing the files described in the next two sections.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Turn your attention back to the file <em>aux.c</em>. As mentioned, its code does the actual work of the program, and there can be many files like its resultant <em>aux.o</em> object file that are necessary to build the program. Now imagine that other programs might be able to make use of the routines we wrote. Could we reuse these object files? That’s where we’re headed next.</p>
<h3 id="h2-500402c15-0002">15.1.2	 Linking with Libraries</h3>
<p class="BodyFirst">Running the compiler on source code usually doesn’t result in enough object code to create a useful executable program all by itself. You need <em>libraries</em> to build complete programs. A C library is a collection of common precompiled components that you can build into your program, and it’s really not much more than a bundle of object files (along with some header files, which we’ll talk about in <span class="xref" itemid="xref_target_Section 15.1.4">Section 15.1.4</span>). For example, there’s a standard math library that many executables draw from because it provides trigonometric functions and the like. </p>
<p>Libraries come into play primarily at link time, when the linker program (<code>ld</code>) creates an executable from object files. Linking using a library is often called <em>linking against</em> a library. This is where you’re most likely to have a problem. For example, if you have a program that uses the curses library but you forget to tell the compiler to link against that library, you’ll see linker errors like this: </p>
<pre><code><b>badobject.o</b>(.text+0x28): undefined reference to '<b>initscr</b>'</code></pre>
<p>The most important parts of these error messages are in bold. When the linker program examined the <em>badobject.o</em> object file, it couldn’t find the function that appears in bold, and thus it couldn’t create the executable. <span epub:type="pagebreak" title="367" id="Page_367"/>In this particular case, you might suspect that you forgot the curses library because the missing function is <code>initscr()</code>; if you do a web search for the function name, you’ll nearly always find a manual page or some other reference to the library.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Undefined references don’t always mean that you’re missing a library. One of the program’s object files could be missing in the link command. It’s usually easy to differentiate between library functions and functions in your object files, because you’ll likely recognize the ones you wrote, or at least be able to search for them. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To fix this problem, you must first find the curses library and then use the compiler’s <code>-l</code> option to link against the library. Libraries are scattered throughout the system, though most libraries reside in a subdirectory named <em>lib </em>(<em>/usr/lib </em>is the system default location). For the preceding example, the basic curses library file is <em>libcurses.a</em>, so the library name is <code>curses</code>. Putting it all together, you would link the program like this: </p>
<pre><code>$ <b>cc -o badobject badobject.o -lcurses</b></code></pre>
<p>You must tell the linker about nonstandard library locations; the parameter for this is <code>-L</code>. Let’s say that the <code>badobject</code> program requires <em>libcrud.a</em> in <em>/usr/junk/lib</em>. To compile and create the executable, use a command like this: </p>
<pre><code>$ <b>cc -o badobject badobject.o -lcurses -L/usr/junk/lib -lcrud</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you want to search a library for a particular function, use the <var>nm</var> command with the <var>--defined-only</var> symbol filter. Be prepared for a lot of output. For example, try this: <var>nm --defined-only libcurses.a</var>. On many distributions, you can also use the <var>less</var> command to view the contents of a library. (You might need to use the <var>locate</var> command to find <span class="Regular">libcurses.a</span>; many distributions now put libraries in architecture-specific subdirectories in <span class="Regular">/usr/lib</span>, such as <span class="Regular">/usr/lib/x86_64-linux-gnu/</span>.)</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>There’s a library on your system called the C standard library, containing fundamental components considered a part of the C programming language. Its basic file is <em>libc.a</em>. When you compile a program, this library is always included unless you specifically exclude it. Most programs on your system use the shared version, so let’s talk about how that works.</p>
<h3 id="h2-500402c15-0003">15.1.3	Working with Shared Libraries</h3>
<p class="BodyFirst">A library file ending with <em>.a</em> (such as <em>libcurses.a</em>) is called a <em>static library</em>. When you link a program against a static library, the linker copies the necessary machine code from the library file into your executable. Once it does this, the final executable no longer needs the original library file when it runs, and because your executable has its own copy of the library code, the executable’s behavior is not subject to change if the <em>.a</em> file changes.</p>
<p>However, library sizes are always increasing, as is the number of libraries in use, and this makes static libraries wasteful in terms of disk space <span epub:type="pagebreak" title="368" id="Page_368"/>and memory. In addition, if a static library is later found to be inadequate or insecure, there’s no way to change the executables that had been linked against it, short of finding and recompiling every executable.</p>
<p><em>Shared libraries</em> counter these problems. Linking a program against a shared library doesn’t copy the code into the final executable; it just adds <em>references</em> to names in the code of the library file. When you run the program, the system loads the library’s code into the process memory space only when necessary. Many processes can share the same shared library code in memory. And if you need to slightly modify the library code, you can generally do so without recompiling any programs. When updating software on your Linux distribution, the packages that you’re updating can include shared libraries. When your update manager asks you to reboot your machine, sometimes it’s doing so to be sure that every part of your system is using new versions of shared libraries.</p>
<p>Shared libraries do have their own costs: difficult management and a somewhat complicated linking procedure. However, you can bring shared libraries under control if you know four things: </p>
<ul>
<li>How to list the shared libraries that an executable needs</li>
<li>How an executable looks for shared libraries</li>
<li>How to link a program against a shared library</li>
<li>How to avoid the common shared library pitfalls</li>
</ul>
<p>The following sections tell you how to use and maintain your system’s shared libraries. If you’re interested in how shared libraries work or if you want to know about linkers in general, you can check out <em>Linkers and Loaders</em> by John R. Levine (Morgan Kaufmann, 1999); “The Inside Story on Shared Libraries and Dynamic Loading” by David M. Beazley, Brian D. Ward, and Ian R. Cooke (<em>Computing in Science &amp; Engineering</em>, September/October 2001); or online resources such as the Program Library HOWTO (<em>https://bit.ly/3q3MbS6</em>). The ld.so(8) manual page is also worth a read. </p>
<h4 id="h3-500402c15-0001">How to List Shared Library Dependencies</h4>
<p class="BodyFirst">Shared library files usually reside in the same places as static libraries. The two standard library directories on a Linux system are <em>/lib</em> and <em>/usr/lib</em>, though many more can be scattered throughout your system. The <em>/lib</em> directory should not contain static libraries. </p>
<p>A shared library has a suffix that contains <em>.so</em> (shared object), as in <em>libc-2.15.so</em> and <em>libc.so.6</em>. To see what shared libraries a program uses, run <code>ldd </code><var>prog</var>, where <var>prog</var> is the executable name. Here’s an example for the shell: </p>
<pre><code>$ <b>ldd /bin/bash</b>
    linux-vdso.so.1 (0x00007ffff31cc000)
    libgtk3-nocsd.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0 (0x00007f72bf3a4000)
    libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f72bf17a000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f72bef76000)
<span epub:type="pagebreak" title="369" id="Page_369"/>    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f72beb85000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f72be966000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f72bf8c5000)</code></pre>
<p>In the interest of optimal performance and flexibility, executables alone don’t usually know the locations of their shared libraries; they know only the names of the libraries, and perhaps a little hint about where to find them. A small program named <code>ld.so</code> (the <em>runtime dynamic linker/loader</em>) finds and loads shared libraries for a program at runtime. The preceding <code>ldd</code> output shows the library names on the left side of the <code>=&gt;</code>; that’s what the executable knows. The right side of the <code>=&gt;</code> shows where <code>ld.so</code> finds the library.</p>
<p>The final line of output shows the actual location of <code>ld.so</code>: <em>/lib/ld-linux.so.2</em>.</p>
<h4 id="h3-500402c15-0002">How ld.so Finds Shared Libraries</h4>
<p class="BodyFirst">One of the common trouble points for shared libraries is the dynamic linker being unable to find a library. The first place the dynamic linker <em>should</em> normally look for shared libraries is an executable’s preconfigured <em>runtime library search path</em> <em>(rpath)</em>, if it exists. You’ll see how to create this path shortly.</p>
<p>Next, the dynamic linker looks in a system cache, <em>/etc/ld.so.cache</em>, to see if the library is in a standard location. This is a fast cache of the names of library files found in directories listed in the cache configuration file <em>/etc/ld.so.conf</em>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	As is typical of many of the Linux configuration files that you’ve seen, <span class="Regular">ld.so.conf</span> may in turn include a number of files from a directory such as <span class="Regular">/etc/ld.so.conf.d</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Each line in <em>ld.so.conf</em> (or in the files it includes) is the name of a directory that you want to include in the cache. The list of directories is usually short, containing something like this: </p>
<pre><code>/lib/i686-linux-gnu
/usr/lib/i686-linux-gnu</code></pre>
<p>The standard library directories <em>/lib</em> and <em>/usr/lib</em> are implicit, which means that you don’t need to include them in <em>/etc/ld.so.conf</em>. </p>
<p>If you alter <em>ld.so.conf</em> or make a change to one of the shared library directories, you must rebuild the <em>/etc/ld.so.cache</em> file by hand with the following command: </p>
<pre><code># <b>ldconfig -v</b></code></pre>
<p>The <code>-v</code> option provides detailed information on libraries that <code>ldconfig</code> adds to the cache and any changes that it detects. </p>
<p>There is one more place that <code>ld.so</code> looks for shared libraries: the environment variable <code>LD_LIBRARY_PATH</code>. We’ll talk about this soon. </p>
<p>Don’t get into the habit of adding stuff to <em>/etc/ld.so.conf</em>. You should know what shared libraries are in the system cache, and if you put every bizarre little shared library directory into the cache, you risk conflicts <span epub:type="pagebreak" title="370" id="Page_370"/>and an extremely disorganized system. When you compile software that needs an obscure library path, give your executable a built-in runtime library search path. Let’s see how to do that.</p>
<h4 id="h3-500402c15-0003">How to Link Programs Against Shared Libraries </h4>
<p class="BodyFirst">Say you have a shared library named <em>libweird.so.1</em> in <em>/opt/obscure/lib</em> that you need to link <code>myprog</code> against. You shouldn’t have this strange path in <em>/etc/ld.so.conf</em>, so you need to convey that path to the linker. Link the program as follows: </p>
<pre><code>$ <b>cc -o myprog myprog.o -Wl,-rpath=/opt/obscure/lib -L/opt/obscure/lib -lweird</b></code></pre>
<p>The <code>-Wl,-rpath</code> option tells the linker to include the specified directory into the executable’s runtime library search path. However, even if you use <code>-Wl,-rpath</code>, you still need the <code>-L</code> flag.</p>
<p>If you need to change the runtime library search path of an existing binary, you can use the <code>patchelf</code> program, but it’s generally better to do this at compile time. (ELF, the Executable and Linkable Format, is the standard format used for executables and libraries on Linux systems.)</p>
<h4 id="h3-500402c15-0004">How to Avoid Problems with Shared Libraries</h4>
<p class="BodyFirst">Shared libraries provide remarkable flexibility, not to mention some really incredible hacks, but you can abuse them to the point where your system becomes an utter and complete mess. Three particularly bad things can happen: </p>
<ul>
<li>Missing libraries</li>
<li>Terrible performance</li>
<li>Mismatched libraries</li>
</ul>
<p>The number one cause of all shared library problems is the environment variable <code>LD_LIBRARY_PATH</code>. Setting this variable to a colon-delimited set of directory names makes <code>ld.so</code> search the given directories <em>before</em> anything else when looking for a shared library. This is a cheap way to make programs work when you move a library around, if you don’t have the program’s source code and can’t use <code>patchelf</code>, or if you’re just too lazy to recompile the executables. Unfortunately, you get what you pay for. </p>
<p><em>Never</em> set <code>LD_LIBRARY_PATH</code> in shell startup files or when compiling software. When the dynamic runtime linker encounters this variable, it often must search through the entire contents of each specified directory more times than you’d care to know. This causes a big performance hit, but more importantly, you can get conflicts and mismatched libraries because the runtime linker looks in these directories for <em>every</em> program. </p>
<p>If you <em>must</em> use <code>LD_LIBRARY_PATH</code> to run some crummy program for which you don’t have the source (or an application that you’d rather not <span epub:type="pagebreak" title="371" id="Page_371"/>recompile, like Firefox or some other beast), use a wrapper script. Let’s say your executable is <em>/opt/crummy/bin/crummy.bin</em> and needs some shared libraries in <em>/opt/crummy/lib</em>. Write a wrapper script called <code>crummy</code> that looks like this: </p>
<pre><code>#!/bin/sh
LD_LIBRARY_PATH=/opt/crummy/lib
export LD_LIBRARY_PATH
exec /opt/crummy/bin/crummy.bin $@</code></pre>
<p>Avoiding <code>LD_LIBRARY_PATH</code> prevents most shared library problems. But one other significant problem that occasionally comes up with developers is that a library’s API may change slightly from one minor version to another, breaking installed software. The best solutions here are preventive: either use a consistent methodology to install shared libraries with <code>-Wl,-rpath</code> to create a runtime link path, or simply use the static versions of obscure libraries.</p>
<h3 id="h2-500402c15-0004">15.1.4	 Working with Header (Include) Files and Directories</h3>
<p class="BodyFirst">C <em>header files</em> are additional source code files that usually contain type and library function declarations, often for the libraries that you just saw. For example, <em>stdio.h</em> is a header file (see the simple program in <span class="xref" itemid="xref_target_Section 15.1">Section 15.1</span>).</p>
<p>A great number of compilation problems are related to header files. Most such glitches occur when the compiler can’t find header files and libraries. There are even some cases where a programmer forgets to add the <code>#include</code> directive to code that includes a required header file, causing a failure to compile some of the source code.</p>
<h4 id="h3-500402c15-0005">Include File Problems</h4>
<p class="BodyFirst">Tracking down the correct header files isn’t always easy. Sometimes you’ll get lucky and find them with <code>locate</code>, but in other instances, there are several include files with the same names in different directories, and it’s not clear which is the correct one. When the compiler can’t find an include file, the error message looks like this: </p>
<pre><code>badinclude.c:1:22: fatal error: notfound.h: No such file or directory</code></pre>
<p>This message reports that the compiler can’t find the <em>notfound.h</em> header file that the <em>badinclude.c</em> file references. If we look at  <em>badinclude.c</em> (on line 1, as the error indicates), we’ll find a line that looks like this:</p>
<pre><code>#include &lt;notfound.h&gt;</code></pre>
<p>Include directives like this do not specify where a header file should reside, only that it should be either in the default location or in one specified on the compiler command line. Most of these locations have <em>include</em> in their names. The default include directory in Unix is <em>/usr/include</em>; the <span epub:type="pagebreak" title="372" id="Page_372"/>compiler always looks there unless you explicitly tell it not to. Of course, you’re unlikely to see the preceding error if the include file is in the default location, so let’s see how to make the compiler look in other include directories. </p>
<p>For example, say that you find <em>notfound.h</em> in <em>/usr/junk/include</em>. To tell the compiler to add this directory to its search path, use the <code>-I</code> option: </p>
<pre><code>$ <b>cc -c -I/usr/junk/include badinclude.c</b></code></pre>
<p>Now the compiler should no longer stumble on the line of code in <em>badinclude.c</em> that references the header file. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You’ll learn more about how to find missing include files in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You should also beware of includes that use double quotes (<code>"</code><var> </var><code>"</code>) instead of angle brackets (<code>&lt; &gt;</code>), like this: </p>
<pre><code>#include "myheader.h"</code></pre>
<p>Double quotes mean that the header file is not in a system include directory, and usually indicate that the include file is in the same directory as the source file. If you encounter a problem with double quotes, you’re probably trying to compile incomplete source code.</p>
<h4 id="h3-500402c15-0006">The C Preprocessor</h4>
<p class="BodyFirst">It turns out that the C compiler doesn’t actually do the work of looking for these include files. That task falls to the <em>C preprocessor</em>, a program that the compiler runs on your source code before parsing the actual program. The preprocessor rewrites source code into a form that the compiler understands; it’s a tool for making source code easier to read (and for providing shortcuts). </p>
<p>Preprocessor commands in the source code are called <em>directives</em>, and they start with the <code># </code>character. There are three basic types of directives: </p>
<ol class="none">
<li><span class="RunInHead">Include files</span>  An <code>#include</code> directive instructs the preprocessor to include an entire file. Note that the compiler’s <code>-I</code> flag is actually an option that causes the preprocessor to search a specified directory for include files, as you saw in the previous section. </li>
<li><span class="RunInHead">Macro definitions</span>  A line such as <code>#define BLAH something</code> tells the preprocessor to substitute <code>something</code> for all occurrences of <code>BLAH</code> in the source code. Convention dictates that macros appear in all uppercase, but it should come as no shock that programmers sometimes use macros whose names look like functions and variables. (Every now and then, this causes a world of headaches. Many programmers make a sport out of abusing the preprocessor.)<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Instead of defining macros within your source code, you can also define them by passing parameters to the compiler: <var>-DBLAH=something</var> works like the preceding <var>#define</var> directive. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</li>
<li><span epub:type="pagebreak" title="373" id="Page_373"/><span class="RunInHead">Conditionals</span>  You can mark out certain pieces of code with <code>#ifdef</code>, <code>#if</code>, and <code>#endif</code>. The <code>#ifdef </code><var>MACRO</var> directive checks to see whether the preprocessor macro <var>MACRO</var> is defined, and <code>#if </code><var>condition</var> tests to see whether <var>condition</var> is nonzero. For both directives, if the condition following the “if” statement is false, the preprocessor does not pass any of the program text between the <code>#if</code> and the next <code>#endif</code> to the compiler. If you plan to look at any C code, you’d better get used to this. 
<p class="ListBody">Let’s look at an example of a conditional directive. When the preprocessor sees the following code, it checks to see whether the macro <code>DEBUG</code> is defined and, if so, passes the line containing <code>fprintf()</code> on to the compiler. Otherwise, the preprocessor skips this line and continues to process the file after the <code>#endif</code>:</p>
<pre><code>#ifdef DEBUG
  fprintf(stderr, "This is a debugging message.\n");
#endif</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The C preprocessor doesn’t know anything about C syntax, variables, functions, and other elements. It understands only its own macros and directives.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</li>
</ol>
<p>On Unix, the C preprocessor’s name is <code>cpp</code>, but you can also run it with <code>gcc -E</code>. However, you’ll rarely need to run the preprocessor by itself. </p>
<h2 id="h1-500402c15-0002">	15.2	make</h2>
<p class="BodyFirst">A program that has more than one source code file or requires strange compiler options is too cumbersome to compile by hand. This problem has been around for years, and the traditional Unix compile management utility that addresses it is called <code>make</code>. You should know a little about <code>make</code> if you’re running a Unix system, because system utilities sometimes rely on <code>make</code> to operate. However, this chapter is only the tip of the iceberg. There are entire books on <code>make</code>, such as <em>Managing Projects with GNU Make</em>, 3rd edition, by Robert Mecklenburg (O’Reilly, 2005). In addition, most Linux packages are built using an additional layer around <code>make</code> or a similar tool. There are many build systems out there; we’ll look at one named autotools in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>.</p>
<p><code>make</code> is a big system, but it’s not very difficult to get an idea of how it works. When you see a file named <em>Makefile</em> or <em>makefile</em>, you know that you’re dealing with <code>make</code>. (Try running <code>make</code> to see if you can build anything.) </p>
<p>The basic idea behind <code>make</code> is the <em>target</em>, a goal that you want to achieve. A target can be a file (a <em>.o</em> file, an executable, and so on) or a label. In addition, some targets depend on other targets; for instance, you need a complete set of <em>.o</em> files before you can link your executable. These requirements are called <em>dependencies</em>. </p>
<p>To build a target, <code>make</code> follows a <em>rule</em>, such as one specifying how to go from a <em>.c</em> source file to a <em>.o</em> object file. <code>make</code> already knows several rules, but you can customize them to create your own.</p>
<h3 id="h2-500402c15-0005"><span epub:type="pagebreak" title="374" id="Page_374"/>15.2.1	 A Sample Makefile </h3>
<p class="BodyFirst">Building on the example files in <span class="xref" itemid="xref_target_Section 15.1.1">Section 15.1.1</span>, the following very simple Makefile builds a program called <code>myprog</code> from <em>aux.c</em> and <em>main.c</em>: </p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> # object files
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> OBJS=aux.o main.o

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> all: <span class="CodeAnnotation" aria-label="annotation4">4</span>myprog

myprog: <span class="CodeAnnotation" aria-label="annotation5">5</span>$(OBJS)
        <span class="CodeAnnotation" aria-label="annotation6">6</span>$(CC) -o myprog $(OBJS)</code></pre>
<p>The <code>#</code> in the first line of this Makefile <span class="CodeAnnotation" aria-label="annotation1">1</span> denotes a comment. </p>
<p>The next line is just a macro definition that sets the <code>OBJS</code> variable to two object filenames <span class="CodeAnnotation" aria-label="annotation2">2</span>. This will be important later. For now, take note of how you define the macro and also how you reference it later (<code>$(OBJS)</code>). </p>
<p>The next item in the Makefile contains its first target, <code>all</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The first target is always the default, the target that <code>make</code> wants to build when you run <code>make</code> by itself on the command line. </p>
<p>The rule for building a target comes after the colon. For <code>all</code>, this Makefile says that you need to satisfy something called <code>myprog</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. This is the first dependency in the file; <code>all</code> depends on <code>myprog</code>. Note that <code>myprog</code> can be an actual file or the target of another rule. In this case, it’s both (the rule for <code>all</code> and the target of <code>OBJS</code>). </p>
<p>To build <code>myprog</code>, this Makefile uses the macro <code>$(OBJS)</code> in the dependencies <span class="CodeAnnotation" aria-label="annotation5">5</span>. The macro expands to <em>aux.o</em> and <em>main.o</em>, indicating that <code>myprog</code> depends on these two files (they must be actual files, because there aren’t any targets with those names anywhere in the Makefile). </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The whitespace before <code>$(CC)</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> is a tab. <code>make</code> is very strict about tabs.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>This Makefile assumes that you have two C source files named <em>aux.c</em> and <em>main.c</em> in the same directory. Running <code>make</code> on the Makefile yields the following output, showing the commands that <code>make</code> is running: </p>
<pre><code>$ <b>make</b>
cc    -c -o aux.o aux.c
cc    -c -o main.o main.c
cc -o myprog aux.o main.o</code></pre>
<p>A diagram of the dependencies is shown in <a href="#figure15-1" id="figureanchor15-1">Figure 15-1</a>.</p>
<h3 id="h2-500402c15-0006">15.2.2	 Built-in Rules</h3>
<p class="BodyFirst">How did <code>make</code> know how to go from <em>aux.c</em> to <em>aux.o</em>? After all, <em>aux.c</em> is not in the Makefile. The answer is that <code>make</code> has some built-in rules to follow. It knows to look for a <em>.c</em> file when you want a <em>.o</em> file, and furthermore, it knows how to run <code>cc -c</code> on that <em>.c</em> file to get to its goal of creating a <em>.o </em>file.</p>
<span epub:type="pagebreak" title="375" id="Page_375"/><figure>
<img src="image_fi/500402c15/f15001.png" alt="f15001"/>
<figcaption><p><a id="figure15-1">Figure 15-1</a>: Makefile dependencies</p></figcaption></figure>
<h3 id="h2-500402c15-0007">15.2.3	 Final Program Build </h3>
<p class="BodyFirst">The final step in getting to <code>myprog</code> is a little tricky, but the idea is clear enough. After you have the two object files in <code>$(OBJS)</code>, you can run the C compiler according to the following line (where <code>$(CC)</code> expands to the compiler name): </p>
<pre><code>        $(CC) -o myprog $(OBJS)</code></pre>
<p>As mentioned earlier, the whitespace before <code>$(CC)</code> is a tab. You <em>must</em> insert a tab before any system command, on its own line. </p>
<p>Watch out for this: </p>
<pre><code>Makefile:7: *** missing separator.  Stop.</code></pre>
<p>An error like this means that the Makefile is broken. The tab is the separator, and if there is no separator or there’s some other interference, you’ll see this error. </p>
<h3 id="h2-500402c15-0008">15.2.4	 Dependency Updates</h3>
<p class="BodyFirst">One last <code>make</code> fundamental concept to know is that, in general, the goal is to bring targets up to date with their dependencies. Furthermore, it’s designed to take only the minimum steps necessary to do that, which can lead to considerable time savings. If you type <code>make</code> twice in a row for the preceding example, the first command builds <code>myprog</code>, but the second yields this output: </p>
<pre><code>make: Nothing to be done for 'all'.</code></pre>
<p><span epub:type="pagebreak" title="376" id="Page_376"/>This second time through, <code>make</code> looked at its rules and noticed that <code>myprog</code> already exists, so it didn’t build <code>myprog</code> again because none of the dependencies had changed since the last time you built it. To experiment with this, do the following:</p>
<ol class="decimal">
<li value="1">Run <code class="bold">touch aux.c</code>. </li>
<li value="2">Run <code class="bold">make</code> again. This time, <code>make</code> determines that <em>aux.c</em> is newer than the <em>aux.o</em> already in the directory, so it compiles <em>aux.o</em> again. </li>
<li value="3"><code>myprog</code> depends on <em>aux.o</em>, and now <em>aux.o</em> is newer than the preexisting <code>myprog</code>, so <code>make</code> must create <code>myprog</code> again. </li>
</ol>
<p>This type of chain reaction is very typical. </p>
<h3 id="h2-500402c15-0009">15.2.5	 Command-Line Arguments and Options</h3>
<p class="BodyFirst">You can get a great deal of mileage out of <code>make</code> if you know how its command-line arguments and options work. </p>
<p>One of the most useful options is to specify a single target on the command line. For the preceding Makefile, you can run <code>make aux.o</code> if you want only the <em>aux.o</em> file.</p>
<p>You can also define a macro on the command line. For example, to use the <code>clang</code> compiler, try:</p>
<pre><code>$ <b>make CC=clang</b></code></pre>
<p>Here, <code>make</code> uses your definition of <code>CC</code> instead of its default compiler, <code>cc</code>. Command-line macros come in handy for testing preprocessor definitions and libraries, especially with the <code>CFLAGS</code> and <code>LDFLAGS</code> macros that we’ll discuss shortly. </p>
<p>In fact, you don’t even need a Makefile to run <code>make</code>. If built-in <code>make</code> rules match a target, you can just ask <code>make</code> to try to create the target. For example, if you have the source to a very simple program called <em>blah.c</em>, try <code>make blah</code>. The <code>make</code> run proceeds like this: </p>
<pre><code>$ <b>make blah</b>
cc   blah.o   -o blah</code></pre>
<p>This use of <code>make</code> works only for the most elementary C programs; if your program needs a library or special include directory, you should probably write a Makefile. Running <code>make</code> without a Makefile is actually most useful when you’re dealing with something like Fortran, Lex, or Yacc and don’t know how the compiler or utility works. Why not let <code>make</code> try to figure it out for you? Even if <code>make</code> fails to create the target, it will probably still give you a pretty good hint as to how to use the tool. </p>
<p>Two <code>make</code> options stand out from the rest: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">-n</code></span>  Prints the commands necessary for a build but prevents <code>make</code> from actually running any commands</li>
<li><span class="RunInHead"><code class="bold">-f</code><var class="bold"> file</var></span>  Tells <code>make</code> to read from <var>file</var><em> </em>instead of <var>Makefile</var> or <var>makefile</var></li>
</ol>
<h3 id="h2-500402c15-0010"><span epub:type="pagebreak" title="377" id="Page_377"/>15.2.6	 Standard Macros and Variables</h3>
<p class="BodyFirst"><code>make</code> has many special macros and variables. It’s difficult to tell the difference between a macro and a variable, but here the term <em>macro</em> is used to mean something that usually doesn’t change after <code>make</code> starts building targets. </p>
<p>As you saw earlier, you can set macros at the start of your Makefile. These are the most common macros:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">CFLAGS</code></span>  C compiler options. When creating object code from a <em>.c</em> file, <code>make</code> passes this as an argument to the compiler. </li>
<li><span class="RunInHead"><code class="bold">LDFLAGS</code></span>  Like <code>CFLAGS</code>, but these options are for the linker when creating an executable from object code. </li>
<li><span class="RunInHead"><code class="bold">LDLIBS</code></span>  If you use <code>LDFLAGS</code> but don’t want to combine the library name options with the search path, put the library name options in this file. </li>
<li><span class="RunInHead"><code class="bold">CC</code></span>  The C compiler. The default is <code>cc</code>. </li>
<li><span class="RunInHead"><code class="bold">CPPFLAGS</code></span>  C <em>preprocessor</em> options. When <code>make</code> runs the C preprocessor in some way, it passes this macro’s expansion on as an argument. </li>
<li><span class="RunInHead"><code class="bold">CXXFLAGS</code></span>  GNU <code>make</code> uses this for C++ compiler flags. </li>
</ol>
<p>A <code>make</code> <em>variable</em> changes as you build targets. Variables begin with a dollar sign (<code>$</code>). There are several ways to set variables, but some of the most common variables are automatically set inside target rules. Here’s what you might see: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">$@</code></span>  When inside a rule, this variable expands to the current target. </li>
<li><span class="RunInHead"><code class="bold">$&lt;</code></span>  When inside a rule, this variable expands to the first dependency of the target.</li>
<li><span class="RunInHead"><code class="bold">$*</code></span>  This variable expands to the <em>basename</em> or stem of the current target. For example, if you’re building <em>blah.o</em>, this expands to <em>blah</em>. </li>
</ol>
<p>Here’s an example illustrating a common pattern—a rule using <code>myprog</code> to generate a <em>.out</em> file from a <em>.in</em> file:</p>
<pre><code>.SUFFIXES: .in
.in.out: $&lt;
	myprog $&lt; -o $*.out</code></pre>
<p>You’ll encounter a rule such as <code>.c.o:</code> in many Makefiles defining a customized way of running the C compiler to create an object file.</p>
<p>The most comprehensive list of <code>make</code> variables on Linux is the <code>make</code> info manual. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Keep in mind that GNU <var>make</var> has many extensions, built-in rules, and features that other variants do not have. This is fine as long as you’re running Linux, but if you step off onto a Solaris or BSD machine and expect the same options to work, you might be in for a surprise. However, that’s the problem that a multiplatform build system such as GNU autotools is designed to solve.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c15-0011"><span epub:type="pagebreak" title="378" id="Page_378"/>15.2.7	 Conventional Targets</h3>
<p class="BodyFirst">Most developers include several additional common targets in their Makefiles that perform auxiliary tasks related to compiles: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">clean</code></span>  The <code>clean</code> target is ubiquitous; a <code>make</code> <code>clean</code> usually instructs <code>make</code> to remove all of the object files and executables so that you can make a fresh start or pack up the software. Here’s an example rule for the <code>myprog</code> Makefile: 
<pre><code>clean:
        rm -f $(OBJS) myprog</code></pre>
</li>
<li><span class="RunInHead"><code class="bold">distclean</code></span>  A Makefile created by way of the GNU autotools system always has a <code>distclean</code> target to remove everything that wasn’t part of the original distribution, including the Makefile. You’ll see more of this in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>. On very rare occasions, you might find that a developer opts not to remove the executable with this target, preferring something like <code>realclean</code> instead. </li>
<li><span class="RunInHead"><code class="bold">install</code></span>  This target copies files and compiled programs to what the Makefile thinks is the proper place on the system. This can be dangerous, so always run a <code>make -n install</code> to see what will happen before you actually run any commands. </li>
<li><span class="RunInHead"><code class="bold">test</code> or <code class="bold">check</code></span>  Some developers provide <code>test</code> or <code>check</code> targets to make sure that everything works after performing a build. </li>
<li><span class="RunInHead"><code class="bold">depend</code></span>  This target creates dependencies by calling the compiler with <code>-M</code> to examine the source code. This is an unusual-looking target because it often changes the Makefile itself. This is no longer common practice, but if you come across some instructions telling you to use this rule, make sure to do so. </li>
<li><span class="RunInHead"><code class="bold">all</code></span>  As mentioned earlier, this is commonly the first target in the Makefile. You’ll often see references to this target instead of an actual executable. </li>
</ol>
<h3 id="h2-500402c15-0012">15.2.8	 Makefile Organization</h3>
<p class="BodyFirst">Even though there are many different Makefile styles, most programmers adhere to some general rules of thumb. For one, in the first part of the Makefile (inside the macro definitions), you should see libraries and includes grouped according to package: </p>
<pre><code>MYPACKAGE_INCLUDES=-I/usr/local/include/mypackage
MYPACKAGE_LIB=-L/usr/local/lib/mypackage -lmypackage

PNG_INCLUDES=-I/usr/local/include
PNG_LIB=-L/usr/local/lib -lpng</code></pre>
<p><span epub:type="pagebreak" title="379" id="Page_379"/>Each type of compiler and linker flag often gets a macro like this: </p>
<pre><code>CFLAGS=$(CFLAGS) $(MYPACKAGE_INCLUDES) $(PNG_INCLUDES)
LDFLAGS=$(LDFLAGS) $(MYPACKAGE_LIB) $(PNG_LIB)</code></pre>
<p>Object files are usually grouped according to executables. For example, say you have a package that creates executables called <code>boring</code> and <code>trite</code>. Each has its own <em>.c</em> source file and requires the code in <em>util.c</em>. You might see something like this: </p>
<pre><code>UTIL_OBJS=util.o

BORING_OBJS=$(UTIL_OBJS) boring.o
TRITE_OBJS=$(UTIL_OBJS) trite.o

PROGS=boring trite</code></pre>
<p>The rest of the Makefile might look like this: </p>
<pre><code>all: $(PROGS)

boring: $(BORING_OBJS)
        $(CC) -o $@ $(BORING_OBJS) $(LDFLAGS)

trite: $(TRITE_OBJS)
        $(CC) -o $@ $(TRITE_OBJS) $(LDFLAGS)</code></pre>
<p>You could combine the two executable targets into one rule, but it’s usually not a good idea to do so because you wouldn’t easily be able to move a rule to another Makefile, delete an executable, or group executables differently. Furthermore, the dependencies would be incorrect: if you had just one rule for <code>boring</code> and <code>trite</code>, <code>trite</code> would depend on <em>boring.c</em>, <code>boring</code> would depend on <em>trite.c</em>, and <code>make</code> would always try to rebuild both programs whenever you changed one of the two source files. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you need to define a special rule for an object file, put the rule for the object file just above the rule that builds the executable. If several executables use the same object file, put the object rule above all of the executable rules. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c15-0003">	15.3	Lex and Yacc</h2>
<p class="BodyFirst">You might encounter Lex and Yacc in the course of compiling programs that read configuration files or commands. These tools are building blocks for programming languages.</p>
<ul>
<li>Lex is a <em>tokenizer</em> that transforms text into numbered tags with labels. The GNU/Linux version is named <code>flex</code>. You may need a <code>-ll</code> or <code>-lfl</code> linker flag in conjunction with Lex. </li>
<li>Yacc is a <em>parser</em> that attempts to read tokens according to a <em>grammar</em>. The GNU parser is <code>bison</code>; to get Yacc compatibility, run <code>bison -y</code>. You may need the <code>-ly</code> linker flag. </li>
</ul>
<h2 id="h1-500402c15-0004"><span epub:type="pagebreak" title="380" id="Page_380"/>	15.4	Scripting Languages</h2>
<p class="BodyFirst">A long time ago, the average Unix systems manager didn’t have to worry much about scripting languages other than the Bourne shell and awk. Shell scripts (discussed in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>) continue to be an important part of Unix, but awk has faded somewhat from the scripting arena. However, many powerful successors have emerged, and many systems programs have actually switched from C to scripting languages (such as the sensible version of the <code>whois</code> program). Let’s look at some scripting basics. </p>
<p>The first thing you need to know about any scripting language is that the first line of a script looks like the shebang of a Bourne shell script. For example, a Python script starts out like this: </p>
<pre><code>#!/usr/bin/python</code></pre>
<p>Or this version, which runs the first version of Python in the command path instead of always going to <em>/usr/bin</em>:</p>
<pre><code>#!/usr/bin/env python</code></pre>
<p>As you saw in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, an executable text file that starts with a <code>#!</code> shebang is a script. The pathname following this prefix is the scripting language interpreter executable. When Unix tries to run an executable file that starts with <code>#!</code>, it runs the program following the <code>#!</code> with the rest of the file as the standard input. Therefore, even this is a script: </p>
<pre><code>#!/usr/bin/tail -2
This program won't print this line,
but it will print this line...
and this line, too.</code></pre>
<p>The first line of a shell script often contains one of the most common basic script problems: an invalid path to the scripting language interpreter. For example, say you named the previous script <code>myscript</code>. What if <code>tail</code> were actually in <em>/bin</em> instead of <em>/usr/bin</em> on your system? In that case, running <code>myscript</code> would produce this error: </p>
<pre><code>bash: ./myscript: /usr/bin/tail: bad interpreter: No such file or directory</code></pre>
<p>Don’t expect more than one argument in the script’s first line to work. That is, the <code>-2</code> in the preceding example might work, but if you add another argument, the system could decide to treat the <code>-2</code> <em>and</em> the new argument as one big argument, spaces and all. This can vary from system to system; don’t test your patience on something this insignificant. </p>
<p>Now, let’s look at a few of the languages out there.</p>
<h3 id="h2-500402c15-0013"><span epub:type="pagebreak" title="381" id="Page_381"/>15.4.1	 Python</h3>
<p class="BodyFirst">Python is a scripting language with a strong following and an array of powerful features, such as text processing, database access, networking, and multithreading. It has a powerful interactive mode and a very organized object model. </p>
<p>Python’s executable is <code>python</code>, and it’s usually in <em>/usr/bin</em>. However, Python isn’t used just from the command line for scripts. It’s found everywhere from data analysis to web applications. <em>Python Distilled</em>, by David M. Beazley (Addison-Wesley, 2021), is a great way to get started.</p>
<h3 id="h2-500402c15-0014">15.4.2	 Perl</h3>
<p class="BodyFirst">One of the older third-party Unix scripting languages is Perl. It’s the original “Swiss army chainsaw” of programming tools. Although Perl has lost a fair amount of ground to Python in recent years, it excels in particular at text processing, conversion, and file manipulation, and you may find many tools built with it. <em>Learning Perl</em>, 7th edition, by Randal L. Schwartz, brian d foy, and Tom Phoenix (O’Reilly, 2016) is a tutorial-style introduction; a larger reference is <em>Modern Perl</em>, 4th edition, by chromatic (Onyx Neon Press, 2016).</p>
<h3 id="h2-500402c15-0015">15.4.3	 Other Scripting Languages</h3>
<p class="BodyFirst">You might also encounter these scripting languages: </p>
<ol class="none">
<li><span class="RunInHead">PHP</span>  This is a hypertext-processing language often found in dynamic web scripts. Some people use PHP for standalone scripts. The PHP website is at <a href="http://www.php.net/" class="LinkURL">http://www.php.net/</a>. </li>
<li><span class="RunInHead">Ruby</span>  Object-oriented fanatics and many web developers enjoy programming in this language (<a href="http://www.ruby-lang.org/" class="LinkURL">http://www.ruby-lang.org/</a>).</li>
<li><span class="RunInHead">JavaScript</span>  This language is used inside web browsers primarily to manipulate dynamic content. Most experienced programmers shun it as a standalone scripting language due to its many flaws, but it’s nearly impossible to avoid when you’re doing web programming. In recent years, an implementation called Node.js has become more prevalent in server-side programming and scripting; its executable name is <code>node</code>.</li>
<li><span class="RunInHead">Emacs Lisp</span>  This is a variety of the Lisp programming language used by the Emacs text editor. </li>
<li><span class="RunInHead">MATLAB, Octave</span>  MATLAB is a commercial matrix and mathematical programming language and library. Octave is a very similar free software project. </li>
<li><span class="RunInHead">R</span>  This is a popular free statistical analysis language. See <a href="http://www.r-project.org/" class="LinkURL">http://www.r-project.org/</a> and <em>The Art of R Programming</em> by Norman Matloff (No Starch Press, 2011) for more information.</li>
<li><span class="RunInHead">Mathematica</span>  This is another commercial mathematical programming language with libraries.</li>
<li><span epub:type="pagebreak" title="382" id="Page_382"/><span class="RunInHead">m4</span>  This is a macro-processing language, usually found only in the GNU autotools.</li>
<li><span class="RunInHead">Tcl</span>  Tcl (tool command language) is a simple scripting language usually associated with the Tk graphical user interface toolkit and Expect, an automation utility. Although Tcl does not enjoy the widespread use that it once did, don’t discount its power. Many veteran developers prefer Tk, especially for its embedded capabilities. See <a href="http://www.tcl.tk/" class="LinkURL">http://www.tcl.tk/</a> for more.  </li>
</ol>
<h2 id="h1-500402c15-0005">	15.5	Java</h2>
<p class="BodyFirst">Java is a compiled language like C, with a simpler syntax and powerful support for object-oriented programming. It has a few niches in Unix systems. For example, it’s often used as a web application environment, and it’s popular for specialized applications. Android applications are usually written in Java. Even though it’s not often seen on a typical Linux desktop, you should know how Java works, at least for standalone applications.</p>
<p>There are two kinds of Java compilers: native compilers for producing machine code for your system (like a C compiler) and bytecode compilers for use by a bytecode interpreter (sometimes called a <em>virtual machine</em>, which is different from the virtual machine offered by a hypervisor, as described in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>). You’ll practically always encounter bytecode on Linux. </p>
<p>Java bytecode files end in <em>.class</em>. The Java Runtime Environment (JRE) contains all of the programs you need to run Java bytecode. To run a bytecode file, use:</p>
<pre><code>$ <b>java </b><var class="bold">file</var><b>.class</b></code></pre>
<p>You might also encounter bytecode files that end in <em>.jar</em>, which are collections of archived <em>.class</em> files. To run a <em>.jar</em> file, use this syntax: </p>
<pre><code>$ <b>java -jar </b><var class="bold">file</var><b>.jar</b></code></pre>
<p>Sometimes you need to set the <code>JAVA_HOME</code> environment variable to your Java installation prefix. If you’re really unlucky, you might need to use <code>CLASSPATH</code> to include any directories containing classes that your program expects. This is a colon-delimited set of directories like the regular <code>PATH</code> variable for executables. </p>
<p>If you need to compile a <em>.java</em> file into bytecode, you need the Java Development Kit (JDK). You can run the <code>javac</code> compiler from JDK to create some <em>.class</em> files: </p>
<pre><code>$ <b>javac </b><var class="bold">file</var><b>.java</b></code></pre>
<p>JDK also comes with <code>jar</code>, a program that can create and pick apart <em>.jar</em> files. It works like <code>tar</code>. </p>
<h2 id="h1-500402c15-0006"><span epub:type="pagebreak" title="383" id="Page_383"/>	15.6	Looking Forward: Compiling Packages</h2>
<p class="BodyFirst">The world of compilers and scripting languages is vast and constantly expanding. As of this writing, new compiled languages such as Go (golang) and Rust are gaining popularity in application and system programming. </p>
<p>The LLVM compiler infrastructure set (<a href="http://llvm.org/" class="LinkURL">http://llvm.org/</a>) has significantly eased compiler development. If you’re interested in how to design and implement a compiler, two good books are <em>Compilers: Principles, Techniques, and Tools</em>, 2nd edition, by Alfred V. Aho et al. (Addison-Wesley, 2006) and <em>Modern Compiler Design</em>, 2nd edition, by Dick Grune et al. (Springer, 2012). For scripting language development, it’s usually best to look for online resources, as the implementations vary widely.</p>
<p>Now that you know the basics of the programming tools on the system, you’re ready to see what they can do. The next chapter is all about how you can build packages on Linux from source code. </p>
</section>
</body></html>