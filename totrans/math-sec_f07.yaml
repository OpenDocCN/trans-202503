- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Welcome to *Math for Security*, a book that is, by my estimation, unlike any
    other security book I’ve ever read. It isn’t intended to introduce you to security
    topics like access control or encryption, nor is it going to help you prepare
    for the next certification exam. It will, however, strengthen your ability to
    examine the world around you and investigate security-relevant questions. The
    contents of the book sit at a crossroads between theoretical research, experimentation,
    and practical application. My goal is to introduce you to key mathematical fields
    through practical research topics. I find the easiest way to understand a complex
    theoretical principle is to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: I am not a mathematician by any stretch of the imagination. I am a security
    practitioner who loves reading theoretical research papers and has found, over
    the years, that there are not many resources for translating this theoretical
    research into a testable system, otherwise known as a *proof of concept*. I decided
    to write the book I wish I had when I started down this path. As you read it,
    you’ll become familiar with the tools and procedures necessary to translate mathematical
    theory into security-relevant applications. You’ll learn to accurately assess
    and communicate the limitations of your tools and procedures by examining the
    inevitable assumptions we must make when dealing with data in the wild. Most of
    all, though, I hope you’ll learn to see mathematical theory in a new, totally
    practical light.
  prefs: []
  type: TYPE_NORMAL
- en: Who Should Read This Book?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, when I begin a discussion about applied mathematics in security, people
    say something along the lines of “but I don’t work on encryption,” which tells
    me many security practitioners misunderstand the role math plays in their day-to-day
    activities. The truth is, applied mathematics is at the heart of every modern
    security automation tool, not just cryptographic tools. My hope is that anyone
    with an interest in security and some Python programming experience will find
    something fun and informative in these projects. If you know enough Python to
    install and import packages, read and write files, and manage basic networking
    tasks, you should be set. You don’t need a deep understanding of math to follow
    along, since we’ll break down the formulas as we use them. If the title of the
    book caught your attention, chances are you’re one of the people who should read
    this book!
  prefs: []
  type: TYPE_NORMAL
- en: What’s in This Book?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ve organized the material into three parts. Part I: Environment and Conventions
    (Chapters [1](c01.xhtml) and [2](c02.xhtml)) will help you set up a Python environment
    for coding and introduce some basic notation concepts. Part II: Graph Theory and
    Computational Geometry (Chapters [3](c03.xhtml)–[10](c10.xhtml)) introduces the
    two main branches of math we’ll be discussing. Finally, Part III: The Art Gallery
    Problem (Chapters [11](c11.xhtml)–[13](c13.xhtml)) covers a larger project built
    to answer the classic art gallery problem, which will require both branches of
    math for our solution. Each chapter concludes with a “Summary” section that will
    cover other potential applications, background readings, and complementary math
    topics to help you continue on your own. Here’s a brief overview of what to expect
    in each chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 1: Setting Up the Environment We’ll start by getting your environment
    set up using Anaconda or pip, depending on your preference and level of familiarity
    with Python. We’ll discuss the importance of isolating development environments
    and cover how to access the Jupyter Notebooks included in the supplemental materials.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 2: Programming and Math Conventions Here we’ll cover the special programming
    syntax and math notation you’ll need to follow along with the examples. We’ll
    cover Python’s list and dictionary comprehensions as well as the `zip` and `unpack`
    functions. Then we’ll dive into the math side of things with a refresher on Boolean
    algebra and set notation; we’ll also look at the many different symbols that populate
    the math world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 3: Securing Networks with Graph Theory This chapter will introduce
    the concepts around building and analyzing graphs using the NetworkX Python library.
    We’ll discuss some of the basic types of graphs you’re likely to encounter, as
    well as how to analyze some key statistics that will help you better understand
    the structure of your graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 4: Building a Network Traffic Analysis Tool In this project, we’ll
    build a graph to represent the communications across a computer network using
    the NetworkX and Scapy libraries. We’ll then apply our understanding of graphs
    to uncover some interesting facts about computers on the network. We’ll conclude
    with a proof-of-concept project in which you’ll capture network packets and use
    them to create a graph of your own.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 5: Identifying Threats with Social Network Analysis This project focuses
    on analyzing people networks instead of computer networks. We’ll build a graph
    using data simulating a social network like Mastodon. We’ll discuss one of the
    ways connections form in social networks and dive into some practical research
    questions to identify interesting people. We’ll conclude with a proof-of-concept
    project that will get you started collecting your own data for analyzing Mastodon
    timelines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 6: Analyzing Social Networks to Prevent Security Incidents We continue
    our analysis of the social network from [Chapter 5](c05.xhtml) by looking at what
    might happen in the future. We’ll use randomness and probability to create a simulation
    of how messages might move through the network, who is likely to respond to whom,
    and on what topics. Finally, we’ll cover our proof of concept, a two-player adversarial
    game to decide the fate of our social network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 7: Using Geometry to Improve Security Practices In this chapter we
    switch to our second branch of math, computational geometry. We’ll discuss how
    to represent different shapes using the Shapely library and common operations
    you’ll encounter when working with shape data. The chapter will also introduce
    some physical security concepts, like resource planning and location, as we discuss
    representing our plans using geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 8: Tracking People in Physical Space with Digital Information We continue
    our exploration of computational geometry by discussing its application in locating
    devices in the physical world. We’ll cover the structure of network data and how
    to connect to the OpenCell API to gather geographic information about networks.
    We’ll also discuss the ethics around device tracking. Our proof-of-concept project
    for this chapter will take in a sample set of tower data, solve for the overlapping
    coverage area, and return it as a bounded search area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 9: Computational Geometry for Safety Resource Distribution In this
    chapter, we cover how to use Voronoi diagrams when doing resource analysis. We’ll
    discuss the current distribution of fire stations around Portland, Oregon, and
    explore where a new station could have the most impact. We’ll cover how to get
    the shape data for larger areas using the OpenStreetMap API. For the proof of
    concept, we’ll create an application capable of programmatically recommending
    the location for a new fire station based on the current stations’ responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10: Computational Geometry for Facial Recognition In the final project
    for computational geometry, we’ll examine its application in facial recognition
    research. We’ll cover what makes good images, how to process image data, different
    ways to measure interesting facial features with shapes, and how to find the key
    features for the best outcome. In this special two-part proof of concept, we’ll
    develop a system to address both aspects of modern data science projects: model
    training and model application. We’ll produce a system capable of processing an
    image set, train a facial classifier, and ultimately apply our method to three
    faces to see if we can properly identify them using only computational geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 11: Distributing Security Resources to Guard a Space This chapter begins
    our exploration of the art gallery problem and the requirements of a larger project.
    We’ll cover the theory and existing research that underpins our solution. Then
    we’ll discuss how we can combine graph theory and computational geometry to improve
    upon the basics for a more realistic answer. The code in this chapter will serve
    as the base for the rest of the project and covers generating the actual solution
    we’re interested in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 12: The Minimum Viable Product Approach to Security Software Development
    Here we’ll expand our project from [Chapter 11](c11.xhtml) beyond a simple proof
    of concept by adding more advanced features that will improve the user experience.
    We’ll discuss speeding up our application with parallel programming. We’ll touch
    on using PyGame to handle graphics and user interactions. Finally, we’ll go over
    the example application that comes with the book and explore how you can use it
    as a starting point for your own art gallery problem solver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 13: Delivering Python Applications We’ll conclude our art gallery problem
    project with a discussion of modern software delivery methods. This is a large
    topic, so I’ve picked a few that I think everyone should be familiar with, from
    packaging your application as a library to delivering it as a cloud service. We’ll
    discuss some of the pros and cons of each option as well as its impact on your
    ability to monetize your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Python?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python checks all the boxes for what we’ll be covering in this book. The Python
    language has a long history of success in the security community and there’s already
    a plethora of tools and books that use it. Operational flexibility has been cited
    as one of the primary reasons for Python’s heavy adoption in the security community.
    Python performs well across a wide variety of platforms, from tiny single-board
    computers (like Raspberry Pi) to massive computing clusters and just about everything
    in between. With Python, you’ll be able to integrate your ideas with a lot of
    existing work.
  prefs: []
  type: TYPE_NORMAL
- en: Python also has strong ties to the applied mathematics communities. In today’s
    computer-centric world, applied mathematics is usually expressed using one or
    more high-level programming languages. Of all modern programming languages, Python
    has emerged as a leader in mathematical and scientific programming because it’s
    easy to learn but almost unlimited in its expressive power. Python 3 is a natural
    choice for the exploratory research we’ll be doing because it has many libraries
    and features that will help us implement the various algorithms required to perform
    in-depth analysis.
  prefs: []
  type: TYPE_NORMAL
- en: That isn’t to say that Python doesn’t have its shortcomings. Python is an interpreted
    language, which means a program (called the *interpreter*) sits between the code
    you write and the system executing that code. The interpreter’s job is to translate
    your instructions into commands the underlying system understands.
  prefs: []
  type: TYPE_NORMAL
- en: Having the interpreter between what you write and what your system receives
    introduces a few problems. First, the additional layer between the instruction
    and the execution adds processing time and memory overhead. Second, the interpreter
    is itself a single application running in a process on a core of your machine.
    Your code is then executed inside the context of the interpreter’s process, which
    means your entire application is restricted to the tiny fraction of the system
    that the OS allocates to a process, even if you have an octocore beast with enough
    RAM to store the congressional library. There are programming tricks you can employ
    to sidestep limitations (such as distributed processing, which we’ll discuss in
    [Chapter 12](c12.xhtml)), but ultimately Python will never be as fast and free
    as a compiled language like C. The dirty truth is that a lot of the computationally
    heavy functions in data science libraries like scikit-learn and NumPy are wrappers
    for compiled C programs under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcomings aside, Python is nevertheless the best choice for our goals. I’ll
    introduce some common idioms in [Chapter 2](c02.xhtml) that we’ll use throughout
    the rest of the book, and I’ll explain the code as necessary in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Information Accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book, I’ll do my best to represent the data included in figures
    in multiple distinct ways, such as numbers and symbols combined with color gradients.
    I chose to add the shape or number representation along with the color to help
    convey the point more clearly, since the images in the printed text are grayscale.
    The choice to use another indicator along with colors is also one of accessibility.
    Having to write for a book using only grayscale images has helped me realize how
    much information we try to convey with color and how unfair that is to people
    who cannot distinguish a large range of colors. Whenever we create a data visualization,
    we should strive to give people a number of ways to distinguish the key points,
    and not over-rely on pretty color gradients to do the talking for us. If you have
    accessibility needs or concerns for the information presented here, please contact
    me on the book’s GitHub ([https://github.com/dreilly369/AppliedMathForSecurityBook](https://github.com/dreilly369/AppliedMathForSecurityBook)),
    and I’ll do my best to provide a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Online Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The supplemental materials and accompanying Jupyter Notebooks for this book
    are available at [https://github.com/dreilly369/AppliedMathForSecurityBook](https://github.com/dreilly369/AppliedMathForSecurityBook).
  prefs: []
  type: TYPE_NORMAL
