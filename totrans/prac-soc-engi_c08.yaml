- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloning a Landing Page
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Victims who click a link in your phishing email should land on a believable
    web page. If your attack reaches this stage, creating a useful and realistic landing
    page becomes the most important aspect of the engagement. Depending on the level
    of difficulty requested by the client, this could range from Myspace-level HTML
    to a nearly identical clone of a site the employee goes to daily.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll walk through a cloned website to show you what kind of
    changes you’ll have to make to the original site. Then we’ll clone two web pages
    from the No Starch Press website by using HTTrack, a Linux command line tool.
    You could host these cloned pages on the Apache server you set up in Chapter 7,
    and then link to this site in the email you send to your client’s employees.
  prefs: []
  type: TYPE_NORMAL
- en: An Example of a Cloned Website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at a fake SurveyMonkey site, which I cloned around 2017\.
    This simple site has three pages. First, it prompts victims to fill in a login
    form. Once victims click the Submit button, they’re taken to a password-reset
    form, which asks some invasive questions. The final page tells the user that an
    error has occurred while resetting their account. Let’s explore these pages in
    greater depth so you can better understand this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The Login Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 8-1](#figure8-1) shows the first page, named *index.html*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![<<Login page of the cloned SurveyMonkey site with the SurveyMonkey logo circled
    in red and a callout reading “A target company’s logo can be included for additional
    realism.”>>](image_fi/500983c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: The first page of the cloned site (*i**ndex.html*)'
  prefs: []
  type: TYPE_NORMAL
- en: Visually, a victim could pick up on a few cues to identify this phish. Notice
    that it lacks the green padlock indicating the use of HTTPS, because I rendered
    it directly from the file into my browser without using Apache. In a real phish,
    the URL wouldn’t have the legitimate format *surveymonkey.com/<path to survey>*
    , though it might mention SurveyMonkey somewhere to fool users. Also, SurveyMonkey
    doesn’t typically put logos on the login page. Otherwise, it’s hard to detect
    this phish; the title shown on the browser tab is accurate, and hovering over
    the Sign Up or BBB Accredited Business links will show the real links.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](#figure8-2) shows us the first page (*index.html*) of our site,
    which we connected to using HTTPS without error. This is the initial page we would
    send victims to and where we will attempt to harvest the email addresses and passwords
    of victims before passing them to the *questions.html* page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![<<HTTPS version of cloned SurveyMonkey site shows URL (practicalsocialengineering.com.cgi-bin.life).
    Left, username and password fields with log in button. Right, buttons for logging
    in using Google, Facebook, Office 365, and LinkedIn.>>](image_fi/500983c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: HTTPS version of the site (showing a clear security rating)'
  prefs: []
  type: TYPE_NORMAL
- en: If you review the HTML source code for this page, you’ll see that it’s almost
    identical to the code from the original site. You can find the source code for
    the pages that we cloned, as well as parsers written in Python for the information
    that may be input, at [http://sm-phish.seosint.xyz/](http://sm-phish.seosint.xyz/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *index.html*, I’ve altered the lines of code that define the login form
    and its fields. I’ve also edited the code so that when users submit the form,
    they get redirected to *questions.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I defined the `action` 1 to tell the system that it should move to the *questions.html*
    page after the user submits the form. Next, I defined the HTTP method as `get`
    2 to capture data from each of the form’s fields. (A full explanation of HTTP
    methods is outside the scope of this book, but you can find many resources covering
    the topic online.) I then created the `input-id` 3, `textfield required` 4, and
    `type` 5 fields, which generate the boxes that will display onscreen for the victim
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: You should understand that HTTP GET is not a secure method. To keep a malicious
    adversary outside the client’s network from exploiting it, ensure that a firewall
    is in place and that the only permissible IP addresses are yours and the client’s.
  prefs: []
  type: TYPE_NORMAL
- en: That said, using the HTTP GET method to record inputs has a variety of advantages.
    First, this tactic doesn’t require a backend database, because the data gets stored
    directly in the Apache log file, located at */var/log/apache2/access.log*. Furthermore,
    if the target organization monitors its network traffic, it should receive alerts
    when code like the `password=something` parameter 6 occurs in cleartext, providing
    the organization with a clue that it’s being attacked.
  prefs: []
  type: TYPE_NORMAL
- en: Passing cleartext credentials in URLs or other insecure channels is a security
    issue. Some platforms encode this text, which isn’t secure either; even if the
    code used a hash as a parameter, an attacker with the ability to intercept that
    traffic could perform a *pass-the-hash attack*, in which an adversary steals the
    cryptographic representation of a password (the hash) and uses it directly to
    access resources without knowing the password.
  prefs: []
  type: TYPE_NORMAL
- en: While this form looks like a login, it’s not. It merely captures the input;
    it doesn’t validate it. As long as each field contains at least one character,
    the user will pass to the next page. If this code were actually performing authentication,
    it would be considered insecure, because the website would let everyone in.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious adversaries could use these collected passwords in a variety of attacks.
    For example, they could attempt password spraying by trying to use a password
    across multiple logins associated with the employee and target.
  prefs: []
  type: TYPE_NORMAL
- en: The Sensitive Questions Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 8-3](#figure8-3) shows the second page, which asks users for sensitive
    information under the guise of recovering their account.'
  prefs: []
  type: TYPE_NORMAL
- en: The *questions.html* page uses the same source code as *index.html*. Here, I
    replaced email addresses and password form fields with four password-reset questions.
    I also replaced the field that leads users to *questions.html* with *error.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '![<<Second page of the cloned SurveyMonkey site. URL bar reads https://practicalsocialengineering.com.cgi-bin.life/Questions.html?username=test&password=test
    and four recovery questions are displayed (including "Your favorite pet''s name?"
    and "The name of your elementary school?").>>](image_fi/500983c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: The second page of the cloned site, with the parameters from *i**ndex.html*
    passed in the URL (*q**uestions.html*)'
  prefs: []
  type: TYPE_NORMAL
- en: The Error Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final page ([Figure 8-4](#figure8-4)) tells users there has been an error.
  prefs: []
  type: TYPE_NORMAL
- en: '![<<Final page of the cloned SurveyMonkey site. URL bar reads https://practicalsocialengineering.com.cgi-bin.life/Error.html?pet=Dee+Oh+Gee&school=School&name=Mom&honeymoon=Anytown%2C+USA.
    Page reads "Oops . . . This survey is closed!">>](image_fi/500983c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: The error screen for the SurveyMonkey phish'
  prefs: []
  type: TYPE_NORMAL
- en: You could use this final page for a variety of purposes. For example, many victims
    may wonder why an error occurred and try the process again, entering new credentials
    in an attempt to make it work. Victims may also report this issue to IT, which
    could put an end to the engagement.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML for this page contains an infinite loop that causes the page to reload
    itself forever. When I wrote this code, around 2017, browsers let this loop run
    forever. Versions of browsers released after 2020 may stop it after some time.
  prefs: []
  type: TYPE_NORMAL
- en: Harvesting the Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The loop causes a problem. Each iteration of it writes a line to the log file,
    which makes gathering passwords and other sensitive information from the file
    manually a challenge. Instead, you can use a couple of Python scripts to extract
    only relevant information. You can find these scripts at [http://sm-phish.seosint.xyz/](http://sm-phish.seosint.xyz/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the logs, the raw information for the “login” transaction includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each line provides information a user submitted. It tells us the page on which
    the data was input (*questions.html* or *error.html*), as well as the field ID
    and value, such as `pet=Dee-Oh-Gee&`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *data_parser_index.py* script will open the log file, find each field we
    prompted users to input on the login page, and then output the field as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We import Python’s regular expression module, and then create a regular expression
    that will parse the username and password of each line that fits the criteria
    in the log file. After we open the file, a `for` loop iterates across each line
    of the log file, displaying all matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the *data_parser_questions.py* script performs the same tasks as the
    previous script, except it extracts the input from the *questions.html* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve used the scripts to parse the data, we should have the information
    we need. The *data_parser_index.py* script yields the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The *data_parser_questions.py* script yields the password-reset questions from
    *questions.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Cloning a Website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you’ll clone a website. For the purpose of this exercise, you’ll create
    a simple, yet nearly identical copy of two No Starch Press web pages. The Apache
    instance you created in the preceding chapter needs some code to host. You need
    something to render on the user’s screen; otherwise, you’re doing nothing but
    measuring clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Login and User Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s assume you’re targeting a company whose employees, as you know through
    your OSINT efforts, buy No Starch Press books often. To steal their credentials
    to the site, you’ll copy the *nostarch.com* login page. Visit this page now, or
    find it using *robots.txt*, a file that tells internet search-engine-index robots
    what to index (and what not to index). We often use this file in OSINT collection
    to identify directories that can’t be found using conventional search engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that clicking the Log In button takes you to a new web page:
    *https://nostarch.com/user*. Let’s clone both the main page and this page.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the Pages by Using HTTrack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll use the website-copying tool HTTrack to accomplish this cloning. This
    command line tool is native to Kali, and you can install it on any Linux system.
    For example, use the following command to install it on Ubuntu and Debian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The tool has several useful options. The `–mirror` option makes a nearly identical
    copy of a specific site. The `–update` option updates the copy of an existing
    site; for example, by changing the underlying code, links, trackers, or fields.
    The `–continue` option continues mirroring a site if the mirroring process was
    interrupted or stopped. The `–skeleton` option copies the site’s HTML files only.
    The `-O` option lets you specify the output directory.
  prefs: []
  type: TYPE_NORMAL
- en: Which operator you should use depends on the complexity of the site you plan
    to clone, in addition to the desired complexity of your phishing engagement. The
    bigger and more complex the website, the longer it takes to clone it, which increases
    the opportunities for that organization to catch and block you from cloning. If
    the client doesn’t care if you’re noisy or wants a robust copy, or if you have
    ample time, do the full mirroring process. Otherwise, the HTML-only option should
    suffice. You’ll use that option here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone the No Starch login page, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-5](#figure8-5) shows the cloned page. You can view it from the directory
    from which you ran HTTrack. Navigate to the appropriate folder for the domain
    and then directory structure. In this case, you are looking at *index.html* from
    *nostarch.com*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![<<Login page of cloned No Starch site. Shows login fields for OpenID, username/email
    address, and password.>>](image_fi/500983c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: A clone of the No Starch login page'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the clone to the original site ([Figure 8-6](#figure8-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![<<Login page of real No Starch site. URL bar (https://nostarch.com/user/).
    Shows login fields for OpenID, username/email address, and password.>>](image_fi/500983c08/f08006_new.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: The real No Starch login page'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference you should notice is the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the Login Field Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As it is right now, anything entered into the cloned site will redirect the
    user to the real site. You need to change that behavior for the login fields.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s view this code. The simplest way is to load the real site and identify
    the login fields in the code by using your browser’s Inspect Elements feature.
    To accomplish this, right-click any part of the page and select **Inspect**. Now
    hover over the login fields, and the code to the right should highlight these
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the login form appears. Here is the form from the original page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Like the login form we discussed earlier, this file contains username 2 and
    password 3 fields, and the capture works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Upon further inspection, you can see that this site uses the HTTP POST method
    instead of GET, which means you will need to rewrite that line 1 so you can steal
    credentials in the URL, thus writing them to the Apache Access log. HTTP POST
    and HTTP GET are both methods to get information from the server to the client.
    The main difference is that the GET method carries the parameters in the URL,
    which is less secure than the HTTP POST methods, which use the body of the message
    to transfer the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply this to our No Starch login and make some changes so that you can
    change the type to GET and capture the credentials as planned. The file you are
    looking for is under the *nostarch.com/user* directory in *index.html*. You can
    find the file by using the Inspect Element method or manually downloading and
    reviewing the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the part from the existing code that has the form (which can be found
    by searching for the word *form*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make the changes shown in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You first alter the `form action` 1 and the `href` tag 2, which allow us to
    redirect traffic from this page to our *error.html* file. At 3 you can see the
    part of the code that you need to remove so that your fake page does not redirect
    the victim to the real page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll have to make your own version of the *error.html* file referenced in
    this file, but this isn’t hard to do. You could do something as simple as copying
    the existing file and replacing the form with a statement that says something
    like this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can find a sample *error.html* file for a SurveyMonkey page in the GitHub
    repository ([http://sm-phish.seosint.xyz/](http://sm-phish.seosint.xyz/)).
  prefs: []
  type: TYPE_NORMAL
- en: Now test this copy by double-clicking the icon in a file viewer or navigating
    to the host in a browser ([Figure 8-7](#figure8-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![<<“My Account” page of cloned No Starch site. Shows "Log in" tab with error
    message "Sorry, but our site is down for maintenance. Please check back in 24
    hours. We are sorry for any inconveniences this may cause".>>](image_fi/500983c08/f08007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: Displaying a custom error message on a clone of No Starch’s registration
    page'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Web Pages to the Apache Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you can confirm that it works, move your site to Apache’s root directory.
    This will be where we have the SSL/TLS certificate installed and DNS pointing
    to. To accomplish this, you will need to move each HTML file to */var/www/public_html*.
    Any connections to the sites will be recorded in *Access.log*, and that is where
    you’ll collect the data provided by victims.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the *Access.log* for this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up phishing pages is not terribly hard. It can be tedious, though, and
    will determine your success. The quality of your phishing landing pages can make
    the difference between a wildly unsuccessful phish, even against a company lacking
    security awareness, and repeat business through a collaborative relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that the pages should be only as realistic
    as your client wants. If they want this exercise to be a 3 out of 10, you may
    leave off the HTTPS support, include broken links, or use poor grammar. If they
    ask for a 9, throw everything and the kitchen sink at them. Be the best nation-state
    social engineer that you can be!
  prefs: []
  type: TYPE_NORMAL
