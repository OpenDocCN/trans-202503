- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ACCESS CONTROL AND MANAGEMENT**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In IT systems, the management of users and permissions has a long tradition
    because humans have played a central role from the beginning. By contrast, embedded
    systems were not meant for interaction in the past and often come with only a
    few users or even just a single system user.
  prefs: []
  type: TYPE_NORMAL
- en: Today, with the increasing complexity of IoT business models and application
    scenarios, many players are involved in the life-cycle processes of IoT devices—from
    developers to maintenance personnel to third-party service providers to the end
    users themselves. Devices must be able to *handle* all these roles and to *separate*
    them from one another. Further, internal processes and applications running on
    your device will also require various permissions to fulfill their purposes. Restricting
    them according to the principle of least privilege can save your device from severe
    damage.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with a look at a variety of situations where access control
    can make an important contribution to device security. Afterward, I explain common
    concepts you can use to implement access restrictions on devices running Linux.
    The case study at the end of the chapter teases the practical possibilities of
    process restrictions with the AppArmor tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Everyday Threats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Database leaks and breaches happen nearly every day. Often, the data published
    or sold by criminals contains long lists of usernames and passwords. Credentials
    for your IoT devices could be among those secrets, enabling adversaries to log
    into your products. You might jump to the conclusion that these are your customers’
    risks and that you don’t have any responsibility in case of credential theft,
    but that’s not completely true.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to ask yourself at least two questions: “Did we separate end-user
    accounts from manufacturer accounts?” and “Did we restrict those end-user accounts
    as far as possible in order to contain the damage in case of leaked credentials?”
    If you don’t consider these topics, they might boomerang and negatively affect
    your product’s reputation, at the very least.'
  prefs: []
  type: TYPE_NORMAL
- en: On a regular basis, penetration testers, security researchers, or even customers
    identify unknown vulnerabilities in products. And the probability of security
    issues increases with device and software complexity and the number of services
    exposed on network interfaces. Even though you might have established a solid
    vulnerability-management process, as described in [Chapter 1](ch01.xhtml#ch01),
    and are even prepared to roll out updates securely, as explained in [Chapter 9](ch09.xhtml#ch09),
    your product could still be vulnerable during a certain time frame. If such a
    case leads to attacks in the field that significantly affect your devices, the
    obvious question experts will pose is, “Why was the vulnerable application able
    to cause impacts on all of the system’s parts when it has a rather constrained
    purpose?”
  prefs: []
  type: TYPE_NORMAL
- en: Currently, a common topic among manufacturers in multiple industries is the
    transformation of their devices into *platforms* that can install and run apps
    from a corresponding marketplace that is, in turn, fed by app developers all around
    the world. Again, it might seem obvious that those developers are in charge of
    their apps’ security. However, if an actual vulnerability is exploited in an app,
    it’s the responsibility of the platform’s designers to protect system processes
    and configurations as well as other apps from the one causing trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes access control is considered only on a software or OS level. However,
    an additional threat has significant relevance for embedded systems: physical
    access. Attackers as well as penetration testers and researchers can analyze a
    device physically by interacting with local (debug) interfaces like JTAG, Universal
    Asynchronous Receiver-Transmitter (UART), or the Inter-Integrated Circuit (I²C)
    bus.'
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating this threat by stating that “no one will open up our device” and,
    even if so, “the internals are so complex that even our engineers don’t know all
    the details” is common, but it’s rarely reasonable. Interested attackers will
    definitely remove the product housing and look for local interfaces, and if they
    have a certain motivation, they’ll also be willing to spend time on manually reverse
    engineering the device until they reach their goal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Control and Damage Containment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, solid access-control management can reduce or even prevent an
    attack’s impact. It’s a perfect example of how engineers and developers can take
    seriously the principle of defense in depth. If one security layer, like the confidentiality
    of user credentials, fails or an unknown software vulnerability is discovered,
    the access-control layer steps in and prevents the worst consequences.
  prefs: []
  type: TYPE_NORMAL
- en: However, this works only if you have a sound basis for deciding whether access
    should be granted and, if so, how much access is actually necessary. You should
    take several properties into account when granting a user access to an object
    like a file or hardware resource.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions can be granted and denied on the basis of the user’s identity, sometimes
    known as *identity-based access control (IBAC)*. However, managing every single
    user or human independently might be too complicated. Therefore, *role-based access
    control (RBAC)*, which sets permissions according to the user’s role, has gained
    popularity. This not only eases permission management but also requires you to
    explicitly assign roles to every user, which increases transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another access-control approach relies on the attributes of subjects, objects,
    and maybe even their environments. Known as *attribute-based access control (ABAC)*,
    it allows for more dynamic access decisions than IBAC or RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: A common strategy for optimizing access control in terms of security is to reduce
    permissions to the minimum required by a given user or application. However, that’s
    the crux of the matter, because those minimum requirements are often not explicitly
    known.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, developers often tend to set permissions generously, leaving space for
    malicious activities or compromise. Their reasoning is understandable because
    restricting users and applications too much might render the device inoperable.
    And, to make the situation worse, the duties of a user and the access privileges
    of an application might change over time. Therefore, it’s important to consider
    access-control management early and comprehensively over the whole device life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '***Design and Development Phase***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During hardware design, discussions about physical access to IC pins, pads,
    and traces on a PCB should already be on the agenda. Obfuscation of debug ports
    or the application of epoxy resin on critical parts might be solutions to think
    about. The impact of physical access also might be reduced by contact switches
    or springs that indicate to the main processor that the product casing was opened.
  prefs: []
  type: TYPE_NORMAL
- en: For higher security, there’s even the possibility of integrating a conducting
    mesh structure into a plastic case, which continuously runs signals on its lines
    to detect any tampering with the housing. Such mechanisms are already used in
    payment terminals.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of firmware development is the specification of system users,
    their roles, directories, initial files, and corresponding permissions. Even if
    this sounds trivial at first, make sure to take the whole range of your device’s
    intended use cases into account. The results have to be implemented in the build
    system of your choice (for example, Yocto or Buildroot) and should be monitored
    for correctness throughout the whole development process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you must analyze all the device’s software applications and services.
    On the one hand, you must specify in which user context each application should
    be run. This defines the rights a process has at runtime, which becomes especially
    important when it’s taken over by a malicious actor. Consider carefully whether
    root is always your best choice.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, applications can also play an active role in access-control
    management. Let’s take a web server as an example. This common type of application
    has control over the web pages it serves to connected clients. Some parts of the
    web interface, like the page for device administration, might be more critical
    than others. Based on OS users or the web server’s own user management, the server
    has to be configured appropriately to grant admin access only to legitimate users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the application might have several “admin” users: a `webadmin` for
    administration tasks carried out by the web application, a `sysadmin` for Linux
    system administration, and maybe a `superadmin` used for manufacturer access.
    And all of them have different permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Production Considerations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Device production is usually not considered an important step in access-control
    management, but more and more standards—for example, the European ETSI EN 303
    645 for consumer electronics—require devices to refrain from implementing global
    default passwords. Since a device’s firmware is usually a static global artifact,
    a device-individual password has to be generated and set during production.
  prefs: []
  type: TYPE_NORMAL
- en: And it’s not only the firmware that has to be individualized. A piece of paper,
    a sticker, or a part of the product packaging also has to be labeled with the
    individual password. This process depends heavily on your device’s firmware structure
    and your production processes.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to in-production password generation is to force end users to
    set a new, custom password at first login. The advantage of this approach is that
    you can use a single, global firmware image, which is much easier to handle during
    production. However, your product is also left with a universal default password
    that can be used at least once during initialization—by users and adversaries.
  prefs: []
  type: TYPE_NORMAL
- en: '***Customer Activities and Decommissioning***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the field, customers might want to create additional users themselves or
    change the permission of given accounts. You have to decide whether that should
    be possible and, if so, within what limits. Allowing a customer to choose freely
    which permissions to grant could lead to an *elevation of privilege*, resulting
    in the end user receiving more rights than implicitly intended.
  prefs: []
  type: TYPE_NORMAL
- en: Manually changing passwords on hundreds of devices is absolutely tedious and
    also error-prone. Therefore, modern IoT infrastructures require a central management
    of assets and configurations—including users, roles, and permissions—in order
    to stay manageable at all. For device manufacturers, preparing devices to support
    Lightweight Directory Access Protocol (LDAP) integration or something similar
    might be reasonable to ease central management. However, make sure to consider
    the potential threats when you trust a remote server to handle users, credentials,
    and permissions for your device.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, applications should be restricted to the minimum permissions
    necessary to function correctly. However, with every firmware update, the features
    and behavior of a device’s software components might change. New functionality
    might require further permissions, and strict security could be a showstopper.
    Also, security updates might remove software routines that required specific permissions,
    and those permissions wouldn’t be needed anymore afterward. In general, if you
    work with tools that restrict software applications and you update that software,
    you always have to double-check that the related permissions match the new version.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you have to consider that your device might be resold and
    used by another customer. That customer should still be able to initialize the
    device and to reset users and permissions, but shouldn’t have access to data created
    by the previous owner. The same applies for final decommissioning when curious
    dumpster divers or scrap dealers might want to get hold of access-restricted data.
    The original customer should be provided with a “clear all private data” button
    that actually does what it says, and newly added users shouldn’t be able to access
    others’ data even if it isn’t cleared.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discretionary Access Control**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Discretionary access control (DAC)* is a fundamental approach to managing
    access rights of subjects and groups to objects within a system. The subjects
    in our case are users in a Linux OS, while objects might be files, directories,
    memory locations, interprocess communication, and all sorts of system devices
    and interfaces. This methodology is *discretionary* because permissions for a
    certain object are granted *at the discretion* of a user owning this specific
    object; *owners* can pass on permissions to other users and groups.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In Linux systems, the root user is omnipotent. It’s able to override permissions
    set by owners. Therefore, “becoming root” is one of the most attractive goals
    for attackers. For developers, this means processes that could potentially be
    compromised, such as all applications listening on network ports, should never
    run as root!*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Filesystem Permissions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every single file in a Linux filesystem has a permission string associated with
    it. As shown in [Listing 11-1](ch11.xhtml#ch11list01), the `ls` tool can print
    the string always at the beginning of each line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: A file permission listing on Linux*'
  prefs: []
  type: TYPE_NORMAL
- en: The prominent strings `root root` show that all files are owned by the root
    user from the root group, except for the *my_notes.md* file, which is owned by
    *bob* of the *guest* group. Further, the very first character of each line specifies
    whether it’s a regular file (`-`), a directory (`d`), or a symbolic link (`l`).
    Block devices (`b`) and character devices (`c`) would also be indicated there.
    The following nine characters represent the permissions granted for each file.
    They’re separated in three groups of three characters each, concerning read (`r`),
    write (`w`), and execute (`x`) permissions of the owner, a corresponding group,
    and anybody else, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the *README* file in [Listing 11-1](ch11.xhtml#ch11list01) can
    be read and written by the root user, but other users in the root group may only
    read. Read permission is also granted to any other user, no matter in which group,
    as indicated by the trailing `r--`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you read tutorials or third-party source code for Linux access-control
    management, you’ll likely stumble over an efficient, three-digit notation of access
    permissions. The 9-bit permission strings can be written efficiently as three
    octal numbers: one for owner permissions, one for group member permissions, and
    the last one stands for all others.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `777` means that everybody may read, write, and execute a given
    object. In contrast, `740` says that the owner may read, write, and execute; group
    members are allowed only to read; and anybody else has no access rights at all.
    [Table 11-1](ch11.xhtml#ch11tab01) details the conversion of permissions to octal
    numbers, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Octal Representation of Linux File Permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Octal** | **Binary** | **Permissions** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 000 | `---` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 001 | `--x` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 010 | `-w-` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 011 | `-wx` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 100 | `r--` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 101 | `r-x` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 110 | `rw-` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 111 | `rwx` |'
  prefs: []
  type: TYPE_TB
- en: Understanding file permissions is straightforward, but directories behave a
    little bit differently. There, read permission enables the enumeration of items
    within a directory. Write permission grants the right to add, delete, or rename
    directory items. Execute permission allows users to navigate to the directory,
    such as with the `cd` command, and access files or subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux User and Group Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Linux, several tools exist for managing users and groups. The most basic
    commands, available in all distributions, even on embedded systems, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| useradd | Create a new user |'
  prefs: []
  type: TYPE_TB
- en: '| usermod | Modify properties of an existing user |'
  prefs: []
  type: TYPE_TB
- en: '| userdel | Delete a user |'
  prefs: []
  type: TYPE_TB
- en: '| groupadd | Create a new group |'
  prefs: []
  type: TYPE_TB
- en: '| groupmod | Modify properties of an existing group |'
  prefs: []
  type: TYPE_TB
- en: '| groupdel | Delete a group |'
  prefs: []
  type: TYPE_TB
- en: When engineering secure devices, the most important commands are `useradd` and
    `groupadd`, because they can be used at image-creation time to implement users
    and roles defined in an associated access-control concept.
  prefs: []
  type: TYPE_NORMAL
- en: For user creation, of course, the new user’s name has to be provided. Further
    options you might want to specify are its *user identifier*—or *UID* (`--uid`)—its
    home directory (`--home`), and whether this directory should be created automatically
    (`--create-home`). In addition, you can define whether a user group with the same
    name should be created (`--user-group`) and which groups the user should belong
    to (`--groups`). The `--shell` option allows for specifying the shell used after
    login, but it can also be used with `false` and `nologin` to disable user login.
    Finally, you can set the user’s password (in hashed form) with the `--password`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: The main parameters to specify for creating a group with `groupadd` are the
    group’s name and, if desired, a corresponding *group identifier (GID)* (`--gid`)
    that you can use to refer to the specific group at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Users as well as groups might be flagged as belonging to the system (`--system`),
    in contrast to being external, probably human users. Such system accounts receive
    a UID/GID from a reserved system range. In addition, system users don’t expire
    and don’t get a home directory created.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The tools* useradd *and* adduser *as well as* groupadd *and* addgroup *get
    mixed up easily. The ones presented in this section are the basic, portable versions,
    while the others might be more user-friendly in an interactive session.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Permission Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To configure owners, groups, and permissions of files and directories, we need
    three common tools on Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: chown    Allows you to change the owner of a file or directory to another owner.
    For example, the owner of the *web.conf* file can be set to *bob* with `chown
    bob web.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: chgrp    Specifies a new group for a given file or directory. The group of the
    *manuals* directory might be changed to *guest* with `chgrp guest manuals`, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: chmod    Manipulates permissions for files and directories. The call `chmod
    +x script.sh` adds execution permission to the *script.sh* file, while `chmod
    -wx script.sh` removes permissions for writing and execution. Both affect only
    the owner’s permissions. By prepending `g` for group, `o` for others, `u` for
    users/owners, and `a` for all, you can also specify which part of the permission
    string should be affected. For example, `chmod go-rwx private.key` removes all
    access rights of the *private.key* file for all group members and anybody else
    except the owner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Access-Control Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In principle, users and groups enable us to represent any desired access-control
    settings. However, in some cases, the limitation that a file or directory can
    have only a single owner and a single associated group makes efficient access-control
    management difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Let me provide an example because the usefulness might not be obvious. Imagine
    you have a directory called *internal_logs* for storing logs and runtime data.
    Files in this directory are created by five users, all belonging to the *service*
    group. Two years after market release, you introduce a new predictive maintenance
    feature and an associated `predmain` user who needs read access only to the *internal_logs/freqtrack.dat*
    file, and the user shouldn’t be able to write anything—to contain damage in case
    of compromise. You can’t add *predmain* to the *service* group because then it
    would have too many permissions, and you can’t make *predmain* the owner of *freqtrack.dat*
    because, again, compromise would leave an attacker with too much control.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to use access-control lists (ACLs) that are implemented based
    on the extended file attributes (xattr) of a Linux filesystem. Depending on your
    system, ACL support has to be installed, and the filesystem has to be mounted
    with the `acl` option before you can use the `getfacl` and `setfacl` command line
    tools to view and change permissions on a fine-grained level, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Access Control for STM32MP157F-DK2 Firmware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, I first demonstrate a user- and file-initialization process
    with Yocto. Next, I explore the default permissions set by Linux for certain system
    files and the reasoning behind them. Finally, as an example of application-level
    access control, I take a look at the configuration of the SSH daemon Dropbear.
  prefs: []
  type: TYPE_NORMAL
- en: '***User Creation and File Provisioning in Yocto***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first question regarding access control you have to clarify on any Linux
    platform is the way you want to handle the root user. Especially during development,
    the root user might be used regularly and often, even without a password. Make
    sure to remove debug settings for production images. In my case, I removed the
    `debug-tweaks` feature from ST’s `st-image-core` image, as shown in [Listing 11-2](ch11.xhtml#ch11list02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Preparing the root user for production*'
  prefs: []
  type: TYPE_NORMAL
- en: I inherited the `extrausers` class, which allows the modification of the existing
    root user (for example, to protect it with a strong password). The cryptic-looking
    string behind `ROOT_PASSWORD_HASH` is the user password hash format expected by
    Linux. It was obtained by calling `openssl passwd -6` password, where the `-6`
    parameter indicates that a salted hash based on SHA-512 is used. Also note that
    the `$` symbols act as separators in this format and that they need to be escaped
    within Yocto recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In many cases, completely disabling root login makes sense, unless you have
    convincing reasons not to, in order to rule out misuse of this powerful user.*'
  prefs: []
  type: TYPE_NORMAL
- en: Yocto additionally provides the `useradd` class to further provision users and
    groups from within a custom recipe. [Listing 11-3](ch11.xhtml#ch11list03) shows
    the creation of two system users, *rservice* and *lservice*, as well as the end
    users *admin* and *guest*. Also, two corresponding groups are created, and the
    users are added to these groups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: Creating users and groups for the image*'
  prefs: []
  type: TYPE_NORMAL
- en: All users are initialized with a password in the `USERADD_PARAM` variable. Specific
    UIDs are used only for end-user accounts. The `GROUPADD_PARAM` variable allows
    you to create new groups, while `GROUPMEMS_PARAM` enrolls the created users in
    those groups.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you also might want to create directories for users and place
    initial files in them. In [Listing 11-4](ch11.xhtml#ch11list04), a snippet from
    a custom recipe is shown that may serve as a simple example of file provisioning
    for created users, including necessary commands to set owners and groups accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: The basic file provisioning for created users*'
  prefs: []
  type: TYPE_NORMAL
- en: First, home directories for all users are created with corresponding permissions.
    For example, end users should be able to read only provided data, but not to store
    their own code to the device or even execute it. Further, administration information
    should not be accessible for the `guest` user.
  prefs: []
  type: TYPE_NORMAL
- en: Service users, on the other hand, have higher permissions. They may load custom
    data to their directories, while the `lservice` local service user has the highest
    rights because it might even read and write to the remote service user’s directory.
  prefs: []
  type: TYPE_NORMAL
- en: With these basic steps, you can lay the foundation for your device’s access-control
    management.
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploration of System Files and Predefined Users***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Luckily, Linux and its distributions already take care of permission settings
    for a variety of system files. Let’s look at some specific examples within the
    firmware of my STM32MP157F device.
  prefs: []
  type: TYPE_NORMAL
- en: The user and password management on Linux is implemented by the */etc/passwd*
    and */etc/shadow* files. As shown in [Listing 11-5](ch11.xhtml#ch11list05), the
    first file is marked readable for everybody because there might be various good
    reasons to read the list of users on a system. However, the actual password hash
    of each user is not included in the *passwd* file. It resides in the *shadow*
    file, which is readable only by root for login verification purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: The access rights to password files on Linux*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shadowing* password storage has been done for decades. The main idea is to
    restrict the access of unprivileged users to password hashes, because if a user
    uses a weak password, an adversary with access to the corresponding password hash
    would be able to launch a brute-force attack against it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you wonder how passwords could be changed if* /etc/shadow *is only readable,
    even for root: the superuser root has similar powers to Chuck Norris; it can even
    write to read-only files.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-6](ch11.xhtml#ch11list06) shows the permission strings for my device’s
    microSD card (*/dev/mmcblk0*), the Linux RNG device (*/dev/urandom*), and the
    hardware RNG device of the STM32MP157F (*/dev/hwrng*).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: The permissions for a microSD card and RNG devices*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that, for device files, the permission string indicates whether
    it’s a block device (`b`) or a character device (`c`). The results also show that
    the microSD card can be read only by root or members of the *disk* group. For
    RNGs, the system differentiates between the OS-provided RNG `urandom`, which can
    be read and written be everyone, and the hardware RNG device `hwrng`, which only
    root may access.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s shift the focus from files to processes. [Listing 11-7](ch11.xhtml#ch11list07)
    shows typical applications like the web server `httpd` or the MQTT broker `mosquitto`
    and the corresponding users executing these processes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: The user context of typical network daemons*'
  prefs: []
  type: TYPE_NORMAL
- en: The web server `httpd` exhibits a common strategy to limit the attack surface
    in case a vulnerability could be exploited remotely. It starts under the root
    user, binds to its designated port (for example, 80), and then deliberately drops
    its high privileges by altering its GID and UID by calls to `setgid()` and `setuid()`,
    respectively. Therefore, in my case, the four “worker threads” of `httpd` run
    under the low-privilege user *daemon*.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for the Mosquitto broker. You can infer from its documentation
    that, even if started as the root user, Mosquitto immediately drops privileges
    after reading its configuration file and continues running in the context of a
    more limited user, called `mosquitto` in my case.
  prefs: []
  type: TYPE_NORMAL
- en: The output of usernames by `ps` is limited to eight characters. Therefore, `mosquitto`
    becomes `mosquitt`.
  prefs: []
  type: TYPE_NORMAL
- en: '***SSH Daemon Access-Control Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Dropbear* is a lightweight SSH daemon that’s especially popular on embedded
    systems. It enables secure remote access to a device, which makes it perfectly
    useful but also absolutely critical. Applications like that deserve dedicated
    consideration regarding access-control settings, because if they implement an
    “open door policy,” it’s literally an invitation for attackers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-8](ch11.xhtml#ch11list08) shows a part of the command line arguments
    for the `dropbear` daemon that are interesting from an access-control point of
    view.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8: Some access-control options for* dropbear'
  prefs: []
  type: TYPE_NORMAL
- en: Disabling root access over SSH (`-w`) is a good idea in most instances. For
    this case study, it might also be reasonable to restrict SSH access to users from
    the *service* group (`-G`), because it shouldn’t be a feature for end users. Disabling
    password logins completely and allowing only public-key authentication would be
    perfect, but if your PKI is not yet prepared for this step, the `-s` option isn’t
    possible. Since we completely disabled root access, using `-g` would be redundant.
    The `-B` argument should be used only during development; you probably don’t want
    to find this in a production firmware image. Lastly, you can restrict the maximum
    number of login tries—for example, to three (`-T 3`).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also change the port of the* dropbear *SSH daemon from 22 to a custom
    one with the* -p *option. That’s just obscurity, but it might save your internet-connected
    device from being discovered by automated SSH scans.*'
  prefs: []
  type: TYPE_NORMAL
- en: To store your `dropbear` settings persistently, you have to change the */etc/dropbear/default*
    file in your firmware image. The important line that it should contain to implement
    the discussed access-control restrictions is `DROPBEAR_EXTRA_ARGS="-w -T 3 -G
    service"`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandatory Access Control**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While DAC concepts are usually known among embedded system developers, *mandatory
    access control (MAC)* is often uncharted territory. However, MAC implementations
    can contribute significantly to a device’s security and to the containment of
    damage in case of compromise.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of MAC systems for embedded devices is that permissions and policies
    regarding the way users and processes may interact with files and other resources
    are managed by the manufacturer and enforced by the OS. In contrast to the user-centric
    approach of DAC, users can’t override the rules defined by MAC.
  prefs: []
  type: TYPE_NORMAL
- en: MAC implementations are powerful tools, but with power comes responsibility.
    *Whitelisting* is a popular access-control strategy in which access is denied
    by default and granted only if explicitly allowed. This approach can also be used
    for MAC systems to permit only defined access of subjects to objects. However,
    if you omit specifying a legitimate access as “allowed,” maybe because it’s used
    infrequently, an application that requires it might crash during runtime whenever
    the access occurs.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose a *blacklisting* approach—defining only dangerous cases for which
    access should be denied, like malware detected by virus scanners—the probability
    of breaking functionality is reduced. However, you have to ensure that corresponding
    rules for newly discovered malicious behavior find their way into your devices
    in a timely manner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Security Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the Linux community was not able to agree on one specific security module,
    Linux introduced the *Linux Security Module (LSM)* framework. It enables the implementation
    of various MAC systems for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: These LSMs are compiled into the Linux kernel and take action if specific hook
    functions are called within the kernel code. These hooks are integrated in all
    procedures relevant for access control within the OS, from file access to task
    spawning to interprocess communication. If reached, the kernel hands over control
    to the LSM, which is able to at least log the performed action or directly decide
    whether access should be granted or denied based on its specific rule set.
  prefs: []
  type: TYPE_NORMAL
- en: 'LSM implementations differ significantly in terms of their concepts, their
    way of configuring rule sets, and their supporting community. However, they also
    share a common property: all have a negative impact on system performance. The
    following sections introduce popular LSM implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: '***SELinux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In 2000, the NSA published its idea of a MAC system for Linux to the open source
    community: *Security-Enhanced Linux (SELinux)*. Supported by other stakeholders
    in this field, the project flourished and was finally integrated into version
    2.6 of the mainline Linux kernel in 2003\. Since version 4.3, it’s the default
    LSM in Android, and many Linux distributions for desktop and server applications
    support it.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux relies on security policies that define which objects might be accessed
    by which subjects. For this purpose, objects and subjects must be registered in
    SELinux with corresponding *labels* containing a user, a role, and an associated
    type. These labels define a kind of context or domain for subjects and objects.
    The actual access control is implemented by *type enforcement*, which defines
    whether a subject with a specific type can access an object with a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: Many Linux distributions provide their own set of predefined SELinux policies
    to restrict a variety of common applications and services. Further, there is a
    database of reference policies that you can use for your purposes. However, creating
    custom policies for your applications requires deep know-how about their functionalities
    and a detailed understanding of the SELinux concepts and structures. You should
    not underestimate the necessary characterization efforts, even if tools are available
    to support you.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, SELinux can be operated in three ways. The *enforcing* mode is meant
    for productive use, because it strictly applies all given policies and logs corresponding
    activities. However, during development or in a test phase, the *permissive* mode
    is more suitable. It processes all policies, but only generates warnings and log
    data without enforcing the defined rules. This can be enormously helpful for fine-tuning
    custom policies and troubleshooting. If *disabled*, SELinux is turned off completely
    and doesn’t protect or restrict anything.
  prefs: []
  type: TYPE_NORMAL
- en: Although (or perhaps precisely because) SELinux provides a vast number of capabilities,
    it’s a pretty complex tool that many embedded system engineers refrain from using.
    This is probably the main reason other LSM implementations emerged and became
    popular alternatives, as described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '***AppArmor***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*AppArmor* is the second LSM implementation to gain significant popularity
    among Linux distributions. It became part of the Linux kernel 2.6.36 in 2010 and
    is currently the default MAC system for Ubuntu and SUSE Linux. Its development
    has been funded by Canonical since 2009.'
  prefs: []
  type: TYPE_NORMAL
- en: Access control is managed on the basis of individual profiles per application.
    In contrast to SELinux, AppArmor uses filesystem paths to identify subjects and
    file objects, so the syntax offers better readability. Further, it allows a hybrid
    approach of whitelisting and blacklisting rules that control the resource access
    of a process. The created profiles can restrict network access and various sorts
    of Linux capabilities, but also permissions to read, write, and execute files.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor comes with a list of predefined profiles, and additional profiles for
    common applications are maintained by the Ubuntu community. Additionally, AppArmor
    provides several tools that support developers in profiling custom applications
    and generating corresponding profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, there are two ways of characterizing access requirements.
    First, targeted profiling allows you to capture access events of a single application
    and to automatically generate a profile from it. Second, AppArmor can apply a
    systemic monitoring approach that logs access operations of a defined set of applications
    for days or even weeks and spanning multiple reboots. The collected log information
    can then be turned into a series of profiles restricting the analyzed applications
    in a preferably optimal way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each AppArmor profile available on a device can be put into one of three modes
    at runtime: enforce, complain, or audit. In *enforcement mode*, the rules set
    by the profile are enforced, and violation attempts are logged. The *complain
    mode* allows for monitoring an application’s behavior under a defined profile,
    and operations that violate the policy are logged. This mode is also used in the
    automated profile creation mentioned previously and is therefore sometimes called
    AppArmor’s *learning mode*. To log all access, whether successful or not, while
    enforcing a given policy, the *audit mode* has to be selected.'
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor is a worthy alternative to SELinux that succeeds in reducing configuration
    and profiling complexity. From a security point of view, it’s sometimes more lax
    than its competitor and leaves space to circumvent access control in specific
    cases. For embedded systems, however, it might be a perfect compromise to introduce
    MAC mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other LSMs and Non-LSM MACs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides the two popular LSM implementations, SELinux and AppArmor, you might
    want to consider further options.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, the *Simplified Mandatory Access Control Kernel (SMACK)*
    system was developed with a focus on simplicity, in contrast to the complexity
    of SELinux. It has been part of the Linux mainline kernel since 2008 and was always
    meant for use in embedded systems. Two larger OS projects rely on its protection
    mechanisms: the mobile OS Tizen used in Samsung’s smart TVs, and the automotive-grade
    Linux distribution meant as an open source platform for connected cars. However,
    looking at SMACK’s website and its Git repositories, it seems that it’s no longer
    actively maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A further MAC system based on the LSM framework is called *TOMOYO*. The project
    was started in 2003 and merged into the Linux kernel 2.6.30 in 2009\. Again, the
    motivation was simpler usage and higher usability—for example, as implemented
    by an automatic policy generation, which is also necessary because this MAC system
    doesn’t come with a comprehensive set of rules for common services. In addition,
    TOMOYO not only serves as a MAC implementation but also facilitates system behavior
    analysis. It comes in three versions: 1.*x*, 2.*x*, and AKARI. The first one requires
    specific kernel patching and is, therefore, usually not your first choice. AKARI
    and TOMOYO 2.*x* use the LSM framework. At the time of writing, AKARI provides
    a few more features, but TOMOYO 2.*x* is catching up.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the LSM framework provides a multitude of possibilities for integrating
    custom security modules, not everybody in the community is satisfied with its
    implementation, especially considering the performance overhead it generates.
    Therefore, non-LSM MAC systems also exist that aim for higher performance or enhanced
    security module features. However, since those implementations are not part of
    the mainline kernel and have to be integrated by applying a custom set of patches,
    they might be an option only if you really can’t reach your requirements with
    the popular LSM implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Application Confinement with AppArmor**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, I shed light on the installation of AppArmor with the Yocto
    toolchain of my STM32MP157F-DK2 device and walk through its basic usage to restrict
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AppArmor is not included in the default installation of ST’s OpenSTLinux distribution.
    Luckily, the Yocto `meta-security` layer maintained by Armin Kuster provides an
    AppArmor recipe under *meta-security/recipes-mac/AppArmor*.
  prefs: []
  type: TYPE_NORMAL
- en: After cloning the corresponding Git repository, the Linux kernel can be configured
    for AppArmor usage with the settings shown in [Listing 11-9](ch11.xhtml#ch11list09).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-9: The Linux kernel configuration to enable AppArmor*'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines enable AppArmor, and the last two lines set it as the default
    LSM to be used. However, I also had to add `security=apparmor` to the kernel’s
    boot arguments in U-Boot’s *extlinux.conf* files to select AppArmor at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: To compile and install the AppArmor user-space tools, add the line `IMAGE_INSTALL
    += "apparmor"` to the image’s recipe. I also had to add several distro features
    to the provided OpenSTLinux, as shown in [Listing 11-10](ch11.xhtml#ch11list010),
    in order to make Yocto successfully complete the building process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-10: The distro features for AppArmor from* meta-security'
  prefs: []
  type: TYPE_NORMAL
- en: After booting the device, you can check whether AppArmor is actually enabled
    with the command shown in [Listing 11-11](ch11.xhtml#ch11list011). If it returns
    a `Y`, it was activated properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-11: Checking whether AppArmor was enabled correctly*'
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor comes with the `aa-status` tool, which lists a variety of details regarding
    AppArmor’s current status, as shown in [Listing 11-12](ch11.xhtml#ch11list012).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-12: The initial output of* aa-status'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the AppArmor recipe from the `meta-security` layer also installs
    a set of 50 standard profiles that are loaded in enforce mode on my device. However,
    the first thing I noticed is that although there are profiles loaded for `apache2`
    and `syslogd`, the corresponding, currently running processes are not confined.
    Only the `avahi-daemon` processes are restricted according to their profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To investigate this issue, we have to take a look at the default AppArmor profiles
    stored in */etc/apparmor.d/*. For `apache2`, the file containing the provided
    profile is called *usr.sbin.apache2*. The filename is already a hint for the path
    of the executable it confines: */usr/sbin/apache2*, in this case. Looking at the
    content of the file, you can see a line stating `profile apache2 /usr/\{bin, sbin\}/apache2`,
    which means that the profile at hand is named `apache2` and targets the executable
    *apache2* located at */usr/bin/* or */usr/sbin/*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this file doesn’t exist in my installation. Instead, it’s called
    *httpd*. Therefore, I created a copy of the initial file named *usr.sbin.httpd*.
    I also changed the profile name to `httpd` and the path for the executable to
    `/usr/\{bin,sbin\}/httpd`. Afterward, I loaded the profile in enforce mode as
    shown in [Listing 11-13](ch11.xhtml#ch11list013) and restarted the web server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-13: Loading and disabling profiles*'
  prefs: []
  type: TYPE_NORMAL
- en: I also disabled the original profile with the help of `aa-disable` in order
    to clean up.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-14](ch11.xhtml#ch11list014) presents the output of another call
    to `aa-status`, showing that the `httpd` profile was loaded correctly and that
    all four corresponding process instances are running in enforce mode as desired.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-14: The output of* aa-status *after profile changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Although we succeeded in activating the predefined profile, we have no idea
    whether the profile actually restricts the web server application in a secure
    way. A comment in the given profile says that “this profile is completely permissive,”
    which means that you still have to customize it according to your application
    and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: A quick look at the profile *sbin.syslogd* associated with the `syslogd` tool,
    the second example binary identified at the beginning of this subsection, reveals
    that the configured path, */sbin/syslogd*, matches the path of the corresponding
    executable, but the process is still not running in enforce mode. The properties
    of the binary, as shown in [Listing 11-15](ch11.xhtml#ch11list015), reveal that
    the executable is actually a symbolic link to another executable—namely, */bin/busybox.nosuid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-15: A symbolic link to another executable*'
  prefs: []
  type: TYPE_NORMAL
- en: This makes the situation somewhat complicated because BusyBox unites a variety
    of tools in one binary. Simply changing the `syslogd` profile’s path doesn’t solve
    this issue but rather causes further problems with other Busy-Box functionalities.
    In such cases, you have several options. You could just spare the `syslogd` profile,
    you could search for or create a comprehensive `busybox` profile, or you could
    install and use the original `syslogd` application after all.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Profiling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For your own applications or third-party tools that don’t come with a predefined
    AppArmor profile, you have to create one yourself if you want to confine them
    with MAC mechanisms at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a very simple Python application that was reduced to the minimum.
    [Listing 11-16](ch11.xhtml#ch11list016) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-16: A simple file-printing application in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: This application’s sole purpose is to print the content of a text file given
    as a command line argument. The application’s filename is *printfile.py*, it’s
    located in */home/root/*, and it’s marked as executable.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that this tool is an essential part of your web interface and needs
    to run with superuser privileges because it has to print the content of the *testfile*
    and *logfile* files, which are accessible only by root. However, during your threat
    and risk analysis, you discover that adversaries might be able to inject other
    filepaths than the two intended ones, which could lead to the exposure of sensitive
    information and should be prevented—for example, by using a custom-tailored AppArmor
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-17](ch11.xhtml#ch11list017) shows the basic initial profile I created
    at */etc/apparmor.d/ home.root.printfile.py* as a starting point for profiling
    this application. It includes read access (`r`) for the two previously mentioned
    files and denies any other file access.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-17: The initial AppArmor profile for* printfile.py'
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, I loaded the newly created profile in complain mode, as
    shown in [Listing 11-18](ch11.xhtml#ch11list018).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-18: Loading a profile in complain mode*'
  prefs: []
  type: TYPE_NORMAL
- en: If you now execute `./printfile.py testfile` in *home/root/*, the application
    will work without issues but will create log entries for all profile violations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-19](ch11.xhtml#ch11list019) shows a pruned set of AppArmor kernel
    messages corresponding to *printfile.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-19: The AppArmor complain messages for* printfile.py'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that multiple access violations occurred while just calling *printfile.py*
    in its intended way. If you put the initial profile in enforce mode, the application
    won’t work anymore. Therefore, you have to use the depicted output to extend the
    AppArmor profile for *printfile.py*. For example, you have to grant read access
    (`r`) to */etc/ld.so.cache*, execution rights (`ux`) for */usr/bin/python3.10*,
    and permissions for reading (`r`) and mapping (`m`) */usr/lib/libpython3.10.so.1.0*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-20](ch11.xhtml#ch11list020) shows the final profile after four
    iterations of execution in complain mode, profile refinement, and reloading.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-20: The AppArmor profile for* printfile.py *after refinement*'
  prefs: []
  type: TYPE_NORMAL
- en: After this manual characterization phase, the created profile can be loaded
    in enforce mode and tested for its behavior ([Listing 11-21](ch11.xhtml#ch11list021)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-21: Testing* printfile.py *in enforce mode*'
  prefs: []
  type: TYPE_NORMAL
- en: Printing the *testfile* and *logfile* files works as intended. However, if attackers
    try to read the *secrets* file in the same folder or even the */etc/passwd* file,
    AppArmor successfully protects from severe damage.
  prefs: []
  type: TYPE_NORMAL
- en: This simple case study showed the basic feasibility of application characterization
    and corresponding AppArmor profile creation. However, even this trivial example
    took several profiling iterations, and the resulting profile will need to be maintained
    continuously—for example, if you switch to another distribution or even a newer
    version of Python. Further, as you can imagine, more complex applications require
    significantly more characterization and testing efforts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access control is an enormously broad topic that could fill a whole book on
    its own. It encompasses the basic configurations of users, groups, directory structures,
    and access permissions (as discussed in this chapter for the Linux DAC system),
    the deactivation of hardware debugging features and tools not meant for end users,
    and the complex field of OS-enforced MAC policies that have to be fine-tuned to
    the individual behavior and resource-access demands of a specific application.
    And while I don’t expect you to invest all your time designing perfect access-control
    settings, there’s no way around this matter in secure device engineering.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we have to find practically feasible compromises. A complete whitelisting
    approach might be hard to implement and can lead to broken applications if misconfigured,
    for which security will be blamed. Blacklisting, on the other hand, won’t be able
    to immediately catch new threats that appear in the field. A fine granularity
    of permissions can be managed over time only if you are willing to expend significant
    effort, but if your access-control concept is too simplistic, your adversaries
    will thank you for removing that annoying obstacle in the way.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I’d like to point out that access-control mechanisms always have a
    strong relation to system-integrity protection, as described in [Chapter 8](ch08.xhtml#ch08).
    Just imagine if you painstakingly defined a perfect set of access rules only to
    find out that an attacker can reset them all to 777 within minutes. That would
    hurt.
  prefs: []
  type: TYPE_NORMAL
