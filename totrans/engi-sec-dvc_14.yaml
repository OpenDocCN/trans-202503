- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: ACCESS CONTROL AND MANAGEMENT**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制与管理**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In IT systems, the management of users and permissions has a long tradition
    because humans have played a central role from the beginning. By contrast, embedded
    systems were not meant for interaction in the past and often come with only a
    few users or even just a single system user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT系统中，用户和权限的管理有着悠久的历史，因为从一开始，人类就在其中扮演了重要角色。相比之下，嵌入式系统过去并不打算进行交互，通常只有少数用户，甚至只有一个系统用户。
- en: Today, with the increasing complexity of IoT business models and application
    scenarios, many players are involved in the life-cycle processes of IoT devices—from
    developers to maintenance personnel to third-party service providers to the end
    users themselves. Devices must be able to *handle* all these roles and to *separate*
    them from one another. Further, internal processes and applications running on
    your device will also require various permissions to fulfill their purposes. Restricting
    them according to the principle of least privilege can save your device from severe
    damage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，随着物联网商业模型和应用场景的日益复杂，许多参与者都涉及到物联网设备的生命周期过程——从开发者、维护人员、第三方服务提供商到最终用户。设备必须能够*处理*这些不同的角色，并将它们*分离*开来。此外，设备上运行的内部过程和应用程序也需要各种权限来完成其目的。按照最小权限原则限制这些权限，可以避免设备遭受严重损害。
- en: This chapter starts with a look at a variety of situations where access control
    can make an important contribution to device security. Afterward, I explain common
    concepts you can use to implement access restrictions on devices running Linux.
    The case study at the end of the chapter teases the practical possibilities of
    process restrictions with the AppArmor tool.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从多个角度讨论访问控制如何对设备安全做出重要贡献。接下来，我将介绍你可以用来在运行Linux的设备上实现访问限制的常见概念。章末的案例研究则展示了如何使用AppArmor工具对进程进行限制的实际可能性。
- en: '**Everyday Threats**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**日常威胁**'
- en: Database leaks and breaches happen nearly every day. Often, the data published
    or sold by criminals contains long lists of usernames and passwords. Credentials
    for your IoT devices could be among those secrets, enabling adversaries to log
    into your products. You might jump to the conclusion that these are your customers’
    risks and that you don’t have any responsibility in case of credential theft,
    but that’s not completely true.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库泄露和漏洞几乎每天都会发生。犯罪分子发布或出售的数据往往包含大量的用户名和密码。你的物联网设备的凭证可能也在这些泄露的秘密中，使得攻击者能够登录到你的产品。你可能会得出结论，认为这些是客户的风险，并且在凭证被盗的情况下，你不需要承担任何责任，但这并不完全正确。
- en: 'You have to ask yourself at least two questions: “Did we separate end-user
    accounts from manufacturer accounts?” and “Did we restrict those end-user accounts
    as far as possible in order to contain the damage in case of leaked credentials?”
    If you don’t consider these topics, they might boomerang and negatively affect
    your product’s reputation, at the very least.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你至少需要问自己两个问题：“我们是否将最终用户账户与制造商账户分开？”以及“我们是否尽可能限制这些最终用户账户，以便在凭证泄露时控制损害？”如果你不考虑这些问题，它们可能会反弹，至少会对你产品的声誉产生负面影响。
- en: On a regular basis, penetration testers, security researchers, or even customers
    identify unknown vulnerabilities in products. And the probability of security
    issues increases with device and software complexity and the number of services
    exposed on network interfaces. Even though you might have established a solid
    vulnerability-management process, as described in [Chapter 1](ch01.xhtml#ch01),
    and are even prepared to roll out updates securely, as explained in [Chapter 9](ch09.xhtml#ch09),
    your product could still be vulnerable during a certain time frame. If such a
    case leads to attacks in the field that significantly affect your devices, the
    obvious question experts will pose is, “Why was the vulnerable application able
    to cause impacts on all of the system’s parts when it has a rather constrained
    purpose?”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员、安全研究人员，甚至是客户，都会定期发现产品中的未知漏洞。随着设备和软件复杂度的增加，以及网络接口上暴露的服务数量的增加，安全问题的概率也会增加。即使你已经建立了一个稳健的漏洞管理流程，如[第1章](ch01.xhtml#ch01)所述，并且准备好以安全的方式发布更新，如[第9章](ch09.xhtml#ch09)所解释的那样，你的产品在某些时间段内仍然可能会有漏洞。如果这种情况导致在实际应用中发生攻击，严重影响设备，专家们自然会问：“为什么这个有漏洞的应用程序在其目的相对有限的情况下，竟然能够影响系统的所有部分？”
- en: Currently, a common topic among manufacturers in multiple industries is the
    transformation of their devices into *platforms* that can install and run apps
    from a corresponding marketplace that is, in turn, fed by app developers all around
    the world. Again, it might seem obvious that those developers are in charge of
    their apps’ security. However, if an actual vulnerability is exploited in an app,
    it’s the responsibility of the platform’s designers to protect system processes
    and configurations as well as other apps from the one causing trouble.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，多个行业的制造商普遍讨论的一个话题是将他们的设备转变为*平台*，可以从相应的市场安装并运行应用程序，而这些市场又由全球的应用程序开发者提供支持。同样，可能看起来显而易见的是，这些开发者负责其应用程序的安全。然而，如果应用程序中实际存在的漏洞被利用，那么保护系统进程和配置以及其他应用免受问题应用影响的责任将落在平台设计者身上。
- en: 'Sometimes access control is considered only on a software or OS level. However,
    an additional threat has significant relevance for embedded systems: physical
    access. Attackers as well as penetration testers and researchers can analyze a
    device physically by interacting with local (debug) interfaces like JTAG, Universal
    Asynchronous Receiver-Transmitter (UART), or the Inter-Integrated Circuit (I²C)
    bus.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，访问控制只在软件或操作系统层面上被考虑。然而，对于嵌入式系统来说，另一个额外的威胁具有重要的相关性：物理访问。攻击者以及渗透测试人员和研究人员可以通过与本地（调试）接口如JTAG、通用异步接收器-发射器（UART）或互连电路（I²C）总线交互来对设备进行物理分析。
- en: Mitigating this threat by stating that “no one will open up our device” and,
    even if so, “the internals are so complex that even our engineers don’t know all
    the details” is common, but it’s rarely reasonable. Interested attackers will
    definitely remove the product housing and look for local interfaces, and if they
    have a certain motivation, they’ll also be willing to spend time on manually reverse
    engineering the device until they reach their goal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声称“没有人会打开我们的设备”，甚至如果真有人打开，“内部结构如此复杂，就连我们的工程师都不了解所有细节”来减轻这种威胁是常见的，但这种说法很少是合理的。有兴趣的攻击者肯定会拆开产品外壳并寻找本地接口，如果他们有一定动机，他们也会愿意花时间手动进行设备反向工程，直到达到他们的目的。
- en: '**Access Control and Damage Containment**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**访问控制与损害隔离**'
- en: In many cases, solid access-control management can reduce or even prevent an
    attack’s impact. It’s a perfect example of how engineers and developers can take
    seriously the principle of defense in depth. If one security layer, like the confidentiality
    of user credentials, fails or an unknown software vulnerability is discovered,
    the access-control layer steps in and prevents the worst consequences.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，完善的访问控制管理可以减少甚至防止攻击的影响。这是一个完美的例子，展示了工程师和开发者如何严肃对待深度防御原则。如果一个安全层（如用户凭证的机密性）失败，或发现未知的软件漏洞，访问控制层将介入并防止最严重的后果。
- en: However, this works only if you have a sound basis for deciding whether access
    should be granted and, if so, how much access is actually necessary. You should
    take several properties into account when granting a user access to an object
    like a file or hardware resource.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只有在你有一个合理的基础来决定是否应当授予访问权限，以及在授予权限时，实际需要多少访问权限的情况下才有效。在授予用户访问文件或硬件资源等对象的权限时，你应该考虑几个属性。
- en: Permissions can be granted and denied on the basis of the user’s identity, sometimes
    known as *identity-based access control (IBAC)*. However, managing every single
    user or human independently might be too complicated. Therefore, *role-based access
    control (RBAC)*, which sets permissions according to the user’s role, has gained
    popularity. This not only eases permission management but also requires you to
    explicitly assign roles to every user, which increases transparency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以根据用户身份授予或拒绝，这种方法有时被称为*基于身份的访问控制（IBAC）*。然而，独立地管理每个用户或人可能过于复杂。因此，*基于角色的访问控制（RBAC）*应运而生，它根据用户的角色来设定权限。这不仅简化了权限管理，而且要求你明确地将角色分配给每个用户，从而提高了透明度。
- en: Yet another access-control approach relies on the attributes of subjects, objects,
    and maybe even their environments. Known as *attribute-based access control (ABAC)*,
    it allows for more dynamic access decisions than IBAC or RBAC.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种访问控制方法依赖于主体、对象，甚至可能是它们的环境的属性。这种方法被称为*基于属性的访问控制（ABAC）*，它比IBAC或RBAC能做出更动态的访问决策。
- en: A common strategy for optimizing access control in terms of security is to reduce
    permissions to the minimum required by a given user or application. However, that’s
    the crux of the matter, because those minimum requirements are often not explicitly
    known.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 优化安全性方面的访问控制的常见策略是将权限减少到给定用户或应用程序所需的最低权限。然而，这正是问题的关键，因为这些最低要求通常并不明确知道。
- en: Thus, developers often tend to set permissions generously, leaving space for
    malicious activities or compromise. Their reasoning is understandable because
    restricting users and applications too much might render the device inoperable.
    And, to make the situation worse, the duties of a user and the access privileges
    of an application might change over time. Therefore, it’s important to consider
    access-control management early and comprehensively over the whole device life
    cycle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发人员通常倾向于慷慨地设置权限，给恶意活动或入侵留下空间。他们的理由是可以理解的，因为过度限制用户和应用程序可能导致设备无法操作。而且，情况可能更糟的是，用户的职责和应用程序的访问权限可能随着时间的推移而发生变化。因此，重要的是要尽早并全面地考虑访问控制管理，贯穿整个设备生命周期。
- en: '***Design and Development Phase***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设计与开发阶段***'
- en: During hardware design, discussions about physical access to IC pins, pads,
    and traces on a PCB should already be on the agenda. Obfuscation of debug ports
    or the application of epoxy resin on critical parts might be solutions to think
    about. The impact of physical access also might be reduced by contact switches
    or springs that indicate to the main processor that the product casing was opened.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件设计过程中，关于对IC引脚、焊盘和PCB上的迹线的物理访问的讨论应该已经提上议程。调试端口的模糊化或在关键部件上应用环氧树脂可能是需要考虑的解决方案。通过接触开关或弹簧，产品外壳被打开时向主处理器发出信号，也可能减少物理访问的影响。
- en: For higher security, there’s even the possibility of integrating a conducting
    mesh structure into a plastic case, which continuously runs signals on its lines
    to detect any tampering with the housing. Such mechanisms are already used in
    payment terminals.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高安全性，甚至可以将导电网格结构集成到塑料外壳中，持续运行信号以检测外壳是否遭到篡改。此类机制已在支付终端中得到应用。
- en: An important part of firmware development is the specification of system users,
    their roles, directories, initial files, and corresponding permissions. Even if
    this sounds trivial at first, make sure to take the whole range of your device’s
    intended use cases into account. The results have to be implemented in the build
    system of your choice (for example, Yocto or Buildroot) and should be monitored
    for correctness throughout the whole development process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 固件开发的重要部分是系统用户、他们的角色、目录、初始文件和相应权限的规范。即使这听起来微不足道，也要确保考虑到设备预期使用情况的整个范围。结果必须在你选择的构建系统中实现（例如Yocto或Buildroot），并且在整个开发过程中应监控其正确性。
- en: Next, you must analyze all the device’s software applications and services.
    On the one hand, you must specify in which user context each application should
    be run. This defines the rights a process has at runtime, which becomes especially
    important when it’s taken over by a malicious actor. Consider carefully whether
    root is always your best choice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须分析设备的所有软件应用程序和服务。一方面，必须指定每个应用程序应该在哪个用户上下文中运行。这定义了进程在运行时拥有的权限，当进程被恶意行为者接管时，这一点尤为重要。仔细考虑是否root总是最好的选择。
- en: On the other hand, applications can also play an active role in access-control
    management. Let’s take a web server as an example. This common type of application
    has control over the web pages it serves to connected clients. Some parts of the
    web interface, like the page for device administration, might be more critical
    than others. Based on OS users or the web server’s own user management, the server
    has to be configured appropriately to grant admin access only to legitimate users.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，应用程序也可以在访问控制管理中发挥积极作用。以Web服务器为例。这种常见的应用程序控制它为连接的客户端提供的网页。某些网页界面部分，如设备管理页面，可能比其他部分更为关键。基于操作系统用户或Web服务器自己的用户管理，服务器必须适当配置，只允许合法用户访问管理员权限。
- en: 'Of course, the application might have several “admin” users: a `webadmin` for
    administration tasks carried out by the web application, a `sysadmin` for Linux
    system administration, and maybe a `superadmin` used for manufacturer access.
    And all of them have different permissions.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序可能有多个“管理员”用户：一个用于网页应用管理任务的`webadmin`，一个用于Linux系统管理的`sysadmin`，还有一个可能用于制造商访问的`superadmin`。这些用户都有不同的权限。
- en: '***Production Considerations***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生产考虑事项***'
- en: Device production is usually not considered an important step in access-control
    management, but more and more standards—for example, the European ETSI EN 303
    645 for consumer electronics—require devices to refrain from implementing global
    default passwords. Since a device’s firmware is usually a static global artifact,
    a device-individual password has to be generated and set during production.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设备生产通常不被视为访问控制管理中的重要步骤，但越来越多的标准——例如欧洲的ETSI EN 303 645消费电子标准——要求设备避免实施全球默认密码。由于设备的固件通常是一个静态的全球性工件，因此必须在生产过程中生成并设置设备专有的密码。
- en: And it’s not only the firmware that has to be individualized. A piece of paper,
    a sticker, or a part of the product packaging also has to be labeled with the
    individual password. This process depends heavily on your device’s firmware structure
    and your production processes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是固件需要个性化。纸张、标签或产品包装的一部分也需要标明个别密码。这个过程很大程度上依赖于设备的固件结构和生产过程。
- en: An alternative to in-production password generation is to force end users to
    set a new, custom password at first login. The advantage of this approach is that
    you can use a single, global firmware image, which is much easier to handle during
    production. However, your product is also left with a universal default password
    that can be used at least once during initialization—by users and adversaries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 生产过程中密码生成的替代方案是强制终端用户在首次登录时设置新的自定义密码。这种方法的优点是可以使用单一的全球固件镜像，这在生产过程中更容易处理。然而，这样做也意味着你的产品仍然会有一个可以在初始化时至少使用一次的通用默认密码——无论是用户还是攻击者都可以使用。
- en: '***Customer Activities and Decommissioning***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***客户活动与报废***'
- en: In the field, customers might want to create additional users themselves or
    change the permission of given accounts. You have to decide whether that should
    be possible and, if so, within what limits. Allowing a customer to choose freely
    which permissions to grant could lead to an *elevation of privilege*, resulting
    in the end user receiving more rights than implicitly intended.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在现场，客户可能希望自行创建额外的用户或更改已有账户的权限。你必须决定是否允许这样做，如果允许，应在什么范围内。允许客户自由选择授予哪些权限可能导致*权限提升*，从而使最终用户获得比原本预期更多的权限。
- en: Manually changing passwords on hundreds of devices is absolutely tedious and
    also error-prone. Therefore, modern IoT infrastructures require a central management
    of assets and configurations—including users, roles, and permissions—in order
    to stay manageable at all. For device manufacturers, preparing devices to support
    Lightweight Directory Access Protocol (LDAP) integration or something similar
    might be reasonable to ease central management. However, make sure to consider
    the potential threats when you trust a remote server to handle users, credentials,
    and permissions for your device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 手动更改数百台设备的密码绝对是枯燥乏味且容易出错的。因此，现代物联网基础设施需要对资产和配置（包括用户、角色和权限）进行集中管理，以确保能够保持可管理性。对于设备制造商来说，准备设备以支持轻量级目录访问协议（LDAP）集成或类似的技术可能是合理的，以简化集中管理。然而，确保在信任远程服务器来处理设备的用户、凭证和权限时，要考虑潜在的威胁。
- en: As mentioned before, applications should be restricted to the minimum permissions
    necessary to function correctly. However, with every firmware update, the features
    and behavior of a device’s software components might change. New functionality
    might require further permissions, and strict security could be a showstopper.
    Also, security updates might remove software routines that required specific permissions,
    and those permissions wouldn’t be needed anymore afterward. In general, if you
    work with tools that restrict software applications and you update that software,
    you always have to double-check that the related permissions match the new version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序应被限制为仅具有正确运行所需的最小权限。然而，随着每次固件更新，设备软件组件的功能和行为可能会发生变化。新的功能可能需要更多的权限，而严格的安全性可能会成为阻碍。同时，安全更新可能会删除那些曾经需要特定权限的软件程序，这些权限之后就不再需要了。一般来说，如果您使用的是限制软件应用程序的工具并且更新了该软件，您总是需要再次检查相关权限是否与新版本匹配。
- en: Last but not least, you have to consider that your device might be resold and
    used by another customer. That customer should still be able to initialize the
    device and to reset users and permissions, but shouldn’t have access to data created
    by the previous owner. The same applies for final decommissioning when curious
    dumpster divers or scrap dealers might want to get hold of access-restricted data.
    The original customer should be provided with a “clear all private data” button
    that actually does what it says, and newly added users shouldn’t be able to access
    others’ data even if it isn’t cleared.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，您必须考虑到您的设备可能会被转售并被另一位客户使用。那位客户应该仍然能够初始化设备并重置用户和权限，但不应访问前一位所有者创建的数据。同样的情况也适用于最终停用，当好奇的垃圾桶潜伏者或废品商贩可能想要获取访问受限的数据时。应该为原始客户提供一个“清除所有私人数据”按钮，确保该按钮真正执行它所说的功能，并且新添加的用户即使没有清除数据，也不能访问其他人的数据。
- en: '**Discretionary Access Control**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自主访问控制**'
- en: '*Discretionary access control (DAC)* is a fundamental approach to managing
    access rights of subjects and groups to objects within a system. The subjects
    in our case are users in a Linux OS, while objects might be files, directories,
    memory locations, interprocess communication, and all sorts of system devices
    and interfaces. This methodology is *discretionary* because permissions for a
    certain object are granted *at the discretion* of a user owning this specific
    object; *owners* can pass on permissions to other users and groups.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*自主访问控制（DAC）* 是一种管理系统内对象的主题和组的访问权限的基本方法。在我们的例子中，主题是 Linux 操作系统中的用户，而对象可能是文件、目录、内存位置、进程间通信以及各种系统设备和接口。此方法是
    *自主的*，因为某个对象的权限是由拥有该特定对象的用户 *自行决定* 的；*所有者* 可以将权限传递给其他用户和组。'
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In Linux systems, the root user is omnipotent. It’s able to override permissions
    set by owners. Therefore, “becoming root” is one of the most attractive goals
    for attackers. For developers, this means processes that could potentially be
    compromised, such as all applications listening on network ports, should never
    run as root!*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Linux 系统中，root 用户是无所不能的。它能够覆盖所有者设置的权限。因此，“成为 root”是攻击者最具吸引力的目标之一。对于开发者而言，这意味着可能被破坏的进程（例如所有监听网络端口的应用程序）不应该以
    root 身份运行！*'
- en: '***Linux Filesystem Permissions***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 文件系统权限***'
- en: Every single file in a Linux filesystem has a permission string associated with
    it. As shown in [Listing 11-1](ch11.xhtml#ch11list01), the `ls` tool can print
    the string always at the beginning of each line.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Linux 文件系统中的文件都有一个与之关联的权限字符串。如 [Listing 11-1](ch11.xhtml#ch11list01) 所示，`ls`
    工具可以在每一行的开头始终打印出这个字符串。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: A file permission listing on Linux*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-1: Linux 上的文件权限列表*'
- en: The prominent strings `root root` show that all files are owned by the root
    user from the root group, except for the *my_notes.md* file, which is owned by
    *bob* of the *guest* group. Further, the very first character of each line specifies
    whether it’s a regular file (`-`), a directory (`d`), or a symbolic link (`l`).
    Block devices (`b`) and character devices (`c`) would also be indicated there.
    The following nine characters represent the permissions granted for each file.
    They’re separated in three groups of three characters each, concerning read (`r`),
    write (`w`), and execute (`x`) permissions of the owner, a corresponding group,
    and anybody else, respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显眼的字符串 `root root` 表明所有文件都归 root 用户和 root 组所有，除了 *my_notes.md* 文件，它归 *guest*
    组中的 *bob* 所有。此外，每行的第一个字符指定文件类型，是普通文件（`-`）、目录（`d`）还是符号链接（`l`）。块设备（`b`）和字符设备（`c`）也会在那里显示。接下来的九个字符代表每个文件的权限，它们被分为三组，每组三个字符，分别表示所有者、相应组和其他人对读取（`r`）、写入（`w`）和执行（`x`）的权限。
- en: For example, the *README* file in [Listing 11-1](ch11.xhtml#ch11list01) can
    be read and written by the root user, but other users in the root group may only
    read. Read permission is also granted to any other user, no matter in which group,
    as indicated by the trailing `r--`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单 11-1](ch11.xhtml#ch11list01) 中的 *README* 文件可以被 root 用户读取和写入，但其他 root
    组中的用户只能读取。读权限也被授予任何其他用户，无论其所在组如何，这由后缀的 `r--` 所示。
- en: 'Whenever you read tutorials or third-party source code for Linux access-control
    management, you’ll likely stumble over an efficient, three-digit notation of access
    permissions. The 9-bit permission strings can be written efficiently as three
    octal numbers: one for owner permissions, one for group member permissions, and
    the last one stands for all others.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你阅读关于 Linux 访问控制管理的教程或第三方源代码时，你可能会遇到一种高效的三位数字访问权限表示法。9位的权限字符串可以高效地写成三个八进制数字：一个表示所有者权限，一个表示组成员权限，最后一个表示其他所有人的权限。
- en: For example, `777` means that everybody may read, write, and execute a given
    object. In contrast, `740` says that the owner may read, write, and execute; group
    members are allowed only to read; and anybody else has no access rights at all.
    [Table 11-1](ch11.xhtml#ch11tab01) details the conversion of permissions to octal
    numbers, and vice versa.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`777` 表示每个人都可以读取、写入和执行给定对象。相对的，`740` 表示所有者可以读取、写入和执行；组成员仅被允许读取；而其他任何人都没有访问权限。[表
    11-1](ch11.xhtml#ch11tab01) 详细说明了权限到八进制数字的转换及其反向转换。
- en: '**Table 11-1:** Octal Representation of Linux File Permissions'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-1：** Linux 文件权限的八进制表示'
- en: '| **Octal** | **Binary** | **Permissions** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **八进制** | **二进制** | **权限** |'
- en: '| --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 000 | `---` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 000 | `---` |'
- en: '| 1 | 001 | `--x` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 001 | `--x` |'
- en: '| 2 | 010 | `-w-` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 010 | `-w-` |'
- en: '| 3 | 011 | `-wx` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 011 | `-wx` |'
- en: '| 4 | 100 | `r--` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 100 | `r--` |'
- en: '| 5 | 101 | `r-x` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 101 | `r-x` |'
- en: '| 6 | 110 | `rw-` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 110 | `rw-` |'
- en: '| 7 | 111 | `rwx` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 111 | `rwx` |'
- en: Understanding file permissions is straightforward, but directories behave a
    little bit differently. There, read permission enables the enumeration of items
    within a directory. Write permission grants the right to add, delete, or rename
    directory items. Execute permission allows users to navigate to the directory,
    such as with the `cd` command, and access files or subdirectories.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理解文件权限是直观的，但目录的行为略有不同。在目录中，读权限使得可以列举目录内的项目。写权限授予添加、删除或重命名目录项的权限。执行权限允许用户进入目录，例如使用
    `cd` 命令，访问文件或子目录。
- en: '***Linux User and Group Management***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 用户和组管理***'
- en: 'In Linux, several tools exist for managing users and groups. The most basic
    commands, available in all distributions, even on embedded systems, are the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，有几个工具用于管理用户和组。最基本的命令是所有发行版都可用的，甚至在嵌入式系统上也可以使用，具体如下：
- en: '| useradd | Create a new user |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| useradd | 创建一个新用户 |'
- en: '| usermod | Modify properties of an existing user |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| usermod | 修改现有用户的属性 |'
- en: '| userdel | Delete a user |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| userdel | 删除一个用户 |'
- en: '| groupadd | Create a new group |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| groupadd | 创建一个新组 |'
- en: '| groupmod | Modify properties of an existing group |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| groupmod | 修改现有组的属性 |'
- en: '| groupdel | Delete a group |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| groupdel | 删除一个组 |'
- en: When engineering secure devices, the most important commands are `useradd` and
    `groupadd`, because they can be used at image-creation time to implement users
    and roles defined in an associated access-control concept.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行安全设备工程时，最重要的命令是 `useradd` 和 `groupadd`，因为它们可以在创建镜像时用于实现与访问控制概念相关的用户和角色。
- en: For user creation, of course, the new user’s name has to be provided. Further
    options you might want to specify are its *user identifier*—or *UID* (`--uid`)—its
    home directory (`--home`), and whether this directory should be created automatically
    (`--create-home`). In addition, you can define whether a user group with the same
    name should be created (`--user-group`) and which groups the user should belong
    to (`--groups`). The `--shell` option allows for specifying the shell used after
    login, but it can also be used with `false` and `nologin` to disable user login.
    Finally, you can set the user’s password (in hashed form) with the `--password`
    option.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户创建，当然需要提供新用户的名字。你可能还需要指定的其他选项包括其*用户标识符*（或*UID*）（`--uid`）、其主目录（`--home`）以及是否应该自动创建该目录（`--create-home`）。此外，你可以定义是否应该创建一个与用户名相同的用户组（`--user-group`）以及用户应该属于哪些组（`--groups`）。`--shell`选项允许指定登录后的shell，但它也可以与`false`和`nologin`一起使用，以禁用用户登录。最后，你可以通过`--password`选项设置用户的密码（以哈希形式）。
- en: The main parameters to specify for creating a group with `groupadd` are the
    group’s name and, if desired, a corresponding *group identifier (GID)* (`--gid`)
    that you can use to refer to the specific group at a later time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组时，`groupadd`命令需要指定的主要参数是组名，如果需要，还可以指定一个相应的*组标识符（GID）*（`--gid`），以便稍后引用该特定组。
- en: Users as well as groups might be flagged as belonging to the system (`--system`),
    in contrast to being external, probably human users. Such system accounts receive
    a UID/GID from a reserved system range. In addition, system users don’t expire
    and don’t get a home directory created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和组可能被标记为属于系统（`--system`），与外部的、可能是人类用户相对。此类系统账户从保留的系统范围获得UID/GID。此外，系统用户不会过期，也不会创建主目录。
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The tools* useradd *and* adduser *as well as* groupadd *and* addgroup *get
    mixed up easily. The ones presented in this section are the basic, portable versions,
    while the others might be more user-friendly in an interactive session.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些工具* useradd *和* adduser *以及* groupadd *和* addgroup *容易混淆。本节中介绍的工具是基本的、可移植的版本，而其他工具可能在交互式会话中更易于使用。*'
- en: '***Linux Permission Management***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux权限管理***'
- en: 'To configure owners, groups, and permissions of files and directories, we need
    three common tools on Linux systems:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，配置文件和目录的所有者、组和权限需要使用三种常见工具：
- en: chown    Allows you to change the owner of a file or directory to another owner.
    For example, the owner of the *web.conf* file can be set to *bob* with `chown
    bob web.conf`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: chown    允许你将文件或目录的所有者更改为另一个所有者。例如，可以使用`chown bob web.conf`将*web.conf*文件的所有者设置为*bob*。
- en: chgrp    Specifies a new group for a given file or directory. The group of the
    *manuals* directory might be changed to *guest* with `chgrp guest manuals`, for
    example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: chgrp    指定给定文件或目录的新组。例如，*manuals*目录的组可能会通过`chgrp guest manuals`命令更改为*guest*。
- en: chmod    Manipulates permissions for files and directories. The call `chmod
    +x script.sh` adds execution permission to the *script.sh* file, while `chmod
    -wx script.sh` removes permissions for writing and execution. Both affect only
    the owner’s permissions. By prepending `g` for group, `o` for others, `u` for
    users/owners, and `a` for all, you can also specify which part of the permission
    string should be affected. For example, `chmod go-rwx private.key` removes all
    access rights of the *private.key* file for all group members and anybody else
    except the owner.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: chmod    操作文件和目录的权限。调用`chmod +x script.sh`为*script.sh*文件添加执行权限，而`chmod -wx script.sh`则移除写入和执行权限。两者只会影响所有者的权限。通过在权限字符串前加上`g`（组）、`o`（其他人）、`u`（用户/所有者）和`a`（所有人），你还可以指定应该影响权限字符串的哪一部分。例如，`chmod
    go-rwx private.key`会移除所有组成员以及除了所有者之外的任何其他人的*private.key*文件的所有访问权限。
- en: '***Access-Control Lists***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问控制列表***'
- en: In principle, users and groups enable us to represent any desired access-control
    settings. However, in some cases, the limitation that a file or directory can
    have only a single owner and a single associated group makes efficient access-control
    management difficult.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，用户和组使我们能够表示任何所需的访问控制设置。然而，在某些情况下，文件或目录只能有一个所有者和一个关联组的限制使得高效的访问控制管理变得困难。
- en: Let me provide an example because the usefulness might not be obvious. Imagine
    you have a directory called *internal_logs* for storing logs and runtime data.
    Files in this directory are created by five users, all belonging to the *service*
    group. Two years after market release, you introduce a new predictive maintenance
    feature and an associated `predmain` user who needs read access only to the *internal_logs/freqtrack.dat*
    file, and the user shouldn’t be able to write anything—to contain damage in case
    of compromise. You can’t add *predmain* to the *service* group because then it
    would have too many permissions, and you can’t make *predmain* the owner of *freqtrack.dat*
    because, again, compromise would leave an attacker with too much control.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我举个例子，因为它的用处可能不太明显。假设你有一个名为 *internal_logs* 的目录，用来存储日志和运行时数据。这个目录中的文件由五个用户创建，所有用户都属于
    *service* 组。两年后，你发布了一项新的预测性维护功能，并引入了一个名为 `predmain` 的新用户，该用户只需要对 *internal_logs/freqtrack.dat*
    文件具有读取权限，并且该用户不应有写入权限——以防止在遭到入侵时造成损害。你不能将 *predmain* 添加到 *service* 组中，因为那样它将拥有过多权限，你也不能将
    *predmain* 设置为 *freqtrack.dat* 的所有者，因为如果遭到入侵，攻击者将会拥有过多控制权限。
- en: One solution is to use access-control lists (ACLs) that are implemented based
    on the extended file attributes (xattr) of a Linux filesystem. Depending on your
    system, ACL support has to be installed, and the filesystem has to be mounted
    with the `acl` option before you can use the `getfacl` and `setfacl` command line
    tools to view and change permissions on a fine-grained level, respectively.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用基于 Linux 文件系统扩展文件属性（xattr）实现的访问控制列表（ACLs）。根据你的系统，必须先安装 ACL 支持，并且在挂载文件系统时需要使用
    `acl` 选项，才能使用 `getfacl` 和 `setfacl` 命令行工具，分别查看和更改细粒度的权限。
- en: '**Case Study: Access Control for STM32MP157F-DK2 Firmware**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：STM32MP157F-DK2 固件的访问控制**'
- en: In this case study, I first demonstrate a user- and file-initialization process
    with Yocto. Next, I explore the default permissions set by Linux for certain system
    files and the reasoning behind them. Finally, as an example of application-level
    access control, I take a look at the configuration of the SSH daemon Dropbear.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我首先展示了在 Yocto 中的用户和文件初始化过程。接下来，我探讨了 Linux 对某些系统文件设置的默认权限以及背后的理由。最后，作为应用层访问控制的一个例子，我查看了
    SSH 守护进程 Dropbear 的配置。
- en: '***User Creation and File Provisioning in Yocto***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Yocto 中的用户创建和文件配置***'
- en: The first question regarding access control you have to clarify on any Linux
    platform is the way you want to handle the root user. Especially during development,
    the root user might be used regularly and often, even without a password. Make
    sure to remove debug settings for production images. In my case, I removed the
    `debug-tweaks` feature from ST’s `st-image-core` image, as shown in [Listing 11-2](ch11.xhtml#ch11list02).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问控制的第一个问题是，在任何 Linux 平台上，你必须明确如何处理 root 用户。尤其在开发过程中，root 用户可能经常被使用，甚至没有密码。确保在生产镜像中删除调试设置。在我的案例中，我从
    ST 的 `st-image-core` 镜像中移除了 `debug-tweaks` 特性，如 [列表 11-2](ch11.xhtml#ch11list02)
    所示。
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Preparing the root user for production*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-2：为生产准备 root 用户*'
- en: I inherited the `extrausers` class, which allows the modification of the existing
    root user (for example, to protect it with a strong password). The cryptic-looking
    string behind `ROOT_PASSWORD_HASH` is the user password hash format expected by
    Linux. It was obtained by calling `openssl passwd -6` password, where the `-6`
    parameter indicates that a salted hash based on SHA-512 is used. Also note that
    the `$` symbols act as separators in this format and that they need to be escaped
    within Yocto recipes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我继承了 `extrausers` 类，它允许修改现有的 root 用户（例如，用强密码保护它）。`ROOT_PASSWORD_HASH` 后面的看似神秘的字符串是
    Linux 预期的用户密码哈希格式。它是通过调用 `openssl passwd -6` 命令获得的，其中 `-6` 参数表示使用基于 SHA-512 的加盐哈希。另外需要注意的是，`$`
    符号在这种格式中作为分隔符，并且在 Yocto 配方中需要转义。
- en: '**NOTE**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In many cases, completely disabling root login makes sense, unless you have
    convincing reasons not to, in order to rule out misuse of this powerful user.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*在许多情况下，完全禁用 root 登录是有意义的，除非你有令人信服的理由不这样做，以防止滥用这个强大的用户权限。*'
- en: Yocto additionally provides the `useradd` class to further provision users and
    groups from within a custom recipe. [Listing 11-3](ch11.xhtml#ch11list03) shows
    the creation of two system users, *rservice* and *lservice*, as well as the end
    users *admin* and *guest*. Also, two corresponding groups are created, and the
    users are added to these groups.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 还提供了 `useradd` 类，以便在自定义配方中进一步配置用户和组。[列表 11-3](ch11.xhtml#ch11list03) 显示了创建两个系统用户
    *rservice* 和 *lservice*，以及最终用户 *admin* 和 *guest*，同时还创建了两个相应的组，并将用户添加到这些组中。
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-3: Creating users and groups for the image*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-3：为镜像创建用户和组*'
- en: All users are initialized with a password in the `USERADD_PARAM` variable. Specific
    UIDs are used only for end-user accounts. The `GROUPADD_PARAM` variable allows
    you to create new groups, while `GROUPMEMS_PARAM` enrolls the created users in
    those groups.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户都使用 `USERADD_PARAM` 变量初始化密码。特定的 UID 仅用于最终用户账户。`GROUPADD_PARAM` 变量用于创建新组，而
    `GROUPMEMS_PARAM` 则将创建的用户添加到这些组中。
- en: In some cases, you also might want to create directories for users and place
    initial files in them. In [Listing 11-4](ch11.xhtml#ch11list04), a snippet from
    a custom recipe is shown that may serve as a simple example of file provisioning
    for created users, including necessary commands to set owners and groups accordingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能还希望为用户创建目录并将初始文件放入其中。在[列表 11-4](ch11.xhtml#ch11list04)中，展示了一个来自自定义配方的代码片段，作为创建用户时文件配置的简单示例，包括设置所有者和组的必要命令。
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-4: The basic file provisioning for created users*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-4：为创建的用户提供基本文件配置*'
- en: First, home directories for all users are created with corresponding permissions.
    For example, end users should be able to read only provided data, but not to store
    their own code to the device or even execute it. Further, administration information
    should not be accessible for the `guest` user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为所有用户创建主目录并设置相应的权限。例如，最终用户应该只能读取提供的数据，而不能在设备上存储自己的代码或执行它。此外，管理员信息不应对 `guest`
    用户可见。
- en: Service users, on the other hand, have higher permissions. They may load custom
    data to their directories, while the `lservice` local service user has the highest
    rights because it might even read and write to the remote service user’s directory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用户则拥有更高的权限。它们可以将自定义数据加载到自己的目录中，而 `lservice` 本地服务用户拥有最高权限，因为它甚至可以读取和写入远程服务用户的目录。
- en: With these basic steps, you can lay the foundation for your device’s access-control
    management.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些基本步骤，你可以为设备的访问控制管理打下基础。
- en: '***Exploration of System Files and Predefined Users***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***系统文件和预定义用户的探索***'
- en: Luckily, Linux and its distributions already take care of permission settings
    for a variety of system files. Let’s look at some specific examples within the
    firmware of my STM32MP157F device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Linux 及其发行版已经为各种系统文件的权限设置做好了配置。我们来看看我的 STM32MP157F 设备固件中的一些具体示例。
- en: The user and password management on Linux is implemented by the */etc/passwd*
    and */etc/shadow* files. As shown in [Listing 11-5](ch11.xhtml#ch11list05), the
    first file is marked readable for everybody because there might be various good
    reasons to read the list of users on a system. However, the actual password hash
    of each user is not included in the *passwd* file. It resides in the *shadow*
    file, which is readable only by root for login verification purposes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 上的用户和密码管理由 */etc/passwd* 和 */etc/shadow* 文件实现。如[列表 11-5](ch11.xhtml#ch11list05)所示，第一个文件被标记为对所有人可读，因为可能有各种合理的理由需要读取系统上的用户列表。然而，每个用户的实际密码哈希并不包含在
    *passwd* 文件中。它存储在 *shadow* 文件中，该文件仅根用户可读，用于登录验证目的。
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-5: The access rights to password files on Linux*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-5：Linux 上密码文件的访问权限*'
- en: '*Shadowing* password storage has been done for decades. The main idea is to
    restrict the access of unprivileged users to password hashes, because if a user
    uses a weak password, an adversary with access to the corresponding password hash
    would be able to launch a brute-force attack against it.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*影像*密码存储已经存在数十年。其主要思想是限制非特权用户对密码哈希的访问，因为如果用户使用了弱密码，攻击者如果能够访问相应的密码哈希，就能对其进行暴力破解攻击。'
- en: '**NOTE**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you wonder how passwords could be changed if* /etc/shadow *is only readable,
    even for root: the superuser root has similar powers to Chuck Norris; it can even
    write to read-only files.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想知道如果* /etc/shadow *只有根用户可读，甚至连 root 都不能修改密码，答案是：超级用户 root 具有类似 Chuck Norris
    的能力；它甚至可以写入只读文件。*'
- en: '[Listing 11-6](ch11.xhtml#ch11list06) shows the permission strings for my device’s
    microSD card (*/dev/mmcblk0*), the Linux RNG device (*/dev/urandom*), and the
    hardware RNG device of the STM32MP157F (*/dev/hwrng*).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-6](ch11.xhtml#ch11list06) 展示了我设备的 microSD 卡（*/dev/mmcblk0*）、Linux RNG
    设备（*/dev/urandom*）和 STM32MP157F 的硬件 RNG 设备（*/dev/hwrng*）的权限字符串。'
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-6: The permissions for a microSD card and RNG devices*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：microSD 卡和 RNG 设备的权限*'
- en: You can see that, for device files, the permission string indicates whether
    it’s a block device (`b`) or a character device (`c`). The results also show that
    the microSD card can be read only by root or members of the *disk* group. For
    RNGs, the system differentiates between the OS-provided RNG `urandom`, which can
    be read and written be everyone, and the hardware RNG device `hwrng`, which only
    root may access.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，对于设备文件，权限字符串指示它是块设备（`b`）还是字符设备（`c`）。结果还显示，microSD 卡只能被 root 或 *disk* 组的成员读取。对于
    RNG，系统区分了操作系统提供的 RNG `urandom`，它可以被所有人读取和写入，以及硬件 RNG 设备 `hwrng`，只有 root 可以访问。
- en: Let’s shift the focus from files to processes. [Listing 11-7](ch11.xhtml#ch11list07)
    shows typical applications like the web server `httpd` or the MQTT broker `mosquitto`
    and the corresponding users executing these processes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将注意力从文件转向进程。[列表 11-7](ch11.xhtml#ch11list07) 展示了典型的应用程序，如 Web 服务器 `httpd`
    或 MQTT 经纪人 `mosquitto`，以及执行这些进程的相应用户。
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-7: The user context of typical network daemons*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-7：典型网络守护进程的用户上下文*'
- en: The web server `httpd` exhibits a common strategy to limit the attack surface
    in case a vulnerability could be exploited remotely. It starts under the root
    user, binds to its designated port (for example, 80), and then deliberately drops
    its high privileges by altering its GID and UID by calls to `setgid()` and `setuid()`,
    respectively. Therefore, in my case, the four “worker threads” of `httpd` run
    under the low-privilege user *daemon*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器 `httpd` 展示了一种常见的策略，以限制在漏洞可能被远程利用时的攻击面。它以 root 用户启动，绑定到指定端口（例如，80），然后通过调用
    `setgid()` 和 `setuid()` 分别改变其 GID 和 UID，从而故意降低其高权限。因此，在我的例子中，`httpd` 的四个“工作线程”在低权限用户
    *daemon* 下运行。
- en: The same is true for the Mosquitto broker. You can infer from its documentation
    that, even if started as the root user, Mosquitto immediately drops privileges
    after reading its configuration file and continues running in the context of a
    more limited user, called `mosquitto` in my case.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mosquitto 经纪人也是如此。你可以从其文档中推断出，即使以 root 用户身份启动，Mosquitto 在读取其配置文件后立即降低权限，并继续以更有限的用户（在我的例子中是
    `mosquitto`）的上下文运行。
- en: The output of usernames by `ps` is limited to eight characters. Therefore, `mosquitto`
    becomes `mosquitt`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 输出的用户名限制为八个字符。因此，`mosquitto` 显示为 `mosquitt`。'
- en: '***SSH Daemon Access-Control Configuration***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SSH 守护进程访问控制配置***'
- en: '*Dropbear* is a lightweight SSH daemon that’s especially popular on embedded
    systems. It enables secure remote access to a device, which makes it perfectly
    useful but also absolutely critical. Applications like that deserve dedicated
    consideration regarding access-control settings, because if they implement an
    “open door policy,” it’s literally an invitation for attackers.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dropbear* 是一个轻量级的 SSH 守护进程，尤其在嵌入式系统中非常流行。它使设备能够进行安全的远程访问，这使它非常有用但也至关重要。像这样的应用程序在访问控制设置方面需要特别的关注，因为如果它们实施了“开放门政策”，那简直是在邀请攻击者。'
- en: '[Listing 11-8](ch11.xhtml#ch11list08) shows a part of the command line arguments
    for the `dropbear` daemon that are interesting from an access-control point of
    view.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-8](ch11.xhtml#ch11list08) 展示了从访问控制角度来看，`dropbear` 守护进程的一部分命令行参数。'
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-8: Some access-control options for* dropbear'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-8：一些 dropbear 的访问控制选项*'
- en: Disabling root access over SSH (`-w`) is a good idea in most instances. For
    this case study, it might also be reasonable to restrict SSH access to users from
    the *service* group (`-G`), because it shouldn’t be a feature for end users. Disabling
    password logins completely and allowing only public-key authentication would be
    perfect, but if your PKI is not yet prepared for this step, the `-s` option isn’t
    possible. Since we completely disabled root access, using `-g` would be redundant.
    The `-B` argument should be used only during development; you probably don’t want
    to find this in a production firmware image. Lastly, you can restrict the maximum
    number of login tries—for example, to three (`-T 3`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用通过SSH的root访问（`-w`）在大多数情况下是个好主意。对于本案例研究，也可能合理限制SSH访问仅限于*service*组的用户（`-G`），因为这不应该是最终用户的功能。完全禁用密码登录并只允许公钥认证是完美的，但如果你的PKI还没有为此步骤做准备，那么`-s`选项就无法使用。由于我们已经完全禁用了root访问，使用`-g`就显得多余。`-B`参数只应在开发过程中使用；你可能不希望在生产固件镜像中看到这个。最后，你可以限制最大登录尝试次数——例如，限制为三次（`-T
    3`）。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also change the port of the* dropbear *SSH daemon from 22 to a custom
    one with the* -p *option. That’s just obscurity, but it might save your internet-connected
    device from being discovered by automated SSH scans.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还可以通过-p选项将dropbear SSH守护进程的端口从22更改为自定义端口。这只是为了增加隐蔽性，但它可能会帮助你的联网设备免于被自动SSH扫描发现。*'
- en: To store your `dropbear` settings persistently, you have to change the */etc/dropbear/default*
    file in your firmware image. The important line that it should contain to implement
    the discussed access-control restrictions is `DROPBEAR_EXTRA_ARGS="-w -T 3 -G
    service"`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要持久存储你的`dropbear`设置，你必须更改固件镜像中的*/etc/dropbear/default*文件。要实现上述访问控制限制，重要的一行内容是`DROPBEAR_EXTRA_ARGS="-w
    -T 3 -G service"`。
- en: '**Mandatory Access Control**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**强制访问控制**'
- en: While DAC concepts are usually known among embedded system developers, *mandatory
    access control (MAC)* is often uncharted territory. However, MAC implementations
    can contribute significantly to a device’s security and to the containment of
    damage in case of compromise.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管DAC概念在嵌入式系统开发人员中通常是已知的，*强制访问控制（MAC）*往往是未知的领域。然而，MAC实现可以显著提升设备的安全性，并在设备遭到破坏时限制损害。
- en: The basic idea of MAC systems for embedded devices is that permissions and policies
    regarding the way users and processes may interact with files and other resources
    are managed by the manufacturer and enforced by the OS. In contrast to the user-centric
    approach of DAC, users can’t override the rules defined by MAC.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备的MAC系统的基本思想是，关于用户和进程如何与文件和其他资源进行交互的权限和策略由制造商管理，并由操作系统强制执行。与DAC以用户为中心的方式不同，用户无法覆盖MAC定义的规则。
- en: MAC implementations are powerful tools, but with power comes responsibility.
    *Whitelisting* is a popular access-control strategy in which access is denied
    by default and granted only if explicitly allowed. This approach can also be used
    for MAC systems to permit only defined access of subjects to objects. However,
    if you omit specifying a legitimate access as “allowed,” maybe because it’s used
    infrequently, an application that requires it might crash during runtime whenever
    the access occurs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: MAC实现是强大的工具，但权力伴随着责任。*白名单*是一种流行的访问控制策略，默认情况下拒绝访问，只有显式允许时才授予访问权限。此方法也可以用于MAC系统，允许定义的主体对对象的访问。然而，如果你省略了指定某个合法访问为“允许”，也许是因为它很少被使用，那么在访问发生时，要求此访问的应用程序可能会在运行时崩溃。
- en: If you choose a *blacklisting* approach—defining only dangerous cases for which
    access should be denied, like malware detected by virus scanners—the probability
    of breaking functionality is reduced. However, you have to ensure that corresponding
    rules for newly discovered malicious behavior find their way into your devices
    in a timely manner.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择*黑名单*方法——只定义需要拒绝访问的危险情况，比如病毒扫描器检测到的恶意软件——则破坏功能的概率会降低。然而，你必须确保及时将新发现的恶意行为的相应规则添加到设备中。
- en: '***Linux Security Modules***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux安全模块***'
- en: Since the Linux community was not able to agree on one specific security module,
    Linux introduced the *Linux Security Module (LSM)* framework. It enables the implementation
    of various MAC systems for Linux.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux社区未能就一个特定的安全模块达成一致，Linux引入了*Linux安全模块（LSM）*框架。它使得在Linux上实现多种MAC系统成为可能。
- en: These LSMs are compiled into the Linux kernel and take action if specific hook
    functions are called within the kernel code. These hooks are integrated in all
    procedures relevant for access control within the OS, from file access to task
    spawning to interprocess communication. If reached, the kernel hands over control
    to the LSM, which is able to at least log the performed action or directly decide
    whether access should be granted or denied based on its specific rule set.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些LSM被编译到Linux内核中，并在内核代码中调用特定的钩子函数时采取相应的行动。这些钩子集成在操作系统中所有与访问控制相关的过程之中，从文件访问到任务生成，再到进程间通信。如果到达钩子，内核将控制权交给LSM，LSM至少可以记录执行的操作，或者根据其特定规则集直接决定是否允许访问。
- en: 'LSM implementations differ significantly in terms of their concepts, their
    way of configuring rule sets, and their supporting community. However, they also
    share a common property: all have a negative impact on system performance. The
    following sections introduce popular LSM implementations.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的LSM实现方式在概念、配置规则集的方式以及支持社区方面有显著差异。然而，它们也有一个共同点：都对系统性能产生负面影响。接下来的章节将介绍一些流行的LSM实现。
- en: '***SELinux***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SELinux***'
- en: 'In 2000, the NSA published its idea of a MAC system for Linux to the open source
    community: *Security-Enhanced Linux (SELinux)*. Supported by other stakeholders
    in this field, the project flourished and was finally integrated into version
    2.6 of the mainline Linux kernel in 2003\. Since version 4.3, it’s the default
    LSM in Android, and many Linux distributions for desktop and server applications
    support it.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年，NSA将其针对Linux的MAC系统理念发布给开源社区：*安全增强Linux（SELinux）*。在该领域其他利益相关者的支持下，该项目蓬勃发展，并最终在2003年集成到主线Linux内核的2.6版本中。从版本4.3开始，它成为Android的默认LSM，许多桌面和服务器应用的Linux发行版也都支持它。
- en: SELinux relies on security policies that define which objects might be accessed
    by which subjects. For this purpose, objects and subjects must be registered in
    SELinux with corresponding *labels* containing a user, a role, and an associated
    type. These labels define a kind of context or domain for subjects and objects.
    The actual access control is implemented by *type enforcement*, which defines
    whether a subject with a specific type can access an object with a specific type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux依赖于定义哪些对象可以被哪些主体访问的安全策略。为此，必须在SELinux中注册对象和主体，并为其分配相应的*标签*，标签中包含用户、角色和关联类型。这些标签定义了主体和对象的某种上下文或领域。实际的访问控制是通过*类型强制*实现的，类型强制定义了具有特定类型的主体是否可以访问具有特定类型的对象。
- en: Many Linux distributions provide their own set of predefined SELinux policies
    to restrict a variety of common applications and services. Further, there is a
    database of reference policies that you can use for your purposes. However, creating
    custom policies for your applications requires deep know-how about their functionalities
    and a detailed understanding of the SELinux concepts and structures. You should
    not underestimate the necessary characterization efforts, even if tools are available
    to support you.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Linux发行版提供了自己预定义的SELinux策略集，以限制各种常见的应用和服务。此外，还有一个参考策略数据库，您可以根据需求使用。然而，为您的应用创建自定义策略需要深入了解其功能，并对SELinux的概念和结构有详细的理解。即便有工具可以支持您，也不应低估所需的特征化工作量。
- en: At runtime, SELinux can be operated in three ways. The *enforcing* mode is meant
    for productive use, because it strictly applies all given policies and logs corresponding
    activities. However, during development or in a test phase, the *permissive* mode
    is more suitable. It processes all policies, but only generates warnings and log
    data without enforcing the defined rules. This can be enormously helpful for fine-tuning
    custom policies and troubleshooting. If *disabled*, SELinux is turned off completely
    and doesn’t protect or restrict anything.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，SELinux可以以三种方式操作。*强制*模式适用于生产环境，因为它严格应用所有给定的策略并记录相应活动。然而，在开发或测试阶段，*宽容*模式更为适用。它处理所有策略，但仅生成警告和日志数据，而不强制执行定义的规则。这对于微调自定义策略和故障排除非常有帮助。如果*禁用*，SELinux将完全关闭，不会保护或限制任何内容。
- en: Although (or perhaps precisely because) SELinux provides a vast number of capabilities,
    it’s a pretty complex tool that many embedded system engineers refrain from using.
    This is probably the main reason other LSM implementations emerged and became
    popular alternatives, as described in the following sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管（或者也许正因为）SELinux提供了大量的能力，它仍然是一个相当复杂的工具，许多嵌入式系统工程师因此不愿使用它。这可能是其他LSM实现出现并成为流行替代方案的主要原因，如接下来的部分所述。
- en: '***AppArmor***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AppArmor***'
- en: '*AppArmor* is the second LSM implementation to gain significant popularity
    among Linux distributions. It became part of the Linux kernel 2.6.36 in 2010 and
    is currently the default MAC system for Ubuntu and SUSE Linux. Its development
    has been funded by Canonical since 2009.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppArmor*是第二个在Linux发行版中获得显著普及的LSM实现。它于2010年成为Linux内核2.6.36的一部分，目前是Ubuntu和SUSE
    Linux的默认MAC系统。自2009年以来，它的开发得到了Canonical的资助。'
- en: Access control is managed on the basis of individual profiles per application.
    In contrast to SELinux, AppArmor uses filesystem paths to identify subjects and
    file objects, so the syntax offers better readability. Further, it allows a hybrid
    approach of whitelisting and blacklisting rules that control the resource access
    of a process. The created profiles can restrict network access and various sorts
    of Linux capabilities, but also permissions to read, write, and execute files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制是基于每个应用程序的个人配置文件进行管理的。与SELinux不同，AppArmor使用文件系统路径来识别主体和文件对象，因此其语法具有更好的可读性。此外，它还支持混合的白名单和黑名单规则方法，控制进程的资源访问。创建的配置文件可以限制网络访问和各种Linux能力，还可以限制读取、写入和执行文件的权限。
- en: AppArmor comes with a list of predefined profiles, and additional profiles for
    common applications are maintained by the Ubuntu community. Additionally, AppArmor
    provides several tools that support developers in profiling custom applications
    and generating corresponding profiles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor提供了一些预定义的配置文件，Ubuntu社区还维护了常见应用程序的额外配置文件。此外，AppArmor还提供了多个工具，帮助开发者为自定义应用程序配置文件并生成相应的配置文件。
- en: Generally speaking, there are two ways of characterizing access requirements.
    First, targeted profiling allows you to capture access events of a single application
    and to automatically generate a profile from it. Second, AppArmor can apply a
    systemic monitoring approach that logs access operations of a defined set of applications
    for days or even weeks and spanning multiple reboots. The collected log information
    can then be turned into a series of profiles restricting the analyzed applications
    in a preferably optimal way.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有两种方式来描述访问需求。首先，目标化的配置文件方法允许你捕获单个应用程序的访问事件，并从中自动生成配置文件。其次，AppArmor可以应用系统监控方法，记录一组定义应用程序的访问操作，持续数天甚至数周，并跨多个重启。收集的日志信息可以转化为一系列配置文件，以尽可能优化的方式限制分析过的应用程序。
- en: 'Each AppArmor profile available on a device can be put into one of three modes
    at runtime: enforce, complain, or audit. In *enforcement mode*, the rules set
    by the profile are enforced, and violation attempts are logged. The *complain
    mode* allows for monitoring an application’s behavior under a defined profile,
    and operations that violate the policy are logged. This mode is also used in the
    automated profile creation mentioned previously and is therefore sometimes called
    AppArmor’s *learning mode*. To log all access, whether successful or not, while
    enforcing a given policy, the *audit mode* has to be selected.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 设备上的每个AppArmor配置文件在运行时可以处于三种模式之一：强制、抱怨或审计。在*强制模式*下，配置文件设定的规则会被强制执行，任何违规尝试都会被记录。*抱怨模式*允许监控在定义的配置文件下应用程序的行为，违规操作会被记录。这个模式也用于前面提到的自动化配置文件创建，因此有时被称为AppArmor的*学习模式*。为了在强制执行给定策略的同时记录所有访问，无论是否成功，必须选择*审计模式*。
- en: AppArmor is a worthy alternative to SELinux that succeeds in reducing configuration
    and profiling complexity. From a security point of view, it’s sometimes more lax
    than its competitor and leaves space to circumvent access control in specific
    cases. For embedded systems, however, it might be a perfect compromise to introduce
    MAC mechanisms.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor是一个值得推荐的SELinux替代方案，成功地降低了配置和配置文件的复杂性。从安全性角度来看，它有时比竞争对手更加宽松，某些情况下可能存在绕过访问控制的空间。然而，对于嵌入式系统来说，它可能是引入MAC机制的完美折衷方案。
- en: '***Other LSMs and Non-LSM MACs***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他LSM和非LSM MACs***'
- en: Besides the two popular LSM implementations, SELinux and AppArmor, you might
    want to consider further options.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个流行的LSM实现，SELinux和AppArmor，你还可以考虑其他选项。
- en: 'As the name suggests, the *Simplified Mandatory Access Control Kernel (SMACK)*
    system was developed with a focus on simplicity, in contrast to the complexity
    of SELinux. It has been part of the Linux mainline kernel since 2008 and was always
    meant for use in embedded systems. Two larger OS projects rely on its protection
    mechanisms: the mobile OS Tizen used in Samsung’s smart TVs, and the automotive-grade
    Linux distribution meant as an open source platform for connected cars. However,
    looking at SMACK’s website and its Git repositories, it seems that it’s no longer
    actively maintained.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，*简化强制访问控制内核（SMACK）*系统的开发重点是简化，与SELinux的复杂性相对。自2008年起，它一直是Linux主线内核的一部分，并始终旨在用于嵌入式系统。两个较大的操作系统项目依赖于其保护机制：用于三星智能电视的移动操作系统Tizen，以及旨在为联网汽车提供开源平台的汽车级Linux发行版。然而，查看SMACK的官方网站及其Git仓库，似乎它不再积极维护。
- en: 'A further MAC system based on the LSM framework is called *TOMOYO*. The project
    was started in 2003 and merged into the Linux kernel 2.6.30 in 2009\. Again, the
    motivation was simpler usage and higher usability—for example, as implemented
    by an automatic policy generation, which is also necessary because this MAC system
    doesn’t come with a comprehensive set of rules for common services. In addition,
    TOMOYO not only serves as a MAC implementation but also facilitates system behavior
    analysis. It comes in three versions: 1.*x*, 2.*x*, and AKARI. The first one requires
    specific kernel patching and is, therefore, usually not your first choice. AKARI
    and TOMOYO 2.*x* use the LSM framework. At the time of writing, AKARI provides
    a few more features, but TOMOYO 2.*x* is catching up.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基于LSM框架的另一个MAC系统被称为*TOMOYO*。该项目始于2003年，并在2009年合并进Linux内核2.6.30。其动机是为了简化使用和提高可用性——例如，通过自动生成策略来实现，这也是必要的，因为这个MAC系统并没有为常见服务提供一套全面的规则。此外，TOMOYO不仅作为MAC实现，还促进了系统行为分析。它有三个版本：1.*x*、2.*x*和AKARI。第一个版本需要特定的内核补丁，因此通常不是首选。AKARI和TOMOYO
    2.*x*使用LSM框架。在撰写本文时，AKARI提供了一些额外的功能，但TOMOYO 2.*x*正在赶超。
- en: Although the LSM framework provides a multitude of possibilities for integrating
    custom security modules, not everybody in the community is satisfied with its
    implementation, especially considering the performance overhead it generates.
    Therefore, non-LSM MAC systems also exist that aim for higher performance or enhanced
    security module features. However, since those implementations are not part of
    the mainline kernel and have to be integrated by applying a custom set of patches,
    they might be an option only if you really can’t reach your requirements with
    the popular LSM implementations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然LSM框架为集成自定义安全模块提供了多种可能性，但并非所有社区成员都对其实现感到满意，尤其是考虑到它带来的性能开销。因此，也存在非LSM的MAC系统，旨在提高性能或增强安全模块功能。然而，由于这些实现不是主线内核的一部分，必须通过应用自定义补丁集来集成，它们可能只有在你无法通过流行的LSM实现满足需求时才是一个可行的选择。
- en: '**Case Study: Application Confinement with AppArmor**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：使用AppArmor进行应用程序限制**'
- en: In this case study, I shed light on the installation of AppArmor with the Yocto
    toolchain of my STM32MP157F-DK2 device and walk through its basic usage to restrict
    an application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我将重点介绍如何在我的STM32MP157F-DK2设备上使用Yocto工具链安装AppArmor，并演示如何通过基本使用来限制应用程序。
- en: '***Installation***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装***'
- en: AppArmor is not included in the default installation of ST’s OpenSTLinux distribution.
    Luckily, the Yocto `meta-security` layer maintained by Armin Kuster provides an
    AppArmor recipe under *meta-security/recipes-mac/AppArmor*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor不包含在ST的OpenSTLinux发行版的默认安装中。幸运的是，Armin Kuster维护的Yocto `meta-security`层提供了一个位于*meta-security/recipes-mac/AppArmor*下的AppArmor食谱。
- en: After cloning the corresponding Git repository, the Linux kernel can be configured
    for AppArmor usage with the settings shown in [Listing 11-9](ch11.xhtml#ch11list09).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆相应的Git仓库后，可以通过[清单11-9](ch11.xhtml#ch11list09)中所示的设置，配置Linux内核以使用AppArmor。
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-9: The Linux kernel configuration to enable AppArmor*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-9：启用AppArmor的Linux内核配置*'
- en: The first two lines enable AppArmor, and the last two lines set it as the default
    LSM to be used. However, I also had to add `security=apparmor` to the kernel’s
    boot arguments in U-Boot’s *extlinux.conf* files to select AppArmor at boot time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行启用AppArmor，最后两行则将其设置为默认使用的LSM。然而，我还需要在U-Boot的*extlinux.conf*文件中添加`security=apparmor`，以在启动时选择AppArmor。
- en: To compile and install the AppArmor user-space tools, add the line `IMAGE_INSTALL
    += "apparmor"` to the image’s recipe. I also had to add several distro features
    to the provided OpenSTLinux, as shown in [Listing 11-10](ch11.xhtml#ch11list010),
    in order to make Yocto successfully complete the building process.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和安装 AppArmor 用户空间工具，请在镜像的配方中添加 `IMAGE_INSTALL += "apparmor"` 这一行。我还必须向提供的
    OpenSTLinux 添加几个发行版特性，如 [列表 11-10](ch11.xhtml#ch11list010) 所示，以便使 Yocto 成功完成构建过程。
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-10: The distro features for AppArmor from* meta-security'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-10：来自* meta-security *的 AppArmor 发行版特性*'
- en: After booting the device, you can check whether AppArmor is actually enabled
    with the command shown in [Listing 11-11](ch11.xhtml#ch11list011). If it returns
    a `Y`, it was activated properly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 启动设备后，您可以使用 [列表 11-11](ch11.xhtml#ch11list011) 中显示的命令检查 AppArmor 是否已正确启用。如果返回
    `Y`，则表示已正确激活。
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-11: Checking whether AppArmor was enabled correctly*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-11：检查是否正确启用了 AppArmor*'
- en: AppArmor comes with the `aa-status` tool, which lists a variety of details regarding
    AppArmor’s current status, as shown in [Listing 11-12](ch11.xhtml#ch11list012).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor 附带了 `aa-status` 工具，它列出了有关 AppArmor 当前状态的各种详细信息，如 [列表 11-12](ch11.xhtml#ch11list012)
    所示。
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-12: The initial output of* aa-status'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-12：初始的* aa-status *输出*'
- en: You can see that the AppArmor recipe from the `meta-security` layer also installs
    a set of 50 standard profiles that are loaded in enforce mode on my device. However,
    the first thing I noticed is that although there are profiles loaded for `apache2`
    and `syslogd`, the corresponding, currently running processes are not confined.
    Only the `avahi-daemon` processes are restricted according to their profile.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到来自 `meta-security` 层的 AppArmor 配方也安装了一组 50 个标准配置文件，这些配置文件在我的设备上以强制模式加载。然而，我首先注意到的是，尽管为
    `apache2` 和 `syslogd` 加载了配置文件，但相应的当前运行的进程并未受到限制。只有 `avahi-daemon` 进程根据其配置文件受到限制。
- en: 'To investigate this issue, we have to take a look at the default AppArmor profiles
    stored in */etc/apparmor.d/*. For `apache2`, the file containing the provided
    profile is called *usr.sbin.apache2*. The filename is already a hint for the path
    of the executable it confines: */usr/sbin/apache2*, in this case. Looking at the
    content of the file, you can see a line stating `profile apache2 /usr/\{bin, sbin\}/apache2`,
    which means that the profile at hand is named `apache2` and targets the executable
    *apache2* located at */usr/bin/* or */usr/sbin/*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要调查此问题，我们需要查看存储在 */etc/apparmor.d/* 中的默认 AppArmor 配置文件。对于 `apache2`，包含提供的配置文件的文件名为
    *usr.sbin.apache2*。文件名已经暗示了它所限制的可执行文件路径：*/usr/sbin/apache2*。查看文件内容，可以看到一行 `profile
    apache2 /usr/\{bin, sbin\}/apache2`，这意味着当前的配置文件名为 `apache2`，并且目标是位于 */usr/bin/*
    或 */usr/sbin/* 的可执行文件 *apache2*。
- en: Unfortunately, this file doesn’t exist in my installation. Instead, it’s called
    *httpd*. Therefore, I created a copy of the initial file named *usr.sbin.httpd*.
    I also changed the profile name to `httpd` and the path for the executable to
    `/usr/\{bin,sbin\}/httpd`. Afterward, I loaded the profile in enforce mode as
    shown in [Listing 11-13](ch11.xhtml#ch11list013) and restarted the web server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我的安装中没有这个文件。相反，它被命名为 *httpd*。因此，我创建了一个名为 *usr.sbin.httpd* 的初始文件副本。我还将配置文件名称更改为
    `httpd`，并将可执行文件的路径更改为 `/usr/\{bin,sbin\}/httpd`。然后，我按 [列表 11-13](ch11.xhtml#ch11list013)
    中所示的方式加载了该配置文件，并重新启动了 Web 服务器。
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-13: Loading and disabling profiles*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-13：加载和禁用配置文件*'
- en: I also disabled the original profile with the help of `aa-disable` in order
    to clean up.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我还通过 `aa-disable` 禁用了原始配置文件，以便清理。
- en: '[Listing 11-14](ch11.xhtml#ch11list014) presents the output of another call
    to `aa-status`, showing that the `httpd` profile was loaded correctly and that
    all four corresponding process instances are running in enforce mode as desired.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-14](ch11.xhtml#ch11list014) 展示了另一次调用 `aa-status` 的输出，显示 `httpd` 配置文件已正确加载，并且所有四个相应的进程实例都按预期在强制模式下运行。'
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 11-14: The output of* aa-status *after profile changes*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-14：更改配置文件后的* aa-status *输出*'
- en: Although we succeeded in activating the predefined profile, we have no idea
    whether the profile actually restricts the web server application in a secure
    way. A comment in the given profile says that “this profile is completely permissive,”
    which means that you still have to customize it according to your application
    and requirements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们成功激活了预定义的配置文件，但我们不知道该配置文件是否以安全的方式实际限制了 Web 服务器应用程序。给定配置文件中的一条注释说：“这个配置文件完全是宽松的”，这意味着您仍然需要根据您的应用程序和需求对其进行定制。
- en: A quick look at the profile *sbin.syslogd* associated with the `syslogd` tool,
    the second example binary identified at the beginning of this subsection, reveals
    that the configured path, */sbin/syslogd*, matches the path of the corresponding
    executable, but the process is still not running in enforce mode. The properties
    of the binary, as shown in [Listing 11-15](ch11.xhtml#ch11list015), reveal that
    the executable is actually a symbolic link to another executable—namely, */bin/busybox.nosuid*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看与`syslogd`工具关联的 *sbin.syslogd* 配置文件，这个工具在本小节开头被标识为第二个示例二进制文件，可以发现配置的路径 */sbin/syslogd*
    与相应可执行文件的路径一致，但进程仍然没有以强制模式运行。如[清单 11-15](ch11.xhtml#ch11list015)所示，二进制文件的属性显示，该可执行文件实际上是指向另一个可执行文件的符号链接——即
    */bin/busybox.nosuid*。
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 11-15: A symbolic link to another executable*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-15：指向另一个可执行文件的符号链接*'
- en: This makes the situation somewhat complicated because BusyBox unites a variety
    of tools in one binary. Simply changing the `syslogd` profile’s path doesn’t solve
    this issue but rather causes further problems with other Busy-Box functionalities.
    In such cases, you have several options. You could just spare the `syslogd` profile,
    you could search for or create a comprehensive `busybox` profile, or you could
    install and use the original `syslogd` application after all.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况有些复杂，因为 BusyBox 将多种工具合并在一个二进制文件中。仅仅更改 `syslogd` 配置文件的路径并不能解决这个问题，反而会导致其他
    BusyBox 功能出现问题。在这种情况下，你有几个选择。你可以只放宽 `syslogd` 配置文件，也可以搜索或创建一个全面的 `busybox` 配置文件，或者你也可以最终安装并使用原版
    `syslogd` 应用程序。
- en: '***Application Profiling***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用程序剖析***'
- en: For your own applications or third-party tools that don’t come with a predefined
    AppArmor profile, you have to create one yourself if you want to confine them
    with MAC mechanisms at runtime.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你自己的应用程序或没有预定义 AppArmor 配置文件的第三方工具，如果你希望在运行时通过 MAC 机制限制它们，你必须自己创建一个配置文件。
- en: Let’s look at a very simple Python application that was reduced to the minimum.
    [Listing 11-16](ch11.xhtml#ch11list016) shows the code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个被简化到最小的 Python 应用。[清单 11-16](ch11.xhtml#ch11list016)展示了代码。
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 11-16: A simple file-printing application in Python*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-16：一个简单的 Python 打印文件应用*'
- en: This application’s sole purpose is to print the content of a text file given
    as a command line argument. The application’s filename is *printfile.py*, it’s
    located in */home/root/*, and it’s marked as executable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的唯一目的是打印作为命令行参数给定的文本文件的内容。应用程序的文件名是 *printfile.py*，位于 */home/root/* 目录下，并且被标记为可执行。
- en: Let’s assume that this tool is an essential part of your web interface and needs
    to run with superuser privileges because it has to print the content of the *testfile*
    and *logfile* files, which are accessible only by root. However, during your threat
    and risk analysis, you discover that adversaries might be able to inject other
    filepaths than the two intended ones, which could lead to the exposure of sensitive
    information and should be prevented—for example, by using a custom-tailored AppArmor
    profile.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个工具是你 web 界面的重要组成部分，并且需要超级用户权限运行，因为它必须打印 *testfile* 和 *logfile* 文件的内容，这些文件只能由
    root 访问。然而，在进行威胁和风险分析时，你发现攻击者可能能够注入除了两个预定文件路径之外的其他路径，这可能会导致敏感信息泄露，必须加以防范——例如，通过使用量身定制的
    AppArmor 配置文件。
- en: '[Listing 11-17](ch11.xhtml#ch11list017) shows the basic initial profile I created
    at */etc/apparmor.d/ home.root.printfile.py* as a starting point for profiling
    this application. It includes read access (`r`) for the two previously mentioned
    files and denies any other file access.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-17](ch11.xhtml#ch11list017)展示了我在 */etc/apparmor.d/home.root.printfile.py*
    中创建的基本初始配置文件，作为配置此应用程序的起点。它包括对之前提到的两个文件的读取权限（`r`），并拒绝任何其他文件访问。'
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-17: The initial AppArmor profile for* printfile.py'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-17：*printfile.py 的初始 AppArmor 配置文件'
- en: In the second step, I loaded the newly created profile in complain mode, as
    shown in [Listing 11-18](ch11.xhtml#ch11list018).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我以告警模式加载了新创建的配置文件，如[清单 11-18](ch11.xhtml#ch11list018)所示。
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 11-18: Loading a profile in complain mode*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-18：以告警模式加载配置文件*'
- en: If you now execute `./printfile.py testfile` in *home/root/*, the application
    will work without issues but will create log entries for all profile violations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在 *home/root/* 中执行 `./printfile.py testfile`，应用程序将正常运行，但会为所有配置文件违规情况创建日志条目。
- en: '[Listing 11-19](ch11.xhtml#ch11list019) shows a pruned set of AppArmor kernel
    messages corresponding to *printfile.py*.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-19](ch11.xhtml#ch11list019)展示了与 *printfile.py* 相关的精简版 AppArmor 内核消息。'
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 11-19: The AppArmor complain messages for* printfile.py'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-19：* printfile.py *的AppArmor抱怨消息*'
- en: You can see that multiple access violations occurred while just calling *printfile.py*
    in its intended way. If you put the initial profile in enforce mode, the application
    won’t work anymore. Therefore, you have to use the depicted output to extend the
    AppArmor profile for *printfile.py*. For example, you have to grant read access
    (`r`) to */etc/ld.so.cache*, execution rights (`ux`) for */usr/bin/python3.10*,
    and permissions for reading (`r`) and mapping (`m`) */usr/lib/libpython3.10.so.1.0*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在以预期的方式调用*printfile.py*时发生了多个访问违规。如果你将初始配置文件放入强制模式，应用程序将不再工作。因此，你需要使用所示输出扩展*printfile.py*的AppArmor配置文件。例如，你需要授予*/etc/ld.so.cache*的读取权限（`r`），*/usr/bin/python3.10*的执行权限（`ux`），以及读取（`r`）和映射（`m`）*/usr/lib/libpython3.10.so.1.0*的权限。
- en: '[Listing 11-20](ch11.xhtml#ch11list020) shows the final profile after four
    iterations of execution in complain mode, profile refinement, and reloading.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-20](ch11.xhtml#ch11list020)展示了在抱怨模式下执行四次、配置文件优化和重新加载后的最终配置文件。'
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 11-20: The AppArmor profile for* printfile.py *after refinement*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-20：优化后的* printfile.py *的AppArmor配置文件*'
- en: After this manual characterization phase, the created profile can be loaded
    in enforce mode and tested for its behavior ([Listing 11-21](ch11.xhtml#ch11list021)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个手动表征阶段之后，创建的配置文件可以在强制模式下加载，并测试其行为（[Listing 11-21](ch11.xhtml#ch11list021)）。
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 11-21: Testing* printfile.py *in enforce mode*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-21：在强制模式下测试* printfile.py *'
- en: Printing the *testfile* and *logfile* files works as intended. However, if attackers
    try to read the *secrets* file in the same folder or even the */etc/passwd* file,
    AppArmor successfully protects from severe damage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 打印*testfile*和*logfile*文件按预期工作。然而，如果攻击者尝试读取同一文件夹中的*secrets*文件，甚至是*/etc/passwd*文件，AppArmor将成功防止严重损害。
- en: This simple case study showed the basic feasibility of application characterization
    and corresponding AppArmor profile creation. However, even this trivial example
    took several profiling iterations, and the resulting profile will need to be maintained
    continuously—for example, if you switch to another distribution or even a newer
    version of Python. Further, as you can imagine, more complex applications require
    significantly more characterization and testing efforts.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的案例研究展示了应用程序表征及相应的AppArmor配置文件创建的基本可行性。然而，即使是这个简单的示例也经历了多个配置文件迭代，且生成的配置文件将需要持续维护——例如，如果你切换到另一个发行版或甚至更新版本的Python。此外，正如你可以想象的，复杂的应用程序需要显著更多的表征和测试工作。
- en: '**Summary**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Access control is an enormously broad topic that could fill a whole book on
    its own. It encompasses the basic configurations of users, groups, directory structures,
    and access permissions (as discussed in this chapter for the Linux DAC system),
    the deactivation of hardware debugging features and tools not meant for end users,
    and the complex field of OS-enforced MAC policies that have to be fine-tuned to
    the individual behavior and resource-access demands of a specific application.
    And while I don’t expect you to invest all your time designing perfect access-control
    settings, there’s no way around this matter in secure device engineering.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制是一个极其广泛的话题，可以单独写成一本书。它涵盖了用户、组、目录结构和访问权限的基本配置（本章讨论了Linux DAC系统），禁用不适用于终端用户的硬件调试功能和工具，以及必须根据特定应用程序的行为和资源访问需求进行微调的操作系统强制MAC策略的复杂领域。尽管我不指望你把所有时间都用来设计完美的访问控制设置，但在安全设备工程中，绕过这个问题是不可行的。
- en: In practice, we have to find practically feasible compromises. A complete whitelisting
    approach might be hard to implement and can lead to broken applications if misconfigured,
    for which security will be blamed. Blacklisting, on the other hand, won’t be able
    to immediately catch new threats that appear in the field. A fine granularity
    of permissions can be managed over time only if you are willing to expend significant
    effort, but if your access-control concept is too simplistic, your adversaries
    will thank you for removing that annoying obstacle in the way.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作中，我们必须找到切实可行的折中方案。完全的白名单策略可能难以实施，并且如果配置错误，可能会导致应用程序崩溃，从而受到安全指责。另一方面，黑名单策略则无法立即捕捉到出现的新威胁。权限的精细粒度只能通过时间管理，如果你愿意付出大量努力，但如果你的访问控制概念过于简单，敌人将会感谢你移除了那个恼人的障碍。
- en: Finally, I’d like to point out that access-control mechanisms always have a
    strong relation to system-integrity protection, as described in [Chapter 8](ch08.xhtml#ch08).
    Just imagine if you painstakingly defined a perfect set of access rules only to
    find out that an attacker can reset them all to 777 within minutes. That would
    hurt.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想指出，访问控制机制总是与系统完整性保护有着密切关系，如[第8章](ch08.xhtml#ch08)所述。试想一下，如果你辛苦定义了一套完美的访问规则，却发现攻击者可以在几分钟内将它们全部重置为777，那将非常痛苦。
