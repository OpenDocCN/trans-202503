["```\n// [Listing14-1](#listinganchor14-1).ino\n//\n// A simple program that demonstrates\n// ADS1115 programming.\n//\n// This program constantly reads the A0\n// ADC channel and displays its values.\n\n#include <Wire.h>\n#define ads1115 (0x48) // Connect ADDR to Gnd\n\n// ADS1x15 registers:\n\n#define conversion  (0)\n#define config      (1)\n#define lowThresh   (2)\n#define highThresh  (3)\n\n// Usual Arduino initialization code:\n\nvoid setup( void )\n{\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"Test reading ADS1115\" );\n    Wire.begin(); // Initialize I2C library\n\n    adsReset();\n}\n\n// adsReset-\n//\n// Reset the ADS1x115 to a known state:\n\nvoid adsReset()\n{\n    // Use the I2C General Call with a reset command:\n\n    Wire.beginTransmission( 0 );\n    Wire.write( 6 );\n    Wire.endTransmission();\n}\n\n// adsWrite-\n//\n// Writes a 16-bit value to one\n// of the ADS1x115 registers:\n\nvoid adsWrite( int adrs, int reg, int value )\n{\n    Wire.beginTransmission( adrs );\n    Wire.write( reg );              // Pointer register value\n\n    // Split the output value into 2 bytes\n    // and write them to the ADS1x15\\. Note that\n    // this is written immediately after the\n    // pointer register byte.\n\n    Wire.write( (value << 8) & 0xff );\n    Wire.write( value & 0xff );\n    Wire.endTransmission();\n}\n\n// adsRead-\n//\n// Reads a (signed) 16-bit value from one\n// of the ADS1x15 registers.\n\nint adsRead( int adrs, int reg )\n{\n    unsigned char LOByte;\n    unsigned char HOByte;\n\n Wire.beginTransmission( adrs );\n    Wire.write( reg );              // Pointer register value\n    Wire.endTransmission( false );  // No stop condition\n\n    // Must send a new start condition and address\n    // byte with the LO bit set to 1 in order to\n    // the 2 bytes (Wire.requestFrom does this).\n\n    Wire.requestFrom( adrs, 2 );   // Read two bytes from\n    HOByte = Wire.read();          // the conversion register\n    LOByte = Wire.read();          \n\n    // Convert the 2 bytes read from the conversion\n    // register to a signed integer and return.\n\n    return (int) ((short) (HOByte << 8) | LOByte);\n}\n\n// wait4Ready-\n//\n// Polls bit 15 of the configuration register (\"ready\" bit)\n// until it contains a 1 (conversion complete).\n\nvoid wait4Ready( void )\n{\n  ❶ while( (adsRead( ads1115, config ) & 0x8000) == 0 )\n    {\n        // Wait for conversion to complete.\n    }\n}\n\n// Arduino main loop.\n\nvoid loop( void )\n{\n    uint16_t startConv;\n\n    // Create value to write to the configuration\n    // register that will start a conversion on\n    // single-ended input A0:\n\n    startConv =\n          ❷ (1) << 15       // Start conversion\n      ❸ |   (0b100) << 12   // A0, single-ended\n      ❹ |   (0b001) << 9    // PGA = 4.095 V\n      ❺ |   (1) << 8        // One-shot mode\n      ❻ |   (0b111) << 5    // 860 sps (ADS1115), 3300 (ADS1015)\n        |   (0) << 4        // Comparator mode (not used)\n        |   (0) << 3        // Comparator polarity (not used)\n        |   (0) << 2        // Non-latching (not used)\n      ❼ |   (0b11);         // Comparator disabled\n\n    // First, wait until any existing conversion completes:\n\n    wait4Ready();\n\n // Start a conversion:\n\n  ❽ adsWrite( ads1115, config, startConv );\n\n    // Wait for it to complete:\n\n  ❾ wait4Ready();\n\n    // Read the ADC value:\n\n    int16_t adcValue = adsRead( ads1115, conversion );\n\n    // Display result:\n\n    Serial.print( \"ADC: \" );\n    Serial.println( adcValue );\n}\n```", "```\nADC: -2\nADC: 3\nADC: -1\nADC: -2\nADC: -1\nADC: 1\nADC: -1\nADC: 0\nADC: 0\nADC: 0\nADC: -1\nADC: -1\nADC: 1\nADC: -2\nADC: 0\nADC: -1\nADC: 0\nADC: -1\n```", "```\nADC: 0\nADC: 0\nADC: 0\nADC: 0\nADC: 0\nADC: 0\nADC: -16\nADC: 0\nADC: 0\nADC: 16\nADC: 0\nADC: 0\nADC: 0\n```", "```\n// [Listing14-2](#listinganchor14-2).ino\n//\n// A simple program that demonstrates\n// ADS1115 programming.\n//\n// This program constantly reads the A0\n// ADC channel and displays its values.\n// It reads the ALRT/RDY pin to determine\n// when the conversion is complete (connect\n// ALRT to D2 on Arduino).\n\n  #include <Wire.h>\n  #define ads1115 (0x48) // Connect ADDR to Gnd\n❶ #define rdy (2)        // RDY is on pin 2\n```", "```\n// Listing14-2.ino (cont.)\n//\n// wait4Ready-\n//\n// Polls digital I/O pin 2 to see\n// if the conversion is complete.\n\nvoid wait4Ready( void )\n{\n  ❷ while( digitalRead( rdy ) != 0 )\n    {\n        // Wait for conversion to complete.\n    }\n}\n```", "```\n// Listing14-2.ino (cont.)\n\nvoid setup( void )\n{\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"Test reading ADS1115\" );\n    Wire.begin(); // Initialize I2C library\n    pinMode( 2, INPUT );\n\n    // Write a 1 to the HO bit of the\n    // high threshold register and a 0\n    // to the HO bit of the low threshold\n    // register to program the ALRT pin\n    // to behave as the RDY pin.\n\n    adsReset();\n    adsWrite( ads1115, config, 0x43E0 );\n  ❸ adsWrite( ads1115, lowThresh, 0x0 );\n  ❹ adsWrite( ads1115, highThresh, 0x8000 );\n}\n```", "```\n// Listing14-2.ino (cont.)\n\nvoid loop( void )\n{\n    uint16_t startConv;\n\n    // Create value to write to the configuration\n    // register that will start a conversion on\n    // single-ended input A0:\n\n    startConv =\n            (1) << 15       // Start conversion\n        |   (0b100) << 12   // A0, single-ended\n        |   (0b001) << 9    // PGA = 4.095 V\n        |   (1) << 8        // One-shot mode\n        |   (0b111) << 5    // 860 sps\n        |   (0) << 4        // Comparator mode (not used)\n        |   (0) << 3        // Comparator polarity (used)\n        |   (0) << 2        // Non-latching (not used)\n      ❺ |   (0b00);         // Comparator enabled\n```", "```\n// [Listing14-3](#listinganchor14-3).ino\n//\n// A simple program that demonstrates\n// ADS1115 programming.\n//\n// This program constantly reads the A0\n// ADC channel and displays its values \n// using continuous conversion mode.\n// It reads the ALRT/RDY pin to determine\n// when a new conversion occurs (so it can\n// output data to the Serial terminal).\n//\n// adsReset-\n//\n// Reset the ADS1x115 to a known state:\n\nvoid adsReset()\n{\n    // Use the I2C General Call with a reset command:\n\n    Wire.beginTransmission( 0 );\n    Wire.write( 6 );\n    Wire.endTransmission();\n}\n\n// wait4Conversion-\n//\n// Polls digital I/O pin 2 to see if the\n// conversion is complete.\n\nvoid wait4Conversion( void )\n{\n    // Wait for the falling edge that\n    // indicates a conversion has occurred.\n\n  ❶ while( digitalRead( rdy ) == 0 )\n    {\n        // Wait for conversion to complete.\n    }\n\n    // Wait for the rising edge so that\n    // the next loop doesn't mistakenly\n    // think a new conversion occurred.\n\n  ❷ while( digitalRead( rdy ) == 1 )\n    {\n        // Wait for conversion to complete.\n    }\n}\n```", "```\n// Listing14-3.ino (cont.)\n//\n// Usual Arduino initialization code.\n\nvoid setup( void )\n{\n\n    Serial.begin( 9600 );\n delay( 1000 );\n    Serial.println( \"Test reading ADS1115\" );\n    Wire.begin(); // Initialize I2C library\n    pinMode( 2, INPUT );\n\n    // Write a 1 to the HO bit of the\n    // high threshold register and a 0\n    // to the HO bit of the low threshold\n    // register to program the ALRT pin\n    // to behave as the RDY pin. Also\n    // put a 0 in bit 8 to turn on the\n    // continuous conversion mode.\n\n    adsReset();\n  ❸ adsWrite( ads1115, config, 0x42E0 );\n    adsWrite( ads1115, lowThresh, 0x0 );\n    adsWrite( ads1115, highThresh, 0x8000 );\n}\n```", "```\n// Listing14-3.ino (cont.)\n//\n// Arduino main loop.\n\nvoid loop( void )\n{\n\n    // Wait for a conversion to complete:\n\n  ❹ wait4Conversion();\n\n    // Read the ADC value:\n\n    int16_t adcValue = adsRead( ads1115, conversion );\n\n    // Display result:\n\n    Serial.print( \"ADC: \" );\n    Serial.println( adcValue );\n}\n```", "```\nint medianOfThree( int a, int b, int c )\n{\n    if( (a > b) != (a > c) ) \n        return a;\n    else if( (b > a) != (b > c) )\n        return b;\n    else\n        return c;\n}\n```", "```\n#include <string.h>\n\n#define ever ;;\n#define breakif(exp) if (exp) break\n\n// Find the median element of an int16_t array.\n//\n// This Quickselect routine is based on the algorithm \n// described in \"Numerical recipes in C,\" Second Edition,\n// Cambridge University Press, 1992, Section 8.5, \n// ISBN 0-521-43108-5.\n//\n// This code was originally written by Nicolas Devillard - 1998\n// Public domain.\n//\n// Code was modified to use macros (straight-line code) for\n// arrays with 9 or fewer elements (an optimization).\n\n#define ELEM_SORT(a,b) { if((a)>(b)) ELEM_SWAP( (a), (b) ); }\n#define ELEM_SWAP(a,b) { register int16_t t=(a);(a)=(b);(b)=t; }\n#define ainReadings_c 32  // Maximum number of readings\n\nint16_t quick_select(int16_t array[ainReadings_c], int n) \n{\n    int low;\n    int high;\n    int median;\n    int middle;\n    int ll;\n    int hh;\n\n // Make temporary copy here because you will modify array.\n\n    int16_t arr[ainReadings_c]; \n\n    // Macros to handle special cases as fast as possible.\n\n    switch( n )\n    {\n        case 1:\n            return array[0];\n\n        case 2:\n\n            // If just two elements, return their \n            // arithmetic mean:\n\n            return (array[0] + array[1]) / 2;\n\n        case 3:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n\n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[0], arr[1] );\n            return(arr[1]) ;\n\n        case 4:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n            arr[3] = array[3];\n\n            ELEM_SORT( arr[0], arr[1] );\n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[0], arr[2] );\n            ELEM_SORT( arr[1], arr[3] );\n\n            // arr[1] and arr[3] may be out of order, \n            // but it doesn't matter.\n\n            // Return the mean of the upper and lower medians:\n\n            return( (arr[1] + arr[2]) / 2 );\n\n        case 5:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n            arr[3] = array[3];\n            arr[4] = array[4];\n\n            ELEM_SORT( arr[0], arr[1] );\n            ELEM_SORT( arr[3], arr[4] ); \n ELEM_SORT( arr[0], arr[3] );\n            ELEM_SORT( arr[1], arr[4] );\n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[2], arr[3] );\n            ELEM_SORT( arr[1], arr[2] );\n            return( arr[2] );\n\n        case 6:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n            arr[3] = array[3];\n            arr[4] = array[4];\n            arr[5] = array[5];\n\n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[3], arr[4] );\n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[4], arr[5] );\n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[3], arr[4] );\n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[4], arr[5] );\n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[3], arr[4] );\n\n            // ELEM_SORT( arr[2], arr[3] ) results in lower\n            // median in  arr[2] and upper median in  arr[3].\n            // \"Median\" of an even number of elements is the \n            // mean of the two middle elements in this code.\n\n            return (  arr[2] +  arr[3] ) / 2;\n\n        case 7:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n            arr[3] = array[3];\n            arr[4] = array[4];\n            arr[5] = array[5];\n            arr[6] = array[6];\n\n            ELEM_SORT( arr[0], arr[5] ); \n            ELEM_SORT( arr[0], arr[3] ); \n            ELEM_SORT( arr[1], arr[6] );\n            ELEM_SORT( arr[2], arr[4] ); \n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[3], arr[5] );\n            ELEM_SORT( arr[2], arr[6] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[3], arr[6] );\n            ELEM_SORT( arr[4], arr[5] ); \n ELEM_SORT( arr[1], arr[4] ); \n            ELEM_SORT( arr[1], arr[3] );\n            ELEM_SORT( arr[3], arr[4] ); \n            return ( arr[3] );\n\n        case 8:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n            arr[3] = array[3];\n            arr[4] = array[4];\n            arr[5] = array[5];\n            arr[6] = array[6];\n            arr[7] = array[7];\n\n            // No convenient macro to get the median\n            // of eight elements, so resorted to an\n            // ugly insertion sort here:\n\n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[6], arr[7] ); \n            ELEM_SORT( arr[1], arr[2] );\n            ELEM_SORT( arr[5], arr[6] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[4], arr[5] );\n            ELEM_SORT( arr[3], arr[4] ); \n            ELEM_SORT( arr[4], arr[5] ); \n            ELEM_SORT( arr[2], arr[3] );\n            ELEM_SORT( arr[5], arr[6] ); \n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[6], arr[7] );\n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[5], arr[6] );\n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[4], arr[5] ); \n            ELEM_SORT( arr[3], arr[4] );\n            ELEM_SORT( arr[4], arr[5] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[5], arr[6] ); \n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            ELEM_SORT( arr[4], arr[5] ); \n            ELEM_SORT( arr[3], arr[4] ); \n            ELEM_SORT( arr[2], arr[3] ); \n            return( (arr[3] + arr[4]) / 2);\n\n        case 9:\n            arr[0] = array[0];\n            arr[1] = array[1];\n            arr[2] = array[2];\n            arr[3] = array[3];\n            arr[4] = array[4];\n            arr[5] = array[5];\n arr[6] = array[6];\n            arr[7] = array[7];\n            arr[8] = array[8];\n\n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[4], arr[5] ); \n            ELEM_SORT( arr[7], arr[8] );\n            ELEM_SORT( arr[0], arr[1] ); \n            ELEM_SORT( arr[3], arr[4] ); \n            ELEM_SORT( arr[6], arr[7] );\n            ELEM_SORT( arr[1], arr[2] ); \n            ELEM_SORT( arr[4], arr[5] ); \n            ELEM_SORT( arr[7], arr[8] );\n            ELEM_SORT( arr[0], arr[3] ); \n            ELEM_SORT( arr[5], arr[8] ); \n            ELEM_SORT( arr[4], arr[7] );\n            ELEM_SORT( arr[3], arr[6] ); \n            ELEM_SORT( arr[1], arr[4] ); \n            ELEM_SORT( arr[2], arr[5] );\n            ELEM_SORT( arr[4], arr[7] ); \n            ELEM_SORT( arr[4], arr[2] ); \n            ELEM_SORT( arr[6], arr[4] );\n            ELEM_SORT( arr[4], arr[2] ); \n            return( arr[4]) ;\n\n        // Handle the general case (not one of the above) here:\n\n        default:\n\n            // The quick_select algorithm modifies the array.\n            // Therefore, you need to make a copy of it prior \n            // to use.\n\n            memcpy( arr, array, n*sizeof( int16_t ) );\n            low = 0; \n            high = n-1; \n            median = (low + high) / 2;\n            for( ever )\n            {\n                if (high <= low)     // One element only\n                {\n                    return arr[median];\n                } // endif\n\n                if (high == low + 1) // Two elements only\n                {\n                    return (arr[low] + arr[high]) / 2;\n                } // endif\n\n                // Find median of low, middle, and high items;\n                // swap into position (low).\n\n                middle = (low + high) / 2;\n                if (arr[middle] > arr[high])\n {\n                    ELEM_SWAP(arr[middle], arr[high]);\n                } // endif\n                if (arr[low] > arr[high])\n                {\n                    ELEM_SWAP(arr[low], arr[high])\n                } // endif\n                if (arr[middle] > arr[low])\n                {\n                    ELEM_SWAP(arr[middle], arr[low]);\n                } // endif\n\n                // Swap low item (now in position middle) \n                // into position (low+1).\n\n                ELEM_SWAP(arr[middle], arr[low+1]) ;\n\n                // Nibble from each end towards middle, \n                // swapping items when stuck.\n\n                ll = low + 1;\n                hh = high;\n                for( ever )\n                {\n                    do ll++; while (arr[low] > arr[ll]);\n                    do hh--; while (arr[hh]  > arr[low]);\n\n                    breakif (hh < ll);\n\n                    ELEM_SWAP(arr[ll], arr[hh]);\n                } // endfor\n\n                // Swap middle item (in position low) back \n                // into correct position.\n\n                ELEM_SWAP(arr[low], arr[hh]);\n\n                // Reset active partition.\n\n                if (hh <= median)\n                {\n                    low = ll;\n                } // endif\n                if (hh >= median)\n                high = hh - 1;\n\n            } // endfor\n    } // end switch\n} // quick_select\n\n#undef ELEM_SWAP\n```"]