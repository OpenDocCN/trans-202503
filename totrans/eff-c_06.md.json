["```\n#include <stdlib.h>\n\ntypedef struct {\n  double d;\n  int i;\n  char c[10];\n} widget;\n\n❶ widget *p = malloc(sizeof *p);\n❷ if (p == nullptr) {\n  // handle allocation error\n}\n// continue processing\n```", "```\nvoid *p = malloc(size);\n```", "```\nchar *p = malloc(size);\n```", "```\nwidget w = {3.2, 9, \"abc\",};\nmemcpy(p, &w, sizeof(w));\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n  char *str = (char *)malloc(16);\n  if (str) {\n    strncpy(str, \"123456789abcdef\", 15);\n    printf(\"str = %s.\\n\", str);\n    free(str);\n    return EXIT_SUCCESS;\n  }\n  return EXIT_FAILURE;\n}\n```", "```\nstrncpy(str, \"123456789abcdef\", 15);\n❶ str[15] = '\\0';\n```", "```\nvoid *aligned_alloc(size_t alignment, size_t size);\n```", "```\nvoid *calloc(size_t nmemb, size_t size);\n```", "```\nvoid *realloc(void *ptr, size_t size);\n```", "```\nsize += 50;\nif ((p = realloc(p, size)) == nullptr) return nullptr;\n```", "```\nvoid *p = malloc(100);\nvoid *p2;\n\n// `--snip--`\nif ((nsize == 0) || (p2 = realloc(p, nsize)) == nullptr) {\n  free(p);\n  return nullptr;\n}\np = p2;\n```", "```\nnewp = realloc(p, ...);\n```", "```\nif (newp != p) {\n  // update pointers to reallocated memory\n}\n```", "```\nif (p == nullptr)\n  newp = malloc(newsize);\nelse\n  newp = realloc(p, newsize);\n```", "```\nnewp = realloc(p, newsize);\n```", "```\nif ((newp = realloc(p, num * size)) == nullptr) {\n  // `--snip--`\n```", "```\nvoid *reallocarray(void *ptr, size_t nmemb, size_t size);\n```", "```\nif ((newp = reallocarray(p, num, size)) == nullptr) {\n  // `--snip--`\n```", "```\nvoid free(void *ptr);\n```", "```\n char *ptr = nullptr;\n  free(ptr);\n```", "```\nvoid free_sized(void *ptr, size_t size);\n```", "```\nvoid *buf = malloc(size);\nuse(buf, size);\nfree(buf);\n```", "```\nvoid *buf = malloc(size);\nuse(buf, size);\nfree_sized(buf, size);\n```", "```\nvoid free_aligned_sized(void *ptr, size_t alignment, size_t size);\n```", "```\nvoid *aligned_buf = aligned_alloc(alignment, size);\nuse_aligned(buf, size, alignment);\nfree(buf);\n```", "```\nvoid *aligned_buf = aligned_alloc(size, alignment);\nuse_aligned(buf, size, alignment);\nfree_aligned_sized(buf, alignment, size);\n```", "```\n#include <dirent.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint closedir(DIR *dirp) {\n  free(dirp->d_buf);\n  free(dirp);\n  return close(dirp->d_fd);  // dirp has already been freed\n}\n```", "```\nchar *ptr = malloc(16);\n// `--snip--`\nfree(ptr);\nptr = nullptr;\n```", "```\nchar *p = malloc(100);\nmemset(p, 0, 50);\n```", "```\n#include <stdlib.h>\n\nconstexpr size_t max_elem = 100;\n\ntypedef struct {\n  size_t num;\n❶ int data[];\n} widget;\n\nwidget *alloc_widget(size_t num_elem) {\n  if (num_elem > max_elem) return nullptr;\n❷ widget *p = (widget *)malloc(sizeof(widget) + sizeof(int) * num_elem);\n  if (p == nullptr) return nullptr;\n\n  p->num = num_elem;\n  for (size_t i = 0; i < p->num; ++i) {\n  ❸ p->data[i] = 17;\n  }\n  return p;\n}\n```", "```\nvoid printerr(errno_t errnum) {\n❶ rsize_t size = strerrorlen_s(errnum) + 1;\n❷ **char *msg = (char *)alloca(size);**\n  if (❸ strerror_s(msg, size, errnum) != 0) {\n   ❹ fputs(msg, stderr);\n  }\n  else {\n   ❺ fputs(\"unknown error\", stderr);\n  }\n}\n```", "```\nvoid func(size_t size) {\n  int vla[size];\n  // `--snip--`\n}\n```", "```\nvoid print_error(int errnum) {\n  size_t size = strerrorlen_s(errnum) + 1;\n **char msg[size];**\n  if (strerror_s(msg, size, errnum) != 0) {\n    fputs(msg, stderr);\n  }\n  else {\n    fputs(\"unknown error\", stderr);\n  }\n}\n```", "```\nstatic const unsigned int num_elem = 12;\ndouble array[num_elem];\n```", "```\nconstexpr unsigned int num_elem = 12;\ndouble array[num_elem];\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  size_t size = 12;\n  (void)(sizeof(size++));\n  printf(\"%zu\\n\", size); // prints 12\n  (void)sizeof(int[size++]);\n  printf(\"%zu\\n\", size); // prints 13\n  typedef int foo[size++];\n  printf(\"%zu\\n\", size); // prints 14\n  typeof(int[size++]) f;\n  printf(\"%zu\\n\", size); // prints 15\n  return EXIT_SUCCESS;\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n**#ifdef DMALLOC**\n**#include \"dmalloc.h\"**\n**#endif**\n\nvoid usage(char *msg) {\n  fprintf(stderr, \"%s\", msg);\n  free(msg);\n  return;\n}\n\nint main(int argc, char *argv[]) {\n if (argc != 3 && argc != 4) {\n    // the error message is less than 80 chars\n    char *errmsg = (char *)malloc(80);\n    sprintf(\n      errmsg,\n      \"Sorry %s,\\nUsage: caesar secret_file keys_file [output_file]\\n\",\n      getenv(\"USER\")\n    );\n    usage(errmsg);\n    free(errmsg);\n    return EXIT_FAILURE;\n  }\n  // `--snip--`\n\n  return EXIT_SUCCESS;\n}\n```", "```\nSorry (null),\nUsage: caesar secret_file keys_file [output_file]\nfree(): double free detected in tcache 2\nProgram terminated with signal: SIGSEGV\n```", "```\n% **dmalloc --usage**\n```", "```\n% **dmalloc -l logfile -i 100 low**\n```", "```\n% **gcc -DDMALLOC caesar.c -ocaesar -ldmalloc**\n```", "```\n% **./caesar**\nSorry student,\nUsage: caesar secret_file keys_file [output_file]\ndebug-malloc library: dumping program, fatal error\n  Error: tried to free previously freed pointer (err 61)\nAborted (core dumped)\n```", "```\n% **more logfile**\n1571549757: 3: Dmalloc version '5.5.2' from 'https://dmalloc.com/'\n1571549757: 3: flags = 0x4e48503, logfile 'logfile'\n1571549757: 3: interval = 100, addr = 0, seen # = 0, limit = 0\n1571549757: 3: starting time = 1571549757\n1571549757: 3: process pid = 29531\n1571549757: 3:   error details: finding address in heap\n1571549757: 3:   pointer '0x7ff010812f88' from 'caesar.c:29' prev access 'unknown'\n1571549757: 3: ERROR: free: tried to free previously freed pointer (err 61)\n```"]