<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_741" aria-label="741"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">MACROS AND THE GAS COMPILE-TIME LANGUAGE</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This chapter discusses the Gas compile-time language (CTL), including its macro expansion facilities. A <i>macro</i>, the CTL equivalent of a procedure, is an identifier that the assembler will expand into additional text. This allows you to abbreviate large amounts of code with a single identifier. Gas’s macro facility is a computer language inside a computer language; that is, you can write short programs inside a Gas source file whose purpose is to generate other Gas source code to be assembled by Gas.</p>&#13;
<p class="TX">The Gas CTL consists of macros, conditionals (<span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements), loops, and other statements. This chapter covers many Gas CTL features and how you can use them to reduce the effort needed to write assembly language code.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_742" aria-label="742"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-137"/><span class="SANS_Futura_Std_Bold_B_11">13.1 The Gas Compile-Time Language Interpreter</span></h3>&#13;
<p class="TNI1">Gas is actually two languages rolled into a single program. The <i>runtime language</i> is the standard ARM/Gas assembly language you’ve been reading about in the previous chapters. This is called the runtime language because the programs you write execute when you run the executable file. Gas contains an interpreter for a second language, the <i>Gas CTL</i>.</p>&#13;
<p class="TX">Gas source files contain instructions for both the Gas CTL and the runtime program, and Gas executes the CTL program during assembly (compilation). Once Gas completes assembly, the CTL program terminates. <a href="chapter13.xhtml#fig13-1">Figure 13-1</a> shows the relationship between compile-time and runtime with respect to the Gas assembler and your assembly language source code.</p>&#13;
<figure class="IMG"><img class="img1" id="fig13-1" src="../images/Figure13-1.jpg" alt="" width="1311" height="911"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-1: Compile-time versus runtime execution</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The CTL application is not a part of the runtime executable that Gas emits, although the CTL application can write part of the runtime program for you. In fact, this is the major purpose of the CTL. Using automatic code generation, the CTL gives you the ability to emit repetitive code easily and elegantly. By learning how to use the Gas CTL and applying it properly, you can potentially develop assembly language applications as rapidly as HLL applications (even faster because Gas’s CTL lets you create very HLL, or VHLL, constructs).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-138"/><span class="SANS_Futura_Std_Bold_B_11">13.2 The C/C++ Preprocessor</span></h3>&#13;
<p class="TNI1">The Gas CTL consists of two separate language processors: the Gas built-in macro processor and the C/C++ preprocessor (CPP). As noted in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_743" aria-label="743"/>standard Gas assembly language source files use the <i>.s</i> suffix. However, if you specify <i>.S</i> as the suffix, Gas will run the source file through the CPP prior to processing the file (see <a href="chapter13.xhtml#fig13-2">Figure 13-2</a>). The CPP emits a temporary source file (with the <i>.s</i> suffix), which the Gas assembler then assembles into object code.</p>&#13;
<figure class="IMG"><img class="img5" id="fig13-2" src="../images/Figure13-2.jpg" alt="" width="635" height="510"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 13-2: C preprocessor processing by Gas</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">It is extremely important to remember that the CPP runs independently of Gas and prior to it assembling the assembly language source file. In particular, Gas’s macro processing takes place <i>after</i> the CPP runs. Therefore, you cannot use Gas statements, symbols, or Gas macros to affect the operation of the CPP. Later in this chapter, I’ll point out the areas where you must take care when mixing the macro facilities of the two languages. This section describes the various features of the CPP.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-243"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.2.1 The #warning and #error Directives</span></h4>&#13;
<p class="TNI1">When writing macros by using CPP, you’ll sometimes encounter a problem (such as a bad parameter argument) that you’ll want to report as an error or a diagnostic message during the assembly process. To do so, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">#warning</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">#error</span> diagnostic statements with the following syntax:</p>&#13;
<pre id="pre-978"><code>#error <var>arbitrary text</var>&#13;
#warning <var>arbitrary text</var></code></pre>&#13;
<p class="TX">These statements must appear on a source line by themselves; nothing other than whitespace (spaces and tabs) should appear on the line before the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> character. (Technically, whitespace is allowed to appear between the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> and the error or the warning tokens, but good programming style dictates keeping them together.)</p>&#13;
<p class="TX">During assembly (or, more precisely, while CPP is processing the source file), the system should display a diagnostic message and print the line containing the <span class="SANS_TheSansMonoCd_W5Regular_11">#error</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">#warning</span> statement, including all the arbitrary text up to the end of the line. By convention, most programmers surround the error or warning message (the arbitrary text) in quotes, but this isn’t absolutely necessary.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_744" aria-label="744"/>If CPP encounters any <span class="SANS_TheSansMonoCd_W5Regular_11">#error</span> statements, it will terminate the assembly after CPP is done scanning the source file, without running the Gas assembler to assemble that file. In this case, you will need to modify the source file as necessary to eliminate the error message before Gas even gets a chance to process the file (and, for example, report on any errors in the assembly language source code).</p>&#13;
<p class="TX">If the CPP encounters any <span class="SANS_TheSansMonoCd_W5Regular_11">#warning</span> statements, it will print the appropriate message during assembly but will allow assembly to proceed after the CPP is done preprocessing the source file. Hence, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">#warning</span> statement to display arbitrary text during the assembly and preprocessing process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-244"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.2.2 Compile-Time Constant Definition with CPP</span></h4>&#13;
<p class="TNI1">You can use the CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement to create constant definitions in your source file:</p>&#13;
<pre id="pre-979"><code>#define <var>identifier</var> <var>arbitrary_text</var></code></pre>&#13;
<p class="TX">When CPP processes the source file, it will replace any following occurrences of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier</span> by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">arbitrary_text</span>. Programmers commonly use this statement, for example, to define manifest (named) constants in their source file, as in the following example:</p>&#13;
<pre id="pre-980"><code>#define pi 3.14159</code></pre>&#13;
<p class="TX">In an assembly language program, you would normally use the <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.set</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> directives to define named constants, as in the following example:</p>&#13;
<pre id="pre-981"><code>maxCnt = 10</code></pre>&#13;
<p class="TX">However, various bugs in Gas might not allow you to use these constants the way you like. Consider the following:</p>&#13;
<pre id="pre-982"><code>pi = 3.14159&#13;
    .&#13;
    .&#13;
    .&#13;
   .double pi</code></pre>&#13;
<p class="TX">If you try to assemble this, Gas will complain that <span class="SANS_TheSansMonoCd_W5Regular_11">3.14159</span> is not a valid constant and that <span class="SANS_TheSansMonoCd_W5Regular_11">pi</span> is not a valid floating-point constant. (The Clang assembler under macOS will accept <span class="SANS_TheSansMonoCd_W5Regular_11">pi = 3.14159</span> but will still complain that <span class="SANS_TheSansMonoCd_W5Regular_11">pi</span> is not a valid floating-point constant.) However, if you replace this with</p>&#13;
<pre id="pre-983"><code>#define pi 3.14159&#13;
   .&#13;
   .&#13;
   .&#13;
   .double pi</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_745" aria-label="745"/>then Gas will assemble the code just fine because CPP will preprocess the source file and replace each occurrence of <span class="SANS_TheSansMonoCd_W5Regular_11">pi</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">3.14159</span>. Therefore, when Gas actually sees the source file, it will find</p>&#13;
<pre id="pre-984"><code>   .double 3.14159</code></pre>&#13;
<p class="Continued1">which is perfectly acceptable. This is a good example of why it helps to use CPP in your Gas source files: it provides you with capabilities, such as real constant definitions, that you wouldn’t normally have with Gas alone.</p>&#13;
<p class="TX">Because CPP does a textual replacement of the defined identifier wherever it finds that identifier (outside of a string or character constant), you’re not limited to using <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> for numeric constants. You can supply character constants, string constants, or even arbitrary text (including nothing) after the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span>:</p>&#13;
<pre id="pre-985"><code>#define hw "Hello, World!"</code></pre>&#13;
<p class="TX">You could even do something like the following if you really prefer the <span class="SANS_TheSansMonoCd_W5Regular_11">xor</span> mnemonic over the <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> mnemonic:</p>&#13;
<pre id="pre-986"><code>#define xor eor&#13;
   .&#13;
   .&#13;
   .&#13;
  xor x1, x0, x2</code></pre>&#13;
<p class="TX">Although redefining instruction mnemonics like this is generally considered poor programming practice, ARM does it all over the place with its “instruction aliases.” If it’s good enough for the ARM, there is no reason you can’t do it if it makes your code more readable to you.</p>&#13;
<p class="TX">Another important use of the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement is to create symbols that the CPP can recognize. The CPP is blissfully unaware of all identifiers appearing in your source file, except those you create with the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement. As you’ll see starting in the next section, you’ll sometimes want to use various expressions in a CPP CTL statement involving named constants. Those named constants must be defined with the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement, not one of Gas’s equate directives.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-245"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.2.3 CPP Compile-Time Expressions</span></h4>&#13;
<p class="TNI1">Certain CPP statements allow simple arithmetic expressions involving constants. The arithmetic operators are the usual C arithmetic operators, including these:</p>&#13;
<pre id="pre-987"><code>+  -  *  /  %  == != &lt;  &lt;=  &gt;  &gt;=  !  ~  &amp;&amp; ||  &amp;  | &lt;&lt; &gt;&gt;</code></pre>&#13;
<p class="TX">Note that CPP supports only (signed) 64-bit integer and character expressions and will report an error if you attempt to use floating-point or <span role="doc-pagebreak" epub:type="pagebreak" id="pg_746" aria-label="746"/>string constants. You can use a named constant in a CPP CTL expression as long as you’ve previously declared that name with a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement.</p>&#13;
<p class="TX">You can use the following CPP built-in function in CPP CTL expressions:</p>&#13;
<pre id="pre-988"><code>defined(<var>identifier</var>)</code></pre>&#13;
<p class="TX">This function returns 1 if the identifier was previously defined in a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement; it returns 0 if no such definition exists (note that you can also use the GCC <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier=value</span> command line option to define symbols). The <span class="SANS_TheSansMonoCd_W5Regular_11">defined()</span> function recognizes only symbols defined in a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement, a good example of the “important use” mentioned in the preceding section. If you pass a normal Gas assembly language identifier here, the function will return 0 even if the definition occurred earlier in the source file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-246"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.2.4 Conditional Assembly</span></h4>&#13;
<p class="TNI1">The CPP provides several statements that allow you to make decisions when processing the source file. Here are those directives:</p>&#13;
<pre id="pre-989"><code>#if <var>expression</var>&#13;
 .&#13;
 .&#13;
 .&#13;
#elif <var>expression</var>  // This is optional and may appear multiple times.&#13;
 .&#13;
 .&#13;
 .&#13;
#else             // This is optional.&#13;
 .&#13;
 .&#13;
 .&#13;
#endif&#13;
&#13;
#ifdef<var> identifier</var>&#13;
 .&#13;
 .&#13;
 .&#13;
#else             // This is optional.&#13;
 .&#13;
 .&#13;
 .&#13;
#endif&#13;
&#13;
#ifndef <var>identifier</var>&#13;
 .&#13;
  .&#13;
 .&#13;
#else             // This is optional.&#13;
 .&#13;
 .&#13;
 .&#13;
#endif</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_747" aria-label="747"/>During preprocessing, CPP will evaluate <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span>. If it yields a nonzero value (true), the <span class="SANS_TheSansMonoCd_W5Regular_11">#if</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">#elif</span> (else if) statements will process the text up to the next <span class="SANS_TheSansMonoCd_W5Regular_11">#elif</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">#else</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> statement.</p>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> evaluates to false, CPP will skip over the following text (up to the next <span class="SANS_TheSansMonoCd_W5Regular_11">#elif</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">#else</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> statement) and will not write that text to the temporary output file. Therefore, Gas will not assemble that text during the assembly phase.</p>&#13;
<p class="TX">Remember that this conditional processing happens during preprocessing (assembly), not at runtime. This is not a generic <span class="SANS_TheSansMonoCd_W5Regular_11">if</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">then</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">elseif</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">else</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">endif</span> statement you’d find in an HLL. The conditional compilation statements control whether the instructions will actually appear in the final object code, activity that should be familiar to anyone who has used conditional compilation in an HLL such as C/C++.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> statement is equivalent to the following:</p>&#13;
<pre id="pre-990"><code>#if defined(<var>identifier</var>)&#13;
 .&#13;
 .&#13;
 .&#13;
#endif</code></pre>&#13;
<p class="TX">The CPP checks the identifier to see whether it was previously defined with a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement (or the <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span> command line option). If so, CPP processes the text after the <span class="SANS_TheSansMonoCd_W5Regular_11">#if</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span>) and up to the <span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> (or up to an <span class="SANS_TheSansMonoCd_W5Regular_11">#elif</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">#else</span> statement, if present).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span> (if not defined) statement is equivalent to this:</p>&#13;
<pre id="pre-991"><code>#if !defined(<var>identifier</var>)&#13;
 .&#13;
 .&#13;
 .&#13;
#endif</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span> statements are common in code that is written for different execution environments. Consider the following example:</p>&#13;
<pre id="pre-992"><code>#ifdef isMacOS&#13;
&#13;
    <var>Code written for macOS</var>&#13;
&#13;
#else&#13;
&#13;
    <var>Assume the code was written for Linux or Pi OS.</var>&#13;
&#13;
#endif</code></pre>&#13;
<p class="TX">Prior to this point, if the following statement appeared, then the former code would compile the section for macOS:</p>&#13;
<pre id="pre-993"><code>#define isMacOS</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_748" aria-label="748"/>Had this definition not appeared, the code would compile the Linux or Pi OS code.</p>&#13;
<p class="TX">Another common use of conditional assembly is to introduce debugging and testing code into your programs. As a typical debugging technique, many Gas programmers insert print statements at strategic points, enabling them to trace through their code and display important values at various checkpoints. A big problem with this technique, however, is that they must remove the debugging code prior to completing the project. Moreover, programmers often forget to remove some debugging statements, creating defects in the final program. Finally, after removing a debugging statement, these programmers often discover that they need that same statement to debug a different problem at a later time. Hence, they must constantly insert and remove the same statements over and over again.</p>&#13;
<p class="TX">Conditional assembly provides a solution to this problem. By defining a symbol (say, <span class="SANS_TheSansMonoCd_W5Regular_11">debug</span>) to control debugging output in your program, you can activate or deactivate <i>all</i> debugging output by modifying a single line of source code, as the following code fragment demonstrates:</p>&#13;
<pre id="pre-994"><code>// Uncomment to activate debug output or -D debug on the command line.&#13;
&#13;
// #define debug&#13;
      .&#13;
      .&#13;
      .&#13;
     #ifdef debug&#13;
&#13;
        #warning *** DEBUG build&#13;
&#13;
        mov  x1, [fp, #i]&#13;
        mstr x1, [sp]&#13;
        lea  x0, debugMsg&#13;
        bl   printf&#13;
&#13;
     #else&#13;
&#13;
        #warning *** RELEASE build&#13;
&#13;
     #endif</code></pre>&#13;
<p class="TX">As long as you surround all debugging output statements with an <span class="SANS_TheSansMonoCd_W5Regular_11">#if</span> statement like the one in the preceding code, you don’t have to worry about debugging output accidentally appearing in your final application. Commenting out the debug symbol definition will automatically disable all such output (or, better yet, just use the <span class="SANS_TheSansMonoCd_W5Regular_11">-D debug</span> command line option to turn on output when you want it). Likewise, you can leave the debugging statements from your programs in your code even after they’ve served their immediate purpose, since conditional assembly makes them easy to deactivate. Later, if you decide you need to view this same debugging information during assembly, you can reactivate it by defining the debug symbol.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_749" aria-label="749"/>&#13;
<h4 class="H2" id="sec7"><span id="h2-247"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.2.5 CPP Macros</span></h4>&#13;
<p class="TNI1">Previously, this chapter used the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement to define compile-time constants, a special case of a <i>macro definition</i>. This section describes CPP macro definitions and expansion in more depth, including a discussion of macro parameters, variable argument lists, and other CPP macro definition features. By using this information, you will be able to create and use CPP macros in your Gas assembly language source files.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.1 Functional Macros</span></h5>&#13;
<p class="TNI1">A macro is a mechanism that CPP uses to replace an identifier with arbitrary text. When defining constants with <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span>, you’re telling CPP to replace every following occurrence of that identifier with the text, which happens to be the constant.</p>&#13;
<p class="TX">However, CPP provides a second type of macro, the <i>functional macro</i>, which behaves more like a (compile-time) function supporting an arbitrary number of arguments. The following example demonstrates a single-argument macro:</p>&#13;
<pre id="pre-995"><code>#define lcl(arg1)  [fp, #arg1]&#13;
   .&#13;
   .&#13;
   .&#13;
  ldr w0, lcl(varName)</code></pre>&#13;
<p class="TX">This last statement expands to</p>&#13;
<pre id="pre-996"><code>  ldr w0, [fp, #varName]</code></pre>&#13;
<p class="Continued1">because the macro <span class="SANS_TheSansMonoCd_W5Regular_11">lcl</span> expands to <span class="SANS_TheSansMonoCd_W5Regular_11">[fp, #varName]</span>. The CPP calls these <i>functional macros</i> because their invocation resembles a function call in the C programming language.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.2 CPP Macro Arguments</span></h5>&#13;
<p class="TNI1">Functional macros support an arbitrary number of arguments. You can specify zero arguments thusly</p>&#13;
<pre id="pre-997"><code>#define zeroArgs()  <var>text</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">zeroArgs()</span> will expand into the specified <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text</span>.</p>&#13;
<p class="TX">This is a difference between the following two macro declarations that manifests when you invoke them:</p>&#13;
<pre id="pre-998"><code>#define noArgs  <var>text1</var>&#13;
#define zeroArgs() <var>text2</var></code></pre>&#13;
<p class="Continued1">You invoke the first macro with <span class="SANS_TheSansMonoCd_W5Regular_11">noArgs</span> and the second macro with <span class="SANS_TheSansMonoCd_W5Regular_11">zeroArgs()</span>. If the macro declaration has an empty set of parentheses, the macro <span role="doc-pagebreak" epub:type="pagebreak" id="pg_750" aria-label="750"/>invocation must also include the empty parentheses. You can use this declaration scheme to differentiate between constant declarations and macro declarations.</p>&#13;
<p class="TX">You can also specify two or more arguments in a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement:</p>&#13;
<pre id="pre-999"><code>#define twoArgs(arg1, arg2)  <var>text to expand</var></code></pre>&#13;
<p class="TX">The following is an example of a <span class="SANS_TheSansMonoCd_W5Regular_11">twoArgs()</span> invocation:</p>&#13;
<pre id="pre-1000"><code>mov w0, twoArgs(1, 2)</code></pre>&#13;
<p class="Continued1">When invoking <span class="SANS_TheSansMonoCd_W5Regular_11">twoArgs()</span>, you must supply exactly two parameters, or Gas will report an error. In general, the number of arguments you supply in a macro invocation must exactly match the parameter list in the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> declaration.</p>&#13;
<p class="TX">When CPP is processing a macro invocation, it usually separates actual parameters by scanning for commas. It ignores commas appearing in string or character constants, or in expressions surrounded by parentheses or square brackets:</p>&#13;
<pre id="pre-1001"><code>  singleArg("Strings can contain commas, that's okay!")&#13;
  singleArg(',')    // Also okay&#13;
  singleArg((1,2))  // (1,2) is a single argument.</code></pre>&#13;
<p class="TX">From CPP’s perspective, each of these macro invocations has a single argument.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.3 Macro Argument Expansion Issues</span></h5>&#13;
<p class="TNI1">As any experienced C programmer knows, you must be careful when specifying macro parameters to avoid unintended consequences during expansion, especially if they involve arithmetic expressions. Consider the following macro:</p>&#13;
<pre id="pre-1002"><code>#define reserve(amt)  amt + 1</code></pre>&#13;
<p class="TX">Now consider the following macro invocation:</p>&#13;
<pre id="pre-1003"><code>.space  reserve(Size) * 2  // Size is a constant.</code></pre>&#13;
<p class="Continued1">The expectation here is to reserve twice as much space as the <span class="SANS_TheSansMonoCd_W5Regular_11">reserve()</span> macro would normally specify. However, consider the actual expansion of this macro:</p>&#13;
<pre id="pre-1004"><code>.space  Size + 1 * 2</code></pre>&#13;
<p class="TX">Gas’s arithmetic rules specify that multiplication has a higher precedence than addition, so this expands to <span class="SANS_TheSansMonoCd_W5Regular_11">Size</span> + 2 rather than (<span class="SANS_TheSansMonoCd_W5Regular_11">Size</span> + 1) × 2, the desired expansion. C programmers work around this issue by always <span role="doc-pagebreak" epub:type="pagebreak" id="pg_751" aria-label="751"/>surrounding macro expansions (that expand to arithmetic expressions) with parentheses, and they always surround the macro parameters themselves with parentheses, as shown in the following example:</p>&#13;
<pre id="pre-1005"><code>#define reserve(amt)  ((amt) + 1)</code></pre>&#13;
<p class="Continued1">This usually resolves the issue of a macro expansion in the middle of an arithmetic expression.</p>&#13;
<p class="TX">For the same reason, it’s generally a good idea to enclose any expression you pass as a macro argument in parentheses:</p>&#13;
<pre id="pre-1006"><code>.space  reserve((Size + 5)) * 2</code></pre>&#13;
<p class="Continued1">Because the expansion could produce unintended consequences based on operator precedence (for example, suppose the <span class="SANS_TheSansMonoCd_W5Regular_11">reserve</span> definition were <span class="SANS_TheSansMonoCd_W5Regular_11">amt * 2</span>, which would expand to <span class="SANS_TheSansMonoCd_W5Regular_11">Size + 5 * 2</span> if you didn’t surround the actual parameter expression with parentheses).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.4 Variable Argument Lists</span></h5>&#13;
<p class="TNI1">CPP provides a mechanism for specifying a variable number of parameters:</p>&#13;
<pre id="pre-1007"><code>#define varArgs(...)  <var>text to expand</var></code></pre>&#13;
<p class="TX">To reference the arguments, use the predefined <span class="SANS_TheSansMonoCd_W5Regular_11">__VA_ARGS__</span> symbol (which begins and ends with two underscores). The CPP will substitute the entire set of arguments in place of <span class="SANS_TheSansMonoCd_W5Regular_11">__VA_ARGS__</span>. <i>This includes all the commas appearing in the varying argument list</i>. Consider the following macro definition and invocation:</p>&#13;
<pre id="pre-1008"><code>#define bytes(...) __VA_ARGS__&#13;
   .&#13;
   .&#13;
   .&#13;
  .byte bytes(1, 2, 3, 4)</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> statement expands to the following:</p>&#13;
<pre id="pre-1009"><code>.byte 1, 2, 3, 4</code></pre>&#13;
<p class="TX">A varying argument list allows zero actual parameters, so the invocation <span class="SANS_TheSansMonoCd_W5Regular_11">bytes()</span> is perfectly legal (and will expand to the empty string, given the previous definition). Therefore</p>&#13;
<pre id="pre-1010"><code>.byte bytes()</code></pre>&#13;
<p class="Continued1">will expand to</p>&#13;
<pre id="pre-1011"><code>.byte</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_752" aria-label="752"/>which, interestingly enough, will not produce an error (Gas does not generate any code for this statement).</p>&#13;
<p class="TX">Although the expansion of the entire argument list is sometimes useful, you’ll much more often need to pick off individual arguments in the varying argument list, as discussed in the following two sections.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.5 Macro Composition and Recursive Macros</span></h5>&#13;
<p class="TNI1">CPP does not support recursive macro invocations. If a macro’s name appears in the expansion text, CPP will simply emit that name as text to be assembled by Gas. This is unfortunate because recursion would be very useful for handling iteration, as CPP doesn’t provide any looping constructs. In section 13.2.5.9, <span class="Xref">“Iteration with Macros,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_757">page 757</a></span>, I’ll provide a workaround; in the meantime, I will discuss how CPP handles macro expansion when one macro invokes another.</p>&#13;
<p class="TX">Consider the following macro definitions and invocations:</p>&#13;
<pre id="pre-1012"><code>#define inc(x) ((x)+1)&#13;
#define mult(y) ((y)*2)&#13;
   .&#13;
   .&#13;
   .&#13;
  .byte mult(inc(5))</code></pre>&#13;
<p class="TX">When CPP encounters a macro invocation within the parameter list of another macro invocation, it will expand the parameter before passing that text on to the enclosing macro invocation. The expansion of the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> statement happens in two steps:</p>&#13;
<pre id="pre-1013"><code>.byte mult(((5) + 1))  // First step</code></pre>&#13;
<p class="Continued1">and then</p>&#13;
<pre id="pre-1014"><code>.byte (((5) + 1) * 2)   // Second step</code></pre>&#13;
<p class="Continued1">which, of course, is equal to:</p>&#13;
<pre id="pre-1015"><code>.byte 12</code></pre>&#13;
<p class="TX">Now consider the following example:</p>&#13;
<pre id="pre-1016"><code>#define calledMacro(x) mov w0, x&#13;
#define callingMacro(y) calledMacro(y)&#13;
   .&#13;
   .&#13;
   .&#13;
  callingMacro(5)</code></pre>&#13;
<p class="TX">When CPP encounters the macro invocation at the end of this example, it will expand <span class="SANS_TheSansMonoCd_W5Regular_11">callingMacro(5)</span> to the following text:</p>&#13;
<pre id="pre-1017"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_753" aria-label="753"/>  calledMacro(5)</code></pre>&#13;
<p class="TX">CPP will then expand this macro to the following:</p>&#13;
<pre id="pre-1018"><code>  mov w0, 5</code></pre>&#13;
<p class="Continued1">As long as CPP continues to find a macro invocation in the expanded text (except for a recursive invocation), it will continue to expand those invocations, regardless of how many iterations this process requires.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">#define calledMacro(x) mov w0, x</span> <i>macro should really be</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">#define calledMacro(x) mov w0, #x</span> <i>using the syntax presented thus far in this book. However, the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">#</span> <i>is a CPP operator (stringify, described a little later) that will turn the actual parameter</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">5</span> <i>into the string</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">"5"</span><i>. Fortunately, Gas accepts a plain constant in place of</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_11">constant</span> <i>for the immediate addressing mode in this example.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.6 Macro Definition Limitations</span></h5>&#13;
<p class="TNI1">The syntax for a CPP macro is the following</p>&#13;
<pre id="pre-1019"><code>#define identifier(<var>parameters)</var> <var>text to expand</var> \n</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">parameters</span>) is optional and <span class="SANS_TheSansMonoCd_W5Regular_11">\n</span> represents a newline character. CPP does not allow any newline characters within <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text to expand</span>. Therefore, a macro can expand only to a single line of text.</p>&#13;
<p class="TX">CPP does allow macro definitions like the following</p>&#13;
<pre id="pre-1020"><code>#define multipleLines(parms) <var>text1</var> \&#13;
                             <var>text2</var> \&#13;
                              .&#13;
                              .&#13;
                              .&#13;
                             <var>textn</var></code></pre>&#13;
<p class="Continued1">which spreads a macro definition across <i>n</i> lines in the source file. Each line, except the last, must be terminated with a backslash character (<span class="SANS_TheSansMonoCd_W5Regular_11">\</span>) immediately followed by a newline character.</p>&#13;
<p class="TX">Although this macro is physically split across multiple source lines, it is still a single line of text because the CPP will delete all the newline characters following the backslash characters. Therefore, you cannot create a macro like the following:</p>&#13;
<pre id="pre-1021"><code>#define printi(i)        \&#13;
        lea   x0, iFmtStr  \&#13;
        lea   x1, i        \&#13;
        ldr   x1, [x1]     \&#13;
        mstr  x1, [sp]     \&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_754" aria-label="754"/>        bl    printf&#13;
         .&#13;
         .&#13;
         .&#13;
        printi(var)</code></pre>&#13;
<p class="TX">This macro definition won’t work because CPP will expand all the assembly language statements on a single line (with spaces between them), generating a syntax error. Sadly, Gas doesn’t seem to provide a general mechanism for supplying multiple assembly statements on the same line. Therefore, you cannot use CPP macros that expand to multiple assembly language statements. (Fortunately, Gas macros do allow this, as you’ll learn in section 13.3.4, <span class="Xref">“Gas Macros,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_765">page 765</a></span>.)</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>On some CPUs, Gas allows the use of the semicolon (</i><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">;</span><i>) character to put multiple statements on the same line. However, the ARM treats semicolons as line comment characters; one semicolon is equivalent to two forward slashes (</i><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">//</span><i>). Your mileage may vary with Gas; for example, under Pi OS you can use the semicolon as a statement separator.</i></p>&#13;
<p class="TX">CPP’s single-line macro definitions have another serious drawback: you cannot incorporate CPP’s conditional compilation statements (such as <span class="SANS_TheSansMonoCd_W5Regular_11">#if</span>) into a macro, since the conditional compilation statements must appear at the beginning of a source line. This is unfortunate, as the ability to make decisions in a macro would be useful. Fortunately, there are a couple of workarounds.</p>&#13;
<p class="TX">First, you can put macro definitions within conditional compilation sequences, as shown in the following example:</p>&#13;
<pre id="pre-1022"><code>#ifdef isMacOS&#13;
#define someMacro<var> text to expand if macOS</var>&#13;
#else&#13;
#define someMacro <var>text to expand if not macOS</var>&#13;
#endif</code></pre>&#13;
<p class="Continued1">This sequence has two macros, only one of which will be defined within a given assembly. You can therefore put the (presumably) macOS-only code in the first macro definition and the Linux code in the second definition.</p>&#13;
<p class="TX">Using two separate macro definitions like this will work in some, but not all, instances; sometimes you really do need the ability to put conditional text within a macro expansion. I’ll provide a second workaround to address this need in section 13.2.5.8, <span class="Xref">“Conditional Macros,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_756">page 756</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.7 Text Concatenation and the Stringify Operator</span></h5>&#13;
<p class="TNI1">CPP provides two special operators for manipulating textual data: the concatenation operator and the stringify operator. This section describes those two operators.</p>&#13;
<p class="TX">A <i>token</i> is an entity, such as an identifier or operator, recognized by the C/C++ language. The CPP <i>concatenation operator</i> (<span class="SANS_TheSansMonoCd_W5Regular_11">##</span>) combines two tokens in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_755" aria-label="755"/>a macro, forming a single token. For example, within a macro body, the following text produces the single token <span class="SANS_TheSansMonoCd_W5Regular_11">identifier</span>:</p>&#13;
<pre id="pre-1023"><code>ident ## ifier</code></pre>&#13;
<p class="TX">Any amount of whitespace may appear between the tokens and the <span class="SANS_TheSansMonoCd_W5Regular_11">##</span> operator. CPP will remove all the whitespace and join the two tokens together—as long as the result is a legal C/C++ token. If a macro parameter identifier appears on either side of the <span class="SANS_TheSansMonoCd_W5Regular_11">##</span> operator, CPP will expand that parameter to the actual parameter’s text before doing the concatenation. Alas, if you pass another macro as the parameter, CPP does not properly expand the parameter:</p>&#13;
<pre id="pre-1024"><code>#define one 1&#13;
#define _e  e&#13;
#define produceOne(x) on ## x&#13;
   .&#13;
   .&#13;
   .&#13;
  produceOne(_e)  // Expands to on_e</code></pre>&#13;
<p class="TX">As a sneaky workaround to this problem, you can create a concatenation macro to create the identifier for later expansion:</p>&#13;
<pre id="pre-1025"><code>#define produceOne  1&#13;
#define concat(x, y) x ## y&#13;
&#13;
    mov w0, #concat(produce, One)</code></pre>&#13;
<p class="Continued1">This will generate the statement</p>&#13;
<pre id="pre-1026"><code>mov w0, #produceOne</code></pre>&#13;
<p class="Continued1">which then expands to this:</p>&#13;
<pre id="pre-1027"><code>mov w0, #1</code></pre>&#13;
<p class="TX">Section 13.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_792">page 792</a></span> includes links to sites that describe CPP’s text concatenation operator more fully.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The concatenation operator is legal only within a CPP macro. The CPP will ignore</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">##</span> <i>everywhere else in the source file, leaving it up to Gas to handle it (which generally produces an error, as</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">##</span> <i>is not a legal token in ARM assembly language).</i></p>&#13;
<p class="TX">The second CPP operator is the <i>stringify operator</i> (<span class="SANS_TheSansMonoCd_W5Regular_11">#</span>), which you can use within a macro body as follows</p>&#13;
<pre id="pre-1028"><code># <var>parmID</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">parmID</span> is the name of one of the macro parameters. The stringify operator will expand the parameter and convert it to a string by surrounding <span role="doc-pagebreak" epub:type="pagebreak" id="pg_756" aria-label="756"/>the text with quotes. This is why the earlier <span class="SANS_TheSansMonoCd_W5Regular_11">#define calledMacro(x) mov w0, #x</span> macro did not work properly—it stringified the argument rather than leaving it as an integer constant.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.8 Conditional Macros</span></h5>&#13;
<p class="TNI1">Although you cannot include conditional compilation directives (<span class="SANS_TheSansMonoCd_W5Regular_11">#if</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">#else</span>, and so on) inside macro bodies, it is possible to create conditional macros by pulling some tricks with the CPP (otherwise known as <i>abusing CPP</i>). Here’s an example of a conditional macro that implements an if ... then macro expansion you can use to select a particular expansion based on other definitions in your source code:</p>&#13;
<pre id="pre-1029"><code>if_else(<var>expression</var>) (<var>true expansion</var>) (<var>false expansion</var>)</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">true expansion</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">false expansion</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> are compile-time expressions. The <span class="SANS_TheSansMonoCd_W5Regular_11">if_else</span> macro will evaluate <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span>; if it evaluates to a nonzero value, this statement will be replaced by <span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">true expansion</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span>. If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> evaluates to false, this statement will be replaced by <span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">false expression</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span>. Here’s a simple example:</p>&#13;
<pre id="pre-1030"><code>.asciz if_else(MacOS) ("macOS") ("LinuxOS")</code></pre>&#13;
<p class="Continued1">If <span class="SANS_TheSansMonoCd_W5Regular_11">MacOS</span> is nonzero, this produces the string <span class="SANS_TheSansMonoCd_W5Regular_11">"macOS"</span>; otherwise, it produces the string <span class="SANS_TheSansMonoCd_W5Regular_11">"LinuxOS"</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">if_else</span> macro is quite complex, and I won’t describe how it works here; it is C rather than assembly language, which puts it beyond the scope of this text. See section 13.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_792">page 792</a></span> for resources on this topic. Here’s the implementation of <span class="SANS_TheSansMonoCd_W5Regular_11">if_else</span> from one of those resources, by Jonathan Heathcote:</p>&#13;
<pre id="pre-1031"><code>#define _secondArg_(a, b, ...) b&#13;
&#13;
#define _is_probe_(...) _secondArg_(__VA_ARGS__, 0)&#13;
#define _probe_() ~, 1&#13;
&#13;
#define _cat_(a, b) a ## b&#13;
&#13;
#define _not_(x) _is_probe_(_cat_(_not_, x))&#13;
#define _not_0 _probe_()&#13;
&#13;
#define _bool_(x) _not_(_not_(x))&#13;
&#13;
#define if_else(condition) _if_else_(_bool_(condition))&#13;
#define _if_else_(condition) _cat_(_if_ , condition)&#13;
&#13;
#define _if_1(...) __VA_ARGS__ _if_1_else&#13;
#define _if_0(...)             _if_0_else&#13;
&#13;
#define _if_1_else(...)&#13;
#define _if_0_else(...) __VA_ARGS__</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_757" aria-label="757"/>Unlike the conditional compilation directives, you can embed the <span class="SANS_TheSansMonoCd_W5Regular_11">if_else</span> macro into the bodies of other macros. Consider the following code:</p>&#13;
<pre id="pre-1032"><code>#define macStr(x) if_else(x) ("macOS")("Linux")</code></pre>&#13;
<p class="Continued1">Invoking this macro yields the string <span class="SANS_TheSansMonoCd_W5Regular_11">"macOS"</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">"Linux"</span>, depending on the compile-time value of the parameter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.9 Iteration with Macros</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">__VA_ARGS__</span> feature in CPP is useful for passing a group of arguments as a single argument. However, it would be nicer if we could process each argument in a varying parameter list one at a time by iterating through the list in order. Unfortunately, the CPP doesn’t provide any statements to support iteration. Because CPP doesn’t support recursion, we can’t even (directly) use recursion to handle iteration.</p>&#13;
<p class="TX">However, if you abuse the CPP a bit, a limited form of recursion is possible, as this section demonstrates. The ultimate goal of this section is to create a macro, let’s call it <span class="SANS_TheSansMonoCd_W5Regular_11">map</span>, that will execute a single-argument macro on each argument in a varying parameter list. Ideally, you’d call <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> thusly</p>&#13;
<pre id="pre-1033"><code>map(<var>macroName</var>, <var>arg1</var>, <var>arg2</var>, ..., <var>argn</var>)</code></pre>&#13;
<p class="Continued1">and the map function would generate <i>n</i> calls to <span class="SANS_TheSansMonoCd_W5Regular_11">macroName</span>:</p>&#13;
<pre id="pre-1034"><code>  <var>macroName</var>(<var>arg1</var>)&#13;
  <var>macroName</var>(<var>arg2</var>)&#13;
   .&#13;
   .&#13;
   .&#13;
  <var>macroName</var>(<var>argn)</var></code></pre>&#13;
<p class="TX">The following set of macros, along with the <span class="SANS_TheSansMonoCd_W5Regular_11">if_else</span> macro from the previous section, provides this functionality (also from Heathcote; see section 13.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_792">page 792</a></span> for implementation details):</p>&#13;
<pre id="pre-1035"><code>// Include the macro definitions for if_else from&#13;
// the previous section here.&#13;
&#13;
#define _firstArg_(a, ...) a&#13;
&#13;
#define _empty_()&#13;
&#13;
#define eval(...) eval1024(__VA_ARGS__)&#13;
#define eval1024(...) eval512(eval512(__VA_ARGS__))&#13;
#define eval512(...) eval256(eval256(__VA_ARGS__))&#13;
#define eval256(...) eval128(eval128(__VA_ARGS__))&#13;
#define eval128(...) eval64(eval64(__VA_ARGS__))&#13;
#define eval64(...) eval32(eval32(__VA_ARGS__))&#13;
#define eval32(...) eval16(eval16(__VA_ARGS__))&#13;
#define eval16(...) eval8(eval8(__VA_ARGS__))&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_758" aria-label="758"/>#define eval8(...) eval4(eval4(__VA_ARGS__))&#13;
#define eval4(...) eval2(eval2(__VA_ARGS__))&#13;
#define eval2(...) eval1(eval1(__VA_ARGS__))&#13;
#define eval1(...) __VA_ARGS__&#13;
&#13;
#define _defer1(m) m _empty_()&#13;
#define _defer2(m) m _empty_ _empty_()()&#13;
#define _defer3(m) m _empty_ _empty_ _empty_()()()&#13;
#define _defer4(m) m _empty_ _empty_ _empty_ _empty_()()()()&#13;
&#13;
#define _has_args(...) _bool_(_firstArg_(_end_of_args __VA_ARGS__)())&#13;
#define _end_of_args() 0&#13;
&#13;
#define map(m, _firstArg_, ...)       \&#13;
  m(_firstArg_)                       \&#13;
  if_else(_has_args(__VA_ARGS__))(    \&#13;
    _defer2(_map)()(m, __VA_ARGS__) \&#13;
  )(                                    \&#13;
    /* Do nothing, just terminate */    \&#13;
  )&#13;
#define _map() map</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">eval</span> macro provides a limited amount of recursion on the macro you pass as an argument (up to 1,024 levels of recursion, which will allow for a varying parameter listing containing up to 1,024 entries). In order for the <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> macro to recurse, you must enclose it in an <span class="SANS_TheSansMonoCd_W5Regular_11">eval</span> invocation. Consider the following example:</p>&#13;
<pre id="pre-1036"><code>#define inc(x) (x+1),&#13;
     .&#13;
     .&#13;
     .&#13;
    .byte eval(map(inc, 1, 2, 3, 4, 5, 6, 7)) 9</code></pre>&#13;
<p class="TX">The comma at the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">inc</span> macro is required because the invocations of <span class="SANS_TheSansMonoCd_W5Regular_11">inc</span> will emit expressions of the form (1 + 1), (2 + 1), ..., (7 + 1) on the same line. The <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> directive requires commas between these expressions.</p>&#13;
<p class="TX">Also note that the value <span class="SANS_TheSansMonoCd_W5Regular_11">9</span> appears after the <span class="SANS_TheSansMonoCd_W5Regular_11">eval</span> invocation. This is because the last expression, <span class="SANS_TheSansMonoCd_W5Regular_11">(7 + 1)</span>, will have a comma after it, so this statement must supply the last value manually. It would be possible to modify the <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> macro to emit this comma for all but the last argument, or you could modify the <span class="SANS_TheSansMonoCd_W5Regular_11">inc</span> macro to check for a special sentinel value (such as a negative number) to terminate the list (without emitting the value or the comma).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.10 Command Line Defines</span></h5>&#13;
<p class="TNI1">If you look back at the <i>build</i> shell script in section 1.10.1, <span class="Xref">“Assembling Programs Under Multiple OSes,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_36">page 36</a></span>, you’ll see that GCC has a command line parameter that specifies the OS in use:</p>&#13;
<pre id="pre-1037"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_759" aria-label="759"/>-D isLinux=1    (for Linux and Pi OS)&#13;
-D isMacOS=1    (for macOS)</code></pre>&#13;
<p class="TX">These command line parameters are roughly equivalent to the following two statements:</p>&#13;
<pre id="pre-1038"><code>#define isLinux 1&#13;
#define isMacOS 1</code></pre>&#13;
<p class="Continued1">In many instances, you can refer to these definitions in your source file exactly as though you had placed these <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements at the beginning of the file.</p>&#13;
<p class="TX">As noted, these parameters are <i>roughly</i> equivalent—not exactly equivalent—to the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements. Within macro bodies, these symbols might not be expanded as normal defined symbols would be. To use these symbols in macro bodies, it’s generally a good idea to explicitly create some <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> symbols by using code such as the following, then refer to <span class="SANS_TheSansMonoCd_W5Regular_11">myIsLinux</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">myIsMacOS</span> within your macros:</p>&#13;
<pre id="pre-1039"><code>#ifdef isLinux&#13;
  #define myIsLinux 1&#13;
  #define myIsMacOS 0&#13;
#else&#13;
  #define myIsLinux 0&#13;
  #define myIsMacOS 1&#13;
#endif</code></pre>&#13;
<p class="TX">If you are compiling your Gas source files directly from the command line via <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span>, you can define other symbols by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span> command line option. See the GCC documentation for details. Note that the <i>build</i> script will not pass <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span> arguments to GCC, but you can easily modify <i>build</i> if you want to define other symbols.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.2.5.11 The CPP #undef Statement</span></h5>&#13;
<p class="TNI1">The CPP allows you to forget a defined symbol by using the <span class="SANS_TheSansMonoCd_W5Regular_11">#undef</span> statement</p>&#13;
<pre id="pre-1040"><code>#undef <var>identifier</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier</span> is a symbol previously defined with a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement. (If the symbol is undefined upon <span class="SANS_TheSansMonoCd_W5Regular_11">#undef</span> execution, CPP will simply ignore the statement.)</p>&#13;
<p class="TX">Undefining a symbol allows you to redefine it (for example, to give it another value). If you attempt to redefine a symbol without first undefining it, CPP will report an error.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_760" aria-label="760"/>&#13;
<h3 class="H1" id="sec19"><span id="h1-139"/><span class="SANS_Futura_Std_Bold_B_11">13.3 Components of the Gas CTL</span></h3>&#13;
<p class="TNI1">Gas’s CTL facilities are closer (than CPP) to what most assembly language programmers expect from a macro expansion system. Although CPP’s macro facilities are useful for certain purposes, macro assembly programming generally requires a much more powerful macro system. Therefore, learning Gas’s macro facilities is essential. This section covers the components of the Gas CTL.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-248"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.3.1 Errors and Warnings During Assembly</span></h4>&#13;
<p class="TNI1">The Gas <span class="SANS_TheSansMonoCd_W5Regular_11">.err</span> directive is similar to CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#error</span>. During assembly, Gas will display an error message (printing the source line containing the <span class="SANS_TheSansMonoCd_W5Regular_11">.err</span> statement). Gas will not generate an object file if it encounters an <span class="SANS_TheSansMonoCd_W5Regular_11">.err</span> directive. For example, the following generates an error message at runtime:</p>&#13;
<pre id="pre-1041"><code>.err</code></pre>&#13;
<p class="TX">Gas also supports the <span class="SANS_TheSansMonoCd_W5Regular_11">.error</span> directive. Its syntax is shown here:</p>&#13;
<pre id="pre-1042"><code>.error "<var>String error message</var>"</code></pre>&#13;
<p class="TX">The operand must be a string constant surrounded by quotes. During assembly, Gas will display the specified error message and will not generate an object file if it encounters an <span class="SANS_TheSansMonoCd_W5Regular_11">.error</span> directive in the source file.</p>&#13;
<p class="TX">Gas also supports a <span class="SANS_TheSansMonoCd_W5Regular_11">.warning</span> directive similar to the CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#warning</span> statement, with the following syntax:</p>&#13;
<pre id="pre-1043"><code>.warning "<var>String warning message</var>"</code></pre>&#13;
<p class="TX">Again, the operand must be a string constant surrounded by quotes. If Gas encounters the <span class="SANS_TheSansMonoCd_W5Regular_11">.warning</span> directive during assembly, it will display the specified warning message. If no errors are in the source files, only warnings, Gas will generate an object file. You can therefore use the <span class="SANS_TheSansMonoCd_W5Regular_11">.warning</span> directive as an assembly-time print statement.</p>&#13;
<p class="TX">Keep in mind the difference between the CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#warning</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">#error</span> statements and the Gas <span class="SANS_TheSansMonoCd_W5Regular_11">.warning</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.error</span> directives: the CPP statements execute during the preprocessor pass, prior to the assembly process, while the Gas directives execute after the preprocessor pass, during assembly. If there are any <span class="SANS_TheSansMonoCd_W5Regular_11">#error</span> statements that execute, CPP will terminate the assembly process without running the assembler (so the Gas directives won’t execute in that situation).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-249"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.3.2 Conditional Assembly</span></h4>&#13;
<p class="TNI1">Gas also supports a set of conditional assembly (or conditional compilation) directives similar to CPP’s <span class="SANS_TheSansMonoCd_W5Regular_11">#if</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> statements. The basic directives are as follows:</p>&#13;
<pre id="pre-1044"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_761" aria-label="761"/>.if <var>expression1</var>&#13;
&#13;
  <var>Statements to assemble if expression is nonzero</var>&#13;
&#13;
.elseif <var>expression2</var>  // Optional, may appear multiple times&#13;
&#13;
  <var>Statements to assemble if expression2 is nonzero</var>&#13;
&#13;
.else  // Optional, but only one instance is legal&#13;
&#13;
  <var>Statements to assemble if expression1, expression2, ...</var>&#13;
  <var>and so on, were all 0</var>&#13;
&#13;
.endif</code></pre>&#13;
<p class="TX">As a general rule, you should prefer Gas’s conditional assembly directives in your source file over the CPP conditional compilation statements. Only use CPP’s conditional compilation statements when conditionally processing source code that contains other CPP statements (such as <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements), or testing whether a symbol has been defined in CPP with the <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span> statement. You cannot test whether a CPP symbol has been defined by using Gas’s conditional assembly statements because all CPP symbols will be expanded (and won’t be present) when Gas is assembling the source file.</p>&#13;
<p class="TX">The Boolean expression appearing after <span class="SANS_TheSansMonoCd_W5Regular_11">.if</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.elseif</span> must be an absolute expression (see <span class="Xref">“Relocatable and Absolute Expressions”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_176">page 176</a></span>). Within conditional assembly expressions, false is a zero result and true is anything else.</p>&#13;
<p class="TX">Gas supports several variants of the <span class="SANS_TheSansMonoCd_W5Regular_11">.if</span> directive:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifdef</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">symbol</span>    Assembles the following section if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">symbol</span> is defined prior to that point in the source file. CPP symbols (created with <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span>) are expanded prior to assembly, so their use may not work as expected in this directive.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifb</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">text</span>    Assembles the following section if the operand field is blank. You generally use this directive to test for a blank macro parameter (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text</span> is typically a macro parameter name that could expand to the empty string).</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifc</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">text1</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">text2</span>    Compares <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text1</span> to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text2</span> and assembles the following section if they are equal. The string comparison ignores any whitespace around the text. The string <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text1</span> comprises all characters from the first non-whitespace character after <span class="SANS_TheSansMonoCd_W5Regular_11">.ifc</span> up to the first comma. The string <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text2</span> is all text after the comma (ignoring leading whitespace) up to the end of the line (also ignoring whitespace at the end of the line). If you need to include whitespace in the string, you may optionally surround the strings with apostrophes (single quotes). Generally, you would use this statement to compare two macro parameter expansions to see if the parameters are equal.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_762" aria-label="762"/><span class="SANS_TheSansMonoCd_W7Bold_11">.ifeq</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">expression</span>    Assembles the following code if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is equal to 0.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifeqs "</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">string1</span><span class="SANS_TheSansMonoCd_W7Bold_11">"</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">"</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">string2</span><span class="SANS_TheSansMonoCd_W7Bold_11">"</span>    Assembles the following code if the two strings are equal. The strings must be surrounded by double quotes.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifge</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">expression</span>    Assembles the following code if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is greater than or equal to 0.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifgt</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">expression</span>    Assembles the following code if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is greater than 0.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifle</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">expression</span>    Assembles the following code if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is less than or equal to 0.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.iflt</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">expression</span>    Assembles the following code if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is less than 0.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifnb</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">text</span>    Assembles the following section if the operand field is not blank. You generally use this directive to test for a nonblank macro parameter (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text</span> is typically a macro parameter name).</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifnc</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">text1</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">text2</span>    Compares <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text1</span> to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text2</span> and assembles the following section if they are not equal. The string comparison ignores any whitespace around the text. The string <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text1</span> comprises all characters from the first non-whitespace character after <span class="SANS_TheSansMonoCd_W5Regular_11">.ifnc</span> up to the first comma. The string <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text2</span> is all text after the comma (ignoring leading whitespace) up to the end of the line (also ignoring whitespace at the end of the line). If you need to include whitespace in the string, you may optionally surround the strings with apostrophes (single quotes). Generally, you would use this statement to compare two macro parameter expansions to see if the parameters are not equal.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifndef</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">symbol</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">.ifnotdef</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">symbol</span>    Assembles the following section if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">symbol</span> is not defined prior to that point in the source file. Note that CPP symbols (created with <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span>) get expanded prior to assembly, so their use may not work as expected in this directive. The <span class="SANS_TheSansMonoCd_W5Regular_11">.ifnotdef</span> directive is a synonym for <span class="SANS_TheSansMonoCd_W5Regular_11">.ifndef</span>.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifne</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_11">expression</span>    Assembles the following code if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is not equal to 0. This directive is a synonym for <span class="SANS_TheSansMonoCd_W5Regular_11">.if</span>.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ifnes "</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">string1</span><span class="SANS_TheSansMonoCd_W7Bold_11">"</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">"</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">string2</span><span class="SANS_TheSansMonoCd_W7Bold_11">"</span>    Assembles the following code if the two strings are not equal. The strings must be surrounded by double quotes.</p>&#13;
</div>&#13;
<p class="TX">Conditional assembly statements in Gas may appear anywhere an instruction mnemonic is legal. Typically, they appear on a line by themselves, though it is legal (if unusual) for a label to appear on the same line. In that case, the label will be associated with the next instruction or directive that emits code.</p>&#13;
<p class="TX">As you can see, Gas provides a wide variety of conditional assembly statements that are quite a bit more powerful and flexible than the CPP conditional compilation statements. This is another reason to use Gas’s conditional assembly statements over CPP’s.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_763" aria-label="763"/>&#13;
<h4 class="H2" id="sec22"><span id="h2-250"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.3.3 Compile-Time Loops</span></h4>&#13;
<p class="TNI1">Unlike CPP, Gas’s CTL provides three looping constructs to easily generate data and unroll loops: <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.irpc</span>. The following subsections describe these directives.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.3.1 .rept....endr</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span> directive repeats a block of statements a fixed number of times. The syntax for this compile-time loop is the following:</p>&#13;
<pre id="pre-1045"><code>.rept <var>expression</var>&#13;
&#13;
  <var>Statements to repeat</var>&#13;
&#13;
.endr</code></pre>&#13;
<p class="TX">Gas will evaluate <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> and repeat the block of statements between the <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.endr</span> directives the specified number of times. If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> evaluates to 0, Gas will ignore all the statements up to the <span class="SANS_TheSansMonoCd_W5Regular_11">.endr</span>, generating no code.</p>&#13;
<p class="TX">The following example will initialize a 32-element byte array with the values 0 through 31:</p>&#13;
<pre id="pre-1046"><code>.set  i, 0     // Initialize array element value.&#13;
.rept 32&#13;
.byte i&#13;
.set  i, i + 1 // Increment array element value.&#13;
.endr</code></pre>&#13;
<p class="TX">You aren’t limited to data values in a <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span> loop but can use <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span> to unroll loops as well:</p>&#13;
<pre id="pre-1047"><code>// Zero out an eight-dword array:&#13;
&#13;
    .set  ofs, 0&#13;
    .rept 8&#13;
    str   xzr, [x0, #ofs]&#13;
    .set  ofs, ofs + 8&#13;
    .endr</code></pre>&#13;
<p class="Continued1">This is equivalent to the following code</p>&#13;
<pre id="pre-1048"><code>    str xzr, [x0, #0]&#13;
    str xzr, [x0, #8]&#13;
    str xzr, [x0, #16]&#13;
    str xzr, [x0, #24]&#13;
    str xzr, [x0, #32]&#13;
    str xzr, [x0, #40]&#13;
    str xzr, [x0, #48]&#13;
    str xzr, [x0, #56]</code></pre>&#13;
<p class="Continued1">which unrolls the loop eight times.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_764" aria-label="764"/>&#13;
<h5 class="H3" id="sec24"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.3.2 .irp....endr</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span> (indefinite repeat) looping directive takes the following form:</p>&#13;
<pre id="pre-1049"><code>.irp <var>identifier</var>, <var>comma-separated-list-of-values</var>&#13;
 .&#13;
 .&#13;
 .&#13;
.endr</code></pre>&#13;
<p class="TX">This loop repeats for each item in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">comma-separated-list-of-values</span>. In the body of the loop, you can refer to the current value by using <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">\identifier</span>; the following example</p>&#13;
<pre id="pre-1050"><code>.irp  i, 0, 1, 2, 3&#13;
.byte \i&#13;
.endr</code></pre>&#13;
<p class="Continued1">is equivalent to</p>&#13;
<pre id="pre-1051"><code>.byte 0&#13;
.byte 1&#13;
.byte 2&#13;
.byte 3</code></pre>&#13;
<p class="Continued1">which unrolls the loop for each <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span> argument.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h5 class="H3" id="sec25"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.3.3 .irpc....endr</span></h5>&#13;
<p class="TNI1">The third compile-time looping construct, <span class="SANS_TheSansMonoCd_W5Regular_11">.irpc</span>, is similar to <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span> but processes a string of text rather than a list of values:</p>&#13;
<pre id="pre-1052"><code>.irpc <var>identifier</var>, <var>text</var>&#13;
 .&#13;
 .&#13;
 .&#13;
.endr</code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier</span> is a symbol that will take on the value of each character in the string specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text</span>. Note that <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">text</span> is a bare sequence of characters; do not surround it by double or single quotes unless you want the <span class="SANS_TheSansMonoCd_W5Regular_11">.irpc</span> loop to process those punctuation marks along with the other characters in the string. The <span class="SANS_TheSansMonoCd_W5Regular_11">.irpc</span> loop will execute once for each character in the string, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">\identifier</span> will expand to that character on each iteration. For example</p>&#13;
<pre id="pre-1053"><code>.irpc x, acde&#13;
.byte '\x'&#13;
.endr</code></pre>&#13;
<p class="Continued1">expands to this:</p>&#13;
<pre id="pre-1054"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_765" aria-label="765"/>.byte 'a'&#13;
.byte 'c'&#13;
.byte 'd'&#13;
.byte 'e'</code></pre>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">\identifier</span> expands even within character and string constants (as <span class="SANS_TheSansMonoCd_W5Regular_11">'\x'</span> did in this example). In this example, had you not enclosed <span class="SANS_TheSansMonoCd_W5Regular_11">\x</span> in single quotes, the <span class="SANS_TheSansMonoCd_W5Regular_11">.irpc</span> loop would have expanded to</p>&#13;
<pre id="pre-1055"><code>.byte a&#13;
.byte c&#13;
.byte d&#13;
.byte e</code></pre>&#13;
<p class="Continued1">which would have generated an error if the symbols <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">c</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> were not defined somewhere in the program (I conveniently skipped <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, which would have expanded to a branch instruction mnemonic).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-251"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">13.3.4 Gas Macros</span></h4>&#13;
<p class="TNI1">Gas provides macro facilities via the <span class="SANS_TheSansMonoCd_W5Regular_11">.macro</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.endm</span> directives. The syntax for a macro definition is as follows</p>&#13;
<pre id="pre-1056"><code>.macro <var>identifier</var> {<var>parameter_list</var>}&#13;
&#13;
  <var>Statements to expand on macro invocation</var>&#13;
&#13;
.endm</code></pre>&#13;
<p class="Continued1">where the <span class="SANS_TheSansMonoCd_W5Regular_11">{</span>and} characters mean the parameter list is optional (you don’t include these characters in the macro definition). The following subsections describe the various components of a Gas macro, along with important semantic information concerning macros.</p>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3" id="sec27"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.4.1 Macro Parameters</span></h5>&#13;
<p class="TNI1">Macro parameters can take one of the following four forms:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">identifier</span>    This first form, just a simple identifier, is the most common. Unless you supply one of the suffixes appearing in the other three options, this syntax tells Gas that the parameter is optional. If you do not supply an appropriate actual parameter value when invoking the macro, Gas will substitute the empty string (a blank parameter) when expanding the parameter in the macro’s body.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">identifier=expression</span>    Like the first form, this specifies a parameter that can be optional, except that Gas will give the identifier the value of the expression rather than an empty string if the macro invocation doesn’t supply a parameter value.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_766" aria-label="766"/><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">identifier</span><span class="SANS_TheSansMonoCd_W7Bold_11">:req</span>    Specifies that the macro argument must be supplied when invoking the macro; if it is missing, Gas will respond with an error message.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">identifier</span><span class="SANS_TheSansMonoCd_W7Bold_11">:vararg</span>    Allows for a varying parameter list (zero or more arguments separated by commas). Gas will expand this macro parameter to the entire list of values, including the commas separating the values.</p>&#13;
</div>&#13;
<p class="TX">In standard Gas syntax, a space separates the macro name and the first parameter (if any). I’ve found that with the ARM assembler, sneaking in a comma works fine too (your mileage may vary).</p>&#13;
<p class="TX">Within a macro body, use a token of the form <span class="SANS_TheSansMonoCd_W5Regular_11">\</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier</span>—where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier</span> is one of the macro’s declared formal parameters—to expand a parameter. For example, the following macro demonstrates the expansion of the <span class="SANS_TheSansMonoCd_W5Regular_11">value</span> argument:</p>&#13;
<pre id="pre-1057"><code>.macro oneByte value&#13;
.byte  \value&#13;
.endm&#13;
 .&#13;
 .&#13;
 .&#13;
oneByte 1  // Expands to .byte 1</code></pre>&#13;
<p class="TX">A macro definition can have zero or more parameters. If you supply more than one parameter, you must separate each formal parameter with a comma. Additionally, if you specify a <span class="SANS_TheSansMonoCd_W5Regular_11">vararg</span> parameter, it must be the last parameter declared in the <span class="SANS_TheSansMonoCd_W5Regular_11">.macro</span> statement. Here’s an example of a slightly complex macro:</p>&#13;
<pre id="pre-1058"><code>.macro bytes yy:req, zz=0, tt, ss:vararg&#13;
.byte  \yy&#13;
.byte  \zz&#13;
.byte  \tt&#13;
.byte  \ss&#13;
.endm</code></pre>&#13;
<p class="TX">When you invoke this macro, you must supply at least one actual parameter (because <span class="SANS_TheSansMonoCd_W5Regular_11">yy</span> is a required parameter). For example</p>&#13;
<pre id="pre-1059"><code>bytes 5</code></pre>&#13;
<p class="Continued1">expands to this:</p>&#13;
<pre id="pre-1060"><code>.byte 5&#13;
.byte 0  // Because zz expands to 0 by default&#13;
.byte    // Argument tt expands to the empty string.&#13;
.byte    // Argument ss also expands to the empty string.</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_767" aria-label="767"/>Note that if a data directive such as <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> does not have any operands, Gas will ignore that statement and not generate any code to the object file.</p>&#13;
<p class="TX">Here’s another invocation of <span class="SANS_TheSansMonoCd_W5Regular_11">bytes</span> that demonstrates full argument expansion</p>&#13;
<pre id="pre-1061"><code>bytes 5, 4, 3, 2, 1, 0</code></pre>&#13;
<p class="Continued1">which expands to:</p>&#13;
<pre id="pre-1062"><code>.byte 5        // yy expansion&#13;
.byte 4        // zz expansion&#13;
.byte 3        // tt expansion&#13;
.byte 2, 1, 0  // ss expansion</code></pre>&#13;
<p class="TX">This example worked out well because the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> directive allows comma-separated operands. However, what if you want to expand a <span class="SANS_TheSansMonoCd_W5Regular_11">vararg</span> parameter where comma-separated operands are not legal? Consider the following macro:</p>&#13;
<pre id="pre-1063"><code>.macro  addVals theVals:vararg&#13;
add     x0, x0, #\theVals&#13;
.endm</code></pre>&#13;
<p class="TX">An invocation of <span class="SANS_TheSansMonoCd_W5Regular_11">addVals</span> such as</p>&#13;
<pre id="pre-1064"><code>addVals 1, 2</code></pre>&#13;
<p class="Continued1">will generate an error because</p>&#13;
<pre id="pre-1065"><code>add x0, x0, #1, 2</code></pre>&#13;
<p class="Continued1">is syntactically incorrect. You can solve this problem by using an <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span> loop inside the macro to process a <span class="SANS_TheSansMonoCd_W5Regular_11">vararg</span> parameter:</p>&#13;
<pre id="pre-1066"><code>.macro  addVals theVals:vararg&#13;
.irp    valToAdd, \theVals&#13;
add     x0, x0, #\valToAdd&#13;
.endr&#13;
.endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">addVals 1, 2</span> invocation will now emit the following:</p>&#13;
<pre id="pre-1067"><code>add x0, x0, #1&#13;
add x0, x0, #2</code></pre>&#13;
<p class="TX">Gas will expand a macro just about anywhere it appears within a macro body. Consider the following macro:</p>&#13;
<pre id="pre-1068"><code>.macro select which&#13;
lea    x1, var\which&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_768" aria-label="768"/>ldr    w1, [x1]&#13;
.endm</code></pre>&#13;
<p class="TX">Assuming you’ve defined the <span class="SANS_TheSansMonoCd_W5Regular_11">var0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">var1</span> symbols somewhere, the invocation <span class="SANS_TheSansMonoCd_W5Regular_11">select 0</span> generates the following</p>&#13;
<pre id="pre-1069"><code>lea x1, var0&#13;
ldr w1, [x1]</code></pre>&#13;
<p class="Continued1">while the invocation <span class="SANS_TheSansMonoCd_W5Regular_11">select 1</span> generates this:</p>&#13;
<pre id="pre-1070"><code>lea x1, var1&#13;
ldr w1, [x1]</code></pre>&#13;
<p class="TX">Suppose you want to supply the prefix of the name, rather than the suffix, as the macro argument in this example. A first attempt at this won’t work:</p>&#13;
<pre id="pre-1071"><code>.macro select2 which&#13;
lea    x1, \whichvar&#13;
ldr    w1, [x1]&#13;
.endm</code></pre>&#13;
<p class="TX">The problem, of course, is that Gas interprets <span class="SANS_TheSansMonoCd_W5Regular_11">\whichvar</span> as the expansion of a parameter named <span class="SANS_TheSansMonoCd_W5Regular_11">whichvar</span>. To separate a parameter name from the following text, use the <span class="SANS_TheSansMonoCd_W5Regular_11">\()</span> token:</p>&#13;
<pre id="pre-1072"><code>.macro select2 which&#13;
lea    x1, \which\()var&#13;
ldr    w1, [x1]&#13;
.endm</code></pre>&#13;
<p class="TX">An invocation such as <span class="SANS_TheSansMonoCd_W5Regular_11">select2 my</span> will now properly expand to</p>&#13;
<pre id="pre-1073"><code>lea    x1, myvar&#13;
ldr    w1, [x1]</code></pre>&#13;
<p class="Continued1">which creates the name <span class="SANS_TheSansMonoCd_W5Regular_11">myvar</span>, as intended.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3" id="sec28"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.4.2 Macro Parameters with String Constants</span></h5>&#13;
<p class="TNI1">Gas’s macros have a “feature” that can bite you if you’re not careful: if you pass a string constant as a formal parameter, Gas will strip the quotes from the string when expanding that parameter. For example, consider the following macro and invocation:</p>&#13;
<pre id="pre-1074"><code>.macro myStr theStr&#13;
.asciz \theStr&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_769" aria-label="769"/>.endm&#13;
 .&#13;
 .&#13;
 .&#13;
myStr "hello"</code></pre>&#13;
<p class="Continued1">This expands to the following:</p>&#13;
<pre id="pre-1075"><code>.asciz hello</code></pre>&#13;
<p class="TX">Unless you’ve defined the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">hello</span> with an appropriate value, this will generate an error. The correct way to do this is as follows:</p>&#13;
<pre id="pre-1076"><code>.macro myStr theStr&#13;
.asciz "\theStr"&#13;
.endm&#13;
 .&#13;
 .&#13;
 .&#13;
myStr "hello"</code></pre>&#13;
<p class="Continued1">This code properly generates the following:</p>&#13;
<pre id="pre-1077"><code>.asciz "hello"</code></pre>&#13;
<p class="TX">One possible use for this is passing parameters that contain commas and whitespace as a single argument to a macro. I will leave it up to you to figure out other abuses of this “feature” in Gas. Personally, I consider it a bug, and I’d be afraid to use this feature because Gas could remove this behavior in a future version of the assembler.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.4.3 Recursive Macros</span></h5>&#13;
<p class="TNI1">Unlike CPP, Gas fully supports recursive macros. Consider the following example (adapted from the Gas manual):</p>&#13;
<pre id="pre-1078"><code>.macro  sum from=0, to=5&#13;
.long   \from&#13;
.ifgt   \to-\from&#13;
sum     "(\from+1)",\to&#13;
.endif&#13;
.endm</code></pre>&#13;
<p class="TX">A macro invocation of the form <span class="SANS_TheSansMonoCd_W5Regular_11">sum 0, 5</span> generates the following code:</p>&#13;
<pre id="pre-1079"><code>.long   0&#13;
.long   1&#13;
.long   2&#13;
.long   3&#13;
.long   4&#13;
.long   5</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_770" aria-label="770"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">sum</span> macro uses conditional assembly statements to prevent endless recursion. Though you could more easily iterate over five values by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span>) directives, sometimes recursion is a better solution than iteration.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">.irp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.rept</span> directives are a better fit for simple iteration. Recursion is better for processing recursive data structures, such as lists and trees, passed as macro arguments, or if you need to reverse the arguments passed to a macro (I give an example of this in the next section).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h5 class="H3" id="sec30"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.4.4 The .exitm Directive</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.exitm</span> directive allows you to prematurely terminate the expansion of a macro. Its syntax is as follows:</p>&#13;
<pre id="pre-1080"><code>.exitm</code></pre>&#13;
<p class="TX">When Gas encounters <span class="SANS_TheSansMonoCd_W5Regular_11">.exitm</span> during a macro expansion, it immediately stops the expansion and ignores the rest of the macro’s body. Of course, just placing an <span class="SANS_TheSansMonoCd_W5Regular_11">.exitm</span> directive in the middle of a macro body (other than for testing purposes) is not especially useful—why write the rest of the macro body if it’s going to be ignored? Instead, you’ll generally find an <span class="SANS_TheSansMonoCd_W5Regular_11">.exitm</span> macro inside a conditional assembly block like the following:</p>&#13;
<pre id="pre-1081"><code>.macro reverse first, args:vararg&#13;
.ifb    \first&#13;
.exitm  // Quit recursion if no more arguments.&#13;
.endif&#13;
reverse \args&#13;
.byte   \first&#13;
.endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">.exitm</span> directive terminates recursion when the argument list is empty. The recursive invocation passes all but the first argument to reverse. As you may already have guessed, this macro will generate the bytes specified as parameters in reverse order to the file. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">reverse 0, 1, 2, 3</span> generates</p>&#13;
<pre id="pre-1082"><code>.byte 3&#13;
.byte 2&#13;
.byte 1&#13;
.byte 0</code></pre>&#13;
<p class="Continued1">reversing the arguments passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">reverse</span> macro.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h5 class="H3" id="sec31"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.4.5 The \@ Operator</span></h5>&#13;
<p class="TNI1">Within a macro, Gas will convert the token <span class="SANS_TheSansMonoCd_W5Regular_11">\@</span> to a string of digits specifying the total number of macros it has expanded during assembly. You can use this operator, typically along with the <span class="SANS_TheSansMonoCd_W5Regular_11">\()</span> token, to create macro-local symbols. The following macro provides a trivial example of this usage:</p>&#13;
<pre id="pre-1083"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_771" aria-label="771"/>        .macro  lclsym sym&#13;
        b       a\()\@&#13;
a\()\@:&#13;
        .endm</code></pre>&#13;
<p class="TX">Multiple expansions of this macro generate a unique symbol by suffixing a string of digits to the end of <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h5 class="H3" id="sec32"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13.3.4.6 The .purgem Directive</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.purgem</span> directive deletes a previously defined Gas macro. It is similar to the CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#undef</span> statement. Normally, if you try to redefine a Gas macro, Gas will generate an error. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">.purgem</span> directive to delete the macro if you want to redefine it.</p>&#13;
<p class="TX">Note that Gas will generate an error if you attempt to purge a macro that has not already been defined. Unfortunately, the <span class="SANS_TheSansMonoCd_W5Regular_11">.ifdef</span> (and comparable) conditional assembly statement does not recognize macro symbols; so there is no way to check whether a macro has been defined before using the <span class="SANS_TheSansMonoCd_W5Regular_11">.purgem</span> directive; you have to ensure that the macro symbol exists prior to using this directive.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h3 class="H1" id="sec33"><span id="h1-140"/><span class="SANS_Futura_Std_Bold_B_11">13.4 The aoaa.inc Header File</span></h3>&#13;
<p class="TNI1">Throughout this book, I’ve used the <i>aoaa.inc</i> header file in examples without discussing what it contains. Now that you’ve been introduced to CPP and Gas macro and CTL facilities, the time has come to fulfill my promise in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> that I would explain, section by section, how this header file works.</p>&#13;
<p class="TX">I’ll go over the source code for <i>aoaa.inc</i> piece by piece, in order to annotate and explain each of its components. The first section is the usual header that appears at the beginning of an include file:</p>&#13;
<pre id="pre-1084"><code>// aoaa.inc&#13;
//&#13;
// "Magic" header file for The Art of ARM Assembly&#13;
// that smooths over the differences between Linux&#13;
// and macOS&#13;
//&#13;
// Assertions:&#13;
//&#13;
// Either isMacOS or isLinux has been&#13;
// defined in the source file (using #define) prior&#13;
// to including this source file. This source file&#13;
// must be included using <var>#include "aoaa.inc"</var>&#13;
// NOT using the Gas <var>.include</var> directive.</code></pre>&#13;
<p class="TX">To begin, the <i>aoaa.inc</i> header file assumes that the source file that includes <i>aoaa.inc</i> is being assembled using the <i>build</i> shell script. Among other things, the <i>build</i> script will include one of the following command <span role="doc-pagebreak" epub:type="pagebreak" id="pg_772" aria-label="772"/>line options on the <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span> command line that assembles the source file, as appropriate for the OS under which you’re running GCC (and Gas):</p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">-D isMacOS=1</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">-D isLinux=1</span></p>&#13;
<p class="TX">Because these symbols are defined for use by CPP (not Gas), the source file must have a <i>.S</i> suffix, and you must run the CPP on this file, meaning you need to assemble the file by running the <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span> executable rather than the <span class="SANS_TheSansMonoCd_W5Regular_11">as</span> (Gas) executable.</p>&#13;
<p class="TX">The next section of the source file handles multiple inclusions:</p>&#13;
<pre id="pre-1085"><code>// aoaa.inc (cont.)&#13;
//&#13;
#ifndef aoaa_inc&#13;
#define aoaa_inc 0</code></pre>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> sequence is the standard way to prevent problems if a program includes a header file more than once. The first time CPP includes this file, the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">aoaa_inc</span> will not be defined; therefore, CPP will process the text after the <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span> statement. The very next statement defines the <span class="SANS_TheSansMonoCd_W5Regular_11">aoaa_inc</span> symbol. Should the assembly source file that included <i>aoaa.inc</i> include it a second time, the <span class="SANS_TheSansMonoCd_W5Regular_11">aoaa_inc</span> symbol will be defined, so CPP will ignore everything up to the matching <span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> (which happens to be at the end of the source file).</p>&#13;
<p class="TX">As the earlier comment states, you must include the <i>aoaa.inc</i> header file by using the CPP statement <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span>, rather than Gas’s <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive. This is because the <i>aoaa.inc</i> file contains several CPP statements (including <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span>), and CPP will never see the <i>aoaa.inc</i> file if you include it via <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span>. Remember, Gas statements are processed long after CPP has executed and quit.</p>&#13;
<p class="TX">Next, the <i>aoaa.inc</i> header file sets up defines for various symbols to handle macOS- and Linux-specific code:</p>&#13;
<pre id="pre-1086"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Make sure all OS symbols are&#13;
// defined and only one of them&#13;
// is set to 1:&#13;
&#13;
#ifndef isMacOS&#13;
    #define isMacOS (0)&#13;
#else&#13;
    #undef isMacOS&#13;
    #define isMacOS (1)&#13;
#endif&#13;
&#13;
#ifndef isLinux&#13;
    #define isLinux (0)&#13;
#else&#13;
    #undef isLinux&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_773" aria-label="773"/>    #define isLinux (1)&#13;
#endif&#13;
&#13;
// Make sure exactly one of the OS symbols is set to 1:&#13;
&#13;
#if (isMacOS+isLinux) != 1&#13;
    #error "Exactly one of isMacOS or isLinux," \&#13;
                       " must be 1"&#13;
#endif</code></pre>&#13;
<p class="TX">This block of conditional compilation statements ensures that both <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span> are defined and are given appropriate values for the OS. The command line parameters supplied by the <i>build</i> script will define only one of these two symbols. These statements ensure that both are defined and are assigned appropriate Boolean values (0 for false, 1 for true).</p>&#13;
<p class="TX">Next up, the <i>aoaa.inc</i> header file defines some symbols required under macOS:</p>&#13;
<pre id="pre-1087"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Do macOS-specific stuff here:&#13;
&#13;
#if isMacOS&#13;
&#13;
    // Change all the C global function&#13;
    // names to include a leading underscore&#13;
    // character, as required by macOS (these&#13;
    // definitions allow you to use all the&#13;
    // same names in example programs in&#13;
    // macOS and Linux). This list includes&#13;
    // all the C stdlib functions used by&#13;
    // AoAA example code.&#13;
  &#13;
    #define asmMain  _asmMain&#13;
    #define acos     _acos&#13;
    #define asin     _asin&#13;
    #define atan     _atan&#13;
    #define cos      _cos&#13;
    #define exp      _exp&#13;
    #define exp2     _exp2&#13;
    #define getTitle _getTitle&#13;
    #define free     _free&#13;
    #define log      _log&#13;
    #define log2     _log2&#13;
    #define log10    _log10&#13;
    #define malloc   _malloc&#13;
    #define pow      _pow&#13;
    #define printf   _printf&#13;
    #define readLine _readLine&#13;
    #define sin      _sin&#13;
    #define sqrt     _sqrt&#13;
    #define strcat   _strcat&#13;
    #define strchr   _strchr&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_774" aria-label="774"/>    #define strcmp   _strcmp&#13;
    #define strcpy   _strcpy&#13;
    #define strlen   _strlen&#13;
    #define strncat  _strncat&#13;
    #define strncpy  _strncpy&#13;
    #define strstr   _strstr&#13;
    #define strtol   _strtol&#13;
    #define tan      _tan&#13;
    #define write    _write&#13;
  &#13;
    #define __errno_location ___error</code></pre>&#13;
<p class="TX">Under macOS, external symbols like the C stdlib function names have a leading underscore. Under Linux, the symbols appear without the underscore. The <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements in the previous code snippet replace several common C stdlib function names with the underscore-prefixed version. This allows calls in this book to use consistent names under both macOS and Linux.</p>&#13;
<p class="TX">These defines work only for the C stdlib functions appearing in this list. If you decide to call other stdlib functions (or use other external symbols), you’ll have to explicitly supply the underscore prefix character or add additional <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements to this list.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro also has a macOS-specific implementation:</p>&#13;
<pre id="pre-1088"><code>// aoaa.inc (cont.)&#13;
//&#13;
// lea (Load Effective Address) macro.&#13;
// Correctly loads the address of&#13;
// a memory object into a register, even&#13;
// on machines that use position-independent&#13;
// executables (PIE):&#13;
&#13;
.macro  lea, reg, mem&#13;
    adrp    \reg,\mem@PAGE&#13;
    add     \reg, \reg, \mem@PAGEOFF&#13;
.endm</code></pre>&#13;
<p class="TX">As noted in <span class="Xref"><a href="chapter1.xhtml">Chapters 1</a></span> and <span class="Xref"><a href="chapter7.xhtml">7</a></span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro expands to two instructions that load the address of a symbol into a 64-bit register. The main reason for including this macro (rather than explicitly writing these two instructions everywhere <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> appears in this book) is that the two instructions are slightly different, depending on whether the code is being assembled for macOS or Linux. This version of the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro generates the code for macOS.</p>&#13;
<p class="TX">Next up are the <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">mstrb</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mstrh</span> macros, which also have macOS-specific implementations:</p>&#13;
<pre id="pre-1089"><code>// aoaa.inc (cont.)&#13;
//&#13;
// mstr Assembles to a str instruction under macOS&#13;
// mstrb&#13;
// mstrh&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_775" aria-label="775"/>.macro      mstr, operands:vararg&#13;
str         \operands&#13;
.endm&#13;
&#13;
.macro      mstrb, operands:vararg&#13;
strb        \operands&#13;
.endm&#13;
&#13;
.macro      mstrh, operands:vararg&#13;
strh        \operands</code></pre>&#13;
<p class="TX">Linux and macOS handle varying parameter lists differently. Under Linux, you continue to pass the first eight parameters in X0 through X7, while under macOS, you pass them both in the registers and on the stack. The <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">mstrb</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mstrh</span> macros expand to code that stores a register onto the stack when operating under macOS (as you’ll see shortly, the Linux versions expand to nothing).</p>&#13;
<p class="TX">The Clang assembler (the macOS version of Gas) does not support the <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> directive; the following macro implements this for macOS. Under macOS, the <i>aoaa.inc</i> header file therefore includes a macro to supply this missing directive, mapping it to the equivalent <span class="SANS_TheSansMonoCd_W5Regular_11">.quad</span> directive:</p>&#13;
<pre id="pre-1090"><code>// aoaa.inc (cont.)&#13;
//&#13;
// macOS's assembler doesn't have .dword,&#13;
// define it here:&#13;
&#13;
.macro  .dword, value:vararg&#13;
    .quad   \value&#13;
.endm</code></pre>&#13;
<p class="TX">Earlier chapters used the <span class="SANS_TheSansMonoCd_W5Regular_11">vparm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> macros to pass variables to the <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function. Because the API for varying parameters differs between macOS and Linux, there are separate definitions for the two OSes. Here is their macOS implementation:</p>&#13;
<pre id="pre-1091"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Macros to load parameters 2..8 onto&#13;
// the stack for macOS when calling&#13;
// a variadic (variable parameter list)&#13;
// function, such as printf().&#13;
//&#13;
// Note that parameter 1 still goes into X0.&#13;
&#13;
.macro  vparm2, mem&#13;
lea     x1, \mem&#13;
ldr     x1, [x1]&#13;
str     x1, [sp]&#13;
.endm&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_776" aria-label="776"/>.macro  vparm3, mem&#13;
lea     x2, \mem&#13;
ldr     x2, [x2]&#13;
str     x2, [sp, #8]&#13;
.endm&#13;
&#13;
.macro  vparm4, mem&#13;
lea     x3, \mem&#13;
ldr     x3, [x3]&#13;
str     x3, [sp, #16]&#13;
.endm&#13;
&#13;
.macro  vparm5, mem&#13;
lea     x4, \mem&#13;
ldr     x4, [x4]&#13;
str     x4, [sp, #24]&#13;
.endm&#13;
&#13;
.macro  vparm6, mem&#13;
lea     x5, \mem&#13;
ldr     x5, [x5]&#13;
str     x5, [sp, #32]&#13;
.endm&#13;
&#13;
.macro  vparm7, mem&#13;
lea     x6, \mem&#13;
ldr     x6, [x6]&#13;
str     x6, [sp, #40]&#13;
.endm&#13;
&#13;
.macro  vparm8, mem&#13;
lea     x7, \mem&#13;
ldr     x7, [x7]&#13;
str     x7, [sp, #48]&#13;
.endm        .endm</code></pre>&#13;
<p class="TX">Next come the Linux-specific implementations of these macros:</p>&#13;
<pre id="pre-1092"><code>// aoaa.inc (cont.)&#13;
&#13;
#elif isLinux == 1&#13;
&#13;
    // Do Linux (no-PIE)-specific stuff here:&#13;
&#13;
    .macro  lea, reg, mem&#13;
        adrp    \reg,\mem&#13;
        add     \reg, \reg, :lo12:\mem&#13;
    .endm&#13;
&#13;
    // mstr  assembles to nothing under Linux&#13;
    // mstrb&#13;
    // mstrh&#13;
&#13;
    .macro      mstr, operands:vararg&#13;
    .endm&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_777" aria-label="777"/>    .macro      mstrb, operands:vararg&#13;
    .endm&#13;
&#13;
    .macro      mstrh, operands:vararg&#13;
    .endm&#13;
&#13;
    .macro  vparm2, mem&#13;
    lea     x1, \mem&#13;
    ldr     x1, [x1]&#13;
    .endm&#13;
&#13;
    .macro  vparm3, mem&#13;
    lea     x2, \mem&#13;
    ldr     x2, [x2]&#13;
    .endm&#13;
&#13;
    .macro  vparm4, mem&#13;
    lea     x3, \mem&#13;
    ldr     x3, [x3]&#13;
    .endm&#13;
&#13;
    .macro  vparm5, mem&#13;
    lea     x4, \mem&#13;
    ldr     x4, [x4]&#13;
    .endm&#13;
&#13;
    .macro  vparm6, mem&#13;
    lea     x5, \mem&#13;
    ldr     x5, [x5]&#13;
    .endm&#13;
&#13;
    .macro  vparm7, mem&#13;
    lea     x6, \mem&#13;
    ldr     x6, [x6]&#13;
    .endm&#13;
&#13;
    .macro  vparm8, mem&#13;
    lea     x7, \mem&#13;
    ldr     x7, [x7]&#13;
    .endm&#13;
&#13;
#endif      #endif</code></pre>&#13;
<p class="TX">There are no <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements for stdlib functions because Linux doesn’t require the underscore prefix character on external names. As for the parameter-related functions, Linux passes the first eight arguments of a varying parameter list only in the registers, not on the stack. The <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">mstrb</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mstrh</span> macros thus expand to nothing, while the <span class="SANS_TheSansMonoCd_W5Regular_11">vparm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> macros expand to code without storing data on the stack.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_778" aria-label="778"/>The remainder of the source file is common to both macOS and Linux. First, the <i>aoaa.inc</i> header file contains a few <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> directives to specify public names for use by the C/C++ program that calls the assembly file:</p>&#13;
<pre id="pre-1093"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Global declarations:&#13;
&#13;
.global asmMain&#13;
.global getTitle&#13;
.global readLine&#13;
.global printf</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">printf</span> definition, strictly speaking, isn’t necessary; it’s really just an external declaration, and undefined symbols are external by default. I added it simply because almost every sample program in this book calls the <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function.</p>&#13;
<p class="TX">Gas doesn’t actually provide a <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> directive. The <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> macro renames <span class="SANS_TheSansMonoCd_W5Regular_11">.octa</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> to be consistent with <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span> and .<span class="SANS_TheSansMonoCd_W5Regular_11">dword</span>:</p>&#13;
<pre id="pre-1094"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Generic code for all OSes:&#13;
&#13;
// Gas doesn't have a .qword&#13;
// directive. Map .qword to .octa:&#13;
&#13;
.macro  .qword, value:vararg&#13;
    .octa   \value&#13;
.endm</code></pre>&#13;
<p class="TX">Next up in <i>aoaa.inc</i> are the definitions needed for the structure definition macros:</p>&#13;
<pre id="pre-1095"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Macros for structure definitions:&#13;
&#13;
__inStruct          = 0&#13;
__inArgs            = 0&#13;
__inLocals          = 0&#13;
__dir               = 1</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">__inStruct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">__inArgs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">__inLocals</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> compile-time variables maintain information needed to declare structure fields, parameters, and local variables by using the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">args</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> macros. The <span class="SANS_TheSansMonoCd_W5Regular_11">__in*</span> variables are Booleans that track whether the program is currently defining a structure, a parameter list, or a set of local variables. Only one of these fields may contain true (nonzero) at a time, though they can all be 0 if you’re not declaring the field of any of these objects.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_779" aria-label="779"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> variable is either 1 or –1. This determines whether successive declarations in these objects have increasing (when <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> is +1) or decreasing (when <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> is –1) offsets. Structures and parameters have increasing offsets, while locals have decreasing offsets.</p>&#13;
<p class="TX">With those compile-time constants out of the way, here are the actual <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">args</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> macros:</p>&#13;
<pre id="pre-1096"><code>// aoaa.inc (cont.)&#13;
&#13;
                <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> .macro  struct  name, initialOffset=0&#13;
__inStruct          = 1&#13;
__inLocals          = 0&#13;
__inArgs            = 0&#13;
__struct_offset     = \initialOffset&#13;
\name\().base       = \initialOffset&#13;
__dir               = 1&#13;
                    .if     \initialOffset &gt; 0&#13;
                    .err&#13;
                    error   struct offset must be negative or 0&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .macro  args  name, initialOffset=16&#13;
__inStruct          = 0&#13;
__inLocals          = 0&#13;
__inArgs            = 1&#13;
__struct_offset     = \initialOffset&#13;
\name\().base       = \initialOffset&#13;
__dir               = 1&#13;
                    .endm&#13;
                <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> .macro  locals  name&#13;
__inStruct          = 0&#13;
__inLocals          = 1&#13;
__inArgs            = 0&#13;
__struct_offset     = 0&#13;
__dir               = -1&#13;
                    .endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">args</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> macros allow you to define structures (records), parameter lists (arguments), and local variables. These macros set up some compile-time variables that track the base address of the object, as well as the direction, positive or negative, by which offsets are assigned to fields of the object.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro <span class="CodeAnnotation" aria-label="annotation1">❶</span> creates structures (records) by associating a field offset with each member of the structure. The <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro itself simply initializes the <span class="SANS_TheSansMonoCd_W5Regular_11">__inStruct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_TheSansMonoCd_W5Regular_11">.base</span> compile-time variables that maintain information needed when declaring fields of the structure (where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> is the user-supplied structure name). The <span class="SANS_TheSansMonoCd_W5Regular_11">__struct_offset</span> CTL maintains a “location counter” within the structure. By default, the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro initializes this with 0. However, the person invoking <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> can specify a negative <span role="doc-pagebreak" epub:type="pagebreak" id="pg_780" aria-label="780"/>value if they would like to specify that the first fields of the structure appear in memory before the structure’s base address. The <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> CTL is initialized with 1 because successive fields in a structure have increasing offsets within the structure.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">args</span> macro <span class="CodeAnnotation" aria-label="annotation2">❷</span> declares parameter lists for a function or procedure, fundamentally the same operation as creating a structure; you are defining part of the activation record, after all. The only real difference is that the starting offset is 16 (this is the offset of the first parameter in the activation record, using the base address specified by the FP register; the saved FP value and the return address consume the double words at offsets 0 and 8, respectively). Because parameters follow in higher addresses, the <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> field is initialized with 1.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> macro <span class="CodeAnnotation" aria-label="annotation3">❸</span> declares local variables allocated on the stack below the address held in the FP register. Because successive declarations appear at lower addresses in memory, this macro initializes the <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> field with –1.</p>&#13;
<p class="TX">The macros for the matching <span class="SANS_TheSansMonoCd_W5Regular_11">ends</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">enda</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> statements appear later in the listing. The following sections describe the data declaration macros that can appear inside a structure:</p>&#13;
<pre id="pre-1097"><code>// aoaa.inc (cont.)&#13;
&#13;
                    .macro  salign, size&#13;
__salign        = 0xFFFFFFFFFFFFFFFF - ((1 &lt;&lt; \size)-1)&#13;
__struct_offset = (__struct_offset + (1 &lt;&lt; \size)-1) &amp; __salign&#13;
                    .endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> macro, which should appear only in a <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">args</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> declaration, adjusts the <span class="SANS_TheSansMonoCd_W5Regular_11">__struct_offset</span> value (the location counter) so that it is aligned at an offset that is a power of 2 (the power of 2 is specified by the parameter). This macro achieves its purpose by creating a bitmask containing size 0s in the LO bits and 1s in the remaining HO bits. Logically ANDing <span class="SANS_TheSansMonoCd_W5Regular_11">__struct_offset</span> with this value produces an offset that is aligned to the designed value.</p>&#13;
<p class="TX">The following macros provide the <span class="SANS_TheSansMonoCd_W5Regular_11">byte</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">word</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">dword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">qword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">oword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">single</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">double</span> directives for use in structures:</p>&#13;
<pre id="pre-1098"><code>// aoaa.inc (cont.)&#13;
&#13;
                    .macro  byte, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + \elements&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + \elements&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  hword, name, elements=1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_781" aria-label="781"/>                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*2)&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + ((\elements)*2)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  word, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*4)&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + ((\elements)*4)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  dword, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*8)&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + ((\elements)*8)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  qword, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*16)&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + ((\elements)*16)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  oword, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*32)&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + ((\elements)*32)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  single, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*4)&#13;
                    .else&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_782" aria-label="782"/>__struct_offset     =       __struct_offset + ((\elements)*4)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm&#13;
&#13;
                    .macro  double, name, elements=1&#13;
                    .if     __dir &gt; 0&#13;
\name               =       __struct_offset&#13;
__struct_offset     =       __struct_offset + ((\elements)*8)&#13;
                    .else&#13;
__struct_offset     =       __struct_offset + ((\elements)*8)&#13;
\name               =       -__struct_offset&#13;
                    .endif&#13;
                    .endm</code></pre>&#13;
<p class="TX">Each macro declares a single scalar or array variable of the specified type (you can specify an array by providing a second argument with the number of elements).</p>&#13;
<p class="TX">These macros will bump the current location counter, <span class="SANS_TheSansMonoCd_W5Regular_11">__struct_offset</span>, by the size of the variable and assign that offset to the declared name. If <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> is negative (locals declarations), the macro first decrements the location counter, then assigns the offset to the name; if <span class="SANS_TheSansMonoCd_W5Regular_11">__dir</span> is positive, the macro assigns the offset and increments the location counter value.</p>&#13;
<p class="TX">Here are the <span class="SANS_TheSansMonoCd_W5Regular_11">ends</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">enda</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> macros:</p>&#13;
<pre id="pre-1099"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Generate name.size and name.offset constants&#13;
// specifying total structure size and the offset&#13;
// just beyond the last field.&#13;
//&#13;
// Also create a macro to be used to declare&#13;
// structure variables.&#13;
&#13;
                    .macro ends, name&#13;
__inStruct          =      0&#13;
\name\().size       =      __struct_offset-\name\().base&#13;
\name\().offset = __struct_offset&#13;
                    .macro  \name, varName&#13;
                    .if     \name\().base &lt; 0&#13;
                    .space  __struct_offset-(\name\().base)&#13;
                    .endif&#13;
\varName:&#13;
                    .if     __struct_offset &gt; 0&#13;
                    .fill   __struct_offset&#13;
                    .endif&#13;
&#13;
                    .endm&#13;
                    .endm&#13;
                    .macro enda, name&#13;
__inArgs            =      0&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_783" aria-label="783"/>\name\().size       =      __struct_offset-\name\().base&#13;
                    .endm&#13;
&#13;
                    .macro endl, name&#13;
__inLocal           =      0&#13;
\name\().size       =      __struct_offset&#13;
                    .endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ends</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">enda</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> macros complete a declaration begun by <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">args</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span>. They set to false the Boolean variable that is tracking an open structure, parameter list, or local variables declaration, then set the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_TheSansMonoCd_W5Regular_11">.size</span> equate to the total size of the declarations. The <span class="SANS_TheSansMonoCd_W5Regular_11">ends</span> macro also defines a macro that you can use to declare structure objects in your code.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">wastr</span> macro emits a word-aligned string to memory. Here is its implementation:</p>&#13;
<pre id="pre-1100"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Macro to emit a string that is padded with bytes&#13;
// so that it consumes a multiple of 4 bytes in memory:&#13;
&#13;
                    .macro   wastr, theStr&#13;
                    .asciz   "\theStr"&#13;
                    .p2align 2&#13;
                    .endm</code></pre>&#13;
<p class="TX">This macro is mainly used in <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> sections because you must keep all code and labels word-aligned within those sections. Quotes must surround the macro parameter expansion because Gas will strip off the quotes you supply in the actual parameter (see section 13.3.4.2, <span class="Xref">“Macro Parameters with String Constants,”</span> on <span class="Xref"><a href="chapter13.xhtml#pg_768">page 768</a></span>).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span> macros provide syntactical sugar for declaring procedures in an assembly language source file. Here is their implementation:</p>&#13;
<pre id="pre-1101"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Macros for declaration procedures/functions:&#13;
&#13;
public              =       1&#13;
                    .macro  proc pName:req, isPublic=0&#13;
&#13;
// If "public" argument is present, emit&#13;
// global statement.&#13;
&#13;
                    .if     \isPublic&#13;
                    .global _\pName&#13;
                    .global \pName&#13;
                    .endif&#13;
&#13;
\pName\().isOpenProcDCL = 1&#13;
\pName:&#13;
_\pName:&#13;
                    .endm&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_784" aria-label="784"/>                    .macro  endp pName:req&#13;
                    .ifndef \pName\().isOpenProcDCL&#13;
                    .err&#13;
                    .err    "Not an open procedure"&#13;
                    .else&#13;
                    .if     \pName\().isOpenProcDCL&#13;
                    .else&#13;
                    .err&#13;
                    .err    "endp name does not match last proc name"&#13;
                    .endif&#13;
                    .endif&#13;
\pName\().isOpenProcDCL = 0&#13;
                    .endm</code></pre>&#13;
<p class="Continued1">Other than emitting the procedure name and (if <span class="SANS_TheSansMonoCd_W5Regular_11">isPublic</span> is 1) the <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> directive, this macro doesn’t really do much.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> equate allows you to specify <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> as a second argument to this macro to tell the assembler to make the symbol global (that is, public). Technically, you could just pass <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> as the second argument, but <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> is more readable.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">.code</span> macro simply expands to <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> and ensures that the location counter is aligned on a word (4-byte) boundary:</p>&#13;
<pre id="pre-1102"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Sanity for ARM code:&#13;
&#13;
                    .macro  .code&#13;
                    .text&#13;
                    .align  2&#13;
                    .endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">leave</span> macros provide the standard entry and standard exit sequences for a procedure (see section 5.4.4, <span class="Xref">“Standard Entry Sequence,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_248">page 248</a></span> and section 5.4.5, <span class="Xref">“Standard Exit Sequence,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_250">page 250</a></span> for more details):</p>&#13;
<pre id="pre-1103"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Assembly standard entry sequence:&#13;
&#13;
    .macro  enter, localsSize&#13;
    stp     fp, lr, [sp, #-16]!&#13;
    mov     fp, sp&#13;
    .if     \localsSize &gt; 0&#13;
    sub     sp, sp, #((\localsSize)+15) &amp; 0xFFFFFFFFFFFFFFF0&#13;
    .endif&#13;
    .endm&#13;
&#13;
// Assembly standard exit sequence:&#13;
&#13;
    .macro  leave&#13;
    mov     sp, fp&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_785" aria-label="785"/>    ldp     fp, lr, [sp], #16&#13;
    ret&#13;
    .endm</code></pre>&#13;
<p class="TX">In rare circumstances, the <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> (branch) and <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> (branch always) instructions may generate an out-of-range error when the target location is too far away from the instruction. In those situations, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> macro to transfer control anywhere in the 64-bit address range of the ARM CPU:</p>&#13;
<pre id="pre-1104"><code>// aoaa.inc (cont.)&#13;
//&#13;
// goto&#13;
//&#13;
// Transfers control to the specified label&#13;
// anywhere in the 64-bit address space:&#13;
&#13;
            .macro  goto, destination&#13;
            adr     x16, 0f&#13;
            ldr     x17, 0f&#13;
            add     x16, x16, x17&#13;
            br      x16&#13;
0:&#13;
            .dword  \destination-0b&#13;
            .endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> macro modifies the values held in the X16 and X17 registers. The ARM API reserves these registers for exactly this purpose, so this is permissible. However, you should always remember that this macro modifies X16 and X17.</p>&#13;
<p class="TX">The C stdlib provides the magic pointer <span class="SANS_TheSansMonoCd_W5Regular_11">__errno_location</span> to return a pointer to C’s <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> variable in X0. The <span class="SANS_TheSansMonoCd_W5Regular_11">getErrno</span> macro expands to a function call that retrieves this value and returns it in W0:</p>&#13;
<pre id="pre-1105"><code>// aoaa.inc (cont.)&#13;
//&#13;
// getErrno&#13;
//&#13;
// Retrieves C errno value and returns&#13;
// it in X0:&#13;
&#13;
            .extern __errno_location&#13;
            .macro  getErrno&#13;
            bl      __errno_location&#13;
            ldr     w0, [x0]&#13;
            .endm</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_786" aria-label="786"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">ccne</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">ccnle</span> equates define useful bit patterns for use by the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction:</p>&#13;
<pre id="pre-1106"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Constants to use in the immediate field of&#13;
// ccmp:&#13;
&#13;
//          NZCV&#13;
    .equ    ccne,   0b0000          // Z = 0&#13;
    .equ    cceq,   0b0100          // Z = 1&#13;
    .equ    cchi,   0b0010          // C = 1&#13;
    .equ    cchs,   0b0110          // Z = 1, C = 1&#13;
    .equ    cclo,   0b0000          // Z = 0, C = 0&#13;
    .equ    ccls,   0b0100          // Z = 1, C = 0&#13;
    .equ    ccgt,   0b0000          // Z = 0, N = V&#13;
    .equ    ccge,   0b0100          // Z = 1, N = V&#13;
    .equ    cclt,   0b0001          // Z = 0, N! = V&#13;
    .equ    ccle,   0b0101          // Z = 1, N! = V&#13;
&#13;
    .equ    cccs,   0b0010          // C = 1&#13;
    .equ    cccc,   0b0000          // C = 0&#13;
    .equ    ccvs,   0b0001          // V = 1&#13;
    .equ    ccvc,   0b0000          // V = 0&#13;
    .equ    ccmi,   0b1000          // N = 1&#13;
    .equ    ccpl,   0b0000          // N = 0&#13;
&#13;
    .equ    ccnhi,  0b0100          // Not HI = LS, Z = 1, C = 0&#13;
    .equ    ccnhs,  0b0000          // Not HS = LO, Z = 0, C = 0&#13;
    .equ    ccnlo,  0b0110          // Not LO = HS, Z = 1, C = 1&#13;
    .equ    ccnls,  0b0010          // Not LS = HI, C = 1&#13;
&#13;
    .equ    ccngt,  0b0101          // Not GT = LE, Z = 1, N! = V&#13;
    .equ    ccnge,  0b0001          // Not GE = LT, Z = 0, N! = V&#13;
    .equ    ccnlt,  0b0100          // Not LT = GE, Z = 1, N = V&#13;
    .equ    ccnle,  0b0000          // Not LE = GT, Z = 0, N = V</code></pre>&#13;
<p class="TX">The opposite branches are useful when writing code to simulate HLL-like control structures such as <span class="SANS_TheSansMonoCd_W5Regular_11">if</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">then</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">else</span> statements:</p>&#13;
<pre id="pre-1107"><code>// aoaa.inc (cont.)&#13;
//&#13;
// Opposite conditions (useful with all conditional instructions)&#13;
&#13;
#define nhi ls&#13;
#define nhs lo&#13;
#define nlo hs&#13;
#define nls hi&#13;
#define ngt le&#13;
#define nge lt&#13;
#define nlt ge&#13;
#define nle gt&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_787" aria-label="787"/>// Opposite branches&#13;
&#13;
        .macro  bnlt, dest&#13;
        bge     \dest&#13;
        .endm&#13;
&#13;
        .macro  bnle, dest&#13;
        bgt     \dest&#13;
        .endm&#13;
&#13;
        .macro  bnge, dest&#13;
        blt     \dest&#13;
        .endm&#13;
&#13;
        .macro  bngt, dest&#13;
        ble     \dest&#13;
        .endm&#13;
&#13;
        .macro  bnlo, dest&#13;
        bhs     \dest&#13;
        .endm&#13;
&#13;
        .macro  bnls, dest&#13;
        bhi     \dest&#13;
        .endm&#13;
&#13;
        .macro  bnhs, dest&#13;
        blo     \dest&#13;
        .endm&#13;
&#13;
        .macro  bnhi, dest&#13;
        bls     \dest&#13;
        .endm&#13;
#endif // aoaa_inc</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> statement terminates the <span class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</span> statement appearing at the very beginning of the source file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h3 class="H1" id="sec34"><span id="h1-141"/><span class="SANS_Futura_Std_Bold_B_11">13.5 Generating Macros by Another Macro</span></h3>&#13;
<p class="TNI1">You can use one macro to write another, as the following code demonstrates:</p>&#13;
<pre id="pre-1108"><code>// Variant of the proc macro that deals&#13;
// with procedures that have varying&#13;
// parameter lists. This macro creates&#13;
// a macro named "_<var>name</var>" (where <var>name</var> is&#13;
// the procedure name) that loads all&#13;
// but the first parameters into registers&#13;
// X1..X7 and stores those values onto&#13;
// the stack.&#13;
//&#13;
// Limitation: maximum of seven arguments&#13;
&#13;
        .macro  varProc pName:req&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_788" aria-label="788"/>// Create a macro specifically for this func:&#13;
&#13;
        .macro  _\pName parms:vararg&#13;
reg     =       1&#13;
        .irp    parm, \parms&#13;
        .irpc   rnum, 1234567&#13;
        .if     reg==\rnum&#13;
        lea     x\rnum, \parm&#13;
        ldr     x\rnum, [x\rnum]&#13;
        mstr    x\rnum, [sp, #(reg-1)*8]&#13;
        .endif&#13;
        .endr&#13;
reg     =       reg + 1&#13;
        .endr&#13;
        bl      \pName&#13;
        .endm&#13;
&#13;
// Finish off the varProc macro (just like&#13;
// the proc macro from aoaa.inc):&#13;
&#13;
\pName\().isOpenProcDCL = 1&#13;
\pName:&#13;
        .endm</code></pre>&#13;
<p class="TX">As the comment states, this variant of the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> macro creates a new <span class="SANS_TheSansMonoCd_W5Regular_11">varProc</span> macro you can use to invoke the procedure with HLL-like syntax. Consider the following invocation of this macro:</p>&#13;
<pre id="pre-1109"><code>// Demonstrate the varProc macro&#13;
// (creates a macro name _someFunc&#13;
// that will load parameters and&#13;
// then branch to printf):&#13;
&#13;
        varProc someFunc&#13;
        b       printf&#13;
        endp    someFunc</code></pre>&#13;
<p class="TX">This expands to the following code:</p>&#13;
<pre id="pre-1110"><code>        .macro _someFunc, parms:vararg&#13;
reg     =       1&#13;
        .irp    parm, \parms&#13;
        .irpc   rnum, 1234567&#13;
        .if     reg==\rnum&#13;
        lea     x\rnum, \parm&#13;
        ldr     x\rnum, [x\rnum]&#13;
        mstr    x\rnum, [sp, #(reg-1)*8]&#13;
        .endif&#13;
        .endr&#13;
reg     =       reg + 1&#13;
        .endr&#13;
        bl      someFunc&#13;
        .endm</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_789" aria-label="789"/>Invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">_someFunc</span> macro as follows:</p>&#13;
<pre id="pre-1111"><code>    lea x0, fmtStr&#13;
    _someFunc i, j</code></pre>&#13;
<p class="TX">This generates the following code</p>&#13;
<pre id="pre-1112"><code>    lea x0, fmtStr&#13;
&#13;
// Macro expansion:&#13;
&#13;
    lea x1, i&#13;
    ldr x1, [x1]&#13;
    lea x2, j&#13;
    ldr x2, [x2]&#13;
    bl  someFunc</code></pre>&#13;
<p class="Continued1">and then generates <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> branches to <span class="SANS_TheSansMonoCd_W5Regular_11">printf</span>, essentially making this a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function.</p>&#13;
<p class="TX">You could have written a macro to invoke <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> directly (handling the arguments), but you’d have to write such a macro for every function you want to call using HLL-like syntax. Having the <span class="SANS_TheSansMonoCd_W5Regular_11">varProc</span> macro automatically write this macro spares you this repetitive task.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">varProc</span> macro has the severe limitation that its parameters must be global memory locations (no register, local variables, or other types of memory operands). While this macro may not be especially useful, it serves to demonstrate how one macro can write another. I’ll leave it as an exercise for you to expand this macro to handle other types of operands.</p>&#13;
<p class="TX">Note that if a macro creates another macro, it must use an undefined name when creating the new macro. The examples in this section achieved this by having the invoker supply the new macro name as an argument to the macro that creates the new macro. It is also possible to use the <span class="SANS_TheSansMonoCd_W5Regular_11">.purgem</span> directive to delete the new macro’s name prior to creating it. However, keep in mind that the macro name must already exist when using <span class="SANS_TheSansMonoCd_W5Regular_11">.purgem</span> to delete it. On the first invocation of the creating macro, this could be a problem since the macro to create might not exist on the first invocation. This is easily remedied by providing an empty macro prior to the first invocation of the creating macro:</p>&#13;
<pre id="pre-1113"><code>.macro  createdMacro&#13;
  <var>Empty body</var>&#13;
.endm&#13;
&#13;
.macro  createMacro&#13;
&#13;
.purgem createdMacro&#13;
.macro  createdMacro&#13;
&#13;
  <var>Macro body</var>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_790" aria-label="790"/>.endm // createdMacro&#13;
  .&#13;
  .&#13;
  .&#13;
.endm</code></pre>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">createdMacro</span> already exists on the first invocation of <span class="SANS_TheSansMonoCd_W5Regular_11">createMacro</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">.purgem</span> statement will not generate an error message. After the first invocation, future invocations of <span class="SANS_TheSansMonoCd_W5Regular_11">createMacro</span> will delete the version of <span class="SANS_TheSansMonoCd_W5Regular_11">createdMacro</span> created in the previous invocation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h3 class="H1" id="sec35"><span id="h1-142"/><span class="SANS_Futura_Std_Bold_B_11">13.6 Choosing Between Gas Macros and CPP Macros</span></h3>&#13;
<p class="TNI1">Glancing at the GNU CPP documentation (<i><a href="https://gcc.gnu.org/onlinedocs/cpp/">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org<wbr/>/onlinedocs<wbr/>/cpp<wbr/>/</a></i>), you’ll find that the GNU folks suggest using the Gas built-in macro facilities rather than the CPP. If the people who wrote CPP and Gas suggest using the Gas macro processor rather than CPP, shouldn’t you take that suggestion seriously?</p>&#13;
<p class="TX">If you could use only one macro processor, you could make a strong case for using the Gas macro processor rather than CPP. CPP is not a very powerful macro processor, and macro abuse by C/C++ programmers has given it a bad reputation. Gas’s macro processor, in many respects, is clearly superior. Gas’s macro facilities would make the better choice between the two.</p>&#13;
<p class="TX">However, who says you have to use only one or the other? Why not both? CPP and Gas each have strengths and weaknesses that tend to be complementary. Although Gas’s macro facilities are more powerful than CPP’s, compared with other assemblers out there—such as the Microsoft Macro Assembler (MASM) or the High-Level Assembler (HLA)—Gas’s macro facilities aren’t particularly impressive. Anything you can use to boost the power of Gas’s macros is a good thing. CPP also has some neat features that Gas lacks (such as functional-style macro invocations), and Gas, of course, has many features that CPP lacks (such as multiline macro definitions). If you’re careful, using both macro processors gives you abilities above and beyond those of either. That’s a good thing, so combining the power of CPP and Gas is something I wholeheartedly recommend.</p>&#13;
<p class="TX">Given that you have two CTLs available to you when compiling a Gas source file (at least when using a <i>.S</i> suffix), which CTL constructs should you use? Most of the time, it doesn’t matter much; if either CTL would work, the choice is up to you, though sticking with Gas’s CTL is probably the safest choice if all other factors are equal. However, because the two have differing capabilities, at times you might need to pick one over the other.</p>&#13;
<p class="TX">For example, CPP’s macro definitions look like functions and can appear almost anywhere (outside of comments) in the source file. They are great for writing address expression functions. The following code demonstrates the use of functional-style CPP macros:</p>&#13;
<pre id="pre-1114"><code>mov x0, #cppMacro(0, x)</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_791" aria-label="791"/>In this example, a Gas macro wouldn’t work because Gas macros don’t support functional-style invocations.</p>&#13;
<p class="TX">On the other hand, CPP macros are limited to producing a single line of text. Therefore, Gas macros are necessary when you want to emit a sequence of instructions:</p>&#13;
<pre id="pre-1115"><code>lea x0, someLabel  // Expands to two instructions!</code></pre>&#13;
<p class="Continued1">Also note that CPP macros can cause you problems if you attempt to use the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> symbol (stringify in CPP, immediate operand in Gas) in your macro expansion.</p>&#13;
<p class="TX">Gas also supports a richer set of conditional assembly statements, along with CTL looping statements. This makes Gas more appropriate for macros that emit a large amount of data or a large number of statements. I generally prefer CPP macros for simple address expression functions and use Gas macros when I need to expand the macro to actual statements.</p>&#13;
<p class="TX">Deciding whether to use CPP statements versus Gas’s <span class="SANS_TheSansMonoCd_W5Regular_11">.set</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> directives for simple constant declarations is less clear-cut. For simple integer constants, Gas’s equate directives work fine. For nonintegral values, CPP works better. The following example demonstrates defining string constants with CPP macros:</p>&#13;
<pre id="pre-1116"><code>#define aStr "Hello, World!"       // This works.&#13;
//      .set aStr, "Hello, World!" // This does not.&#13;
&#13;
        .asciz aStr</code></pre>&#13;
<p class="TX">For integer expressions, Gas’s equates tend to work better:</p>&#13;
<pre id="pre-1117"><code>// #define a (a+1)  // Generally doesn't work as expected&#13;
    .set a, a+1     // Works fine (assuming some previous definition of a)</code></pre>&#13;
<p class="TX">Finally, always keep in mind that CPP processes its CTL statements in a preprocessing pass before assembly takes place, meaning CPP is blissfully unaware of symbols and other tokens specific to the assembly language source file. For example:</p>&#13;
<pre id="pre-1118"><code>a:   .byte 0&#13;
      .&#13;
      .&#13;
      .&#13;
#ifdef a    // a is undefined to CPP; it's a Gas symbol.&#13;
 .&#13;
 .&#13;
 .&#13;
#endif&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_792" aria-label="792"/>    .ifdef a  // a is defined to Gas's conditional assembly.&#13;
     .&#13;
     .&#13;
     .&#13;
    .endif</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> symbol would believe that the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> is undefined (even though it was defined earlier in the Gas source file). Remember, CPP conditional compilation statements know only about symbols created with <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h3 class="H1" id="sec36"><span id="h1-143"/><span class="SANS_Futura_Std_Bold_B_11">13.7 Moving On</span></h3>&#13;
<p class="TNI1">The Gas and CPP CTLs greatly expand the capabilities of the Gas assembler. Using these facilities, including constant definitions, macro definitions, conditional compilation and assembly, and so on, can reduce the effort you need to write assembly language source code.</p>&#13;
<p class="TX">This chapter covered the basic information you need to employ the Gas and CPP CTLs in your assembly language source files, beginning with a discussion of CPP. The second half of this chapter discussed the Gas CTL, including the error and warning directives, conditional assembly, compile-time looping directives, and Gas macros. Next, this chapter described the internal source code for the <i>aoaa.inc</i> header file that you’ve used extensively since <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. The chapter concluded by contrasting the CPP CTL and the Gas macro facilities, discussing when you should pick one system over the other.</p>&#13;
<p class="TX">Now that this book has described the Gas CTL, its example code will begin to use the macro facilities, starting in the next chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h3 class="H1" id="sec37"><span id="h1-144"/><span class="SANS_Futura_Std_Bold_B_11">13.8 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">You can review the GNU CPP documentation at <i><a href="https://gcc.gnu.org/onlinedocs/cpp/">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org<wbr/>/onlinedocs<wbr/>/cpp<wbr/>/</a></i>.</li>&#13;
<li class="BL">Find the Gas documentation (including macros) at <i><a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_toc.html">https://<wbr/>ftp<wbr/>.gnu<wbr/>.org<wbr/>/old<wbr/>-gnu<wbr/>/Manuals<wbr/>/gas<wbr/>-2<wbr/>.9<wbr/>.1<wbr/>/html<wbr/>_node<wbr/>/as<wbr/>_toc<wbr/>.html</a></i>. For more on Gas macros in particular, see <i><a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_107.html">https://<wbr/>ftp<wbr/>.gnu<wbr/>.org<wbr/>/old<wbr/>-gnu<wbr/>/Manuals<wbr/>/gas<wbr/>-2<wbr/>.9<wbr/>.1<wbr/>/html<wbr/>_node<wbr/>/as<wbr/>_107<wbr/>.html</a></i>.</li>&#13;
<li class="BL">For information on advanced CPP macros, check out “C Pre-Processor Magic” by Jonathan Heathcote at <i><a href="http://jhnet.co.uk/articles/cpp_magic">http://<wbr/>jhnet<wbr/>.co<wbr/>.uk<wbr/>/articles<wbr/>/cpp<wbr/>_magic</a></i> and <i><a href="https://github.com/18sg/uSHET/blob/master/lib/cpp_magic.h">https://<wbr/>github<wbr/>.com<wbr/>/18sg<wbr/>/uSHET<wbr/>/blob<wbr/>/master<wbr/>/lib<wbr/>/cpp<wbr/>_magic<wbr/>.h</a></i>.</li>&#13;
<li class="BL">You can check the C Preprocessor Tricks, Tips, and Idioms GitHub site to find CPP tricks: <i><a href="https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms">https://<wbr/>github<wbr/>.com<wbr/>/pfultz2<wbr/>/Cloak<wbr/>/wiki<wbr/>/C<wbr/>-Preprocessor<wbr/>-tricks,<wbr/>-tips,<wbr/>-and<wbr/>-idioms</a></i>.</li>&#13;
<li class="BL">Find the Boost CPP library at <i><a href="https://www.boost.org/doc/libs/1_57_0/libs/preprocessor/doc/index.html">https://<wbr/>www<wbr/>.boost<wbr/>.org<wbr/>/doc<wbr/>/libs<wbr/>/1<wbr/>_57<wbr/>_0<wbr/>/libs<wbr/>/preprocessor<wbr/>/doc<wbr/>/index<wbr/>.html</a></i>.</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_793" aria-label="793"/>Embedded Artistry has an article on “Exploiting the Preprocessor for Fun and Profit” by Klemens Morgenstern: <i><a href="https://embeddedartistry.com/blog/2020/07/27/exploiting-the-preprocessor-for-fun-and-profit/">https://<wbr/>embeddedartistry<wbr/>.com<wbr/>/blog<wbr/>/2020<wbr/>/07<wbr/>/27<wbr/>/exploiting<wbr/>-the<wbr/>-preprocessor<wbr/>-for<wbr/>-fun<wbr/>-and<wbr/>-profit<wbr/>/</a></i>.</li>&#13;
<li class="BL">Learn more about macro metaprogramming from Thomas Mailund’s blog at <i><a href="https://mailund.dk/posts/macro-metaprogramming/">https://<wbr/>mailund<wbr/>.dk<wbr/>/posts<wbr/>/macro<wbr/>-metaprogramming<wbr/>/</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-32">&#13;
<p class="BH" id="box-32"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What does</span> <span class="SANS_Futura_Std_Book_Oblique_11">CTL</span> <span class="SANS_Futura_Std_Book_11">stand for?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  When do CTL programs execute?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What directive would you use to print a message (not an error) during preprocessing (CPP)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What directive would you use to print a message (not an error) during assembly?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What directive would you use to print an error message during CPP preprocessing?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  What directive would you use to print an error message during assembly?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What directive would you use to create a CPP CTL variable?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What directive(s) could you use to create a Gas CTL variable?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  What are the CPP conditional compilation directives?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  What are the Gas conditional assembly directives?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">11.  What macro could you use to create preprocessor-time loops?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">12.  What directive(s) could you use to create assembly-time loops?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">13.  What directive would you use to extract the characters from a macro parameter object in a loop?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">14.  What directive(s) do you use to define a CPP macro?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">15.  What directive(s) do you use to define a Gas macro?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">16.  How do you invoke a macro in a Gas source file?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">17.  How do you specify macro parameters in a CPP macro declaration?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">18.  How do you specify macro parameters in a Gas macro declaration?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">19.  How do you specify that a Gas macro parameter is required?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">20.  How do you specify that a Gas macro parameter is optional?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">21.  How do you specify a variable number of CPP macro arguments?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">22.  How do you specify a variable number of Gas macro arguments?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">23.  Explain how you can manually test whether a Gas macro parameter is present (without using the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">:req</span> <span class="SANS_Futura_Std_Book_11">suffix).</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">24.  What Gas directive would you use (generally inside a conditional assembly sequence) to immediately terminate macro expansion without processing any additional statements in the macro?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>