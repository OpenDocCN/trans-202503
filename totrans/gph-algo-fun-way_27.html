<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="backmatter" aria-labelledby="appendix_C">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_369" aria-label="369"/>&#13;
<hgroup>&#13;
<h1 class="TITLE" id="appendix_C">&#13;
<span class="APN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">C</samp></span>&#13;
<span class="APH"><samp class="SANS_Dogma_OT_Bold_B_11">UNION-FIND</samp></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Kruskal’s algorithm, randomized maze generation, and single-linkage clustering from <span class="chapterintro_Xref"><a href="chapter10.xhtml">Chapter 10</a></span> all use a data structure called <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> to represent the disjoint sets of nodes corresponding to the different connected components in a graph. This data structure allows the algorithms to efficiently (1) determine whether two nodes are already in the same connected component and (2) merge two different components. For completeness, this appendix describes and provides the code for this data structure.</p>&#13;
<p class="TX">We begin by providing a very brief overview of union-find data structures, followed by just enough code to implement the algorithms in this book. We encourage interested readers to explore additional resources. The “Union-Find” chapter of Daniel Zingaro’s <i>Algorithmic Thinking</i>, 2nd edition <span role="doc-pagebreak" epub:type="pagebreak" id="pg_370" aria-label="370"/>(No Starch Press, 2023), provides an accessible introduction to these fascinating data structures as well as additional optimizations.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h-283"/><samp class="SANS_Futura_Std_Bold_B_11">The Union-Find Data Structure</samp></h2>&#13;
<p class="TNI1">The <i>union-find</i> data structure (also called a <i>disjoint sets</i> data structure) is commonly viewed as a list of trees (also called a <i>forest</i> of trees). Each item is represented as a tree node and each set is encoded as a tree. Items are considered to be in the same set if and only if they are in the same tree.</p>&#13;
<p class="TX"><a href="#figC-1">Figure C-1</a> shows an example union-find data structure with 11 items organized into three sets: {0, 1, 6, 7, 10}, {3, 5, 9}, {2, 4, 8}. As shown in the figure, the trees are not restricted to be binary (at most two children per node), nor do they enforce an ordering over the elements.</p>&#13;
<figure class="IMG"><img id="figC-1" class="img60" src="../images/f0c001.jpg" alt="The left-most tree has root 0 and nodes 0, 1, 6, 7, and 10. The middle tree has root 5 and nodes 5, 3, and 9. The right-most tree has root 2 and nodes 2, 4, and 8." width="906" height="356"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure C-1: Three disjoint sets represented as trees</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each set in this data structure is uniquely identified by the index number of the root node. The trees in <a href="#figC-1">Figure C-1</a> have labels 0, 5, and 2 from left to right. We can easily retrieve the set label for any item by traversing from that item’s node to the root of the tree. For example, we could identify the set label for item 9 by progressing from node 9 to node 3 to node 5 and then returning 5.</p>&#13;
<p class="TX">We create the union of sets by combining trees. There are a variety of ways to append one tree to another. In this appendix, we’ll use the common optimization of appending the root node of the tree with fewer nodes to the root node of a larger tree. <a href="#figC-2">Figure C-2</a> shows an example of combining the sets rooted at 0 and 2 into a single set. Since the tree rooted at node 2 has fewer nodes, we set the parent pointer of node 2 to node 0, effectively adding the subtree as a child.</p>&#13;
<figure class="IMG"><img id="figC-2" class="img40" src="../images/f0c002.jpg" alt="The combined tree has root node 0. Node 2 has a parent pointer into node 0." width="561" height="362"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure C-2: Combining two trees</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_371" aria-label="371"/>For illustration purposes, in this section we describe a minimalist <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure that uses an explicit forest-of-trees implementation to make the tree-based operations clear. More efficient optimizations are possible, such as array-based implementations of the data structure and the use of path compression to reduce tree height.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h-284"/><samp class="SANS_Futura_Std_Bold_B_11">UnionFind</samp></h2>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure partitions elements into different (and disjoint) sets such that each element belongs to exactly one set. For Kruskal’s algorithm, these sets represent the different connected components within the graph. Nodes within the same component are part of the same set.</p>&#13;
<p class="TX">As discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, this data structure is powerful because it facilitates performing two operations very quickly. The first operation is to determine whether two points are in the same set, which is necessary for determining if two nodes are already connected. The second operation is merging two sets, which is necessary for connecting components.</p>&#13;
<p class="TX">This appendix provides the code for the following functions that make up the union-find interface:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">are_disjoint(i, j)</samp><b> </b>Determines whether two elements <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are in different sets</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">union_sets(i, j)</samp><b> </b>Merges the set with element <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and the set with element <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> into a single set</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">find_set(i)</samp><b> </b>Returns a unique label for the set containing element <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp></p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H2" id="sec3"><span id="h-285"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UnionFindNode</samp></h3>&#13;
<p class="TNI1">Since we only ever need to travel up the tree (rather than down), each node only needs to store two pieces of information: its own index number and the pointer to its parent. Nodes do not need to store pointers to their children. We can define a minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFindNode</samp> as follows:</p>&#13;
<pre><code>class UnionFindNode: &#13;
    def __init__(self, label: int):&#13;
        self.label = label&#13;
        self.parent = None&#13;
</code></pre>&#13;
<p class="TX">We initially set the parent of a node to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate that it is a root node.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H2" id="sec4"><span id="h-286"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UnionFind Class</samp></h3>&#13;
<p class="TNI1">Our minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> object tracks three pieces of information:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">nodes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>A list of <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFindNode</samp> objects indexed by their label</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">set_sizes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>A list that maps the set’s label to its size</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_disjoint_sets</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>The number of disjoint sets</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_372" aria-label="372"/>We use a list to store the nodes because we only need to support contiguous integer labels for the algorithms in this book. However, we could support more general labels, such as strings, by using a dictionary to map each label to its corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFindNode</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_disjoint_sets</samp> attribute could be computed from the other attributes but is explicitly stored for simplicity.</p>&#13;
<p class="TX">Using these attributes, we define a constructor to set up the initial state of the union-find data structure:</p>&#13;
<pre><code>class UnionFind:&#13;
    def __init__(self, num_sets: int): &#13;
        self.nodes: list = [UnionFindNode(i) for i in range(num_sets)]&#13;
        self.set_sizes: list = [1 for i in range(num_sets)]&#13;
        self.num_disjoint_sets: int = num_sets&#13;
</code></pre>&#13;
<p class="TX">The constructor takes the number of items (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_sets</samp>) and constructs both the full list of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>) and the list of sizes for each set (<samp class="SANS_TheSansMonoCd_W5Regular_11">set_sizes</samp>). Since the items all start in disjoint sets, the constructor initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">num_sets</samp> sizes to 1 for each item. Finally, it sets the count of disjoint sets (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_disjoint_sets</samp>).</p>&#13;
<p class="TX">Finding the label of a set corresponds to walking up the tree and returning the label of the root node:</p>&#13;
<pre><code>def find_set(self, label: int) -&gt; int: &#13;
    if label &lt; 0 or label &gt;= len(self.nodes):&#13;
        raise IndexError&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> current: UnionFindNode = self.nodes[label]&#13;
    while current.parent is not None:&#13;
        current = current.parent&#13;
    return current.label&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_set()</samp> function starts by checking the bounds of the label and raising an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp> if the label is out of bounds. It then starts at the current node <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to walk up the tree to the parent. It returns the label of the parent node as the identifier for the set.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">are_disjoint()</samp> function uses two calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">find_set()</samp> to extract the set labels for each item and test whether they are equal:</p>&#13;
<pre><code>def are_disjoint(self, label1: int, label2: int) -&gt; bool: &#13;
    return self.find_set(label1) != self.find_set(label2)&#13;
</code></pre>&#13;
<p class="TX">If the set labels are the same, the items must share a root node and thus be in the same set.</p>&#13;
<p class="TX">Taking the union of two sets consists of appending the trees:</p>&#13;
<pre><code>def union_sets(self, label1: int, label2: int): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> set1_label: int = self.find_set(label1)&#13;
    set2_label: int = self.find_set(label2)&#13;
    if set1_label == set2_label:&#13;
        return<span role="doc-pagebreak" epub:type="pagebreak" id="pg_373" aria-label="373"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if self.set_sizes[set1_label] &lt; self.set_sizes[set2_label]:&#13;
        small = set1_label&#13;
        large = set2_label&#13;
    else:&#13;
        small = set2_label&#13;
        large = set1_label&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> self.nodes[small].parent = self.nodes[large]&#13;
    self.set_sizes[large] += self.set_sizes[small]&#13;
    self.set_sizes[small] = 0&#13;
    self.num_disjoint_sets -= 1&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">union_sets()</samp> function starts by finding the label for each set and checking whether they are already equal to each other <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If so, there is nothing to be done and the function returns. If not, the function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_sizes</samp> list to determine which tree has fewer nodes <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and appends the root node of the smaller tree as a child of the larger tree’s root node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. Finally, the function updates the remaining data by computing the new size of the larger tree, setting the size entry of the smaller tree to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (since it is no longer a disjoint set), and updating the number of disjoint sets.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>