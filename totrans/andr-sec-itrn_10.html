<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Device Security"><div class="titlepage"><div><div><h1 class="title"><a id="device_security"/>Chapter 10. Device Security</h1></div></div></div><p><a id="iddle1572" class="indexterm"/>Until now, we’ve focused on how Android implements sandboxing and privilege separation in order to isolate applications from one another and the core OS. In this chapter, we look at how Android ensures OS integrity and protects device data from attackers that have physical access to a device. We start with a brief description of Android’s bootloader and recovery OS, then discuss Android’s verified boot feature, which guarantees that the <span class="emphasis"><em>system</em></span> partition is not modified by malicious programs. Next we look at how Android encrypts the <span class="emphasis"><em>userdata</em></span> partition, which hosts OS configuration files and application data. This guarantees that the device can’t be booted without the decryption password and that user data can’t be extracted even by direct access to the device’s flash memory. We then show how Android’s screen locking functionality is implemented, and how unlock patterns, PINs, and passphrases are hashed and stored on the device.</p><p>We’ll also discuss secure USB debugging, which authenticates hosts that connect to the <span class="emphasis"><em>Android Debug Bridge (ADB)</em></span> daemon over USB and requires <a id="iddle1289" class="indexterm"/><a id="iddle1586" class="indexterm"/><a id="iddle1587" class="indexterm"/><a id="iddle1797" class="indexterm"/><a id="iddle2360" class="indexterm"/><a id="iddle2361" class="indexterm"/>users to explicitly allow access for each host. Because ADB access over USB allows execution of privileged operations such as application installation, full backup, and filesystem access (including full access to external storage), this feature helps prevent unauthorized access to device data and applications on devices that have ADB debugging enabled. Finally, we describe the implementation and archive encryption format of Android’s full backup feature.</p><div class="sect1" title="Controlling OS Boot-Up and Installation"><div class="titlepage"><div><div><h1 class="title"><a id="controlling_os_boot-up_and_installation"/>Controlling OS Boot-Up and Installation</h1></div></div></div><p>Given physical access to a device, an attacker can access or modify user and system data not only via higher-level OS constructs such as files and directories, but also by accessing memory or raw disk storage directly. Such direct access can be achieved by physically interfacing with the device’s electronic components by, for example, disassembling the device and connecting to hidden hardware debug interfaces or desoldering flash memory and reading the contents with a specialized device.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p><span class="emphasis"><em>Such hardware attacks are beyond the scope of this book; see <a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a> of the</em></span> Android Hacker’s Handbook <span class="emphasis"><em>(Wiley, 2014) for an introduction to this topic.</em></span></p></div><p>A less intrusive, but still powerful way to gain access to this data is to use the device update mechanism to modify system files and remove access restrictions, or boot an alternative operating system that allows direct access to storage devices. Most consumer Android devices are locked down by default so that those techniques are either not possible or require possession of a code signing key, typically available only to the device manufacturer.</p><p>In the next sections, we briefly discuss how Android’s bootloader and recovery OS regulate access to boot images and device update mechanisms. (We’ll explore bootloader and recovery functionality in more detail in <a class="xref" href="ch13.html" title="Chapter 13. System Updates and Root Access">Chapter 13</a>.)</p><div class="sect2" title="Bootloader"><div class="titlepage"><div><div><h2 class="title"><a id="bootloader"/>Bootloader</h2></div></div></div><p>A <span class="emphasis"><em>bootloader</em></span> is a specialized, hardware-specific program that executes when a device is first powered on (coming out of reset for ARM devices). Its purpose is to initialize device hardware, optionally provide a minimal device configuration interface, and then find and start the operating system.</p><p>Booting a device typically requires going through different stages, which may involve a separate bootloader for each stage—but we’ll refer to a single, aggregate bootloader that includes all boot stages, for the sake of simplicity. Android bootloaders are typically proprietary and specific to the system on a chip (SoC) that the device is built upon. Device and SoC manufacturers provide different functionality and levels of protection in their bootloaders, but most bootloaders support a <span class="emphasis"><em>fastboot</em></span>, or more generally, <span class="emphasis"><em>download mode</em></span>, which allows for the writing (usually called <span class="emphasis"><em>flashing</em></span>) of raw partition images to the device’s persistent storage, as well as booting <a id="iddle1588" class="indexterm"/><a id="iddle2362" class="indexterm"/><a id="iddle2368" class="indexterm"/><a id="iddle2573" class="indexterm"/>transient system images (without flashing them to the device). Fastboot mode is enabled by a special hardware key combination applied while the device is booting, or by sending the <span class="emphasis"><em>reboot bootloader</em></span> command via ADB.</p><p>In order to ensure device integrity, consumer devices are shipped with locked bootloaders, which either disallow flashing and booting system images completely or allow it only for images that have been signed by the device manufacturer. Most consumer devices allow for unlocking the boot-loader, which removes fastboot restrictions and image signature checks. Unlocking the bootloader typically requires formatting the <span class="emphasis"><em>userdata</em></span> partition, thus ensuring that a malicious OS image cannot get access to existing user data.</p><p>On some devices, unlocking the bootloader is an irreversible procedure, but most devices provide a way to relock the bootloader and return it to its original state. This is typically implemented by storing a bootloader state flag on a dedicated system partition (typically called <code class="literal">param</code> or <code class="literal">misc</code>) that hosts various device metatdata. Relocking the bootloader simply resets the value of this flag.</p></div><div class="sect2" title="Recovery"><div class="titlepage"><div><div><h2 class="title"><a id="recovery"/>Recovery</h2></div></div></div><p>A more flexible way to update a device is via its recovery OS. The <span class="emphasis"><em>recovery OS</em></span>, or simply <span class="emphasis"><em>recovery</em></span>, is a minimal Linux-based OS that includes a kernel, RAM disk with various low-level tools, and a minimal UI that is typically operated using the device’s hardware buttons. The recovery is used to apply post-ship updates, generally delivered in the form of over-the-air (OTA) update packages. OTA packages include the new versions (or a binary patch) of updated system files and a script that applies the update. As we learned in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>, OTA files are also code signed with the private key of the device manufacturer. The recovery includes the public part of that key and verifies OTA files before applying them. This ensures that only OTA files that originate from a trusted party can modify the device OS.</p><p>The recovery OS is stored on a dedicated partition, just like the main Android OS. Therefore, it can be replaced by putting the bootloader into download mode and flashing a custom recovery image, which replaces the embedded public key, or does not verify OTA signatures at all. Such a recovery OS allows the main OS to be completely replaced with a build produced by a third party. A custom recovery OS can also allow unrestricted root access via ADB, as well as raw partition data acquisition. While the <span class="emphasis"><em>userdata</em></span> partition could be encrypted (see “<a class="xref" href="ch10.html#disk_encryption" title="Disk Encryption">Disk Encryption</a>”), making direct data access impossible, it is trivial to install a malicious program (rootkit) on the <span class="emphasis"><em>system</em></span> partition while in recovery mode. The rootkit can then enable remote access to the device when the main OS is booted and thus allow access to user data that is transparently decrypted when the main OS boots. Verified boot (discussed in the next section) can prevent this, but only if the device verifies the <span class="emphasis"><em>boot</em></span> partition using an unmodifiable verification key, stored in hardware.</p><p>An unlocked bootloader allows booting or flashing custom system images and direct access to system partitions. While Android security <a id="iddle1563" class="indexterm"/><a id="iddle1600" class="indexterm"/><a id="iddle1603" class="indexterm"/><a id="iddle1653" class="indexterm"/><a id="iddle1656" class="indexterm"/><a id="iddle1659" class="indexterm"/><a id="iddle2143" class="indexterm"/><a id="iddle2144" class="indexterm"/><a id="iddle2159" class="indexterm"/><a id="iddle2167" class="indexterm"/><a id="iddle3057" class="indexterm"/><a id="iddle3060" class="indexterm"/>features such as verified boot and disk encryption can limit the damage that a malicious system image flashed via an unlocked bootloader can do, controlling access to the bootloader is integral to protecting an Android device. Therefore the bootloader should only be unlocked on test or development devices, or relocked and returned to its original state immediately after modifying the system.</p></div></div><div class="sect1" title="Verified Boot"><div class="titlepage"><div><div><h1 class="title"><a id="verified_boot-id00021"/>Verified Boot</h1></div></div></div><p>Android’s verified boot implementation is based on the dm-verity device-mapper block integrity checking target.<sup>[<a id="ch10fn01" href="#ftn.ch10fn01" class="footnote">100</a>]</sup> <span class="emphasis"><em>Device-mapper</em></span><sup>[<a id="ch10fn02" href="#ftn.ch10fn02" class="footnote">101</a>]</sup> is a Linux kernel framework that provides a generic way to implement virtual block devices. It’s the basis of Linux’s Logical Volume Manager (LVM), and it’s used to implement full-disk encryption (using the dm-crypt target), RAID arrays, and even distributed replicated storage.</p><p>Device-mapper works by essentially mapping a virtual block device to one or more physical block devices and optionally modifying transferred data in transit. For example, dm-crypt (which is also the basis of Android’s <span class="emphasis"><em>userdata</em></span> partition encryption, as discussed in “<a class="xref" href="ch10.html#disk_encryption" title="Disk Encryption">Disk Encryption</a>”) decrypts read physical blocks and encrypts written blocks before committing them to disk. Thus, disk encryption is transparent to users of the virtual dm-crypt block device. Device-mapper targets can be stacked on top of each other, making it possible to implement complex data transformations.</p><div class="sect2" title="dm-verity Overview"><div class="titlepage"><div><div><h2 class="title"><a id="dm-verity_overview"/>dm-verity Overview</h2></div></div></div><p>Because dm-verity is a block integrity checking target, it transparently verifies the integrity of each device block as it’s being read from disk. If the block checks out, the read succeeds; if not, the read generates an I/O error as if the block were physically corrupted.</p><p>Under the hood, dm-verity is implemented using a precalculated hash tree (also called a <span class="emphasis"><em>Merkle tree</em></span>) that includes the hashes of all device blocks. The leaf nodes of the tree include hashes of physical device blocks, while intermediate nodes are hashes of their child nodes (hashes of hashes). The root node is called the <span class="emphasis"><em>root hash</em></span> and is based on all hashes in lower levels, as shown in <a class="xref" href="ch10.html#dm-verity_hash_tree" title="Figure 10-1. dm-verity hash tree">Figure 10-1</a>. Thus, a change even in a single device block will result in a change of the root hash, and in order to verify that a hash tree is genuine we only need to verify its root hash.</p><p>At runtime, dm-verity calculates the hash of each block when it’s read and verifies it by traversing the precalculated hash tree. Because reading data from a physical device is already a time-consuming operation, the <a id="iddle1413" class="indexterm"/><a id="iddle1602" class="indexterm"/><a id="iddle1658" class="indexterm"/><a id="iddle2639" class="indexterm"/><a id="iddle3059" class="indexterm"/><a id="iddle3063" class="indexterm"/>latency added by hashing and verification is relatively low. Furthermore, once verified, disk blocks are cached, and subsequent reads of the same block do not trigger integrity verification.</p><div class="figure"><a id="dm-verity_hash_tree"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00052"/><img src="figs/web/10fig01.png.jpg" alt="dm-verity hash tree"/></div></div><p class="title">Figure 10-1. dm-verity hash tree</p></div><p>Because dm-verity depends on a precalculated hash tree over all blocks of a device, the underlying device must be mounted read-only in order for verification to be possible. Most filesystems record mount times and other metadata in their superblock, so even if no files are changed at runtime, block integrity checks will fail if the underlying block device is mounted read-write. Even though this can be seen as a limitation, it works well for devices or partitions that hold system files, which are only changed by OS updates. Any other change indicates either OS or disk corruption, or that a malicious program is trying to modify the OS or masquerade as a system file.</p><p>Ultimately, dm-verity’s read-only requirement fits well with Android’s security model, which hosts only application data on a read-write partition and keeps OS files on the read-only <span class="emphasis"><em>system</em></span> partition.</p></div><div class="sect2" title="Android Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="android_implementation-id00022"/>Android Implementation</h2></div></div></div><p>The dm-verity device-mapper target was originally developed in order to implement verified boot in Chrome OS and was integrated into the mainline Linux kernel in version 3.4. It’s enabled with the <code class="literal">CONFIG_DM_VERITY</code> kernel configuration item.</p><p>Like Chrome OS, Android 4.4 also uses the dm-verity target, but the cryptographic verification of the root hash and mounting of verified partitions are implemented differently. The RSA public key used for verification is embedded in the boot partition under the <span class="emphasis"><em>verity_key</em></span> filename and is used to verify the dm-verity mapping table, which holds the locations of the target device and the offset of the hash table, as well as the root hash and salt.</p><p>The mapping table and its signature are part of the verity metadata block, which is written to disk directly after the last filesystem block of the target device. A partition is marked as verifiable by adding the <code class="literal">verify</code> flag to the Android-specific <span class="emphasis"><em>fs_mgr_flags</em></span> field of the device’s <span class="emphasis"><em>fstab</em></span> file. When Android’s filesystem manager encounters the <code class="literal">verify</code> flag in <span class="emphasis"><em>fstab</em></span>, it loads <a id="iddle1601" class="indexterm"/><a id="iddle1657" class="indexterm"/><a id="iddle3058" class="indexterm"/>the verity metadata from the block device specified in <span class="emphasis"><em>fstab</em></span> and verifies its signature using the included verity key. If the signature check succeeds, the filesystem manager parses the dm-verity mapping table and passes it to the Linux device-mapper, which uses the information contained in the mapping table in order to create a virtual dm-verity block device. This virtual block device is then mounted at the mount point specified in <span class="emphasis"><em>fstab</em></span> in place of the corresponding physical device. As a result, all reads from the underlying physical device are transparently verified against the pre-generated hash tree. Modifying or adding files, or even remounting the partition as read-write results in an integrity verification and an I/O error.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note02"/>Note</h3><p><span class="emphasis"><em>Because dm-verity is a kernel feature, in order for its integrity protection to be effective, the kernel that the device boots needs to be trusted. On Android, this requires verifying the boot partition, which also contains the root filesystem RAM disk (</em></span>initrd<span class="emphasis"><em>) and the verity public key. Kernel or boot image verification is a device-specific process, which is typically implemented in the device bootloader and relies on an unmodifiable signature verification key stored in hardware.</em></span></p></div></div><div class="sect2" title="Enabling Verified Boot"><div class="titlepage"><div><div><h2 class="title"><a id="enabling_verified_boot"/>Enabling Verified Boot</h2></div></div></div><p>The official Android documentation describes the procedure required to enable verified boot on Android as a multi-step process, which involves generating a hash tree, creating a dm-verity mapping table for the hash tree, signing the table, and generating and writing a verity metadata block to the target device.<sup>[<a id="ch10fn03" href="#ftn.ch10fn03" class="footnote">102</a>]</sup> In this section, we briefly describe the key steps of this process.</p><p>A dm-verity hash tree is generated with the <code class="literal">veritysetup</code> program, which is part of the <span class="emphasis"><em>cryptsetup</em></span> cryptographic volume management tools package. The <code class="literal">veritysetup</code> program can operate directly on block devices or generate a hash tree using a filesystem image, and write the hash table to a file. Android’s dm-verity implementation expects that the hash tree data to be stored on the same device as the target filesystem, so an explicit hash offset that points to a location after the verity metadata block must be specified when invoking <code class="literal">veritysetup</code>. <a class="xref" href="ch10.html#layout_of_a_disk_partition_prepared_for" title="Figure 10-2. Layout of a disk partition prepared for dm-verity verification">Figure 10-2</a> shows the layout of a disk partition prepared for use with dm-verity.</p><div class="figure"><a id="layout_of_a_disk_partition_prepared_for"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00053"/><img src="figs/web/10fig02.png.jpg" alt="Layout of a disk partition prepared for dm-verity verification"/></div></div><p class="title">Figure 10-2. Layout of a disk partition prepared for dm-verity verification</p></div><p>Generating the hash tree produces the root hash, which is used to build the dm-verity mapping table for the target device. A sample mapping table is shown in <a class="xref" href="ch10.html#android_dm-verity_device_mapping_table" title="Example 10-1. Android dm-verity device mapping table">Example 10-1</a>.</p><div class="example"><a id="android_dm-verity_device_mapping_table"/><p class="title">Example 10-1. Android dm-verity device mapping table</p><div class="example-contents"><pre class="programlisting">1➊ /dev/block/mmcblk0p21➋ /dev/block/mmcblk0p21➌ 4096➍ 4096➎
204800➏ 204809➐ sha256➑
1F951588516c7e3eec3ba10796aa17935c0c917475f8992353ef2ba5c3f47bcb➒
5f061f591b51bf541ab9d89652ec543ba253f2ed9c8521ac61f1208267c3bfb1➓</pre></div></div><p><a id="iddle2640" class="indexterm"/><a id="iddle3068" class="indexterm"/>As shown in the listing, the table is a single line (split across multiple lines for readability) that, besides the root hash ➒, contains the dm-verity version ➊, name of the underlying data and hash device (➋ and ➌), data and hash block sizes (➍ and ➎), data and hash disk offsets (➏ and ➐), hash algorithm ➑, and salt ➓.</p><p>The mapping table is signed using a 2048-bit RSA key, and along with the resulting PKCS#1 v1.5 signature, is used to form the 32 KB verity metadata block. <a class="xref" href="ch10.html#verity_metadata_block_contents" title="Table 10-1. Verity Metadata Block Contents">Table 10-1</a> shows the contents and size of each field of the metadata block.</p><div class="table"><a id="verity_metadata_block_contents"/><p class="title">Table 10-1. Verity Metadata Block Contents</p><div class="table-contents"><table summary="Verity Metadata Block Contents" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Field</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Size</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Value</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Magic number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Used by fs_mgr as a sanity check</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4 bytes</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>0xb001b001</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Metadata block version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4 bytes</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Currently 0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Signature</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Mapping table signature (PKCS#1 v1.5)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>256 bytes</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Mapping table length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Mapping table length in bytes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4 bytes</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Mapping table</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>dm-verity mapping table</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>variable</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>Padding</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>Zero-byte padding to 32k byte length</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>variable</p></td><td style=""> </td></tr></tbody></table></div></div><p>The RSA public key used for verification needs to be in mincrypt format (a minimalistic cryptographic library, also used by the stock recovery when verifying OTA file signatures), which is a serialization of mincrypt’s <code class="literal">RSAPublicKey</code> structure. The interesting thing about this structure is that it doesn’t simply include the key’s modulus and public exponent values, but contains pre-computed values used by mincrypt’s RSA implementation (based on Montgomery reduction). The public key is included in the root of the boot image under the <span class="emphasis"><em>verity_key</em></span> filename.</p><p>The last step needed to enable verified boot is to modify the device’s <span class="emphasis"><em>fstab</em></span> file in order to enable block integrity verification for the <span class="emphasis"><em>system</em></span> partition. This is simply a matter of adding the <code class="literal">verify</code> flag, as shown in <a class="xref" href="ch10.html#fstab_entry_for_a_dm-verity-formatted_pa" title="Example 10-2. fstab entry for a dm-verity-formatted partition verified">Example 10-2</a> (example <span class="emphasis"><em>fstab</em></span> file for Nexus 4).</p><div class="example"><a id="fstab_entry_for_a_dm-verity-formatted_pa"/><p class="title">Example 10-2. <span class="roman">fstab</span> entry for a dm-verity-formatted partition verified</p><div class="example-contents"><pre class="programlisting">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,barrier=1 wait,verify</pre></div></div><p><a id="iddle1579" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1722" class="indexterm"/><a id="iddle1807" class="indexterm"/><a id="iddle1839" class="indexterm"/><a id="iddle2059" class="indexterm"/><a id="iddle2083" class="indexterm"/><a id="iddle2369" class="indexterm"/>When the device boots, Android automatically creates a virtual dm-verity device based on the <span class="emphasis"><em>fstab</em></span> entry and the information in the mapping table (contained in the metadata block), and mounts it at <span class="emphasis"><em>/system</em></span> as shown in <a class="xref" href="ch10.html#dm-verity_virutal_block_device_mounted_a" title="Example 10-3. dm-verity virutal block device mounted at /system">Example 10-3</a>.</p><div class="example"><a id="dm-verity_virutal_block_device_mounted_a"/><p class="title">Example 10-3. dm-verity virutal block device mounted at <span class="roman">/system</span></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>mount|grep system</strong></span>
/dev/block/dm-0 /system ext4 ro,seclabel,relatime,data=ordered 0 0</pre></div></div><p>Now, any modifications to the system partition will result in read errors when reading the corresponding file(s). Unfortunately, system modifications by file-based OTA updates, which modify file blocks without updating verity metadata, also invalidate the hash tree. As mentioned in the official documentation, in order to be compatible with dm-verity-based verified boot, OTA updates should operate at the block level, ensuring that both file blocks and the hash tree and metadata are updated. This requires changing the current OTA update infrastructure, which is probably one of the reasons verified boot has yet to be deployed to production devices.</p></div></div><div class="sect1" title="Disk Encryption"><div class="titlepage"><div><div><h1 class="title"><a id="disk_encryption"/>Disk Encryption</h1></div></div></div><p>Android 3.0 introduced disk encryption along with device administrator policies (see <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a> for details) that can enforce mandatory device encryption as one of the several “enhancements for the enterprise” included in that release. Disk encryption has been available in all subsequent versions with relatively few changes until version 4.4, which introduced a new key derivation function (scrypt). This section describes how Android implements disk encryption and how encryption keys and meta-data are stored and managed.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note03"/>Note</h3><p><span class="emphasis"><em>The Android Compatibility Definition requires that “IF the device has lockscreen, the device MUST support full-disk encryption.”</em></span><sup>[<a id="ch10fn04" href="#ftn.ch10fn04" class="footnote">103</a>]</sup></p></div><p><span class="emphasis"><em>Disk encryption</em></span> uses an encryption algorithm to convert every bit of data that goes to disk to ciphertext, ensuring that data cannot be read from the disk without the decryption key. <span class="emphasis"><em>Full-disk encryption (FDE)</em></span> promises that everything on disk is encrypted, including operating system files, cache, and temporary files. In practice, a small part of the OS, or a separate OS loader, must be kept unencrypted so that it can obtain the decryption key and then decrypt and mount the disk volume(s) used by the main OS. The disk decryption key is usually stored encrypted and requires an additional key encryption key (KEK) in order to be decrypted. The KEK can either be stored in a hardware module, such as a smart card or a TPM, or derived <a id="iddle1327" class="indexterm"/><a id="iddle1378" class="indexterm"/><a id="iddle1386" class="indexterm"/><a id="iddle1582" class="indexterm"/><a id="iddle1642" class="indexterm"/><a id="iddle1654" class="indexterm"/><a id="iddle1719" class="indexterm"/><a id="iddle1760" class="indexterm"/><a id="iddle2809" class="indexterm"/>from a passphrase obtained from the user on each boot. When stored in a hardware module, the KEK can also be protected by a user-supplied PIN or password.</p><p>Android’s FDE implementation encrypts only the <span class="emphasis"><em>userdata</em></span> partition, which stores system configuration files and application data. The <span class="emphasis"><em>boot</em></span> and <span class="emphasis"><em>system</em></span> partitions, which store the kernel and OS files, are not encrypted, but <span class="emphasis"><em>system</em></span> can optionally be verified using the dm-verity device-mapper target as described earlier in “<a class="xref" href="ch10.html#verified_boot-id00021" title="Verified Boot">Verified Boot</a>”. Android’s disk encryption is not enabled by default, and the disk encryption process must be triggered either by the user or by a device policy on managed devices. We examine Android’s disk encryption implementation in the following sections.</p><div class="sect2" title="Cipher Mode"><div class="titlepage"><div><div><h2 class="title"><a id="cipher_mode"/>Cipher Mode</h2></div></div></div><p>Android’s disk encryption uses dm-crypt,<sup>[<a id="ch10fn05" href="#ftn.ch10fn05" class="footnote">104</a>]</sup> currently the standard disk encryption subsystem in the Linux kernel. Like dm-verity, dm-crypt is a device-mapper target that maps an encrypted physical block device to a virtual device-mapper device. All data access to the virtual device is decrypted (for reads) or encrypted (for writes) transparently.</p><p>The encryption mechanism employed in Android uses a randomly generated 128-bit key together with AES in CBC mode. As we learned in <a class="xref" href="ch05.html" title="Chapter 5. Cryptographic Providers">Chapter 5</a>, CBC mode requires an initialization vector (IV) that needs to be both random and unpredictable in order for encryption to be secure. This presents a problem when encrypting block devices, because blocks are accessed non-sequentially, and therefore each sector (or device block) requires a separate IV.</p><p>Android uses the encrypted salt-sector initialization vector (ESSIV) method with the SHA-256 hash algorithm (ESSIV:SHA256) in order to generate per-sector IVs. ESSIV employs a hash algorithm to derive a secondary key <span class="emphasis"><em>s</em></span> from the disk encryption key <span class="emphasis"><em>K</em></span>, called a <span class="emphasis"><em>salt</em></span>. It then uses the salt as an encryption key and encrypts the sector number <span class="emphasis"><em>SN</em></span> of each sector to produce a per-sector IV. In other words, <span class="emphasis"><em>IV(SN) = AES<sub>s</sub>(SN)</em></span>, where <span class="emphasis"><em>s = SHA256(K)</em></span>.</p><p>Because the IV of each sector depends on a secret piece of information (the disk encryption key), per-sector IVs cannot be deduced by an attacker. However, ESSIV does not change CBC’s malleability property and does not ensure the integrity of encrypted blocks. In fact, it’s been demonstrated that an attacker who knows the original plaintext stored on disk can manipulate stored data and even inject a backdoor on volumes that use CBC for disk encryption.<sup>[<a id="ch10fn06" href="#ftn.ch10fn06" class="footnote">105</a>]</sup></p><div class="sidebar"><a id="alternative_ciper_modes_xts"/><p class="title">Alternative Ciper Modes: XTS</p><p><a id="iddle1459" class="indexterm"/><a id="iddle1584" class="indexterm"/><a id="iddle1648" class="indexterm"/><a id="iddle1720" class="indexterm"/><a id="iddle1761" class="indexterm"/><a id="iddle2060" class="indexterm"/><a id="iddle2080" class="indexterm"/><a id="iddle2084" class="indexterm"/><a id="iddle2431" class="indexterm"/><a id="iddle3158" class="indexterm"/>This particular attack against the ESSIV mode can be avoided by switching to a tweakable encryption cipher mode such as XTS (XEX-based tweaked-codebook mode with ciphertext stealing), which uses a combination of the sector address and index of the cipher block inside the sector to derive a unique “tweak” (variable parameter) for each sector.</p><p>Using a distinct tweak for each sector has the same effect as encrypting each sector with a unique key: the same plaintext will result in different ciphertext when stored in different sectors, but has much better performance than deriving a separate key (or IV) for each sector. However, while better than the CBC ESSIV mode, XTS is still susceptible to data manipulation in some cases and does not provide ciphertext authentication.</p><p>As of this writing, Android does not support the XTS mode for disk encryption. However, the underlying dm-crypt device-mapper target supports XTS, and it can easily be enabled with some modifications to Android’s volume daemon (<span class="emphasis"><em>vold</em></span>) implementation.</p></div></div><div class="sect2" title="Key Derivation"><div class="titlepage"><div><div><h2 class="title"><a id="key_derivation"/>Key Derivation</h2></div></div></div><p>The disk encryption key (called the “master key” in Android source code) is encrypted with another 128-bit AES key (KEK), derived from a user-supplied password. In Android versions 3.0 to 4.3, the key derivation function used was PBKDF2 with 2,000 iterations and a 128-bit random salt value. The resulting encrypted master key and the salt are stored, along with other metadata like the number of failed decryption attempts, in a footer structure occupying the last 16 KB of the encrypted partition, called a <span class="emphasis"><em>crypto footer</em></span>. Storing an encrypted key on disk instead of using a key derived from the user-supplied password directly allows for changing the decryption password quickly, because the only thing that needs to be re-encrypted with the key derived from the new password is the master key (16 bytes).</p><p>While using a random salt makes it impossible to use precomputed tables to speed up key cracking, the number of iterations (2,000) used for PBKDF2 is not sufficiently large by today’s standards. (The keystore key derivation process uses 8,192 iterations as discussed in <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>. Backup encryption uses 10,000 iterations, as discussed later in “<a class="xref" href="ch10.html#android_backup" title="Android Backup">Android Backup</a>”.) Additionally, PBKDF2 is an iterative algorithm, based on standard and relatively easy to implement hash functions, which makes it possible for PBKDF2 key derivation to be parallelized, taking full advantage of the processing power of multi-core devices such as GPUs. This allows even fairly complex alphanumeric passphrases to be brute-forced in a matter of days, or even hours.</p><p>In order to make it harder to brute-force disk encryption passwords, Android 4.4 introduced support for a new key derivation function called <a id="iddle1585" class="indexterm"/><a id="iddle1650" class="indexterm"/><a id="iddle2061" class="indexterm"/><a id="iddle2085" class="indexterm"/><a id="iddle2671" class="indexterm"/><span class="emphasis"><em>scrypt</em></span>.<sup>[<a id="ch10fn07" href="#ftn.ch10fn07" class="footnote">106</a>]</sup> Scrypt employs a key derivation algorithm specifically designed to require large amounts of memory, as well as multiple iterations (such an algorithm is called <span class="emphasis"><em>memory hard</em></span>). This makes it harder to mount brute-force attacks on specialized hardware such as ASICs or GPUs, which typically operate with a limited amount of memory.</p><p>Scrypt can be tuned by specifying the variable parameters <span class="emphasis"><em>N</em></span>, <span class="emphasis"><em>r</em></span>, and <span class="emphasis"><em>p</em></span>, which influence the required CPU resources, memory amount, and parallelization cost, respectively. The values used in Android by default are <span class="emphasis"><em>N</em></span> = 32768 (2<sup>15</sup>), <span class="emphasis"><em>r</em></span> = 8, and <span class="emphasis"><em>p</em></span> = 2. They can be changed by setting the value of the <span class="emphasis"><em>ro.crypto.scrypt_params</em></span> system property using the <span class="emphasis"><em>N_factor:r_factor:p_factor</em></span> format; for example, <span class="emphasis"><em>15:3:1</em></span> (the default). The value of each parameter is computed by raising 2 to the power of the respective factor. Android 4.4 devices automatically update the key derivation algorithm in the crypto footer from PBKDF2 to scrypt and re-encrypt the master key using a scrypt-derived encryption key. When the encrypted master key is updated, the <span class="emphasis"><em>N, r</em></span>, and <span class="emphasis"><em>p</em></span> parameters that were used for KEK derivation are written to the crypto footer.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note04"/>Note</h3><p><span class="emphasis"><em>On the same desktop machine, brute-forcing a 4-digit PIN (using a naive, single-threaded algorithm that generates all possible PINs starting from 0000) takes about 5 milliseconds per PIN when using PBKDF2, and about 230 milliseconds per PIN when using scrypt as the KEK derivation function. In other words, brute-forcing PBKDF2 is almost 50 times cheaper (that is, faster) compared to scrypt.</em></span></p></div></div><div class="sect2" title="Disk Encryption Password"><div class="titlepage"><div><div><h2 class="title"><a id="disk_encryption_password"/>Disk Encryption Password</h2></div></div></div><p>As discussed in the previous section, the KEK used to encrypt the disk encryption key is derived from a user-supplied password. When you first start the device encryption process, you’re asked to either confirm your device unlock PIN or password, or set one if you haven’t already or you’re using the pattern screen lock (see <a class="xref" href="ch10.html#device_encryption_screen" title="Figure 10-3. Device encryption screen">Figure 10-3</a>). The entered password or PIN is then used to derive the master key encryption key, and you’re required to enter the password or PIN each time you boot the device, and then once more to unlock the screen after it starts.</p><p>Android doesn’t have a dedicated setting to manage the encryption password after the device is encrypted, and changing the screen lock password or PIN will also silently change the device encryption password. This is most probably a usability-driven decision: most users would be confused by having to remember and enter two different passwords at different times and would probably quickly forget the less frequently used, and possibly more complex, disk encryption password. While this design is good for usability, it effectively forces users to use a simple disk encryption password, because they have to enter it each time they unlock the device, usually dozens of times a day. No one wants to enter a complex password that many times, and thus most users opt for a simple numeric PIN (unless a device policy requires otherwise). <a id="iddle1457" class="indexterm"/><a id="iddle1581" class="indexterm"/><a id="iddle1651" class="indexterm"/><a id="iddle2432" class="indexterm"/>Additionally, passwords are limited to 16 characters (a limit that is hardwired in the framework and not configurable), so using a passphrase is not an option.</p><div class="figure"><a id="device_encryption_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00054"/><img src="figs/web/10fig03.png.jpg" alt="Device encryption screen"/></div></div><p class="title">Figure 10-3. Device encryption screen</p></div><p>What’s the problem with using the same password for both disk encryption and the lockscreen? After all, to get to the data on the phone you need to guess the lockscreen password anyway, so why bother with a separate one for disk encryption? The reason is that the two passwords protect your phone against two different types of attack. Most screen lock attacks would be online, brute-force ones: essentially someone trying out different passwords on a running device when they get brief access to it. After a few unsuccessful attempts, Android will lock the screen for 30 seconds (rate limiting), and even wipe the device if there are more failed unlock attempts (if required by device policy). Thus, even a relatively short screen-lock PIN offers adequate protection against online attacks in most cases (see “<a class="xref" href="ch10.html#brute-force_attack_protection" title="Brute-Force Attack Protection">Brute-Force Attack Protection</a>” for details).</p><p>Of course, if someone has physical access to the device or a disk image of it, they can extract password hashes and crack them offline without worrying about rate-limiting or device wiping. This, in fact, is the scenario that full disk encryption is designed to protect against: when a device is stolen or confiscated, the attacker can either brute-force the actual device, or copy its data and analyze it even after the device is returned or disposed of. As mentioned earlier in “<a class="xref" href="ch10.html#key_derivation" title="Key Derivation">Key Derivation</a>”, the encrypted master key is stored on disk, and if the password used to derive its encryption key is based on a short numeric PIN, it can be brute-forced in minutes<sup>[<a id="ch10fn08" href="#ftn.ch10fn08" class="footnote">107</a>]</sup> (or even seconds on pre-4.4 devices that use PBKDF2 for key derivation). A remote wipe solution could prevent this attack by deleting the master key, which only takes a moment and renders the device useless, but this is often not an option because the device might be offline or turned off.</p></div><div class="sect2" title="Changing the Disk Encryption Password"><div class="titlepage"><div><div><h2 class="title"><a id="changing_the_disk_encryption_password"/>Changing the Disk Encryption Password</h2></div></div></div><p>The user-level part of disk encryption is implemented in the <span class="emphasis"><em>cryptfs</em></span> module of Android’s volume management daemon (<span class="emphasis"><em>vold</em></span>). <span class="emphasis"><em>crypfs</em></span> has commands for <a id="iddle1583" class="indexterm"/><a id="iddle1643" class="indexterm"/><a id="iddle1644" class="indexterm"/><a id="iddle2622" class="indexterm"/><a id="iddle3073" class="indexterm"/>both creating and mounting an encrypted volume, and for verifying and changing the master key encryption password. Android system services communicate with <span class="emphasis"><em>cryptfs</em></span> by sending commands to <span class="emphasis"><em>vold</em></span> through a local socket (also named <span class="emphasis"><em>vold</em></span>), and <span class="emphasis"><em>vold</em></span> sets system properties that describe the current state of the encryption or mount process based on the received command. (This results in a fairly complex boot procedure, described in detail in “<a class="xref" href="ch10.html#enabling_encryption" title="Enabling Encryption">Enabling Encryption</a>” below and “<a class="xref" href="ch10.html#booting_an_encrypted_device" title="Booting an Encrypted Device">Booting an Encrypted Device</a>”.)</p><p>Android does not provide a UI to change only the disk encryption password, but one can do so by communicating directly with the <span class="emphasis"><em>vold</em></span> daemon using the <code class="literal">vdc</code> command-line utility. However, access to the <span class="emphasis"><em>vold</em></span> control socket is limited to the root user and members of the <span class="emphasis"><em>mount</em></span> group, and furthermore, <span class="emphasis"><em>cryptfs</em></span> commands are only available to the <span class="emphasis"><em>root</em></span> and <span class="emphasis"><em>system</em></span> users. If you’re using an engineering build, or your device provides root access via a “superuser” app (see <a class="xref" href="ch13.html" title="Chapter 13. System Updates and Root Access">Chapter 13</a>), you can send the <span class="emphasis"><em>cryptfs</em></span> command shown in <a class="xref" href="ch10.html#changing_the_disk_encryption_password_us" title="Example 10-4. Changing the disk encryption password using vdc">Example 10-4</a> to <span class="emphasis"><em>vold</em></span> in order to change the disk encryption password.</p><div class="example"><a id="changing_the_disk_encryption_password_us"/><p class="title">Example 10-4. Changing the disk encryption password using <code class="literal">vdc</code></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>vdc cryptfs changepw &lt;newpass&gt;</strong></span>
200 0 0</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch10note05"/>Note</h3><p><span class="emphasis"><em>If you change your lockscreen password, the disk encryption password will be changed automatically. (This does not apply to secondary users on multi-user devices.)</em></span></p></div></div><div class="sect2" title="Enabling Encryption"><div class="titlepage"><div><div><h2 class="title"><a id="enabling_encryption"/>Enabling Encryption</h2></div></div></div><p>As mentioned in the previous section, the user-level part of Android’s disk encryption is implemented by a dedicated <span class="emphasis"><em>cryptfs</em></span> module of the <span class="emphasis"><em>vold</em></span> daemon. <span class="emphasis"><em>cryptfs</em></span> provides the <code class="literal">checkpw</code>, <code class="literal">restart</code>, <code class="literal">cryptocomplete</code>, <code class="literal">enablecrypto</code>, <code class="literal">changepw</code>, <code class="literal">verifypw</code>, <code class="literal">getfield</code>, and <code class="literal">setfield</code> commands, which the framework sends at various points of the encryption or encrypted volume mount process. In addition to the permissions set on the <span class="emphasis"><em>vold</em></span> local socket, <span class="emphasis"><em>crypfs</em></span> explicitly checks the identity of the command sender, and only allows access to the <span class="emphasis"><em>root</em></span> and <span class="emphasis"><em>system</em></span> users.</p><div class="sect3" title="Controlling Device Encryption Using System Properties"><div class="titlepage"><div><div><h3 class="title"><a id="controlling_device_encryption_using_syst"/>Controlling Device Encryption Using System Properties</h3></div></div></div><p>The <span class="emphasis"><em>vold</em></span> daemon sets a number of system properties in order to trigger the various stages of device encryption or mounting and to communicate the current encryption state to framework services. The <span class="emphasis"><em>ro.crypto.state</em></span> property holds the current encryption state, which is set to <span class="emphasis"><em>encrypted</em></span> when the data partition has been successfully encrypted, and to <span class="emphasis"><em>unencrypted</em></span> when it has not yet been encrypted. The property can also be set to <span class="emphasis"><em>unsupported</em></span> if the device does not support disk encryption. The <span class="emphasis"><em>vold</em></span> daemon also sets various predefined values to the <span class="emphasis"><em>vold.decrypt</em></span> property in order to signal the current state of device encryption or mounting. The <span class="emphasis"><em>vold.encrypt_progress</em></span> property holds the current encryption progress (from 0 to 100), or an error string if an error occurred during device encryption or mounting.</p><p><a id="iddle1646" class="indexterm"/><a id="iddle2620" class="indexterm"/><a id="iddle3001" class="indexterm"/>The <span class="emphasis"><em>ro.crypto.fs_crypto_blkdev</em></span> system property contains the name of the virtual device allocated by the device mapper. After successfully decrypting the disk encryption key, this virtual device is mounted at <span class="emphasis"><em>/data</em></span> in place of the underlying physical volume, as shown in <a class="xref" href="ch10.html#encrypted_virtual_block_device_mounted_a" title="Example 10-5. Encrypted virtual block device mounted at /data">Example 10-5</a> (with output split for readability).</p><div class="example"><a id="encrypted_virtual_block_device_mounted_a"/><p class="title">Example 10-5. Encrypted virtual block device mounted at <span class="roman">/data</span></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>mount|grep '/data'</strong></span>
/dev/block/dm-0 /data ext4 rw,seclabel,nosuid,nodev,noatime,
errors=panic,user_xattr,barrier=1,nomblk_io_submit,data=ordered 0 0</pre></div></div></div><div class="sect3" title="Unmounting /data"><div class="titlepage"><div><div><h3 class="title"><a id="unmounting_solidusdata"/>Unmounting /data</h3></div></div></div><p>The Android framework expects <span class="emphasis"><em>/data</em></span> to be available, but it needs to be unmounted in order to be encrypted. This creates a catch-22 situation, which Android solves by unmounting the physical <span class="emphasis"><em>userdata</em></span> partition and mounting an on-memory filesystem (tempfs) in its place while performing encryption. Switching partitions at runtime in turn requires stopping and restarting certain system services, which <span class="emphasis"><em>vold</em></span> triggers by setting the value of the <span class="emphasis"><em>vold.decrypt</em></span> system property to <span class="emphasis"><em>trigger_restart_framework</em></span>, <span class="emphasis"><em>trigger_restart_min_framework</em></span>, or <span class="emphasis"><em>trigger_shutdown_framework</em></span>. These values trigger different parts of <span class="emphasis"><em>init.rc</em></span>, as shown in <a class="xref" href="ch10.html#volddotdecrypt_triggers_in_initdotrc" title="Example 10-6. vold.decrypt triggers in init.rc">Example 10-6</a>.</p><div class="example"><a id="volddotdecrypt_triggers_in_initdotrc"/><p class="title">Example 10-6. <span class="roman">vold.decrypt</span> triggers in <span class="roman">init.rc</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
on post-fs-data➊
    chown system system /data
    chmod 0771 /data
    restorecon /data
    copy /data/system/entropy.dat /dev/urandom
--<span class="emphasis"><em>snip</em></span>--
on property:vold.decrypt=trigger_reset_main➋
    class_reset main

on property:vold.decrypt=trigger_load_persist_props
    load_persist_props

on property:vold.decrypt=trigger_post_fs_data➌
    trigger post-fs-data

on property:vold.decrypt=trigger_restart_min_framework➍
    class_start main

on property:vold.decrypt=trigger_restart_framework➎
    class_start main
    class_start late_start

on property:vold.decrypt=trigger_shutdown_framework➏
    class_reset late_start
    class_reset main
--<span class="emphasis"><em>snip-</em></span></pre></div></div></div><div class="sect3" title="Triggering the Encryption Process"><div class="titlepage"><div><div><h3 class="title"><a id="triggering_the_encryption_process"/>Triggering the Encryption Process</h3></div></div></div><p><a id="iddle1454" class="indexterm"/><a id="iddle1456" class="indexterm"/><a id="iddle1460" class="indexterm"/><a id="iddle1580" class="indexterm"/><a id="iddle1638" class="indexterm"/><a id="iddle1645" class="indexterm"/><a id="iddle1647" class="indexterm"/><a id="iddle1655" class="indexterm"/><a id="iddle2228" class="indexterm"/>When the user starts the encryption process via the system Settings UI with Security▸Encrypt phone, the Settings app calls <code class="literal">MountService</code>, which in turn sends the <code class="literal">cryptfs enablecrypto inplace</code> <span class="emphasis"><em><code class="literal">password</code></em></span> command to <span class="emphasis"><em>vold</em></span>, where <span class="emphasis"><em><code class="literal">password</code></em></span> is the lockscreen password. In turn, <span class="emphasis"><em>vold</em></span> unmounts the <span class="emphasis"><em>userdata</em></span> partition and sets <span class="emphasis"><em>vold.decrypt</em></span> to <span class="emphasis"><em>trigger_shutdown_framework</em></span> (➏ in <a class="xref" href="ch10.html#volddotdecrypt_triggers_in_initdotrc" title="Example 10-6. vold.decrypt triggers in init.rc">Example 10-6</a>), which shuts down most system services except for those that are part of the <span class="emphasis"><em>core</em></span> service class. The <span class="emphasis"><em>vold</em></span> daemon then unmounts <span class="emphasis"><em>/data,</em></span> mounts a tempfs file-system in its place, and then sets <span class="emphasis"><em>vold.encrypt_progress</em></span> to 0 and <span class="emphasis"><em>vold.decrypt</em></span> to <span class="emphasis"><em>trigger_restart_min_framework</em></span> (➍ in <a class="xref" href="ch10.html#volddotdecrypt_triggers_in_initdotrc" title="Example 10-6. vold.decrypt triggers in init.rc">Example 10-6</a>). This starts a few more system services (in the <span class="emphasis"><em>main</em></span> class) that are required for showing the encryption progress UI.</p></div><div class="sect3" title="Updating the Crypto Footer and Encrypting Data"><div class="titlepage"><div><div><h3 class="title"><a id="updating_the_crypto_footer_and_encryptin"/>Updating the Crypto Footer and Encrypting Data</h3></div></div></div><p>Next, <span class="emphasis"><em>vold</em></span> sets up the virtual dm-crypt device and writes the crypto footer. The footer can be written to the end of the <span class="emphasis"><em>userdata</em></span> partition or to a dedicated partition or file, and its location is specified in the <span class="emphasis"><em>fstab</em></span> file as the value of the <code class="literal">encryptable</code> flag. For example, on the Nexus 5 the crypto footer is written to the dedicated partition <span class="emphasis"><em>metadata</em></span>, as shown in <a class="xref" href="ch10.html#encryptable_fstab_flag_specifies_the_loc" title="Example 10-7. The encryptable fstab flag specifies the location of the crypto footer">Example 10-7</a> as ➊ (with the single line broken for readability). When the crypto footer is written at the end of the encrypted partition, the <code class="literal">encryptable</code> flag is set to the string <span class="emphasis"><em>footer</em></span>.</p><div class="example"><a id="encryptable_fstab_flag_specifies_the_loc"/><p class="title">Example 10-7. The <code class="literal">encryptable</code> <span class="roman">fstab</span> flag specifies the location of the crypto footer</p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
/dev/block/platform/msm_sdcc.1/by-name/userdata  /data  ext4
noatime,nosuid,nodev,barrier=1,data=ordered,nomblk_io_submit,noauto_da_alloc,errors=panic
wait,check,encryptable=/dev/block/platform/msm_sdcc.1/by-name/metadata➊
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The crypto footer contains the encrypted disk encryption key (master key), the salt used for KEK derivation, and other key derivation parameters and metadata. Its <span class="emphasis"><em>flags</em></span> field is set to <code class="literal">CRYPT_ENCRYPTION_IN_PROGRESS</code> (0x2) to signal that device encryption has started but not been completed.</p><p>Finally, each block is read from the physical <span class="emphasis"><em>userdata</em></span> partition and written to the virtual dm-crypt device, which encrypts read blocks and writes them to disk, thus encrypting the <span class="emphasis"><em>userdata</em></span> partition in place. If encryption completes without errors, <span class="emphasis"><em>vold</em></span> clears the <code class="literal">CRYPT_ENCRYPTION_IN_PROGRESS</code> flag and reboots the device.</p></div></div><div class="sect2" title="Booting an Encrypted Device"><div class="titlepage"><div><div><h2 class="title"><a id="booting_an_encrypted_device"/>Booting an Encrypted Device</h2></div></div></div><p>Booting an encrypted device requires asking the user for the disk encryption password. Rather then use a specialized bootloader UI, Android sets the <span class="emphasis"><em>vold. decrypt</em></span> system property to 1 and then starts a minimal set of system services in order to show a standard Android UI. As with device encryption, this again requires mounting a tmpfs filesystem at <span class="emphasis"><em>/data</em></span> in order to allow core system <a id="iddle1458" class="indexterm"/>services to start. When the core framework is up, Android detects that <span class="emphasis"><em>vold. decrypt</em></span> is set to 1 and starts the <span class="emphasis"><em>userdata</em></span> partition mount process.</p><div class="figure"><a id="device_encryption_password_input_ui"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00055"/><img src="figs/web/10fig04.png.jpg" alt="Device encryption password input UI"/></div></div><p class="title">Figure 10-4. Device encryption password input UI</p></div><div class="figure"><a id="ui_shown_if_device_encryption_fails"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00056"/><img src="figs/web/10fig05.png.jpg" alt="UI shown if device encryption fails"/></div></div><p class="title">Figure 10-5. UI shown if device encryption fails</p></div><div class="sect3" title="Obtaining the Disk Encryption Password"><div class="titlepage"><div><div><h3 class="title"><a id="obtaining_the_disk_encryption_password"/>Obtaining the Disk Encryption Password</h3></div></div></div><p>The first step in this process is to check whether the partition has been successfully encrypted by sending the <code class="literal">cryptfs cryptocomplete</code> command to <span class="emphasis"><em>vold</em></span>, which in turn checks whether the crypto footer is properly formatted and that the <code class="literal">CRYPT_ENCRYPTION_IN_PROGRESS</code> flag is not set. If the partition is found to be successfully encrypted, the framework launches the password entry UI shown in <a class="xref" href="ch10.html#device_encryption_password_input_ui" title="Figure 10-4. Device encryption password input UI">Figure 10-4</a> provided by <code class="literal">CryptKeeper</code>, part of the system Settings app. This activity acts as a home screen (launcher), and because it has higher priority than the default launcher, it’s started first after the device boots.</p><p>If the device is unencrypted, <code class="literal">CryptKeeper</code> disables itself and finishes, which causes the system activity manager to launch the default home screen application. If the device is encrypted or in the process of being encrypted (that is, the <span class="emphasis"><em>vold.crypt</em></span> property is not empty or set to <span class="emphasis"><em>trigger_restart_framework</em></span>), the <code class="literal">CryptKeeper</code> activity starts and hides the status and system bars. In addition, <code class="literal">CryptKeeper</code> ignores hardware back button presses, thus disallowing navigation away from the password input UI.</p><p>If the encrypted device is corrupted, or the encryption process interrupted and the <span class="emphasis"><em>userdata</em></span> partition left only partially encrypted, the device cannot be booted. In this case, <code class="literal">CryptKeeper</code> displays the UI shown in <a class="xref" href="ch10.html#ui_shown_if_device_encryption_fails" title="Figure 10-5. UI shown if device encryption fails">Figure 10-5</a>, allowing the user to trigger a factory reset, which reformats the <span class="emphasis"><em>userdata</em></span> partition.</p></div><div class="sect3" title="Decrypting and Mounting /data"><div class="titlepage"><div><div><h3 class="title"><a id="decrypting_and_mounting_solidusdata"/>Decrypting and Mounting /data</h3></div></div></div><p><a id="iddle1455" class="indexterm"/><a id="iddle1531" class="indexterm"/><a id="iddle1639" class="indexterm"/><a id="iddle1640" class="indexterm"/><a id="iddle1641" class="indexterm"/><a id="iddle1649" class="indexterm"/><a id="iddle2229" class="indexterm"/><a id="iddle2621" class="indexterm"/><a id="iddle3000" class="indexterm"/><a id="iddle3074" class="indexterm"/>When the user enters their password, <code class="literal">CryptKeeper</code> sends the <code class="literal">cryptfs checkpw</code> command to <span class="emphasis"><em>vold</em></span> by calling the <code class="literal">decryptStorage()</code> method of the system <code class="literal">MountService</code>. This instructs <span class="emphasis"><em>vold</em></span> to check whether the entered password is correct by trying to mount the encrypted partition at a temporary mount point and then unmounting it. If the procedure succeeds, <span class="emphasis"><em>vold</em></span> sets the name of the virtual block device allocated by the device-mapper as the value of <span class="emphasis"><em>ro.crypto.fs_crypto_blkdev</em></span> property and returns control to <code class="literal">MountService</code>, which in turn sends the <code class="literal">cryptfs restart</code> command, instructing <span class="emphasis"><em>vold</em></span> to restart all system services in the <span class="emphasis"><em>main</em></span> class (➋ in <a class="xref" href="ch10.html#volddotdecrypt_triggers_in_initdotrc" title="Example 10-6. vold.decrypt triggers in init.rc">Example 10-6</a>). This allows the tempfs filesystem to be unmounted, and the newly allocated virtual dm-crypt block device to be mounted at <span class="emphasis"><em>/data</em></span>.</p></div><div class="sect3" title="Starting All System Services"><div class="titlepage"><div><div><h3 class="title"><a id="starting_all_system_services"/>Starting All System Services</h3></div></div></div><p>After the encrypted partition is mounted and prepared, <span class="emphasis"><em>vold</em></span> sets <span class="emphasis"><em>vold.decrypt</em></span> to <span class="emphasis"><em>trigger_post_fs_data</em></span> (➌ in <a class="xref" href="ch10.html#volddotdecrypt_triggers_in_initdotrc" title="Example 10-6. vold.decrypt triggers in init.rc">Example 10-6</a>), thus triggering the <span class="emphasis"><em>post-fs-data</em></span> ➊ section of <span class="emphasis"><em>init.rc</em></span>. The commands in this section set up file and directory permissions, restore SELinux contexts, and create required directories under <span class="emphasis"><em>/data</em></span> if necessary.</p><p>Finally, <span class="emphasis"><em>post-fs-data</em></span> sets the <span class="emphasis"><em>vold.post_fs_data_done property</em></span> to 1, which <span class="emphasis"><em>vold</em></span> polls periodically. When <span class="emphasis"><em>vold</em></span> detects a value of 1, it sets the <span class="emphasis"><em>vold.decrypt</em></span> property to <span class="emphasis"><em>trigger_restart_framework</em></span> (➎ in <a class="xref" href="ch10.html#volddotdecrypt_triggers_in_initdotrc" title="Example 10-6. vold.decrypt triggers in init.rc">Example 10-6</a>), which restarts all services in the <span class="emphasis"><em>main</em></span> class, and starts all delayed services (class <span class="emphasis"><em>late_start</em></span>). At this point, the framework is fully initialized and the device boots using the decrypted view of the <span class="emphasis"><em>userdata</em></span> partition mounted at <span class="emphasis"><em>/data</em></span>. From this point on, all data written by applications or the system is automatically encrypted before being committed to disk.</p><div class="sidebar"><a id="limitations_of_disk_encryption"/><p class="title">Limitations of Disk Encryption</p><p>Disk encryption only protects data at rest; that is, when the device is turned off. Because disk encryption is transparent and implemented at the kernel level, after an encrypted volume is mounted, it is indistinguishable from a plaintext volume to user-level processes. Therefore disk encryption does not protect data from malicious programs running on the device. Applications that deal with sensitive data should not rely solely on full-disk encryption, but should implement their own, file-based encryption instead. The file encryption key should be encrypted with a KEK derived from a user-supplied password, or some unchangeable hardware property if the data needs to be bound to the device. To ensure file integrity, encrypted data must be authenticated using either an authenticated encryption scheme like GCM, or an additional authentication function such as HMAC.</p></div></div></div></div><div class="sect1" title="Screen Security"><div class="titlepage"><div><div><h1 class="title"><a id="screen_security"/>Screen Security</h1></div></div></div><p><a id="iddle1589" class="indexterm"/><a id="iddle1592" class="indexterm"/><a id="iddle1978" class="indexterm"/><a id="iddle2656" class="indexterm"/><a id="iddle2670" class="indexterm"/>One way to control access to an Android device is by requiring user authentication in order to access the system UI and applications. User authentication is implemented by showing a <span class="emphasis"><em>lockscreen</em></span> each time the device boots or its screen is turned on. The lockscreen on a single-user device, configured to require a numeric PIN to unlock, might look like <a class="xref" href="ch10.html#pin_lockscreen" title="Figure 10-6. PIN lockscreen">Figure 10-6</a>.</p><p>In early Android versions, the lock-screen was only designed to protect access to the device’s UI. As the platform evolved, the lockscreen has been extended with features that display widgets that show up-to-date device or application state, allow switching between users on multi-user devices, and the ability to unlock the system keystore. Similarly, the screen unlock PIN or password is now used to derive the credential storage encryption key (for software implementations), as well as the disk encryption key KEK.</p><div class="figure"><a id="pin_lockscreen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00057"/><img src="figs/web/10fig06.png.jpg" alt="PIN lockscreen"/></div></div><p class="title">Figure 10-6. PIN lockscreen</p></div><div class="sect2" title="Lockscreen Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="lockscreen_implementation"/>Lockscreen Implementation</h2></div></div></div><p>Android’s lockscreen (or <span class="emphasis"><em>keyguard</em></span>) is implemented like regular Android applications: with widgets laid out on a window. It’s special because its window lives on a high window layer that other applications cannot draw on top of or control. Additionally, the keyguard intercepts the normal navigation buttons, which makes it impossible to bypass and thus “locks” the device.</p><p>The keyguard window layer is not the highest layer, however; dialogs originating from the keyguard itself, and the status bar, are drawn over the keyguard. You can see a list of the currently shown windows using the Hierarchy Viewer tool available with the ADT. When the screen is locked, the active window is the Keyguard window, as shown in <a class="xref" href="ch10.html#keyguard_window_position_in_androidapost" title="Figure 10-7. Keyguard window position in Android’s window stack">Figure 10-7</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note06"/>Note</h3><p><span class="emphasis"><em>Prior to Android 4.0, third-party applications could show windows in the keyguard layer, which allowed applications to intercept the Home button and implement “kiosk”-style applications. However, because this functionality was abused by certain malware applications, since Android 4.0 adding windows to the keyguard layer requires the <code class="literal">INTERNAL_SYSTEM_WINDOW</code> signature permission, which is available only to system applications.</em></span></p></div><div class="figure"><a id="keyguard_window_position_in_androidapost"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00058"/><img src="figs/web/10fig07.png" alt="Keyguard window position in Android’s window stack"/></div></div><p class="title">Figure 10-7. Keyguard window position in Android’s window stack</p></div><p><a id="iddle1424" class="indexterm"/><a id="iddle1591" class="indexterm"/><a id="iddle1948" class="indexterm"/><a id="iddle2093" class="indexterm"/><a id="iddle2094" class="indexterm"/><a id="iddle2095" class="indexterm"/><a id="iddle2096" class="indexterm"/><a id="iddle2154" class="indexterm"/><a id="iddle2658" class="indexterm"/>For a long time, the keyguard was an implementation detail of Android’s window system and was not separated into a dedicated component. With the introduction of lockscreen widgets, dreams (that is, screensavers), and support for multiple users, the keyguard gained quite a lot of new functionality and was eventually extracted in a dedicated system application, <code class="literal">Keyguard</code>, in Android 4.4. The <code class="literal">Keyguard</code> app lives in the <span class="emphasis"><em>com.android.systemui</em></span> process, along with the core Android UI implementation.</p><p>The UI for each unlock method (discussed next) is implemented as a specialized view component. This component is hosted by a dedicated view container class called <code class="literal">KeyguardHostView</code>, along with keyguard widgets and other helper UI components. For example, the PIN unlock view shown in <a class="xref" href="ch10.html#pin_lockscreen" title="Figure 10-6. PIN lockscreen">Figure 10-6</a> is implemented in the <code class="literal">KeyguardPINView</code> class, and password unlock is implemented by the <code class="literal">KeyguardPasswordView</code> class. The <code class="literal">KeyguardHostView</code> class automatically selects and displays the appropriate keyguard view for the currently configured unlock method and device state. Unlock views delegate password checks to the <code class="literal">LockPatternUtils</code> class, which is responsible for comparing user input to saved unlock credentials, as well as for persisting password changes to disk and updating authentication-related metadata.</p><p>Besides the implementations of keyguard unlock views, the <code class="literal">Keyguard</code> system application includes the exported <code class="literal">KeyguardService</code> service, which exposes a remote AIDL interface, <code class="literal">IKeyguardService</code>. This service allows its clients to check the current state of the keyguard, set the current user, launch the camera, and hide or disable the keyguard. Operations that change the state of the keyguard are protected by a system signature permission, <code class="literal">CONTROL_KEYGUARD</code>.</p></div><div class="sect2" title="Keyguard Unlock Methods"><div class="titlepage"><div><div><h2 class="title"><a id="keyguard_unlock_methods"/>Keyguard Unlock Methods</h2></div></div></div><p>Stock Android provides several keyguard unlock methods (also called <span class="emphasis"><em>security modes</em></span> in Android’s source code). Of these, five can be directly selected in the Choose screen lockscreen: Slide, Face Unlock, Pattern, PIN, and Password, as shown in <a class="xref" href="ch10.html#directly_selectable_keyguard_unlock_meth" title="Figure 10-8. Directly selectable keyguard unlock methods">Figure 10-8</a>.</p><p><a id="iddle2098" class="indexterm"/><a id="iddle2100" class="indexterm"/><a id="iddle2102" class="indexterm"/><a id="iddle2106" class="indexterm"/><a id="iddle2426" class="indexterm"/><a id="iddle2428" class="indexterm"/><a id="iddle2481" class="indexterm"/><a id="iddle2660" class="indexterm"/><a id="iddle2662" class="indexterm"/><a id="iddle2664" class="indexterm"/><a id="iddle2669" class="indexterm"/><a id="iddle2844" class="indexterm"/>The Slide unlock method requires no user authentication and its security level is therefore equivalent to selecting None. Both states are represented internally by setting the current security mode to the <code class="literal">KeyguardSecurityModel.SecurityMode.None</code> enum value. As of this writing, Face Unlock is the only implementation of the <code class="literal">SecurityMode.Biometric</code> security mode and is internally referred to as “weak biometric” (a “strong bio-metric” could be implemented with fingerprint or iris recognition in a future version). Unlock methods that are not compatible with the current device security policy (the top three in <a class="xref" href="ch10.html#directly_selectable_keyguard_unlock_meth" title="Figure 10-8. Directly selectable keyguard unlock methods">Figure 10-8</a>) are disabled and cannot be selected. The security policy can be set either explicitly by a device administrator, or implicitly by enabling a security-related OS feature such as credential storage or full-disk encryption.</p><p>The Pattern unlock method (<code class="literal">SecurityMode.Pattern</code>) is Android-specific and requires drawing a predefined pattern on a 3×3 grid to unlock the device, as shown in <a class="xref" href="ch10.html#configuring_the_pattern_unlock_method" title="Figure 10-9. Configuring the Pattern unlock method">Figure 10-9</a>.</p><div class="figure"><a id="directly_selectable_keyguard_unlock_meth"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00059"/><img src="figs/web/10fig08.png.jpg" alt="Directly selectable keyguard unlock methods"/></div></div><p class="title">Figure 10-8. Directly selectable keyguard unlock methods</p></div><div class="figure"><a id="configuring_the_pattern_unlock_method"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00060"/><img src="figs/web/10fig09.png.jpg" alt="Configuring the Pattern unlock method"/></div></div><p class="title">Figure 10-9. Configuring the Pattern unlock method</p></div><p>The PIN (<code class="literal">SecurityMode.PIN</code>) and Password (<code class="literal">SecurityMode.Password</code>) unlock methods are implemented similarly, but differ by the scope of allowed characters: only numeric (0-9) for the PIN, or alphanumeric for Password are allowed.</p><p><a id="iddle1786" class="indexterm"/><a id="iddle2097" class="indexterm"/><a id="iddle2104" class="indexterm"/><a id="iddle2479" class="indexterm"/><a id="iddle2485" class="indexterm"/><a id="iddle2549" class="indexterm"/><a id="iddle2659" class="indexterm"/><a id="iddle2667" class="indexterm"/>The <code class="literal">SecurityMode</code> enum defines three more unlock methods that are not directly selectable in the Choose screen lockscreen: <code class="literal">SecurityMode.Account</code>, <code class="literal">SecurityMode.SimPin</code>, and <code class="literal">SecurityMode.SimPuk</code>. The <code class="literal">SecurityMode.Account</code> method is available only on devices that support Google accounts (Google experience devices) and is not an independent unlock method. It can only be used as a fallback method for another security mode. Similarly, <code class="literal">SecurityMode.SimPin</code> and <code class="literal">SecurityMode.SimPuk</code> are not lockscreen unlock methods per se; they’re only available if the device’s SIM card requires a PIN before use. Because the SIM card remembers the PIN authentication status, the PIN or PUK must be entered only once—when the device boots (or if the SIM card state is otherwise reset). We’ll delve deeper into the implementation of each lockscreen security mode in the next sections.</p><div class="sect3" title="Face Unlock"><div class="titlepage"><div><div><h3 class="title"><a id="face_unlock"/>Face Unlock</h3></div></div></div><p>Face Unlock is a relatively new unlock method introduced in Android 4.0. It uses the device’s front-facing camera to register an image of the owner’s face (see <a class="xref" href="ch10.html#face_unlock_setup_screen" title="Figure 10-10. Face Unlock setup screen">Figure 10-10</a>) and relies on image recognition technology to recognize the face captured when unlocking the device. Although improvements to Face Unlock’s accuracy have been made since its introduction, it’s considered the least secure of all unlock methods, and even the setup screen warns users that “someone who looks similar to you could unlock your phone.” In addition, Face Unlock requires a backup unlock method—either a pattern or a PIN, to handle situations when face recognition is not possible (such as poor lighting, camera malfunction, and so on). The Face Unlock implementation is based on facial recognition technology developed by the PittPatt (Pittsburgh Pattern Recognition) company, which Google acquired in 2011. The code remains proprietary and no details are available about the format of the stored data or the recognition algorithms employed. As of this writing, the implementation of Face Unlock resides in the <code class="literal">com.android.facelock</code> package.</p><div class="figure"><a id="face_unlock_setup_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00061"/><img src="figs/web/10fig10.png.jpg" alt="Face Unlock setup screen"/></div></div><p class="title">Figure 10-10. Face Unlock setup screen</p></div></div><div class="sect3" title="Pattern Unlock"><div class="titlepage"><div><div><h3 class="title"><a id="pattern_unlock"/>Pattern Unlock</h3></div></div></div><p><a id="iddle1370" class="indexterm"/><a id="iddle2101" class="indexterm"/><a id="iddle2157" class="indexterm"/><a id="iddle2429" class="indexterm"/><a id="iddle2652" class="indexterm"/><a id="iddle2663" class="indexterm"/>As shown in <a class="xref" href="ch10.html#configuring_the_pattern_unlock_method" title="Figure 10-9. Configuring the Pattern unlock method">Figure 10-9</a>, the code for pattern unlock is entered by joining at least four points on a 3×3 matrix. Each point can be used only once (crossed points are disregarded) and the maximum number of points is nine. Internally, the pattern is stored as a byte sequence, with each point represented by its index, where 0 is top left and 8 is bottom right. Thus the pattern is similar to a PIN with a minimum of four and maximum of nine digits, which uses only nine distinct digits (0 to 8). However, because points cannot be repeated, the number of variations in an unlock pattern is considerably lower compared to those of a nine-digit PIN.</p><p>The hash for the pattern lock is stored in <span class="emphasis"><em>/data/system/gesture.key</em></span> (<span class="emphasis"><em>/data/ system/users/&lt;user ID&gt;/gesture.key</em></span> on multi-user devices) as an unsalted SHA-1 value. By simply dumping this file, we can easily see that the contents of the <span class="emphasis"><em>gesture.key</em></span> file for the pattern in <a class="xref" href="ch10.html#configuring_the_pattern_unlock_method" title="Figure 10-9. Configuring the Pattern unlock method">Figure 10-9</a> (represented as <span class="emphasis"><em>00010204060708</em></span> in hexadecimal) shown in <a class="xref" href="ch10.html#contents_of_the_solidusdatasolidussystem" title="Example 10-8. Contents of the /data/system/gesture.key file">Example 10-8</a> matches the SHA-1 hash of the pattern byte sequence, which is <span class="emphasis"><em>6a062b9b3452e366407181a1bf92ea73e9ed4c48</em></span> for this example.</p><div class="example"><a id="contents_of_the_solidusdatasolidussystem"/><p class="title">Example 10-8. Contents of the <span class="roman">/data/system/gesture.key</span> file</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>od -t x1 /data/system/gesture.key</strong></span>
0000000 6a 06 2b 9b 34 52 e3 66 40 71 81 a1 bf 92 ea 73
0000020 e9 ed 4c 48</pre></div></div><p>Because a random salt value isn’t used when calculating the hash, each pattern is always hashed to the same value, which makes it relatively easy to generate a precomputed table of all possible patterns and their respective hashes. (Such tables are readily available online.) This allows for instant recovery of the pattern once the <span class="emphasis"><em>gesture.key</em></span> file is obtained. However, the file is owned by the <span class="emphasis"><em>system</em></span> user and its permissions are set to 0600, so recovery is not usually possible on production devices. The entered pattern is checked against the saved hash using the <code class="literal">checkPattern()</code> method of the <code class="literal">LockScreenUtils</code> class, and the pattern hash is calculated and persisted using the <code class="literal">saveLockPattern()</code> method of that class. Saving the pattern also sets the current password quality value to <code class="literal">DevicePolicyManager.PASSWORD_QUALITY_SOMETHING</code>.</p><p>Another unfortunate property of the pattern unlock method is that because capacitive touch screens are operated directly using a finger (not with a stylus or a similar tool), drawing the unlock pattern multiple times leaves a distinct trace on a touch screen, making it vulnerable to the so called “smudge attack.” Using appropriate lighting and cameras, finger smudges on the screen can be detected, and the unlock pattern can be inferred with a very high probability. For these reasons, the pattern unlock method’s security level is considered very low. In addition, because the number of combinations is limited, the unlock pattern is a poor source of entropy and is disallowed when the user’s unlock credential is used <a id="iddle2099" class="indexterm"/><a id="iddle2103" class="indexterm"/><a id="iddle2427" class="indexterm"/><a id="iddle2482" class="indexterm"/><a id="iddle2661" class="indexterm"/><a id="iddle2665" class="indexterm"/>to derive an encryption key, such as those used for system’s keystore and device encryption.</p><p>Like Face Unlock, the pattern unlock method supports a backup unlock mechanism that is only made available after the user enters an invalid pattern more than five times. Backup authentication must be manually activated by pressing the Forgot Pattern button shown at the bottom of the lock-screen. After the button is pressed, the device goes into the <code class="literal">SecurityMode.Account</code> security mode and displays the screen shown in <a class="xref" href="ch10.html#google_account_unlock_mode" title="Figure 10-11. Google account unlock mode">Figure 10-11</a>.</p><p>The user can enter the credentials of any Google account registered on the device to unlock it, and then reset or change the unlock method. Therefore, having a Google account with an easy to guess (or shared) password registered on the device could be a potential backdoor to the device’s lockscreen.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note07"/>Note</h3><p><span class="emphasis"><em>As of this writing, Google accounts that have been configured to require two-factor authentication cannot be used to unlock the device.</em></span></p></div><div class="figure"><a id="google_account_unlock_mode"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00062"/><img src="figs/web/10fig11.png.jpg" alt="Google account unlock mode"/></div></div><p class="title">Figure 10-11. Google account unlock mode</p></div></div><div class="sect3" title="PIN and Password Unlock"><div class="titlepage"><div><div><h3 class="title"><a id="pin_and_password_unlock"/>PIN and Password Unlock</h3></div></div></div><p>The PIN and password methods are essentially equivalent: they compare the hash of the user’s input to a salted hash stored on the device and unlock it if the values match. The hash of the PIN or password is a combination of the SHA-1 and MD5 hash values of the user input, salted with a 64-bit random value. The calculated hash is stored in the <span class="emphasis"><em>/data/misc/password.key</em></span> (/<span class="emphasis"><em>data/system/users/&lt;user ID&gt;/password.key</em></span> on multi-user devices) file as a hexadecimal string and may look like <a class="xref" href="ch10.html#contents_of_the_solidusdatasolidusmiscso" title="Example 10-9. Contents of the /data/misc/password.key file">Example 10-9</a>.</p><div class="example"><a id="contents_of_the_solidusdatasolidusmiscso"/><p class="title">Example 10-9. Contents of the <span class="roman">/data/misc/password.key</span> file</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>cat /data/system/password.key &amp;&amp; echo</strong></span>
9B93A9A846FE2FC11D49220FC934445DBA277EB0AF4C9E324D84FFC0120D7BAE1041FAAC</pre></div></div><p>The salt used for calculating the hash values was saved in the <code class="literal">secure</code> table of the system’s <code class="literal">SettingsProvider</code> content provider under the <span class="emphasis"><em>lockscreen.password_salt</em></span> key in Android versions prior to 4.2, but was moved to a dedicated database, along with other lockscreen-related metadata in order to <a id="iddle1010" class="indexterm"/><a id="iddle1570" class="indexterm"/><a id="iddle2158" class="indexterm"/><a id="iddle2424" class="indexterm"/><a id="iddle2425" class="indexterm"/>support multiple users per device. As of Android 4.4, the database is located in <span class="emphasis"><em>/data/system/locksettings.db</em></span> and is accessed via the <code class="literal">ILockSettings</code> AIDL interface of the <code class="literal">LockSettingsService</code>.</p><p>Accessing the service requires the <code class="literal">ACCESS_KEYGUARD_SECURE_STORAGE</code> signature permission, which is only allowed to system applications. The <span class="emphasis"><em>locksettings.db</em></span> database has a single table, also called <code class="literal">locksettings</code>, which may contain data like <a class="xref" href="ch10.html#contents_of_solidusdatasolidussy-id00023" title="Example 10-10. Contents of /data/system/locksettings.db for the owner user">Example 10-10</a> for a particular user (the <code class="literal">user</code> column contains the Android user ID).</p><div class="example"><a id="contents_of_solidusdatasolidussy-id00023"/><p class="title">Example 10-10. Contents of <span class="roman">/data/system/locksettings.db</span> for the owner user</p><div class="example-contents"><pre class="programlisting">sqlite&gt; <span class="strong"><strong>select name, user, value from locksettings where user=0;</strong></span>
name                              |user|value
--<span class="emphasis"><em>snip</em></span>--
lockscreen.password_salt          |0   |6909501022570534487➊
--<span class="emphasis"><em>snip</em></span>--
lockscreen.password_type_alternate|0   |0➋
lockscreen.password_type          |0   |131072➌
lockscreen.passwordhistory        |0   |5BFE43E89C989972EF0FA0EC00BA30F356EE7B
7C7BF8BC08DEA2E067FF6C18F8CD7134B8,EE29A531FE0903C2144F0618B08D1858473C50341A7
8DEA85D219BCD27EF184BCBC2C18C➍</pre></div></div><p>Here, the <span class="emphasis"><em>lockscreen.password_salt</em></span> setting ➊ stores the 64-bit (represented as a Java <code class="literal">long</code> type) salt value, and the <span class="emphasis"><em>lockscreen.password_type_alternate</em></span> setting ➋ contains the type of the backup (also called alternate) unlock method type (0 means none) for the current unlock method. <span class="emphasis"><em>lockscreen.password_type</em></span> ➌ stores the currently selected password type, represented by the value of the corresponding <code class="literal">PASSWORD_QUALITY</code> constant defined in the <code class="literal">DevicePolicyManager</code> class. In this example, 131072 (0x00020000 in hexadecimal) corresponds to the <code class="literal">PASSWORD_QUALITY_NUMERIC</code> constant, which is the password quality provided by a numeric PIN. Finally, <span class="emphasis"><em>lockscreen.passwordhistory</em></span> ➍ contains the password history, saved as a sequence of previous PIN or password hashes, separated by commas. The history is only saved if the history length has been set to a value greater than zero using one of the <code class="literal">setPasswordHistoryLength()</code> methods of the <code class="literal">DevicePolicyManager</code> class. When password history is available, entering a new password that is the same as any password in the history is forbidden.</p><p>The password hash can be easily calculated by concatenating the password or PIN string (<span class="emphasis"><em>1234</em></span> for this example) with the salt value formatted as a hexadecimal string (<span class="emphasis"><em>5fe37a926983d657</em></span> for this example) and calculating the SHA-1 and MD5 hashes of the resulting string, as shown in <a class="xref" href="ch10.html#calculating_a_pin_or_password_hash_using" title="Example 10-11. Calculating a PIN or password hash using sha1sum and md5sum">Example 10-11</a>.</p><div class="example"><a id="calculating_a_pin_or_password_hash_using"/><p class="title">Example 10-11. Calculating a PIN or password hash using <span class="roman">sha1sum</span> and <span class="roman">md5sum</span></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>SHA1=`echo -n '12345fe37a926983d657'|sha1sum|cut -d- -f1|tr '[a-z]' '[A-Z]'</strong></span>➊
$ <span class="strong"><strong>MD5=`echo -n '12345fe37a926983d657'|md5sum|cut -d- -f1|tr '[a-z]' '[A-Z]'`</strong></span>➋
$ <span class="strong"><strong>echo "$SHA1$MD5"|tr -d ' '</strong></span>➌
9B93A9A846FE2FC11D49220FC934445DBA277EB0AF4C9E324D84FFC0120D7BAE1041FAAC</pre></div></div><p>In this example the hashes are calculated using the <code class="literal">sha1sum</code> ➊ and <code class="literal">md5sum</code> ➋ commands. When concatenated ➌, the output of the two commands produces the string contained in the <span class="emphasis"><em>password.key</em></span> file shown in <a class="xref" href="ch10.html#contents_of_the_solidusdatasolidusmiscso" title="Example 10-9. Contents of the /data/misc/password.key file">Example 10-9</a>.</p><p><a id="iddle1364" class="indexterm"/><a id="iddle1369" class="indexterm"/><a id="iddle1999" class="indexterm"/><a id="iddle2105" class="indexterm"/><a id="iddle2155" class="indexterm"/><a id="iddle2230" class="indexterm"/><a id="iddle2480" class="indexterm"/><a id="iddle2483" class="indexterm"/><a id="iddle2484" class="indexterm"/><a id="iddle2550" class="indexterm"/><a id="iddle2617" class="indexterm"/><a id="iddle2651" class="indexterm"/><a id="iddle2666" class="indexterm"/><a id="iddle2668" class="indexterm"/><a id="iddle2883" class="indexterm"/>Note that while using a random hash makes it impossible to use a single precalculated table for brute-forcing the PIN or password of any device, calculating the password or hash requires a single hash invocation, so generating a targeted hash table for a particular device (assuming the salt value is also available) is still relatively cheap. Additionally, while Android calculates both the SHA-1 and MD5 hashes of the PIN or password, this provides no security value, as it is sufficient to target the shorter hash (MD5) in order to uncover the PIN or password.</p><p>The entered password is checked against the stored hash using the <code class="literal">LockPatternUtils.checkPassword()</code> method, and the hash of a user-supplied password is calculated and persisted using the one of the <code class="literal">saveLockPassword()</code> methods of that class. Calling <code class="literal">saveLockPassword()</code> updates the <span class="emphasis"><em>password.key</em></span> file for the target (or current) user. Like <span class="emphasis"><em>gesture.key</em></span>, this file is owned by the <span class="emphasis"><em>system</em></span> user and has permissions 0600. In addition to updating the password hash, <code class="literal">saveLockPassword()</code> calculates the complexity of the entered password and updates the <code class="literal">value</code> column corresponding to the <span class="emphasis"><em>lockscreen.password_type</em></span> key (➌ in <a class="xref" href="ch10.html#contents_of_solidusdatasolidussy-id00023" title="Example 10-10. Contents of /data/system/locksettings.db for the owner user">Example 10-10</a>) in <span class="emphasis"><em>locksettings.db</em></span> with the calculated complexity value. If password history is enabled, <code class="literal">saveLockPassword()</code> also adds the PIN or password hash to the <code class="literal">locksettings</code> table (➍ in <a class="xref" href="ch10.html#calculating_a_pin_or_password_hash_using" title="Example 10-11. Calculating a PIN or password hash using sha1sum and md5sum">Example 10-11</a>).</p><p>Recall that when the device is encrypted, the PIN or password is used to derive a KEK that encrypts the disk encryption key. Therefore, changing the PIN or password of the owner user also re-encrypts the disk encryption key by calling the <code class="literal">changeEncryptionPassword()</code> method of the system’s <code class="literal">MountService</code>. (Changing the PIN or password of a secondary user does not affect the disk encryption key.)</p></div><div class="sect3" title="PIN and PUK Unlock"><div class="titlepage"><div><div><h3 class="title"><a id="pin_and_puk_unlock"/>PIN and PUK Unlock</h3></div></div></div><p>The PIN and PUK security modes are not lockscreen unlock methods per se because they depend on the state of the device’s SIM card and are only shown if the SIM card is in a locked state. A SIM card can require users to enter a preconfigured PIN code in order to unlock the card and get access to any network authentication keys stored inside, which are required to register with the mobile network and place non-emergency calls.</p><p>Because a SIM card retains its unlock state until reset, the PIN code typically must be entered only when the device first boots. If an incorrect code is entered more than three times, the SIM card locks and requires the user to enter a separate code to unlock it called the <span class="emphasis"><em>PIN unlock key (PUK)</em></span>, or <span class="emphasis"><em>personal unblocking code (PUC)</em></span>.</p><p>When the lockscreen is shown, Android checks the state of the SIM card, and if it’s <code class="literal">State.PIN_REQUIRED</code> (defined in the <code class="literal">IccCardConstants</code> class), it shows the SIM unlock keyguard view shown in <a class="xref" href="ch10.html#sim_unlock_screen" title="Figure 10-12. SIM unlock screen">Figure 10-12</a>. When the user enters a SIM unlock PIN, it’s passed to the <code class="literal">supplyPinReportResult()</code> method of the <code class="literal">ITelephony</code> interface (implemented in the <code class="literal">TeleService</code> system application), which in turn passes it to the device’s baseband processor (the device component that implements mobile network communication, also sometimes referred to as the <span class="emphasis"><em>modem</em></span> or <span class="emphasis"><em>radio</em></span>) via the radio interface daemon (<span class="emphasis"><em>rild</em></span>). Finally, the baseband processor, which is directly connected to <a id="iddle1305" class="indexterm"/><a id="iddle1590" class="indexterm"/><a id="iddle2657" class="indexterm"/><a id="iddle2884" class="indexterm"/>the SIM, sends the PIN to the SIM card and receives a status code in exchange. The status code is passed back to the unlock view via the same route. If the status code indicates that the SIM card accepted the PIN and no screen lock is configured, the home screen (launcher) is displayed next. If, on the other hand, a screen lock has been configured, it’s shown after unlocking the SIM card, and the user must enter their credentials in order to unlock the device.</p><div class="figure"><a id="sim_unlock_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00063"/><img src="figs/web/10fig12.png.jpg" alt="SIM unlock screen"/></div></div><p class="title">Figure 10-12. SIM unlock screen</p></div><p>If the SIM card is locked (that is, in the <code class="literal">PUK_REQUIRED</code> state), Android shows a PUK entry screen and allows the user to set up a new PIN after they unlock the card. The PUK and new PIN are passed to the <code class="literal">supplyPukReportResult()</code> method of the <code class="literal">ITelephony</code> interface, which delivers them to the SIM card. If a screen lock is configured, it is shown when the PUK is validated and the new PIN configured.</p><p>The <code class="literal">Keyguard</code> system application monitors SIM state changes by registering for the <code class="literal">TelephonyIntents.ACTION_SIM_ STATE_CHANGED</code> broadcast and shows the lockscreen if the card becomes locked or permanently disabled. Users can toggle the SIM card’s PIN protection by navigating to <span class="strong"><strong>Settings</strong></span>▸<span class="strong"><strong>Security</strong></span>▸ <span class="strong"><strong>Set up SIM card lock</strong></span> and using the <span class="strong"><strong>Lock SIM card</strong></span> checkbox.</p><div class="figure"><a id="rate_limiting_after_five_subsequent_fail"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00064"/><img src="figs/web/10fig13.png.jpg" alt="Rate limiting after five subsequent failed authentication attempts"/></div></div><p class="title">Figure 10-13. Rate limiting after five subsequent failed authentication attempts</p></div></div></div><div class="sect2" title="Brute-Force Attack Protection"><div class="titlepage"><div><div><h2 class="title"><a id="brute-force_attack_protection"/>Brute-Force Attack Protection</h2></div></div></div><p>Because complex passwords can be tricky to input on a touch screen keyboard, users typically use relatively short unlock credentials, which can easily be guessed or brute-forced. Android protects against brute-force attacks executed directly on the device (online attacks) by requiring users to wait 30 seconds after each five subsequent failed authentication attempts, as shown in <a class="xref" href="ch10.html#rate_limiting_after_five_subsequent_fail" title="Figure 10-13. Rate limiting after five subsequent failed authentication attempts">Figure 10-13</a>. This technique is referred to as <span class="emphasis"><em>rate limiting</em></span>.</p><p><a id="iddle1075" class="indexterm"/><a id="iddle1077" class="indexterm"/><a id="iddle1087" class="indexterm"/><a id="iddle1522" class="indexterm"/><a id="iddle1524" class="indexterm"/><a id="iddle1593" class="indexterm"/><a id="iddle1595" class="indexterm"/><a id="iddle2988" class="indexterm"/><a id="iddle2990" class="indexterm"/>To further deter brute-force attacks, password complexity, expiration, and history rules can be set and enforced using the <code class="literal">DevicePolicyManager</code> API, as discussed in <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a>. If the device stores or allows access to sensitive corporate data, device administrators can also set a threshold for the allowed failed authentication attempts using the <code class="literal">DevicePolicyManager.setMaximumFailedPasswordsForWipe()</code> method. When the threshold is reached, all user data on the device is automatically deleted, preventing attackers from gaining unauthorized access to it.</p></div></div><div class="sect1" title="Secure USB Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="secure_usb_debugging"/>Secure USB Debugging</h1></div></div></div><p>One reason for Android’s success is the low entry barrier to application development; apps can be developed on any OS, in a high-level language, without the need to invest in developer tools or hardware (when using the Android emulator). Developing software for embedded or other dedicated devices has traditionally been difficult, because it’s usually hard (or in some cases impossible) to inspect a program’s internal state or otherwise interact with the device in order to debug programs.</p><p>Since its earliest versions, Android has included a powerful device interaction toolkit that allows interactive debugging and inspecting device state, called the <span class="emphasis"><em>Android Debug Bridge (ADB)</em></span>. ADB is typically turned off on consumer devices, but can be turned on via the system UI in order to enable app development and debugging on the device. Because ADB provides privileged access to the device’s filesystem and applications, it can be used to obtain unauthorized access to data. In the following sections, we’ll discuss ADB’s architecture, then discuss the steps recent Android versions have taken to restrict access to ADB.</p><div class="sect2" title="ADB Overview"><div class="titlepage"><div><div><h2 class="title"><a id="adb_overview"/>ADB Overview</h2></div></div></div><p>ADB keeps track of all devices (or emulators) connected to a host, and offers various services to its clients (command line clients, IDEs, and so on). It consists of three main components: the ADB server, the ADB daemon (<span class="emphasis"><em>adbd),</em></span> and the default command-line client (<code class="literal">adb</code>). The ADB server runs on the host machine as a background process and decouples clients from the actual devices or emulators. It monitors device connectivity and sets their state appropriately (<code class="literal">CS_CONNECTED</code>, <code class="literal">CS_OFFLINE</code>, <code class="literal">CS_RECOVERY</code>, and so on).</p><p>The ADB daemon runs on an Android device (or emulator) and provides the actual services client use. It connects to the ADB server through USB or TCP/IP, and receives and processes commands from it. The <code class="literal">adb</code> command-line client lets you send commands to a particular device. In practice, it is implemented in the same binary as the ADB server and thus shares much of its code. <a class="xref" href="ch10.html#adb_architecture" title="Figure 10-14. ADB architecture">Figure 10-14</a> shows an overview of ADB’s architecture.</p><div class="figure"><a id="adb_architecture"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00065"/><img src="figs/web/10fig14.png.jpg" alt="ADB architecture"/></div></div><p class="title">Figure 10-14. ADB architecture</p></div><div class="note" title="Note"><h3 class="title"><a id="ch10note08"/>Note</h3><p><a id="iddle1108" class="indexterm"/><a id="iddle1136" class="indexterm"/><span class="emphasis"><em>In addition to the native implementation in the <code class="literal">adb</code> command and the Java-based one in the Android Development Tools (ADT) Eclipse plugin, various third-party implementations of the ADB protocol are also available, including a Python client</em></span><sup>[<a id="ch10fn09" href="#ftn.ch10fn09" class="footnote">108</a>]</sup> <span class="emphasis"><em>and an ADB server implemented in JavaScript,</em></span><sup>[<a id="ch10fn10" href="#ftn.ch10fn10" class="footnote">109</a>]</sup> <span class="emphasis"><em>which can be embedded in the Chrome browser as an extension.</em></span></p></div><p>The client talks to the local ADB server via TCP (typically via <span class="emphasis"><em>localhost:5037</em></span>) using text-based commands, and receives <span class="emphasis"><em>OK</em></span> or <span class="emphasis"><em>FAIL</em></span> responses in return. Some commands, like enumerating devices, port forwarding, or daemon restart are handled by the local daemon, while others (like shell or log access) require a connection to the target Android device. Device access is generally accomplished by forwarding input and output streams to/from the host. The transport layer that implements this uses simple messages with a 24-byte header, which contains a command identifier, two arguments, the length and CRC32 of the optional payload that follows, and a magic value, which simply flips all bits of the command. The message structure is defined in <span class="emphasis"><em>system/core/adb/adb.h</em></span> and is shown in <a class="xref" href="ch10.html#adb_message_structure" title="Example 10-12. ADB message structure">Example 10-12</a> for reference. Messages are in turn encapsulated in packets, which are sent over the USB or TCP link to the ADB server running on the device.</p><div class="example"><a id="adb_message_structure"/><p class="title">Example 10-12. ADB message structure</p><div class="example-contents"><pre class="programlisting">struct amessage {
    unsigned command;       /* command identifier constant      */
    unsigned arg0;          /* first argument                   */
    unsigned arg1;          /* second argument                  */
    unsigned data_length;   /* length of payload (0 is allowed) */
    unsigned data_check;    /* checksum of data payload         */
    unsigned magic;         /* command ^ 0xffffffff             */
};</pre></div></div><p><a id="iddle1079" class="indexterm"/><a id="iddle1096" class="indexterm"/><a id="iddle1526" class="indexterm"/><a id="iddle1597" class="indexterm"/><a id="iddle2992" class="indexterm"/>We won’t discuss the ADB protocol in more detail other than to note the authentication commands added to the protocol in order to implement secure USB debugging. (For more details on ADB, see the protocol description in the <span class="emphasis"><em>system/core/adb/protocol.txt</em></span> file in Android’s source tree.)</p><div class="note" title="Note"><h3 class="title"><a id="ch10note09"/>Note</h3><p><span class="emphasis"><em>You can enable trace logs for all ADB services by setting the <code class="literal">ADB_TRACE</code> environment variable to 1 on the host and the <code class="literal">persist.adb.trace_mask</code> system property on the device. Selected services can be traced by setting the value of <code class="literal">ADB_TRACE</code> or <code class="literal">persist.adb.trace_mask</code> to a comma- or space-separated (columns or semi-columns as a separator are also supported) list of service tags. See</em></span> system/core/adb/adb.c <span class="emphasis"><em>for the full list of supported tags.</em></span></p></div></div><div class="sect2" title="The Need for Secure ADB"><div class="titlepage"><div><div><h2 class="title"><a id="need_for_secure_adb"/>The Need for Secure ADB</h2></div></div></div><p>If you’ve done any development, you know that “debugging” is usually the exact opposite of “secure.” Debugging typically involves inspecting (and sometimes even changing) internal program state, dumping encrypted communication data to log files, universal root access, and other scary but necessary activities. Debugging is hard enough without having to bother with security, so why further complicate things by adding additional security layers? Android debugging, as provided by the ADB, is quite versatile and gives you almost complete control over a device when enabled. This feature is, of course, very welcome when developing or testing an application (or the OS itself), but it can also be used for other purposes.</p><p>Here’s a selective list of things ADB lets you do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Copy files to and from the device</p></li><li class="listitem"><p>Debug apps running on the device (using JWDP or <code class="literal">gdbserver</code>)</p></li><li class="listitem"><p>Execute shell commands on the device</p></li><li class="listitem"><p>Get the system and apps logs</p></li><li class="listitem"><p>Install and remove apps</p></li></ul></div><p>If debugging is enabled on a device, you can do all of the above and more (for example, inject touch events or input text in the UI) simply by connecting the device to a computer with a USB cable. Because ADB does not depend on the device’s screen lock, you don’t have to unlock the device in order to execute ADB commands, and on most devices that provide root access, connecting via ADB allows you to access and change every file, including system files and password databases. Worse, you don’t actually need a computer with development tools in order to access an Android device via ADB; another Android device and a USB On-The-Go (OTG) cable are sufficient. Android tools that can extract as much data as possible <a id="iddle1082" class="indexterm"/><a id="iddle1527" class="indexterm"/><a id="iddle1598" class="indexterm"/><a id="iddle2993" class="indexterm"/>from another device in a very short time are readily available.<sup>[<a id="ch10fn11" href="#ftn.ch10fn11" class="footnote">110</a>]</sup> If the device is rooted, such tools can extract all of your credentials, disable or brute-force the screen lock, and even log into your Google account. But even without root, anything on external storage, most notably photos, is accessible, as are your contacts and text messages.</p></div><div class="sect2" title="Securing ADB"><div class="titlepage"><div><div><h2 class="title"><a id="securing_adb"/>Securing ADB</h2></div></div></div><p>Android 4.2 was the first version to try to make ADB access harder by hiding the Developer options settings screen, requiring you to use a “secret knock” (tapping the build number seven times) in order to enable it. While not a very effective access protection method, it makes sure that most users don’t accidentally enable ADB access. This is, of course, only a stop-gap measure, and as soon as you manage to turn USB debugging on, your device is once again vulnerable.</p><div class="figure"><a id="usb_debugging_authorization_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00066"/><img src="figs/web/10fig15.png.jpg" alt="USB debugging authorization dialog"/></div></div><p class="title">Figure 10-15. USB debugging authorization dialog</p></div><p>Android 4.2.2 introduced a proper solution with the so-called secure USB debugging feature. “Secure” here refers to the fact that only hosts that are explicitly authorized by the user can now connect to the <span class="emphasis"><em>adbd</em></span> daemon on the device and execute debugging commands. Thus if someone tries to connect a device to another one via USB in order to access ADB, they must first unlock the target device and authorize access from the debug host by clicking OK in the confirmation dialog shown in <a class="xref" href="ch10.html#usb_debugging_authorization_dialog" title="Figure 10-15. USB debugging authorization dialog">Figure 10-15</a>.</p><p>You can make your decision persistent by checking the <span class="strong"><strong>Always allow from this computer</strong></span> checkbox and debugging will work just as before, as long as you’re on the same machine.</p><p>Naturally, this secure USB debugging is only effective if you have a reasonably secure lockscreen password in place.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note10"/>Note</h3><p><span class="emphasis"><em>On tablets with multi-user support, the confirmation dialog is only shown to the primary (owner) user.</em></span></p></div></div><div class="sect2" title="Secure ADB Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="secure_adb_implementation"/>Secure ADB Implementation</h2></div></div></div><p><a id="iddle1002" class="indexterm"/><a id="iddle1078" class="indexterm"/><a id="iddle1084" class="indexterm"/><a id="iddle1085" class="indexterm"/><a id="iddle1086" class="indexterm"/><a id="iddle1525" class="indexterm"/><a id="iddle1596" class="indexterm"/><a id="iddle2991" class="indexterm"/><a id="iddle2995" class="indexterm"/>The ADB host authentication functionality is enabled by default when the <span class="emphasis"><em>ro.adb.secure</em></span> system property is set to 1, and there is no way to disable it via the system interface. When a device connects to a host, it is initially in the <code class="literal">CS_UNAUTHORIZED</code> state and only goes into the <code class="literal">CS_DEVICE</code> state after the host has authenticated. Hosts use RSA keys in order to authenticate to the ADB daemon on the device, typically following this three-step process:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>When a host tries to connect, the device sends an <code class="literal">A_AUTH</code> message with an argument of type <code class="literal">ADB_AUTH_TOKEN</code> that includes a 20-byte random value (read from <span class="emphasis"><em>/dev/urandom/</em></span>).</p></li><li class="listitem"><p>The host responds with an <code class="literal">A_AUTH</code> message with an argument of type <code class="literal">ADB_AUTH_SIGNATURE</code>, which includes a <span class="emphasis"><em>SHA1withRSA</em></span> signature of the random token with one of the host’s private keys.</p></li><li class="listitem"><p>The device tries to verify the received signature, and if signature verification succeeds, it responds with an <code class="literal">A_CNXN</code> packet and goes into the <code class="literal">CS_DEVICE</code> state. If verification fails, either because the signature value doesn’t match, or because there is no corresponding public key to verify with, the device sends another <code class="literal">ADB_AUTH_TOKEN</code> with a new random value so that the host can try authenticating again (slowing down if the number of failures goes over a certain threshold).</p></li></ol></div><p>Signature verification typically fails the first time you connect the device to a new host because it doesn’t yet have the host’s key. In that case the host sends its public key in an <code class="literal">A_AUTH</code> message with an <code class="literal">ADB_AUTH_RSAPUBLICKEY</code> argument. The device takes the MD5 hash of that key and displays it in the <span class="emphasis"><em>Allow USB debugging confirmation</em></span> dialog shown in <a class="xref" href="ch10.html#usb_debugging_authorization_dialog" title="Figure 10-15. USB debugging authorization dialog">Figure 10-15</a>. Since <span class="emphasis"><em>adbd</em></span> is a native daemon, the key must be passed to the main Android OS in order for its hash to be displayed on screen. This is accomplished by simply writing the key to a local socket (also named <span class="emphasis"><em>adbd</em></span>), which the <span class="emphasis"><em>adbd</em></span> daemon monitors.</p><p>When you enable ADB debugging from the developer settings screen, a thread that listens to that <span class="emphasis"><em>adbd</em></span> socket is started. When the thread receives a message starting with <span class="emphasis"><em>PK</em></span>, it treats it as a public key, parses it, calculates the MD5 hash and displays the confirmation dialog (implemented in a dedicated activity, <code class="literal">UsbDebuggingActivity</code>, part of the SystemUI package). If you tap OK, the activity sends a simple <span class="emphasis"><em>OK</em></span> response to <span class="emphasis"><em>adbd</em></span>, which uses the key to verify the authentication message. If you check the Always allow from this computer checkbox, the public key is written to disk and automatically used for signature verification the next time you connect to the same host.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note11"/>Note</h3><p><span class="emphasis"><em>As of version 4.3, Android allows you to clear all saved host authentication keys. This functionality can be triggered by selecting Settings</em></span>▸<span class="emphasis"><em>Developer options</em></span>▸<span class="emphasis"><em>Revoke USB debugging authorizations.</em></span></p></div><p><a id="iddle1076" class="indexterm"/><a id="iddle1083" class="indexterm"/><a id="iddle1097" class="indexterm"/><a id="iddle1152" class="indexterm"/><a id="iddle1523" class="indexterm"/><a id="iddle1528" class="indexterm"/><a id="iddle1594" class="indexterm"/><a id="iddle1599" class="indexterm"/><a id="iddle2989" class="indexterm"/><a id="iddle2994" class="indexterm"/><a id="iddle2996" class="indexterm"/>The <code class="literal">UsbDeviceManager</code> class provides public methods for allowing and denying USB debugging, clearing cached authentication keys, as well as for starting and stopping the <span class="emphasis"><em>adbd</em></span> daemon. Those methods are made available to other applications via the <code class="literal">IUsbManager</code> AIDL interface of the system <code class="literal">UsbService</code>. Calling <code class="literal">IUsbManager</code> methods that modify device state requires the <code class="literal">MANAGE_USB</code> system signature permission.</p></div><div class="sect2" title="ADB Authentication Keys"><div class="titlepage"><div><div><h2 class="title"><a id="adb_authentication_keys"/>ADB Authentication Keys</h2></div></div></div><p>Although we described the ADB authentication protocol above, we haven’t said much about the actual keys used in the process: 2048-bit RSA keys generated by the local ADB server. These keys are typically stored in <span class="emphasis"><em>$HOME/.android</em></span> (<span class="emphasis"><em>%USERPOFILE%\.android</em></span> on Windows) as <span class="emphasis"><em>adbkey</em></span> (private key) and <span class="emphasis"><em>adbkey.pub</em></span> (public key). The default key directory can be overridden by setting the <code class="literal">ANDROID_SDK_HOME</code> environment variable. If the <code class="literal">ADB_VENDOR_KEYS</code> environment variable is set, the directory it points to is also searched for keys. If no keys are found in any of the above locations, a new key pair is generated and saved.</p><p>The private key file (<span class="emphasis"><em>adbkey</em></span>), which is only stored on the host, is in standard OpenSSL PEM format. The public key file (<span class="emphasis"><em>adbkey.pub</em></span>) contains the Base 64–encoded mincrypt-compatible representation of the public key, which is basically a serialization of mincrypt’s <code class="literal">RSAPublicKey</code> structure (see “<a class="xref" href="ch10.html#enabling_verified_boot" title="Enabling Verified Boot">Enabling Verified Boot</a>”), followed by a <span class="emphasis"><em>user@host</em></span> user identifier, separated by space. The user identifier doesn’t seem to be used as of this writing and is only meaningful on Unix-based OSes; on Windows, it is always <span class="emphasis"><em>unknown@unknown</em></span>.</p><p>Keys are stored on the device in the <span class="emphasis"><em>/data/misc/adb/adb_keys/</em></span> file, and new authorized keys are appended to the same file as you accept them. Read-only “vendor keys” are stored in the <span class="emphasis"><em>/adb_keys</em></span> file, but it doesn’t seem to exist on current Nexus devices. Public keys are in the same format as on the host, making it easy to load in libmincrypt, which <span class="emphasis"><em>adbd</em></span> links statically. <a class="xref" href="ch10.html#contents_of_the_adbunderscorekeys_file" title="Example 10-13. Contents of the adb_keys file">Example 10-13</a> shows some sample <span class="emphasis"><em>adb_keys</em></span>. The file is owned by the <span class="emphasis"><em>system</em></span> user, its group is set to <span class="emphasis"><em>shell</em></span>, and its permissions to 0640.</p><div class="example"><a id="contents_of_the_adbunderscorekeys_file"/><p class="title">Example 10-13. Contents of the <span class="roman">adb_keys</span> file</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>cat data/misc/adb/adb_keys</strong></span>
QAAAAJs1UDFt17wyV+Y2GNGF+EgWoiPfsByfC4frNd3s64w3IGt25fKERnl7O8/A+iVPGv1W
--<span class="emphasis"><em>snip</em></span>--
yZ61cFd7R6ohLFYJRPB6Dy7tISUPRpb+NF4pbQEAAQA= unknown@unknown
QAAAAKFLvP+fp1cB4Eq/6zyV+hnm1S1eV9GYd7cYe+tmwuQZFe+O4vpeow6huIN8YbBRkr7
--<span class="emphasis"><em>snip</em></span>--
m7+bGd6F0hRkO82gopy553xywXU7rI/aMl6FBAEAAQA= user1@host2</pre></div></div></div><div class="sect2" title="Verifying the Host Key Fingerprint"><div class="titlepage"><div><div><h2 class="title"><a id="verifying_the_host_key_fingerprint"/>Verifying the Host Key Fingerprint</h2></div></div></div><p>While the USB debugging confirmation dialog helpfully displays a key fingerprint to let you verify that you’re connected to the expected host, the <code class="literal">adb</code> client doesn’t have a handy command to print the fingerprint of the <a id="iddle1253" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle1258" class="indexterm"/><a id="iddle1573" class="indexterm"/><a id="iddle1574" class="indexterm"/><a id="iddle1578" class="indexterm"/>host key. Although it may seem that there’s little room for confusion (after all, there is only one cable plugged in to a single machine) when running a couple of VMs, things can get a little fuzzy. <a class="xref" href="ch10.html#displaying_the_host_keyapostrophes_finge" title="Example 10-14. Displaying the host key’s fingerprint">Example 10-14</a> shows one way to display the host key’s fingerprint in the same format used by the confirmation dialog shown in <a class="xref" href="ch10.html#usb_debugging_authorization_dialog" title="Figure 10-15. USB debugging authorization dialog">Figure 10-15</a> (run in <span class="emphasis"><em>$HOME/.android</em></span> or specify the full path to the public key file).</p><div class="example"><a id="displaying_the_host_keyapostrophes_finge"/><p class="title">Example 10-14. Displaying the host key’s fingerprint</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>cut -d' ' -f1 adbkey.pub|openssl base64 -A -d -a | \</strong></span>
<span class="strong"><strong>openssl md5 -c|cut -d' ' -f2|tr '[a-z]' '[A-Z]'</strong></span>
69:D4:AC:0D:AF:6B:17:88:BA:6B:C4:BE:0C:F7:75:9A</pre></div></div></div></div><div class="sect1" title="Android Backup"><div class="titlepage"><div><div><h1 class="title"><a id="android_backup"/>Android Backup</h1></div></div></div><p>Android includes a backup framework that allows application data to be backed up to Google’s cloud storage and supports full backup of installed APK files, application data, and external storage files to a host machine connected via USB. While device backup is not exactly a security feature, backups allow application data to be extracted from the device, which can present a security issue.</p><div class="sect2" title="Android Backup Overview"><div class="titlepage"><div><div><h2 class="title"><a id="android_backup_overview"/>Android Backup Overview</h2></div></div></div><p>Android’s backup framework was publicly announced in Android 2.2, but it was probably available internally earlier. The framework lets applications declare special components called <span class="emphasis"><em>backup agents</em></span>, which are called by the system when creating a backup for an application and when restoring its data. While the backup framework did support pluggable backup transports internally, initially the only transport that was usable in practice was a proprietary one that stores application data in Google’s cloud storage.</p><div class="sect3" title="Cloud Backup"><div class="titlepage"><div><div><h3 class="title"><a id="cloud_backup"/>Cloud Backup</h3></div></div></div><p>Because backups are associated with a user’s Google account, when they install an application that has a backup agent on a new device, the application’s data can be automatically restored if the user has registered the same Google account as the one used when the backup was created. Backup and restore is managed by the system and cannot typically be triggered or controlled by users (though developer commands that trigger cloud backup are accessible via the Android shell). By default, backups are triggered periodically, and restore only when an app is first installed on a device.</p></div><div class="sect3" title="Local Backup"><div class="titlepage"><div><div><h3 class="title"><a id="local_backup"/>Local Backup</h3></div></div></div><p>Android 4.0 added a new, local backup transport that lets users save backups to a file on their desktop computer as well. Local backup (also called full backup) requires ADB debugging to be enabled and authorized because <a id="iddle1093" class="indexterm"/><a id="iddle1130" class="indexterm"/><a id="iddle1257" class="indexterm"/><a id="iddle1259" class="indexterm"/><a id="iddle1577" class="indexterm"/><a id="iddle1838" class="indexterm"/>backup data is streamed to the host computer using the same method that ADB (via <code class="literal">adb pull</code>) employs to transfer device files to a host.</p><div class="figure"><a id="backup_confirmation_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00067"/><img src="figs/web/10fig16.png.jpg" alt="Backup confirmation dialog"/></div></div><p class="title">Figure 10-16. Backup confirmation dialog</p></div><p>Full backup is started by executing the <code class="literal">adb backup</code> command in a shell. This command starts a new Java process on the device, which binds to the system’s <code class="literal">BackupManagerService</code> and requests a backup with the parameters specified to <code class="literal">adb backup</code>. The <code class="literal">BackupManagerService</code> in turn starts a confirmation activity like the one shown in <a class="xref" href="ch10.html#backup_confirmation_dialog" title="Figure 10-16. Backup confirmation dialog">Figure 10-16</a>, prompting the user to authorize the backup and specify a backup encryption password if desired. If the device is already encrypted, the user must enter the device encryption password to proceed. This password will be used to encrypt the backup as well, because using a dedicated backup encryption password is not supported. The full backup process is started when the user presses the Back up my data button.</p><p>Full backup calls the backup agent of each target package in order to obtain a copy of its data. If a backup agent is not defined, the <code class="literal">BackupManagerService</code> uses an internal <code class="literal">FullBackupAgent</code> class, which copies all of the package’s files. Full backup honors the <code class="literal">allowBackup</code> attribute of the <code class="literal">&lt;application&gt;</code> tag in the package’s <span class="emphasis"><em>AndroidManifest.xml</em></span> file, and will not extract package data if <code class="literal">allowBackup</code> is set to <code class="literal">false</code>.</p><p>In addition to application data, full backup can include user-installed and system application APK files, as well as external storage contents, with some limitations: full backup doesn’t back up protected (with DRM) apps, and skips some system settings such as mobile network APNs and Wi-Fi access points’ connection details.</p><p>Backups are restored using the <code class="literal">adb restore</code> command. Backup restore is quite limited and doesn’t allow any options to be specified, as it can only perform a full restore.</p></div></div><div class="sect2" title="Backup File Format"><div class="titlepage"><div><div><h2 class="title"><a id="backup_file_format"/>Backup File Format</h2></div></div></div><p>Android backup files start with a few lines of text, followed by binary data. These lines are the backup header and they specify the backup format and encryption parameters (if a backup password was specified) used to create the backup. The header of an unencrypted backup is shown in <a class="xref" href="ch10.html#unencrypted_backup_header" title="Example 10-15. Unencrypted backup header">Example 10-15</a>.</p><div class="example"><a id="unencrypted_backup_header"/><p class="title">Example 10-15. Unencrypted backup header</p><div class="example-contents"><pre class="programlisting">ANDROID BACKUP➊
1➋
1➌
none➍</pre></div></div><p><a id="iddle1260" class="indexterm"/>The first line ➊ is the file magic (format identifier), the second ➋ is the backup format version (1 up till Android 4.4.2, 2 in later versions; version 2 denotes a change in the key derivation method, which now takes into account multibyte password characters), the third ➌ is a compression flag (1 if compressed), and the last ➍ is the encryption algorithm used (<span class="emphasis"><em>none</em></span> or <span class="emphasis"><em>AES-256</em></span>).</p><p>The actual backup data is a compressed and optionally encrypted tar file that includes a backup manifest file, followed by the application APK (if any), and app data (files, databases, and shared preferences). The data is compressed using the deflate algorithm and can be decompressed using OpenSSL’s <code class="literal">zlib</code> command, as shown in <a class="xref" href="ch10.html#uncompressing_an_android_backup_using_op" title="Example 10-16. Uncompressing an Android backup using OpenSSL">Example 10-16</a>.</p><div class="example"><a id="uncompressing_an_android_backup_using_op"/><p class="title">Example 10-16. Uncompressing an Android backup using OpenSSL</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>dd if=mybackup.ab bs=24 skip=1|openssl zlib -d &gt; mybackup.tar</strong></span></pre></div></div><p>After the backup is uncompressed, you can view its contents or extract it with the standard <code class="literal">tar</code> command, as shown in <a class="xref" href="ch10.html#viewing_the_contents_of_an_uncompressed" title="Example 10-17. Viewing the contents of an uncompressed backup using tar">Example 10-17</a>.</p><div class="example"><a id="viewing_the_contents_of_an_uncompressed"/><p class="title">Example 10-17. Viewing the contents of an uncompressed backup using <code class="literal">tar</code></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>tar tvf mybackup.tar</strong></span>
-rw------- 1000/1000          1019 apps/org.myapp/_manifest➊
-rw-r--r-- 1000/1000       1412208 apps/org.myapp/a/org.myapp-1.apk➋
-rw-rw---- 10091/10091         231 apps/org.myapp/f/share_history.xml➌
-rw-rw---- 10091/10091           0 apps/org.myapp/db/myapp.db-journal➍
-rw-rw---- 10091/10091        5120 apps/org.myapp/db/myapp.db
-rw-rw---- 10091/10091        1110 apps/org.myapp/sp/org.myapp_preferences.xml➎</pre></div></div><p>Inside the tar file, app data is stored in the <span class="emphasis"><em>apps/</em></span> directory, which contains a subdirectory for each backed-up package. Each package directory includes a <span class="emphasis"><em>_manifest</em></span> file ➊ in its root, the APK file (if requested) in <span class="emphasis"><em>a/</em></span> ➋, app files in <span class="emphasis"><em>f/</em></span> ➌, databases in <span class="emphasis"><em>db/</em></span> ➍, and shared preferences in <span class="emphasis"><em>sp/</em></span> ➎. The manifest contains the app’s package name and version code, the platform’s version code, a flag indicating whether the archive contains the app APK, and the app’s signing certificate.</p><p>The <code class="literal">BackupManagerService</code> uses this information when restoring an app in order to check whether it’s been signed with the same certificate as the currently installed one. If the certificates don’t match, it will skip installing the APK, except for system packages, which might be signed with a different (manufacturer-owned) certificate on different devices. Additionally, <code class="literal">BackupManagerService</code> expects the files to be in the order shown in <a class="xref" href="ch10.html#viewing_the_contents_of_an_uncompressed" title="Example 10-17. Viewing the contents of an uncompressed backup using tar">Example 10-17</a> <a id="iddle1118" class="indexterm"/><a id="iddle1256" class="indexterm"/><a id="iddle1576" class="indexterm"/><a id="iddle1723" class="indexterm"/><a id="iddle2433" class="indexterm"/>and restore will fail if they are out for order. For example, if the manifest states that the backup includes an APK, the <code class="literal">BackupManagerService</code> will try to read and install the APK first, before restoring the app’s files. This restore order is required because you cannot restore files for an app you don’t have installed. However, <code class="literal">BackupManagerService</code> will not search for the APK in the archive, and if it is not right after the manifest, all other files will be skipped.</p><p>If the user requested external storage backup (by passing the <code class="literal">-shared</code> option to <code class="literal">adb backup</code>), there will also be a <span class="emphasis"><em>shared/</em></span> directory in the archive, containing external storage files.</p></div><div class="sect2" title="Backup Encryption"><div class="titlepage"><div><div><h2 class="title"><a id="backup_encryption"/>Backup Encryption</h2></div></div></div><p>If the user supplied an encryption password when requesting the backup, the backup file is encrypted with a key derived from the password. The password is used to generate a 256-bit AES key using 10,000 rounds of PBKDF2 with a randomly generated 512-bit salt. This key is then used to encrypt another, randomly generated 256-bit AES bit master key, which is in turn used to encrypt the actual archive data in CBC mode (using the <span class="emphasis"><em>AES/CBC/PKCS5Padding</em></span> <code class="literal">Cipher</code> transformation). A master key checksum is also calculated and saved in the backup file header. In order to generate the checksum, the generated raw master key is converted to a Java character array by casting each byte to <code class="literal">char</code>, with the result treated as a password string, and run through the PBKDF2 function to effectively generate another AES key, whose bytes are used as the checksum.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note12"/>Note</h3><p><span class="emphasis"><em>Because an AES key is essentially a random byte sequence, the raw key usually contains several bytes that don’t map to printable characters. Because PKCS#5 does not specify the actual encoding of a password string, Android’s encryption checksum generation method produces implementation and version-dependent results.</em></span></p></div><p>The checksum is used to verify whether the user-supplied decryption password is correct before actually decrypting the backup data. When the master key is decrypted, its checksum is calculated using the method described above and then compared to the checksum in the archive header. If the checksums don’t match, the password is considered incorrect, and the restore process is aborted. <a class="xref" href="ch10.html#encrypted_backup_header" title="Example 10-18. Encrypted backup header">Example 10-18</a> shows an example backup header for an encrypted archive.</p><div class="example"><a id="encrypted_backup_header"/><p class="title">Example 10-18. Encrypted backup header</p><div class="example-contents"><pre class="programlisting">ANDROID BACKUP
1
1
AES-256➊
68404C30DF8CACA5FA004F49BA3A70...➋
909459ADCA2A60D7C2B117A6F91E3D...➌
10000➍
789B1A01E3B8FA759C6459AF1CF1F0FD ➎
8DC5E483D3893EC7F6AAA56B97A6C2...➏</pre></div></div><p><a id="iddle1131" class="indexterm"/><a id="iddle1255" class="indexterm"/><a id="iddle1575" class="indexterm"/>Here, <span class="emphasis"><em>AES-256</em></span> ➊ is the backup encryption algorithm used, the next line ➋ is the user password salt as a hexadecimal string, followed by the master key checksum salt ➌, the number of PBKDF2 rounds used to derive a key ➍, and the user key IV ➎. The final line ➏ is the master key blob, which contains the archive data encryption IV, the actual master key and its checksum, all encrypted with the key derived from the user-supplied password. <a class="xref" href="ch10.html#master_key_blob_format" title="Example 10-19. Master key blob format">Example 10-19</a> shows the detailed format of the master key blob.</p><div class="example"><a id="master_key_blob_format"/><p class="title">Example 10-19. Master key blob format</p><div class="example-contents"><pre class="programlisting">byte Niv➊
byte[Niv] IV➋
byte Nmk➌
byte [Nmk] MK➍
byte Nck➎
byte [Nck] MKck➏</pre></div></div><p>The first field ➊ is the IV length, followed by the IV value ➋, the master key (MK) length ➌, and the actual master key ➍. The last two fields store the master key checksum hash length ➎, and the master key checksum hash itself ➏.</p></div><div class="sect2" title="Controlling Backup Scope"><div class="titlepage"><div><div><h2 class="title"><a id="controlling_backup_scope"/>Controlling Backup Scope</h2></div></div></div><p>Android’s security model guarantees that each application runs within its own sandbox and that its files cannot be accessed by other applications or the device user, unless the application explicitly allows access. Therefore, most applications do not encrypt their data before storing it to disk. However, both legitimate users and attackers that have somehow obtained the device unlock password can easily extract applications data using Android’s full backup feature. For this reason, applications that store sensitive data should either encrypt it or provide an explicit backup agent that limits exportable data in order to guarantee that sensitive data cannot be easily extracted via backup.</p><p>As mentioned in “<a class="xref" href="ch10.html#android_backup_overview" title="Android Backup Overview">Android Backup Overview</a>”, if application data backup isn’t needed or desirable, applications can disallow it completely by setting their <code class="literal">allowBackup</code> attribute to <code class="literal">false</code> in <span class="emphasis"><em>AndroidManifest.xml</em></span>, as shown in <a class="xref" href="ch10.html#disallowing_application_data_backup_in_a" title="Example 10-20. Disallowing application data backup in AndroidManifest.xml">Example 10-20</a>.</p><div class="example"><a id="disallowing_application_data_backup_in_a"/><p class="title">Example 10-20. Disallowing application data backup in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
   package="org.example.app"
   android:versionCode="1"
   android:versionName="1.0" &gt;
   --<span class="emphasis"><em>snip</em></span>--
   &lt;application
       android:icon="@drawable/ic_launcher"
       android:label="@string/app_name"
       android:theme="@style/AppTheme"
       android:allowBackup="false"&gt;
        --<span class="emphasis"><em>snip</em></span>-
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00024"/>Summary</h1></div></div></div><p>Android employs various measures in order to protect user data and applications, and ensure the integrity of the operating system. On production devices, the bootloader is locked, and the recovery OS only allows OTA updates signed by the device manufacturer to be installed, thus ensuring that only authorized OS builds can be booted or flashed to a device. When enabled, dm-verity-based verified boot guarantees that the <span class="emphasis"><em>system</em></span> partition is not modified by checking the hash value of each device block against a trusted hash tree, which prevents the installation of malicious programs such as rootkits on the <span class="emphasis"><em>system</em></span> partition. Android can also encrypt the <span class="emphasis"><em>userdata</em></span> partition, making it harder to extract applications data by directly accessing storage devices.</p><p>Android supports various screen lock methods and applies rate limiting to unsuccessful authentication attempts, thus deterring online attacks against a booted device. The type and complexity of the unlock PIN or password can be specified and enforced by device administrator applications. A device policy that wipes the device after too many unsuccessful authentication attempts is also supported. Secure USB debugging requires debug hosts to be explicitly authorized by the user and added to a whitelist, thus preventing information extraction via USB.</p><p>Finally, full device backups can be encrypted with a key derived from a user-supplied password, making it harder to access device data that has been extracted into a backup. To achieve a higher level of device security, all supported security measures should be enabled and configured accordingly.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch10fn01" href="#ch10fn01" class="para">100</a>] </sup>Milan Broz, “dm-verity: device-mapper block integrity checking target,” <span class="emphasis"><em><a class="ulink" href="https://code.google.com/p/cryptsetup/wiki/DMVerity">https://code.google.com/p/cryptsetup/wiki/DMVerity</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn02" href="#ch10fn02" class="para">101</a>] </sup>Red Hat, Inc., “Device-Mapper Resource Page,” <span class="emphasis"><em><a class="ulink" href="https://www.sourceware.org/dm/">https://www.sourceware.org/dm/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn03" href="#ch10fn03" class="para">102</a>] </sup>Google, “dm-verity on boot,” <span class="emphasis"><em><a class="ulink" href="https://source.android.com/devices/tech/security/dm-verity.html">https://source.android.com/devices/tech/security/dm-verity.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn04" href="#ch10fn04" class="para">103</a>] </sup>Google, <span class="emphasis"><em>Android 4.4 Compatibility Definition</em></span>, “9.9. Full-Disk Encryption,” <span class="emphasis"><em><a class="ulink" href="https://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf">https://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn05" href="#ch10fn05" class="para">104</a>] </sup>Milan Broz, “dm-crypt: Linux kernel device-mapper crypto target,” <span class="emphasis"><em><a class="ulink" href="https://code.google.com/p/cryptsetup/wiki/DMCrypt">https://code.google.com/p/cryptsetup/wiki/DMCrypt</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn06" href="#ch10fn06" class="para">105</a>] </sup>Jakob Lell, “Practical malleability attack against CBC-Encrypted LUKS partitions,” <span class="emphasis"><em><a class="ulink" href="http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/">http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn07" href="#ch10fn07" class="para">106</a>] </sup>C. Percival and S. Josefsson, <span class="emphasis"><em>The scrypt Password-Based Key Derivation Function</em></span>, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01/">http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn08" href="#ch10fn08" class="para">107</a>] </sup>Demonstrated by viaForensics in the “Into The Droid” talk, presented at DEF CON 20. Slides are available at <span class="emphasis"><em><a class="ulink" href="https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/DEFCON-20-Cannon-Into-The-Droid.pdf">https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/DEFCON-20-Cannon-Into-The-Droid.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn09" href="#ch10fn09" class="para">108</a>] </sup>Anthony King, “PyAdb: basic ADB core for python using TCP,” <span class="emphasis"><em><a class="ulink" href="https://github.com/cybojenix/PyAdb/">https://github.com/cybojenix/PyAdb/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn10" href="#ch10fn10" class="para">109</a>] </sup>Kenny Root, “adb-on-chrome: ADB (Android Debug Bridge) server as a Chrome extension,” <span class="emphasis"><em><a class="ulink" href="https://github.com/kruton/adb-on-chrome/">https://github.com/kruton/adb-on-chrome/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch10fn11" href="#ch10fn11" class="para">110</a>] </sup>Kyle Osborn, “p2p-adb Framework,” <span class="emphasis"><em><a class="ulink" href="https://github.com/kosborn/p2p-adb/">https://github.com/kosborn/p2p-adb/</a></em></span></p></div></div></div></body></html>