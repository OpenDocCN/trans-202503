["```\ndef Dijkstras(g: Graph, start_index: int) -> list: \n    cost: list = [math.inf] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    pq: PriorityQueue = PriorityQueue(min_heap=True)\n\n  ❶ pq.enqueue(start_index, 0.0)\n    for i in range(g.num_nodes):\n        if i != start_index:\n            pq.enqueue(i, math.inf)\n    cost[start_index] = 0.0\n\n    while not pq.is_empty():\n      ❷ index: int = pq.dequeue()\n\n        for edge in g.nodes[index].get_edge_list():\n            neighbor: int = edge.to_node\n\n          ❸ if pq.in_queue(neighbor):\n                new_cost: float = cost[index] + edge.weight\n              ❹ if new_cost < cost[neighbor]:\n                  ❺ pq.update_priority(neighbor, new_cost)\n                    last[neighbor] = index\n                    cost[neighbor] = new_cost\n\n    return last \n```", "```\ndef BellmanFord(g: Graph, start_index: int) -> Union[list, None]: \n    cost: list = [math.inf] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    all_edges: list = g.make_edge_list()\n    cost[start_index] = 0.0 for itr in range(g.num_nodes - 1):\n        for edge in all_edges:\n          ❶ cost_thr_node: float = cost[edge.from_node] + edge.weight\n          ❷ if cost_thr_node < cost[edge.to_node]:\n                cost[edge.to_node] = cost_thr_node\n                last[edge.to_node] = edge.from_node\n\n    for edge in all_edges:\n      ❸ if cost[edge.to_node] > cost[edge.from_node] + edge.weight:\n            return None\n    return last \n```", "```\nlast: list = []\nfor n in range(g.num_nodes):\n    last.append(BellmanFord(g, n))\nreturn last \n```", "```\ndef FloydWarshall(g: Graph) -> list: \n    N: int = g.num_nodes\n    cost: list = [[math.inf] * N for _ in range(N)] last: list = [[-1] * N for _ in range(N)]\n  ❶ for i in range(N):\n        for j in range(N):\n            if i == j:\n                cost[i][j] = 0.0\n            else:\n                edge: Union[Edge, None] = g.get_edge(i, j)\n                if edge is not None:\n                    cost[i][j] = edge.weight\n                  ❷ last[i][j] = i\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n              ❸ if cost[i][j] > cost[i][k] + cost[k][j]:\n                    cost[i][j] = cost[i][k] + cost[k][j]\n                  ❹ last[i][j] = last[k][j]\n    return last \n```", "```\ndef GraphDiameter(g: Graph) -> float: \n  ❶ last: list = FloydWarshall(g)\n    max_cost: float = -math.inf\n\n    for i in range(g.num_nodes):\n        for j in range(g.num_nodes):\n            cost: float = 0.0\n            current: int = j\n\n          ❷ while current != i:\n                prev: int = last[i][current]\n              ❸ if prev == -1:\n                    return math.inf\n\n                edge: Union[Edge, None] = g.get_edge(prev, current)\n                cost = cost + edge.weight\n                current = prev\n\n          ❹ if cost > max_cost:\n                max_cost = cost\n\n    return max_cost \n```"]