- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 14 HEAPS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14 堆
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In the last chapter, we worked with binary trees, and we’ll continue doing
    so in this chapter, but with a variant that is stored without the need for dynamic
    memory: heaps. Heaps allow for easy implementation of a new abstract data type
    (ADT), a good performance sorting method, and a new structure for an enhanced
    version of binary search trees. We’ll consider implementing heaps (in particular,
    binary max heaps, but other types too), and we’ll look at using heaps for priority
    queues, sorting arrays with heapsort, and searching with another new structure
    called treaps*.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，我们处理了二叉树，本章我们将继续使用二叉树，不过这次使用的是一种不需要动态内存的变体：堆。堆允许我们轻松实现一个新的抽象数据类型（ADT）、一个高效的排序方法，并为二叉搜索树的增强版本提供新的结构。我们将考虑实现堆（特别是二叉最大堆，但也包括其他类型），并探讨堆在优先队列、堆排序和另一种叫做treaps*的新结构中的应用。
- en: In the next chapter, we’ll follow with another representation for heaps that
    uses dynamic memory and allows for more freedom and better performance for some
    new operations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍另一种堆的表示方法，它使用动态内存，并且为一些新操作提供了更多的自由度和更好的性能。
- en: '### Binary Heaps'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 二叉堆'
- en: 'A *binary heap*, usually referred to simply as a *heap*, is a type of binary
    tree with two particular properties: a *structure property* that determines the
    shape of the tree and a *heap property* that specifies the relationship between
    the key of a parent node and those of its children.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉堆*，通常简称为*堆*，是一种具有两个特定属性的二叉树：一个*结构属性*，决定了树的形状；一个*堆属性*，指定了父节点与子节点键值之间的关系。'
- en: The Structure Property
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结构属性
- en: Heaps are a subset of binary trees, and the structure property requires that
    the tree must be complete and that all leaves on the last level must be located
    on the left. Consider the trees in [Figure 14-1](chapter14.xhtml#fig14-1). Only
    one qualifies as a heap while the other two fail. Can you tell which is which?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是二叉树的一个子集，结构属性要求树必须是完全树，且最后一层的所有叶子节点必须位于左侧。请看[图 14-1](chapter14.xhtml#fig14-1)中的树。只有一个符合堆的条件，而其他两个不符合。你能分辨出哪个是哪个吗？
- en: '![](../images/Figure14-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-1.jpg)'
- en: 'Figure 14-1: Of these three heap candidates, which is the right one?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：在这三种堆候选中，哪一个是正确的？
- en: The tree on the left in [Figure 14-1](chapter14.xhtml#fig14-1) is the only heap.
    The tree in the middle has an incomplete middle level, and in the tree on the
    right, the bottom children are not all on the left.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](chapter14.xhtml#fig14-1)中左边的树是唯一的堆。中间的树有一个不完整的中间层，而右边的树则底部的子节点不全在左侧。'
- en: Given this rule, you can store a heap in a common array without dynamic memory
    or pointers to simplify implementation. (See question 14.18 to consider an alternative.)
    Place the root at the first position of the array, followed by the nodes at the
    second level from left to right, then the nodes at the third level (also from
    left to right), and so on. [Figure 14-2](chapter14.xhtml#fig14-2) shows how the
    array looks for a sample case. The numbers in the nodes correspond to indices
    in the array.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个规则，你可以在一个普通的数组中存储堆，而无需动态内存或指针，从而简化实现。（参见问题 14.18，考虑另一种替代方案。）将根节点放在数组的第一个位置，然后依次放置第二层节点（从左到右）、第三层节点（也是从左到右），以此类推。[图
    14-2](chapter14.xhtml#fig14-2)展示了一个示例的数组布局。节点中的数字对应于数组中的索引。
- en: '![](../images/Figure14-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-2.jpg)'
- en: 'Figure 14-2: Storing a heap’s nodes in an array'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：将堆的节点存储在数组中
- en: In this representation, the heap’s root is always at position 0\. The left and
    right children of the node at position p are placed in consecutive adjacent positions,
    2*p+1 and 2*p+2, respectively—unless they fall beyond the end of the heap, in
    which case the node has fewer children. The parent of a non-root node at position
    p is found at the Math.floor((p-1)/2) position.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示法中，堆的根节点总是位于位置 0。位置为 p 的节点的左右子节点分别位于连续的相邻位置 2*p+1 和 2*p+2，除非它们超出了堆的末尾，此时该节点的子节点会较少。非根节点位置
    p 的父节点位于 Math.floor((p-1)/2) 位置。
- en: You can verify those rules with a few examples. The children of the root (at
    position 0) are at positions 2*0 + 1=1 and 2*0 + 2=2. Node 4 has a single child
    at position 2*4 + 1=9, because the other child would be beyond the heap size.
    The parent of node 9 is at position Math.floor((9-1)/2)=4. The parent of node
    2 is at position Math.floor((2-1)/2)=1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几个示例验证这些规则。根节点（在位置0）的子节点位于位置2*0 + 1=1和2*0 + 2=2。节点4有一个子节点，位于位置2*4 + 1=9，因为另一个子节点会超出堆的大小。节点9的父节点位于位置Math.floor((9-1)/2)=4。节点2的父节点位于位置Math.floor((2-1)/2)=1。
- en: These rules let you implement algorithms without needing any pointers; a simple
    array suffices. As with complete trees in [Chapter 12](chapter12.xhtml), if a
    heap has up to *n* = 2*^h*^(–1) nodes, its height will be *h*, so its height is
    bounded by log *n*, a result that will feature in order calculations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则让你能够实现算法而无需任何指针；一个简单的数组就足够了。与[第12章](chapter12.xhtml)中的完全树一样，如果堆最多有*n* =
    2*^h*^(–1)个节点，则它的高度将是*h*，因此它的高度受限于log *n*，这是在顺序计算中会出现的一个结果。
- en: The Heap Property
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆属性
- en: 'The second property of heaps is simple: the key of a node must be greater than
    or equal to the keys of its children. This is an important contrast from binary
    search trees: in heaps, there’s no difference between a left child and a right
    child (either could be greater than the other), although they both will be smaller
    than or equal to their parent. Any tree that follows both the structure property
    and the heap property is called a *binary max heap* or, more simply, a *heap*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的第二个属性很简单：节点的键值必须大于或等于其子节点的键值。这与二叉搜索树有重要的区别：在堆中，左右子节点没有区别（任意一个可能大于另一个），但它们的键值都会小于或等于其父节点。任何同时遵循结构属性和堆属性的树被称为*二叉最大堆*，或者更简单地，称为*堆*。
- en: NOTE
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Why do I say the word heap means “max heap” by default? The song “New York,
    New York” may give us a clue: Frank Sinatra describes wanting to be “king of the
    hill” or “top of the heap.” This suggests the root (top) of the heap should be
    the greatest value, doesn’t it?*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么我说堆默认表示“最大堆”？歌曲《New York, New York》也许能给我们一些线索：弗兰克·辛纳特拉描述了想成为“山丘之王”或“堆顶之王”。这表明堆的根节点（顶部）应该是最大的值，不是吗？*'
- en: You can reverse the condition and specify that the parent’s key be smaller than
    or equal to those of its children, meaning the root would be the minimum value
    of the heap. This variant is called a *min heap*, and you can use it (among other
    scenarios) to merge several linked lists, which requires finding the minimum of
    many elements repeatedly (see question 14.5). The heap shown in [Figure 14-3](chapter14.xhtml#fig14-3)
    satisfies both the structure and heap properties.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以反转条件，指定父节点的键值要小于或等于其子节点的键值，这意味着根节点将是堆的最小值。这个变体称为*最小堆*，你可以在（其他场景中）使用它来合并多个链表，这需要反复找到许多元素中的最小值（见第14.5题）。[图14-3](chapter14.xhtml#fig14-3)中显示的堆同时满足结构和堆的属性。
- en: '![](../images/Figure14-3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-3.jpg)'
- en: 'Figure 14-3: A valid heap'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-3：有效的堆
- en: As mentioned previously, this tree also could be represented by an array where
    60 (the root) is at position 0 of the array, as shown in [Figure 14-4](chapter14.xhtml#fig14-4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这棵树也可以通过数组来表示，其中60（根节点）位于数组的第0个位置，如[图14-4](chapter14.xhtml#fig14-4)所示。
- en: '![](../images/Figure14-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-4.jpg)'
- en: 'Figure 14-4: The same heap shown in [Figure 14-3](chapter14.xhtml#fig14-3),
    as stored in an array'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4：与[图14-3](chapter14.xhtml#fig14-3)相同的堆，以数组形式存储
- en: 'The heap property has an immediate consequence: the highest value in the heap
    will necessarily be at its root; can you see why? Where in the heap will you find
    its second highest value? The third highest? The fourth? (See question 14.13.)
    This result will be key for a sorting algorithm called *heapsort*, which we’ll
    study later in this chapter.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 堆属性有一个直接的结果：堆中的最大值必然位于根节点；你能看出为什么吗？你会在堆中的哪里找到第二大值？第三大值？第四大值？（见第14.13题。）这个结果对于我们稍后在本章中学习的一种排序算法*堆排序*至关重要。
- en: Heap Implementation
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆实现
- en: To implement a heap, you need only a simple array. A heap is a data structure
    with a few operations, as shown in [Table 14-1](chapter14.xhtml#tab14-1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现堆，你只需要一个简单的数组。堆是一种数据结构，具有一些操作，如[表14-1](chapter14.xhtml#tab14-1)所示。
- en: 'Table 14-1: Operations on Heaps'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-1：堆的操作
- en: '| Operation | Signature | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → H | Create a new heap. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → H | 创建一个新的堆。 |'
- en: '| Empty? | H → boolean | Determine whether the heap is empty. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | H → boolean | 确定堆是否为空。 |'
- en: '| Top | H → key | Given a heap, produce its top value. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Top | H → key | 给定一个堆，返回它的顶部值。 |'
- en: '| Add | H × key → H | Given a new value, add it to the heap. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Add | H × key → H | 给定一个新值，将其添加到堆中。 |'
- en: '| Remove | H → H × key | Given a heap, extract its top value and update the
    structure correspondingly. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Remove | H → H × key | 给定一个堆，提取其顶部值并相应更新结构。 |'
- en: 'The functions you’ll implement for those operations are:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为这些操作实现的函数是：
- en: '**newHeap() **Creates a new heap'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**newHeap() **创建一个新的堆'
- en: '**isEmpty(heap) **Determines whether the heap is empty'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**isEmpty(heap) **判断堆是否为空'
- en: '**top(heap) **Gets the value of the topmost (maximum) element of the heap'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**top(heap) **获取堆顶（最大）元素的值'
- en: '**add(heap, value) **Adds a new element to the heap'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**add(heap, value) **将新元素添加到堆中'
- en: '**remove(heap) **Removes the topmost element of the heap'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**remove(heap) **移除堆顶元素'
- en: 'The first three functions are very short:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个函数非常简短：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a new empty heap is the same as returning an empty array ❶. The size
    of the heap is heap.length, so checking it for 0 tells you whether the heap is
    empty ❷. Also, the top of the heap (unless the heap is empty, in which case this
    code returns undefined) is at the first position of the array ❸, so the implementation
    details are straightforward.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的空堆与返回一个空数组相同❶。堆的大小是heap.length，因此检查其是否为0可以判断堆是否为空❷。另外，堆的顶部（除非堆为空，此时该代码返回undefined）位于数组的第一个位置❸，所以实现细节非常直接。
- en: Adding to a Heap
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向堆中添加元素
- en: 'To add a new value to the heap, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 向堆中添加新值的步骤如下：
- en: 1. Add the new value at the end of the array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将新值添加到数组的末尾。
- en: 2. If the value is greater than its parent, exchange places with it repeatedly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果值大于其父节点，反复交换位置。
- en: 3. When the value is smaller than its parent or when it gets to the top of the
    heap, stop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 当值小于父节点或者到达堆顶时，停止。
- en: Let’s see how this works. Start with the heap shown in [Figure 14-5](chapter14.xhtml#fig14-5).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的。首先看一下[图14-5](chapter14.xhtml#fig14-5)中显示的堆。
- en: '![](../images/Figure14-5.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-5.jpg)'
- en: 'Figure 14-5: An initial heap, before adding a new value'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-5：初始堆，在添加新值之前
- en: If you want to insert a new value of 56, the first step is to add it at the
    end of the heap, so you’d get the result shown in [Figure 14-6](chapter14.xhtml#fig14-6).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想插入一个新的值56，第一步是将它添加到堆的末尾，这样你就会得到[图14-6](chapter14.xhtml#fig14-6)所示的结果。
- en: '![](../images/Figure14-6.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-6.jpg)'
- en: 'Figure 14-6: The new value (56) starts at the end of the heap.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-6：新值（56）从堆的末尾开始。
- en: Let’s see if the new value should bubble up. Comparing 56 with its parent (24)
    shows that they need to be swapped, resulting in a new heap configuration (see
    [Figure 14-7](chapter14.xhtml#fig14-7)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新值是否需要上浮。比较56与其父节点（24）后，发现它们需要交换，结果是得到一个新的堆配置（见[图14-7](chapter14.xhtml#fig14-7)）。
- en: '![](../images/Figure14-7.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-7.jpg)'
- en: 'Figure 14-7: If the new value is greater than its parent, it has to “bubble”
    up.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-7：如果新值大于父节点，它必须“上浮”。
- en: After bubbling up, keep checking recursively, and a new upward movement is required
    (see [Figure 14-8](chapter14.xhtml#fig14-8)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上浮后，继续递归检查，如果需要，继续向上移动（见[图14-8](chapter14.xhtml#fig14-8)）。
- en: '![](../images/Figure14-8.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-8.jpg)'
- en: 'Figure 14-8: Bubbling up continues until the added value is not greater than
    its parent or at the root of the heap.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-8：上浮继续，直到添加的值不大于其父节点或位于堆的根部。
- en: The last step led to a situation where the inserted value is not greater than
    its parent, so the algorithm stops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步导致了插入值不大于其父节点的情况，因此算法停止。
- en: 'Our version of add() is short and to the point:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的add()版本简洁明了：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As described, the new value was added at the end of the heap ❶, and it was forced
    to bubble up to its final position ❷ by using the _bubbleUp() auxiliary function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，新的值被添加到堆的末尾❶，并通过使用_bubbleUp()辅助函数强制它上浮到最终位置❷。
- en: 'As before, a recursive implementation is easiest. If the element has moved
    up, apply _bubbleUp() recursively to keep it moving:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，递归实现是最简单的。如果元素已经上浮，使用_bubbleUp()递归应用以保持其上浮：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the element is not already at the top of the heap ❶, use math (as in “The
    Structure Property” on page 318) to determine the parent p of position i ❷. If
    you need to swap elements ❸, destructuring makes it easy ❹, and you can keep bubbling
    up (if needed) by using recursion ❺.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素尚未位于堆顶❶，则使用数学方法（如“结构属性”第318页所示）确定位置i的父节点p❷。如果需要交换元素❸，使用解构赋值非常方便❹，并且可以通过递归继续上浮（如果需要）❺。
- en: Removing from a Heap
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从堆中移除
- en: Next you need the remove() method. Remember that the whole heap must become
    one element smaller, so what happens after removing the top of the heap? If the
    heap is empty, there’s nothing to remove; throw an exception, and you’re done.
    Otherwise, pick the last element of the heap, place it at the top, and then reduce
    the heap size by one. If the element doesn’t have any children, stop. If the element
    is greater than the greatest of its children, also stop. Otherwise, exchange the
    element with its greatest child and keep moving it down.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要 `remove()` 方法。记住，整个堆必须变小一个元素，所以移除堆顶后会发生什么呢？如果堆为空，就没有东西可移除；抛出异常，然后完成。如果堆不为空，取出堆中的最后一个元素，放到堆顶，然后将堆的大小减去一。如果该元素没有子节点，就停止。如果该元素大于其子节点中的最大值，也停止。否则，将该元素与它的最大子节点交换，并继续将它向下移动。
- en: Here is an example of how this works. Start with the heap in [Figure 14-9](chapter14.xhtml#fig14-9).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了这个过程是如何工作的。请从[图 14-9](chapter14.xhtml#fig14-9)中的堆开始。
- en: '![](../images/Figure14-9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-9.jpg)'
- en: 'Figure 14-9: An initial heap before removing its top'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-9：移除堆顶之前的初始堆
- en: The first step involves removing the top value (60), replacing it with the last
    value in the heap (22), and shortening the heap by one, which leads to the situation
    shown in [Figure 14-10](chapter14.xhtml#fig14-10). The value that needs to be
    moved downward to restore the heap is highlighted.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是移除堆顶的值（60），用堆中的最后一个值（22）替换它，然后将堆的大小减去一，这样就得到了[图 14-10](chapter14.xhtml#fig14-10)所示的情况。需要向下移动的值已被高亮显示。
- en: '![](../images/Figure14-10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-10.jpg)'
- en: 'Figure 14-10: After removing the top, replace it with the last element of the
    heap (22).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-10：移除堆顶后，将其替换为堆中的最后一个元素（22）。
- en: Now start sifting down. Comparing 22 with its children, it needs to be swapped
    with 56, which results in the new situation shown in [Figure 14-11](chapter14.xhtml#fig14-11).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始向下筛选。将 22 与它的子节点进行比较，需要与 56 交换，这样就得到了[图 14-11](chapter14.xhtml#fig14-11)所示的新情况。
- en: '![](../images/Figure14-11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-11.jpg)'
- en: 'Figure 14-11: If the new top isn’t greater than its children, it must “sink”
    down.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-11：如果新的堆顶不大于其子节点，它必须“下沉”。
- en: Recursively, compare 22 with its new children, and again, it needs to sink down,
    as shown in [Figure 14-12](chapter14.xhtml#fig14-12).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地将 22 与它的新子节点进行比较，结果它仍然需要向下筛选，如[图 14-12](chapter14.xhtml#fig14-12)所示。
- en: '![](../images/Figure14-12.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-12.jpg)'
- en: 'Figure 14-12: Sinking down proceeds until the value is greater than its children
    or reaches a leaf.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-12：向下筛选一直进行，直到该值大于其子节点或达到叶节点为止。
- en: In this situation, 22 is now greater than its children, so the sinking-down
    procedure ends. If the value 40 had been a 20, the 22 would have been exchanged
    with the 24, and the shifting-down procedure would have finished as well, since
    22 would have no children.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，22 现在大于它的子节点，因此向下筛选过程结束。如果值 40 变成了 20，22 将与 24 交换，并且向下筛选过程也会结束，因为 22
    将没有子节点。
- en: 'Take a look at the following code, which uses a recursive _sinkDown() auxiliary
    function to push a value down the heap:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下代码，它使用递归的 `_sinkDown()` 辅助函数将一个值推向堆的下方：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calculate l and r, the children of the parent at i; you can use the formula
    discussed earlier in “The Structure Property” section on page 318 ❶ and find r
    just by adding 1 ❷, since r follows l in the array. Use g to determine the greatest
    value at positions i, l, and r ❸. If the value at i isn’t greater than its children,
    swap it ❹ and keep sinking it down recursively ❺.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 l 和 r，分别为父节点 i 的左子节点和右子节点；你可以使用之前在“结构属性”章节第 318 页❶讨论的公式，通过添加 1 ❷来找到 r，因为在数组中
    r 紧跟 l。使用 g 来确定位置 i、l 和 r 中的最大值 ❸。如果 i 位置的值不大于其子节点，交换它 ❹，并递归地继续向下筛选 ❺。
- en: 'At this point, you can finally write the remove() function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你终于可以编写 `remove()` 函数了：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code closely follows the description in the previous example. When you
    get the top (which may be undefined, if the heap is empty) ❶, and if the heap
    isn’t empty ❷, place its last value at the top ❸, reduce the heap’s length by
    one ❹, and sink the new top down ❺. Finally, return the top value and the updated
    heap ❻.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码紧跟着前面示例中的描述。当你获取堆顶（如果堆为空，则可能是未定义的）❶，如果堆不为空❷，将最后一个值放到堆顶❸，将堆的长度减去一❹，并将新的堆顶向下筛选❺。最后，返回堆顶值和更新后的堆❻。
- en: Considering Performance for Heaps
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑堆的性能
- en: '[Table 14-2](chapter14.xhtml#tab14-2) shows the performance of the algorithms
    just explored.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14-2](chapter14.xhtml#tab14-2)展示了刚刚探讨过的算法的性能。'
- en: 'Table 14-2: Performance of Operations for Heaps'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-2：堆操作的性能
- en: '| Operation | Performance |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | O(1) |'
- en: '| Top | O(1) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | O(1) |'
- en: '| Add | O(log n) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) |'
- en: '| Remove | O(log n) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n) |'
- en: 'Three operations work in constant time: creating a heap, testing whether it’s
    empty, and getting the top value. The other two operations, adding and removing,
    are more complex. Adding an element may make it bubble up from the bottom of the
    heap all the way up to the top. Since you know that the heap’s height is log *n*,
    this operation requires logarithmic time. Similarly, removing an element implies
    placing a new one at the top and possibly sinking it down to the bottom. It’s
    the same number of operations as in adding a value, but in reverse (also logarithmic
    time).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 三个操作是常数时间的：创建堆、测试是否为空和获取顶部值。其他两个操作，添加和删除，则更为复杂。添加元素可能会使其从堆底部向上冒泡，直到顶部。由于堆的高度是log
    *n*，因此此操作需要对数时间。类似地，删除元素意味着将新元素放到顶部，并可能将其下沉到底部。这个过程的操作数量与添加元素时相同，只是顺序相反（同样是对数时间）。
- en: 'Let’s move on to consider a new ADT, and compare the performance of heaps versus
    the other structures already discussed.  ### Priority Queues and Heaps'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们继续考虑一个新的ADT，并比较堆与之前讨论过的其他数据结构的性能。 ### 优先队列与堆'
- en: '*Priority queues (PQs)* are different from the queues discussed in [Chapter
    10](chapter10.xhtml), because each element has an associated priority, which determines
    what element is removed first. In a PQ, the first element to be removed is the
    one with the highest priority, not the first one that was added, as in a first
    in, first out (FIFO) strategy.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先队列（PQs）* 与[第10章](chapter10.xhtml)中讨论的队列不同，因为每个元素都有一个关联的优先级，决定了哪个元素会被首先移除。在优先队列中，第一个被移除的元素是具有最高优先级的元素，而不是最早添加的元素（这与先进先出FIFO策略不同）。'
- en: NOTE
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*There’s a problem with the English language! The term* priority one *implies
    the highest priority, but 1 is the lowest-priority number. If you order tasks
    by priority and the lowest numbered task is the one you should tackle first, then
    lower numbers have a higher priority. However, some tools (like Microsoft Project)
    assume that 0 is the lowest priority and higher numbers are higher priority, so
    there’s no clear-cut case. Regardless, if you actually need a min heap instead
    of a max heap, see question 14.4.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*英语语言存在问题！术语* priority one *意味着最高优先级，但1是最低优先级数字。如果你按优先级顺序排序任务，最低编号的任务应该最先处理，那么较低的数字具有较高的优先级。然而，一些工具（例如Microsoft
    Project）假定0是最低优先级，较高的数字具有较高优先级，因此没有明确的规定。不管怎样，如果你需要最小堆而非最大堆，参见问题14.4。*'
- en: PQs are used in multiple algorithms and many different situations. Operating
    system schedulers use priorities to select what process will be the next to run.
    Discrete event simulations decide the next step to apply based on a timestamp
    (and in this case, lower timestamps equal higher priorities). Dijkstra’s shortest
    path algorithm (which we’ll consider in [Chapter 17](chapter17.xhtml)) requires
    finding the vertex with the minimum distance to another given vertex. Prim’s algorithm
    for finding a minimum spanning tree for a graph also needs to find the vertex
    with the smallest (cheapest) connection to another vertex. Huffman’s coding algorithm
    builds a tree and repeatedly needs to find the two nodes with the smallest probabilities
    to replace them with a new node with the sum of those probabilities. All of these
    things require PQs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列（PQs）在多个算法和不同的场景中都有应用。操作系统调度器通过优先级来选择下一个执行的进程。离散事件模拟根据时间戳决定下一步的操作（在这种情况下，较小的时间戳表示较高的优先级）。Dijkstra最短路径算法（我们将在[第17章](chapter17.xhtml)中讨论）需要找到与另一个给定顶点的最短距离的顶点。Prim算法用于查找图的最小生成树，也需要找到与另一个顶点连接最小（最便宜）的顶点。霍夫曼编码算法构建树并反复需要找到两个概率最小的节点，用它们的概率之和替换为一个新节点。所有这些操作都需要优先队列（PQs）。
- en: In terms of an ADT, the description for a PQ then requires the following operations
    shown in [Table 14-3](chapter14.xhtml#tab14-3) (other versions that add more operations
    are considered later).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象数据类型（ADT）角度来看，优先队列的描述需要以下操作，参见[表14-3](chapter14.xhtml#tab14-3)（其他增加更多操作的版本将在后面讨论）。
- en: 'Table 14-3: Operations on Priority Queues'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-3：优先队列的操作
- en: '| Operation | Signature | Description |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → PQ | Create a new PQ. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → 优先队列 | 创建一个新的优先队列。 |'
- en: '| Empty? | PQ → boolean | Determine whether the PQ is empty. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | PQ → boolean | 判断一个优先队列（PQ）是否为空。 |'
- en: '| Top | PQ → key | Given a PQ, produce its top value. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 顶部 | PQ → key | 给定一个优先队列（PQ），返回其顶部元素。 |'
- en: '| Add | PQ × key → PQ | Given a new key, add it to a PQ. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | PQ × key → PQ | 给定一个新键，将其添加到一个优先队列（PQ）中。 |'
- en: '| Remove | PQ → PQ × key | Given a PQ, extract its top value and update the
    PQ correspondingly. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | PQ → PQ × key | 给定一个优先队列（PQ），提取其顶部元素并相应地更新优先队列。 |'
- en: 'In terms of the provided operations, a heap matches the requirements of a PQ,
    so implementation is straightforward. For the sake of variety, though, take a
    look at other simple ways of implementing PQs and compare their performances:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就提供的操作而言，堆符合优先队列（PQ）的要求，因此实现起来很简单。然而，为了多样性，看看其他一些简单的优先队列实现方式，并比较它们的性能：
- en: With an unordered array or list, getting the top value would be *O*(*n*). Removing
    it would also be *O*(*n*), because you have to go through all the values to find
    it, and adding a new element would be *O*(1).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无序数组或列表时，获取顶部元素的时间复杂度是 *O*(*n*)。移除它的时间复杂度也是 *O*(*n*)，因为你需要遍历所有元素来找到它，添加新元素的时间复杂度则是
    *O*(1)。
- en: With an ordered array (the top value at the last position), getting and removing
    the top would be *O*(1), but adding a new element would be *O*(*n*); after finding
    where the element goes, which is *O*(log *n*) with binary search, you have to
    move the elements physically to make space, and that’s *O*(*n*).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有序数组（最大值位于最后一个位置）时，获取和移除顶部元素的时间复杂度是 *O*(1)，但添加新元素的时间复杂度是 *O*(*n*)；在找到元素的位置后，使用二分查找的时间复杂度是
    *O*(log *n*)，你还需要物理移动元素以腾出空间，这就是 *O*(*n*)。
- en: With an ordered list (the top value in the first place), the results are the
    same as with an ordered array.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有序列表（最大值位于第一个位置）时，结果与使用有序数组时相同。
- en: With a balanced binary search tree, all three operations would be *O*(log *n*).
    If you have an extra pointer to the maximum value, getting the top value becomes
    *O*(1), but insertions and deletions will be a tad slower because they have to
    maintain the added pointer.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平衡的二叉搜索树时，三种操作的时间复杂度都是 *O*(log *n*)。如果你有一个指向最大值的额外指针，获取顶部元素的时间复杂度变为 *O*(1)，但插入和删除操作会稍微变慢，因为它们需要维护该额外指针。
- en: This list of possible implementations for PQs isn’t complete, but it should
    be enough to show how the heap is one of the best ways of implementing them, with
    extra points for low complexity. In the following chapter, we’ll consider some
    extra operations you may need, which will lead to other implementations of PQs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个优先队列实现方式的列表并不完整，但足以展示堆是实现优先队列的最佳方式之一，且由于其低复杂度，获得额外的优点。在接下来的章节中，我们将考虑一些额外的操作，这些操作可能需要其他优先队列的实现方式。
- en: Heapsort
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆排序
- en: 'Heaps can be used to create a well-performing sorting method. Given a set of
    values, with a heap, you can easily find the highest value of the set. After removing
    it and restoring the heap, you can find the second-highest value of the set, and
    so on. The basic algorithm structure is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 堆可以用来创建一个表现良好的排序方法。给定一组值，使用堆可以轻松找到集合中的最大值。移除最大值并恢复堆后，你可以找到第二大值，依此类推。基本的算法结构如下：
- en: 1. Build a heap out of the values to be sorted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将待排序的值构建成一个堆。
- en: 2. Then, until no more values are left, swap the heap’s top element with its
    last, reduce the heap size by one, and restore the heap condition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，直到没有更多元素，交换堆的顶部元素和最后一个元素，堆的大小减一，并恢复堆的性质。
- en: Take a look at how this algorithm works and then consider an enhancement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个算法是如何工作的，然后考虑一些优化。
- en: Williams’ Original Heapsort
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 威廉姆斯的原始堆排序
- en: 'First, here is an example implementation of the heapsort algorithm, invented
    by John W. J. Williams in 1964\. You can reuse the _bubbleUp() and _sinkDown()
    functions from earlier without any change (so I won’t list them here), and what’s
    added is just the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是1964年由约翰·W·J·威廉姆斯发明的堆排序算法的示例实现。你可以重用之前的 _bubbleUp() 和 _sinkDown() 函数（因此我不会在这里列出它们），新增的部分仅包括以下内容：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first stage of heapsort goes from the beginning to the end of the array,
    making each element bubble up to its correct place ❶. The second stage ❷ swaps
    the top element with the last one of the (current) heap ❸ and sinks it down, using
    the second argument to _sinkDown() to limit how far it can sink ❹.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序的第一阶段从数组的开始到结束，将每个元素“冒泡”到正确的位置 ❶。第二阶段 ❷ 将堆的顶部元素与（当前）堆的最后一个元素交换 ❸，并使用 _sinkDown()
    的第二个参数限制它可以下沉的深度 ❹。
- en: Here is the algorithm in action. The building phase goes through the stages
    shown in [Figure 14-13](chapter14.xhtml#fig14-13). The highlighted area corresponds
    to the heap that’s being built, and the rest are the values that haven’t yet been
    added to the heap.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是算法的执行过程。构建阶段按照[图14-13](chapter14.xhtml#fig14-13)所示的步骤进行。高亮区域对应正在构建的堆，其他部分是尚未添加到堆中的值。
- en: '![](../images/Figure14-13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-13.jpg)'
- en: 'Figure 14-13: The first phase of heapsort is to build up the heap (highlighted
    area) one value at a time.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-13：堆排序的第一阶段是逐个构建堆（高亮区域）。
- en: In every step of the algorithm, a new value is added to the heap as it is so
    far, bubbling up as needed, until you get a heap with one more element than before.
    After the building phase is done, the second part of the algorithm starts. The
    top element of the heap is swapped with the last value of the heap, which shrinks
    down in size by one, and the new value at the top sinks down to restore the heap,
    as shown in [Figure 14-14](chapter14.xhtml#fig14-14).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的每一步中，一个新的值被添加到堆中，并根据需要上浮，直到堆中元素的数量增加了一。构建阶段完成后，算法的第二部分开始。堆顶元素与堆的最后一个值交换，堆的大小减一，新的堆顶元素下沉以恢复堆的性质，详见[图14-14](chapter14.xhtml#fig14-14)。
- en: '![](../images/Figure14-14.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-14.jpg)'
- en: 'Figure 14-14: In the second phase of heapsort, the top value is repeatedly
    removed to build up the sorted array.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-14：堆排序的第二阶段是不断移除堆顶元素，以构建有序数组。
- en: In the first step, the top value (60) is exchanged with the last value of the
    heap (11). The 11 sinks down, and 56 moves up to the top. In the next step, 56
    is exchanged with the last value (again 11), and 11 sinks down as 40 goes to the
    top. This continues step by step, and when the heap is at size 1, the array is
    sorted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，堆顶值（60）与堆的最后一个值（11）交换。11下沉，56上浮到堆顶。在接下来的步骤中，56与最后一个值（再次是11）交换，11下沉，40上浮到堆顶。这个过程一步步进行，当堆的大小为1时，数组就已排序。
- en: Heapsort Analysis
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆排序分析
- en: What’s the order of heapsort? Without going too deep into mathematical details,
    if you are sorting *n* items, you call the _bubbleUp() function *n* times, and
    each time, an element may bubble up to the top of the heap, which is log *n* high,
    so that’s *O*(*n* log *n*). Similarly, when removing elements from the heap to
    produce the ordered array, call _sinkDown() *n* times, and elements may sink down
    to the bottom of the heap, so that’s *O*(*n* log *n*) again; the conclusion is
    that the algorithm is *O*(*n* log *n*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序的时间复杂度是多少？不深入数学细节，如果你要排序*n*个元素，你需要调用_bubbleUp()函数*n*次，每次一个元素可能会浮到堆顶，而堆的高度是log
    *n*，因此时间复杂度为*O*(*n* log *n*)。类似地，在从堆中移除元素以产生有序数组时，需要调用_sinkDown() *n*次，元素可能会下沉到底部，因此也是*O*(*n*
    log *n*)；最终得出的结论是该算法的时间复杂度是*O*(*n* log *n*)。
- en: An interesting property is that this behavior is guaranteed. No set of data
    will lead to a worse case, as in quicksort, which could become *O*(*n*^²). Also,
    since we’ve established that *O*(*n* log *n*) is the best possible order for comparison-based
    sorting algorithms, you can see that heapsort is a solid algorithm with consistent
    performance, often used in libraries and in other algorithms that may require
    sorting.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的特性是，这种行为是有保障的。没有任何数据集会导致像快速排序那样的最坏情况（快速排序可能会变成*O*(*n*^²)）。此外，由于我们已经确定*O*(*n*
    log *n*)是基于比较的排序算法中最优的时间复杂度，因此可以看出，堆排序是一种稳定的算法，具有一致的性能，通常用于库函数和其他可能需要排序的算法中。
- en: Finally, heapsort isn’t a stable sort in the sense shown in [Chapter 6](chapter6.xhtml)
    (see question 14.12 for an example).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，堆排序并不是[第六章](chapter6.xhtml)中所示意义上的稳定排序（具体例子见问题14.12）。
- en: Floyd’s Heap-Building Enhancement
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Floyd的堆构建优化
- en: Williams’ version of the algorithm is quite efficient, but a possible enhancement,
    thanks to Robert Floyd, speeds up the heap-building part to O(*n*), although we
    won’t go into the math here. The reason for this result is that most of the elements
    are near the bottom, so sinking them down is much faster than bubbling them up.
    Very few are near the top, where sinking them is slower than bubbling up, all
    of which is enough to change the order of heap building. Since the second part
    of the procedure is still *O*(*n* log *n*), the algorithm’s total order won’t
    change, but it will run faster in any case.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Williams版的算法非常高效，但借助Robert Floyd的改进，堆构建部分的时间复杂度被优化为O(*n*)，尽管我们这里不会深入探讨数学原理。这个结果的原因在于大多数元素都在底部，因此将它们下沉比将它们上浮要快得多。很少有元素接近顶部，那里的下沉速度比上浮慢，这些因素足以改变堆构建的顺序。由于过程的第二部分仍然是*O*(*n*
    log *n*），算法的总时间复杂度不会改变，但无论如何，它会运行得更快。
- en: Instead of making each element bubble up to its position, the algorithm builds
    small heaps, which are then made larger by joining them together, until you get
    the complete heap. Initially, you can consider all the leaves of the tree to be
    small one-sized heaps. Then, take two leaves and their parent and reorganize them
    (if needed) so that those three values form a heap. Keep doing this, and eventually,
    you’ll get to the top of the heap and be done.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法不是让每个元素上浮到它的位置，而是构建小的堆，然后通过将它们合并成更大的堆，直到最终得到完整的堆。最初，你可以将树的所有叶子视为大小为1的小堆。然后，取两颗叶子和它们的父节点，并重新组织它们（如果需要的话），使这三个值形成一个堆。不断重复这一过程，最终你会到达堆的顶部并完成堆的构建。
- en: 'Take a look at the code first and then at an example. The code for this new
    heapsort version will depend on the previous _sinkDown() code, which you’ll use
    unchanged. The rest of the algorithm is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看代码，然后再看一个示例。这种新的堆排序版本的代码将依赖于之前的_sinkDown()_代码，后者将保持不变。其余部分的算法如下：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code for the second part of the algorithm (exchanging and restructuring)
    is the same; the only difference is where you build up the heap using _sinkDown().
    [Figure 14-15](chapter14.xhtml#fig14-15) shows just the heap-building part of
    this code in action—specifically, how more parts of the array successively become
    a heap. At each step, the part of the array that becomes a “mini heap” is highlighted.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 算法第二部分（交换和重构）的代码是相同的；唯一的区别在于你是通过_sinkDown()_来构建堆的。[图14-15](chapter14.xhtml#fig14-15)展示了这段代码的堆构建部分，具体来说，就是数组的更多部分如何逐步成为堆。在每一步中，成为“迷你堆”的数组部分都会被突出显示。
- en: '![](../images/Figure14-15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-15.jpg)'
- en: 'Figure 14-15: The enhanced heap-building algorithm creates the heap out of
    smaller, previously created ones.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-15：增强版的堆构建算法通过较小的堆逐步构建出完整的堆。
- en: To better understand [Figure 14-15](chapter14.xhtml#fig14-15), look at the heap
    at different stages. Initially, the array looks like [Figure 14-16](chapter14.xhtml#fig14-16)
    and obviously isn’t a heap.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解[图14-15](chapter14.xhtml#fig14-15)，请查看不同阶段的堆。最初，数组看起来像[图14-16](chapter14.xhtml#fig14-16)，显然还不是堆。
- en: '![](../images/Figure14-16.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-16.jpg)'
- en: 'Figure 14-16: An initial array, which doesn’t fulfill the heap property'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-16：一个初始数组，未满足堆的性质
- en: After two steps, subheaps out of 11 and 24 are built (which were left as they
    were) as well as 12, 34, and 56 (where 34 sifted down and 56 took its place).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 经过两步，构建了来自11和24的子堆（这两个保持不变），以及12、34和56（其中34下沉，56替代了它的位置）。
- en: '[Figure 14-17](chapter14.xhtml#fig14-17) shows two more steps.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-17](chapter14.xhtml#fig14-17)展示了另外两步。'
- en: '![](../images/Figure14-17.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-17.jpg)'
- en: 'Figure 14-17: After some rotations, a few subheaps are built.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-17：经过几次旋转，构建了几个子堆。
- en: The heap is practically done with root 56 (the 22 value sank down and 56 took
    its place) and another with root 60 (where no changes were needed). You are just
    one step away from finishing, as shown in [Figure 14-18](chapter14.xhtml#fig14-18).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 堆几乎完成，根节点为56（22的值下沉，56取代了它的位置），另一个根为60（无需任何变化）。你只差一步就可以完成，如[图14-18](chapter14.xhtml#fig14-18)所示。
- en: '![](../images/Figure14-18.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-18.jpg)'
- en: 'Figure 14-18: More and more subheaps are built, reaching to the top.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-18：越来越多的子堆被构建出来，逐渐达到顶部。
- en: The last step completes the heap; the 9 value sinks down to its place, being
    replaced by 60\. [Figure 14-19](chapter14.xhtml#fig14-19) shows the finished heap.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步完成堆的构建；9的值下沉到它的位置，被60替代。[图14-19](chapter14.xhtml#fig14-19)展示了完成后的堆。
- en: '![](../images/Figure14-19.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-19.jpg)'
- en: 'Figure 14-19: Upon reaching the top, the array has become a heap.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-19：到达顶部时，数组已变成堆。
- en: 'Floyd’s enhanced algorithm has two advantages: a faster first phase (the second
    phase, which generates the sorted result, is the same) and shorter code. You can
    take advantage of this method for your heap logic and modify the newHeap() function
    (see question 14.8).  ### Treaps'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'Floyd的增强算法有两个优点：第一阶段更快（第二阶段生成排序结果相同），并且代码更简短。你可以利用这种方法改进堆逻辑并修改newHeap()函数（见问题14.8）。
    ### Treaps'
- en: 'In [Chapter 12](chapter12.xhtml), we discussed binary search trees and several
    ways to try to keep them balanced in order to avoid slow searches. In 1989, a
    new structure was invented that mixes the characteristics of trees and heaps:
    treaps. These trees are balanced, although their heights are not guaranteed to
    be *O*(log *n*); rather, randomization and the heap property are used to maintain
    balance with high probability.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](chapter12.xhtml)，我们讨论了二叉搜索树及几种保持其平衡以避免搜索缓慢的方法。在1989年，发明了一种新结构，混合了树和堆的特性：treaps。这些树是平衡的，尽管它们的高度不一定是*O*(log
    *n*)；相反，随机化和堆属性被用来以较高的概率保持平衡。
- en: The (invented) term *treap* is a portmanteau of the words *tree* and *heap*.
    How does this mix come about? Basically, every key is associated with a random
    priority, and when you build the binary search tree, take care to satisfy the
    heap property, so a parent node always will have a priority greater than those
    of its children. (The structure property will not be satisfied; nodes are linked
    by pointers, not an array.) Note that instead of using a random number generator,
    you can apply a hash function to the key, and thus produce its “random” priority.
    Mathematical analysis of treaps depends on truly random numbers, but the form
    of randomness generated by hashing also works. And in terms of testing algorithms,
    hashing has the advantage of determinacy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*Treap*（发明的术语）是*tree*和*heap*两个词的混合词。这种混合是怎么来的呢？基本上，每个键都关联一个随机优先级，当你构建二叉搜索树时，需要确保满足堆属性，因此父节点的优先级总是大于其子节点的优先级。（这种结构属性不一定满足；节点是通过指针链接的，而不是数组。）注意，除了使用随机数生成器外，你还可以对键应用哈希函数，从而生成其“随机”优先级。对treaps的数学分析依赖于真正的随机数，但哈希生成的随机性也有效。在测试算法方面，哈希具有确定性的优势。'
- en: Let’s think about this a bit more. If you happened to order the keys by priority
    and insert them in the tree in decreasing order of priority, the resulting tree
    would satisfy the heap property. (Can you see why?) This means that assigning
    random priorities is equivalent to taking a random permutation of the keys before
    inserting them in the tree, which will probabilistically provide a good shape
    for the resulting tree, with an expected height that is *O*(log *n*), as with
    balanced trees.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再深入思考一下。如果你恰好按照优先级排序键并按优先级递减的顺序插入树中，生成的树将满足堆属性。（你能看出为什么吗？）这意味着分配随机优先级等同于在插入树之前对键进行随机排列，这将以概率的方式为生成的树提供良好的形状，期望高度为*O*(log
    *n*)，与平衡树相同。
- en: Given a set of distinct keys and their corresponding (also distinct) priorities,
    the resulting treap is unique, and we can construct a recursive proof for this.
    First, the root of the treap must be the key with the highest priority. Then,
    all the smaller keys will go into the root’s left subtree and the greater keys
    will go into the right subtree, and we can apply the same reasoning recursively
    to prove that those two subtrees will also be unique.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组不同的键及其对应的（也是不同的）优先级，生成的treap是唯一的，我们可以为此构造递归证明。首先，treap的根节点必须是优先级最高的键。然后，所有较小的键将进入根节点的左子树，较大的键将进入右子树，我们可以递归地应用相同的推理来证明这两个子树也是唯一的。
- en: You can also modify the binary search tree algorithms from [Chapter 12](chapter12.xhtml)
    to create treaps. The code is simpler than code for AVL or red-black trees, yet
    it provides competitive performance, often better than that of its more complex
    alternatives.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以修改[第12章](chapter12.xhtml)中的二叉搜索树算法来创建treaps。与AVL树或红黑树的代码相比，这种代码更简洁，但却能提供竞争力的性能，通常优于那些更复杂的替代方案。
- en: Creating and Searching a Treap
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建与搜索Treap
- en: 'Given that treaps are just binary search trees at heart, most of the code discussed
    in [Chapter 12](chapter12.xhtml) will still work. Start coding treaps as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 既然treaps本质上只是二叉搜索树，那么在[第12章](chapter12.xhtml)中讨论的大多数代码仍然适用。开始编写treaps的代码如下：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The treap is based on the previous binary search tree ❶, and many of the functions
    written there are still valid. When creating a new node, add a random priority
    ❷, but that’s all that will change here.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Treap 基于之前的二叉搜索树 ❶，并且许多在那里的函数依然有效。在创建新节点时，添加一个随机的优先级 ❷，但这里的变化就只有这些。
- en: NOTE
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you want to test your code and need deterministic results, you could compute
    priority as a hash of the key; as long as the results are random enough, it will
    do.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想测试你的代码并且需要确定性的结果，可以将优先级计算为键的哈希值；只要结果足够随机，这样做就行。*'
- en: Let’s move on to adding a new key, which requires some extra coding.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要进行的是添加一个新键，这需要一些额外的编码。
- en: Adding a Key to a Treap
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向 Treap 中添加键
- en: Insertion into a treap requires basically the same logic as for binary search
    trees, except that after having added the node in its place, you may need to do
    some rotations to maintain the heap property. Adding new keys to a treap is possible
    using the _rotate() method introduced in previous chapters. The basic idea is
    first to place the new node in the tree according to its value and then rotate
    it, if needed, in a way that the binary search tree condition is kept but that
    also satisfies the heap condition. [Figure 14-20](chapter14.xhtml#fig14-20) shows
    the basic rotations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 向 treap 中插入节点基本上与二叉搜索树插入的逻辑相同，唯一的区别是在将节点插入到适当位置后，可能需要进行旋转以保持堆的性质。向 treap 中添加新键可以通过前面章节介绍的
    _rotate() 方法来完成。基本思路是首先根据值将新节点插入到树中，然后根据需要进行旋转，既保持二叉搜索树条件，又满足堆条件。[图 14-20](chapter14.xhtml#fig14-20)
    展示了基本的旋转操作。
- en: '![](../images/Figure14-20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-20.jpg)'
- en: 'Figure 14-20: Rotations also make the binary search tree become a heap.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-20：旋转操作也使得二叉搜索树变成了堆。
- en: The minus sign represents a smaller key value than the plus sign. If the node
    placed lower (the minus) has a higher priority than its parent (the plus), which
    is shown in the left side of the figure, you can apply a *right rotation* and
    produce the situation on the right, which would satisfy the heap property. Conversely,
    if you have the situation on the right and the lower node (plus) has a higher
    priority than its parent (minus), you can apply a *left rotation* to get the situation
    on the left. In both cases, the resulting tree is still a binary search tree,
    but the nodes are shifted around so that the final parent node has a greater priority
    than its children.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 减号表示比加号对应的键值更小。如果放置在下方的节点（减号）比其父节点（加号）优先级更高，如图左侧所示，可以执行 *右旋转* 操作，从而得到图右侧的情况，这样就满足了堆的性质。相反，如果有右侧的情况，且下方节点（加号）的优先级高于其父节点（减号），则可以执行
    *左旋转* 来获得左侧的情况。在这两种情况下，最终得到的树依然是二叉搜索树，但节点的位置发生了变化，使得最终的父节点优先级大于其子节点。
- en: Here is an example of how the add() algorithm should work. Start with the treap
    shown in [Figure 14-21](chapter14.xhtml#fig14-21), where priorities are shown
    to the right of nodes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 add() 算法如何工作的示例。我们从 [图 14-21](chapter14.xhtml#fig14-21) 中显示的 treap 开始，节点的右侧显示了优先级。
- en: '![](../images/Figure14-21.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-21.jpg)'
- en: 'Figure 14-21: In a treap, keys form a binary search tree and priorities form
    a heap.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-21：在 treap 中，键值形成二叉搜索树，优先级形成堆。
- en: If you want to add a 12 node with a (random) priority of 0.8, the first step
    is to insert the new node, without worrying about priorities and the heap property,
    which will be sorted out later. This insertion (done in the standard way for binary
    search trees, as described in [Chapter 12](chapter12.xhtml)) leads to the tree
    shown in [Figure 14-22](chapter14.xhtml#fig14-22).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想插入一个优先级为 0.8 的 12 节点，第一步是按照二叉搜索树的标准方法插入新节点，而不考虑优先级和堆的性质，这些会稍后处理。这个插入（按照
    [第 12 章](chapter12.xhtml) 中描述的标准方法进行）会导致如 [图 14-22](chapter14.xhtml#fig14-22)
    所示的树。
- en: '![](../images/Figure14-22.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-22.jpg)'
- en: 'Figure 14-22: After standard insertion, the resulting binary search tree may
    no longer be a heap.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-22：在标准插入操作后，得到的二叉搜索树可能不再是堆。
- en: The treap works for searches, but the heap property isn’t satisfied, because
    the priority for the 12 node is higher than the priority of its parent. You can
    fix that problem by doing a left rotation, leading to the tree shown in [Figure
    14-23](chapter14.xhtml#fig14-23).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Treap 支持搜索操作，但由于 12 节点的优先级高于其父节点的优先级，因此堆的性质没有得到满足。你可以通过执行左旋转来解决这个问题，从而得到 [图
    14-23](chapter14.xhtml#fig14-23) 所示的树。
- en: '![](../images/Figure14-23.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-23.jpg)'
- en: 'Figure 14-23: Rotations are applied until the heap property is satisfied, but
    this tree is still wrong.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-23：旋转操作会一直应用，直到满足堆的性质，但这个树仍然是错误的。
- en: The rotation still leaves a valid binary search tree, but the process hasn’t
    ended, because the heap property isn’t yet fully satisfied. The 12 node has a
    higher priority than its parent; perform a right rotation to solve this, which
    leads to the tree shown in [Figure 14-24](chapter14.xhtml#fig14-24).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转仍然保持有效的二叉搜索树，但过程尚未结束，因为堆的性质还没有完全满足。12 节点的优先级高于其父节点；进行一次右旋操作以解决这个问题，这样就得到了图中所示的树[图
    14-24](chapter14.xhtml#fig14-24)。
- en: '![](../images/Figure14-24.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-24.jpg)'
- en: 'Figure 14-24: Now the heap property is satisfied.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-24：现在堆的性质已经满足。
- en: After this second rotation, you can check that the heap property is satisfied,
    thus the addition to the treap was done correctly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次旋转后，你可以检查堆的性质是否已经满足，因此添加到 Treap 中的操作是正确的。
- en: 'The final code follows, and there’s a single line that’s different from common
    binary search trees:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最终的代码，其中有一行与普通的二叉搜索树不同：
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The line in bold makes sure that the heap property is satisfied. After adding
    the new key on tree[side], if the priority of that subtree is not greater than
    the priority of the root, you’re done; otherwise, apply a rotation on that side
    to bring up the greater priority.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体的那一行确保堆的性质得以满足。在树的[侧边]添加新键后，如果该子树的优先级不大于根节点的优先级，你就完成了；否则，应用该侧的旋转将优先级更高的元素提到上面。
- en: The last method needed is to remove a key from a treap.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要的方法是从 Treap 中删除一个键。
- en: Removing a Key from a Treap
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 Treap 中删除一个键
- en: 'The algorithm for removing a key from a binary search tree involves finding
    it first, possibly finding its successor, and putting it in the removed node’s
    place. With treaps, given that you must maintain the heap property, it’s a tad
    more complex, but just as with insertions, you can use rotations to make things
    come out right. To remove a node, use a different logic from earlier with binary
    search trees:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从二叉搜索树中删除一个键的算法包括先找到该键，可能需要找到它的后继节点，并将后继节点放到被删除节点的位置。对于 Treap，由于你必须保持堆的性质，这个过程稍微复杂一些，但就像插入操作一样，你可以使用旋转来确保结果是正确的。要删除一个节点，使用与之前二叉搜索树不同的逻辑：
- en: If you search for a key to remove in an empty tree, there’s nothing to be done.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在空树中查找要删除的键，什么都不需要做。
- en: If the key to remove is lower than the key at the root, delete the key from
    the tree at the root’s left child.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要删除的键小于根节点的键，从根节点的左子节点中删除该键。
- en: Otherwise, if the key to remove is greater than the key at the root, delete
    the key from the tree at the root’s right child.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果要删除的键大于根节点的键，从根节点的右子节点中删除该键。
- en: Otherwise, if the key has neither a left child nor a right child, just delete
    it.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果该键既没有左子节点也没有右子节点，直接删除它。
- en: Otherwise, if it has a right child but no left child, set it to the right child.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果它有右子节点但没有左子节点，将其设置为右子节点。
- en: Otherwise, if it has a left child but no right child, set it to the left child.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果它有左子节点但没有右子节点，将其设置为左子节点。
- en: Finally, if it has both left and right children, apply a rotation to move the
    key lower in the tree and attempt to delete it again.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果它有左子节点和右子节点，应用一次旋转将该键移到树的更低位置，并尝试再次删除它。
- en: The last step is the one that may be surprising, and it’s certainly different
    from binary search trees. With the rotations shown earlier when inserting in a
    treap, it’s possible to rotate a node with one of its children, and the rotated
    node will be lower in the treap. If you carefully choose what rotation to use,
    you can keep satisfying the heap property; so if you had a valid treap before
    the rotation, you’ll still have a valid one after it. And finally, as the key
    to delete moves lower and lower, it can’t always keep having two children. At
    some point, it will have one or none, and then you can finish the job quickly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步可能会让人感到惊讶，它与二叉搜索树的处理方式完全不同。通过前面在插入 Treap 时展示的旋转操作，可以旋转一个节点与它的某个子节点，而旋转后的节点会在
    Treap 中较低的位置。如果你仔细选择使用哪种旋转方式，你仍然可以保持堆的性质；因此，如果在旋转之前 Treap 是有效的，旋转后它仍然会保持有效。最后，随着要删除的键逐渐下移，它不能总是保有两个子节点。在某个时刻，它只会有一个或没有子节点，然后你可以快速完成删除操作。
- en: Consider a more complex case. Start with the treap shown in [Figure 14-25](chapter14.xhtml#fig14-25)
    and remove the 9 node (as in the section “Adding a Key to a Treap” on page 333,
    the priorities are shown to the right of the nodes).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个更复杂的情况。从[图 14-25](chapter14.xhtml#fig14-25)所示的treap开始，删除9节点（如在“向treap中添加键”一节第333页所示，优先级显示在节点的右侧）。
- en: '![](../images/Figure14-25.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-25.jpg)'
- en: 'Figure 14-25: An initial treap, with a node to be removed'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-25：初始的treap，包含一个待删除节点
- en: After finding the node, it happens that it has two children, so you need to
    do a rotation. The right child of 9 has greater priority, so apply a left rotation,
    leaving the intermediate situation shown in [Figure 14-26](chapter14.xhtml#fig14-26)
    (notice that the heap property is not satisfied, but it will be after you remove
    the 9 node).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 找到节点后，恰好它有两个子节点，所以需要进行旋转。9的右子节点优先级更高，因此执行左旋，得到如[图 14-26](chapter14.xhtml#fig14-26)所示的中间状态（注意，此时堆性质尚未满足，但在你删除9节点后就会满足）。
- en: '![](../images/Figure14-26.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-26.jpg)'
- en: 'Figure 14-26: A left rotation brings down the node to be removed.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-26：左旋将要删除的节点向下移动。
- en: The 9 node again has two children, so do a new rotation. This time, the child
    with the greater priority is the left one, so you can do a right rotation, resulting
    in a new situation ([Figure 14-27](chapter14.xhtml#fig14-27)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 9节点再次有两个子节点，因此进行新的旋转。这次，优先级更高的是左子节点，因此可以进行右旋，得到新的状态（见[图 14-27](chapter14.xhtml#fig14-27)）。
- en: '![](../images/Figure14-27.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-27.jpg)'
- en: 'Figure 14-27: A new rotation moves the node to be deleted further down the
    treap.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-27：新的旋转将要删除的节点进一步移至treap下方。
- en: Now you’ve reached a simple case, since the 9 node has only one child, which
    allows you to remove it, resulting in the final treap ([Figure 14-28](chapter14.xhtml#fig14-28)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经遇到了一个简单的情况，因为9节点只有一个子节点，这允许你删除它，最终得到如[图 14-28](chapter14.xhtml#fig14-28)所示的treap。
- en: '![](../images/Figure14-28.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-28.jpg)'
- en: 'Figure 14-28: The final treap after removing the node you want to delete'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-28：删除目标节点后的最终treap
- en: 'The code for removing a key is as follows (notice that the implementation closely
    follows the previous bulleted list):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 删除键的代码如下（请注意，该实现严格按照前面列出的步骤进行）：
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code is the same as for common binary search trees, except that when a key
    is found that has two children ❶, you decide which rotation you need ❷, apply
    it ❸, and go down recursively to attempt deleting the key ❹. If you had done a
    left rotation, the original root (with the key you wanted to delete) would be
    displaced to the left subtree, so the removal process continues there. With a
    right rotation, the process would continue at the right subtree.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与常见的二叉搜索树相同，不同之处在于当找到一个有两个子节点的键时❶，你需要决定进行哪种旋转❷，然后执行旋转❸，接着递归地向下尝试删除该键❹。如果执行了左旋，原根节点（即你想删除的键所在节点）将被移到左子树，因此删除过程将在左子树中继续。如果执行右旋，删除过程将在右子树中继续。
- en: You’ve now used heaps to extend binary search trees. Let’s look at the results
    of this change.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经使用堆来扩展二叉搜索树。让我们看看这种变化的结果。
- en: Considering the Performance of Treaps
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑treap的性能
- en: 'As mentioned earlier, the expected height of treaps is *O*(log *n*), which
    means that adding, removing, and finding keys all have that same expected order.
    The randomization implied by the assignment of priorities does not ensure, however,
    that there won’t be bad cases, and in fact, the worst-case scenario is the same
    as with binary search trees: trees having *O*(*n*) depth and an effect on the
    algorithms’ performance.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，treap的预期高度是*O*(log *n*)，这意味着添加、删除和查找键的预期时间复杂度都是这个级别。然而，优先级的随机化并不能确保不会出现坏情况，实际上，最坏的情况与二叉搜索树相同：树的深度为*O*(*n*)，并会影响算法的性能。
- en: A main difference with common binary search trees is that in practice, getting
    a “bad” sequence of data may not be unexpected, always leading to bad trees. However,
    in a treap, because of the random priorities, the probability of building a “bad”
    treap is very low, no matter the order of the original data. In fact, to get a
    badly balanced treap, priorities would have to be correlated with the key values,
    which is very unlikely to happen with random numbers. Thus, the average performance
    of algorithms will be independent of the sequence of key insertions (see [Table
    14-4](chapter14.xhtml#tab14-4)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与常见的二叉搜索树的主要区别在于，实际上，获取一个“坏”的数据序列并不出乎意料，常常会导致糟糕的树。然而，在treap中，由于随机优先级的存在，无论原始数据的顺序如何，构建一个“坏”的treap的概率非常低。实际上，要得到一个平衡差的treap，优先级必须与键值相关联，而这种情况在随机数中非常不可能发生。因此，算法的平均性能将独立于键值插入的顺序（见[表14-4](chapter14.xhtml#tab14-4)）。
- en: 'Table 14-4: Performance of Operations for Treaps'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-4：Treap操作性能
- en: '| Operation | Average performance | Worst case |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 平均性能 | 最坏情况 |'
- en: '| --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | O(1) | O(1) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) | O(1) |'
- en: '| Add | O(log n) | O(n) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) | O(n) |'
- en: '| Remove | O(log n) | O(n) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n) | O(n) |'
- en: '| Find | O(log n) | O(n) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) | O(n) |'
- en: '| Traverse | O(n) | O(n) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 遍历 | O(n) | O(n) |'
- en: The key to treaps is that randomization makes it highly probable that some balance
    will be achieved, thus providing high performance. (This was the same argument
    for randomized binary search trees.) In addition, treaps allow you to implement
    other methods, like partitioning a treap into two or rejoining two treaps to make
    one. We won’t discuss those methods directly here, but see questions 14.15 and
    14.16 at the end of the chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Treap的关键在于，随机化使得实现一定平衡的可能性非常高，从而提供了高性能。（这与随机化二叉搜索树的论点相同。）此外，treap允许你实现其他方法，例如将一个treap分成两个或将两个treap重新合并为一个。我们在这里不会直接讨论这些方法，但请参阅本章末尾的问题14.15和14.16。
- en: Ternary and D-ary Heaps
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三叉堆和D叉堆
- en: If binary heaps are a good structure for priority queues, the logical generalization
    is that as with B-trees, having more children at each level makes for a shorter
    tree and faster algorithms, such as with *ternary* (also known as *trinary*) heaps,
    in which each node has three children, or *quaternary* heaps with four children,
    and in general *d-ary* heaps with *d* children for each node.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二叉堆是优先队列的一个良好结构，那么逻辑上的推广就是，正如B树那样，每个层级拥有更多的子节点会使树更短，算法更快，例如*三叉*（也称为*三元*）堆，其中每个节点有三个子节点，或者*四叉*堆有四个子节点，一般的*d叉*堆每个节点有*d*个子节点。
- en: 'Basically, all the differences are in the _bubbleUp() and _sinkDown() methods,
    which now have to deal with more than two children, as shown:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，所有的差异都在于_bubbleUp()和_sinkDown()方法中，这些方法现在必须处理超过两个子节点，如下所示：
- en: '[PRE10]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Take a look at the changes in the code. We added an ORDER variable (here set
    to 3) to store the order of the new heap ❶. Calculating the *parent* of a node
    requires using a corrected formula; instead of dividing by 2 as in binary heaps,
    divide by the heap order ❷. Then make the same change (substituting the heap order
    for the 2) to find the children of an element ❸ ❹. Since you may have any number
    of children for a node, loop over them to find the greatest ❺.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下代码中的变化。我们添加了一个ORDER变量（这里设置为3），用于存储新堆的阶数❶。计算节点的*父节点*需要使用修正的公式；与二叉堆不同，不是除以2，而是除以堆的阶数❷。然后，做相同的更改（将堆的阶数替换为2）来查找元素的子节点❸❹。由于一个节点可能有多个子节点，因此需要循环遍历它们，找到最大的一个❺。
- en: If you create a new heap (ternary, in this case) and add values 22, 9, 60, 34,
    24, 40, 11, 12, 56, 4, and 58, in that order, you’ll get the heap in [Figure 14-29](chapter14.xhtml#fig14-29)
    (shown as both a tree and an array).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个新的堆（在此为三叉堆），并按顺序添加值22、9、60、34、24、40、11、12、56、4和58，你将得到图[14-29](chapter14.xhtml#fig14-29)中的堆（同时以树形和数组形式显示）。
- en: '![](../images/Figure14-29.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-29.jpg)'
- en: 'Figure 14-29: In a ternary heap, the implementation is similar to binary heaps.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-29：在三叉堆中，实现方式与二叉堆相似。
- en: What about the order of *d*-ary heaps in general? Since the height of the tree
    is always *O*(log *n*), the order for all operations is the same. However, some
    operations may have better or worse performance. For instance, bubbling up becomes
    faster (because the tree is flatter), but sinking down is slower (because you
    have to find the largest out of more values).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 *d* 叉堆的一般顺序如何呢？由于树的高度始终是 *O*(log *n*)，因此所有操作的时间复杂度是相同的。然而，一些操作的性能可能更好或更差。例如，向上冒泡变得更快（因为树更平坦），但向下沉降会变得更慢（因为你必须在更多的值中找到最大的一个）。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter introduced a new data structure, a heap in several variants: binary
    and *d*-ary, as well as min and max heaps. We saw how heaps could be used to implement
    a new ADT: priority queues. Another usage of heaps was a sorting algorithm with
    good constant performance. Finally, we applied the heap concept to create a randomized
    binary search tree: a treap. In the next chapter, we’ll continue exploring related
    concepts and consider some variants of heaps that allow for new operations.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种新的数据结构——堆，有多种变体：二叉堆和 *d* 叉堆，以及最小堆和最大堆。我们看到了堆如何用于实现一种新的抽象数据类型：优先队列。堆的另一种用法是作为一个具有良好常数性能的排序算法。最后，我们应用堆的概念创建了一个随机化的二叉搜索树：treap。在下一章中，我们将继续探索相关概念，并考虑一些堆的变体，以支持新的操作。
- en: Questions
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**14.1  Is It a Heap?**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.1  它是一个堆吗？**'
- en: Given an array, write a function that returns whether the array is a max heap.
    You don’t need to build a heap; just answer whether it already is one.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数组，写一个函数返回该数组是否为最大堆。你不需要构建堆，只需回答它是否已经是堆。
- en: '**14.2  Making Do with Queues**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.2  用队列凑合一下**'
- en: 'Suppose you could work only with priority queues but not with stacks or queues.
    How could you emulate those two ADTs with a priority queue? (Hint: since stacks
    and queues do not use a priority field, you can assign them whichever values you
    want.)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只能使用优先队列，而不能使用栈或队列。你如何使用优先队列来模拟这两种抽象数据类型（ADT）？（提示：由于栈和队列没有优先级字段，你可以为它们分配任意值。）
- en: '**14.3  Max to Min**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.3  从最大堆到最小堆**'
- en: Suppose you have a max heap; can you convert it into a min heap in linear *O*(*n*)
    time?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个最大堆；你能否在*O*(*n*) 时间内将其转换为最小堆？
- en: '**14.4  Max or Min**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.4  最大或最小**'
- en: What changes would you have to apply to your max heaps in order to get min heaps
    instead?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将最大堆转换为最小堆，你需要对最大堆做哪些修改？
- en: '**14.5  Merge Away!**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.5  合并吧！**'
- en: Suppose you are given several ordered lists and want to merge them into a single
    list. Implement this algorithm using a min heap to decide what node to choose
    at each step.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有几个有序的列表，并希望将它们合并为一个单一的列表。使用最小堆实现这个算法，在每一步决定选择哪个节点。
- en: '**14.6  Searching a Heap**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.6  搜索堆**'
- en: Even though it makes little sense (because the heap isn’t structured for it),
    how could you implement a find() function to search for a value in a heap?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这没有太大意义（因为堆本身并不是为此结构化的），你如何实现一个 `find()` 函数来在堆中查找一个值呢？
- en: '**14.7  Removing from the Middle of a Heap**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.7  从堆的中间删除元素**'
- en: In a heap, you always remove the value at the top, and if you want to remove
    the last value of a heap, it’s trivial, but can you write an algorithm that allows
    you to remove any element whatsoever from a heap?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆中，你总是移除顶部的值，如果你想移除堆的最后一个值，这很简单，但是你能写一个算法来移除堆中的任何元素吗？
- en: '**14.8  Faster Build**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.8  更快的构建**'
- en: Floyd’s enhancement builds a heap in *O*(*n*) time. Modify newHeap() so if given
    an array of values, it will use Floyd’s method to initialize the heap.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Floyd 的优化方法以 *O*(*n*) 时间构建堆。修改 `newHeap()`，使其在给定一个值数组时，使用 Floyd 的方法初始化堆。
- en: '**14.9  Another Way of Looping**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.9  另一种循环方式**'
- en: In the heapsort_original function, you could have easily used forEach() to build
    up the heap; can you see how?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `heapsort_original` 函数中，你本可以很容易地使用 `forEach()` 来构建堆；你能看到怎么做吗？
- en: '**14.10  Extra Looping?**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.10  额外的循环？**'
- en: 'In the heapsort_enhanced function, what would have happened if you had done
    a complete loop when building up the heap? More specifically, what if that code
    had been written as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `heapsort_enhanced` 函数中，如果在构建堆时执行一个完整的循环，会发生什么？更具体地说，如果那段代码写成如下形式会怎样：
- en: '[PRE11]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**14.11  Maximum Equality**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.11  最大平等性**'
- en: What’s the order of heapsort if you use it to sort an array filled with the
    same value?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用堆排序来排序一个填满相同值的数组，它的时间复杂度是多少？
- en: '**14.12  Unstable Heap?**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.12  不稳定的堆？**'
- en: 'Heapsort isn’t stable, and trying to sort a short array is enough to verify
    this. Can you produce such an example and show the lack of stability? Tip: you
    won’t need a very large array.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序不是稳定的，尝试排序一个短数组就足以验证这一点。你能提供一个这样的例子并展示其不稳定性吗？提示：你不需要一个很大的数组。
- en: '**14.13  Trimmed Selection**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.13 修剪选择**'
- en: You can use a heap to select the *k* greatest values out of *n* by removing
    the top of the heap *k* times. However, if *k* << *n*, you may speed up things
    a bit. Show that the *k* greatest values must be found in level 1 (the root) up
    to level *k* (but not beyond), and use this finding to prune the heap before doing
    the selection.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用堆从 *n* 中选择出 *k* 个最大值，通过将堆顶移除 *k* 次。然而，如果 *k* << *n*，你可能会稍微加速一些。证明这 *k*
    个最大值一定出现在第 1 层（根节点）到第 *k* 层（但不超过此层），并利用这一发现，在进行选择前修剪堆。
- en: '**14.14  Is It a Treap?**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.14 它是一个 Treap 吗？**'
- en: Given a binary tree whose nodes have key and priority fields, can you write
    a function that will check whether that tree is actually a treap?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个二叉树，其中每个节点有键和值域，你能写一个函数来检查该树是否实际上是一个 treap 吗？
- en: '**14.15  Splitting a Treap**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.15 拆分 Treap**'
- en: 'Given a treap and a limit value, partition it into two separate treaps: one
    with all the keys smaller than the limit value and the other with all the keys
    larger than the limit. Assume that the limit value isn’t in the treap.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 treap 和一个限制值，将其分成两个独立的 treap：一个包含所有小于限制值的键，另一个包含所有大于限制值的键。假设限制值不在 treap
    中。
- en: '**14.16  Rejoining Two Treaps**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.16 重新连接两个 Treap**'
- en: 'Consider the inverse to question 14.15: assume that you have two separate treaps,
    such that all keys in the first are smaller than all keys in the second. Can you
    find a way to join those two treaps to form a single one?'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第 14.15 问题的逆问题：假设你有两个独立的 treap，第一个 treap 中的所有键都小于第二个 treap 中的所有键。你能找到一种方法将这两个
    treap 合并为一个吗？
- en: '**14.17  Removing from a Treap**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.17 从 Treap 中移除**'
- en: If in the remove() method for a treap you changed the line
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 treap 的 remove() 方法中你更改了这一行
- en: '[PRE12]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 改为
- en: '[PRE13]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'would it still work? For reference, this is how the code would look (the changed
    line is in bold):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然会起作用吗？参考代码如下（更改的行以**粗体**显示）：
- en: '[PRE14]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**14.18  Trees as Heaps**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.18 树作为堆**'
- en: 'What would happen if you used binary search trees to represent heaps? What
    would the performance be of the three basic operations: add(), remove(), and top()?
    Can you think of ways to make top() faster?'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用二叉搜索树来表示堆，会发生什么？三个基本操作：add()、remove() 和 top() 的性能会如何？你能想到哪些方法来加速 top()
    操作？
