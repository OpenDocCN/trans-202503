- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*What seems complex from a distance is often quite simple when you look closely
    enough.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At first glance, learning how to use Ruby can seem fairly simple. Developers
    around the world find Ruby’s syntax to be graceful and straightforward. You can
    express algorithms in a very natural way, and then it’s just a matter of typing
    `ruby` at the command line and pressing enter, and your Ruby script is running.
  prefs: []
  type: TYPE_NORMAL
- en: However, Ruby’s syntax is *deceptively* simple; in fact, Ruby employs sophisticated
    ideas from complex languages like Lisp and Smalltalk. On top of this, Ruby is
    dynamic; using metaprogramming, Ruby programs can inspect and change themselves.
    Beneath this thin veneer of simplicity, Ruby is a very complex tool.
  prefs: []
  type: TYPE_NORMAL
- en: By looking very closely at Ruby—by learning how Ruby itself works internally—you’ll
    discover that a few important computer science concepts underpin Ruby’s many features.
    By studying these, you’ll gain a deeper understanding of what is happening under
    the hood as you use the language. In the process, you’ll learn how the team that
    built Ruby *intends* for you to use the language.
  prefs: []
  type: TYPE_NORMAL
- en: '*Ruby Under a Microscope* will show you what happens inside Ruby when you run
    a simple program. You’ll learn how Ruby understands and executes your code, and
    with the help of extensive diagrams, you’ll build a mental model of what Ruby
    does when you create an object or call a block.'
  prefs: []
  type: TYPE_NORMAL
- en: Who This Book Is For
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Ruby Under a Microscope* is not a beginner’s guide to learning Ruby. I assume
    you already know how to program in Ruby and that you use it daily. There are already
    many great books that teach Ruby basics; the world doesn’t need another one.'
  prefs: []
  type: TYPE_NORMAL
- en: Although Ruby itself is written in C, a confusing, low-level language, no C
    programming knowledge is required to read this book. *Ruby Under a Microscope*
    will give you a high-level, conceptual understanding of how Ruby works without
    your having to understand how to program in C. Inside this book, you’ll find hundreds
    of diagrams that make the low-level details of Ruby’s internal implementation
    easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Readers familiar with C will find a few snippets of C code that give a more
    concrete sense of what’s going on inside Ruby. I’ll also tell you where the code
    derives from, making it easier for you to start studying the C code yourself.
    If you’re not interested in the C code details, just skip over these sections.*'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ruby to Test Itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn’t matter how beautiful your theory is, it doesn’t matter how smart
    you are. If it doesn’t agree with experiment, it’s wrong.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Richard Feynman
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Imagine that the entire world functioned like a large computer program. To explain
    natural phenomena or experimental results, physicists like Richard Feynman would
    simply consult this program. (A scientist’s dream come true!) But of course, the
    universe is not so simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, to discover how Ruby works, all we need to do is read its internal
    C source code: a kind of theoretical physics that describes Ruby’s behavior. Just
    as Maxwell’s equations explain electricity and magnetism, Ruby’s internal C source
    code explains what happens when you pass an argument to a method or include a
    module in a class.'
  prefs: []
  type: TYPE_NORMAL
- en: Like scientists, however, we need to perform experiments to be sure our hypotheses
    are correct. After learning about each part of Ruby’s internal implementation,
    we’ll perform an experiment and use Ruby to test itself! We’ll run small Ruby
    test scripts to see whether they produce the expected output or run as quickly
    or as slowly as we expect. We’ll find out if Ruby actually behaves the way theory
    says it should. And since these experiments are written in Ruby, you can try them
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Which Implementation of Ruby?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby was invented by Yukihiro “Matz” Matsumoto in 1993, and the original, standard
    version of Ruby is often known as *Matz’s Ruby Interpreter (MRI)*. Most of this
    book will discuss how MRI works; essentially, we’ll learn how Matz implemented
    his own language.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years many alternative implementations of Ruby have been written. Some,
    like RubyMotion, MacRuby, and IronRuby, were designed to run on specific platforms.
    Others, like Topaz and JRuby, were built using programming languages other than
    C. One version, Rubinius, was built using Ruby itself. And Matz himself is now
    working on a smaller version of Ruby called *mruby*, designed to run inside another
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'I explore the Ruby implementations JRuby and Rubinius in detail in [Chapter 10](ch10.html
    "Chapter 10. JRuby: Ruby on the JVM"), [Chapter 11](ch11.html "Chapter 11. Rubinius:
    Ruby Implemented with Ruby"), and [Chapter 12](ch12.html "Chapter 12. Garbage
    Collection in MRI, JRuby, and Rubinius"). You’ll learn how they use different
    technologies and philosophies to implement the same language. As you study these
    alternative Rubies, you’ll gain additional perspective on MRI’s implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In **[Chapter 1](ch01.html "Chapter 1. Tokenization and Parsing")**, you’ll
    learn how Ruby parses your Ruby program. This is one of the most fascinating areas
    of computer science: How can a computer language be smart enough to understand
    the code you give it? What does this intelligence really consist of?'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2](ch02.html "Chapter 2. Compilation")** explains how Ruby uses
    a compiler to convert your program into a different language before running it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code")** looks at
    the virtual machine Ruby uses to run your program. What’s inside this machine?
    How does it work? We’ll look deep inside this virtual machine to find out.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](ch04.html "Chapter 4. Control Structures and Method Dispatch")**
    continues the description of Ruby’s virtual machine, looking at how Ruby implements
    control structures such as `if...else` statements and `while...end` loops. It
    also explores how Ruby implements method calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](ch05.html "Chapter 5. Objects and Classes")** discusses Ruby’s
    implementation of objects and classes. How are objects and classes related? What
    would we find inside a Ruby object?'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6](ch06.html "Chapter 6. Method Lookup and Constant Lookup")** examines
    Ruby modules and their relationship to classes. You’ll learn how Ruby finds methods
    and constants in your Ruby code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7](ch07.html "Chapter 7. The Hash Table: The Workhorse of Ruby Internals")**
    explores Ruby’s implementation of hash tables. As it turns out, MRI uses hash
    tables for much of its internal data, not only for data you save in Ruby hash
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](ch08.html "Chapter 8. How Ruby Borrowed a Decades-Old Idea from
    Lisp")** reveals that one of Ruby’s most elegant and useful features, blocks,
    is based on an idea originally developed for Lisp.'
  prefs: []
  type: TYPE_NORMAL
- en: In **[Chapter 9](ch09.html "Chapter 9. Metaprogramming")** tackles one of the
    most difficult topics for Ruby developers. By studying how Ruby implements metaprogramming
    internally, you’ll learn how to use metaprogramming effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10](ch10.html "Chapter 10. JRuby: Ruby on the JVM")** introduces
    JRuby, an alternative version of Ruby implemented with Java. You’ll learn how
    JRuby uses the Java Virtual Machine (JVM) to run your Ruby programs faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11](ch11.html "Chapter 11. Rubinius: Ruby Implemented with Ruby")**
    looks at one of the most interesting and innovative implementations of Ruby: Rubinius.
    You’ll learn how to locate—and modify—the Ruby code in Rubinius to see how a particular
    Ruby method works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12](ch12.html "Chapter 12. Garbage Collection in MRI, JRuby, and
    Rubinius")** concludes with a look at garbage collection (GC), one of the most
    mysterious and confusing topics in computer science. You’ll see how Rubinius and
    JRuby use very different GC algorithms from those used by MRI.'
  prefs: []
  type: TYPE_NORMAL
- en: By studying all of these aspects of Ruby’s internal implementation, you’ll acquire
    a deeper understanding of what happens when you use Ruby’s complex feature set.
    Just as Antonie van Leeuwenhoek first saw microbes and cells looking through early
    microscopes in the 1600s, by looking inside of Ruby you’ll discover a wide array
    of interesting structures and algorithms. Join me on a fascinating behind-the-scenes
    look at what brings Ruby to life!
  prefs: []
  type: TYPE_NORMAL
