<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch7">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label=" Page 123. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NETWORK FILTER DRIVERS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Sometimes an EDR must implement its own sensor to capture the telemetry data generated by certain system components. Filesystem minifilters are one example of this. In Windows, the network stack is no different.</p>&#13;
<p class="TX">A host-based security agent might wish to capture network telemetry for many reasons. Network traffic is tied to the most common way for an attacker to gain initial access to a system (for example, when a user visits a malicious website). It’s also one of the key artifacts created when they perform lateral movement to jump from one host to another. If an endpoint security product wishes to capture and perform inspection on network packets, it’ll most likely implement some type of network filter driver.</p>&#13;
<p class="TX">This chapter covers one of the most common driver frameworks used to capture network telemetry: Windows Filtering Platform (WFP). The Windows network stack and driver ecosystem can be a little overwhelming for newcomers, so to reduce the likelihood of headaches, we’ll briefly introduce core concepts and then focus only on the elements relevant to an EDR’s sensor.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-89"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label=" Page 124. "/><samp class="SANS_Futura_Std_Bold_B_11">Network-Based vs. Endpoint-Based Monitoring</samp></h2>&#13;
<p class="TNI">You might assume that the best way to detect malicious traffic is to use a network-based security appliance, but this isn’t always the case. The efficacy of these network appliances depends on their position in the network. For example, a network intrusion detection system (NIDS) would need to sit between host A and host B in order to detect lateral movement between the two.</p>&#13;
<p class="TX">Imagine that the adversary must cross core network boundaries (for example, to move from the VPN subnet into the data center subnet). In those situations, the security engineers can strategically deploy the appliance at a logical choke point through which all that traffic must flow. This boundary-oriented architecture would look similar to the one shown in <a href="#fig7-1">Figure 7-1</a>.</p>&#13;
<figure class="IMG"><img id="fig7-1" class="img40" src="../images/Figure7-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A NIDS between two networks</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">But what about intra-subnet lateral movement, such as movement from workstation to workstation? It wouldn’t be cost-effective to deploy a network-monitoring appliance between every node on the local network, but security teams still need that telemetry to detect adversarial activities in their networks.</p>&#13;
<p class="TX">This is where an endpoint-based traffic-monitoring sensor comes into play. By deploying a monitoring sensor on every client, a security team can solve the problem of where in the network to insert their appliance. After all, if the sensor is monitoring traffic on a client, as shown in <a href="#fig7-2">Figure 7-2</a>, it effectively has a man-in-the-middle relationship between the client and all other systems the client may communicate with.</p>&#13;
<figure class="IMG"><img id="fig7-2" class="img60" src="../images/Figure7-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Endpoint network monitoring</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label=" Page 125. "/>Using endpoint-based monitoring offers another valuable advantage over network-based solutions: context. Because the agent running on the endpoint can collect additional host-based information, it can paint a more complete picture of how and why the network traffic was created. For example, it could determine that a child process of <i>outlook.exe</i> with a certain PID is communicating with a content distribution network endpoint once every 60 seconds; this might be command-and-control beaconing from a process tied to initial access.</p>&#13;
<p class="TX">The host-based sensor can get data related to the originating process, user context, and activities that occurred before the connection happened. By contrast, an appliance deployed on the network would be able to see only the metrics about the connection, such as its source and destination, packet frequency, and protocol. While this can provide valuable data to responders, it misses key pieces of information that would aid their investigation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-90"/><samp class="SANS_Futura_Std_Bold_B_11">Legacy Network Driver Interface Specification Drivers</samp></h2>&#13;
<p class="TNI">There are many types of network drivers, most of which are backed by the Network Driver Interface Specification (NDIS). NDIS is a library that abstracts a device’s network hardware. It also defines a standard interface between <i>layered</i> network drivers (those operating at different network layers and levels of the operating system) and maintains state information. NDIS supports four types of drivers:</p>&#13;
<p class="RunInPara"><b>Miniport</b>   Manages a network interface card, such as by sending and receiving data. This is the lowest level of NDIS drivers.</p>&#13;
<p class="RunInPara"><b>Protocol</b>   Implements a transport protocol stack, such as TCP/IP. This is the highest level of NDIS drivers.</p>&#13;
<p class="RunInPara"><b>Filter</b>   Sits between miniport and protocol drivers to monitor and modify the interactions between the two subtypes.</p>&#13;
<p class="RunInPara"><b>Intermediate</b>   Sits between miniport and protocol drivers to expose both drivers’ entry points for communicating requests. These drivers expose a virtual adapter to which the protocol driver sends its packets. The intermediate driver then ships these packets to the appropriate miniport. After the miniport completes its operation, the intermediate driver passes the information back to the protocol driver. These drivers are commonly used for load-balancing traffic across more than one network interface card.</p>&#13;
<p class="TX">The interactions of these drivers with NDIS can be seen in the (grossly oversimplified) diagram in <a href="#fig7-3">Figure 7-3</a>.</p>&#13;
<p class="TX">For the purposes of security monitoring, filter drivers work best, as they can catch network traffic at the lowest levels of the network stack, just before it is passed to the miniport and associated network interface card. However, these drivers pose some challenges, such as significant code complexity, limited support for the network and transport layers, and a difficult installation process.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label=" Page 126. "/>&#13;
<figure class="IMG"><img id="fig7-3" class="img100" src="../images/Figure7-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: NDIS driver relationships</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">But perhaps the biggest issue with filter drivers when it comes to security monitoring is their lack of context. While they can capture the traffic being processed, they aren’t aware of the caller context (the process that initiated the request) and lack the metadata needed to provide valuable telemetry to the EDR agent. For this reason, EDRs nearly always use another framework: the Windows Filtering Platform (WFP).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h2 class="H1" id="sec3"><span id="h-91"/><samp class="SANS_Futura_Std_Bold_B_11">The Windows Filtering Platform</samp></h2>&#13;
<p class="TNI">WFP is a set of APIs and services for creating network-filtering applications, and it includes both user-mode and kernel-mode components. It was designed to replace legacy filtering technologies, including the NDIS filters, starting in Windows Vista and Server 2008. While WFP has some downsides when it comes to network performance, it is generally considered the best option for creating filter drivers. Even the Windows firewall itself is built on WFP.</p>&#13;
<p class="TX">The platform offers numerous benefits. It allows EDRs to filter traffic related to specific applications, users, connections, network interface cards, and ports. It supports both IPv4 and IPv6, provides boot-time security until the base filtering engine has started, and lets drivers filter, modify, and reinject traffic. It can also process pre- and post-decryption IPsec packets and integrates hardware offloading, allowing filter drivers to use hardware for packet inspection.</p>&#13;
<p class="TX">WFP’s implementation can be tricky to understand, as it has a complex architecture and uses unique names for its core components, which are distributed across both user mode and kernel mode. The WFP architecture looks something like what is shown in <a href="#fig7-4">Figure 7-4</a>.</p>&#13;
<p class="TX">To make sense of all this, let’s follow part of a TCP stream coming from a client connected to a server on the internet. The client begins by calling a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!send()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">WS2_32!WSASend()</samp> to send data over a connected socket. These functions eventually pass the packet down to the network stack provided by <i>tcpip.sys</i> for IPv4 and <i>tcpip6.sys</i> for IPv6.</p>&#13;
<p class="TX">As the packet traverses the network stack, it is passed to a shim associated with the relevant layer of the stack, such as the stream layer. <i>Shims</i> are kernel components that have a few critical jobs. One of their first responsibilities is to extract data and properties from the packet and pass them to the filter engine to start the process of applying filters.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label=" Page 127. "/>&#13;
<figure class="IMG"><img id="fig7-4" class="img60" src="../images/Figure7-4.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: The WFP architecture</samp></p></figcaption>&#13;
</figure>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Filter Engine</samp></h3>&#13;
<p class="TNI">The filter engine, sometimes called the <i>generic filter engine</i> to avoid confusion with the user-mode <i>base filtering engine</i>, performs filtering at the network and transport layers. It contains layers of its own, which are containers used to organize filters into sets. Each of these layers, defined as GUIDs under the hood, has a schema that says what types of filters may be added to it. Layers may be further divided into sublayers that manage filtering conflicts. (For example, imagine that the rules “open port 1028” and “block all ports greater than 1024” were configured on the same host.) All layers inherit default sublayers, and developers can add their own.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter Arbitration</samp></h3>&#13;
<p class="TNI">You might be wondering how the filter engine knows the order in which to evaluate sublayers and filters. If rules were applied to traffic in a random order, this could cause huge problems. For example, say the first rule was a default-deny that dropped all traffic. To address this problem, both sublayers and filters can be assigned a priority value, called a <i>weight</i>, that dictates the order in which they should be processed by the filter manager. This ordering logic is called <i>filter arbitration</i>.</p>&#13;
<p class="TX">During filter arbitration, filters evaluate the data parsed from the packet from highest to lowest priority to determine what to do with the packet. Each filter contains conditions and an action, just like common firewall rules (for example, “if the destination port is 4444, block the packet” or “if the application is <i>edge.exe</i>, allow the packet”). The basic actions a filter can return are <i>Block</i> and <i>Permit</i>, but three other supported actions pass <span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label=" Page 128. "/>packet details to callout drivers: <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_TERMINATING</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_UNKNOWN</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Callout Drivers</samp></h3>&#13;
<p class="TNI">Callout drivers are third-party drivers that extend WFP’s filtering functionality beyond that of the base filters. These drivers provide advanced features such as deep-packet inspection, parental controls, and data logging. When an EDR vendor is interested in capturing network traffic, it typically deploys a callout driver to monitor the system.</p>&#13;
<p class="TX">Like basic filters, callout drivers can select the types of traffic that they’re interested in. When the callout drivers associated with a particular operation are invoked, they can suggest action be taken on the packet based on their unique internal processing logic. A callout driver can permit some traffic, block it, continue it (meaning pass it to other callout drivers), defer it, drop it, or do nothing. These actions are only suggestions, and the driver might override them during the filter arbitration process.</p>&#13;
<p class="TX">When filter arbitration ends, the result is returned to the shim, which acts on the final filtering decision (for example, permitting the packet to leave the host).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h2 class="H1" id="sec7"><span id="h-95"/><samp class="SANS_Futura_Std_Bold_B_11">Implementing a WFP Callout Driver</samp></h2>&#13;
<p class="TNI">When an EDR product wants to intercept and process network traffic on a host, it most likely uses a WFP callout driver. These drivers must follow a somewhat complex workflow to set up their callout function, but the flow should make sense to you when you consider how packets traverse the network stack and filter manager. These drivers are also substantially easier to work with than their legacy NDIS counterparts, and Microsoft’s documentation should be very helpful for EDR developers looking to add this capability to their sensor lineup.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening a Filter Engine Session</samp></h3>&#13;
<p class="TNI">Like other types of drivers, WFP callout drivers begin their initialization inside their internal <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function. One of the first things the callout driver will do, an activity unique to WFP, is open a session with the filter engine. To do this, the driver calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmEngineOpen()</samp>, defined in <a href="#list7-1">Listing 7-1</a>.</p>&#13;
<pre id="list7-1"><code>DWORD FwpmEngineOpen0(&#13;
  [in, optional] const wchar_t             *serverName,&#13;
  [in]           UINT32                    authnService,&#13;
  [in, optional] SEC_WINNT_AUTH_IDENTITY_W *authIdentity,&#13;
  [in, optional] const FWPM_SESSION0       *session,&#13;
  [out]          HANDLE                    *engineHandle&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpmEngineOpen()</samp> function definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label=" Page 129. "/>The most notable argument passed to this function as input is <samp class="SANS_TheSansMonoCd_W5Regular_11">authnService</samp>, which determines the authentication service to use. This can be either <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_WINNT</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">RPC_C_AUTHN_DEFAULT</samp>, both of which essentially just tell the driver to use NTLM authentication. When this function completes successfully, a handle to the filter engine is returned through the <samp class="SANS_TheSansMonoCd_W5Regular_11">engineHandle</samp> parameter and typically preserved in a global variable, as the driver will need it during its unloading process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering Callouts</samp></h3>&#13;
<p class="TNI">Next, the driver registers its callouts. This is done through a call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpmCalloutRegister()</samp> API. Systems running Windows 8 or later will convert this function to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FwpsCalloutRegister2()</samp>, the definition of which is included in <a href="#list7-2">Listing 7-2</a>.</p>&#13;
<pre id="list7-2"><code>NTSTATUS FwpsCalloutRegister2(&#13;
  [in, out]       void                *deviceObject,&#13;
  [in]            const FWPS_CALLOUT2 *callout,&#13;
  [out, optional] UINT32              *calloutId&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FwpsCalloutRegister2()</samp> function definition</span></p>&#13;
<p class="TX">The pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_CALLOUT2</samp> structure passed as input to this function (via its <samp class="SANS_TheSansMonoCd_W5Regular_11">callout</samp> parameter) contains details about the functions internal to the callout driver that will handle the filtering of packets. It is defined in <a href="#list7-3">Listing 7-3</a>.</p>&#13;
<pre id="list7-3"><code>typedef struct FWPS_CALLOUT2_ {&#13;
  GUID                                 calloutKey;&#13;
  UINT32                               flags;&#13;
  FWPS_CALLOUT_CLASSIFY_FN2            classifyFn;&#13;
  FWPS_CALLOUT_NOTIFY_FN2              notifyFn;&#13;
  FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0  flowDeleteFn;&#13;
} FWPS_CALLOUT2;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_CALLOUT2</samp> structure definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">notifyFn</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">flowDeleteFn</samp> members are callout functions used to notify the driver when there is information to be passed related to the callout itself or when the data that the callout is processing has been terminated, respectively. Because these callout functions aren’t particularly relevant to detection efforts, we won’t cover them in further detail. The <samp class="SANS_TheSansMonoCd_W5Regular_11">classifyFn</samp> member, however, is a pointer to the function invoked whenever there is a packet to be processed, and it contains the bulk of the logic used for inspection. We’ll cover these callouts in <span class="Xref">“Detecting Adversary Tradecraft with Network Filters” on <a href="#sec14">page 135</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h-98"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label=" Page 130. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Callout Function to the Filter Engine</samp></h3>&#13;
<p class="TNI">After we’ve defined the callout function, we can add it to the filter engine by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmCalloutAdd()</samp>, passing the engine handle obtained earlier and a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_CALLOUT</samp> structure, shown in <a href="#list7-4">Listing 7-4</a>, as input.</p>&#13;
<pre id="list7-4"><code>typedef struct FWPM_CALLOUT0_ {&#13;
  GUID               calloutKey;&#13;
  FWPM_DISPLAY_DATA0 displayData;&#13;
  UINT32             flags;&#13;
  GUID               *providerKey;&#13;
  FWP_BYTE_BLOB      providerData;&#13;
  GUID               applicableLayer;&#13;
  UINT32             calloutId;&#13;
} FWPM_CALLOUT0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_CALLOUT</samp> structure definition</span></p>&#13;
<p class="TX">This structure contains data about the callout, such as its optional friendly name and description in its <samp class="SANS_TheSansMonoCd_W5Regular_11">displayData</samp> member, as well as the layers to which the callout should be assigned (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_STREAM_V4</samp> for IPv4 streams). Microsoft documents dozens of filter layer identifiers, each of which usually has IPv4 and IPv6 variants. When the function used by the driver to add its callout completes, it returns a runtime identifier for the callout that is preserved for use during unloading.</p>&#13;
<p class="TX">Unlike filter layers, a developer may add their own sublayers to the system. In those cases, the driver will call <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmSublayerAdd()</samp>, which receives the engine handle, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER</samp> structure, and an optional security descriptor. The structure passed as input includes the sublayer key, a <samp class="SANS_TheSansMonoCd_W5Regular_11">GUID</samp> to uniquely identify the sublayer, an optional friendly name and description, an optional flag to ensure that the sublayer persists between reboots, the sublayer weight, and other members that contain the state associated with a sublayer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a New Filter Object</samp></h3>&#13;
<p class="TNI">The last action a callout driver performs is adding a new filter object to the system. This filter object is the rule that the driver will evaluate when processing the connection. To create one, the driver calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp>, passing in the engine handle, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure shown in <a href="#list7-5">Listing 7-5</a>, and an optional pointer to a security descriptor.</p>&#13;
<pre id="list7-5"><code>typedef struct FWPM_FILTER0_ {&#13;
  GUID                   filterKey;&#13;
  FWPM_DISPLAY_DATA0     displayData;&#13;
  UINT32                 flags;&#13;
  GUID                   *providerKey;&#13;
  FWP_BYTE_BLOB          providerData;&#13;
  GUID                   layerKey;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label=" Page 131. "/>&#13;
  GUID                   subLayerKey;&#13;
  FWP_VALUE0             weight;&#13;
  UINT32                 numFilterConditions;&#13;
  FWPM_FILTER_CONDITION0 *filterCondition;&#13;
  FWPM_ACTION0           action;&#13;
  union {&#13;
    UINT64 rawContext;&#13;
    GUID   providerContextKey;&#13;
  };&#13;
  GUID                   *reserved;&#13;
  UINT64                 filterId;&#13;
  FWP_VALUE0             effectiveWeight;&#13;
} FWPM_FILTER0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER</samp> structure definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure contains a few key members worth highlighting. The <samp class="SANS_TheSansMonoCd_W5Regular_11">flags</samp> member contains several flags that describe attributes of the filter, such as whether the filter should persist through system reboots (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_PERSISTENT</samp>) or if it is a boot-time filter (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_BOOTTIME</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp> member defines the priority value of the filter in relation to other filters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">numFilterConditions</samp> is the number of filtering conditions specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp> member, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_CONDITION</samp> structures that describe all the filtering conditions. For the callout functions to process the event, all conditions must be true. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">action</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_TYPE</samp> value indicating what action to perform if all filtering conditions return true. These actions include permitting, blocking, or passing the request to a callout function.</p>&#13;
<p class="TX">Of these members, <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp> is the most important, as each filter condition in the array represents a discrete “rule” against which the connections will be evaluated. Each rule is itself made up of a condition value and match type. The definition for this structure is shown in <a href="#list7-6">Listing 7-6</a>.</p>&#13;
<pre id="list7-6"><code>typedef struct FWPM_FILTER_CONDITION0_ {&#13;
  GUID                 fieldKey;&#13;
  FWP_MATCH_TYPE       matchType;&#13;
  FWP_CONDITION_VALUE0 conditionValue;&#13;
} FWPM_FILTER_CONDITION0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPM_FILTER_CONDITION</samp> structure definition</span></p>&#13;
<p class="TX">The first member, <samp class="SANS_TheSansMonoCd_W5Regular_11">fieldKey</samp>, indicates the attribute to evaluate. Each filtering layer has its own attributes, identified by GUIDs. For example, a filter inserted in the stream layer can work with local and remote IP addresses and ports, traffic direction (whether inbound or outbound), and flags (for example, if the connection is using a proxy).</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">matchType</samp> member specifies the type of match to be performed. These comparison types are defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_MATCH_TYPE</samp> enumeration shown in <a href="#list7-7">Listing 7-7</a> and can match strings, integers, ranges, and other data types.</p>&#13;
<pre id="list7-7"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label=" Page 132. "/>typedef enum FWP_MATCH_TYPE_ {&#13;
  FWP_MATCH_EQUAL = 0,&#13;
  FWP_MATCH_GREATER,&#13;
  FWP_MATCH_LESS,&#13;
  FWP_MATCH_GREATER_OR_EQUAL,&#13;
  FWP_MATCH_LESS_OR_EQUAL,&#13;
  FWP_MATCH_RANGE,&#13;
  FWP_MATCH_FLAGS_ALL_SET,&#13;
  FWP_MATCH_FLAGS_ANY_SET,&#13;
  FWP_MATCH_FLAGS_NONE_SET,&#13;
  FWP_MATCH_EQUAL_CASE_INSENSITIVE,&#13;
  FWP_MATCH_NOT_EQUAL,&#13;
  FWP_MATCH_PREFIX,&#13;
  FWP_MATCH_NOT_PREFIX,&#13;
  FWP_MATCH_TYPE_MAX&#13;
} FWP_MATCH_TYPE;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_MATCH_TYPE</samp> enumeration</span></p>&#13;
<p class="TX">The last member of the structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionValue</samp>, is the condition against which the connection should be matched. The filter condition value is composed of two parts, the data type and a condition value, housed together in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_CONDITION_VALUE</samp> structure, shown in <a href="#list7-8">Listing 7-8</a>.</p>&#13;
<pre id="list7-8"><code>typedef struct FWP_CONDITION_VALUE0_ {&#13;
  FWP_DATA_TYPE type;&#13;
  union {&#13;
    UINT8                  uint8;&#13;
    UINT16                 uint16;&#13;
    UINT32                 uint32;&#13;
    UINT64                 *uint64;&#13;
    INT8                   int8;&#13;
    INT16                  int16;&#13;
    INT32                  int32;&#13;
    INT64                  *int64;&#13;
    float                  float32;&#13;
    double                 *double64;&#13;
    FWP_BYTE_ARRAY16       *byteArray16;&#13;
    FWP_BYTE_BLOB          *byteBlob;&#13;
    SID                    *sid;&#13;
    FWP_BYTE_BLOB          *sd;&#13;
    FWP_TOKEN_INFORMATION  *tokenInformation;&#13;
    FWP_BYTE_BLOB         *tokenAccessInformation;&#13;
    LPWSTR                 unicodeString;&#13;
    FWP_BYTE_ARRAY6       *byteArray6;&#13;
    FWP_V4_ADDR_AND_MASK   *v4AddrMask;&#13;
    FWP_V6_ADDR_AND_MASK   *v6AddrMask;&#13;
    FWP_RANGE0             *rangeValue;&#13;
  };&#13;
} FWP_CONDITION_VALUE0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_CONDITION_VALUE</samp> structure definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label=" Page 133. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_DATA_TYPE</samp> value indicates what union member the driver should use to evaluate the data. For instance, if the type member is <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_V4_ADDR_MASK</samp>, which maps to an IPv4 address, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">v4AddrMask</samp> member would be accessed.</p>&#13;
<p class="TX">The match type and condition value members form a discrete filtering requirement when combined. For example, this requirement could be “if the destination IP address is 1.1.1.1” or “if the TCP port is greater than 1024.” What should happen when the condition evaluates as true? To determine this, we use the action member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure. In callout drivers that perform firewalling activities, we could choose to permit or block traffic based on certain attributes. In the context of security monitoring, however, most developers forward the request to the callout functions by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_ACTION_CALLOUT_INSPECTION</samp> flag, which passes the request to the callout without expecting the callout to make a permit/deny decision regarding the connection.</p>&#13;
<p class="TX">If we combine all three components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">filterCondition</samp> member, we could represent a filtering condition as a complete sentence, such as the one shown in <a href="#fig7-5">Figure 7-5</a>.</p>&#13;
<figure class="IMG"><img id="fig7-5" class="img60" src="../images/Figure7-5.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Filtering conditions</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At this point, we have our rule’s basic “if this, do that” logic, but we have yet to deal with some other conditions related to filter arbitration.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Weights and Sublayers</samp></h3>&#13;
<p class="TNI">What if our driver has filters to, say, both permit traffic on TCP port 1080 and block outbound connections on TCP ports greater than 1024? To handle these conflicts, we must assign each filter a weight. The greater the weight, the higher the priority of the condition, and the earlier it should be evaluated. For instance, the filter allowing traffic on port 1080 should be evaluated before the one blocking all traffic using ports higher than 1024 to permit software using port 1080 to function. In code, a weight is just an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT8</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT64</samp>) assigned in the weight member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER</samp> structure.</p>&#13;
<p class="TX">In addition to assigning the weight, we need to assign the filter to a sublayer so that it is evaluated at the correct time. We do this by specifying a GUID in the <samp class="SANS_TheSansMonoCd_W5Regular_11">layerKey</samp> member of the structure. If we created our own sublayer, we would specify its GUID here. Otherwise, we’d use one of the default sublayer GUIDs listed in <a href="#tab7-1">Table 7-1</a>.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab7-1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label=" Page 134. "/><samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default Sublayer GUIDs</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Filter sublayer identifier</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Filter type</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_EDGE_TRAVERSAL</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(BA69DC66-5176-4979-9C89-26A7B46A8327)</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Edge traversal</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_INSPECTION</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(877519E1-E6A9-41A5-81B4-8C4F118E4A60)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Inspection</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_DOSP</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(E076D572-5D3D-48EF-802B-909EDDB098BD)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">IPsec denial-of-service (DoS) protection</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_TUNNEL</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(A5082E73-8F71-4559-8A9A-101CEA04EF87)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">IPsec forward outbound tunnel</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_TUNNEL</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(83F299ED-9FF4-4967-AFF4-C309F4DAB827)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">IPsec tunnel</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_LIPS</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(1B75C0CE-FF60-4711-A70F-B4958CC3B2D0)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Legacy IPsec filters</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_RPC_AUDIT</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(758C84F4-FB48-4DE9-9AEB-3ED9551AB1FD)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Remote procedure call (RPC) audit</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_SECURE_SOCKET</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(15A66E17-3F3C-4F7B-AA6C-812AA613DD82)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Secure socket</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(337608B9-B7D5-4D5F-82F9-3618618BC058)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">TCP Chimney Offload</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_TCP_TEMPLATES</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(24421DCF-0AC5-4CAA-9E14-50F6E3636AF0)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">TCP template</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_UNIVERSAL</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(EEBECC03-CED4-4380-819A-2734397B2B74)</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Those not assigned to any other sublayers</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_SUBLAYER_IPSEC_SECURITY_REALM</samp> sublayer identifier is defined in the <i>fwpmu.h</i> header but is undocumented.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H2" id="sec13"><span id="h-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a Security Descriptor</samp></h3>&#13;
<p class="TNI">The last parameter we can pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp> is a security descriptor. While optional, it allows the developer to explicitly set the access control list for their filter. Otherwise, the function will apply a default value to the filter. This default security descriptor grants <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> rights to members of the Local Administrators group, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp> rights to members of the Network Configuration Operators group, as well as the diagnostic service host (<i>WdiServiceHost</i>), IPsec policy agent (<i>PolicyAgent</i>), network list service (<i>NetProfm</i>), remote procedure call (<i>RpcSs</i>), and Windows firewall (<i>MpsSvc</i>) services. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_OPEN</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_ACTRL_CLASSIFY</samp> are granted to the Everyone group.</p>&#13;
<p class="TX">After the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpuclnt!FwpmFilterAdd()</samp> completes, the callout driver has been initialized, and it will process events until the driver is ready to be unloaded. The unloading process is outside the scope of this chapter, as it is largely irrelevant to security monitoring, but it closes all the previously opened handles, deletes created sublayers and filters, and safely removes the driver.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h2 class="H1" id="sec14"><span id="h-102"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label=" Page 135. "/><samp class="SANS_Futura_Std_Bold_B_11">Detecting Adversary Tradecraft with Network Filters</samp></h2>&#13;
<p class="TNI">The bulk of the telemetry that a WFP filter driver collects comes from its callouts. These are most often <i>classify</i> callouts, which receive information about the connection as input. From this data, developers can extract telemetry useful for detecting malicious activity. Let’s explore these functions further, starting with their definition in <a href="#list7-9">Listing 7-9</a>.</p>&#13;
<pre id="list7-9"><code>FWPS_CALLOUT_CLASSIFY_FN2 FwpsCalloutClassifyFn2;&#13;
&#13;
void FwpsCalloutClassifyFn2(&#13;
  [in]                const FWPS_INCOMING_VALUES0 *inFixedValues,&#13;
  [in]                const FWPS_INCOMING_METADATA_VALUES0 *inMetaValues,&#13;
  [in, out, optional] void *layerData,&#13;
  [in, optional]      const void *classifyContext,&#13;
  [in]                const FWPS_FILTER2 *filter,&#13;
  [in]                UINT64 flowContext,&#13;
  [in, out]           FWPS_CLASSIFY_OUT0 *classifyOut&#13;
)&#13;
{...}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-9: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FwpsCalloutClassifyFn</samp> definition</span></p>&#13;
<p class="TX">On invocation, the callout receives pointers to a few structures containing interesting details about the data being processed. These details include the basic network information you’d expect to receive from any packet-capturing application (the remote IP address, for example) and metadata that provides additional context, including the requesting process’s PID, image path, and token.</p>&#13;
<p class="TX">In return, the callout function will set the action for the stream-layer shim to take (assuming the packet being processed is in the stream layer), as well as an action for the filter engine to take, such as to block or allow the packet. It might also defer the decision-making to the next registered callout function. We describe this process in greater detail in the following sections.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Basic Network Data</samp></h3>&#13;
<p class="TNI">The first parameter, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_VALUES</samp> structure, is defined in <a href="#list7-10">Listing 7-10</a> and contains information about the connection that has been passed from the filter engine to the callout.</p>&#13;
<pre id="list7-10"><code>typedef struct FWPS_INCOMING_VALUES0_ {&#13;
  UINT16               layerId;&#13;
  UINT32               valueCount;&#13;
  FWPS_INCOMING_VALUE0 *incomingValue;&#13;
} FWPS_INCOMING_VALUES0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_VALUES</samp> structure</span></p>&#13;
<p class="TX">The first member of this structure contains the identifier of the filter layer at which the data was obtained. Microsoft defines these values (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_LAYER_INBOUND_IPPACKET_V4</samp>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label=" Page 136. "/>The second member contains the number of entries in the array pointed to by the third parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">incomingValue</samp>. This is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS _INCOMING_VALUE</samp> structures containing the data that the filter engine passes to the callout. Each structure in the array has only an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWP_VALUE</samp> structure, shown in <a href="#list7-11">Listing 7-11</a>, that describes the type and value of the data.</p>&#13;
<pre id="list7-11"><code>typedef struct FWP_VALUE0_ {&#13;
  FWP_DATA_TYPE type;&#13;
  union {&#13;
    UINT8                  uint8;&#13;
    UINT16                 uint16;&#13;
    UINT32                 uint32;&#13;
    UINT64                 *uint64;&#13;
    INT8                   int8;&#13;
    INT16                  int16;&#13;
    INT32                  int32;&#13;
    INT64                  *int64;&#13;
    float                  float32;&#13;
    double                 *double64;&#13;
    FWP_BYTE_ARRAY16       *byteArray16;&#13;
    FWP_BYTE_BLOB          *byteBlob;&#13;
    SID                    *sid;&#13;
    FWP_BYTE_BLOB          *sd;&#13;
    FWP_TOKEN_INFORMATION  *tokenInformation;&#13;
    FWP_BYTE_BLOB          *tokenAccessInformation;&#13;
    LPWSTR                 unicodeString;&#13;
    FWP_BYTE_ARRAY6        *byteArray6;&#13;
  };&#13;
} FWP_VALUE0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWP_VALUE</samp> structure definition</span></p>&#13;
<p class="TX">To access the data inside the array, the driver needs to know the index at which the data resides. This index varies based on the layer identifier being processed. For instance, if the layer is <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_LAYER_OUTBOUND_IPPACKET_V4</samp>, the driver would access fields based on their index in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp> enumeration, defined in <a href="#list7-12">Listing 7-12</a>.</p>&#13;
<pre id="list7-12"><code>typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V4_ {&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_TYPE,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_TUNNEL_TYPE,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_COMPARTMENT_ID,&#13;
  FWPS_FIELD_OUTBOUND_IPPACKET_V4_MAX&#13;
} FWPS_FIELDS_OUTBOUND_IPPACKET_V4;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-12: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_FIELDS_OUTBOUND_IPPACKET_V4</samp> enumeration</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label=" Page 137. "/>For example, if an EDR’s driver wanted to inspect the remote IP address, it could access this value using the code in <a href="#list7-13">Listing 7-13</a>.</p>&#13;
<pre id="list7-13"><code>if (inFixedValues-&gt;layerId == FWPS_LAYER_OUTBOUND_IPPACKET_V4)&#13;
{&#13;
  UINT32 remoteAddr = inFixedValues-&gt;&#13;
    incomingValues[FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS].value.uint32;&#13;
&#13;
  <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-13: Accessing the remote IP address in the incoming values</span></p>&#13;
<p class="TX">In this example, the EDR driver extracts the IP address by referencing the unsigned 32-bit integer (<samp class="SANS_TheSansMonoCd_W5Regular_11">uint32</samp>) value at the index <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS</samp> in the incoming values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h-104"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Metadata</samp></h3>&#13;
<p class="TNI">The next parameter that the callout function receives is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_INCOMING_METADATA_VALUES0</samp> structure, which provides incredibly valuable metadata to an EDR, beyond the information you’d expect to get from a packet-capture application such as Wireshark. You can see this metadata in <a href="#list7-14">Listing 7-14</a>.</p>&#13;
<pre id="list7-14"><code>typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#13;
  UINT32                          currentMetadataValues;&#13;
  UINT32                          flags;&#13;
  UINT64                          reserved;&#13;
  FWPS_DISCARD_METADATA0          discardMetadata;&#13;
  UINT64                          flowHandle;&#13;
  UINT32                          ipHeaderSize;&#13;
  UINT32                          transportHeaderSize;&#13;
  FWP_BYTE_BLOB                   *processPath;&#13;
  UINT64                          token;&#13;
  UINT64                          processId;&#13;
  UINT32                          sourceInterfaceIndex;&#13;
  UINT32                          destinationInterfaceIndex;&#13;
  ULONG                           compartmentId;&#13;
  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#13;
  ULONG                           pathMtu;&#13;
  HANDLE                          completionHandle;&#13;
  UINT64                          transportEndpointHandle;&#13;
  SCOPE_ID                        remoteScopeId;&#13;
  WSACMSGHDR                      *controlData;&#13;
  ULONG                           controlDataLength;&#13;
  FWP_DIRECTION                   packetDirection;&#13;
  PVOID                           headerIncludeHeader;&#13;
  ULONG                           headerIncludeHeaderLength;&#13;
  IP_ADDRESS_PREFIX               destinationPrefix;&#13;
  UINT16                          frameLength;&#13;
  UINT64                          parentEndpointHandle;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label=" Page 138. "/>&#13;
  UINT32                          icmpIdAndSequence;&#13;
  DWORD                           localRedirectTargetPID;&#13;
  SOCKADDR                        *originalDestination;&#13;
  HANDLE                          redirectRecords;&#13;
  UINT32                          currentL2MetadataValues;&#13;
  UINT32                          l2Flags;&#13;
  UINT32                          ethernetMacHeaderSize;&#13;
  UINT32                          wiFiOperationMode;&#13;
  NDIS_SWITCH_PORT_ID             vSwitchSourcePortId;&#13;
  NDIS_SWITCH_NIC_INDEX           vSwitchSourceNicIndex;&#13;
  NDIS_SWITCH_PORT_ID             vSwitchDestinationPortId;&#13;
  UINT32                          padding0;&#13;
  USHORT                          padding1;&#13;
  UINT32                          padding2;&#13;
  HANDLE                          vSwitchPacketContext;&#13;
  PVOID                           subProcessTag;&#13;
  UINT64                          reserved1;&#13;
} FWPS_INCOMING_METADATA_VALUES0;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FWPS_INCOMING_METADATA_VALUES0</samp> structure definition</span></p>&#13;
<p class="TX">We mentioned that one of the main benefits to monitoring network traffic on each endpoint is the context that this approach provides to the EDR. We can see this in the <samp class="SANS_TheSansMonoCd_W5Regular_11">processPath</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">processId</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">token</samp> members, which give us information about the endpoint process and the associated principal.</p>&#13;
<p class="TX">Note that not all values in this structure will be populated. To see which values are present, the callout function checks the <samp class="SANS_TheSansMonoCd_W5Regular_11">currentMetadataValues</samp> member, which is a bitwise-OR of a combination of metadata filter identifiers. Microsoft nicely provided us with a macro, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_IS_METADATA_FIELD_PRESENT()</samp>, that will return true if the value we’re interested in is present.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Layer Data</samp></h3>&#13;
<p class="TNI">After the metadata, the classify function receives information about the layer being filtered and the conditions under which the callout is invoked. For example, if the data originates from the stream layer, the parameter will point to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_CALLOUT_IO_PACKET0</samp> structure. This layer data contains a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_DATA0</samp> structure, which contains flags that encode the characteristics of the stream (for example, whether it is inbound or outbound, whether it is high priority, and whether the network stack will pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">FIN</samp> flag in the final packet). It will also contain the offset to the stream, the size of its data in the stream, and a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp> that describes the current portion of the stream.</p>&#13;
<p class="TX">This buffer list is a linked list of <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER</samp> structures. Each structure in the list contains a chain of memory descriptor lists used to hold the data sent or received over the network. Note that if the request didn’t originate from the stream layer, the <samp class="SANS_TheSansMonoCd_W5Regular_11">layerData</samp> parameter will point only to a <samp class="SANS_TheSansMonoCd_W5Regular_11">NET_BUFFER_LIST</samp>, assuming it is not null.</p>&#13;
<p class="TX">The layer data structure also contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp> member, which is an <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_TYPE</samp> value describing an action that the callout recommends the stream-layer shim take. These include:</p>&#13;
<ul class="BL">&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label=" Page 139. "/>Doing nothing (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NONE</samp>).</li>&#13;
<li class="BL">Allowing all future data segments in the flow to continue without inspection (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_ALLOW_CONNECTION</samp>).</li>&#13;
<li class="BL">Requesting more data. If this is set, the callout must populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">countBytesRequired</samp> member with the number of bytes of stream data required (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_NEED_MORE_DATA</samp>).</li>&#13;
<li class="BL">Dropping the connection (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DROP_CONNECTION</samp>).</li>&#13;
<li class="BL">Deferring processing until <samp class="SANS_TheSansMonoCd_W5Regular_11">fwpkclnt!FwpsStreamContinue0()</samp> is called. This is used for flow control, to slow down the rate of incoming data (<samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_STREAM_ACTION_DEFER</samp>).</li>&#13;
</ul>&#13;
<p class="TX">Don’t confuse this <samp class="SANS_TheSansMonoCd_W5Regular_11">streamAction</samp> member with the <samp class="SANS_TheSansMonoCd_W5Regular_11">classifyOut</samp> parameter passed to the classify function to indicate the result of the filtering operation.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h-106"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Network Filters</samp></h2>&#13;
<p class="TNI">You’re probably interested in evading network filters primarily because you’d like to get your command-and-control traffic to the internet, but other types of traffic are subject to filtering too, such as lateral movement and network reconnaissance.</p>&#13;
<p class="TX">However, when it comes to evading WFP callout drivers, there aren’t many options (at least not compared to those available for other sensor components). In a lot of ways, evading network filters is very similar to performing a standard firewall rule assessment. Some filters may opt to explicitly permit or deny traffic, or they may send the contents off for inspection by a callout.</p>&#13;
<p class="TX">As with any other type of rule-coverage analysis, the bulk of the work comes down to enumerating the various filters on the system, their configurations, and their rulesets. Thankfully, many available tools can make this process relatively painless. The built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">netsh</samp> command allows you to export the currently registered filters as an XML document, an example of which is shown in <a href="#list7-15">Listing 7-15</a>.</p>&#13;
<pre id="list7-15"><code>PS &gt; <b>netsh</b>&#13;
netsh&gt; <b>wfp</b>&#13;
netsh wfp&gt; <b>show filters</b>&#13;
Data collection successful; output = filters.xml&#13;
&#13;
netsh wfp&gt; <b>exit</b>&#13;
&#13;
PS &gt; <b>Select-Xml .\filters.xml -XPath 'wfpdiag/filters/item/displayData/name' | </b>&#13;
<b>&gt;&gt; ForEach-Object {$_.Node.InnerXML}</b>&#13;
Rivet IpPacket V4 IpPacket Outbound Filtering Layer&#13;
Rivet IpPacket V6 Network Outbound Filtering Layer&#13;
Boot Time Filter&#13;
Boot Time Filter&#13;
Rivet IpV4 Inbound Transport Filtering Layer&#13;
Rivet IpV6 Inbound Transport Filtering Layer&#13;
Rivet IpV4 Outbound Transport Filtering Layer&#13;
Rivet IpV6 Outbound Filtering Layer<span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label=" Page 140. "/>&#13;
Boot Time Filter&#13;
Boot Time Filter&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-15: Enumerating registered filters with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">netsh</samp></span></p>&#13;
<p class="TX">Because parsing XML can cause some headaches, you might prefer to use an alternative tool, NtObjectManager. It includes cmdlets for collecting information related to WFP components, including sublayer identifiers and filters.</p>&#13;
<p class="TX">One of the first actions you should perform to get an idea of what drivers are inspecting traffic on the system is to list all the non-default sublayers. You can do this using the commands shown in <a href="#list7-16">Listing 7-16</a>.</p>&#13;
<pre id="list7-16"><code>PS &gt; <b>Import-Module NtObjectManager</b>&#13;
PS &gt; <b>Get-FwSubLayer | </b>&#13;
<b>&gt;&gt; Where-Object {$_.Name -notlike ‘WFP Built-in*’} |</b>&#13;
<b>&gt;&gt; select Weight, Name, keyname | </b>&#13;
<b>&gt;&gt; Sort-Object Weight -Descending | fl</b>&#13;
&#13;
Weight  :  32765&#13;
Name    :  IPxlat Forward IPv4 sub layer&#13;
KeyName :  {4351e497-5d8b-46bc-86d9-abccdb868d6d}&#13;
&#13;
Weight  :  4096&#13;
Name    :  windefend&#13;
KeyName  :  {3c1cd879-1b8c-4ab4-8f83-5ed129176ef3}&#13;
&#13;
Weight  :  256&#13;
Name    :  OpenVPN&#13;
KeyName :  {2f660d7e-6a37-11e6-a181-001e8c6e04a2}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-16: Enumerating WFP sublayers using NtObjectManager</span></p>&#13;
<p class="TX">The weights indicate the order in which the sublayers will be evaluated during filter arbitration. Look for interesting sublayers worth exploring further, such as those associated with applications that provide security monitoring. Then, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwFilter</samp> cmdlet, return filters associated with the specified sublayer, as shown in <a href="#list7-17">Listing 7-17</a>.</p>&#13;
<pre id="list7-17"><code>PS &gt; <b>Get-FwFilter | </b>&#13;
<b>&gt;&gt; Where-Object {$_.SubLayerKeyName -eq '{3c1cd879-1b8c-4ab4-8f83-5ed129176ef3}'} | </b>&#13;
<b>&gt;&gt; Where-Object {$_.IsCallout -eq $true} |</b>&#13;
<b>&gt;&gt; select ActionType,Name,LayerKeyName,CalloutKeyName,FilterId | </b>&#13;
<b>&gt;&gt; fl</b>&#13;
&#13;
ActionType     : CalloutTerminating&#13;
Name           : windefend_stream_v4&#13;
LayerKeyName   : FWPM_LAYER_STREAM_V4&#13;
CalloutKeyName : {d67b238d-d80c-4ba7-96df-4a0c83464fa7}&#13;
FilterId       : 69085<span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label=" Page 141. "/>&#13;
&#13;
ActionType     : CalloutInspection&#13;
Name           : windefend_resource_assignment_v4&#13;
LayerKeyName   : FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4&#13;
CalloutKeyName : {58d7275b-2fd2-4b6c-b93a-30037e577d7e}&#13;
FilterId       : 69087&#13;
&#13;
ActionType     : CalloutTerminating&#13;
Name           : windefend_datagram_v6&#13;
LayerKeyName   : FWPM_LAYER_DATAGRAM_DATA_V6&#13;
CalloutKeyName : {80cece9d-0b53-4672-ac43-4524416c0353}&#13;
FilterId       : 69092&#13;
&#13;
ActionType     : CalloutInspection&#13;
Name           : windefend_resource_assignment_v6&#13;
LayerKeyName   : FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6&#13;
CalloutKeyName : {ced78e5f-1dd1-485a-9d35-7e44cc9d784d}&#13;
FilterId       : 69088</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-17: Enumerating filters associated with a subfilter layer</span></p>&#13;
<p class="TX">For our purposes, the most interesting filter in this layer is <samp class="SANS_TheSansMonoCd_W5Regular_11">CalloutInspection</samp>, as it sends the contents of the network connection to the driver, which will determine whether to terminate the connection. You can inspect callouts by passing their key names to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-FwCallout</samp> cmdlet. <a href="#list7-18">Listing 7-18</a> shows the process of investigating one of Windows Defender’s filters.</p>&#13;
<pre id="list7-18"><code>PS &gt; <b>Get-FwCallout |</b>&#13;
<b>&gt;&gt; Where-Object {$_.KeyName -eq '{d67b238d-d80c-4ba7-96df-4a0c83464fa7}'} |</b>&#13;
&gt;&gt; <b>select *</b>&#13;
&#13;
Flags               : ConditionalOnFlow, Registered&#13;
ProviderKey         : 00000000-0000-0000-0000-000000000000&#13;
ProviderData        : {}&#13;
ApplicableLayer     : 3b89653c-c170-49e4-b1cd-e0eeeee19a3e&#13;
CalloutId           : 302&#13;
Key                 : d67b238d-d80c-4ba7-96df-4a0c83464fa7&#13;
Name                : windefend_stream_v4&#13;
Description         : windefend&#13;
KeyName             : {d67b238d-d80c-4ba7-96df-4a0c83464fa7}&#13;
SecurityDescriptor  : <var>--snip--</var>&#13;
ObjectName          : windefend_stream_v4&#13;
NtType              : Name = Firewall - Index = -1&#13;
IsContainer         : False</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 7-18: Using NtObjectManager to inspect WFP filters</span></p>&#13;
<p class="TX">This information helps us determine the type of traffic being inspected, as it includes the layer for which the callout is registered; a description that could make understanding the purpose of the callout more easily identifiable; and the security descriptor, which can be audited to find any potential misconfigurations that would grant excessive control over it. But it still doesn’t tell us exactly what the driver is looking for. No two EDR vendors will <span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label=" Page 142. "/>inspect the same attributes in the same way, so the only way to know what a driver is examining is to reverse engineer its callout routines.</p>&#13;
<p class="TX">We can, however, assess WFP filters by looking for configuration gaps like those found in standard firewalls. After all, why bother reverse-engineering a driver when we could just look for rules to abuse? One of my favorite ways of evading detection is to find gaps that allow the traffic to slip through. For example, if a callout only monitors IPv4 traffic, traffic sent using IPv6 won’t be inspected.</p>&#13;
<p class="TX">Because bypasses vary between vendors and environments, try looking for rules that explicitly allow traffic to a certain destination. In my experience, these are usually implemented for the particular environment in which the EDR is deployed rather than being part of the EDR’s default configuration. Some might even be outdated. Say you discover an old rule allowing all outbound traffic on TCP port 443 to a certain domain. If the domain has expired, you may be able to purchase it and use it as an HTTPS command-and-control channel.</p>&#13;
<p class="TX">Also look for specific filter configurations that you can take advantage of. For instance, a filter might clear the <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT</samp>. As a result, lower-priority filters won’t be able to override this filter’s decisions. Now say that an EDR explicitly allows traffic to egress to a domain and clears the aforementioned flag. Even if a lower-priority filter issues a block, the traffic will still be allowed out.</p>&#13;
<p class="TX">(Of course, as with all things WFP, it’s not exactly that simple. There exists a flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">FWPS_RIGHT_ACTION_WRITE</samp>, that vetoes this decision if reset prior to the evaluation of the filter. This is called a <i>filter conflict</i>, and it causes a few things to happen: the traffic is blocked, an audit event is generated, and applications subscribed to notifications will receive one, allowing them to become aware of the misconfiguration.)</p>&#13;
<p class="TX">In summary, evading WFP filters is a lot like evading traditional firewalls: we can look for gaps in the rulesets, configurations, and inspection logic implemented by an EDR’s network filter driver to find ways of getting our traffic out. Evaluate the viability of each technique in the context of the environment and each EDR’s particular filters. In some cases, this can be as simple as reviewing the filtering rules. In others, this may mean a deep dive into the driver’s inspection logic to determine what is being filtered and how.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec19">&#13;
<h2 class="H1" id="sec19"><span id="h-107"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">Network filter drivers have the capability to allow, deny, or inspect network traffic on the host. Most relevant to EDR is the inspection function facilitated by these drivers’ callouts. When an attacker activity involves the network stack, such as command-and-control agent beaconing and lateral movement, a network filter driver sitting inline of the traffic can pick out indicators of it. Evading these callouts requires understanding the types of traffic they wish to inspect and then identifying gaps in coverage, not dissimilar to a standard firewall rule audit.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>