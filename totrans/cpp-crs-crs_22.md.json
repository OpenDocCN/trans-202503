["```\nstd::future<FuncReturnType> std::async([policy], func, Args&&... args);\n```", "```\n#include <future>\n#include <string>\n\nusing namespace std;\n\nTEST_CASE(\"async returns valid future\") {\n  using namespace literals::string_literals;\n  auto the_future = async([] { return \"female\"s; }); ➊\n  REQUIRE(the_future.valid()); ➋\n}\n```", "```\nTEST_CASE(\"future invalid by default\") {\n  future<bool> default_future; ➊\n  REQUIRE_FALSE(default_future.valid()); ➋\n}\n```", "```\nTEST_CASE(\"async returns the return value of the function object\") {\n  using namespace literals::string_literals;\n  auto the_future = async([] { return \"female\"s; }); ➊\n  REQUIRE(the_future.get() == \"female\"); ➋\n}\n```", "```\nTEST_CASE(\"get may throw \") {\n  auto ghostrider = async(\n                      [] { throw runtime_error{ \"The pattern is full.\" }; }); ➊\n  REQUIRE_THROWS_AS(ghostrider.get(), runtime_error); ➋\n}\n```", "```\nTEST_CASE(\"wait_for indicates whether a task is ready\") {\n  using namespace literals::chrono_literals;\n  auto sleepy = async(launch::async, [] { this_thread::sleep_for(100ms); }); ➊\n  const auto not_ready_yet = sleepy.wait_for(25ms); ➋\n  REQUIRE(not_ready_yet == future_status::timeout); ➌\n  const auto totally_ready = sleepy.wait_for(100ms); ➍\n  REQUIRE(totally_ready == future_status::ready); ➎\n}\n```", "```\n#include <set>\n\ntemplate <typename T>\nstd::multiset<T> factorize(T x) {\n  std::multiset<T> result{ 1 }; ➊\n  for(T candidate{ 2 }; candidate <= x; candidate++) { ➋\n    if (x % candidate == 0) { ➌\n      result.insert(candidate); ➍\n      x /= candidate; ➎\n      candidate = 1; ➏\n    }\n  }\n  return result;\n}\n```", "```\n#include <set>\n#include <chrono>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nstruct Stopwatch {\n--snip--\n};\n\ntemplate <typename T>\nset<T> factorize(T x) {\n--snip--\n}\n\nstring factor_task(unsigned long x) { ➊\n  chrono::nanoseconds elapsed_ns;\n  set<unsigned long long> factors;\n  {\n    Stopwatch stopwatch{ elapsed_ns }; ➋\n    factors = factorize(x); ➌\n  }\n  const auto elapsed_ms =\n             chrono::duration_cast<chrono::milliseconds>(elapsed_ns).count(); ➍\n  stringstream ss;\n  ss << elapsed_ms << \" ms: Factoring \" << x << \" ( \"; ➎\n  for(auto factor : factors) ss << factor << \" \"; ➏\n  ss << \")\\n\";\n  return ss.str(); ➐\n}\n```", "```\n#include <set>\n#include <array>\n#include <vector>\n#include <iostream>\n#include <limits>\n#include <chrono>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nstruct Stopwatch {\n--snip--\n};\n\ntemplate <typename T>\nset<T> factorize(T x) {\n--snip--\n}\n\nstring factor_task(unsigned long long x) {\n--snip--\n}\n\narray<unsigned long long, 6> numbers{ ➊\n        9'699'690,\n        179'426'549,\n        1'000'000'007,\n        4'294'967'291,\n        4'294'967'296,\n        1'307'674'368'000\n};\n\nint main() {\n  chrono::nanoseconds elapsed_ns;\n  {\n    Stopwatch stopwatch{ elapsed_ns }; ➋\n    for(auto number : numbers) ➌\n      cout << factor_task(number); ➍\n  }\n  const auto elapsed_ms =\n             chrono::duration_cast<chrono::milliseconds>(elapsed_ns).count(); ➎\n  cout << elapsed_ms << \"ms: total program time\\n\"; ➏\n}\n-----------------------------------------------------------------------\n0 ms: Factoring 9699690 ( 1 2 3 5 7 11 13 17 19 )\n1274 ms: Factoring 179426549 ( 1 179426549 )\n6804 ms: Factoring 1000000007 ( 1 1000000007 )\n29035 ms: Factoring 4294967291 ( 1 4294967291 )\n0 ms: Factoring 4294967296 ( 1 2 )\n0 ms: Factoring 1307674368000 ( 1 2 3 5 7 11 13 )\n37115ms: total program time\n```", "```\n#include <set>\n#include <vector>\n#include <array>\n#include <iostream>\n#include <limits>\n#include <chrono>\n#include <future>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nstruct Stopwatch {\n--snip--\n};\n\ntemplate <typename T>\nset<T> factorize(T x) {\n--snip--\n}\n\nstring factor_task(unsigned long long x) {\n--snip--\n}\n\narray<unsigned long long, 6> numbers{\n--snip--\n};\n\nint main() {\n  chrono::nanoseconds elapsed_ns;\n  {\n    Stopwatch stopwatch{ elapsed_ns }; ➊\n    vector<future<string>> factor_tasks; ➋\n    for(auto number : numbers) ➌\n      factor_tasks.emplace_back(async(launch::async, factor_task, number)); ➍\n    for(auto& task : factor_tasks) ➎\n      cout << task.get(); ➏\n  }\n  const auto elapsed_ms =\n             chrono::duration_cast<chrono::milliseconds>(elapsed_ns).count(); ➐\n  cout << elapsed_ms << \" ms: total program time\\n\"; ➑\n}\n-----------------------------------------------------------------------\n0 ms: Factoring 9699690 ( 1 2 3 5 7 11 13 17 19 )\n1252 ms: Factoring 179426549 ( 1 179426549 )\n6816 ms: Factoring 1000000007 ( 1 1000000007 )\n28988 ms: Factoring 4294967291 ( 1 4294967291 )\n0 ms: Factoring 4294967296 ( 1 2 )\n0 ms: Factoring 1307674368000 ( 1 2 3 5 7 11 13 )\n28989 ms: total program time\n```", "```\n#include <future>\n#include <iostream>\n\nusing namespace std;\n\nvoid goat_rodeo() {\n  const size_t iterations{ 1'000'000 };\n  int tin_cans_available{}; ➊\n\n  auto eat_cans = async(launch::async, [&] { ➋\n    for(size_t i{}; i<iterations; i++)\n      tin_cans_available--; ➌\n  });\n  auto deposit_cans = async(launch::async, [&] { ➍\n    for(size_t i{}; i<iterations; i++)\n      tin_cans_available++; ➎\n  });\n  eat_cans.get(); ➏\n  deposit_cans.get(); ➐\n  cout << \"Tin cans: \" << tin_cans_available << \"\\n\"; ➑\n}\nint main() {\n  goat_rodeo();\n  goat_rodeo();\n  goat_rodeo();\n}\n-----------------------------------------------------------------------\nTin cans: -609780\nTin cans: 185380\nTin cans: 993137\n```", "```\n#include <future>\n#include <iostream>\n#include <mutex>\n\nusing namespace std;\n\nvoid goat_rodeo() {\n  const size_t iterations{ 1'000'000 };\n  int tin_cans_available{};\n  mutex tin_can_mutex; ➊\n\n  auto eat_cans = async(launch::async, [&] {\n    for(size_t i{}; i<iterations; i++) {\n      tin_can_mutex.lock(); ➋\n      tin_cans_available--;\n      tin_can_mutex.unlock(); ➌\n    }\n  });\n  auto deposit_cans = async(launch::async, [&] {\n    for(size_t i{}; i<iterations; i++) {\n      tin_can_mutex.lock(); ➍\n      tin_cans_available++;\n      tin_can_mutex.unlock(); ➎\n    }\n  });\n  eat_cans.get();\n  deposit_cans.get();\n  cout << \"Tin cans: \" << tin_cans_available << \"\\n\";\n}\n\nint main() {\n  goat_rodeo(); ➏\n  goat_rodeo(); ➐\n  goat_rodeo(); ➑\n}\n-----------------------------------------------------------------------\nTin cans: 0 ➏\nTin cans: 0 ➐\nTin cans: 0 ➑\n```", "```\n#include <future>\n#include <iostream>\n#include <mutex>\n\nusing namespace std;\n\nvoid goat_rodeo() {\n  const size_t iterations{ 1'000'000 };\n  int tin_cans_available{};\n  mutex tin_can_mutex;\n  auto eat_cans = async(launch::async, [&] {\n    for(size_t i{}; i<iterations; i++) {\n      lock_guard<mutex> guard{ tin_can_mutex }; ➊\n      tin_cans_available--;\n    }\n  });\n  auto deposit_cans = async(launch::async, [&] {\n    for(size_t i{}; i<iterations; i++) {\n      lock_guard<mutex> guard{ tin_can_mutex }; ➋\n      tin_cans_available++;\n    }\n  });\n  eat_cans.get();\n  deposit_cans.get();\n  cout << \"Tin cans: \" << tin_cans_available << \"\\n\";\n}\n\nint main() {\n  goat_rodeo();\n  goat_rodeo();\n  goat_rodeo();\n}\n-----------------------------------------------------------------------\nTin cans: 0\nTin cans: 0\nTin cans: 0\n```", "```\n#include <future>\n#include <iostream>\n#include <atomic>\n\nusing namespace std;\n\nvoid goat_rodeo() {\n  const size_t iterations{ 1'000'000 };\n  atomic_int➊ tin_cans_available{};\n  auto eat_cans = async(launch::async, [&] {\n    for(size_t i{}; i<iterations; i++)\n      tin_cans_available--; ➋\n  });\n  auto deposit_cans = async(launch::async, [&] {\n    for(size_t i{}; i<iterations; i++)\n      tin_cans_available++; ➌\n  });\n  eat_cans.get();\n  deposit_cans.get();\n  cout << \"Tin cans: \" << tin_cans_available << \"\\n\";\n}\n\nint main() {\n  goat_rodeo();\n  goat_rodeo();\n  goat_rodeo();\n}\n-----------------------------------------------------------------------\nTin cans: 0\nTin cans: 0\nTin cans: 0\n```", "```\n#include <future>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\nusing namespace std;\n\nvoid goat_rodeo() {\n  mutex m; ➊\n  condition_variable cv; ➋\n  const size_t iterations{ 1'000'000 };\n  int tin_cans_available{};\n  auto eat_cans = async(launch::async, [&] {\n    unique_lock<mutex> lock{ m }; ➌\n    cv.wait(lock, [&] { return tin_cans_available == 1'000'000; }); ➍\n    for(size_t i{}; i<iterations; i++)\n      tin_cans_available--;\n  });\n\n  auto deposit_cans = async(launch::async, [&] {\n    scoped_lock<mutex> lock{ m }; ➎\n    for(size_t i{}; i<iterations; i++)\n      tin_cans_available++;\n    cv.notify_all(); ➏\n  });\n  eat_cans.get();\n  deposit_cans.get();\n  cout << \"Tin cans: \" << tin_cans_available << \"\\n\";\n}\n\nint main() {\n  goat_rodeo();\n  goat_rodeo();\n  goat_rodeo();\n}\n-----------------------------------------------------------------------\nTin cans: 0\nTin cans: 0\nTin cans: 0\n```", "```\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <random>\n#include <chrono>\n#include <iostream>\n#include <execution>\n\nusing namespace std;\n\n// From Listing 12-25:\nstruct Stopwatch {\n--snip--\n};\n\nvector<long> make_random_vector() { ➊\n  vector<long> numbers(1'000'000'000);\n  iota(numbers.begin(), numbers.end(), 0);\n  mt19937_64 urng{ 121216 };\n  shuffle(numbers.begin(), numbers.end(), urng);\n  return numbers;\n}\n\nint main() {\n  cout << \"Constructing random vectors...\";\n  auto numbers_a = make_random_vector(); ➋\n  auto numbers_b{ numbers_a }; ➌\n  chrono::nanoseconds time_to_sort;\n  cout << \" \" << numbers_a.size() << \" elements.\\n\";\n  cout << \"Sorting with execution::seq...\";\n  {\n    Stopwatch stopwatch{ time_to_sort };\n    sort(execution::seq, numbers_a.begin(), numbers_a.end()); ➍\n  }\n  cout << \" took \" << time_to_sort.count() / 1.0E9 << \" sec.\\n\";\n\n  cout << \"Sorting with execution::par...\";\n  {\n    Stopwatch stopwatch{ time_to_sort };\n    sort(execution::par, numbers_b.begin(), numbers_b.end()); ➎\n  }\n  cout << \" took \" << time_to_sort.count() / 1.0E9 << \" sec.\\n\";\n}\n-----------------------------------------------------------------------\nConstructing random vectors... 1000000000 elements.\nSorting with execution::seq... took 150.489 sec.\nSorting with execution::par... took 17.7305 sec.\n```", "```\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <numeric>\n#include <execution>\n\nint main() {\n  std::vector<long> numbers{ 1'000'000 }, squares{ 1'000'000 }; ➊\n  std::iota(numbers.begin(), numbers.end(), 0); ➋\n  size_t n_transformed{}; ➌\n  std::transform(std::execution::par, numbers.begin(), numbers.end(), ➍\n                 squares.begin(), [&n_transformed] (const auto x) {\n                  ++n_transformed; ➎\n                  return x * x; ➏\n                });\n  std::cout << \"n_transformed: \" << n_transformed << std::endl; ➐\n}\n-----------------------------------------------------------------------\nn_transformed: 187215 ➐\n```"]