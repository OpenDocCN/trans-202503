<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label="31"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PATHS THROUGH GRAPHS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The concept of a <i>path</i> through a graph is another foundational building block we’ll use throughout the book. For example, we may be interested in determining the lowest-cost path between two nodes (<i>shortest path algorithm</i>) or whether it is even possible to reach one node from another using any path at all. Multiple subsequent chapters are devoted to computing paths with different properties.</p>&#13;
<p class="TX">The general concept of a path mirrors its real-world counterpart. Just as the paths in your favorite park provide routes for moving from one place to the next, paths in graphs provide the same mechanism. They are sequences of nodes (or edges) that let us travel through the graph. When escaping a maze or navigating a road trip, we move from node to node using the graph’s edges.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_32" aria-label="32"/>This chapter formally defines what we mean by paths through a graph and looks at different ways we can represent these structures. Whether finding paths or using them as part of an algorithm, we need to be able to represent them efficiently and unambiguously. If you’ve ever asked for directions and been met by a vague wave and a statement like “Go that way and turn right when you get to either the third or fourth intersection. You’ll probably know it when you see it,” you’ve experienced working with an incomplete path.</p>&#13;
<p class="TX">This chapter introduces three decidedly unambiguous representations. We also consider the properties of paths and a few tasks for which we can use them. We explore functions to check whether a path is valid and to compute the cost of a path in a weighted graph. Finally, we discuss how paths relate to the question of reachability in a graph.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-27"/><samp class="SANS_Futura_Std_Bold_B_11">Paths</samp></h3>&#13;
<p class="TNI1">A <i>path</i> through a graph is a sequence of nodes that are connected by edges. These are the waypoints we pass through when moving along the graph from one node to another. Just as we referred to the endpoints of individual edges as origins and destinations, we use those terms to describe the endpoints of an entire path: the first node in the path is the origin, and the last is the destination. <a href="#fig3-1">Figure 3-1</a> shows the path consisting of the nodes [0, 1, 3, 2, 4, 7]. Each adjacent pair of nodes along the list corresponds to an edge in the graph.</p>&#13;
<figure class="IMG"><img id="fig3-1" class="img70" src="../images/f03001.jpg" alt="A graph with eight nodes has a path through it indicated by bolded edges from node 0 to node one, node one to node three, node three to node two, node two to node four, and node four to node seven." width="1023" height="544"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: A valid path from node 0 to node 7</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For the purposes of this book, we use the definition of a path (as a sequence of nodes) that is common in computer science and algorithm texts. This differs from the formal graph theory definition of a path, which does not allow for repeated nodes. In graph theory, a path allowing repeated nodes is called a <i>walk</i>. Using the more general definition of a path allows us both to stay consistent with the other algorithmic texts and to mirror the real-world paths.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label="33"/>Paths have directionality, even on undirected graphs. The list of nodes presents the order in which we travel the path. The path [0, 1, 2, 7] travels <i>from</i> node 0 <i>to</i> node 1 <i>to</i> node 2 <i>to</i> node 7. This directionality will be important in understanding the results of algorithms throughout the rest of this book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-28"/><samp class="SANS_Futura_Std_Bold_B_11">Path Representation</samp></h3>&#13;
<p class="TNI1">There are a variety of ways to represent a path in code. As with all representations, we can tailor the data structures of a path to the problem or algorithm at hand. This section covers several approaches to storing paths in code, and their respective advantages and drawbacks. We also look at how each representation maps to a real-world counterpart in the context of planning a road trip.</p>&#13;
<p class="TX">Throughout the section, we also use the problem of checking path validity to illustrate how the storage representation works and how code traverses it. For the purposes of the following code, we will consider empty paths, containing no nodes or edges, as valid. You can easily adapt the code to exclude these cases depending on the problem domain.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-29"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Nodes</samp></h4>&#13;
<p class="TNI1">We typically use an ordered <i>list of nodes</i> to represent the path from a starting node to an ending node in the graph, a representation found in many computer science texts. We define the list of nodes inclusively, so <samp class="SANS_TheSansMonoCd_W5Regular_11">path[0]</samp> is the index of the starting node (path origin), while <samp class="SANS_TheSansMonoCd_W5Regular_11">path[N-1]</samp> is the index of the ending node (path destination) for a path of length <samp class="SANS_TheSansMonoCd_W5Regular_11">N</samp>. For example, we represent the path in <a href="#fig3-1">Figure 3-1</a> as [0, 1, 3, 2, 4, 7]. This representation can be used for a single path with a fixed origin and destination.</p>&#13;
<p class="TX">On our road trip, the list-of-nodes representation is equivalent to listing each city we will visit along the way. Suppose we plan to travel from Boston to Philadelphia to Pittsburgh to Columbus to Indianapolis. If we stop at a tourist center in each city, including the origin and destination, and purchase a commemorative postcard, the complete stack of cards will sum up the exciting journey.</p>&#13;
<p class="TX">We check whether such a path is valid by iterating through the list of nodes and confirming that an edge exists between each pair, as shown in the following code:</p>&#13;
<pre><code>def check_node_path_valid(g: Graph, path: list) -&gt; bool: &#13;
    num_nodes_on_path: int = len(path)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if num_nodes_on_path == 0:&#13;
        return True&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> prev_node: int = path[0]&#13;
    if prev_node &lt; 0 or prev_node &gt;= g.num_nodes:&#13;
        return False<span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label="34"/>&#13;
&#13;
    for step in range(1, num_nodes_on_path):&#13;
        next_node: int = path[step]&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if not g.is_edge(prev_node, next_node):&#13;
            return False&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> prev_node = next_node&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">check_node_path_valid()</samp> function first checks whether the path is empty and, if so, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> because we defined a path of zero nodes as valid.</p>&#13;
<p class="TX">If the path is not empty, the code retrieves the starting node of the path and checks that it is valid <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. The code then loops through the remaining nodes on the path, using the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp> to track the current step under consideration. Since the code already tested the first node, it starts at the second node in the list (<samp class="SANS_TheSansMonoCd_W5Regular_11">step=1</samp>). For each new node, it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp> function to check both that the node is valid and that there exists an edge from the previous node to this new node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If the new node is invalid or no corresponding edge exists in the graph, the function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. After checking the edge, the code proceeds to the next node in the path <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. The function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if it makes it through the entire path without finding any invalid nodes or edges.</p>&#13;
<p class="TX">In the context of our road trip example, this code corresponds to iterating over the list of cities. We check that each city is a valid city and that there is a road directly from the previous city on the list (in other words, there is an edge). Given a list such as [Boston, New York, Philadelphia, Pittsburgh], we would return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, while [Boston, New York, Madrid, Philadelphia, Pittsburgh] would clearly return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-30"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Edges</samp></h4>&#13;
<p class="TNI1">Another natural approach to representing paths is to use a <i>list of edges</i>. The origin and destination of the path correspond to the origin of the first edge and the destination of the last edge, respectively. Each edge in the list represents the transition between two nodes.</p>&#13;
<p class="TX">This formulation requires the additional constraint that the origin of every edge (except the first one) equals the destination of the previous edge. We say that a set of edges [<i>e</i><sub>0</sub>, <i>e</i><sub>1</sub>, . . . , <i>e</i><span class="ePub-I-SUB">k</span>] is a valid path only if:</p>&#13;
<p class="EQ"><i>e</i><sub>(</sub><span class="ePub-I-SUB">i</span> <sub>− 1)</sub>.<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> = <i>e</i><span class="ePub-I-SUB">i</span>.<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> for all <i>i</i> &gt; 0</p>&#13;
<p class="TX">This definition restricts paths to mirror their real-world counterparts in that the start of every segment (edge) needs to align with the ending point of the previous segment (edge). We do not allow the path to stop at one node and magically restart from a different one. If a friend gave you instructions for a road trip from Boston to Seattle in which day one is spent driving from Boston to Pittsburgh and day two is spent driving from Cincinnati to St. Louis, you would soon realize there was a problem: somehow the proposed route skips the majority of Ohio. The path shown in <a href="#fig3-2">Figure 3-2</a>, like our friend’s bad directions, is not valid.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label="35"/>&#13;
<figure class="IMG"><img id="fig3-2" class="img70" src="../images/f03002.jpg" alt="A graph with eight nodes has an invalid path indicated by bolded edges from node zero to node five, node three to node four, and node four to node seven." width="1023" height="544"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: An invalid path through the graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When writing paths as a list of edges, we denote each edge as the tuple (<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>) to mirror the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> objects. For example, the path in <a href="#fig3-1">Figure 3-1</a> corresponds to [(0, 1), (1, 3), (3, 2), (2, 4), (4, 7)].</p>&#13;
<p class="TX">We check whether such a path is valid by iterating through the list of edges and confirming both that the destination of the last edge matches the origin of the current edge and that the edge exists in the graph, as shown in the following code:</p>&#13;
<pre><code>def check_edge_path_valid(g: Graph, path: list) -&gt; bool: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if len(path) == 0:&#13;
        return True&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> prev_node: int = path[0].from_node&#13;
    if prev_node &lt; 0 or prev_node &gt;= g.num_nodes:&#13;
        return False&#13;
&#13;
    for edge in path:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if edge.from_node != prev_node:&#13;
            return False&#13;
&#13;
        next_node: int = edge.to_node&#13;
        if not g.is_edge(prev_node, next_node):&#13;
            return False&#13;
&#13;
        prev_node = next_node&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">check_edge_path_valid()</samp> function first checks whether the path is empty and, if so, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> because we previously defined a path of zero edges as valid. Otherwise, the code retrieves the starting node of the path as the origin of the first edge <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. It checks that this node has a valid index and, if not, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>&#13;
<p class="TX">The code then loops through all the edges on the path. For each edge, it first checks that the origin of the edge matches the last edge’s destination <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. It then extracts the index of the new destination node (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_node</samp>) and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp> function to check both that the node is valid and that this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label="36"/>edge exists. If the new node is invalid, or no corresponding edge exists in the graph, the function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. After checking the edge, the code proceeds to the next edge along the path. The function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if it makes it through the entire path without finding any invalid nodes or edges.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-31"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Previous Nodes</samp></h4>&#13;
<p class="TNI1">For many of the algorithms in this book, we use a more specialized representation of paths as lists mapping nodes to the previous node along the path. This method lends itself well to how many of the algorithms in this book process the data by traveling from one node to the next. It has both significant advantages and significant disadvantages.</p>&#13;
<p class="TX">Consider the path [0, 1, 3, 2, 4, 7] shown in <a href="#fig3-3">Figure 3-3</a>. For each node along the path, we can indicate which node precedes it, as shown in the list <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">last[4]=2</samp> indicates that we get <i>to</i> node 4 <i>from</i> node 2. We use the special value −1 to indicate that a node does not have a preceding node. This can be due to the node either being the first node on the path (the origin of the path) or not being part of the path at all.</p>&#13;
<figure class="IMG"><img id="fig3-3" class="img70" src="../images/f03003.jpg" alt="A graph with eight nodes has a path through it indicated by bolded arrows from node 0 to node one, node one to node three, node three to node two, node two to node four, and node four to node seven. Below the graph is an array labeled last and containing the values −1, 0, 3, 1, 2, −1, −1, 4." width="1023" height="713"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: A path through the graph and its representation as an array of previous nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The major disadvantage of this representation is that it limits the types of paths we can represent. Each node can have, at most, one preceding node. We cannot represent many paths that revisit nodes, such as [0, 1, 3, 0, 5, 3, 4, 7]. If we were to try to represent this path as an array of previous nodes, we would run into a problem with node 3’s <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> entry. Node 3 is preceded first by node 1 and then, later, by node 5. While it is possible to define more complex lists of lists that handle these cases, we use the single list of indices because it is well suited to the algorithms in this book.</p>&#13;
<p class="TX">The major advantage of this representation is that it’s easy to update paths inside the algorithms because we need to change only a single index <span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label="37"/>value. We will use this behavior again and again throughout later chapters to simplify the code. Another advantage is that this representation can capture multiple, branching paths. Unlike the previous two representations, which use a single fixed origin and destination nodes, the previous-node representation requires only a single fixed origin. The list can be used to extract a path from <i>any</i> destination node back to the origin.</p>&#13;
<p class="TX">In the road trip analogy, the list-of-previous-nodes representation is equivalent to listing each city you <i>could</i> visit and the city from which you would travel to get there. If your plans change and you decide to visit Pittsburgh, you can follow the chain of previous nodes through Philadelphia and back to Boston. The list of previous visits provides information for all possible stops on trips out of the origin city.</p>&#13;
<p class="TX">Another useful analogy for this representation is the set of chalk marks that an adventurer makes while exploring a labyrinth, such as shown in <a href="#fig3-4">Figure 3-4</a>.</p>&#13;
<figure class="IMG"><img id="fig3-4" class="img40" src="../images/f03004.jpg" alt="A maze constructed on a 4 × 4 grid. The start is at the top left corner and the exit is at the bottom left corner. Each grid cell contains an arrow pointing in the direction of the start." width="489" height="344"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Chalk marks in a labyrinth indicating the direction you came from</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Determined not to get lost, the adventurer draws a chalk arrow at every intersection, indicating the passage they used to get to the current room. These markings point backward along the path traveled. Such chalk marks have a distinct advantage over breadcrumbs in their overall information content, allowing the adventurer to find their way back to the start from any room in the dungeon. In particular, if they know the location of the exit, they can rebuild the path from the exit to the start.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Translating a Previous-Node List into a List of Nodes</samp></h5>&#13;
<p class="TNI1">To translate the previous-nodes representation into a list of nodes, we walk the pointers in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list backward from a given destination, as shown in the following code:</p>&#13;
<pre><code>def make_node_path_from_last(last: list, dest: int) -&gt; list: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> reverse_path: list = []&#13;
    current: int = dest&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while current != -1:&#13;
        reverse_path.append(current)&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> current = last[current]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label="38"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> path: list = list(reversed(reverse_path))&#13;
    return path&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_node_path_from_last()</samp> function begins by compiling the path list in reverse and storing it in <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>, before reversing the order at the end. Initially, the code sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp> list as empty and starts at the end by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> node to the destination <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to traverse the path until it hits <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, which indicates the lack of a previous node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. At each step in the loop, the code appends the current node to <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp> and moves to the preceding node as defined by <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. Finally, the code creates a reversed copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp> (the path in the correct order) and returns that list <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Let’s consider what happens when we apply the code to the graph in <a href="#fig3-5">Figure 3-5(a)</a> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array indicating paths starting from node 0:</p>&#13;
<p class="EQ">[−1, 0, 1, 2, 2, 0, 5, 0, 5, 8]</p>&#13;
<p class="TX"><a href="#fig3-5">Figure 3-5(b)</a> shows the backward pointers on the graph. As we can see, the arrows point backward to the origin node. <a href="#fig3-5">Figure 3-5(c)</a> reverses each point to demonstrate how we can reconstruct the forward path.</p>&#13;
<figure class="IMG"><img id="fig3-5" class="img100" src="../images/f03005.jpg" alt="(A) shows an undirected graph with 10 nodes. (B) shows the same graph with arrows linking each node back a node closer to 0. (C) shows the same graph as (B) with the arrows reversed." width="1691" height="380"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: An example graph (a), the last pointers created by a breadth-first search (b), and the corresponding forward paths through the graph (c)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If we use node 9 as our destination (<samp class="SANS_TheSansMonoCd_W5Regular_11">dest=9</samp>), we build up the reverse path (represented as a list of nodes) as follows:</p>&#13;
<p class="ListPlain">[9]</p>&#13;
<p class="ListPlain">[9, 8]</p>&#13;
<p class="ListPlain">[9, 8, 5]</p>&#13;
<p class="ListPlain">[9, 8, 5, 0]</p>&#13;
<p class="BodyContinued">The returned final path in this case is [0, 5, 8, 9].</p>&#13;
<p class="TX">As noted earlier, the previous-node representation allows us to represent paths from a single origin to all destinations in the graph. Because of this, it is often not possible to convert from a list-of-nodes or list-of-edges representation into a full list-of-previous-nodes representation. Returning to <a href="#fig3-5">Figure 3-5</a>, a list-of-nodes path from node 0 to node 3 would be [0, 1, 2, 3]. While this tells us everything we need to know about the path from node 0 <span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label="39"/>to node 3, it does not tell us about paths from node 0 to any nodes that are <i>not</i> in the list. We could not use it to derive a path from node 0 to node 5.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Checking the Validity of a Previous-Node List</samp></h5>&#13;
<p class="TNI1">To test the validity of this type of path, we iterate over all entries in the list and check that either the previous node is −1, or the edge exists:</p>&#13;
<pre><code>def check_last_path_valid(g: Graph, last: list) -&gt; bool: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if len(last) != g.num_nodes:&#13;
        return False&#13;
&#13;
    for to_node, from_node in enumerate(last):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if from_node != -1 and not g.is_edge(from_node, to_node):&#13;
            return False&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">check_last_path_valid()</samp> code first checks that the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list has the correct number of entries <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Even if all the entries are −1, there needs to be an entry for every node.</p>&#13;
<p class="TX">The code then iterates through the list using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate()</samp> function, where <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> is the index of <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> currently being examined and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> is the corresponding value. The code checks that either <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> is –1, indicating that there is no previous node on the path, or that the combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> corresponds to a valid edge <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If neither case holds, the code immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If every entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> is valid, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
<p class="TX">In the context of our road trip example, this function iterates over each city in our list and asks, “Can we get there directly from the listed previous city?” We would approve an entry for Pittsburgh that has a previous node of Philadelphia or Erie. However, we would soundly reject an entry for Boston with a previous node of Santa Fe.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-32"/><samp class="SANS_Futura_Std_Bold_B_11">Calculating Path Cost</samp></h3>&#13;
<p class="TNI1">For many use cases, we may be interested not only in which edges to use to compose the path but also an overall measure of either the benefits or cost of the path as a whole. As we saw in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we can use edge weights to capture the cost of traversing between two nodes, such as using them to model the distance between cities on our road trip. When planning a flight itinerary from Boston to Seattle, we might skip the edge from Boston to Miami because of its nearly 1,500-mile cost.</p>&#13;
<p class="TX">We define the <i>cost of a path</i> in a weighted graph as the sum of the edge weights along that path. Formally, we say that for a path [<i>e</i><sub>0</sub>, <i>e</i><sub>1</sub>, . . . , <i>e</i><span class="ePub-I-SUB">k</span>]:</p>&#13;
<p class="EQ"><i>PathCost</i>([<i>e</i><sub>0</sub>, <i>e</i><sub>1</sub>, . . . , <i>e</i><span class="ePub-I-SUB">k</span>]) = <i>∑</i><span class="ePub-I-SUB">i =</span> <sub>1</sub> <span class="ePub-I-SUB">to k</span> <i>e</i><span class="ePub-I-SUB">i</span>.<samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp></p>&#13;
<p class="TX">The cost of the path [0, 3, 4, 2] in <a href="#fig3-6">Figure 3-6</a> would be 1.0 + 3.0 + 5.0 = 9.0.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label="40"/>&#13;
<figure class="IMG"><img id="fig3-6" class="img50" src="../images/f03006.jpg" alt="A graph with six nodes and weighted, directed edges. The arrow from node 0 to node 3 is labeled 1.0. The arrow from node 3 to node 4 is labeled 3.0. The arrow from node 4 to node 2 is labeled 5.0." width="846" height="499"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: A weighted, directed graph with six nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For unweighted graphs, we often use a unit value of 1.0 for each edge and thus compute the cost as the number of edges used.</p>&#13;
<p class="TX">If we have a list of edges representing our path, we compute the cost of the path by iterating over those edges, as shown in <a href="#list3-1">Listing 3-1</a>.</p>&#13;
<span id="list3-1"/>&#13;
<pre><code>def compute_path_cost_from_edges(path: list) -&gt; float: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if len(path) == 0:&#13;
        return 0.0&#13;
&#13;
    cost: float = 0.0&#13;
    prev_node: int = path[0].from_node&#13;
    for edge in path:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if edge.from_node != prev_node:&#13;
            cost = math.inf&#13;
        else:&#13;
            cost = cost + edge.weight&#13;
        prev_node = edge.to_node&#13;
&#13;
    return cost&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: A function to compute the total path cost</samp></p>&#13;
<p class="TX">The code starts by checking that the path has at least one edge and, if not, returning a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It also initializes variables to track the total cost (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>) and the previous node seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp> variable is used to assess the validity of the path.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_path_cost_from_edges()</samp> function computes the cost of a path iterating through each edge in the list. It checks that the origin of the current edge matches the last node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If the nodes do not match, the path is invalid. For example, an edge list of [(0, 1), (2, 3), (3, 4)] would be invalid because you cannot jump from node 1 to node 2 without an edge between the two nodes. If the transition is valid, the edge’s weight is added to the cost. If the transition is invalid, we use an infinite weight. Depending on the implementation, the programmer might want to raise an exception, exit the program, or use some other method to indicate an error. The code updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp> variable to track the new current location.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label="41"/>The code continues through the list, checking each edge and summing their weights. When it has finished each edge in the list, it returns the total cost with <samp class="SANS_TheSansMonoCd_W5Regular_11">return cost</samp>.</p>&#13;
<p class="TX">Unlike other functions in this chapter, we intentionally do not pass in a graph to this implementation to demonstrate how we can operate on a pure list of edges. The downside to this simplicity is that the function cannot validate the path against the graph itself. We could extend the function to perform an additional check by passing in the graph and using it to validate both the node indices and the edges’ existence. The code for these additional checks follows the approach shown in other functions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h-33"/><samp class="SANS_Futura_Std_Bold_B_11">Reachability</samp></h3>&#13;
<p class="TNI1">We can use the formulations of paths to formalize another important question on graphs: “Is node <i>v</i> reachable from node <i>u</i>?” This question is vital to a range of real-world problems. In a transportation network, it translates into the question, “Can we get to city <i>v</i> from city <i>u</i>?” In a social network, it translates into the question, “Can a rumor spread from person <i>u</i> to person <i>v</i>?” And in a dungeon labyrinth, it translates into the vital question, “Can I get from here to the exit?”</p>&#13;
<p class="TX">We say that node <i>v</i> is <i>reachable</i> from node <i>u</i> if there exists a path that starts at node <i>u</i> and ends at node <i>v</i>. Given a candidate path, we can use any one of our validity checkers from earlier in this chapter to test whether it is valid.</p>&#13;
<p class="TX">Imagine you are trapped in a castle dungeon represented by the graph in <a href="#fig3-7">Figure 3-7</a>. The edges indicate which adjacent rooms have an unlocked door between them. To escape from the evil wizard, you need to navigate to a room with a staircase to the upper floor. Here, the reachability question is vital. If you start in room 0 and need to navigate to node 15, you are out of luck. Node 15 is not reachable from node 0.</p>&#13;
<figure class="IMG"><img id="fig3-7" class="img50" src="../images/f03007.jpg" alt="A graph with 16 nodes is arranged as a 4 × 4 square. The nodes 10, 11, 14, and 15 are connected to each other, but not to the other nodes." width="648" height="648"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: A graph representing connectivity among rooms in a castle dungeon</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label="42"/>In an undirected graph, we can divide the nodes into disjoint sets called <i>connected components</i> such that any node in a connected component is reachable from any other node. Given a subset of nodes <i>V</i><span class="symbol">′ ⊆</span> <i>V</i>, we say that a connected component is a maximal set of nodes such that:</p>&#13;
<p class="EQ"><i>reachable</i>(<i>u</i>, <i>v</i>) for all <i>u</i> <span class="symbol">∈</span> <i>V</i><span class="symbol">′</span> and <i>v</i> <span class="symbol">∈</span> <i>V</i><span class="symbol">′</span></p>&#13;
<p class="TX">In the context of our dungeon example from <a href="#fig3-7">Figure 3-7</a>, the map consists of the two connected components {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13} and {10, 11, 14, 15}. We are okay if the stairs out of the dungeon are in the same connected component as our current room. Otherwise, we are trapped.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h-34"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">We will use the concept of paths throughout the book to solve problems spanning from path planning to optimizing flow through a capacity-limited network. Paths will be a fundamental unit of data used throughout many of the algorithms and will be one of the most common results computed by the functions. Concepts like reachability and path cost will be foundational in numerous algorithms, from finding strongly connected components in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> to performing matching on bipartite graphs in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>.</p>&#13;
<p class="TX">In addition to their computational usefulness, paths can help us visualize the operation of algorithms in a real-world context. Instead of an abstract “sequence of edges,” it helps to visualize paths as their real-world counterparts. This chapter repeatedly made use of the road trip analogy to map edges to roads across the country. We can similarly imagine physically walking paths through many of the algorithms discussed in this book.</p>&#13;
<p class="TX">The next chapter builds upon the concept of paths, considering multiple algorithms that explore graphs and return the paths taken. These paths provide important information about both the functionality of the search and the ability to navigate through the graph.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>