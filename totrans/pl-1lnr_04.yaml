- en: Chapter 5. Working With Arrays and Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at various one-liners for creating strings and arrays,
    for doing things like generating passwords, creating strings of certain length,
    finding the numeric values of characters, and creating arrays of numbers. You’ll
    also learn about the range operator `..`, the `x` operator, the `$`, special variable,
    and the `@ARGV` array.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Generate and print the alphabet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner prints all letters from `a` to `z` in the English alphabet as
    `abcdefghijklmnopqrstuvwxyz`. The letters are generated by the range operator
    `..`, which, when used on strings in the list context (provided here by `print`),
    applies the magical auto-increment algorithm that advances the string to the next
    character. Therefore, in this one-liner, the auto-increment algorithm on the range
    `a..z` produces all letters from `a` to `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I really golfed this one-liner. If I had used `strict`, it wouldn’t have worked
    because of the bare words `a` and `z`. This version is more correct semantically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the range operator `..` produces a list of values. If you wish,
    you could print the values with comma separations by setting the `$`, special
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$`, is the field separator. It’s output by `print` between each field.
    Semantically, though, using `join` to separate the list of letters with a comma
    is more appealing because it works even when not using `print` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the list `a..z` is joined by a comma before printing, and the output is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 5.2 Generate and print all the strings from “a” to “zz”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner uses the range operator `..` again, but this time, it doesn’t
    stop at `z` as in the previous one-liner. Instead, it advances `z` by one character,
    producing `aa`. Then it keeps going, producing `ab`, `ac`, and so on, until it
    hits `az`. At that point, it advances the string to `ba`, continues with `bb`,
    `bc`, and so on, until eventually it reaches `zz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also generate all strings from `aa` to `zz` by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output from this one-liner is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 5.3 Create a hex lookup table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this one-liner, the `@hex` array is filled with the numbers 0, 1, 2, 3, 4,
    5, 6, 7, 8, 9 and the letters a, b, c, d, e, f. You could use this array to convert
    a number (in variable `$num`) from decimal to hex with the following base conversion
    formula. (This isn’t a one-liner; I include it to illustrate how to use the `@hex`
    lookup array.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But surely, converting a number to hex is much easier if I use `printf` (or
    `sprintf`) with the `%x` format specifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert the number back from hex to dec, use the `hex` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `hex` operator takes a hex string (beginning with or without `0x`) and converts
    it to decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Generate a random eight-character password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `map` operator executes the code `("a".."z")[rand 26]` eight times
    because it iterates over the range `1..8`. In each iteration, the code chooses
    a random letter from the alphabet. When `map` has finished iterating, it returns
    the generated list of characters, and `print` prints it, thereby concatenating
    all the characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To also include numbers in the password, add `0..9` to the list of characters
    to choose from and change `26` to `36` because you now have `36` possible characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you need a longer password, change `1..8` to `1..20` to generate one that’s
    20 characters long.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Create a string of specific length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner creates a string of 50 letters `a` and prints it. Operator `x`
    is the repetition operator. Here, the letter `a` is repeated 50 times by `x50`.
    This one-liner is handy when you need to generate a specific amount of data for
    debugging or other tasks. For example, if you need 1KB of data, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I removed the `-l` argument because it would have output an additional newline
    symbol, producing 1025 bytes of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the repetition operator in the list context, with a list as its
    first operand, you create a list with the given elements repeated, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner creates a list of 20 repetitions of `(1, 2)` that looks like
    `(1, 2, 1, 2, 1, 2, ...)`. (The parentheses to the left of `x` make a list.)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Create an array from a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `@months` is filled with values from the string containing month names.
    Because all month names are separated by a space, the `split` operator splits
    them and puts them in `@months`. As a result, `$months[0]` contains `Jan`, `$months[1]`
    contains `Feb`, … , and `$months[11]` contains `Dec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do the same thing with the `qw/.../` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `qw/.../` operator takes a space-separated string and creates an array in
    which each word is an array element.
  prefs: []
  type: TYPE_NORMAL
- en: Although not a one-liner per se, this is a useful, idiomatic way to create arrays
    that can come in handy when writing one-liners.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Create a string from the command-line arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner uses the `@ARGV` array, which contains all the arguments that
    have been passed to Perl. In this one-liner, the values passed to Perl are `val1`,
    `val2`, and `val3`, so `@ARGV` contains the strings `val1`, `val2`, and `val3`.
    This one-liner prints the string `(val1,val2,val3)` and would be useful, for example,
    to generate a SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with the INSERT query in SQL, you know its most basic form
    looks like `INSERT INTO table VALUES (val1, val2, val3, ...)`. As you can see,
    this one-liner generates the `VALUES` part of the SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily modify this one-liner to print the whole INSERT query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the one-liner prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 5.8 Find the numeric values for characters in a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner takes the string `"hello world"` and splits it into a list of
    characters with `split //, "hello world"`. It then maps the `ord` operator onto
    each of the characters, which returns each character’s numeric value. Finally,
    all of the numeric values are joined together by a comma and printed. Here’s the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also do this with the `unpack` operator by specifying `C*` as the
    unpacking template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `C` in the template means “unsigned character” and `*` means “all characters.”
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the hexadecimal values of the characters, you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `map` operator executes `sprintf "0x%x", ord $_` for every character,
    which returns the character’s hexadecimal value prepended with `''0x''`. Here’s
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to get the octal values of characters, you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, to generate proper octal values that begin with `0`, you can specify
    the `%#o` format to the `sprintf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 5.9 Convert a list of numeric ASCII values into a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as I unpacked a string into a list of values with the `C*` template in
    the previous one-liner, I can pack them into a string by using the same template.
    Here’s the output from the one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to convert a list of numeric ASCII values into a string is to use
    the `chr` operator, which takes the code point value and returns the corresponding
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, you simply `map` the `chr` operator onto each numeric value in the `@ascii`
    array, which produces a list of characters that correspond to the numeric values.
    Next, you `join` the characters together and produce the `$str`, and then you
    print it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also golf this one-liner and come up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `@ARGV` array and pass the ASCII values as arguments to
    the one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 5.10 Generate an array with odd numbers from 1 to 100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner generates an array of odd numbers from 1 to 99 (that is, 1, 3,
    5, 7, 9, 11, … , 99). It uses `grep` to evaluate the code `$_ % 2 == 1` for each
    element in the list `1..100` and returns only those elements for which the given
    code evaluates to true. In this case, the code tests to see if the remainder when
    dividing by 2 is 1\. If it is, the number is odd, and it’s put in the `@odd` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also write this using the fact that odd numbers have the least significant
    bit set and test for the least significant bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The expression `$_ & 1` isolates the least significant bit, and `grep` selects
    only those numbers with the least significant bit set—that is, all odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Generate an array with even numbers from 1 to 100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is almost the same as the one in 5.10, except that `grep` tests
    for the condition “is the number even (remainder after dividing by two is 0)?”
  prefs: []
  type: TYPE_NORMAL
- en: 5.12 Find the length of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `length` subroutine finds the length of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 5.13 Find the number of elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating an array in the scalar context returns its number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also do this by adding `1` to the last index of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$#array` returns the last index in `@array`. Because that number is one
    less than the number of elements in the array, you add `1` to the result to find
    the total number of elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you want to find out how many text files are in the current
    directory. You can use `@ARGV` and pass the `*.txt` wildcard to Perl. The shell
    expands the `*.txt` wildcard to a list of filenames that match `*.txt`, and Perl
    puts them into the `@ARGV` array and prints the array in the scalar context. The
    output will be the number of text files in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If your shell doesn’t support filename expansion (also known as *globbing*)
    or if you’re on Windows, you can use the diamond operator with the `*.txt` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the diamond operator does the globbing and returns a list of filenames
    that match `*.txt`. Evaluating this list in the scalar context returns the number
    of files that matched.
  prefs: []
  type: TYPE_NORMAL
