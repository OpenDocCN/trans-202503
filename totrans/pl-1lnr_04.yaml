- en: Chapter 5. Working With Arrays and Strings
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章：处理数组和字符串
- en: In this chapter, we’ll look at various one-liners for creating strings and arrays,
    for doing things like generating passwords, creating strings of certain length,
    finding the numeric values of characters, and creating arrays of numbers. You’ll
    also learn about the range operator `..`, the `x` operator, the `$`, special variable,
    and the `@ARGV` array.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些用于创建字符串和数组的单行命令，用于做一些事情，比如生成密码、创建特定长度的字符串、查找字符的数值以及创建数字数组。你还将学习范围操作符`..`、`x`操作符、`$`特殊变量以及`@ARGV`数组。
- en: 5.1 Generate and print the alphabet
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 生成并打印字母表
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This one-liner prints all letters from `a` to `z` in the English alphabet as
    `abcdefghijklmnopqrstuvwxyz`. The letters are generated by the range operator
    `..`, which, when used on strings in the list context (provided here by `print`),
    applies the magical auto-increment algorithm that advances the string to the next
    character. Therefore, in this one-liner, the auto-increment algorithm on the range
    `a..z` produces all letters from `a` to `z`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令打印了从`a`到`z`的所有字母，结果为`abcdefghijklmnopqrstuvwxyz`。字母是通过范围操作符`..`生成的，当它在列表上下文中用于字符串时（这里由`print`提供），它应用了神奇的自动增量算法，将字符串推进到下一个字符。因此，在这个单行命令中，范围`a..z`的自动增量算法产生了从`a`到`z`的所有字母。
- en: 'I really golfed this one-liner. If I had used `strict`, it wouldn’t have worked
    because of the bare words `a` and `z`. This version is more correct semantically:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实把这个单行命令做得很简洁。如果我使用了`strict`，它就无法工作，因为裸词`a`和`z`。这个版本在语义上更正确：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember that the range operator `..` produces a list of values. If you wish,
    you could print the values with comma separations by setting the `$`, special
    variable:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，范围操作符`..`会生成一个值的列表。如果你愿意，你可以通过设置`$`特殊变量来打印这些值，并用逗号分隔：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `$`, is the field separator. It’s output by `print` between each field.
    Semantically, though, using `join` to separate the list of letters with a comma
    is more appealing because it works even when not using `print` directly:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`是字段分隔符。它在每个字段之间由`print`输出。然而，从语义上讲，使用`join`将字母列表用逗号分隔会更具吸引力，因为即使不直接使用`print`，它也能正常工作：'
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the list `a..z` is joined by a comma before printing, and the output is
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`a..z`的列表在打印之前用逗号连接，输出为：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 5.2 Generate and print all the strings from “a” to “zz”
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 生成并打印从“a”到“zz”的所有字符串
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This one-liner uses the range operator `..` again, but this time, it doesn’t
    stop at `z` as in the previous one-liner. Instead, it advances `z` by one character,
    producing `aa`. Then it keeps going, producing `ab`, `ac`, and so on, until it
    hits `az`. At that point, it advances the string to `ba`, continues with `bb`,
    `bc`, and so on, until eventually it reaches `zz`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令再次使用了范围操作符`..`，但这一次，它不像之前的单行命令那样停在`z`。相反，它将`z`前进一个字符，产生`aa`。然后继续进行，产生`ab`、`ac`，依此类推，直到到达`az`。此时，它将字符串推进到`ba`，继续生成`bb`、`bc`，依此类推，直到最终达到`zz`。
- en: 'You could also generate all strings from `aa` to `zz` by doing this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过这样做来生成所有从`aa`到`zz`的字符串：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output from this one-liner is
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令的输出是：
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 5.3 Create a hex lookup table
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 创建十六进制查找表
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this one-liner, the `@hex` array is filled with the numbers 0, 1, 2, 3, 4,
    5, 6, 7, 8, 9 and the letters a, b, c, d, e, f. You could use this array to convert
    a number (in variable `$num`) from decimal to hex with the following base conversion
    formula. (This isn’t a one-liner; I include it to illustrate how to use the `@hex`
    lookup array.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单行命令中，`@hex`数组包含了数字0、1、2、3、4、5、6、7、8、9以及字母a、b、c、d、e、f。你可以使用这个数组将一个数字（在变量`$num`中）从十进制转换为十六进制，使用以下的进制转换公式。（这不是一个单行命令，我加入它是为了说明如何使用`@hex`查找数组。）
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But surely, converting a number to hex is much easier if I use `printf` (or
    `sprintf`) with the `%x` format specifier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，如果我使用`printf`（或`sprintf`）并使用`%x`格式说明符，转换数字为十六进制会更容易。
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To convert the number back from hex to dec, use the `hex` operator:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数字从十六进制转换回十进制，使用`hex`操作符：
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `hex` operator takes a hex string (beginning with or without `0x`) and converts
    it to decimal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`hex`操作符接受一个十六进制字符串（可以以`0x`开头或不以`0x`开头），并将其转换为十进制。'
- en: 5.4 Generate a random eight-character password
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 生成一个随机的八字符密码
- en: '[PRE12]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `map` operator executes the code `("a".."z")[rand 26]` eight times
    because it iterates over the range `1..8`. In each iteration, the code chooses
    a random letter from the alphabet. When `map` has finished iterating, it returns
    the generated list of characters, and `print` prints it, thereby concatenating
    all the characters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`map` 操作符执行代码 `("a".."z")[rand 26]` 八次，因为它会遍历范围 `1..8`。在每次迭代中，代码会从字母表中随机选择一个字母。当
    `map` 完成迭代后，它会返回生成的字符列表，`print` 会打印它，从而将所有字符连接起来。
- en: 'To also include numbers in the password, add `0..9` to the list of characters
    to choose from and change `26` to `36` because you now have `36` possible characters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在密码中包含数字，可以将 `0..9` 添加到字符列表中，并将 `26` 改为 `36`，因为现在有 `36` 种可能的字符：
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you need a longer password, change `1..8` to `1..20` to generate one that’s
    20 characters long.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更长的密码，可以将 `1..8` 改为 `1..20`，生成一个 20 个字符长的密码。
- en: 5.5 Create a string of specific length
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 创建特定长度的字符串
- en: '[PRE14]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This one-liner creates a string of 50 letters `a` and prints it. Operator `x`
    is the repetition operator. Here, the letter `a` is repeated 50 times by `x50`.
    This one-liner is handy when you need to generate a specific amount of data for
    debugging or other tasks. For example, if you need 1KB of data, just do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码创建了一个由 50 个字母 `a` 组成的字符串并打印出来。操作符 `x` 是重复操作符。在这里，字母 `a` 被 `x50` 重复 50
    次。这个单行代码在你需要为调试或其他任务生成特定数据时非常有用。例如，如果你需要 1KB 的数据，只需执行以下操作：
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I removed the `-l` argument because it would have output an additional newline
    symbol, producing 1025 bytes of data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我去掉了 `-l` 参数，因为它会输出一个额外的换行符，导致数据量为 1025 字节。
- en: 'When you use the repetition operator in the list context, with a list as its
    first operand, you create a list with the given elements repeated, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在列表上下文中使用重复操作符，并且将一个列表作为第一个操作数时，你会创建一个包含给定元素重复的列表，像这样：
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This one-liner creates a list of 20 repetitions of `(1, 2)` that looks like
    `(1, 2, 1, 2, 1, 2, ...)`. (The parentheses to the left of `x` make a list.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码创建了一个包含 20 次 `(1, 2)` 重复的列表，形如 `(1, 2, 1, 2, 1, 2, ...)`。（`x` 左侧的括号表示一个列表。）
- en: 5.6 Create an array from a string
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 从字符串创建数组
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `@months` is filled with values from the string containing month names.
    Because all month names are separated by a space, the `split` operator splits
    them and puts them in `@months`. As a result, `$months[0]` contains `Jan`, `$months[1]`
    contains `Feb`, … , and `$months[11]` contains `Dec`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`@months` 被填充了包含月份名称的字符串中的值。由于所有月份名称由空格分隔，`split` 操作符将它们分割并放入 `@months` 中。因此，`$months[0]`
    包含 `Jan`，`$months[1]` 包含 `Feb`，……，`$months[11]` 包含 `Dec`。
- en: 'You could do the same thing with the `qw/.../` operator:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `qw/.../` 操作符做同样的事情：
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `qw/.../` operator takes a space-separated string and creates an array in
    which each word is an array element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`qw/.../` 操作符接受一个由空格分隔的字符串，并创建一个数组，其中每个单词都是数组的一个元素。'
- en: Although not a one-liner per se, this is a useful, idiomatic way to create arrays
    that can come in handy when writing one-liners.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本身不是一个单行代码，但这是一个有用的、符合习惯的方式来创建数组，写单行代码时会很有帮助。
- en: 5.7 Create a string from the command-line arguments
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 从命令行参数创建字符串
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This one-liner uses the `@ARGV` array, which contains all the arguments that
    have been passed to Perl. In this one-liner, the values passed to Perl are `val1`,
    `val2`, and `val3`, so `@ARGV` contains the strings `val1`, `val2`, and `val3`.
    This one-liner prints the string `(val1,val2,val3)` and would be useful, for example,
    to generate a SQL query.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码使用了 `@ARGV` 数组，包含了所有传递给 Perl 的参数。在这个单行代码中，传递给 Perl 的值是 `val1`、`val2` 和
    `val3`，所以 `@ARGV` 包含了字符串 `val1`、`val2` 和 `val3`。这个单行代码打印出字符串 `(val1,val2,val3)`，例如，可以用来生成
    SQL 查询。
- en: If you’re familiar with the INSERT query in SQL, you know its most basic form
    looks like `INSERT INTO table VALUES (val1, val2, val3, ...)`. As you can see,
    this one-liner generates the `VALUES` part of the SQL query.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 SQL 中的 INSERT 查询，你会知道其最基本的形式是 `INSERT INTO table VALUES (val1, val2, val3,
    ...)`。如你所见，这个单行代码生成了 SQL 查询中的 `VALUES` 部分。
- en: 'You can easily modify this one-liner to print the whole INSERT query:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松修改这个单行代码来打印整个 INSERT 查询：
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s what the one-liner prints:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个单行代码的输出：
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 5.8 Find the numeric values for characters in a string
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 查找字符串中字符的数值
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This one-liner takes the string `"hello world"` and splits it into a list of
    characters with `split //, "hello world"`. It then maps the `ord` operator onto
    each of the characters, which returns each character’s numeric value. Finally,
    all of the numeric values are joined together by a comma and printed. Here’s the
    output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令将字符串 `"hello world"` 拆分成一个字符列表，使用 `split //, "hello world"`。然后它将 `ord`
    操作符映射到每个字符上，返回每个字符的数字值。最后，所有的数字值通过逗号连接并打印出来。输出如下：
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You could also do this with the `unpack` operator by specifying `C*` as the
    unpacking template:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `unpack` 操作符，通过指定 `C*` 作为解包模板来实现：
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `C` in the template means “unsigned character” and `*` means “all characters.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的 `C` 代表“无符号字符”，而 `*` 代表“所有字符”。
- en: 'To find the hexadecimal values of the characters, you could do this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找字符的十六进制值，你可以这样做：
- en: '[PRE25]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, the `map` operator executes `sprintf "0x%x", ord $_` for every character,
    which returns the character’s hexadecimal value prepended with `''0x''`. Here’s
    the output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`map` 操作符对每个字符执行 `sprintf "0x%x", ord $_`，返回字符的十六进制值，并加上前缀 `'0x'`。输出如下：
- en: '[PRE26]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, to get the octal values of characters, you do this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要获取字符的八进制值，你可以这样做：
- en: '[PRE27]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And finally, to generate proper octal values that begin with `0`, you can specify
    the `%#o` format to the `sprintf` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了生成以 `0` 开头的正确八进制值，你可以在 `sprintf` 函数中指定 `%#o` 格式：
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And here’s the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '[PRE30]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 5.9 Convert a list of numeric ASCII values into a string
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9 将一系列数字 ASCII 值转换为字符串
- en: '[PRE31]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just as I unpacked a string into a list of values with the `C*` template in
    the previous one-liner, I can pack them into a string by using the same template.
    Here’s the output from the one-liner:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在前面的单行命令中使用 `C*` 模板将字符串解包成一个值的列表一样，我也可以使用相同的模板将它们打包成一个字符串。单行命令的输出如下：
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another way to convert a list of numeric ASCII values into a string is to use
    the `chr` operator, which takes the code point value and returns the corresponding
    character:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列数字 ASCII 值转换为字符串的另一种方法是使用 `chr` 操作符，它接受代码点值并返回对应的字符：
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, you simply `map` the `chr` operator onto each numeric value in the `@ascii`
    array, which produces a list of characters that correspond to the numeric values.
    Next, you `join` the characters together and produce the `$str`, and then you
    print it out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需将 `chr` 操作符映射到 `@ascii` 数组中的每个数字值上，这样就会生成一个与这些数字值对应的字符列表。接下来，你将字符连接在一起生成
    `$str`，然后打印出来。
- en: 'You can also golf this one-liner and come up with the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对这个单行命令进行简化，得到以下代码：
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also use the `@ARGV` array and pass the ASCII values as arguments to
    the one-liner:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `@ARGV` 数组，将 ASCII 值作为参数传递给单行命令：
- en: '[PRE35]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 5.10 Generate an array with odd numbers from 1 to 100
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.10 生成一个包含 1 到 100 之间的奇数的数组
- en: '[PRE36]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This one-liner generates an array of odd numbers from 1 to 99 (that is, 1, 3,
    5, 7, 9, 11, … , 99). It uses `grep` to evaluate the code `$_ % 2 == 1` for each
    element in the list `1..100` and returns only those elements for which the given
    code evaluates to true. In this case, the code tests to see if the remainder when
    dividing by 2 is 1\. If it is, the number is odd, and it’s put in the `@odd` array.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令生成了一个从 1 到 99 的奇数数组（即 1, 3, 5, 7, 9, 11, … , 99）。它使用 `grep` 对列表 `1..100`
    中的每个元素进行代码 `$_ % 2 == 1` 的评估，仅返回那些评估结果为真的元素。在这个例子中，代码检查除以 2 的余数是否为 1。如果是，那么该数字是奇数，并被放入
    `@odd` 数组。
- en: 'You could also write this using the fact that odd numbers have the least significant
    bit set and test for the least significant bit:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过利用奇数的最低有效位被设置的特点，并测试最低有效位来编写这段代码：
- en: '[PRE37]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The expression `$_ & 1` isolates the least significant bit, and `grep` selects
    only those numbers with the least significant bit set—that is, all odd numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `$_ & 1` 用于隔离最低有效位，`grep` 仅选择那些最低有效位被设置的数字——也就是所有奇数。
- en: 5.11 Generate an array with even numbers from 1 to 100
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.11 生成一个包含 1 到 100 之间偶数的数组
- en: '[PRE38]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This one-liner is almost the same as the one in 5.10, except that `grep` tests
    for the condition “is the number even (remainder after dividing by two is 0)?”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令几乎与 5.10 中的命令相同，唯一的区别是 `grep` 测试条件是“这个数字是否为偶数（除以 2 后余数为 0）？”
- en: 5.12 Find the length of a string
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.12 查找字符串的长度
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `length` subroutine finds the length of a string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 子例程用于查找字符串的长度。'
- en: 5.13 Find the number of elements in an array
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.13 查找数组中的元素个数
- en: '[PRE40]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Evaluating an array in the scalar context returns its number of elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在标量上下文中评估数组会返回数组的元素个数。
- en: 'You could also do this by adding `1` to the last index of an array:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在数组的最后一个索引上加`1`来做到这一点：
- en: '[PRE41]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `$#array` returns the last index in `@array`. Because that number is one
    less than the number of elements in the array, you add `1` to the result to find
    the total number of elements in the array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`$#array`返回`@array`中的最后一个索引。因为这个数字比数组中元素的数量少1，所以你可以在结果上加上`1`来找到数组中的元素总数。
- en: 'For example, say you want to find out how many text files are in the current
    directory. You can use `@ARGV` and pass the `*.txt` wildcard to Perl. The shell
    expands the `*.txt` wildcard to a list of filenames that match `*.txt`, and Perl
    puts them into the `@ARGV` array and prints the array in the scalar context. The
    output will be the number of text files in the current directory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想找出当前目录中有多少个文本文件。你可以使用`@ARGV`并将`*.txt`通配符传递给Perl。Shell将`*.txt`通配符扩展为匹配`*.txt`的文件名列表，然后Perl将它们放入`@ARGV`数组，并在标量上下文中打印该数组。输出将是当前目录中文本文件的数量：
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If your shell doesn’t support filename expansion (also known as *globbing*)
    or if you’re on Windows, you can use the diamond operator with the `*.txt` argument:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Shell不支持文件名扩展（也称为*通配符匹配*），或者你使用的是Windows，你可以使用钻石操作符与`*.txt`参数：
- en: '[PRE43]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, the diamond operator does the globbing and returns a list of filenames
    that match `*.txt`. Evaluating this list in the scalar context returns the number
    of files that matched.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，钻石操作符会进行通配符匹配，并返回一个匹配`*.txt`的文件名列表。在标量上下文中评估这个列表会返回匹配的文件数量。
