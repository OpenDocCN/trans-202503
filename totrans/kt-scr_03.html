<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<span aria-label="47" epub:type="pagebreak" id="pg_47" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch2">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">2</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">ARRAYS, COLLECTIONS, AND CLASSES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">In this chapter, we’ll continue to explore the fundamentals of the Kotlin language by learning how to store and manipulate data in various ways. We’ll move beyond the simple data types of <span class="calibre4"><a href="chapter1.xhtml" class="calibre3">Chapter 1</a></span> and explore data structures that can hold multiple values in a single unit. We’ll start with arrays, then move on to collections such as lists, sets, and maps, which provide more functionality and flexibility for working with data. Then we’ll learn how to create custom containers in the form of classes. We’ll investigate various kinds of classes, including regular, data, abstract, and enum classes.</p>
<p class="tx">Classes are the foundation of the object-oriented style of programming, allowing us to model and manipulate data by defining our own data <span aria-label="48" epub:type="pagebreak" id="pg_48" role="doc-pagebreak"/>types with specific properties and behaviors. As we discuss classes, we’ll also demystify other object-oriented concepts, such as encapsulation, inheritance, polymorphism, and interfaces. At the end of the chapter, we’ll synthesize the topics we’ve covered into a project where we create a basic task manager app to help you track and organize your daily tasks.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-20"/><span class="sans_futura_std_bold_b_">Arrays</span></h3>
<p class="tni">A Kotlin <i class="calibre9">array</i> is a collection of elements in a contiguous block of memory. The number of elements in the array is determined when the array is created; therefore, it can’t be changed, meaning you can’t add an extra element to an array once it is created. However, the values of an array’s elements are mutable, so they can be modified as needed. An array can hold elements of any type, including user-created types, as long as all elements within the same array have the same type or are derived from a common parent type (supertype).</p>
<p class="tx">Each array element has an index that allows you to access it individually. By default, the first element of an array will have an index of <span class="sans_thesansmonocd_w5regular_">0</span>, the second element an index of <span class="sans_thesansmonocd_w5regular_">1</span>, and so on. The index of an array’s last element is therefore always one less than the array’s size. For example, if we create an array of size <span class="sans_thesansmonocd_w5regular_">10</span> (that is, containing 10 elements), the index of the last element would be <span class="sans_thesansmonocd_w5regular_">9</span>. To access an array element, place its index in square brackets after the name of the array.</p>
<p class="tx">Here we create two different arrays, one comprising integers and one comprising string values, and print the last element of the first array and the first element of the second:</p>
<pre class="calibre10"><code class="calibre11">val arrInt = arrayOf(10, 20, 30, 40)
println(arrInt[3]) // output: 40
val arrString = arrayOf("one", "two", "three", "four", "five")
println(arrString[0]) // output: one</code></pre>
<p class="tx">We create each array with the <span class="sans_thesansmonocd_w5regular_">arrayOf()</span> function, passing the initial values for the array’s elements as arguments. Notice that we don’t have to specify the data type (<span class="sans_thesansmonocd_w5regular_">Int</span> or <span class="sans_thesansmonocd_w5regular_">String</span>) explicitly; the compiler can infer the array type from the values provided.</p>
<p class="tx">In Kotlin, we can create an array with elements of different subtypes as long as they’re all derived from the same supertype. For example, <span class="sans_thesansmonocd_w5regular_">Any</span> is a Kotlin supertype that encompasses all other data types, such as <span class="sans_thesansmonocd_w5regular_">Int</span>, <span class="sans_thesansmonocd_w5regular_">String</span>, and <span class="sans_thesansmonocd_w5regular_">Boolean</span>. Therefore, if we create an array of type <span class="sans_thesansmonocd_w5regular_">Any</span>, we’re free to mix these data types, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val myArray: Array&lt;Any&gt; = arrayOf(1, "bye", false)</code></pre>
<p class="tx">We use the <span class="sans_thesansmonocd_w5regular_">Array&lt;Any&gt;</span> type declaration to indicate that <span class="sans_thesansmonocd_w5regular_">myArray</span> can contain elements of any data type. Indeed, it contains an integer (<span class="sans_thesansmonocd_w5regular_">1</span>), a string (<span class="sans_thesansmonocd_w5regular_">"bye"</span>), and a Boolean (<span class="sans_thesansmonocd_w5regular_">false</span>). Since all these types are derived from the common supertype <span class="sans_thesansmonocd_w5regular_">Any</span>, they can be stored in the same array. We could have skipped declaring the array type using <span class="sans_thesansmonocd_w5regular_">Array&lt;Any&gt;</span> in this case; Kotlin is smart <span aria-label="49" epub:type="pagebreak" id="pg_49" role="doc-pagebreak"/>enough to figure it out on its own. However, if you’re creating an array of elements with a user-defined type, it may be a good idea to declare the type explicitly to remind yourself that you’re working with elements of a nonstandard type. For example, if you have a custom <span class="sans_thesansmonocd_w5regular_">Person</span> class and want to create an array of objects of this class, you could declare the type as follows:</p>
<pre class="calibre10"><code class="calibre11">val people: Array&lt;Person&gt; = arrayOf(...)</code></pre>
<p class="tni">This indicates that the elements in the <span class="sans_thesansmonocd_w5regular_">people</span> array will all be <span class="sans_thesansmonocd_w5regular_">Person</span> objects.</p>
<aside aria-label="box-8" class="box">
<p class="boxtitle" id="box-8"><span class="sans_futura_std_bold_b_">WHAT IS AN OBJECT?</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">An</span> <span class="sans_futura_std_book_oblique_">object</span> <span class="sans_futura_std_book_">is a fundamental concept in object-oriented programming (OOP). It is an instance of a class, which is a blueprint for creating objects. Each object can have its own set of properties and functions, which are defined by the class. In general, objects are used to organize code into reusable, modular components. We’ll cover classes and objects in detail later in this chapter.</span></p>
</aside>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h1" id="sec2"><span id="h2-19"/><span class="sans_futura_std_bold_condensed_oblique_">Primitive Arrays</span></h4>
<p class="tni">Kotlin provides specialized array types for select data types including <span class="sans_thesansmonocd_w5regular_">Byte</span>, <span class="sans_thesansmonocd_w5regular_">Short</span>, <span class="sans_thesansmonocd_w5regular_">Int</span>, <span class="sans_thesansmonocd_w5regular_">Long</span>, <span class="sans_thesansmonocd_w5regular_">Char</span>, <span class="sans_thesansmonocd_w5regular_">Float</span>, <span class="sans_thesansmonocd_w5regular_">Double</span>, and <span class="sans_thesansmonocd_w5regular_">Boolean</span>. For example, we can use <span class="sans_thesansmonocd_w5regular_">IntArray</span> for integers, <span class="sans_thesansmonocd_w5regular_">DoubleArray</span> for floating-point values, and <span class="sans_thesansmonocd_w5regular_">CharArray</span> for individual characters. Primitive arrays are more memory efficient than their nonprimitive counterparts, making them a good choice for performance-critical operations. The syntax for creating primitive arrays is similar to that of regular arrays, with a specialized function, equivalent to <span class="sans_thesansmonocd_w5regular_">arrayOf()</span>, for each type of primitive array:</p>
<pre class="calibre10"><code class="calibre11">val intArray = intArrayOf(1, 2, 3, 4, 5)
val doubleArray = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0)
val charArray = charArrayOf('a', 'b', 'c', 'd', 'e')
val booleanArray = booleanArrayOf(true, false, true, false)</code></pre>
<p class="tx">No primitive array for the <span class="sans_thesansmonocd_w5regular_">String</span> type exists in Kotlin, since <span class="sans_thesansmonocd_w5regular_">String</span> is a reference type, not a primitive type, and is handled differently by the Java Virtual Machine (JVM) compared to primitive types during runtime. Because of this, creating a special primitive string array wouldn’t provide any significant memory or performance advantage in the way something like <span class="sans_thesansmonocd_w5regular_">intArray</span> or <span class="sans_thesansmonocd_w5regular_">booleanArray</span> does.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1" id="sec3"><span id="h2-20"/><span class="sans_futura_std_bold_condensed_oblique_">The Array Constructor</span></h4>
<p class="tni">Another way to create an array is with the <span class="sans_thesansmonocd_w5regular_">Array</span> constructor. As we’ll discuss in more detail later in the chapter when we look at classes, a <i class="calibre9">constructor</i> is a <span aria-label="50" epub:type="pagebreak" id="pg_50" role="doc-pagebreak"/>function for creating an object of a particular class—in this case, the <span class="sans_thesansmonocd_w5regular_">Array</span> class. In Kotlin, you can use the <span class="sans_thesansmonocd_w5regular_">Array</span> constructor to create an array of a given size and set its elements to values determined using a lambda expression or function. Once the array elements are initialized, you can access them later and update their values as required. Using a lambda expression or a function to initialize a large array can be more efficient than hardcoding the values as arguments to the <span class="sans_thesansmonocd_w5regular_">arrayOf()</span> function or reading them from an input file.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">Array</span> constructor takes two parameters: the size of the array and a function that returns the initial value for each array element based on its index. For example:</p>
<pre class="calibre10"><code class="calibre11">val num = Array(4, {i -&gt; i * 2})</code></pre>
<p class="tni">Here, we call the <span class="sans_thesansmonocd_w5regular_">Array</span> constructor to create an array of size <span class="sans_thesansmonocd_w5regular_">4</span> and initialize its elements using a lambda expression. The lambda takes the index of each element (<span class="sans_thesansmonocd_w5regular_">i</span>) and doubles it to set the element’s value. The result is an array of the integer values <span class="sans_thesansmonocd_w5regular_">0</span>, <span class="sans_thesansmonocd_w5regular_">2</span>, <span class="sans_thesansmonocd_w5regular_">4</span>, and <span class="sans_thesansmonocd_w5regular_">6</span>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1" id="sec4"><span id="h2-21"/><span class="sans_futura_std_bold_condensed_oblique_">Array Operations</span></h4>
<p class="tni">Arrays in Kotlin offer a variety of methods that can help you access and manipulate their elements. <a href="chapter2.xhtml#tab2-1" class="calibre2">Table 2-1</a> summarizes some of the commonly used methods for array manipulation.</p>
<p class="tt" id="tab2-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 2-1:</span></span> <span class="sans_futura_std_book_">Commonly Used Array Methods</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Operation</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Description</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Example</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Access</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Retrieve an element by its index.</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">val element</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array[index]</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Update</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Modify an element at a specific index.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">array[index]</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">newValue</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Size</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Get the number of elements in the array.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">val size</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array.size</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Iterate</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Loop through each element in the array.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">for (element in array) {/* ... */}</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Search/find</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Check if an element exists in the array (</span><span class="sans_thesansmonocd_w5regular_">true</span> <span class="sans_futura_std_book_">or</span> <span class="sans_thesansmonocd_w5regular_">false</span><span class="sans_futura_std_book_">).</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">val found</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array.contains(element)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Slice</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Extract a portion of the array.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">val subArray</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array.slice(startIndex..endIndex)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Sort</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Arrange elements in ascending or descending order.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">array.sort()</span> <span class="sans_futura_std_book_">or</span> <span class="sans_thesansmonocd_w5regular_">array.sortDescending()</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Filter</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Create a new array with elements that meet a condition.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">val filteredArray</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array.filter {/* condition */}</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Map/transform</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Apply a function to each element and create a new array with the results.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">val mappedArray</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array.map {/* transformation */}</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Join</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Combine elements into a single string with a delimiter.</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">val joinedString</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">array .joinToString(", ")</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span aria-label="51" epub:type="pagebreak" id="pg_51" role="doc-pagebreak"/>Notice that when we apply methods such as <span class="sans_thesansmonocd_w5regular_">filter</span> and <span class="sans_thesansmonocd_w5regular_">map</span> to a data container such as an array, and the method name is followed by a lambda expression, we don’t have to include parentheses after the method name like we typically would when calling a function. I encourage you to try out these operations by creating and manipulating different types of arrays.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1" id="sec5"><span id="h2-22"/><span class="sans_futura_std_bold_condensed_oblique_">Multidimensional Arrays</span></h4>
<p class="tni">A <i class="calibre9">multidimensional array</i> is an array whose elements are themselves arrays. Nested arrays are widely used in scientific and numerical computation. For instance, a two-dimensional array can represent a grid of pixels in an image or the coordinates of locations on a map. Similarly, a three-dimensional array can be used to track the location and movements of an object in space, such as in three-dimensional gaming or for real-world objects like satellites.</p>
<p class="tx">In Kotlin, you can create multidimensional arrays using the built-in array creation functions. Here’s how to create a two-dimensional array using the <span class="sans_thesansmonocd_w5regular_">Array</span> constructor:</p>
<pre class="calibre10"><code class="calibre11">val numRow = 3
val numCol = 4
// Create a (3x4) array.
val twoDimArray = Array(numRow) {Array(numCol) {0}}
// Access and modify an element using its indices.
twoDimArray[2][3] = 99</code></pre>
<p class="tx">In this example, we use the <span class="sans_thesansmonocd_w5regular_">Array</span> constructor to create a two-dimensional array with <span class="sans_thesansmonocd_w5regular_">3</span> rows and <span class="sans_thesansmonocd_w5regular_">4</span> columns and initialize all 12 of its elements to <span class="sans_thesansmonocd_w5regular_">0</span>. We then replace the value of the last element, which has a row index of <span class="sans_thesansmonocd_w5regular_">2</span> and a column index of <span class="sans_thesansmonocd_w5regular_">3</span>, with a new value (<span class="sans_thesansmonocd_w5regular_">99</span>). Notice that we use separate sets of square brackets for the two indices. Creating and manipulating a three-dimensional array follows the same pattern:</p>
<pre class="calibre10"><code class="calibre11">// Create a 3D array.
val threeDimArray = Array(2) {Array(3) {Array(4) {""}}}
// Access and modify an element using its indices.
threeDimArray[1][2][3] = "Hello, world!"</code></pre>
<p class="tx">In this example, we first create an array of dimensions 2×3×4 and initialize its elements to empty strings. As before, we access and change the last element in the array using its dimensional indices.</p>
<p class="tx">We can also use nested calls of the <span class="sans_thesansmonocd_w5regular_">arrayOf()</span> function (or equivalent primitive array functions) to create a multidimensional array. Here’s an example of creating a two-dimensional array of integers:</p>
<pre class="calibre10"><code class="calibre11">val arr2D = arrayOf(
    intArrayOf(0, 1, 1),
    intArrayOf(2, 0, 2),
    intArrayOf(3, 3, 0)
)
println(arr2D[2][2])  // output: 0</code></pre>
<p class="tx"><span aria-label="52" epub:type="pagebreak" id="pg_52" role="doc-pagebreak"/>We use <span class="sans_thesansmonocd_w5regular_">arrayOf()</span> to create an array of arrays called <span class="sans_thesansmonocd_w5regular_">arr2D</span>. Each element of <span class="sans_thesansmonocd_w5regular_">arr2D</span> is an array of integers created using <span class="sans_thesansmonocd_w5regular_">intArrayOf()</span>. For example, the first element of <span class="sans_thesansmonocd_w5regular_">arr2D</span> is an array containing integers <span class="sans_thesansmonocd_w5regular_">0</span>, <span class="sans_thesansmonocd_w5regular_">1</span>, and <span class="sans_thesansmonocd_w5regular_">1</span>. Printing the value of the last element of <span class="sans_thesansmonocd_w5regular_">arr2D</span>, designated by <span class="sans_thesansmonocd_w5regular_">arr2D[2][2]</span>, will produce an output of <span class="sans_thesansmonocd_w5regular_">0</span>.</p>
<aside aria-label="box-9" class="box2">
<p class="boxtitle" id="box-9"><span class="sans_futura_std_bold_b_">EXERCISES</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Try your hand at the following array-based problems:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Find the second-largest element in an array of integers, and print it to the console. For example, if the array is</span> <span class="sans_thesansmonocd_w5regular_">[1, 2, 3, 4, 5, 6]</span><span class="sans_futura_std_book_">, the code should print</span> <span class="sans_thesansmonocd_w5regular_">5</span><span class="sans_futura_std_book_">.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Given an array of integers, find the contiguous subarray with the largest sum, and return that sum. For example, given the array</span> <span class="sans_thesansmonocd_w5regular_">[-2, 1, -3, 4, -1, 2, 1, -5, 4]</span><span class="sans_futura_std_book_">, the contiguous subarray with the largest sum is</span> <span class="sans_thesansmonocd_w5regular_">[4, -1, 2, 1]</span><span class="sans_futura_std_book_">, and its sum is</span> <span class="sans_thesansmonocd_w5regular_">6</span><span class="sans_futura_std_book_">.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">3.  Given an array of integers and a positive integer</span> <span class="sans_thesansmonocd_w5regular_">k</span><span class="sans_futura_std_book_">, rotate the array to the right by</span> <span class="sans_thesansmonocd_w5regular_">k</span> <span class="sans_futura_std_book_">positions. For example, given the array</span> <span class="sans_thesansmonocd_w5regular_">[1, 2, 3, 4, 5]</span> <span class="sans_futura_std_book_">and a</span> <span class="sans_thesansmonocd_w5regular_">k</span> <span class="sans_futura_std_book_">of</span> <span class="sans_thesansmonocd_w5regular_">2</span><span class="sans_futura_std_book_">, the rotated array should be</span> <span class="sans_thesansmonocd_w5regular_">[4, 5, 1, 2, 3]</span><span class="sans_futura_std_book_">.</span></p>
</div>
</aside>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h" id="sec6"><span id="h1-21"/><span class="sans_futura_std_bold_b_">Collections</span></h3>
<p class="tni">Kotlin <i class="calibre9">collections</i> are containers that can hold data or objects of the same type or different subtypes of a common supertype (for example, <span class="sans_thesansmonocd_w5regular_">Any</span>). Collections can be resized as needed when declared as mutable. This is in contrast to arrays, whose size can’t be changed once they’re initialized. Kotlin provides various types of collections, such as lists, sets, and maps, each with distinct properties and use cases.</p>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="h1" id="sec7"><span id="h2-23"/><span class="sans_futura_std_bold_condensed_oblique_">Lists</span></h4>
<p class="tni">A <i class="calibre9">list</i> in Kotlin is an ordered collection of elements that can be either read-only or mutable. A read-only list is an immutable collection of elements that can’t be modified once created. You can perform only read operations like <span class="sans_thesansmonocd_w5regular_">size</span>, <span class="sans_thesansmonocd_w5regular_">contains</span>, <span class="sans_thesansmonocd_w5regular_">indexOf</span>, and <span class="sans_thesansmonocd_w5regular_">subList</span> on a read-only list. On the other hand, a mutable list is an ordered collection of elements that supports adding and removing elements or changing the value of a particular element.</p>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="h2" id="sec8"><span id="h3-13"/><span class="sans_futura_std_bold_b_">Read-Only</span></h5>
<p class="tni">You create a read-only list using the <span class="sans_thesansmonocd_w5regular_">listOf()</span> function:</p>
<pre class="calibre10"><code class="calibre11">val list = listOf(1, 2, 3, 2)</code></pre>
<p class="tni"><span aria-label="53" epub:type="pagebreak" id="pg_53" role="doc-pagebreak"/>Notice that this list includes the value <span class="sans_thesansmonocd_w5regular_">2</span> twice. The potential for duplicate values is a key feature that distinguishes lists from sets, another type of Kotlin collection. A list created using <span class="sans_thesansmonocd_w5regular_">listOf()</span> can contain only one type of data, which will be inferred from the elements of the list.</p>
<p class="tx">The elements of a list can be accessed the same way we access array elements: using an index system that starts with <span class="sans_thesansmonocd_w5regular_">0</span>. Lists also provide the <span class="sans_thesansmonocd_w5regular_">first()</span> and <span class="sans_thesansmonocd_w5regular_">last()</span> methods for convenient access to the first and last elements directly, without the need for an index. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">val names = listOf("Mary", "Sam", "Olivia", "Mike", "Ian")
println(names[1])       // output: Sam
println(names.first())  // output: Mary
println(names.last())   // output: Ian</code></pre>
<p class="tx">Since lists are zero indexed like arrays, <span class="sans_thesansmonocd_w5regular_">name[1]</span> returns the second element in the array. Meanwhile, <span class="sans_thesansmonocd_w5regular_">names.first()</span> and <span class="sans_thesansmonocd_w5regular_">names.last()</span> return the first and last array elements, respectively.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h5 class="h2" id="sec9"><span id="h3-14"/><span class="sans_futura_std_bold_b_">Mutable</span></h5>
<p class="tni">If you want the flexibility to modify a list, use <span class="sans_thesansmonocd_w5regular_">mutableListOf()</span> to create a <i class="calibre9">mutable list</i>. This way, you can change both the list’s content and its size, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val mutableList = mutableListOf(1, 2, 3)
mutableList.add(4)       // Add an element.
mutableList.removeAt(1)  // Remove an element.
mutableList[0] = 5       // Modify an element.
println(mutableList)</code></pre>
<p class="tx">After creating a list with three elements, we use the <span class="sans_thesansmonocd_w5regular_">add()</span> method to append a fourth element to the end of the list and the <span class="sans_thesansmonocd_w5regular_">removeAt()</span> method to delete the element at index <span class="sans_thesansmonocd_w5regular_">1</span>; the later elements in the list slide over to fill in the gap. We also set a new value for the list’s first element (index <span class="sans_thesansmonocd_w5regular_">0</span>). When you run this code, the output should look like this:</p>
<pre class="calibre10"><code class="calibre11">[5, 3, 4]</code></pre>
<p class="tx">Another way to append an element to the end of a mutable list is to use the <span class="sans_thesansmonocd_w5regular_">+=</span> operator, and you can likewise remove the first instance of an element with the <span class="sans_thesansmonocd_w5regular_">-=</span> operator. You can also use the <span class="sans_thesansmonocd_w5regular_">removeAll()</span> method to delete all the elements of a list that meet a specific condition. Here’s another example:</p>
<pre class="calibre10"><code class="calibre11">val fruits = mutableListOf("apple", "banana", "berry", "cherry")
// Add an element using the += operator.
fruits += "plum"
// Remove all elements that start with the letter "b".
fruits.removeAll {it.startsWith("b")}</code></pre>
<p class="tx"><span aria-label="54" epub:type="pagebreak" id="pg_54" role="doc-pagebreak"/>We create a mutable list of fruits and use <span class="sans_thesansmonocd_w5regular_">+=</span> to add an extra element to it. Then we call <span class="sans_thesansmonocd_w5regular_">removeAll()</span>, providing a lambda expression that checks if each list element starts with <span class="sans_thesansmonocd_w5regular_">b</span>. Remember that if a lambda has a single parameter, the <span class="sans_thesansmonocd_w5regular_">it</span> keyword can stand in as that parameter. In this case, <span class="sans_thesansmonocd_w5regular_">it</span> is a proxy for each element of the list.</p>
<p class="tx">One method that’s particularly helpful while working with mutable lists is <span class="sans_thesansmonocd_w5regular_">clear()</span>, which deletes the list’s entire contents:</p>
<pre class="calibre10"><code class="calibre11">mutableList.clear()</code></pre>
<p class="tni">This method allows us to reuse a mutable list repeatedly instead of creating new lists that would take up additional memory resources.</p>
<p class="tx">It’s common to initially create an empty mutable list and to then fill it with elements as needed. In this case, you must include a type declaration for the list when calling the <span class="sans_thesansmonocd_w5regular_">mutableListOf()</span> function, as shown here:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> val list = mutableListOf&lt;Any&gt;()
list.add("hello")
list.add(2)
list.add(33.33)
println(list.joinToString(", "))</code></pre>
<p class="tx">We use <span class="sans_thesansmonocd_w5regular_">&lt;Any&gt;</span> when creating the list <span aria-label="annotation1" class="codeannotation">❶</span> to indicate it can contain any of this supertype’s subtypes, including <span class="sans_thesansmonocd_w5regular_">String</span>, <span class="sans_thesansmonocd_w5regular_">Int</span>, and <span class="sans_thesansmonocd_w5regular_">Double</span>. When you run this code, the output should look like this:</p>
<pre class="calibre10"><code class="calibre11">hello, 2, 33.33</code></pre>
<p class="tni">Notice how we’ve used the <span class="sans_thesansmonocd_w5regular_">joinToString()</span> method to merge the list elements into a single string that’s printed out, with a comma separating each element.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1" id="sec10"><span id="h2-24"/><span class="sans_futura_std_bold_condensed_oblique_">Sets</span></h4>
<p class="tni">A <i class="calibre9">set</i> is a collection of unique elements, meaning each element can occur only once. Sets don’t have a defined order, so two sets are considered equal if they contain the same elements in any order. Sets come in read-only and mutable varieties, created with the <span class="sans_thesansmonocd_w5regular_">setOf()</span> or <span class="sans_thesansmonocd_w5regular_">mutableSetOf()</span> functions, respectively. Here’s an example of each:</p>
<pre class="calibre10"><code class="calibre11">val readonlySet = setOf(1, 2, 3, 4, 5)
val mutableSet = mutableSetOf("apple", "banana", "cherry")</code></pre>
<p class="tx">When assigning values to a set in Kotlin, the compiler automatically ignores any duplicate elements. Consider the following code snippet:</p>
<pre class="calibre10"><code class="calibre11">val mySet = setOf(1, 3, 3, 4, 5, 5, 6)
println(mySet)</code></pre>
<p class="tni"><span aria-label="55" epub:type="pagebreak" id="pg_55" role="doc-pagebreak"/>When you run this code, the output should be:</p>
<pre class="calibre10"><code class="calibre11">[1, 3, 4, 5, 6]</code></pre>
<p class="tni">The duplicate values (<span class="sans_thesansmonocd_w5regular_">3</span> and <span class="sans_thesansmonocd_w5regular_">5</span>) have been filtered out while creating <span class="sans_thesansmonocd_w5regular_">mySet</span>. In this way, sets ensure that each element appears only once, making them useful for maintaining unique collections of data.</p>
<p class="tx">Every set has a <span class="sans_thesansmonocd_w5regular_">size</span> property that reports its number of elements. Sets also have standard methods like <span class="sans_thesansmonocd_w5regular_">add()</span>, <span class="sans_thesansmonocd_w5regular_">remove()</span>, and <span class="sans_thesansmonocd_w5regular_">contains()</span>. In addition, you can use the <span class="sans_thesansmonocd_w5regular_">union()</span>, <span class="sans_thesansmonocd_w5regular_">intersect()</span>, and <span class="sans_thesansmonocd_w5regular_">subtract()</span> methods to create a new set based on the contents of two other sets, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val set1 = setOf(1, 2, 3)
val set2 = setOf(3, 4, 5)
// set operations
val unionSet = set1.union(set2)
val intersectionSet = set1.intersect(set2)
val differenceSet = set1.subtract(set2)</code></pre>
<p class="tx">We call the methods on one set, passing the second set as an argument. In this example, <span class="sans_thesansmonocd_w5regular_">unionSet</span> holds <span class="sans_thesansmonocd_w5regular_">{1, 2, 3, 4, 5}</span>, all the unique elements from both input sets; <span class="sans_thesansmonocd_w5regular_">intersectionSet</span> holds <span class="sans_thesansmonocd_w5regular_">{3}</span>, the only element present in both input sets; and <span class="sans_thesansmonocd_w5regular_">differenceSet</span> holds <span class="sans_thesansmonocd_w5regular_">{1, 2}</span>, the elements from <span class="sans_thesansmonocd_w5regular_">set1</span> that aren’t in <span class="sans_thesansmonocd_w5regular_">set2</span>.</p>
<aside aria-label="box-10" class="box2">
<p class="boxtitle" id="box-10"><span class="sans_futura_std_bold_b_">EXERCISES</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Create two sets,</span> <span class="sans_thesansmonocd_w5regular_">mathStudents</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">scienceStudents</span><span class="sans_futura_std_book_">, containing the names of students who have chosen to take math and science courses, respectively. (Assume that students can take both courses if they wish.) Perform the following operations on these sets to analyze the data:</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">a.  Find and print the students who have chosen both math and science courses (intersection).</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">b.  Find and print the students who have chosen math courses, science courses, or both (union).</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">c.  Find and print the students who have chosen math but not science courses (difference).</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">d.  Find and print the students who have chosen science but not math courses (difference).</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">e.  Calculate and print the total number of students who have chosen math or science courses.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Given a set of integers, write a code snippet to find all possible subsets of the set and return them. For example, given the set</span> <span class="sans_thesansmonocd_w5regular_">{1, 2}</span><span class="sans_futura_std_book_">, the possible subsets are</span> <span class="sans_thesansmonocd_w5regular_">{}</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">{1}</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">{2}</span><span class="sans_futura_std_book_">, and</span> <span class="sans_thesansmonocd_w5regular_">{1, 2}</span><span class="sans_futura_std_book_">.</span></p>
</div>
</aside>
</section>
<section aria-labelledby="sec11" epub:type="division">
<span aria-label="56" epub:type="pagebreak" id="pg_56" role="doc-pagebreak"/>
<h4 class="h1" id="sec11"><span id="h2-25"/><span class="sans_futura_std_bold_condensed_oblique_">Maps</span></h4>
<p class="tni">A <i class="calibre9">map</i> is a collection of key-value pairs, where each key is a label associated with a value. If you’ve encountered dictionaries in Python or hash maps in Java, the idea is similar. The keys in a map must be unique. As with lists and sets, you can create a map using the <span class="sans_thesansmonocd_w5regular_">mapOf()</span> or <span class="sans_thesansmonocd_w5regular_">mutableMapOf()</span> functions, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val ages = mapOf("Alice" to 30, "Bob" to 25, "Charlie" to 35)
val vertices = mutableMapOf("circle" to 0, "triangle" to 3,
    "rectangle" to 4, "pentagon" to 5)</code></pre>
<p class="tni">We use <span class="sans_thesansmonocd_w5regular_">ages</span> to <span class="sans_thesansmonocd_w5regular_">map</span> people’s names to their ages and <span class="sans_thesansmonocd_w5regular_">vertices</span> to map different shapes to their number of vertices. When creating each map, notice how we use <span class="sans_thesansmonocd_w5regular_">to</span> for pairing each key (such as <span class="sans_thesansmonocd_w5regular_">"Alice"</span>) with a value (such as <span class="sans_thesansmonocd_w5regular_">30</span>). The key-value pairs are separated by commas.</p>
<p class="tx">Common properties and methods for maps include <span class="sans_thesansmonocd_w5regular_">size</span> to return the number of key-value pairs, <span class="sans_thesansmonocd_w5regular_">get()</span> to return the value associated with a key, <span class="sans_thesansmonocd_w5regular_">remove()</span> to delete a key and its value, <span class="sans_thesansmonocd_w5regular_">put()</span> to add a new key-value pair, and <span class="sans_thesansmonocd_w5regular_">containsKey()</span> to check if a key is present. Here are a few examples based on the maps created in the previous snippet:</p>
<pre class="calibre10"><code class="calibre11">val bobAge = ages.get("Bob") // returns the associated value: 25
vertices.put("hexagon", 6)   // adds a new key-value pair
vertices.remove("circle")    // removes the circle-0 pair
val testForCircle = vertices.containsKey("circle") // returns false
println(bobAge)
println(vertices)
println(testForCircle)</code></pre>
<p class="tx">We retrieve a value from the ages map with <span class="sans_thesansmonocd_w5regular_">get()</span> and add a new key-value pair to vertices with <span class="sans_thesansmonocd_w5regular_">put()</span>. Then we delete the <span class="sans_thesansmonocd_w5regular_">"circle"</span> entry from vertices with <span class="sans_thesansmonocd_w5regular_">remove()</span>, meaning that <span class="sans_thesansmonocd_w5regular_">vertices.containsKey("circle")</span> should return <span class="sans_thesansmonocd_w5regular_">false</span>. This code snippet should produce the following output:</p>
<pre class="calibre10"><code class="calibre11">25
{triangle=3, rectangle=4, pentagon=5, hexagon=6}
false</code></pre>
<p class="tx">Notice that when we call the <span class="sans_thesansmonocd_w5regular_">put()</span> method, we don’t use the same <span class="sans_thesansmonocd_w5regular_italic_">key</span> <span class="sans_thesansmonocd_w5regular_">to</span> <span class="sans_thesansmonocd_w5regular_italic_">value</span> syntax used when creating a map. Instead, we provide the key and value as individual arguments, separated by a comma.</p>
<p class="tx">We’ve only scratched the surface of Kotlin’s various collections and their properties and methods. For more, I recommend consulting the official Kotlin documentation at <span class="copyright_accent"><a href="https://kotlinlang.org/docs/home.xhtml" class="calibre2">https://kotlinlang.org/docs/home.xhtml</a></span>.</p>
<span aria-label="57" epub:type="pagebreak" id="pg_57" role="doc-pagebreak"/>
<aside aria-label="box-11" class="box2">
<p class="boxtitle" id="box-11"><span class="sans_futura_std_bold_b_">EXERCISES</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Use maps and their methods to solve the following problems:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Given an array of integers, find the most frequent element in the array and return it. For example, given the array</span> <span class="sans_thesansmonocd_w5regular_">[1, 2, 3, 2, 1, 4, 2]</span><span class="sans_futura_std_book_">, the most frequent element is</span> <span class="sans_thesansmonocd_w5regular_">2</span><span class="sans_futura_std_book_">. (Hint: Make each unique element in the array a key in a map, paired with a value counting how many times that element occurs.)</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Given a string, create a map where the keys are individual characters from the string and the values represent the count of each character. Return the resulting map.</span></p>
</div>
</aside>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="h" id="sec12"><span id="h1-22"/><span class="sans_futura_std_bold_b_">An Introduction to Classes</span></h3>
<p class="tni">A <i class="calibre9">class</i> in Kotlin is a template for creating custom objects. It specifies the properties (variables) and methods (functions) that all objects of that class should have. When you use a class in your code to make an object, you create an <i class="calibre9">instance</i> of that class. This process is called <i class="calibre9">instantiation</i>. Classes are the core building blocks of the object-oriented style of programming. While objects are codified models of real-world entities or concepts, you can also think of the classes used to create them as custom containers that encapsulate data and functionality into a single unit.</p>
<p class="tx">Classes simplify building complex systems by providing abstraction levels. When we categorize objects into classes, we can abstract their common features and behaviors into a single unit. For example, consider a <span class="sans_thesansmonocd_w5regular_">Person</span> class representing any person in code. It has properties like <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span>, along with methods like <span class="sans_thesansmonocd_w5regular_">speak()</span> and <span class="sans_thesansmonocd_w5regular_">walk()</span>. Instances of this class (representing specific people) fill in their own values for properties and have access to the shared methods.</p>
<p class="tx">Classes further help us model complex systems in a modular way using <i class="calibre9">subclasses</i>. For instance, the <span class="sans_thesansmonocd_w5regular_">Person</span> class can have subclasses like <span class="sans_thesansmonocd_w5regular_">Teacher</span>, <span class="sans_thesansmonocd_w5regular_">Student</span>, and <span class="sans_thesansmonocd_w5regular_">Athlete</span>. Each subclass inherits general properties and methods from the <span class="sans_thesansmonocd_w5regular_">Person</span> superclass while adding new features specific to the subclass. For example, a <span class="sans_thesansmonocd_w5regular_">Teacher</span> might have an <span class="sans_thesansmonocd_w5regular_">isTenured</span> property, and a <span class="sans_thesansmonocd_w5regular_">Student</span> might have a <span class="sans_thesansmonocd_w5regular_">gradeLevel</span> property.</p>
<p class="tx">To create a class in Kotlin, you declare it with the <span class="sans_thesansmonocd_w5regular_">class</span> keyword, followed by the name of the class and its body, which is enclosed in braces. By convention, class names should begin with a capital letter. Here’s an example of a simple class declaration:</p>
<pre class="calibre10"><code class="calibre11">class Person {
    var name: String = ""
    var age: Int = 0
}</code></pre>
<p class="tx"><span aria-label="58" epub:type="pagebreak" id="pg_58" role="doc-pagebreak"/>Here, we define a class called <span class="sans_thesansmonocd_w5regular_">Person</span> that has two properties: <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span>. These properties are declared just like regular variables in the class body and are assigned initial values of <span class="sans_thesansmonocd_w5regular_">""</span> (an empty string) and <span class="sans_thesansmonocd_w5regular_">0</span>, respectively. With the <span class="sans_thesansmonocd_w5regular_">Person</span> class declared, we can now create an individual instance of the class and change its properties, like this:</p>
<pre class="calibre10"><code class="calibre11">val person1 = Person()
person1.name = "John"
person1.age = 25</code></pre>
<p class="tx">Here we create a new <span class="sans_thesansmonocd_w5regular_">Person</span> object and store it in the <span class="sans_thesansmonocd_w5regular_">person1</span> variable. We do this by invoking the <span class="sans_thesansmonocd_w5regular_">Person()</span> constructor, which returns a new object of the <span class="sans_thesansmonocd_w5regular_">Person</span> class (you’ll find more on constructors in the next section). We then assign values to the object’s <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> properties, accessing these properties using dot notation. Why limit ourselves to just one <span class="sans_thesansmonocd_w5regular_">Person</span> object, however? The beauty of classes is that we can use them to create as many different objects of that class as we want. Let’s create another <span class="sans_thesansmonocd_w5regular_">Person</span> object:</p>
<pre class="calibre10"><code class="calibre11">val person2 = Person()
person2.name = "Irina"
person2.age = 21</code></pre>
<p class="tx">This time we store the object in the <span class="sans_thesansmonocd_w5regular_">person2</span> variable and give it its own values for the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> properties, distinct from those of <span class="sans_thesansmonocd_w5regular_">person1</span>.</p>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="h1" id="sec13"><span id="h2-26"/><span class="sans_futura_std_bold_condensed_oblique_">Constructors</span></h4>
<p class="tni">In the previous example, you saw how class properties can be initialized directly in the class body, but it’s more common to initialize class properties using a <i class="calibre9">constructor</i>. This is a special function that’s automatically called when a new object of a class is created. In Kotlin, you can initialize properties using a primary constructor or a secondary constructor, both of which we’ll discuss in this section.</p>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="h2" id="sec14"><span id="h3-15"/><span class="sans_futura_std_bold_b_">Primary Constructors</span></h5>
<p class="tni">A <i class="calibre9">primary constructor</i> is defined in the class header, a set of parentheses after the class name. The primary constructor lays out the names and data types of class properties using the following syntax:</p>
<pre class="calibre10"><code class="calibre11">class MyClass(val <var class="calibre18">property1</var>: <var class="calibre18">Type1</var>, val <var class="calibre18">property2</var>: <var class="calibre18">Type2</var>) {
// class body
}</code></pre>
<p class="tx">In this syntax, class properties are listed as a sequence of <span class="sans_thesansmonocd_w5regular_italic_">name</span><span class="sans_thesansmonocd_w5regular_">:</span> <span class="sans_thesansmonocd_w5regular_italic_">type</span> entries, similar to declaring function parameters. All property names must be preceded by <span class="sans_thesansmonocd_w5regular_">val</span> or <span class="sans_thesansmonocd_w5regular_">var</span>. With the class properties declared in this way, we can then provide specific values for the properties when creating an object of the class, much like passing argument values to a function.</p>
<p class="tx"><span aria-label="59" epub:type="pagebreak" id="pg_59" role="doc-pagebreak"/>Besides declaring the name and type of each property, we can also provide default values for the properties in the class header as part of the primary constructor. To illustrate, let’s redefine the <span class="sans_thesansmonocd_w5regular_">Person</span> class, adding a header with a primary constructor. We’ll then create a couple of instances of the class and initialize their properties through the constructor:</p>
<pre class="calibre10"><code class="calibre11">class Person(val name: String = "", val age: Int = -99) {
    override fun toString(): String {
        return "Person(name=$name, age=$age)"
    }
}

fun main() {
    val person1 = Person("John", 25)
    val person2 = Person("Irina", 21)
    println(person1)
    println(person2)
}</code></pre>
<p class="tx">This code segment defines a class named <span class="sans_thesansmonocd_w5regular_">Person</span> with two properties, <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span>, specified in the class header, which serves as the primary constructor. We give <span class="sans_thesansmonocd_w5regular_">name</span> a default value of <span class="sans_thesansmonocd_w5regular_">""</span> (an empty string) and <span class="sans_thesansmonocd_w5regular_">age</span> a default value of <span class="sans_thesansmonocd_w5regular_">-99</span>. The class also overrides (redefines) the <span class="sans_thesansmonocd_w5regular_">toString()</span> method; we’ll discuss this in more detail shortly.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we create two objects of the <span class="sans_thesansmonocd_w5regular_">Person</span> class, passing values for the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> properties as arguments to the constructor. This saves us from having to write separate statements setting these property values, as we did in our original implementation of the class. We then print the two <span class="sans_thesansmonocd_w5regular_">Person</span> objects to the console. When you run this code, the output should be as follows:</p>
<pre class="calibre10"><code class="calibre11">Person(name=John, age=25)
Person(name=Irina, age=21)</code></pre>
<p class="tx">When you pass an object to <span class="sans_thesansmonocd_w5regular_">println()</span>, Kotlin automatically invokes that object’s <span class="sans_thesansmonocd_w5regular_">toString()</span> method to display some kind of string representation of the object. All classes come with a default implementation of this method, inherited from the general <span class="sans_thesansmonocd_w5regular_">Any</span> class, but this default implementation displays only the class name and the object’s hash code (a unique integer identifier), which is not very informative or readable. Overriding the <span class="sans_thesansmonocd_w5regular_">Person</span> class’s <span class="sans_thesansmonocd_w5regular_">toString()</span> method with a customized definition allows us to display the properties of the object in a more meaningful way. We’ll learn more about overriding methods inherited from a parent class later in this chapter.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h5 class="h2" id="sec15"><span id="h3-16"/><span class="sans_futura_std_bold_b_">Secondary Constructors</span></h5>
<p class="tni">Kotlin classes can also have one or more <i class="calibre9">secondary constructors</i> containing additional parameters or logic that should be invoked when new objects are created. The secondary constructor isn’t part of the class header but is instead defined inside the class body with the <span class="sans_thesansmonocd_w5regular_">constructor</span> keyword. If a <span aria-label="60" epub:type="pagebreak" id="pg_60" role="doc-pagebreak"/>primary constructor also exists, a secondary constructor must always delegate to it (that is, call it), either directly or indirectly through other secondary constructors, using the <span class="sans_thesansmonocd_w5regular_">this</span> keyword.</p>
<p class="tx">A class can have just a primary constructor, primary and secondary constructors, or just secondary constructors. While secondary constructors aren’t mandatory, they can be useful in certain scenarios. For instance, when we need to initialize too many class properties, it may be more convenient to initialize them inside a secondary constructor. This mechanism also allows you to set default values for properties that aren’t initialized in the primary constructor. Moreover, secondary constructors allow you to create instances of the class with different combinations of properties. This is like function overloading, where you have multiple functions with the same name but different parameters.</p>
<p class="tx">The following example shows how to create and use secondary constructors. In the process, it illustrates all three ways of initializing class properties: inside the class body, using a primary constructor, and using secondary constructors.</p>
<pre class="calibre10"><code class="calibre11">class Car(val make: String, val model: String, val year: Int) {
    // property initialization inside class body
  <span aria-label="annotation1" class="code_codeannotation">❶</span> var color: String = "Unknown"

    // 1st secondary constructor (no args)
    constructor() : this("Unknown", "Unknown", 0)

    // 2nd secondary constructor (1 arg)
  <span aria-label="annotation2" class="code_codeannotation">❷</span> constructor(make: String) : this(make, "Unknown", 0)

    // 3rd secondary constructor (2 args)
    constructor(make: String, model: String) : this(make, model, 0)

    override fun toString(): String =
        "Make: ${make}, Model: ${model}, Year: ${year}, Color: ${color}"
}

fun main() {
    val c1 = Car()
    val c2 = Car("Nissan")
    val c3 = Car("Toyota", "Prius")
    val c4 = Car("Ford", "Mustang", 2024)

    c1.color = "Blue"
    c2.color = "Red"
    c3.color = "Black"
    c4.color = "Yellow"

    println(c1)
    println(c2)
    println(c3)
    println(c4)
}</code></pre>
<p class="tx"><span aria-label="61" epub:type="pagebreak" id="pg_61" role="doc-pagebreak"/>In this example, the <span class="sans_thesansmonocd_w5regular_">Car</span> class has a primary constructor with three parameters: <span class="sans_thesansmonocd_w5regular_">make</span>, <span class="sans_thesansmonocd_w5regular_">model</span>, and <span class="sans_thesansmonocd_w5regular_">year</span>. It also has three secondary constructors with zero, one, and two parameters, respectively. These secondary constructors use the <span class="sans_thesansmonocd_w5regular_">this</span> keyword (after a colon) to call the primary constructor, passing along the received parameter values while filling in default values for the missing ones. For example, the second secondary constructor <span aria-label="annotation2" class="codeannotation">❷</span> takes in a value for the <span class="sans_thesansmonocd_w5regular_">make</span> property while providing default values of <span class="sans_thesansmonocd_w5regular_">"Unknown"</span> and <span class="sans_thesansmonocd_w5regular_">0</span> for the <span class="sans_thesansmonocd_w5regular_">model</span> and <span class="sans_thesansmonocd_w5regular_">year</span> properties. Notice how the <span class="sans_thesansmonocd_w5regular_">Car</span> class also has a <span class="sans_thesansmonocd_w5regular_">color</span> property that’s initialized to <span class="sans_thesansmonocd_w5regular_">"Unknown"</span> in the class body <span aria-label="annotation1" class="codeannotation">❶</span>, separate from any of the constructors. This property can be set to a different value after a <span class="sans_thesansmonocd_w5regular_">Car</span> object is created, because it was declared with a <span class="sans_thesansmonocd_w5regular_">var</span>.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we create four <span class="sans_thesansmonocd_w5regular_">Car</span> objects using the different constructors. Kotlin determines which one to invoke based on the number of arguments supplied. For example, <span class="sans_thesansmonocd_w5regular_">c1</span> will be created with the first secondary constructor, since no arguments are provided, while <span class="sans_thesansmonocd_w5regular_">c4</span> will be created with the primary constructor, since all three arguments are provided. We then set the <span class="sans_thesansmonocd_w5regular_">color</span> property of each object and print out the details of each object using the class’s <span class="sans_thesansmonocd_w5regular_">toString()</span> method, which we’ve again overridden. The code should produce the following output:</p>
<pre class="calibre10"><code class="calibre11">Make: Unknown, Model: Unknown, Year: 0, Color: Blue
Make: Nissan, Model: Unknown, Year: 0, Color: Red
Make: Toyota, Model: Prius, Year: 0, Color: Black
Make: Ford, Model: Mustang, Year: 2024, Color: Yellow</code></pre>
<p class="tx">Notice how the objects range from having all default values when no arguments were supplied to having all custom values when three arguments were supplied.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="h1" id="sec16"><span id="h2-27"/><span class="sans_futura_std_bold_condensed_oblique_">The init Block</span></h4>
<p class="tni">In Kotlin, you can use an <span class="sans_thesansmonocd_w5regular_">init</span> block within a class to run a code segment during object construction. The <span class="sans_thesansmonocd_w5regular_">init</span> block is automatically executed when an object of the class is created. If you have multiple <span class="sans_thesansmonocd_w5regular_">init</span> blocks, they’ll run in the same order in which they appear inside the class.</p>
<p class="tx">Here’s an example of how to use the <span class="sans_thesansmonocd_w5regular_">init</span> block to initialize properties within a class:</p>
<pre class="calibre10"><code class="calibre11">class Person (var name: String, var age: Int) {
    // additional property
    var isMinor: Boolean = false

    // init block for custom initialization
    init {
        if (age &lt; 18) isMinor = true
    }
}</code></pre>
<p class="tx">We give the <span class="sans_thesansmonocd_w5regular_">Person</span> class an <span class="sans_thesansmonocd_w5regular_">init</span> block that changes the <span class="sans_thesansmonocd_w5regular_">isMinor</span> property from <span class="sans_thesansmonocd_w5regular_">false</span> to <span class="sans_thesansmonocd_w5regular_">true</span> when the <span class="sans_thesansmonocd_w5regular_">age</span> property of the <span class="sans_thesansmonocd_w5regular_">Person</span> object is less than <span class="sans_thesansmonocd_w5regular_">18</span>. <span aria-label="62" epub:type="pagebreak" id="pg_62" role="doc-pagebreak"/>This block will be executed whenever a <span class="sans_thesansmonocd_w5regular_">Person</span> object is created to adjust the <span class="sans_thesansmonocd_w5regular_">isMinor</span> value as needed.</p>
<p class="tx">Both <span class="sans_thesansmonocd_w5regular_">init</span> blocks and secondary constructors can be used to initialize class properties or run additional logic when an object is created. The <span class="sans_thesansmonocd_w5regular_">init</span> block is preferred over the secondary constructor when we need to run additional code after initializing certain properties. (In the previous example, we changed the value of the <span class="sans_thesansmonocd_w5regular_">isMinor</span> property after initializing it using an <span class="sans_thesansmonocd_w5regular_">init</span> block.) The <span class="sans_thesansmonocd_w5regular_">init</span> block can use primary constructor parameters and is executed immediately after the primary constructor but before executing any secondary constructors.</p>
<p class="tx">On the other hand, secondary constructors are more useful when you need to provide additional ways to instantiate a class with different combinations of properties. Still, the two mechanisms share many similarities; when coding, you often have multiple ways to complete a task.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="h1" id="sec17"><span id="h2-28"/><span class="sans_futura_std_bold_condensed_oblique_">Methods</span></h4>
<p class="tni"><i class="calibre9">Methods</i> are functions associated with a class that can be called through objects of that class to perform certain actions. A class’s methods are declared as part of the class body. To illustrate, let’s add a <span class="sans_thesansmonocd_w5regular_">sayHello()</span> method to our <span class="sans_thesansmonocd_w5regular_">Person</span> class:</p>
<pre class="calibre10"><code class="calibre11">class Person (var name: String = "Unknown", var age = -99) {
    fun sayHello() {
        println("Hello, my name is $name, " +
                "and I am $age years old.")
    }
}</code></pre>
<p class="tx">Inside the class body, we declare a <span class="sans_thesansmonocd_w5regular_">sayHello()</span> method that uses string templates to print a greeting that includes the person’s <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> properties. Notice that declaring a method follows the same syntax as declaring an ordinary function, with the <span class="sans_thesansmonocd_w5regular_">fun</span> keyword and a body enclosed in braces.</p>
<p class="tx">To use this method, create a <span class="sans_thesansmonocd_w5regular_">Person</span> object and invoke the method via dot notation, like so:</p>
<pre class="calibre10"><code class="calibre11">val person = Person("John", 25)
person.sayHello()</code></pre>
<p class="tni">This will output:</p>
<pre class="calibre10"><code class="calibre11">Hello, my name is John, and I am 25 years old.</code></pre>
<p class="tx">You can add more methods to the <span class="sans_thesansmonocd_w5regular_">Person</span> class to perform other actions or calculations based on the object’s properties. Methods can also take parameters and return values, just like regular functions.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<span aria-label="63" epub:type="pagebreak" id="pg_63" role="doc-pagebreak"/>
<h4 class="h1" id="sec18"><span id="h2-29"/><span class="sans_futura_std_bold_condensed_oblique_">Encapsulation</span></h4>
<p class="tni"><i class="calibre9">Encapsulation</i> is a fundamental principle of object-oriented programming that helps you control access to the internal state of an object. This control is achieved through <i class="calibre9">access modifiers</i>, keywords that specify the visibility or accessibility of a property or method. Access modifiers allow you to hide (<i class="calibre9">encapsulate</i>) the implementation details of a class and maintain the integrity of the objects of a class by reducing the risk of unintended modifications. The two most important access modifiers in Kotlin are <span class="sans_thesansmonocd_w5regular_">public</span> and <span class="sans_thesansmonocd_w5regular_">private</span>.</p>
<p class="tx">Unless declared otherwise, all properties and methods of a class are considered <i class="calibre9">public</i> by default. This means they can be accessed from anywhere in the code. <i class="calibre9">Private</i> properties and methods, by contrast, can be accessed only within the class declaration itself. For instance, if you designated the <span class="sans_thesansmonocd_w5regular_">Person</span> class’s <span class="sans_thesansmonocd_w5regular_">age</span> property as private, you could reference it within the declarations of <span class="sans_thesansmonocd_w5regular_">Person</span> class methods, but you couldn’t use it in code outside the class declaration, such as to update a <span class="sans_thesansmonocd_w5regular_">Person</span> object’s <span class="sans_thesansmonocd_w5regular_">age</span> value from the <span class="sans_thesansmonocd_w5regular_">main()</span> function. This protects the <span class="sans_thesansmonocd_w5regular_">age</span> property from being altered in unintended ways.</p>
<p class="tx">Here’s an example of how to harness encapsulation and the <span class="sans_thesansmonocd_w5regular_">private</span> access modifier within the <span class="sans_thesansmonocd_w5regular_">Person</span> class:</p>
<pre class="calibre10"><code class="calibre11">class Person(private var name: String, private var age: Int) {
    fun introduce() {
        println("Hi, I'm $name, and I'm $age years old.")
    }

    fun haveBirthday() {
        age++
    }
}

fun main() {
    val person = Person("Alice", 30)

    // Access and modify properties using public methods.
    person.introduce()
    person.haveBirthday()
    person.introduce()

    // Trying to access private properties directly
    // will result in a compilation error.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> // println(person.name)
    // person.age++
}</code></pre>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">Person</span> class header, we use the <span class="sans_thesansmonocd_w5regular_">private</span> access modifier to designate the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> properties as private. This way, the properties can be accessed and modified only within the class itself. We also give the class two methods, <span class="sans_thesansmonocd_w5regular_">introduce()</span> and <span class="sans_thesansmonocd_w5regular_">haveBirthday()</span>, which are considered public by default. These methods provide controlled access to the private properties, with <span class="sans_thesansmonocd_w5regular_">introduce()</span> displaying the values of <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span>, and <span class="sans_thesansmonocd_w5regular_">haveBirthday()</span> <span aria-label="64" epub:type="pagebreak" id="pg_64" role="doc-pagebreak"/>incrementing <span class="sans_thesansmonocd_w5regular_">age</span>. In effect, this restricts how a <span class="sans_thesansmonocd_w5regular_">Person</span> object’s <span class="sans_thesansmonocd_w5regular_">age</span> property can be updated; it can increase by only one year at a time, rather than by jumping abruptly from, say, <span class="sans_thesansmonocd_w5regular_">30</span> to <span class="sans_thesansmonocd_w5regular_">40</span>.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we create a <span class="sans_thesansmonocd_w5regular_">Person</span> object, passing initial values for <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> (it’s still possible to set the values of private properties through the constructor). Then we call the public <span class="sans_thesansmonocd_w5regular_">introduce()</span> and <span class="sans_thesansmonocd_w5regular_">haveBirthday()</span> methods, and <span class="sans_thesansmonocd_w5regular_">introduce()</span> again, producing the following output:</p>
<pre class="calibre10"><code class="calibre11">Hi, I'm Alice, and I'm 30 years old.
Hi, I'm Alice, and I'm 31 years old.</code></pre>
<p class="tni">In this way, we’re able to access and modify the object’s private properties indirectly through its public methods. However, we can’t access or modify the private properties directly, as we attempt to do in the commented-out lines of code <span aria-label="annotation1" class="codeannotation">❶</span>. If you try removing these comments to execute these statements, you’ll get compilation errors because the properties are private.</p>
<p class="tx">Kotlin also has two additional access modifiers, <span class="sans_thesansmonocd_w5regular_">protected</span> and <span class="sans_thesansmonocd_w5regular_">internal</span>. <i class="calibre9">Protected</i> properties and methods are like private ones, except they can be accessed within subclasses of a class, as well as within the class itself (more on subclasses shortly). <i class="calibre9">Internal</i> properties and methods can be accessed only within the same module.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_15-n">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre9">A</i> <span class="copyright_accent">module</span> <i class="calibre9">is a set of Kotlin files that must be processed together during compilation. Files or functions accessed through an</i> <span class="sans_thesansmonocd_w5regular_italic_">import</span> <i class="calibre9">statement aren’t considered part of the module itself but rather external dependencies used by the module.</i></p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h1" id="sec19"><span id="h2-30"/><span class="sans_futura_std_bold_condensed_oblique_">The this Keyword</span></h4>
<p class="tni">Inside a Kotlin class declaration, the <span class="sans_thesansmonocd_w5regular_">this</span> keyword is a reference to the current instance of the class. For example, if you see <span class="sans_thesansmonocd_w5regular_">this.name</span> inside a method definition for the <span class="sans_thesansmonocd_w5regular_">Person</span> class, it simply refers to the value of the <span class="sans_thesansmonocd_w5regular_">name</span> property of whatever <span class="sans_thesansmonocd_w5regular_">Person</span> object the method is called on. We haven’t used the <span class="sans_thesansmonocd_w5regular_">this</span> keyword in our <span class="sans_thesansmonocd_w5regular_">Person</span> class examples so far, because it’s been clear from the code that variables like <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> are properties of the class. The keyword becomes important when we need to distinguish between class properties and method parameters with the same name. Here’s an example of a <span class="sans_thesansmonocd_w5regular_">Book</span> class where <span class="sans_thesansmonocd_w5regular_">this</span> is necessary:</p>
<pre class="calibre10"><code class="calibre11">class Book(var title: String, var author: String) {
    fun displayInfo() {
        println("Title: $title")
        println("Author: $author")
    }

    fun updateInfo(title: String, author: String) {
        this.title = title
        this.author = author
    }
}

<span aria-label="65" epub:type="pagebreak" id="pg_65" role="doc-pagebreak"/>fun main() {
    val book1 = Book("The Great Gatsby", "F. Scott Fitzgerald")
    // Display book information.
    book1.displayInfo()
    // Update book information.
    book1.updateInfo("To Kill a Mockingbird", "Harper Lee")

    println("\nUpdated book information:")
    book1.displayInfo()
}</code></pre>
<p class="tx">In this example, we have a <span class="sans_thesansmonocd_w5regular_">Book</span> class with <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">author</span> properties and two methods. The <span class="sans_thesansmonocd_w5regular_">displayInfo()</span> method displays the book’s title and author, and the <span class="sans_thesansmonocd_w5regular_">updateInfo()</span> method takes in new values for <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">author</span> as arguments and updates the properties of the class with these values. Notice how we use the <span class="sans_thesansmonocd_w5regular_">this</span> keyword in the <span class="sans_thesansmonocd_w5regular_">updateInfo()</span> method to distinguish <span class="sans_thesansmonocd_w5regular_">this.title</span> and <span class="sans_thesansmonocd_w5regular_">this.author</span> (the <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">author</span> properties of the class) from <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">author</span> (the method’s parameters). In this way, we can update the book’s information correctly without any naming conflicts.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we instantiate a <span class="sans_thesansmonocd_w5regular_">Book</span> object and then use its <span class="sans_thesansmonocd_w5regular_">updateInfo()</span> method to change its title and author, displaying the book’s properties before and after the change with <span class="sans_thesansmonocd_w5regular_">displayInfo()</span>. The output should appear as follows:</p>
<pre class="calibre10"><code class="calibre11">Title: The Great Gatsby
Author: F. Scott Fitzgerald

Updated book information:
Title: To Kill a Mockingbird
Author: Harper Lee</code></pre>
<p class="tx">Try removing the <span class="sans_thesansmonocd_w5regular_">this</span> keywords from the <span class="sans_thesansmonocd_w5regular_">updateInfo()</span> method, leaving <span class="sans_thesansmonocd_w5regular_">title</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">author</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">author</span>. The code will no longer work: Kotlin will try to interpret <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">author</span> as local variables being declared without a <span class="sans_thesansmonocd_w5regular_">val</span> or <span class="sans_thesansmonocd_w5regular_">var</span>, and it won’t be able to initialize those local variables with the arguments supplied (which wouldn’t be our intention anyway).</p>
<p class="tx">While the <span class="sans_thesansmonocd_w5regular_">this</span> keyword refers to the current instance of the class when it appears inside a class method, it has other meanings in other contexts. As we’ve already seen, when <span class="sans_thesansmonocd_w5regular_">this</span> appears after a colon in a secondary constructor, it serves to delegate to the primary constructor of the same class. For information about additional uses of the <span class="sans_thesansmonocd_w5regular_">this</span> keyword, see the official Kotlin documentation.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="h1" id="sec20"><span id="h2-31"/><span class="sans_futura_std_bold_condensed_oblique_">Inheritance and Polymorphism</span></h4>
<p class="tni"><i class="calibre9">Inheritance</i> and <i class="calibre9">polymorphism</i> are interrelated tenets of object-oriented programming. Inheritance allows a more specialized subclass, or <i class="calibre9">child class</i>, to take on properties and methods from a more general superclass, or <i class="calibre9">parent class</i>; polymorphism enables the child class to override and extend the behavior of its parent. Together, inheritance and polymorphism foster <span aria-label="66" epub:type="pagebreak" id="pg_66" role="doc-pagebreak"/>flexibility and code reusability, and they enable different child classes to extend the same inherited parent method in distinct ways.</p>
<p class="tx">Unlike some other programming languages, Kotlin classes aren’t inheritable by default. Instead, you need to explicitly mark the parent class with the <span class="sans_thesansmonocd_w5regular_">open</span> keyword to make it inheritable by child classes. Then, after the header in the child class declaration, you specify the parent class name (with a colon before its name). This establishes the inheritance relationship.</p>
<p class="tx">Here is a simple example of creating a child class that has its own unique property in addition to what it inherits from the parent class:</p>
<pre class="calibre10"><code class="calibre11">open class ParentClass(val name: String, val age: Int) {
    init {
        println()
        println("Hello, I am $name, and I am $age years old.")
    }
}

class ChildClass(name: String, age: Int, val occupation: String)
    : ParentClass(name, age) {

    init {
        println("My occupation is $occupation.")
    }
}

fun main() {
    // Create instances of parent and child classes.
    val person1 = ParentClass("John", 33)
    val person2 = ChildClass("Sarah", 24, "accountant")
}</code></pre>
<p class="tx">Notice that we’ve used the <span class="sans_thesansmonocd_w5regular_">open</span> keyword before the parent class. This indicates that the class can be inherited by a child class. The primary constructor of the parent class requires two properties: <span class="sans_thesansmonocd_w5regular_">name</span> of type <span class="sans_thesansmonocd_w5regular_">String</span> and <span class="sans_thesansmonocd_w5regular_">age</span> of type <span class="sans_thesansmonocd_w5regular_">Int</span>. Since no default values are provided for these properties, their values must be supplied when instantiating a child class. Additionally, the child class introduces a new property called <span class="sans_thesansmonocd_w5regular_">occupation</span>, which also requires a value during instantiation.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we create <span class="sans_thesansmonocd_w5regular_">person1</span> as an instance of the parent class and <span class="sans_thesansmonocd_w5regular_">person2</span> as an instance of the child class. Since both classes have <span class="sans_thesansmonocd_w5regular_">init</span> blocks, when you run this program the output should resemble the following:</p>
<pre class="calibre10"><code class="calibre11">Hello, I am John, and I am 33 years old.

Hello, I am Sarah, and I am 24 years old.
My occupation is accountant.</code></pre>
<p class="tx">If you intend to customize or override properties or methods from the parent class in the child class, you also need to mark them individually with the <span class="sans_thesansmonocd_w5regular_">open</span> keyword in the parent class. Then, in the child class, use <span aria-label="67" epub:type="pagebreak" id="pg_67" role="doc-pagebreak"/>the <span class="sans_thesansmonocd_w5regular_">override</span> keyword before these properties or methods. This ensures that the compiler recognizes your intention to override the parent class’s implementation.</p>
<p class="tx">Here is a simple example of overriding a parent class’s method within the child class:</p>
<pre class="calibre10"><code class="calibre11">// parent class
open class Vehicle {
    open fun startEngine() {
        println("Vehicle engine started")
    }
}

// child class
class Car : Vehicle() {
    override fun startEngine() {
        println("Car engine started")
    }
}

fun main() {
    val myCar = Car()
    myCar.startEngine()
}</code></pre>
<p class="tx">In this example, we employed the <span class="sans_thesansmonocd_w5regular_">open</span> keyword twice—once preceding the parent class (<span class="sans_thesansmonocd_w5regular_">Vehicle</span>) and once when declaring the <span class="sans_thesansmonocd_w5regular_">startEngine()</span> method within the parent class. Then, within the child class (<span class="sans_thesansmonocd_w5regular_">Car</span>), we modified the method using the <span class="sans_thesansmonocd_w5regular_">override</span> keyword. As a result, when you run this code, it should yield the following output:</p>
<pre class="calibre10"><code class="calibre11">Car engine started</code></pre>
<p class="tx">While we’ve covered the basics of inheritance and polymorphism, you still have much more to explore. I recommend consulting the official Kotlin documentation for additional use cases.</p>
</section>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="h" id="sec21"><span id="h1-23"/><span class="sans_futura_std_bold_b_">Common Classes and Custom Types</span></h3>
<p class="tni">Now that we’ve outlined some basic principles of classes and object-oriented programming, in this section we’ll explore several commonly used classes and custom types in Kotlin. These include data classes, pairs and triples, abstract classes, interfaces, and enum classes. If you’re new to classes and haven’t used any of these features before, you might want to start with a quick overview before getting into the details. <a href="chapter2.xhtml#tab2-2" class="calibre2">Table 2-2</a> provides names, short descriptions, and use cases of the features we’ll cover. You can refer to this table if you need to refresh your memory or clarify any concepts.</p>
<span aria-label="68" epub:type="pagebreak" id="pg_68" role="doc-pagebreak"/>
<p class="tt" id="tab2-2"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 2-2:</span></span> <span class="sans_futura_std_book_">Commonly Used Classes and Custom Types</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Class</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Definition</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Use cases</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Data class</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">A simple class primarily used to hold data. It doesn’t have any user-defined methods. Data classes are marked with the</span> <span class="sans_thesansmonocd_w5regular_">data</span> <span class="sans_futura_std_book_">keyword.</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Used as basic building blocks for modeling data by providing descriptive names to pair</span> <span class="sans_futura_std_book_">with values. They often serve as</span> <span class="sans_futura_std_book_">building blocks for more com</span><span class="sans_futura_std_book_">plex data structures.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">Pair</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">Triple</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Simple classes for holding two (</span><span class="sans_thesansmonocd_w5regular_">Pair</span><span class="sans_futura_std_book_">) or three (</span><span class="sans_thesansmonocd_w5regular_">Triple</span><span class="sans_futura_std_book_">) values of the same or different data types.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Used to store or return two or three values in a single instance, especially when you don’t need descriptive names for the values.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Abstract class</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">A class that can’t be instantiated and can have abstract members that must be overridden by its subclasses.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Used for defining a common set of features for a group of related classes.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Interface</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">A collection of functions and properties that must be implemented by inheriting classes or types.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Used to enforce methods and properties on other types (classes, functions, custom types).</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Enum class</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">A special class type that represents a group of constants with optional properties and methods.</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Used for representing a fixed set of values.</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">We’ll review each of these concepts with detailed examples in the sections that follow.</p>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="h1" id="sec22"><span id="h2-32"/><span class="sans_futura_std_bold_condensed_oblique_">Data Classes</span></h4>
<p class="tni">In Kotlin, a <i class="calibre9">data class</i> is a class whose main purpose is to hold data and not to perform complex operations or logic. Essentially, it’s a class with properties but no custom methods (although adding such methods isn’t prohibited). To declare a data class, you need to add the <span class="sans_thesansmonocd_w5regular_">data</span> keyword before the <span class="sans_thesansmonocd_w5regular_">class</span> keyword and include at least one parameter in the primary constructor.</p>
<p class="tx">Based on the properties declared in the primary constructor, a data class can automatically generate a number of methods, including:</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">equals()</span> Compares two data class instances for equality.</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">toString()</span> Returns a human-readable string representation of the object.</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">copy()</span> Creates a shallow copy of the data class instance. (See <span>“Copying Objects”</span> on <span><a href="#pg_75" class="calibre2">page 75</a></span> for information about shallow copies.)</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">hashCode()</span> Generates a <span class="copyright_italic">hash code</span>, a unique integer based on a hashing algorithm applied to one or more properties of a class. This method is used in conjunction with <span class="sans_thesansmonocd_w5regular_">equals()</span> to determine if two objects are equivalent.</p>
<p class="tni">By contrast, a regular class in Kotlin doesn’t autogenerate such methods; you would have to manually implement them if required.</p>
<p class="tx"><span aria-label="69" epub:type="pagebreak" id="pg_69" role="doc-pagebreak"/>Here’s an example of how to create and use a simple data class in Kotlin:</p>
<pre class="calibre10"><code class="calibre11">// Declare a data class.
data class Person(val name: String, val age: Int)

fun main() {
    // Create an instance.
    val person = Person("Steve", 40)
    println(person)
}</code></pre>
<p class="tx">We create a <span class="sans_thesansmonocd_w5regular_">Person</span> data class with <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> properties. Since these properties are declared in the class header, a class body isn’t needed. In <span class="sans_thesansmonocd_w5regular_">main()</span> we create an instance of the data class, <span class="sans_thesansmonocd_w5regular_">person</span>, and pass it directly to the <span class="sans_thesansmonocd_w5regular_">println()</span> function. When <span class="sans_thesansmonocd_w5regular_">println()</span> encounters an instance of a data class, Kotlin calls the object’s <span class="sans_thesansmonocd_w5regular_">toString()</span> method automatically, which generates the following output:</p>
<pre class="calibre10"><code class="calibre11">Person(name=Steve, age=40)</code></pre>
<p class="tx">Data classes are extremely useful for modeling and working with data in a clean and efficient manner by grouping related values into a single, custom-designed object. They share some similarities with maps, which use key-value pairs rather than class properties to associate names with data values. However, while maps are primarily used to store and retrieve values by key, data classes are better suited to modeling data in a more meaningful and structured way. Data classes also provide those useful autogenerated methods we just discussed.</p>
<aside aria-label="box-12" class="box">
<p class="boxtitle" id="box-12"><span class="sans_futura_std_bold_b_">DECONSTRUCTION</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_oblique_">Deconstruction</span> <span class="sans_futura_std_book_">is a feature in Kotlin that allows you to extract multiple properties of an object and assign them to individual variables in a single statement. This way, you can use those properties independently of the object. Say you have a</span> <span class="sans_thesansmonocd_w5regular_">Person</span> <span class="sans_futura_std_book_">data class with</span> <span class="sans_thesansmonocd_w5regular_">name</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">age</span> <span class="sans_futura_std_book_">properties, and an instance of that class called</span> <span class="sans_thesansmonocd_w5regular_">person</span><span class="sans_futura_std_book_">. You could use deconstruction to extract the values of those properties from the object as follows:</span></p>
<pre class="calibre10"><code class="calibre11">val (name, age) = person // deconstruction</code></pre>
<p class="box1"><span class="sans_futura_std_book_">The variables that receive the deconstructed values go on the left side of an assignment statement, within parentheses, while the object to be deconstructed goes on the right side. The object’s properties are extracted in the order in which they’re declared in the constructor, so here the value of the</span> <span class="sans_thesansmonocd_w5regular_">name</span> <span class="sans_futura_std_book_">property goes to the</span> <span class="sans_thesansmonocd_w5regular_">name</span> <span class="sans_futura_std_book_">variable and the</span> <span class="sans_thesansmonocd_w5regular_">age</span> <span class="sans_futura_std_book_">property goes to the</span> <span class="sans_thesansmonocd_w5regular_">age</span> <span class="sans_futura_std_book_">variable. (The names happen to match, but this doesn’t have to be the case.)</span></p>
<p class="box1"><span aria-label="70" epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/><span class="sans_futura_std_book_">After deconstruction, the values are available through the simple variables—for example, for printing:</span></p>
<pre class="calibre10"><code class="calibre11">println("Name: $name")    // Print the value of name.
println("Age: $age")      // Print the value of age.</code></pre>
<p class="boxfirst"><span class="sans_futura_std_book_">Notice how we’re using the</span> <span class="sans_thesansmonocd_w5regular_">name</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">age</span> <span class="sans_futura_std_book_">variables in the</span> <span class="sans_thesansmonocd_w5regular_">println()</span> <span class="sans_futura_std_book_">calls, without having to reference the</span> <span class="sans_thesansmonocd_w5regular_">person</span> <span class="sans_futura_std_book_">object.</span></p>
</aside>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="h1" id="sec23"><span id="h2-33"/><span class="sans_futura_std_bold_condensed_oblique_">Pairs and Triples</span></h4>
<p class="tni">A <i class="calibre9">pair</i> in Kotlin is a data class that can store exactly two values, which can be of the same or different types. Pairs are useful for storing two related values in a single object, such as the x- and y-coordinates for a point on a graph or the name and age of a person. They also provide a way to associate a key with a value. In the latter case, the first value in the pair is a string descriptor of the second value. You can create a pair with the <span class="sans_thesansmonocd_w5regular_">Pair()</span> constructor, passing the two values as arguments, or without the constructor by placing <span class="sans_thesansmonocd_w5regular_">to</span> between the two values in an assignment statement. Here’s an example of each technique:</p>
<pre class="calibre10"><code class="calibre11">val pair1 = Pair("Alice", 20)
val pair2 = "Bob" to 25</code></pre>
<p class="tx">A <i class="calibre9">triple</i> is a similar structure for storing three related values in a single object, such as the name, age, and gender of a person, or the RGB color components of a pixel. You can create a triple with the <span class="sans_thesansmonocd_w5regular_">Triple()</span> constructor as follows:</p>
<pre class="calibre10"><code class="calibre11">val triple1 = Triple("Alice", 20, "Female")</code></pre>
<p class="tx">Once a pair or triple is created, it’s immutable, so its values can’t be updated. Those values are accessible using dot notation as the <span class="sans_thesansmonocd_w5regular_">first</span>, <span class="sans_thesansmonocd_w5regular_">second</span>, and <span class="sans_thesansmonocd_w5regular_">third</span> properties. For example:</p>
<pre class="calibre10"><code class="calibre11">val pair = "Hello" to "World"
val triple = Triple(1, 2, 3)

println(pair.first)   // Hello
println(triple.third) // 3</code></pre>
<p class="tx">You can also use deconstruction syntax (see the <span>“Deconstruction”</span> box) to extract the data elements of a pair or triple into individual variables. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="71" epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>val pair = Pair("John", 29)
val (name, age) = pair // deconstruction
println("Name: $name") // Print the value of name.
println("Age: $age")   // Print the value of age.</code></pre>
<p class="tx">We create a <span class="sans_thesansmonocd_w5regular_">Pair</span> called <span class="sans_thesansmonocd_w5regular_">pair</span> with two values: <span class="sans_thesansmonocd_w5regular_">John</span> and <span class="sans_thesansmonocd_w5regular_">29</span>. We then use deconstruction to extract these values and assign them to the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> variables. From there, we can use the variables independently to print out the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> of the <span class="sans_thesansmonocd_w5regular_">pair</span> object.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="h1" id="sec24"><span id="h2-34"/><span class="sans_futura_std_bold_condensed_oblique_">Abstract Classes</span></h4>
<p class="tni">In Kotlin, an <i class="calibre9">abstract class</i> is a class that can’t be instantiated on its own. Instead, it serves as a blueprint for other classes to extend through inheritance and polymorphism. You can use abstract classes when you want to provide a common foundation or framework—including methods and properties—that must be implemented and fleshed out by various child classes but that wouldn’t itself hold up as a fully functional class. In this sense, an abstract class serves much like a regular parent class declared with <span class="sans_thesansmonocd_w5regular_">open</span> in that it allows inheritance and permits the overriding of properties and methods. The key difference lies in the fact that you can’t directly instantiate an abstract class.</p>
<p class="tx">You declare an abstract class using the <span class="sans_thesansmonocd_w5regular_">abstract</span> keyword. It can have abstract properties (with no initial values, just names and data types) and abstract methods (with no implementation, just names and return types). Abstract properties and methods are declared using the <span class="sans_thesansmonocd_w5regular_">abstract</span> keyword, just like the class itself. Abstract classes can also have concrete (nonabstract) properties and methods—complete variable or function declarations that provide default behavior.</p>
<p class="tx">Any class that inherits from an abstract class must implement the inherited abstract properties and methods, giving them concrete values and definitions. If the child class doesn’t do this, it must be declared as an abstract class as well. Subclasses also have the option to override the concrete members of the abstract class.</p>
<p class="tx">Here’s an example of how all of this works, where we create an abstract <span class="sans_thesansmonocd_w5regular_">Shape</span> class and use it as a model for <span class="sans_thesansmonocd_w5regular_">Circle</span> and <span class="sans_thesansmonocd_w5regular_">Square</span> classes:</p>
<pre class="calibre10"><code class="calibre11">abstract class Shape {
    abstract fun area(): Double  // abstract method
    val name: String = "Shape"   // concrete property
    fun describe() {
        println("This is a $name")
    }
}

class Circle(val radius: Double): Shape() {
    override fun area(): Double {
        return Math.PI * radius * radius
    }
}

<span aria-label="72" epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/>class Square(val side: Double): Shape() {
    override fun area(): Double {
        return side * side
    }
}

fun main() {
    val circle = Circle(5.0)
    val square = Square(4.0)

    circle.describe()
    println("Area of the circle: ${circle.area()}")

    square.describe()
    println("Area of the square: ${square.area()}")
}</code></pre>
<p class="tx">We use the <span class="sans_thesansmonocd_w5regular_">abstract</span> keyword to designate <span class="sans_thesansmonocd_w5regular_">Shape</span> as an abstract class. It has an abstract <span class="sans_thesansmonocd_w5regular_">area()</span> method that should return a value of type <span class="sans_thesansmonocd_w5regular_">Double</span> and a concrete <span class="sans_thesansmonocd_w5regular_">name</span> property with a value of <span class="sans_thesansmonocd_w5regular_">"Shape"</span>, as well as a concrete <span class="sans_thesansmonocd_w5regular_">describe()</span> method that prints a message. We then declare both <span class="sans_thesansmonocd_w5regular_">Circle</span> and <span class="sans_thesansmonocd_w5regular_">Square</span> as nonabstract subclasses of <span class="sans_thesansmonocd_w5regular_">Shape</span>. Each is given a property unique to the subclass (<span class="sans_thesansmonocd_w5regular_">radius</span> for <span class="sans_thesansmonocd_w5regular_">Circle</span> and <span class="sans_thesansmonocd_w5regular_">side</span> for <span class="sans_thesansmonocd_w5regular_">Square</span>), and each inherits the <span class="sans_thesansmonocd_w5regular_">name</span> property and <span class="sans_thesansmonocd_w5regular_">describe()</span> method from <span class="sans_thesansmonocd_w5regular_">Shape</span>. The subclasses must also provide a concrete implementation for the inherited <span class="sans_thesansmonocd_w5regular_">area()</span> method using the <span class="sans_thesansmonocd_w5regular_">override</span> keyword. In this way, the abstract <span class="sans_thesansmonocd_w5regular_">Shape</span> class serves as a common structure for both types of shape, enforcing that any subclass must implement a method that calculates the shape’s area.</p>
<p class="tx">In <span class="sans_thesansmonocd_w5regular_">main()</span> we create an instance of each concrete class and invoke its <span class="sans_thesansmonocd_w5regular_">area()</span> method within a string template. The code should produce the following output:</p>
<pre class="calibre10"><code class="calibre11">This is a Shape
Area of the circle: 78.53981633974483
This is a Shape
Area of the square: 16.0</code></pre>
<p class="tx">In addition to ensuring consistency through a shared structure between the parent and the child classes, abstract classes reduce code duplication, improve code readability, and simplify code maintenance.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h4 class="h1" id="sec25"><span id="h2-35"/><span class="sans_futura_std_bold_condensed_oblique_">Interfaces</span></h4>
<p class="tni">An <i class="calibre9">interface</i> is a collection of methods and properties that form a common set of behaviors that the types implementing the interface must follow. These methods and properties are abstract in the sense that we can’t use them directly, but we don’t use the <span class="sans_thesansmonocd_w5regular_">abstract</span> keyword when defining them. Interfaces can contain declarations of abstract methods and properties, as well as method implementations. However, they can’t store state, meaning they can’t contain any fields or properties that store data.</p>
<p class="tx"><span aria-label="73" epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>A class or object can implement one or more interfaces. When a class implements an interface, it must provide full definitions for all the abstract methods and properties declared in that interface. In this sense, the interface acts as a common contract for the classes that implement it, laying out the features that any implementing class must agree to have.</p>
<p class="tx">Here’s an example of how to define and use an interface in Kotlin:</p>
<pre class="calibre10"><code class="calibre11">import kotlin.math.PI

interface Properties {
    fun area(): Double
    fun perimeter(): Double
}

class Circle(val radius: Double): Properties {
    override fun area() = PI * radius * radius
    override fun perimeter() = 2 * PI * radius
}

fun main() {
    val circle = Circle(4.0)
    val area = circle.area()
    val perimeter = circle.perimeter()

    println("Properties of the circle:")
    println(" radius = ${circle.radius}\n area = $area\n" +
            " perimeter = $perimeter")
}</code></pre>
<p class="tx">We use the <span class="sans_thesansmonocd_w5regular_">interface</span> keyword to declare the <span class="sans_thesansmonocd_w5regular_">Properties</span> interface. It defines two abstract methods, <span class="sans_thesansmonocd_w5regular_">area()</span> and <span class="sans_thesansmonocd_w5regular_">perimeter()</span>, both of which return a floating-point value. Any class that implements the interface, such as the <span class="sans_thesansmonocd_w5regular_">Circle</span> class declared here, must include definitions for both methods.</p>
<p class="tx">The syntax for implementing an interface is similar to that of inheritance: a colon after the class header, followed by the name of the interface. Notice that we also need to use the <span class="sans_thesansmonocd_w5regular_">override</span> keyword when implementing the functions from the interface.</p>
<p class="tx">In <span class="sans_thesansmonocd_w5regular_">main()</span>, we create an instance of the <span class="sans_thesansmonocd_w5regular_">Circle</span> class and invoke its <span class="sans_thesansmonocd_w5regular_">area()</span> and <span class="sans_thesansmonocd_w5regular_">perimeter()</span> methods, storing the results in the local <span class="sans_thesansmonocd_w5regular_">area</span> and <span class="sans_thesansmonocd_w5regular_">perimeter</span> variables. Then we print these values to the console, generating the following output:</p>
<pre class="calibre10"><code class="calibre11">Properties of the circle:
radius = 4.0
area = 50.26548245743669
perimeter = 25.132741228718345</code></pre>
<p class="tx">Kotlin interfaces can also inherit from other interfaces, meaning they can provide implementations for the inherited members and declare new functions and properties. However, classes implementing such an interface are required to define only the missing implementations.</p>
<span aria-label="74" epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/>
<aside aria-label="box-13" class="box">
<p class="boxtitle" id="box-13"><span class="sans_futura_std_bold_b_">ABSTRACT CLASSES VS. INTERFACES</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Abstract classes and interfaces share some common features, but they also have some important differences. An abstract class is a higher-level framework (superclass) for a group of related classes. It can have functions and properties, and it can hold state. Methods and properties designated as abstract in an abstract class must be fully implemented in the inheriting class. An abstract class can inherit multiple interfaces but can extend only one class. Furthermore, an abstract class can’t be directly instantiated.</span></p>
<p class="boxlast"><span class="sans_futura_std_book_">An interface is a collection of methods and properties that an inheriting type is forced to implement. Like an abstract class, an interface can’t be instantiated directly (it’s not a class at all but rather a custom type). Its purpose is limited to forcing the implementation of its methods and properties. Unlike an abstract class, an interface can’t hold state.</span></p>
</aside>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h4 class="h1" id="sec26"><span id="h2-36"/><span class="sans_futura_std_bold_condensed_oblique_">Enum Classes</span></h4>
<p class="tni">An <i class="calibre9">enum</i> (short for <i class="calibre9">enumeration</i>) is a special kind of class that defines a finite set of constant values. Enums are typically used to represent a fixed set of related values, like days of the week, cardinal directions, status codes, playing card suits, and seasons. In Kotlin, we use the <span class="sans_thesansmonocd_w5regular_">enum class</span> keywords to define an enum, followed by the class name. Then comes a comma-separated list of the enum’s constants, enclosed in braces. Here’s an example of an enum in Kotlin:</p>
<pre class="calibre10"><code class="calibre11">// Define an enum class for days of the week.
enum class DayOfWeek {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
    FRIDAY, SATURDAY, SUNDAY
}

fun main() {
    // using the enum values
    val today = DayOfWeek.MONDAY

    when (today) {
        DayOfWeek.MONDAY -&gt; println("It's a manic Monday!")
        else -&gt; println("It's some other day.")
    }
}</code></pre>
<p class="tx">In this example, we defined an enum class called <span class="sans_thesansmonocd_w5regular_">DayOfWeek</span> representing the days of the week. The body of the class contains a comma-separated list of the enum’s constant values, which, by convention, are written in all caps. In the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we create a variable <span class="sans_thesansmonocd_w5regular_">today</span> and assign it the value <span class="sans_thesansmonocd_w5regular_">DayOfWeek.MONDAY</span> from the enum. Enum constants are always accessed this way, using dot notation that couples the enum class name with the specific <span aria-label="75" epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>constant name. We then use a <span class="sans_thesansmonocd_w5regular_">when</span> expression to check the value of <span class="sans_thesansmonocd_w5regular_">today</span> and print a message based on the day. The program should print <span class="sans_thesansmonocd_w5regular_">It's a manic Monday!</span> because <span class="sans_thesansmonocd_w5regular_">today</span> is set to <span class="sans_thesansmonocd_w5regular_">DayOfWeek.MONDAY</span>.</p>
<aside aria-label="box-14" class="box2">
<p class="boxtitle" id="box-14"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Create a simple game that involves different types of characters (wizards and warriors). Each character has a name, a level, and a set of abilities. Some characters can fly, while others can’t. This is an open-ended problem, so use your imagination!</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Create an abstract class called</span> <span class="sans_thesansmonocd_w5regular_">Character</span> <span class="sans_futura_std_book_">that defines the basic properties and methods of any character.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Create an interface called</span> <span class="sans_thesansmonocd_w5regular_">Flyable</span> <span class="sans_futura_std_book_">that defines a</span> <span class="sans_thesansmonocd_w5regular_">fly()</span> <span class="sans_futura_std_book_">method.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">3.  Create two subclasses of</span> <span class="sans_thesansmonocd_w5regular_">Character</span> <span class="sans_futura_std_book_">called</span> <span class="sans_thesansmonocd_w5regular_">Wizard</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">Warrior</span><span class="sans_futura_std_book_">. The</span> <span class="sans_thesansmonocd_w5regular_">Wizard</span> <span class="sans_futura_std_book_">class should implement the</span> <span class="sans_thesansmonocd_w5regular_">Flyable</span> <span class="sans_futura_std_book_">interface, while the</span> <span class="sans_thesansmonocd_w5regular_">Warrior</span> <span class="sans_futura_std_book_">class should not.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">4.  Create a</span> <span class="sans_thesansmonocd_w5regular_">Game</span> <span class="sans_futura_std_book_">class that creates instances of</span> <span class="sans_thesansmonocd_w5regular_">Wizard</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">Warrior</span> <span class="sans_futura_std_book_">and calls their respective methods.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">5.  Finally, create an instance of the</span> <span class="sans_thesansmonocd_w5regular_">Game</span> <span class="sans_futura_std_book_">class in the</span> <span class="sans_thesansmonocd_w5regular_">main()</span> <span class="sans_futura_std_book_">function and play the game.</span></p>
</div>
</aside>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="h" id="sec27"><span id="h1-24"/><span class="sans_futura_std_bold_b_">Copying Objects</span></h3>
<p class="tni">In many cases, you’ll need to copy an object, meaning you create a new instance of an object with the same or modified values compared to the original object. In Kotlin, you can create either a shallow copy or a deep copy of an object. The difference comes down to whether and how the original and the copy are connected. Which type of copy you use depends on the circumstances and the structure or complexity of the original object.</p>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="h1" id="sec28"><span id="h2-37"/><span class="sans_futura_std_bold_condensed_oblique_">Shallow Copy</span></h4>
<p class="tni">A <i class="calibre9">shallow copy</i> in Kotlin involves creating a new object that mirrors an existing one. However, the copy doesn’t fully replicate any nested objects within the original object. Instead, the copied object retains the same references to the nested objects as the original one. Therefore, a change to a nested object in the original version affects the copied version as well, and vice versa. As noted earlier, the <span class="sans_thesansmonocd_w5regular_">copy()</span> method that comes built in to any data class creates shallow copies.</p>
<p class="tx">To illustrate, say we define a <span class="sans_thesansmonocd_w5regular_">Person</span> data class with a <span class="sans_thesansmonocd_w5regular_">name</span> property and a <span class="sans_thesansmonocd_w5regular_">hobbies</span> property, the latter being a <span class="sans_thesansmonocd_w5regular_">MutableList&lt;String&gt;</span>. The <span class="sans_thesansmonocd_w5regular_">hobbies</span> property is considered to be nested, since a list of strings is itself an object within <span aria-label="76" epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>the overarching <span class="sans_thesansmonocd_w5regular_">Person</span> object. If we use the class’s built-in <span class="sans_thesansmonocd_w5regular_">copy()</span> method to copy a <span class="sans_thesansmonocd_w5regular_">Person</span> object, the copy will be shallow. The new instance will share the same list reference as the original one, so whether we modify the original list or the shallow-copied list, both instances of the data class will be affected. Here’s some code that demonstrates this behavior:</p>
<pre class="calibre10"><code class="calibre11">data class Person(val name: String,
                  val hobbies: MutableList&lt;String&gt;)
fun main() {
    val person1 = Person("Bob", mutableListOf("Reading", "Gaming"))
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val person2 = person1.copy()

    // Print both objects.
    println(person1)
    println(person2)

    // Add a new element to the mutable list of person1.
    person1.hobbies.add("Coding")

    // Print both objects again.
    println(person1)
    println(person2)
}</code></pre>
<p class="tx">We declare the <span class="sans_thesansmonocd_w5regular_">Person</span> data class as described and create two instances of the class. The first, <span class="sans_thesansmonocd_w5regular_">person1</span>, is instantiated from scratch, while <span class="sans_thesansmonocd_w5regular_">person2</span> is created by copying <span class="sans_thesansmonocd_w5regular_">person1</span> <span aria-label="annotation1" class="codeannotation">❶</span>. To see the implications of shallow copying, we print both objects, add one more hobby to the <span class="sans_thesansmonocd_w5regular_">person1</span> object’s <span class="sans_thesansmonocd_w5regular_">hobbies</span> list, and print both objects again. The code should generate the following output:</p>
<pre class="calibre10"><code class="calibre11">Person(name=Bob, hobbies=[Reading, Gaming])
Person(name=Bob, hobbies=[Reading, Gaming])
Person(name=Bob, hobbies=[Reading, Gaming, Coding])
Person(name=Bob, hobbies=[Reading, Gaming, Coding])</code></pre>
<p class="tx">Notice that even though we modified the <span class="sans_thesansmonocd_w5regular_">hobbies</span> property only of <span class="sans_thesansmonocd_w5regular_">person1</span>, <span class="sans_thesansmonocd_w5regular_">person2</span> was affected in the same way. This is because the <span class="sans_thesansmonocd_w5regular_">hobbies</span> property of <span class="sans_thesansmonocd_w5regular_">person2</span> isn’t a true clone; it references the same memory location as the <span class="sans_thesansmonocd_w5regular_">hobbies</span> property of <span class="sans_thesansmonocd_w5regular_">person1</span>. Keep in mind this applies only to nested objects; if we updated the <span class="sans_thesansmonocd_w5regular_">name</span> property of <span class="sans_thesansmonocd_w5regular_">person1</span>, the change would apply only to <span class="sans_thesansmonocd_w5regular_">person1</span>, since this property isn’t nested.</p>
<p class="tx">Shallow copying can be useful for performance optimization as it avoids duplicating large amounts of data and taking up additional memory space. But what if you need the two instances of the <span class="sans_thesansmonocd_w5regular_">Person</span> class to be entirely independent of each other? This is where deep copies come into play.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="h1" id="sec29"><span id="h2-38"/><span class="sans_futura_std_bold_condensed_oblique_">Deep Copy</span></h4>
<p class="tni">A <i class="calibre9">deep copy</i> creates a new, completely independent object from an existing object by copying all its nested objects as well as its nonnested properties. <span aria-label="77" epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/>This results in two separate and unrelated objects, so changes to one won’t affect the other. In Kotlin, you usually have to write a custom function tailored to the class at hand to make deep copies. Here’s a simple example:</p>
<pre class="calibre10"><code class="calibre11">data class Address(var street: String, val city: String)
data class Person(val name: String, val address: Address)

fun deepCopyPerson(person: Person): Person {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val clonedAddress = Address(person.address.street,
                                person.address.city)
    return Person(person.name, clonedAddress)
}

fun main() {
    val originalPerson = Person("Alice", Address("123 Main St", "Cityville"))
    val copiedPerson = deepCopyPerson(originalPerson)

    // Modify the original address.
    originalPerson.address.street = "456 Elm St"

    // Check if the copied address remains unchanged.
    println(originalPerson.address.street) // output: 456 Elm St
    println(copiedPerson.address.street)   // output: 123 Main St
}</code></pre>
<p class="tx">We declare two data classes, <span class="sans_thesansmonocd_w5regular_">Address</span> and <span class="sans_thesansmonocd_w5regular_">Person</span>. Notice how the <span class="sans_thesansmonocd_w5regular_">Person</span> class has an address property of type <span class="sans_thesansmonocd_w5regular_">Address</span>, meaning this property is a nested object. To achieve deep copying for the <span class="sans_thesansmonocd_w5regular_">Person</span> class, we declare a <span class="sans_thesansmonocd_w5regular_">deepCopyPerson()</span> function. The function first creates a new <span class="sans_thesansmonocd_w5regular_">Address</span> object by manually extracting the nested address properties from the original <span class="sans_thesansmonocd_w5regular_">Person</span> object <span aria-label="annotation1" class="codeannotation">❶</span>. Then it returns a new <span class="sans_thesansmonocd_w5regular_">Person</span> object containing the original object’s <span class="sans_thesansmonocd_w5regular_">name</span> property along with the deep-copied <span class="sans_thesansmonocd_w5regular_">Address</span> object.</p>
<p class="tx">In <span class="sans_thesansmonocd_w5regular_">main()</span>, we create a <span class="sans_thesansmonocd_w5regular_">Person</span> object, then use <span class="sans_thesansmonocd_w5regular_">deepCopyPerson()</span> to copy it. At that point, we can modify the <span class="sans_thesansmonocd_w5regular_">address</span> property of the original <span class="sans_thesansmonocd_w5regular_">Person</span> object and it won’t have any effect on the copy, since the nested object has been copied during the deep-copying process.</p>
<p class="tx">It’s also common to have to make a deep copy of a list of objects. This can be done with just one line of code by using the list’s <span class="sans_thesansmonocd_w5regular_">map()</span> method to call <span class="sans_thesansmonocd_w5regular_">copy()</span> on each object. Here’s how it works:</p>
<pre class="calibre10"><code class="calibre11">data class Person(var name: String, var age: Int)

fun main() {
    // original mutable list
    val originalList =
        mutableListOf(Person("Alice", 30), Person("Bob", 25))

    // Deep-copy the list using map() and copy().
    val deepCopyList =
        originalList.map{it.copy()}.toMutableList()
}</code></pre>
<p class="tx"><span aria-label="78" epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/>In this example, we have a mutable list of <span class="sans_thesansmonocd_w5regular_">Person</span> data class objects, where each <span class="sans_thesansmonocd_w5regular_">Person</span> has two properties: <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span>. We create a deep copy of the list using the <span class="sans_thesansmonocd_w5regular_">map()</span> method, which iterates through the elements of the original list, applies a function to each one, and stores the results in a new list. In this case, the applied function is the lambda expression <span class="sans_thesansmonocd_w5regular_">it.copy()</span>, which copies the current <span class="sans_thesansmonocd_w5regular_">Person</span> objects (this is possible because the <span class="sans_thesansmonocd_w5regular_">Person</span> class doesn’t have any nested objects). We chain a call to <span class="sans_thesansmonocd_w5regular_">toMutableList()</span> after the lambda, since <span class="sans_thesansmonocd_w5regular_">map()</span> results in a regular, read-only list rather than a mutable list.</p>
<p class="tx">I invite you to add a few more lines of code to the previous listing, modifying the properties of a <span class="sans_thesansmonocd_w5regular_">Person</span> object in the original list and then printing both lists. You should find that making changes to the original list doesn’t affect the copied list (and vice versa).</p>
<p class="headaexercise" id="pre-2"><span class="sans_dogma_ot_bold_b_15-n">Project 2: Build a Versatile Task Manager</span></p>
<p class="tni">Let’s apply what we’ve learned about data structures in this chapter to a simple project: we’ll create a console-based task manager application. The application will allow users to keep track of their daily tasks, with the following key functionalities:</p>
<ul class="ul">
<li class="listbullet">Adding tasks to the task list</li>
<li class="listbullet">Displaying a list of all the tasks</li>
<li class="listbullet">Marking a task as done</li>
<li class="listbullet">Deleting unwanted or completed tasks</li>
<li class="listbullet">Exiting the program</li>
</ul>
<p class="tx">Our primary challenge is to maintain a list of tasks. Since tasks can be added and removed, a mutable list is an appropriate structure. We also must decide on the attributes that define each task. We can encapsulate these in a data class. Additionally, we need to handle user interactions effectively, providing users with options and ensuring robust error handling for invalid inputs, concepts we touched on in <span><a href="chapter1.xhtml" class="calibre2">Chapter 1</a></span>.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="h1" id="sec30"><span id="h2-39"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Let’s start with a high-level overview of the program’s structural components before getting into the details of individual pieces and how they interact. Here’s an outline of the data structures, functions, and logic that we’ll need:</p>
<pre class="calibre10"><code class="calibre11">// macro view of the task manager program

data class Task(val title: String,
                val description: String,
                var status: String = "not done"
)

class TaskManager {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val taskList = mutableListOf&lt;Task&gt;()
<span aria-label="79" epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>    fun addTask(task: Task) {...}
    fun listTasks() {...}
    fun markTaskAsDone(taskIndex: Int) {...}
    fun deleteTask(taskIndex: Int) {...}
}

fun printOptions() {...}
fun readIndex(taskListSize: Int): Int? {...}

fun main() {
    val taskManager = TaskManager()

    while (true) {
        printOptions()
        when (readln()) {
            "1" -&gt; {...}
            "2" -&gt; {...}
            "3" -&gt; {...}
            "4" -&gt; {...}
            "5" -&gt; return   // breaks the while loop
            else -&gt; println("\nInvalid choice. Please try again.")
        }
    }
}</code></pre>
<p class="tx">The project comprises five main code blocks. First, the <span class="sans_thesansmonocd_w5regular_">Task</span> data class defines the structure of each individual task; each task will have a <span class="sans_thesansmonocd_w5regular_">title</span>, a <span class="sans_thesansmonocd_w5regular_">description</span>, and a <span class="sans_thesansmonocd_w5regular_">status</span> property set to <span class="sans_thesansmonocd_w5regular_">"not done"</span> by default. Next, the <span class="sans_thesansmonocd_w5regular_">TaskManager</span> class holds methods responsible for all task management work, like adding, listing, and deleting tasks. Notice its <span class="sans_thesansmonocd_w5regular_">taskList</span> property <span aria-label="annotation1" class="codeannotation">❶</span>, a mutable list for storing all the current tasks. Two stand-alone helper functions, <span class="sans_thesansmonocd_w5regular_">printOptions()</span> and <span class="sans_thesansmonocd_w5regular_">readIndex()</span>, support user interaction and input handling. Finally, the <span class="sans_thesansmonocd_w5regular_">main()</span> function oversees presenting options to the user and directing flow based on user choices.</p>
<p class="tx">We’ll now explore the <span class="sans_thesansmonocd_w5regular_">main()</span> function and its components in a top-down manner. As we go, we’ll implement the missing code blocks designated by <span class="sans_thesansmonocd_w5regular_">{...}</span> in the previous listing.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function begins by creating an instance of the <span class="sans_thesansmonocd_w5regular_">TaskManager</span> class named <span class="sans_thesansmonocd_w5regular_">taskManager</span>. This class, in turn, initializes a mutable list of type <span class="sans_thesansmonocd_w5regular_">Task</span> as its <span class="sans_thesansmonocd_w5regular_">taskList</span> property. This list starts out empty, but it’s a mutable list, so we can add or remove elements as needed.</p>
<p class="tx">Next, we invoke a <span class="sans_thesansmonocd_w5regular_">while</span> loop to repeatedly present the user with a menu of task management options and respond to the user’s requests. The loop’s condition is simply <span class="sans_thesansmonocd_w5regular_">true</span>, meaning it will repeat indefinitely unless the user chooses the option for exiting the program (more on this mechanism later). The first part of the loop is a call to the <span class="sans_thesansmonocd_w5regular_">printOptions()</span> function, defined here:</p>
<pre class="calibre10"><code class="calibre11">fun printOptions() {
    println("\nTask Manager Menu:")
    println("1. Add Task")
<span aria-label="80" epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/>    println("2. List Tasks")
    println("3. Mark Task as done")
    println("4. Delete Task")
    println("5. Exit")
    print("Enter your choice (1-5): ")
}</code></pre>
<p class="tx">The function simply displays the five available commands the user can enter, denoted by the numbers <span class="sans_thesansmonocd_w5regular_">1</span> through <span class="sans_thesansmonocd_w5regular_">5</span>.</p>
<section aria-labelledby="sec31" epub:type="division">
<h5 class="h2" id="sec31"><span id="h3-17"/><span class="sans_futura_std_bold_b_">Adding a Task</span></h5>
<p class="tni">After printing the options, the <span class="sans_thesansmonocd_w5regular_">while</span> loop uses a <span class="sans_thesansmonocd_w5regular_">when</span> expression to trigger the appropriate code based on which number was entered. Here’s a look at the <span class="sans_thesansmonocd_w5regular_">when</span> expression again, including the implementation of the <span class="sans_thesansmonocd_w5regular_">"1"</span> branch for adding a task:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> when (readln()) {
    "1" -&gt; {
        print("\nEnter task title: ")
        val title = readln()
        print("Enter task description: ")
        val description = readln()
      <span aria-label="annotation2" class="code_codeannotation">❷</span> val task = Task(title, description)
      <span aria-label="annotation3" class="code_codeannotation">❸</span> taskManager.addTask(task)
    }
    "2" -&gt; {...}
    "3" -&gt; {...}
    "4" -&gt; {...}
    "5" -&gt; break   // breaks the while loop
  <span aria-label="annotation4" class="code_codeannotation">❹</span> else -&gt; println("\nInvalid choice. Please try again.")
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">when</span> expression initiates by using <span class="sans_thesansmonocd_w5regular_">readln()</span> to take in a line of input (a string) from the console representing the user’s menu choice <span aria-label="annotation1" class="codeannotation">❶</span>. If the entered value doesn’t match any of the five options (<span class="sans_thesansmonocd_w5regular_">"1"</span>, <span class="sans_thesansmonocd_w5regular_">"2"</span>, <span class="sans_thesansmonocd_w5regular_">"3"</span>, <span class="sans_thesansmonocd_w5regular_">"4"</span>, or <span class="sans_thesansmonocd_w5regular_">"5"</span>), the <span class="sans_thesansmonocd_w5regular_">else</span> block within the <span class="sans_thesansmonocd_w5regular_">when</span> expression is triggered <span aria-label="annotation4" class="codeannotation">❹</span>, signaling to the user that their choice was invalid and they should make another selection.</p>
<p class="tx">When the user selects option <span class="sans_thesansmonocd_w5regular_">"1"</span>, the code block under <span class="sans_thesansmonocd_w5regular_">"1" -&gt;</span> is executed. Since this choice is associated with adding a task, the user is prompted to provide a task title and description. We use these input values (or empty strings if the user simply presses <small class="calibre12">ENTER</small>) to create a new instance of the <span class="sans_thesansmonocd_w5regular_">Task</span> data class <span aria-label="annotation2" class="codeannotation">❷</span>, which is then passed as an argument to the <span class="sans_thesansmonocd_w5regular_">taskManager</span> object’s <span class="sans_thesansmonocd_w5regular_">addTask()</span> method <span aria-label="annotation3" class="codeannotation">❸</span>. This method appends the task to the <span class="sans_thesansmonocd_w5regular_">taskList</span> mutable list, like this:</p>
<pre class="calibre10"><code class="calibre11">fun addTask(task: Task) {
    taskList.add(task)
}</code></pre>
<p class="tx">We call the list’s <span class="sans_thesansmonocd_w5regular_">add()</span> method to insert the new task at the end of the list.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<span aria-label="81" epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>
<h5 class="h2" id="sec32"><span id="h3-18"/><span class="sans_futura_std_bold_b_">Listing the Tasks</span></h5>
<p class="tni">When the user selects option <span class="sans_thesansmonocd_w5regular_">"2"</span> (listing the tasks), the code block under <span class="sans_thesansmonocd_w5regular_">"2"</span> <span class="sans_thesansmonocd_w5regular_">-&gt;</span> of the <span class="sans_thesansmonocd_w5regular_">when</span> expression is executed. This makes a call to the <span class="sans_thesansmonocd_w5regular_">list</span><span class="sans_thesansmonocd_w5regular_">Tasks()</span> method of the <span class="sans_thesansmonocd_w5regular_">taskManager</span> object:</p>
<pre class="calibre10"><code class="calibre11">when (readln()) {
<var class="calibre18">--snip--</var>
    "2" -&gt; taskManager.listTasks()</code></pre>
<p class="tx">Let’s take a look inside the <span class="sans_thesansmonocd_w5regular_">listTasks()</span> method, which is the second method defined in the <span class="sans_thesansmonocd_w5regular_">TaskManager</span> class:</p>
<pre class="calibre10"><code class="calibre11">fun listTasks() {
    if (taskList.size &gt; 0) {
        println("\nTasks:")
        for ((index, task) in taskList.withIndex()) {
          <span aria-label="annotation1" class="code_codeannotation">❶</span> println("${index+1}. ${task.title} - " +
                    "${task.description} - ${task.status}")
        }
    } else
        println("Task list is empty.")

}</code></pre>
<p class="tx">Inside <span class="sans_thesansmonocd_w5regular_">listTasks()</span>, we first check if the <span class="sans_thesansmonocd_w5regular_">taskList</span> has any tasks. If it does, we iterate over the tasks and print them out, showing their indices, titles, descriptions, and completion statuses. While Kotlin lists are indexed from 0, most humans think of the first item in a list as item 1, so we add 1 to each index before printing it <span aria-label="annotation1" class="codeannotation">❶</span>. If the task list is empty, we print a simple message indicating this.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h5 class="h2" id="sec33"><span id="h3-19"/><span class="sans_futura_std_bold_b_">Marking a Task as Done</span></h5>
<p class="tni">When the user selects option <span class="sans_thesansmonocd_w5regular_">"3"</span> to mark a task as done, the code block under <span class="sans_thesansmonocd_w5regular_">"3"</span> <span class="sans_thesansmonocd_w5regular_">-&gt;</span> is executed, as shown here:</p>
<pre class="calibre10"><code class="calibre11">when (readln()) {
<var class="calibre18">--snip--</var>
    "3" -&gt; {
        taskManager.listTasks()
      <span aria-label="annotation1" class="code_codeannotation">❶</span> if (taskManager.taskList.size &lt;= 0) {
            continue
        } else {
            print("\nEnter the task number to mark as done: ")
          <span aria-label="annotation2" class="code_codeannotation">❷</span> val taskNumber =
                readIndex(taskManager.taskList.size)
            if (taskNumber != null) {
                taskManager.markTaskAsDone(taskNumber -1)
            }
        }
    }</code></pre>
<p class="tx"><span aria-label="82" epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>Within this code block, we first call the <span class="sans_thesansmonocd_w5regular_">listTasks()</span> method to display the current list of tasks. Then, if <span class="sans_thesansmonocd_w5regular_">taskList</span> is found to be empty <span aria-label="annotation1" class="codeannotation">❶</span>, the program will continue, meaning the remaining code will be skipped, the overarching <span class="sans_thesansmonocd_w5regular_">while</span> loop will restart, and the user will be presented with the menu options again. Otherwise, the user is prompted to select a task by its index, from the displayed list of tasks. We process the user input using the <span class="sans_thesansmonocd_w5regular_">readIndex()</span> function <span aria-label="annotation2" class="codeannotation">❷</span>, which validates the data as follows:</p>
<pre class="calibre10"><code class="calibre11">fun readIndex(taskListSize: Int): Int? {
    val input = readln()
  <span aria-label="annotation1" class="code_codeannotation">❶</span> if (input.isBlank()) {
        println("Invalid input. Please enter a valid task number.")
        return null
    }

  <span aria-label="annotation2" class="code_codeannotation">❷</span> val taskNumber = input.toIntOrNull()
    if (taskNumber != null &amp;&amp; taskNumber &gt;= 1 &amp;&amp;
                         taskNumber &lt;= taskListSize) {
        return taskNumber
    } else {
        println("Invalid task number. Please enter a valid task number.")
        return null
    }
}</code></pre>
<p class="tx">In this code, we initially read a line of text from the console. If the input is empty <span aria-label="annotation1" class="codeannotation">❶</span>, we display an <span class="sans_thesansmonocd_w5regular_">Invalid input</span> message, and a <span class="sans_thesansmonocd_w5regular_">null</span> value is returned. This <span class="sans_thesansmonocd_w5regular_">null</span> return value will result in no task being marked as done.</p>
<p class="tx">If the input isn’t empty, we convert it to the <span class="sans_thesansmonocd_w5regular_">IntOrNull</span> type <span aria-label="annotation2" class="codeannotation">❷</span>. Then we perform further checks to ensure that the <span class="sans_thesansmonocd_w5regular_">Int</span> value is greater than or equal to <span class="sans_thesansmonocd_w5regular_">1</span> and less than or equal to the size of the <span class="sans_thesansmonocd_w5regular_">taskList</span> (which was passed as an argument to the function). If these conditions are met, the user’s input value is returned; otherwise, we return <span class="sans_thesansmonocd_w5regular_">null</span>, which again will skip the remainder of the option <span class="sans_thesansmonocd_w5regular_">"3"</span> code.</p>
<p class="tx">Returning to the <span class="sans_thesansmonocd_w5regular_">when</span> expression’s <span class="sans_thesansmonocd_w5regular_">"3"</span> branch, if the user input is valid and not <span class="sans_thesansmonocd_w5regular_">null</span>, we call the <span class="sans_thesansmonocd_w5regular_">markTaskAsDone()</span> method from the <span class="sans_thesansmonocd_w5regular_">TaskManager</span> class, passing in <span class="sans_thesansmonocd_w5regular_">taskNumber - 1</span> as an argument (remember, we added 1 to each task’s index number before displaying the tasks to the user). The method is defined here:</p>
<pre class="calibre10"><code class="calibre11">fun markTaskAsDone(taskIndex: Int) {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> if (taskIndex in taskList.indices) {
        taskList[taskIndex].status = "done"
    } else {
        println("Invalid task index. Task not found.")
    }
}</code></pre>
<p class="tx"><span aria-label="83" epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>We verify whether the <span class="sans_thesansmonocd_w5regular_">taskIndex</span> parameter falls within the valid range of indices in the <span class="sans_thesansmonocd_w5regular_">taskList</span>, which we access using the list’s built-in <span class="sans_thesansmonocd_w5regular_">indices</span> property <span aria-label="annotation1" class="codeannotation">❶</span>. If <span class="sans_thesansmonocd_w5regular_">taskIndex</span> is within this range, we set the <span class="sans_thesansmonocd_w5regular_">status</span> property of the corresponding task to <span class="sans_thesansmonocd_w5regular_">"done"</span>. The <span class="sans_thesansmonocd_w5regular_">else</span> block in this method, which handles the case when the <span class="sans_thesansmonocd_w5regular_">taskIndex</span> is out of range, is included for potential unforeseen circumstances, even though it isn’t strictly necessary since the <span class="sans_thesansmonocd_w5regular_">readIndex()</span> function has already verified that the chosen index is within the valid range of indices.</p>
</section>
<section aria-labelledby="sec34" epub:type="division">
<h5 class="h2" id="sec34"><span id="h3-20"/><span class="sans_futura_std_bold_b_">Deleting a Task</span></h5>
<p class="tni">When the user selects option <span class="sans_thesansmonocd_w5regular_">"4"</span> to delete a task, the code block under <span class="sans_thesansmonocd_w5regular_">"4"</span> <span class="sans_thesansmonocd_w5regular_">-&gt;</span> in the <span class="sans_thesansmonocd_w5regular_">when</span> expression is executed, as shown here:</p>
<pre class="calibre10"><code class="calibre11">when (readln()) {
<var class="calibre18">--snip--</var>
    "4" -&gt; {
        taskManager.listTasks()
        if (taskManager.taskList.size &lt;= 0) {
            continue
        } else {
            print("\nEnter the task number to be deleted: ")
            val taskNumber =
                readIndex(taskManager.taskList.size)
            if (taskNumber != null) {
                taskManager.deleteTask(taskNumber - 1)
            }
        }
    }</code></pre>
<p class="tx">This code block is nearly identical to the one for option <span class="sans_thesansmonocd_w5regular_">"3"</span>: we display the task list, skip the remainder of the code if the list is empty, and otherwise take in a task number from the user with the <span class="sans_thesansmonocd_w5regular_">readIndex()</span> function. The difference is that for a valid, nonnull input, we call the <span class="sans_thesansmonocd_w5regular_">deleteTask()</span> method from the <span class="sans_thesansmonocd_w5regular_">TaskManager</span> class rather than the <span class="sans_thesansmonocd_w5regular_">markTaskAsDone()</span> method. Here’s the <span class="sans_thesansmonocd_w5regular_">deleteTask()</span> definition:</p>
<pre class="calibre10"><code class="calibre11">fun deleteTask(taskIndex: Int) {
    if (taskIndex in taskList.indices) {
        taskList.removeAt(taskIndex)
    } else {
        println("Invalid task index. Task not found.")
    }
}</code></pre>
<p class="tx">This time, if <span class="sans_thesansmonocd_w5regular_">taskIndex</span> is within the valid range, we use <span class="sans_thesansmonocd_w5regular_">removeAt()</span> to delete the corresponding task from <span class="sans_thesansmonocd_w5regular_">taskList</span>.</p>
</section>
<section aria-labelledby="sec35" epub:type="division">
<span aria-label="84" epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>
<h5 class="h2" id="sec35"><span id="h3-21"/><span class="sans_futura_std_bold_b_">Exiting the Program</span></h5>
<p class="tni">The last available option is <span class="sans_thesansmonocd_w5regular_">"5"</span>, to exit the program. This triggers the <span class="sans_thesansmonocd_w5regular_">"5" -&gt;</span> branch of the <span class="sans_thesansmonocd_w5regular_">when</span> expression, which terminates the <span class="sans_thesansmonocd_w5regular_">while</span> loop and returns the program flow to outside the loop:</p>
<pre class="calibre10"><code class="calibre11">when (readln()) {
<var class="calibre18">--snip--</var>
    "5" -&gt; break   // breaks the while loop</code></pre>
<p class="tx">As no more code remains to execute in the <span class="sans_thesansmonocd_w5regular_">main()</span> function after the <span class="sans_thesansmonocd_w5regular_">while</span> loop, disrupting the loop results in the program terminating normally.</p>
</section>
</section>
<section aria-labelledby="sec36" epub:type="division">
<h4 class="h1" id="sec36"><span id="h2-40"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Try launching and experimenting with the task manager program for an extended period. Here’s some sample output for various arbitrary choices I made while trying out the program:</p>
<pre class="calibre10"><code class="calibre11">Task Manager Menu:
1. Add Task
2. List Tasks
3. Mark Task as done
4. Delete Task
5. Exit
Enter your choice (1-5): <b class="calibre6">1</b>

Enter task title: <b class="calibre6">Task 1</b>
Enter task description: <b class="calibre6">Reply to Nathan's email</b>

Task Manager Menu:
1. Add Task
2. List Tasks
3. Mark Task as done
4. Delete Task
5. Exit
Enter your choice (1-5): <b class="calibre6">1</b>

Enter task title: <b class="calibre6">Task 2</b>
Enter task description: <b class="calibre6">Complete Chapter 2 by this weekend</b>

Task Manager Menu:
1. Add Task
2. List Tasks
3. Mark Task as done
4. Delete Task
5. Exit
Enter your choice (1-5): <b class="calibre6">2</b>

Tasks:
1. Task 1 – Reply to Nathan's email - not done
2. Task 2 – Complete Chapter 2 by this weekend - not done</code></pre>
<p class="tx"><span aria-label="85" epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>The output you’ll see will likely be different because your choices will differ from mine. Despite its somewhat limited capabilities, this program successfully integrates some of the fundamental features found in real task management tools. We’ve accomplished all of this with just around 110 lines of Kotlin code, while using structures like mutable lists and classes with their own properties and methods to keep the code organized.</p>
<aside aria-label="box-15" class="box2">
<p class="boxtitle" id="box-15"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Try expanding the features of the task manager application we developed in <a href="chapter2.xhtml#pre-2" class="calibre2">Project 2</a> to turn it into a program that you can use to manage your own tasks. Here are some suggested improvements to try:</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">The main limitation of the task manager program is that it doesn’t save the list of tasks for future use. Once you exit the program, all information is lost. Use the file input/output methods we discussed in <a href="chapter1.xhtml" class="calibre2">Chapter 1</a> to add a feature that allows the user to save the data before exiting and reload the data the next time they launch the program. You can also allow the user to choose which saved datafile to use, which would allow multiple users to save and work with their own files.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Add more attributes to the</span> <span class="sans_thesansmonocd_w5regular_">Task</span> <span class="sans_futura_std_book_">data class so you can store additional information about each task. Extra attributes might include a due date, a task priority level, and a task reminder. The last feature can be added by changing the value of the</span> <span class="sans_thesansmonocd_w5regular_">status</span> <span class="sans_futura_std_book_">property to</span> <span class="sans_thesansmonocd_w5regular_">"Overdue"</span> <span class="sans_futura_std_book_">when the due date has passed (based on the current date).</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Add further functionalities to the program. Among the many possibilities, you can try adding the following: the ability to edit a task’s description; the ability to sort tasks based on priority, due date, or status (for example, not started, in progress, or done); and the ability to search and filter tasks using keywords in the title or description.</span></li>
</ul>
<p class="boxlast"><span class="sans_futura_std_book_">Adding these features won’t just make the program more useful; it will also hugely improve your coding skills in Kotlin and strengthen your ability to plan and implement a complete project with multiple interactive components.</span></p>
</aside>
</section>
</section>
<section aria-labelledby="sec37" epub:type="division">
<h3 class="h" id="sec37"><span id="h1-25"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, we explored essential aspects of data manipulation and object-oriented programming. We began with arrays, which store values of a specific type or its subtypes. Arrays are rigid in size but can have their values modified. Lists, in contrast, are immutable in both content and size, though mutable lists offer flexibility when needed. Lists are a type of collection, along with sets and maps.</p>
<p class="tx"><span aria-label="86" epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/>We ventured into the world of user-defined classes, which store data in the form of properties, along with methods for manipulating that data. We saw how encapsulation safeguards data within a class, while inheritance and polymorphism enable code reuse and modular design. We also covered topics like abstract classes, data classes, interfaces, and enum classes, each of which has distinct roles and advantages. For example, an abstract class provides a higher-level framework (superclass) for a group of related classes, whereas an interface enforces a consistent implementation of methods and properties across all inheriting types.</p>
<p class="tx">You learned these concepts through examples and exercises, reinforcing your understanding. The chapter culminated in a practical project in which you studied and then transformed a text-based task manager into a versatile tool (assuming you completed the exercise).</p>
<p class="tx">This chapter, along with <span><a href="chapter1.xhtml" class="calibre2">Chapter 1</a></span> on Kotlin basics, equips you with the essential concepts and foundational knowledge necessary to begin an exciting journey into the world of Kotlin applications. You’re now well prepared to explore a wide array of fun and progressively complex challenges in the fields of mathematics, science, modeling, algorithms, and optimization. First, though, we’ll explore the basics of data visualization with JavaFX, a tool we’ll use in many of our upcoming projects.</p>
</section>
<section aria-labelledby="sec38" epub:type="division">
<h3 class="h" id="sec38"><span id="h1-26"/><span class="sans_futura_std_bold_b_">Resource</span></h3>
<p class="reference">Kotlin. “Kotlin Docs.” (The official Kotlin documentation.) Accessed June 15, 2024. <i class="calibre9"><a href="https://kotlinlang.org/docs/home.xhtml" class="calibre2">https://kotlinlang.org/docs/home.xhtml</a></i>.</p>
</section>
</section>
</div></body></html>