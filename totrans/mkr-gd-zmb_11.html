<html><head></head><body>
<h2 class="h2" id="ch11"><a id="page_209"/><strong>11</strong></h2>
<p class="h2a"><strong>HAPTIC COMMUNICATION</strong></p>
<div class="image1"><img src="graphics/f0001-01.jpg" alt="image"/></div>
<p class="noindent">If you’re out on a supply run, then you’ll definitely want this silent communication device, which uses trembling buzzer motors and radio modules to send two-way messages. With this final project, you can communicate without attracting unwanted attention.</p>
<h3 class="h3" id="ch00lev1sec206"><strong>PROJECT 20: SILENT HAPTIC COMMUNICATION WITH ARDUINO</strong></h3>
<p class="noindent">The problem with walkie-talkies is that, as the name suggests, they require talking. Zombies have very acute hearing for human speech and will easily home in on any desperate request for backup that you shriek into a walkie-talkie. This is where a silent two-way haptic communication device comes into its own (see <a href="ch11.html#ch11fig1">Figure 11-1</a>).</p>
<div class="image"><a id="page_210"/><img src="graphics/f11-01.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig1">Figure 11-1:</a> “When the sign said ‘press for attention,’ this wasn’t what I thought it meant!”</p>
<p class="indent"><em>Haptic</em> is just a fancy way of saying “relating to touch,” and instead of making noise, the devices you’ll build in this project will vibrate like a cell phone. You will make a pair of these haptic devices, one of which is shown in <a href="ch11.html#ch11fig2">Figure 11-2</a>.</p>
<p class="indent">Each device has a push-button switch and a small buzzer motor of the sort you find in cell phones. When you press the button on one handset, it causes the buzzer on the other handset to vibrate, and vice versa. The whole thing is powered by a 9V battery.</p>
<p class="indent">Then when you are out and about, you can get in touch with your partner using a set of prearranged signals: one short buzz means, “I’m OK”; one long buzz means. “Come quickly, I’m about to be eaten!” In your free time (which has probably increased now that your old school or office is full of zombies), you could even memorize the Morse code you used in “<a href="ch10.html#ch00lev1sec196">Project 19: Arduino Morse Code Beacon</a>” on <a href="ch10.html#page_196">page 196</a> and send more detailed messages.</p>
<div class="image"><a id="page_211"/><img src="graphics/f11-02.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig2">Figure 11-2:</a> A haptic communicator</p>
<h4 class="h4" id="ch00lev1sec207"><strong>WHAT YOU WILL NEED</strong></h4>
<p class="noindentb">To make this pair of haptic communicators, you’ll need the following parts:</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<th valign="top" class="table_th"><p class="table1"><strong>ITEMS</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>NOTES</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>SOURCE</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Arduinos</p></td>
<td valign="top" class="table"><p class="table">2 x Arduino Uno R3</p></td>
<td valign="top" class="table"><p class="table">Adafruit, Fry’s (7224833), SparkFun</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Protoshields</p></td>
<td valign="top" class="table"><p class="table">2 x Arduino Protoshield PCB</p></td>
<td valign="top" class="table"><p class="table">eBay (Arduino code: A000077)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Header pins</p></td>
<td valign="top" class="table"><p class="table">Header pins 64 way in total (for 2 handsets)</p></td>
<td valign="top" class="table"><p class="table">Adafruit (392), eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> 9V battery leads</p></td>
<td valign="top" class="table"><p class="table">2 x Arduino 9V battery leads</p></td>
<td valign="top" class="table"><p class="table">Adafruit (80), eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> 9V batteries</p></td>
<td valign="top" class="table"><p class="table">2 x PP3 batteries</p></td>
<td valign="top" class="table"><p class="table">Hardware store</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> R1</p></td>
<td valign="top" class="table"><p class="table">2 x 1 kΩ resistor</p></td>
<td valign="top" class="table"><p class="table">Mouser (293-1k-RC)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Transistors</p></td>
<td valign="top" class="table"><p class="table">2 x 2N3904 NPN bipolar transistor</p></td>
<td valign="top" class="table"><p class="table">Adafruit (756)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Vibration motors</p></td>
<td valign="top" class="table"><p class="table">2 x 5V or 3V vibration motor</p></td>
<td valign="top" class="table"><p class="table">eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Tactile switch</p></td>
<td valign="top" class="table"><p class="table">2 x tactile push switch</p></td>
<td valign="top" class="table"><p class="table">Adafruit (504)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> RF modules</p></td>
<td valign="top" class="table"><p class="table">2 x NRF24 RF modules</p></td>
<td valign="top" class="table"><p class="table">eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Assorted hookup wire</p></td>
<td valign="top" class="table"><p class="table">Stranded wire</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Wire</p></td>
<td valign="top" class="table"><p class="table">Insulated solid-core wire for making PCB connections</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_212"/>You might also want to enclose your communicators in plastic boxes to protect them from the elements. If you choose to do so, then you will need to find something big enough to contain the Arduino, protoshield, and battery. It will also need a hole so that you can press the button and add an on/off switch.</p>
<p class="indent">Electronically, this is probably the most complicated project so far. You might struggle to find all the parts after a zombie apocalypse, as some, like the vibration motors and the RF modules, are best bought off eBay or Amazon. So make this project now, before the postal service un-dies. Vibration motors can also be scavenged from cellphones.</p>
<h4 class="h4" id="ch00lev1sec208"><strong>CONSTRUCTION</strong></h4>
<p class="noindent">These instructions will tell you how to make one haptic module, and <a href="ch11.html#ch11fig3">Figure 11-3</a> shows the schematic for one communicator. Of course, to communicate with someone else, you will need to make two devices.</p>
<div class="image"><img src="graphics/f11-03.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig3">Figure 11-3:</a> The schematic for one haptic communicator</p>
<p class="indent"><a id="page_213"/>Pin 2 of the Arduino will be set up as a digital input with internal pullup resistor enabled, connected to the push button S1. When the button is pressed, the Arduino will control the NRF24 radio module to send a message to the other handset, activating its vibration motor.</p>
<p class="indent">The vibration motor is controlled from pin D5 of the Arduino. We use a transistor (T1) because the motor uses more current than the Arduino output can cope with by itself, and the 5V supply is used because the 3V supply cannot provide enough current. Pin D5 is controlled as an analog output to manage the level of vibration with the software, keeping the device as quiet as possible; this also prevents the motor from burning out, as most vibration motors are 3V rather than the 5V the Arduino usually uses.</p>
<p class="indent">Note that strictly speaking, the motor should be accompanied by a diode to protect the Arduino from current spikes from the motor, but a little testing with one of these tiny motors showed that a very minimal amount of noise was added to the Arduino supply rails. So for the sake of keeping things simple the normal diode was omitted.</p>
<p class="indent">This project uses a protoshield rather than the screwshields used in most of the projects in this book. A protoshield is like a screwshield but without its screw terminals and hence is a bit cheaper and smaller.</p>
<h5 class="h5" id="ch00lev1sec209"><strong>STEP 1: ASSEMBLE THE PROTOSHIELD</strong></h5>
<p class="noindent">Protoshields sometimes come with a full set of extra components, such as reset switches and header pins, but for this project you don’t want glowing power LEDs that might attract unwanted attention. Therefore, it’s better (and cheaper) to buy the bare Protoshield PCB and some headers.</p>
<p class="indent">Solder the header pins to the outermost rows of holes on each side of the PCB. A good way to keep the header pins straight is to put them into an Arduino and then put the Protoshield PCB on top of the headers. When all the pins are attached, the protoshield should look something like <a href="ch11.html#ch11fig4">Figure 11-4</a>.</p>
<div class="image"><img src="graphics/f11-04.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig4">Figure 11-4:</a> A protoshield with header pins attached</p>
<h5 class="h5" id="ch00lev1sec210"><a id="page_214"/><strong>STEP 2: FIX THE COMPONENTS IN POSITION</strong></h5>
<p class="noindent">Use <a href="ch11.html#ch11fig5">Figure 11-5</a> as a reference for the location of the components. All the connections to the NRF24 module are to the 2×4 header on the right of the module’s PCB. Don’t solder the vibration motor just yet; it will need to be glued in place first as the leads are a bit delicate.</p>
<div class="image"><img src="graphics/f11-05.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig5">Figure 11-5:</a> The protoshield layout, where R1 is the resistor, S1 is the switch, T1 is the transistor, and the dark rectangle at the top left is the NRF24</p>
<p class="indent">Apart from the two wires coming from the motor, the dark lines going to various solder pads in <a href="ch11.html#ch11fig5">Figure 11-5</a> represent connections you’ll make on the underside of the board. The header pins of the NRF24 module fit through the holes in the protoshield, so place that now and solder it to the pads beneath. Do not clip the excess pin lengths off but instead gently splay them out after soldering; this will make it easier to connect them up later. Note that one pin on the NRF24 module is not used.</p>
<p class="indent">The transistor has one curved side. It is important that this goes onto the protoshield the right way around, with the curved side pointing left toward the NRF24 (use <a href="ch11.html#ch11fig4">Figure 11-4</a> as a guide). Leave about 1/3 inches (about 7.5 mm) of the transistor lead on the top side of the screwshield and fold it down (<a href="ch11.html#ch11fig5">Figure 11-5</a>) to solder.</p>
<p class="indent">The switch has contacts that are on a rectangular grid, four holes long one way and three holes the other. Make sure the switch goes the right way around (<a href="ch11.html#ch11fig4">Figure 11-4</a>) so that it is longer vertically.</p>
<p class="indent">Do not clip off any wires yet, as these can be used to link up the components on the underside of the board. When all the components have been fixed in place, the board should look something like <a href="ch11.html#ch11fig6">Figure 11-6</a>.</p>
<div class="image"><a id="page_215"/><img src="graphics/f11-06.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig6">Figure 11-6:</a> The components attached to the protoshield</p>
<h5 class="h5" id="ch00lev1sec211"><strong>STEP 3: WIRE THE UNDERSIDE OF THE BOARD</strong></h5>
<p class="noindent">This step is the fiddliest, so take care with it. All the components need to be connected on the underside of the board (<a href="ch11.html#ch11fig5">Figure 11-5</a>). Of course, when the board is flipped over, everything is reversed. In <a href="ch11.html#ch11fig7">Figure 11-7</a>, I’ve transposed <a href="ch11.html#ch11fig5">Figure 11-5</a> to show the underside of the board for you to work from.</p>
<div class="image"><img src="graphics/f11-07.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig7">Figure 11-7:</a> Wiring diagram from the underside of the protoshield</p>
<p class="indent"><a href="ch11.html#ch11fig7">Figure 11-7</a> marks the positions of the components so that you can orient yourself, but remember that this is the underside of the board, so the components are actually on the other side of the protoshield.</p>
<p class="indent"><a id="page_216"/>Many of the connecting wires cross over each other, so use insulated solid-core wire. When everything is connected, the underside of the board should look like <a href="ch11.html#ch11fig8">Figure 11-8</a>.</p>
<div class="image"><img src="graphics/f11-08.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig8">Figure 11-8:</a> The underside of the protoshield</p>
<p class="indent">Double-check everything very carefully to make sure there are no accidental solder connections and that every wire makes the correct connection.</p>
<h5 class="h5" id="ch00lev1sec212"><strong>STEP 4: ATTACH THE VIBRATION MOTOR</strong></h5>
<p class="noindent">Glue the motor to the <em>top</em> of the protoshield, being careful not to get glue on the rotating bit at the front of the motor. The leads are quite fine, so it’s better to solder them to the top of the board rather than through a hole. <a href="ch11.html#ch11fig9">Figure 11-9</a> shows the motor glued in place and the leads soldered to the protoshield.</p>
<div class="image"><img src="graphics/f11-09.jpg" alt="image"/></div>
<p class="figuret"><a id="ch11fig9">Figure 11-9:</a> Attaching the vibration motor</p>
<h5 class="h5" id="ch00lev1sec213"><a id="page_217"/><strong>STEP 5: REPEAT FOR THE OTHER HANDSET</strong></h5>
<p class="noindent">Having built one handset, do the whole lot again for its partner.</p>
<h5 class="h5" id="ch00lev1sec214"><strong>STEP 6: PLACING IT INTO AN ENCLOSURE</strong></h5>
<p class="noindent">You may want to scavenge for some small plastic boxes to contain the handsets. Alternatively, you might prefer to go postapocalypse chic and just tape the battery to the Arduino and protoshield, leaving the battery clip accessible as a rudimentary switch.</p>
<h4 class="h4" id="ch00lev1sec215"><strong>SOFTWARE</strong></h4>
<p class="noindent">All the source code for this book is available from <em><a href="http://www.nostarch.com/zombies/">http://www.nostarch.com/zombies/</a></em>. See <a href="app03.html#app03">Appendix C</a> for instructions on installing the Arduino sketch for this project, which is called <em>Project_20_Haptic_Communicator</em>.</p>
<p class="indent">This project uses a community-maintained Arduino library called <em>Mirf</em>. This library provides an easy-to-use wrapper around the Serial Peripheral Interface (SPI) serial interface to the NRF24 radio module, allowing the Arduino to communicate with the module. The Mirf library must be downloaded from the Internet, which is another good reason to make this project before the outbreak spreads too far. Download the ZIP file for the library from <em><a href="http://playground.arduino.cc/InterfacingWithHardware/Nrf24L01">http://playground.arduino.cc/InterfacingWithHardware/Nrf24L01</a></em>.</p>
<p class="indent">Extract the ZIP file and copy the whole <em>Mirf</em> folder into <em>My Documents\Arduino\Libraries</em> if you’re using Windows or <em>Documents/Arduino/libraries</em> if you’re using a Mac or Linux. Note that if the <em>libraries</em> folder doesn’t exist within the Arduino directory, you’ll need to create it before copying.</p>
<p class="indent">The Arduino IDE won’t recognize the new library until you restart it, so after copying the <em>library</em> folder, save anything you’re working on, quit the IDE, and restart. Next, open the sketch file for this project and upload it to both Arduinos, one after the other. The sketch starts by importing three libraries:</p>
<pre>#include &lt;SPI.h&gt;<br/>#include &lt;Mirf.h&gt;<br/>#include &lt;MirfHardwareSpiDriver.h&gt;</pre>
<p class="indent">The SPI library is part of the Arduino IDE distribution and simplifies communication with devices using SPI. The MirfHardwareSpiDriver library is also used in the sketch.</p>
<p class="indent">Next, three constants are defined:</p>
<pre>const int numberOfSends = 3;<br/>const int buzzerPin = 5;<br/>const int switchPin = 2;</pre>
<p class="indent"><a id="page_218"/>The range of wireless communication can be extended by sending the “button pressed” message several times, so that at the edge of the range, only one of the messages has to get through. The constant <code>numberOfSends</code> defines how many times each message should be sent. This is followed by pin definitions for the buzzer and switch pins.</p>
<p class="indent">The next constant (<code>buzzerVolume</code>) specifies the <code>analogWrite</code> value for the vibration motor:</p>
<pre>const int buzzerVolume = 100; // Keep less than 153 for 3V!<br/>const int buzzMinDuration = 20;</pre>
<p class="indent">If you are using a 3V motor, it is important that the <code>analogWrite</code> value does not exceed 153; a value of 153 will deliver power equivalent to a 3V supply to the motor, and more power would overload it. Reducing this value will make your buzzer quieter. The <code>buzzMinDuration</code> constant specifies the minimum duration for a buzz in milliseconds. This is important because too short a buzz may not be noticed.</p>
<p class="indent">The global <code>byte data</code> array contains a 4-byte message to be sent whenever the button is pressed:</p>
<pre>byte data[] = {0x54, 0x12, 0x01, 0x00};</pre>
<p class="indent">The first three values in this array are chosen as being unique for the pair of haptic communicators. When a message is received, they are checked to see whether they match. This ensures that the communicator has received a real message and not just noise. It also means that you could set up a second pair of devices using different values, and the new pair would not interfere with this pair. Depending on the group dynamics in your band of survivors, you might want to communicate with one person in some situations (“Come save me!”) and another person in other situations (“If you show up now, I bet the zombie will eat your brains and not mine”).</p>
<p class="indent">The fourth byte is not used in this project, but it’s there in case you would like the button-press messages to send a parameter. You could, for example, add a second button to the communicator for emergencies that sends a different value in this byte, which could then be read at the receiving end.</p>
<p class="indent">Next is the <code>setup</code> function:</p>
<pre>void setup()<br/>{<br/>  analogWrite(buzzerPin, 0);<br/>  pinMode(switchPin, INPUT_PULLUP);<br/>  Mirf.spi = &amp;MirfHardwareSpi;<br/>  Mirf.init();<br/><a id="page_219"/><br/>  listenMode();<br/>  Mirf.payload = 4;<br/>  Mirf.config();<br/>}</pre>
<p class="indent">This function starts by making sure the buzzer is off at <code>analogWrite</code>. Then it sets the mode of the <code>switchPin</code> to an input with the internal pull-up resistor enabled (see “<a href="app03.html#ch00lev1sec247">Stabilizing Digital Inputs with Pull-up Resistors</a>” on <a href="app03.html#page_252">page 252</a> for more information on pull-up resistors). The radio module is then initialized and put into listen mode, waiting to receive a message.</p>
<p class="indent">Next comes the <code>loop</code> function:</p>
<pre>void loop()<br/>{ <br/>  if (!Mirf.isSending() &amp;&amp; Mirf.dataReady())<br/>  {<br/>    Mirf.getData(data);<br/>    checkForBuzz();<br/>  }<br/>  if (digitalRead(switchPin) == LOW)<br/>  {<br/>          sendBuzz(); <br/>  }<br/>}</pre>
<p class="indent">This starts with an <code>if</code> statement that first checks whether the module is itself sending a message. It then checks whether there is data ready to be read, and it reads the message over the radio. Once the message is read, the function <code>checkForBuzz</code> is called to check that the message is legitimate before buzzing the vibration motor.</p>
<p class="indent">The <code>loop</code> function finally checks for a button press on this end and responds to a button press by calling the <code>sendBuzz</code> function.</p>
<p class="indent">Now, let’s look at the other functions defined in this sketch, starting with <code>listenMode</code> and <code>sendMode</code>:</p>
<pre>void listenMode()<br/>{<br/>  Mirf.setRADDR((byte *)"serv1");<br/>}<br/>void sendMode()<br/>{<br/>  Mirf.setRADDR((byte *)"clie1");<br/>}</pre>
<p class="indent">The <code>listenMode</code> function puts the radio module into listening mode by setting its receive address to <code>"serv1"</code>. The <code>sendMode</code> function puts the radio <a id="page_220"/>module into sending mode by setting its receive address to <code>"clie1"</code>. We call both the <code>listenMode</code> function and the <code>sendMode</code> function inside <code>sendBuzz</code>, which gets called in the <code>loop</code> function’s last <code>if</code> statement.</p>
<p class="indent">Finally, we have the <code>checkForBuzz</code> function:</p>
<pre>void checkForBuzz()<br/>{<br/>  if (data[0]==0x54 &amp;&amp; data[1]==0x12 &amp;&amp; data[2]==0x01)<br/>  {<br/>    analogWrite(buzzerPin, buzzerVolume);<br/>    delay(buzzMinDuration);<br/>    analogWrite(buzzerPin, 0);<br/>  }<br/>}</pre>
<p class="indent">This function checks the first 3 bytes of the message sent from the other module, and if they match, it turns on the vibration motor for the duration specified in milliseconds by <code>buzzMinDuration</code>.</p>
<h4 class="h4" id="ch00lev1sec216"><strong>USING THE HAPTIC COMMUNICATOR</strong></h4>
<p class="noindent">This project is a lot of fun to use. I’m pretty sure casinos are wise to this kind of contraption, though, so to avoid trouble, don’t use it to cheat at the gaming tables. Money will have little use after the apocalypse in any case.</p>
<p class="indentb">If you’re prepared to learn Morse code, the handsets can be used with Morse, although they are a little slow. Alternatively, you could come up with a simplified vocabulary along the following lines:</p>
<p class="bull">• <strong>One short buzz</strong>: All is well</p>
<p class="bull">• <strong>One long buzz</strong>: Zombies sighted</p>
<p class="bull">• <strong>Three long buzzes</strong>: Zombies close</p>
<p class="bull">• <strong>Three short buzzes</strong>: Run!!</p>
<p class="indentt">This is the final project in the book, and I hope you have had fun as you’ve equipped yourself for the apocalypse. Whether you’re building these projects in anticipation of the coming zombie hordes or you’re already in hiding, I also hope they help you to survive!</p>
</body></html>