<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/>&#13;
<figure class="co-img"><img id="fig-pg92" class="img60" src="../images/pg92.jpg" alt="" width="691" height="1576"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-13.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">LOCAL VARIABLES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">Up to this point, you’ve been able to compile only programs that return constant expressions. In this chapter, you’ll implement local variables, which will let you compile far more interesting programs. Your compiler will need to support a more expressive grammar so it can parse C programs that declare, assign values to, and refer to variables. It will also need to contend with the ways that variables can be declared and used incorrectly. To catch these potential errors, you’ll add a <i>semantic analysis</i> stage, which is bolded in the diagram at the beginning of this chapter. This stage validates that variables are not declared multiple times in the same scope or used before they’re declared. It also assigns each variable a unique identifier that allows you to safely refer to it in TACKY.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label="94"/>Luckily, the TACKY and assembly IRs in your compiler already support variables, since they use temporary variables to store intermediate results. That means you won’t have to change anything in your compiler after TACKY generation. Before jumping into the compiler passes, let’s define the language features we need to support.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-45"/><samp class="SANS_Futura_Std_Bold_B_11">Variables, Declarations, and Assignment</samp></h3>&#13;
<p class="TNI">For variables to be even remotely useful, we’ll need to implement a few new language features. First of all, we need to support variable <i>declarations</i>. Every local variable in C must be declared before it can be used. A variable declaration consists of the variable’s type, its name, and an optional expression, called an <i>initializer</i>, that specifies its initial value. Here’s a declaration with an initializer:</p>&#13;
<pre><code>int a = 2 * 3;</code></pre>&#13;
<p class="TX">Here’s a declaration without one:</p>&#13;
<pre><code>int b;</code></pre>&#13;
<p class="TX">Second, we must support using a variable’s value in an expression, like <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Just like an integer constant, a variable is a complete expression on its own but can also appear in more complex logical and arithmetic expressions.</p>&#13;
<p class="TX">Finally, we need to support variable <i>assignment</i>. In C, you update a variable using the assignment operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>). Variable assignment in C is an expression, like addition, subtraction, and so forth. This means it evaluates to some result, which you can use in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement or as part of a larger expression. The result of an assignment expression is the updated value of the destination variable. For example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp> evaluates to 10. First, you assign the value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> to the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, then you multiply the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Because assignment is an expression, you can perform multiple assignments at once in an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. Unlike other binary operations we’ve seen so far, assignment is right-associative, so <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>. To evaluate this expression, you first perform the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. Then, you assign the result of that expression, which is the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.</p>&#13;
<p class="TX">Variable assignment is the first expression we’ve encountered that has a <i>side effect</i>. That means it doesn’t just reduce to a value; it also has some impact on the execution environment. In <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>, the subexpression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> has a value (<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and it also has a side effect (updating <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>). Most of the time, we care only about the side effect of a variable assignment, not the resulting value.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label="95"/>An action counts as a side effect only if it’s visible outside of the language construct in question. For example, updating a local variable is a side effect of an assignment expression because the variable’s new value is visible outside of that expression. But it’s <i>not</i> a side effect of the function that contains the assignment expression, because the effect isn’t visible outside of that function. Updating a global variable, on the other hand, would be a side effect of the expression <i>and</i> the function.</p>&#13;
<p class="TX">Since we’re implementing expressions with side effects, it also makes sense to add support for <i>expression statements</i>, which evaluate an expression but don’t use the result. Statements that assign to variables, like</p>&#13;
<pre><code>foo = 3 * 3;</code></pre>&#13;
<p class="BodyContinued">are expression statements. This expression has the side effect of assigning the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. The result of the whole expression is also the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>, but this result isn’t used anywhere; only the side effect of updating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> affects the program.</p>&#13;
<p class="TX">You can also have expression statements with no side effect at all:</p>&#13;
<pre><code>1 + a * 2;</code></pre>&#13;
<p class="BodyContinued">You don’t typically see expression statements without side effects, because they’re completely useless, but they’re perfectly valid.</p>&#13;
<p class="TX">Any expression can appear on the right side of the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator, but only some expressions can appear on the left side. It makes sense to assign values to variables, array elements, and struct members:</p>&#13;
<pre><code>x = 3;&#13;
array[2] = 100;&#13;
my_struct.member = x * 2;</code></pre>&#13;
<p class="BodyContinued">But it doesn’t make sense to assign values to constants or the results of logical or arithmetic expressions:</p>&#13;
<pre><code>4 = 5;&#13;
foo &amp;&amp; bar = 6;&#13;
a - 5 = b;</code></pre>&#13;
<p class="TX">Expressions that can appear on the left side of an assignment are called <i>lvalues</i>. In this chapter, the only lvalues we’ll handle are variables. You’ll learn about more complex lvalues in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<aside class="box" aria-label="box-92"><p class="BoxTitle" id="box-92"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label="96"/><samp class="SANS_Dogma_OT_Bold_B_11">UNDEFINED BEHAVIOR ALERT!</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Local variables introduce new opportunities for undefined behavior, which you learned about in</samp> <samp class="SANS_Futura_Std_Book_11"><a href="chapter4.xhtml">Chapter 4</a>. For example, with a few exceptions, using the value of an uninitialized variable leads to undefined behavior. Consider the following function:</samp></p>&#13;
<pre><code>int foo(void) {&#13;
    int a;&#13;
    return a;&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">It’s possible that this function will allocate stack space for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_Futura_Std_Book_11">without initializing it, then return whatever value happens to already be in that uninitialized memory. In this case, although the return value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">will be unpredictable, the rest of the program will behave reasonably. But because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp><samp class="SANS_Futura_Std_Book_11">’s behavior is undefined, it’s also possible that it will do something completely different; calling</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">could crash the program or even make other functions misbehave later on.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Let’s look at a subtler example with two unsequenced variable assignments:</samp></p>&#13;
<pre><code>int main(void) {&#13;
    int a;&#13;
    (a = 4) + (a = 5);&#13;
    return a;&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Remember that the operands of a binary operator like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_Futura_Std_Book_11">are unsequenced; they can be evaluated in any order. It might look like this program has two possible behaviors: it could return either</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp><samp class="SANS_Futura_Std_Book_11">. But performing multiple unsequenced assignments to the same variable is undefined behavior, so there are no restrictions on how this program might behave. In practice, it probably</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">will</samp> <samp class="SANS_Futura_Std_Book_11">return</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp><samp class="SANS_Futura_Std_Book_11">, but that isn’t guaranteed.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Similarly, the behavior is undefined if you use a variable’s value and assign to it in unsequenced expressions, like so:</samp></p>&#13;
<pre><code>int main(void) {&#13;
    int a = 0;&#13;
    return (a = 1) + a;&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">These examples aren’t an exhaustive overview of every possible undefined behavior involving local variables, but they illustrate how problems that appear to affect one small part of a program can make the entire program’s behavior undefined.</samp></p>&#13;
</aside>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label="97"/>Now that you understand the language features you’re going to add in this chapter, let’s extend the compiler.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-46"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add one new token in this chapter:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> An equal sign, the assignment operator</p>&#13;
<p class="TX">You don’t need a new token to represent variable names. The lexer already recognizes identifiers, like the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, and variable names are just identifiers. We won’t distinguish between function names and variable names until the parsing stage.</p>&#13;
<aside class="box" aria-label="box-93"><p class="BoxTitle" id="box-93"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 5 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your lexer should succeed on all of this chapter’s test cases.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-47"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">As usual, we’ll update the AST and grammar to support this chapter’s new language constructs. We’ll also update our precedence climbing code to correctly parse assignment expressions.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-34"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Updated AST and Grammar</samp></h4>&#13;
<p class="TNI">Let’s start by extending our AST definition to support using, declaring, and assigning to variables. To support using variables in expressions, we’ll add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. Since variable assignment is also an expression, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> too. <a href="chapter5.xhtml#list5-1">Listing 5-1</a> shows the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>.</p>&#13;
<a id="list5-1"/>&#13;
<pre><code>exp = Constant(int)&#13;
    <b>| Var(identifier)</b>&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    <b>| Assignment(exp, exp)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: The definition for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Var</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Assignment</samp></p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> node holds the variable name. An <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> consists of two parts: the lvalue being updated and the expression we’re assigning to that lvalue. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label="98"/>When we parse the program, we’ll allow any expression on the left-hand side of an assignment. In the semantic analysis stage, we’ll make sure that expression is a valid lvalue. We validate lvalues during semantic analysis, rather than during parsing, because we’ll need to support more complex lvalues in later chapters.</p>&#13;
<p class="TX">Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> AST node to support expression statements. We’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Expression</samp> constructor, which takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node as an argument. We’ll also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Null</samp> constructor to represent <i>null statements</i>, which are expression statements without the expression:</p>&#13;
<pre><code>statement = Return(exp) <b>| Expression(exp) | Null</b></code></pre>&#13;
<p class="TX">A null statement has no content; it’s just a semicolon. It’s a placeholder for when the grammar requires a statement, but you don’t want that statement to do anything. <a href="chapter5.xhtml#list5-2">Listing 5-2</a>, which is taken from section 6.8.3, paragraph 5, of the C standard, illustrates why you might need a null statement.</p>&#13;
<a id="list5-2"/>&#13;
<pre><code>char *s;&#13;
/* ... */&#13;
while ( <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> *s++ != '\0')&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> ;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: An example of a null statement from the C standard</samp></p>&#13;
<p class="TX">In this example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop finds the end of a null-terminated string by iterating over each character until it reaches the null byte. The loop body doesn’t need to do anything, because all the work happens in the controlling expression <span class="CodeAnnotation" aria-label="annotation1">❶</span>, but omitting the loop body completely would be syntactically invalid. Instead, you can use a null statement <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Null statements don’t really have anything to do with local variables, but we’ll implement them here because they’re technically a kind of expression statement. (They’re also easy to implement.)</p>&#13;
<p class="TX">We’ll need an AST node to represent variable declarations too:</p>&#13;
<pre><code>declaration = Declaration(identifier name, exp? init)</code></pre>&#13;
<p class="TX">A declaration consists of a name and an optional initializer. (The question mark in <samp class="SANS_TheSansMonoCd_W5Regular_11">exp?</samp> means that field is optional.) We’ll include type information for declarations in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, but we don’t need it yet because <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is the only possible type.</p>&#13;
<p class="TX">Declarations are a separate AST node, not another kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>, because declarations aren’t statements! Conceptually, the difference is that statements are executed when the program runs, whereas declarations simply tell the compiler that some identifier exists and can be used later. This distinction will become obvious during TACKY generation: we’ll handle declarations with initializers like normal variable assignments, but declarations without initializers will just disappear.</p>&#13;
<p class="TX">The more concrete difference, from the parser’s perspective, is that there are parts of a program where a statement can appear but a declaration <span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label="99"/>can’t. For example, the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is always another statement:</p>&#13;
<pre><code>if (a == 2)&#13;
    return 4;</code></pre>&#13;
<p class="BodyContinued">It can’t be a declaration, because declarations aren’t statements. So, this is invalid:</p>&#13;
<pre><code>if (a == 2)&#13;
    int x = 0;</code></pre>&#13;
<p class="TX">It might be surprising to hear that an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> body is a single statement, since an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> body often appears to be a list of statements and declarations, like this:</p>&#13;
<pre><code>if (a == 2) {&#13;
    int x = 0;&#13;
    return x;&#13;
}</code></pre>&#13;
<p class="BodyContinued">But a list of statements and declarations wrapped in braces is actually a single statement, called a <i>compound statement</i>. We’ll implement compound statements in <span class="bodycontinued_Xref-1"><a href="chapter7.xhtml">Chapter 7</a></span>; for now, the key point is that we need to distinguish between statements and declarations in the AST.</p>&#13;
<p class="TX">Finally, we need to change how we define a function body so that we can parse functions that contain multiple declarations and statements, like <a href="chapter5.xhtml#list5-3">Listing 5-3</a>.</p>&#13;
<a id="list5-3"/>&#13;
<pre><code>int main(void) {&#13;
    int a;&#13;
    a = 2;&#13;
    return a * 2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A program with a declaration and multiple statements</samp></p>&#13;
<p class="TX">Up until this point, we’ve defined a function body as a single statement:</p>&#13;
<pre><code>function_definition = Function(identifier name, statement body)</code></pre>&#13;
<p class="BodyContinued">Now, though, we need to define it as a list of statements and declarations, which are collectively called <i>block items</i>. We’ll add a new AST node to represent block items:</p>&#13;
<pre><code>block_item = S(statement) | D(declaration)</code></pre>&#13;
<p class="TX">Then we can represent a function body as a list of block items:</p>&#13;
<pre><code>function_definition = Function(identifier name, <b>block_item*</b> body)</code></pre>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label="100"/>The asterisk here indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> is a list. Putting it all together, <a href="chapter5.xhtml#list5-4">Listing 5-4</a> shows the new AST definition, with this chapter’s additions bolded.</p>&#13;
<a id="list5-4"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, <b>block_item* </b>body)&#13;
<b>block_item = S(statement) | D(declaration)</b>&#13;
<b>declaration = Declaration(identifier name, exp? init)</b>&#13;
statement = Return(exp) <b>| Expression(exp) | Null</b>&#13;
exp = Constant(int)&#13;
    <b>| Var(identifier)</b>&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    <b>| Assignment(exp, exp)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The abstract syntax tree with variables, assignment expressions, and expression statements</samp></p>&#13;
<p class="TX"><a href="chapter5.xhtml#list5-5">Listing 5-5</a> shows the updated grammar.</p>&#13;
<a id="list5-5"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" "{" <b>{&lt;block-item&gt;}</b> "}"&#13;
<b>&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;</b>&#13;
<b>&lt;declaration&gt; ::= "int" &lt;identifier&gt; ["=" &lt;exp&gt;] ";"</b>&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";" <b>| &lt;exp&gt; ";" | ";"</b>&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;int&gt; <b>| &lt;identifier&gt;</b> | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="<b> | "="</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: The grammar with variables, assignment expressions, and expression statements</samp></p>&#13;
<p class="TX"><a href="chapter5.xhtml#list5-5">Listing 5-5</a> introduces a couple of new bits of EBNF notation. Wrapping a sequence of symbols in braces indicates that it can be repeated zero or more times, so <samp class="SANS_TheSansMonoCd_W5Regular_11">{&lt;block-item&gt;}</samp> indicates a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;block-item&gt;</samp> symbols. Note the difference between unquoted braces, which indicate repetition, and quoted braces, which indicate literal <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and} tokens. In the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;function&gt;</samp>, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">"{" {&lt;block-item&gt;} "}"</samp> indicates a <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>token, then a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;block-item&gt;</samp> symbols, then a} token. The pseudocode in <a href="chapter5.xhtml#list5-6">Listing 5-6</a> shows how to parse the list of block items in a function definition.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label="101"/>&#13;
<a id="list5-6"/>&#13;
<pre><code>parse_function_definition(tokens):&#13;
    // parse everything up through the open brace as before...&#13;
    <var>--snip--</var>&#13;
    function_body = []&#13;
    while peek(tokens) != "}":&#13;
        next_block_item = parse_block_item(tokens)&#13;
        function_body.append(next_block_item)&#13;
    take_token(tokens)&#13;
    return Function(name, function_body)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Parsing a list of block items</samp></p>&#13;
<p class="TX">You keep parsing block items until you see a close brace, which indicates the end of the function body. You can then remove that brace from the input stream and finish processing the function definition.</p>&#13;
<p class="TX">Just as braces indicate repetition in EBNF notation, wrapping a sequence of symbols in square brackets indicates that it’s optional. We represent the optional initializer in declarations with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">["=" &lt;exp&gt;]</samp>. To handle this optional construct, your declaration parsing code should check whether the identifier in the grammar rule is followed by an <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> token, which means the initializer is present, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token, which means the initializer is absent.</p>&#13;
<p class="TX">While parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;block-item&gt;</samp>, you need a way to tell whether the current block item is a statement or a declaration. To do this, peek at the first token; if it’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> keyword, it’s a declaration, and otherwise it’s a statement.</p>&#13;
<p class="TX"><a href="chapter5.xhtml#list5-5">Listing 5-5</a> also includes a new production rule for the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> symbol, corresponding to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor, and a new binary operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, to represent variable assignment. Even though we won’t represent variable assignment with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST node, it looks just like any other binary operator in the grammar. This lets us parse variable assignments with the precedence climbing algorithm we’ve already implemented, although it will require a few tweaks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-35"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Improved Precedence Climbing Algorithm</samp></h4>&#13;
<p class="TNI">There’s just one problem with using our current precedence climbing code to parse assignment expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator is right-associative, but our code can handle only left-associative operators. To remind ourselves why, let’s look at the precedence climbing pseudocode again. We saw the full version of this algorithm in <span class="Xref-1"><a href="chapter3.xhtml#list3-7">Listing 3-7</a></span>; it’s reproduced here as <a href="chapter5.xhtml#list5-7">Listing 5-7</a>.</p>&#13;
<a id="list5-7"/>&#13;
<pre><code>parse_exp(tokens, min_prec):&#13;
    left = parse_factor(tokens)&#13;
    next_token = peek(tokens)&#13;
    while next_token is a binary operator and precedence(next_token) &gt;= min_prec:&#13;
        operator = parse_binop(tokens)&#13;
        right = parse_exp(tokens, <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> precedence(next_token) + 1)&#13;
        left = Binary(operator, left, right)&#13;
        next_token = peek(tokens)&#13;
    return left</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Parsing left-associative operators with precedence climbing</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label="102"/>When we make recursive calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, we set the minimum precedence higher than the precedence of the current operator <span class="CodeAnnotation" aria-label="annotation1">❶</span>. So, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> will return only <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> won’t meet the minimum precedence. That’s how we get left-associative expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">(left</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is right-associative, however, we shouldn’t stop if we hit that same token in the recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>; we should include it in the right-hand expression. To do that, we need to set the minimum precedence on the right-hand side <i>equal</i> to the precedence of the current token. In other words, when handling a right-associative token like <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, the recursive call should be:</p>&#13;
<pre><code>right = parse_exp(tokens, precedence(next_token))</code></pre>&#13;
<p class="TX">Suppose you’re parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. You’ll parse the left-hand side into the factor <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. If the minimum precedence in this recursive call were <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, it would parse only the next factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. But if the minimum precedence is <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>, it will parse the entire assignment, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> as the right-hand side of the expression. The final result will be <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>, which is exactly what we want.</p>&#13;
<p class="TX">The only other difference between parsing variable assignment and other binary expressions is that we need to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST node instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> node. <a href="chapter5.xhtml#list5-8">Listing 5-8</a> gives the updated pseudocode for precedence climbing with these adjustments.</p>&#13;
<a id="list5-8"/>&#13;
<pre><code>parse_exp(tokens, min_prec):&#13;
    left = parse_factor(tokens)&#13;
    next_token = peek(tokens)&#13;
    while next_token is a binary operator and precedence(next_token) &gt;= min_prec:&#13;
        <b>if next_token is "=":</b>&#13;
            <b>take_token(tokens) // remove "=" from list of tokens</b>&#13;
            <b>right = parse_exp(tokens, precedence(next_token))</b>&#13;
            <b>left = Assignment(left, right)</b>&#13;
        <b>else:</b>&#13;
            operator = parse_binop(tokens)&#13;
            right = parse_exp(tokens, precedence(next_token) + 1)&#13;
            left = Binary(operator, left, right)&#13;
        next_token = peek(tokens)&#13;
    return left</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: The extended precedence climbing algorithm</samp></p>&#13;
<p class="TX">Finally, we need to add <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> to our precedence table. <a href="chapter5.xhtml#tab5-1">Table 5-1</a> lists the precedence values I’m using for all the binary operators, with the new operator bolded. It has lower precedence than any other operator we’ve implemented so far.</p>&#13;
<p class="TT" id="tab5-1"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label="103"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Precedence Values of Binary Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">30</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">30</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">At this point, you know how to build a valid AST for every program you’ll encounter in this chapter; you’re ready to update the parser and test it out.</p>&#13;
<aside class="box" aria-label="box-94"><p class="BoxTitle" id="box-94"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test this chapter’s changes to the parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 5 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The parser should successfully parse every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_5/valid</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_5/invalid_semantics</samp><samp class="SANS_Futura_Std_Book_11">. It should raise an error for every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_5/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-48"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">Up to this point, the only errors we’ve had to worry about were syntax errors. If we could parse a program, we knew the remaining compiler passes would succeed. Now, a program can be syntactically correct but <span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label="104"/><i>semantically</i> invalid; in other words, it might just not make sense. For example, a program could assign a value to an expression that isn’t assignable:</p>&#13;
<pre><code>2 = a * 3; // ERROR: can't assign a value to a constant</code></pre>&#13;
<p class="BodyContinued">Or it could declare the same variable twice in the same scope:</p>&#13;
<pre><code>int a = 3;&#13;
int a; // ERROR: a has already been declared!</code></pre>&#13;
<p class="BodyContinued">Or it could try to use a variable before it’s been declared:</p>&#13;
<pre><code>int main(void) {&#13;
    a = 4; // ERROR: a has not been declared yet!&#13;
    return a;&#13;
}</code></pre>&#13;
<p class="TX">All of these examples use valid syntax, but you should get an error if you try to compile them. The semantic analysis stage detects this kind of error. This stage will eventually include several different passes that validate different aspects of the program. In this chapter, we’ll add our first semantic analysis pass, <i>variable resolution</i>.</p>&#13;
<p class="TX">The variable resolution pass will track which variables are in scope throughout the program and <i>resolve</i> each reference to a variable by finding the corresponding declaration. It will report an error if a program declares the same variable more than once or uses a variable that hasn’t been declared. It will also rename each local variable with a globally unique identifier. For example, it might convert the program</p>&#13;
<pre><code>int main(void) {&#13;
    int a = 4;&#13;
    int b = a + 1;&#13;
    a = b - 5;&#13;
    return a + b;&#13;
}</code></pre>&#13;
<p class="BodyContinued">into something like this:</p>&#13;
<pre><code>int main(void) {&#13;
    int a0 = 4;&#13;
    int b1 = a0 + 1;&#13;
    a0 = b1 - 5;&#13;
    return a0 + b1;&#13;
}</code></pre>&#13;
<p class="TX">(Of course, this pass actually transforms ASTs rather than source files, but I’m presenting these examples as C source code to make them more readable.)</p>&#13;
<p class="TX">This transformation may not seem too helpful—the variable names <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were already unique—but it will be essential once we introduce <span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label="105"/>multiple variable scopes, because different variables in different scopes can have the same name. For example, we might transform the program</p>&#13;
<pre><code>int main(void) {&#13;
    int a = 2;&#13;
    if (a &lt; 5) {&#13;
        int a = 7;&#13;
        return a;&#13;
    }&#13;
    return a;&#13;
}</code></pre>&#13;
<p class="BodyContinued">into:</p>&#13;
<pre><code>int main(void) {&#13;
    int a0 = 2;&#13;
    if (a0 &lt; 5) {&#13;
        int a1 = 7;&#13;
        return a1;&#13;
    }&#13;
    return a0;&#13;
}</code></pre>&#13;
<p class="TX">This makes it clear that <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">a1</samp> are two different variables, which will simplify later compiler stages.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-36"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable Resolution</samp></h4>&#13;
<p class="TNI">Now we’ll write the variable resolution pass. During this pass, we’ll construct a map from the user-defined variable names to the unique names we’ll use in later stages. We’ll process block items in order, checking for errors and replacing variable names as we go. When we encounter a variable declaration, we’ll add a new entry mapping that variable name to a unique name that we generate. Then, when we see an expression that uses a variable, we’ll replace the variable name with the corresponding unique name from the map. The pseudocode in <a href="chapter5.xhtml#list5-9">Listing 5-9</a> demonstrates how to resolve a variable declaration.</p>&#13;
<a id="list5-9"/>&#13;
<pre><code>resolve_declaration(Declaration(name, init), variable_map):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if name is in variable_map:&#13;
        fail("Duplicate variable declaration!")&#13;
    unique_name = make_temporary()&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> variable_map.add(name, unique_name)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if init is not null:&#13;
        init = resolve_exp(init, variable_map)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> return Declaration(unique_name, init)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Resolving a variable declaration</samp></p>&#13;
<p class="TX">First, we check whether the variable being declared is already present in the variable map <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it is, that means it was declared earlier in the function, so this is a duplicate declaration. In that case, we throw an error. Next, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label="106"/>we associate the user-defined variable name with a unique autogenerated name in the variable map <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">After we update the variable map, we process the declaration initializer, if there is one <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> returns a new copy of the initializer with any variables renamed, throwing an error if the initializer uses an undeclared variable. Finally, we return a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Declaration</samp> node <span class="CodeAnnotation" aria-label="annotation4">❹</span> that uses the new autogenerated name instead of the old user-defined one, along with the new initializer we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>.</p>&#13;
<p class="TX">The identifiers you generate in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp> must not conflict with the names of temporary TACKY variables. If you’re using a global counter to generate unique identifiers, use the same counter across both the semantic analysis and TACKY generation stages.</p>&#13;
<p class="TX">These identifiers must not conflict with the names of functions or global variables, either. (In <span class="Xref-1"><a href="chapter10.xhtml">Chapter 10</a></span>, you’ll see that global variables keep their original names, like functions, instead of being renamed, like local variables.) You can rely on the usual trick of generating identifiers that wouldn’t be syntactically valid in C. I recommend including a variable’s original name in its autogenerated name to help with debugging; for example, you might rename <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">b.1</samp>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You might have noticed that the examples in the previous section used autogenerated identifiers that</i> <span class="note_Italic">are</span> <i>syntactically valid in C, like a0 and b1, because those examples were presented as C source code. The naming scheme in those examples wouldn’t work in practice, because the renamed variables could conflict with function names and with each other. For example, two local variables named a and a1 could both be renamed a12.</i></p>&#13;
<aside class="box" aria-label="box-95"><p class="BoxTitle" id="box-95"><samp class="SANS_Dogma_OT_Bold_B_11">USING VARIABLES IN THEIR OWN INITIALIZERS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Because <a href="chapter5.xhtml#list5-9">Listing 5-9</a> updates the variable map before processing the initializer, it will happily process an initializer that uses the same variable it initializes. Take this example:</samp></p>&#13;
<pre><code>int foo = foo + 1;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">When we process the initializer,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp class="SANS_Futura_Std_Book_11">, the variable</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">is already in the map, so the variable resolution pass won’t complain. This is consistent with the C standard; a variable really is in scope in its own initializer. Still, this declaration isn’t exactly legal. It will result in undefined behavior, because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">is uninitialized when it’s used in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp class="SANS_Futura_Std_Book_11">. (Remember that compilers don’t need to detect undefined behavior, so it’s okay not to report an error here.)</samp></p>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label="107"/><samp class="SANS_Futura_Std_Book_11">In other cases, using a variable in its own initializer makes sense. For example, in</samp></p>&#13;
<pre><code>unsigned int foo = sizeof foo;&#13;
</code></pre>&#13;
<p class="BoxBodyContinued"><samp class="SANS_Futura_Std_Book_11">we’re still using</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">before initializing it, but we consider only</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp><samp class="SANS_Futura_Std_Book_11">’s size, not its value. Annex J of the C standard says we get undefined behavior when “an lvalue … is used in a context</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">that requires the value of the designated object</samp><samp class="SANS_Futura_Std_Book_11">, but the object is uninitialized” (emphasis added). Since</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_11">doesn’t require</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp><samp class="SANS_Futura_Std_Book_11">’s value, there’s no undefined behavior in this declaration.</samp></p>&#13;
</aside>&#13;
<p class="TX">To resolve a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement or expression statement, we just process the inner expression, as <a href="chapter5.xhtml#list5-10">Listing 5-10</a> illustrates.</p>&#13;
<a id="list5-10"/>&#13;
<pre><code>resolve_statement(statement, variable_map):&#13;
    match statement with&#13;
    | Return(e) -&gt; return Return(resolve_exp(e, variable_map))&#13;
    | Expression(e) -&gt; return Expression(resolve_exp(e, variable_map))&#13;
    | Null -&gt; return Null</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Resolving a statement</samp></p>&#13;
<p class="TX">When we resolve an expression, we check that all the variable uses and assignments in that expression are valid. <a href="chapter5.xhtml#list5-11">Listing 5-11</a> shows how to do that.</p>&#13;
<a id="list5-11"/>&#13;
<pre><code>resolve_exp(e, variable_map):&#13;
    match e with&#13;
    | Assignment(left, right) -&gt;&#13;
        if left is not a Var node:&#13;
            fail("Invalid lvalue!")&#13;
        return Assignment( <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> resolve_exp(left, variable_map), <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> resolve_exp(right, variable_map))&#13;
    | Var(v) -&gt;&#13;
        if v is in variable_map:&#13;
            return Var( <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> variable_map.get(v))&#13;
        else:&#13;
            fail("Undeclared variable!")&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Resolving an expression</samp></p>&#13;
<p class="TX">When we encounter an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> expression, we check that the left side is a valid lvalue; for now, that means it must be a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. We then recursively resolve the left <span class="CodeAnnotation" aria-label="annotation1">❶</span> and right <span class="CodeAnnotation" aria-label="annotation2">❷</span> subexpressions. When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>, we replace the variable name with the unique identifier from the variable map <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it’s not in the variable map, that means it hasn’t been declared yet, so we throw an error. Since we process both sides of an assignment recursively with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> case in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> handles variables on the left side of assignment expressions too.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label="108"/>To handle other kinds of expressions, we process any subexpressions recursively with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>. Ultimately, the variable resolution pass should return a complete AST that uses autogenerated instead of user-defined variable names.</p>&#13;
<aside class="box" aria-label="box-96"><p class="BoxTitle" id="box-96"><samp class="SANS_Dogma_OT_Bold_B_11">THE TROUBLE WITH TYPEDEF</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The way we’ve structured our compiler has one major limitation: we first parse the entire program, and then resolve variables. This approach works well for the subset of C we’ll implement in this book, but to implement the whole language, you need to resolve identifiers</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_11">you parse the program. In particular, our approach can’t handle</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp><samp class="SANS_Futura_Std_Book_11">, which lets you declare names for arbitrary types:</samp></p>&#13;
<pre><code>typedef int foo;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The problem is that some statements can be parsed one way if an identifier like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">refers to a type and another way if it refers to a function or variable. Here’s a simple illustration:</samp></p>&#13;
<pre><code>return (foo) * x;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">is the name of a type, this statement dereferences</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp><samp class="SANS_Futura_Std_Book_11">, casts the result to type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp><samp class="SANS_Futura_Std_Book_11">, and then returns it. But if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">is a variable, this statement instead multiplies</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">and returns the result. To make matters worse, type names follow the same scoping rules as variable names. So, just as the same identifier might refer to two different variables at different points in a program, it might refer to a variable at one point and a type at a different point. To figure out whether a given identifier refers to a type or a variable, you need to resolve identifiers as you parse the program. Since the correct way to parse a C construct might depend on other parts of the program you’ve already parsed, we say that C has a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">context-sensitive grammar</samp><samp class="SANS_Futura_Std_Book_11">. (By contrast, a language has a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">context-free grammar</samp> <samp class="SANS_Futura_Std_Book_11">if you can apply every production rule in isolation, without worrying about anything that came before it.)</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Production C compilers generally deal with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> <samp class="SANS_Futura_Std_Book_11">by maintaining a symbol table (similar to our variable map) while they parse the program. Some of them feed the information from the symbol table back into the lexer, which then interprets type names as a different kind of token from other identifiers; this approach is called the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lexer hack</samp><samp class="SANS_Futura_Std_Book_11">. Others use the same token type for all identifiers and do all the work of distinguishing between type names and other identifiers in the parser. If you want to implement</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> <samp class="SANS_Futura_Std_Book_11">on your own, I recommend the latter approach.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Here’s a quick sketch of how you could adapt our implementation to support</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp><samp class="SANS_Futura_Std_Book_11">. First, you’ll need to move all the variable resolution logic into the parser. You should pass around a variable map as you parse the program. Your parser should add declarations to the map and rename variables as it goes. It should also validate that variables are declared before they’re used,</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label="109"/><samp class="SANS_Futura_Std_Book_11">that there are no conflicting declarations, and so on. Once you’re ready to add</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp><samp class="SANS_Futura_Std_Book_11">, you can track type names in this map too, recording whether each entry in the map refers to a type or some other entity. You might want to convert type names to unique IDs during parsing, and then replace these names with the corresponding types in a separate pass. Alternatively, you could replace type names with the corresponding types right away as you parse the program. Either way, your parser will have enough information to distinguish types from other identifiers. The other semantic analysis passes that we’ll add in later chapters should remain separate from the parser.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If you decide to implement</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> <samp class="SANS_Futura_Std_Book_11">yourself, I recommend reading Eli Bendersky’s blog post “The Context Sensitivity of C’s Grammar, Revisited,” which walks through some particularly ugly edge cases that you’ll need to handle (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited">https://<wbr/>eli<wbr/>.thegreenplace<wbr/>.net<wbr/>/2011<wbr/>/05<wbr/>/02<wbr/>/the<wbr/>-context<wbr/>-sensitivity<wbr/>-of<wbr/>-cs<wbr/>-grammar<wbr/>-revisited</a></samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The --validate Option</samp></h4>&#13;
<p class="TNI">To test out the new compiler pass, you’ll need to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">--validate</samp> command line option to your compiler driver. This option should run your compiler through the semantic analysis stage, stopping before TACKY generation. In later chapters, after you’ve updated the semantic analysis stage to include multiple passes, this option should direct your compiler to run all of them.</p>&#13;
<p class="TX">Like the existing options to run the compiler up to a specific stage, this new option shouldn’t produce any output files. As usual, it should return an exit code of 0 if compilation succeeds and a nonzero exit code if it fails.</p>&#13;
<aside class="box" aria-label="box-97"><p class="BoxTitle" id="box-97"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE VARIABLE RESOLUTION PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out this pass, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 5 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This pass should reject every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_5/invalid_semantics</samp> <samp class="SANS_Futura_Std_Book_11">and accept every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_5/valid</samp><samp class="SANS_Futura_Std_Book_11">. You may also want to write your own unit tests for this pass to verify that it updates variable names correctly.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-49"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">We don’t need to modify the TACKY IR at all in this chapter. We can already refer to variables with the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor and assign values to them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. The TACKY IR doesn’t include variable <span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label="110"/>declarations, because it doesn’t need them. We got all the information we needed out of variable declarations during semantic analysis, and now we can discard them.</p>&#13;
<p class="TX">Although TACKY itself doesn’t need to change, the TACKY generation pass does: we need to extend this pass to handle the latest additions to the AST. First, we’ll deal with the two new kinds of expressions we added in this chapter. Next, we’ll handle the other additions to the AST, including expression statements and declarations.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable and Assignment Expressions</samp></h4>&#13;
<p class="TNI">We’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> in the AST to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> in TACKY, keeping the same identifier. Because we autogenerated the identifier, we can guarantee that it won’t conflict with any other identifiers in the TACKY program. To handle an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST node, we’ll emit the instructions to evaluate the right-hand side, then emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction to copy the result to the left-hand side. <a href="chapter5.xhtml#list5-12">Listing 5-12</a> shows how to handle both expressions.</p>&#13;
<a id="list5-12"/>&#13;
<pre><code>emit_tacky(e, instructions):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | Var(v) -&gt; return Var(v)&#13;
    | Assignment(Var(v), rhs) -&gt;&#13;
        result = emit_tacky(rhs, instructions)&#13;
        instructions.append(Copy(result, Var(v)))&#13;
        return Var(v)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Converting variable and assignment expressions to TACKY</samp></p>&#13;
<p class="TX">This is an inefficient way to handle variable assignments; we’ll often end up evaluating the right-hand side, storing the result in a temporary variable, and then copying it into variable <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>, instead of storing the result directly in <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> and avoiding the temporary variable entirely. The optimizations we implement in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span> will remove some of these superfluous copies.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-39"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations, Statements, and Function Bodies</samp></h4>&#13;
<p class="TNI">Now we’ll handle declarations. As I mentioned earlier, we can discard variable declarations at this stage; in TACKY, you don’t need to declare variables before using them. But we do need to emit TACKY to <i>initialize</i> variables. If a declaration includes an initializer, we’ll handle it like a normal variable assignment. If a declaration doesn’t have an initializer, we won’t emit any TACKY at all.</p>&#13;
<p class="TX">We also need to handle expression statements and null statements. To convert an expression statement to TACKY, we’ll just process the inner expression. This will return a new temporary variable that holds the result of the expression, but we won’t use that variable again during TACKY generation. We won’t emit any TACKY instructions for a null statement.</p>&#13;
<p class="TX">Finally, we’ll deal with the fact that a function contains multiple block items instead of a single statement. We’ll process the block items in the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>function body in order, emitting TACKY for each one. Suppose we’re compiling the C function in <a href="chapter5.xhtml#list5-13">Listing 5-13</a>.</p>&#13;
<a id="list5-13"/>&#13;
<pre><code>int main(void) {&#13;
    int b;&#13;
    int a = 10 + 1;&#13;
    b = a * 2;&#13;
    return b;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A C function with variable declarations and an assignment expression</samp></p>&#13;
<p class="TX">Let’s assume that we renamed <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b.0</samp> during variable resolution, and that we use the naming scheme <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> for all temporary variables, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> is the value of a global counter. Then, we’ll generate the TACKY instructions shown in <a href="chapter5.xhtml#list5-14">Listing 5-14</a> for the function body. (This listing, like <span class="Xref-1"><a href="chapter4.xhtml#list4-6">Listing 4-6</a></span> in the previous chapter, uses the notation <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp>. Similarly, it uses notation like <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, src1, src2, dst)</samp>.)</p>&#13;
<a id="list5-14"/>&#13;
<pre><code>tmp.2 = 10 + 1&#13;
a.1 = tmp.2&#13;
tmp.3 = a.1 * 2&#13;
b.0 = tmp.3&#13;
Return(b.0)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: Implementing <a href="chapter5.xhtml#list5-13">Listing 5-13</a> in TACKY</samp></p>&#13;
<p class="TX">We won’t generate any TACKY for the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> in <a href="chapter5.xhtml#list5-13">Listing 5-13</a>, because it doesn’t include an initializer. We’ll convert the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> into the first two instructions of <a href="chapter5.xhtml#list5-14">Listing 5-14</a>, which calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and copy the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. We’ll convert the expression statement <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a * 2;</samp> to the next two instructions, and we’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement to the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction.</p>&#13;
<p class="TX">At this point, you know how to convert the whole AST to TACKY. But we’re not quite done; we have one last edge case to consider.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with No return Statement</samp></h4>&#13;
<p class="TNI">Since our AST now supports more than one kind of statement, we might encounter functions without <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements, like <a href="chapter5.xhtml#list5-15">Listing 5-15</a>.</p>&#13;
<a id="list5-15"/>&#13;
<pre><code>int main(void) {&#13;
    int a = 4;&#13;
    a = 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">What happens if you call this function? The C standard gives one answer for <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and a different answer for any other function. (I’m ignoring functions with return type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, which don’t return a value, because <span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/>we haven’t implemented them yet.) Section 5.1.2.2.3 says that “reaching the} that terminates the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function returns a value of 0,” so the code in <a href="chapter5.xhtml#list5-15">Listing 5-15</a> is equivalent to <a href="chapter5.xhtml#list5-16">Listing 5-16</a>.</p>&#13;
<a id="list5-16"/>&#13;
<pre><code>int main(void) {&#13;
    int a = 4;&#13;
    a = 0;&#13;
    <b>return 0;</b>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function that returns</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">0</samp></p>&#13;
<p class="TX">The situation is more complicated for other functions. According to section 6.9.1, paragraph 12, “Unless otherwise specified, if the} that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.” This implicitly covers two possible cases. In the first case, shown in <a href="chapter5.xhtml#list5-17">Listing 5-17</a>, the caller tries to use the function’s return value.</p>&#13;
<a id="list5-17"/>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
&#13;
int foo(void) {&#13;
    printf("I'm living on the edge, baby!");&#13;
    // no return statement&#13;
}&#13;
&#13;
int main(void) {&#13;
    return foo(); // try to use return value from foo&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Trying to use a function’s return value when it didn’t return anything</samp></p>&#13;
<p class="TX">This results in undefined behavior, which means all bets are off; the standard makes no guarantees about what will happen. In the second case, shown in <a href="chapter5.xhtml#list5-18">Listing 5-18</a>, we call the function but don’t use its return value.</p>&#13;
<a id="list5-18"/>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
&#13;
int foo(void) {&#13;
    printf("I'm living on the edge, baby!");&#13;
    // no return statement&#13;
}&#13;
&#13;
int main(void) {&#13;
    foo();&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Calling a function without using its return value</samp></p>&#13;
<p class="TX">There’s no undefined behavior in this program; it’s guaranteed to print <samp class="SANS_TheSansMonoCd_W5Regular_11">I'm living on the edge, baby!</samp> and then exit with a status code of 0. When we compile a function like <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, we don’t know whether any of its callers use its <span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>return value, so we have to assume it’s part of a program like <a href="chapter5.xhtml#list5-18">Listing 5-18</a>. In particular, we need to restore the caller’s stack frame and return control to the caller at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. Because we aren’t returning any particular value, we can set EAX to whatever we like, or not set it at all.</p>&#13;
<p class="TX">The easiest way to handle both cases is to add one extra TACKY instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(0))</samp>, to the end of every function body. This gives us the correct behavior for <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and for programs like <a href="chapter5.xhtml#list5-18">Listing 5-18</a>. If a function already ends with a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, this extra instruction will never run, so it won’t change the program’s behavior. In <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>, you’ll learn how to eliminate this extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction when it’s not needed.</p>&#13;
<p class="TX">Once you’ve extended the TACKY generation stage, you’re ready to test the whole compiler! Because we didn’t change the TACKY IR, we don’t need to change the assembly generation or code emission stages, either.</p>&#13;
<aside class="box" aria-label="box-98"><p class="BoxTitle" id="box-98"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out your compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 5</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Once these tests pass, you can either implement a couple of related extra credit features or go straight to the next chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-50"/><samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Compound Assignment, Increment, and Decrement</samp></h3>&#13;
<p class="TNI">Now that your compiler supports the simple assignment operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, you have the option of implementing several <i>compound assignment</i> operators: <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>. If you added the bitwise binary operators in <span class="Xref-1"><a href="chapter3.xhtml">Chapter 3</a></span>, you should add the corresponding compound assignment operators here as well: <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;=</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;=</samp>.</p>&#13;
<p class="TX">You can also add the increment and decrement operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>. Each of these operators can be used in two distinct ways: as a prefix operator in an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">++a</samp>, or as a postfix operator in an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">a++</samp>. When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> as a prefix operator, it increments or decrements its operand and evaluates to its new value. A postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operator also increments or decrements its operand, but it evaluates to the operand’s original value. As with the other language constructs in this chapter, you can implement the compound assignment, increment, and decrement operators without changing any part of your compiler after TACKY generation.</p>&#13;
<p class="TX">To include test cases for the increment and decrement operators, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--increment</samp> flag when you run the test suite. To include the test cases for compound assignment, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp> flag. The test script will run the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>test cases for bitwise compound assignment operators, like <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, only if you use both the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp> flags.</p>&#13;
<p class="TX">You can test all the extra credit features at once using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> flag. The command</p>&#13;
<pre><code>$ <b>./test_compiler</b> <var><b>/path/to/your_compiler</b></var> <b>--chapter 5 --extra-credit</b></code></pre>&#13;
<p class="BodyContinued">is equivalent to:</p>&#13;
<pre><code>$ <b>./test_compiler</b> <var><b>/path/to/your_compiler</b></var> <b>--chapter 5 --bitwise --compound --increment</b></code></pre>&#13;
<p class="TX">When we introduce more extra credit features in later chapters, the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> flag will cover those too.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h1-51"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">This chapter was a milestone in a few ways: you added a new kind of statement, and you implemented your first language construct that has a side effect. You also implemented a semantic analysis stage to catch new kinds of errors in the programs you compile. In later chapters, you’ll keep expanding the semantic analysis stage to detect more errors and gather additional information that you’ll need later in compilation. Next, you’ll implement your first control-flow constructs: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>