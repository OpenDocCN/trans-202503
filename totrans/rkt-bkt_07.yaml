- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OPERATING SYSTEM BOOT PROCESS ESSENTIALS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces you to the most important bootkit-related aspects of
    the Microsoft Windows boot process. Because the goal of the bootkit is to hide
    on a target system at a very low level, it needs to tamper with the OS boot components.
    So, before we can dive into how bootkits are built and how they behave, you’ll
    need to understand how the boot process works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '*The information in this chapter applies to Microsoft Windows Vista and later
    versions; the boot process for earlier versions of Windows differs, as explained
    in* “[*The* bootmgr *Module and Boot Configuration Data*](ch05.xhtml#ch05lev2sec4)”
    *on [page 64](ch05.xhtml#page_64).*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The boot process is one of the most important yet least understood phases of
    operating system operation. Although the general concept is universally familiar,
    few programmers—including systems programmers—understand it in detail, and most
    lack the tools to do so. This makes the boot process fertile ground for attackers
    to leverage the knowledge they’ve gleaned from reverse engineering and experimentation,
    while programmers must often rely on documentation that’s incomplete or outdated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: From a security point of view, the boot process is responsible for starting
    the system and bringing it to a trustworthy state. The logical facilities that
    defensive code uses to check the state of a system are also created during this
    process, so the earlier an attacker manages to compromise a system, the easier
    it is to hide from a defender’s checks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we review the basics of the boot process in Windows systems
    running on machines with legacy firmware. The boot process for machines running
    UEFI firmware, introduced in Windows 7 x64 SP1, is significantly different from
    legacy-based machines, so we’ll discuss that process separately in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we approach the boot process from the attacker’s point
    of view. Although nothing prevents attackers from targeting a specific chipset
    or peripheral—and indeed some do—these kinds of attacks do not scale well and
    are hard to develop reliably. It’s in the attacker’s best interest, therefore,
    to target interfaces that are relatively generic, yet not so generic that defensive
    programmers could easily understand and analyze the attacks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, offensive research pushes the envelope, digging deeper into the
    system as advances become public and transparent. The organization of this chapter
    underscores this point: we’ll begin with a general overview but progress to undocumented
    (at the time of this writing) data structures and a logic flow that can be gleaned
    only from disassembling the system—exactly the route that both bootkit researchers
    and malware creators follow.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**High-Level Overview of the Windows Boot Process**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) shows the general flow of the modern boot
    process. Almost any part of the process can be attacked by a bootkit, but the
    most common targets are the Basic Input/Output System (BIOS) initialization, the
    Master Boot Record (MBR), and the operating system bootloader.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/05fig01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: The flow of the system boot process*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '*Secure Boot technology, which we’ll discuss in [Chapter 17](ch17.xhtml#ch17),
    aims to protect the modern boot process, including its complex and versatile UEFI
    parts.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As the boot process progresses, the execution environment becomes more complex,
    offering the defender richer and more familiar programming models. However, it’s
    the lower-level code that creates and supports these abstracted models, so by
    targeting that code, attackers can manipulate the models to intercept the flow
    of the boot process and interfere with the higher-level system state. In this
    way, more abstract and powerful models can be crippled, which is exactly the point
    of a bootkit.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**The Legacy Boot Process**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand a technology, it is helpful to review its previous iterations.
    Here’s a basic summary of the boot process as it was normally executed in the
    heyday of boot sector viruses (1980s–2000s), such as Brain (discussed in [Chapter
    4](ch04.xhtml#ch04)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Power on (a cold boot)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power supply self-test
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ROM BIOS execution
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ROM BIOS test of hardware
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Video test
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memory test
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power-On Self-Test (POST), a full hardware check (this step can be skipped when
    the boot process is a *warm* or *soft boot*—that is, a boot from a state that
    isn’t completely off)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test for the MBR at the first sector of the default boot drive, as specified
    in the BIOS setup
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MBR execution
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operating system file initialization
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Base device driver initializations
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Device status check
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuration file reading
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Command shell loading
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shell’s startup command file execution
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the early boot process begins by testing and initializing the hardware.
    This is often still the case, though many hardware and firmware technologies have
    moved on since Brain and its immediate successors. The boot processes described
    later in this book differ from earlier iterations in terminology and complexity,
    but the overall principles are similar.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**The Windows Boot Process**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 5-2](ch05.xhtml#ch05fig02) shows a high-level picture of the Windows
    boot process and the components involved, applicable to Windows versions Vista
    and higher. Each block in the figure represents modules that are executed and
    given control during the boot process, in order from top to bottom. As you can
    see, it’s quite similar to the iterations of the legacy boot process. However,
    as the components of modern Windows operating systems have increased in complexity,
    so too have the modules involved in the boot process.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/05fig02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: A high-level view of the Windows boot process*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few sections, we’ll refer to this figure as we walk through this
    boot process in more detail. As [Figure 5-2](ch05.xhtml#ch05fig02) shows, when
    a computer is first powered on, the BIOS boot code receives control. This is the
    start of the boot process as the software sees it; other logic is involved at
    the hardware/firmware level (for example, during chipset initialization) but is
    not visible to software during the boot process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '***BIOS and the Preboot Environment***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BIOS performs basic system initialization and a POST to ensure that the
    critical system hardware is working properly. The BIOS also provides a specialized
    environment that includes the basic services needed to communicate with system
    devices. This simplified I/O interface first becomes available in the preboot
    environment, and is later replaced by different operating system abstractions
    for the majority of Windows uses. The most interesting of these services in terms
    of bootkit analysis is the *disk service*, which exposes a number of entry points
    used to perform disk I/O operations. The disk service is accessible through a
    special handler known as the *interrupt 13h handler*, or simply INT 13h. Bootkits
    will often target the disk service by tampering with its INT 13h; they do this
    in an effort to disable or circumvent OS protections by modifying operating system
    and boot components that are read from the hard drive during system startup.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Next, the BIOS looks for the bootable disk drive, which hosts the instance of
    the operating system to be loaded. This may be a hard drive, a USB drive, or a
    CD drive. Once the bootable device has been identified, the BIOS boot code loads
    the MBR, as [Figure 5-2](ch05.xhtml#ch05fig02) shows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '***The Master Boot Record***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The MBR is a data structure containing information on hard drive partitions
    and the boot code. Its main task is to determine the active partition of the bootable
    hard drive, which contains the instance of the OS to load. Once it has identified
    the active partition, the MBR reads and executes its boot code. [Listing 5-1](ch05.xhtml#ch05list01)
    shows the structure of the MBR.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: The structure of the MBR*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the MBR boot code ➊ is restricted to just 446 bytes (0x1BE in
    hexadecimal, a familiar value to reverse engineers of boot code), so it can implement
    only basic functionality. Next, the MBR parses the partition table, shown at ➋,
    in order to locate the active partition; reads the Volume Boot Record (VBR) in
    its first sector; and transfers control to it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition Table**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The partition table in the MBR is an array of four elements, each of which is
    described by the `MBR_PARTITION_TABLE_ENTRY` structure shown in [Listing 5-2](ch05.xhtml#ch05list02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: The structure of the partition table entry*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The first byte ➊ of the `MBR_PARTITION_TABLE_ENTRY`, the `status` field, signifies
    whether the partition is active. Only one partition at any time may be marked
    as active, a status indicated with a value of 128 (0x80 in hexadecimal).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`MBR_PARTITION_TABLE_ENTRY` 的第一个字节 ➊，即 `status` 字段，表示分区是否为活动分区。任何时候只能有一个分区被标记为活动分区，其状态由值
    128（十六进制为 0x80）表示。'
- en: 'The `type` field ➋ lists the partition type. The most common types are:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 字段 ➋ 列出了分区类型。最常见的类型有：'
- en: EXTENDED MBR partition type
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 MBR 分区类型
- en: FAT12 filesystem
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FAT12 文件系统
- en: FAT16 filesystem
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FAT16 文件系统
- en: FAT32 filesystem
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FAT32 文件系统
- en: IFS (Installable File System used for the installation process)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IFS（用于安装过程的可安装文件系统）
- en: LDM (Logical Disk Manager for Microsoft Windows NT)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDM（Microsoft Windows NT 的逻辑磁盘管理器）
- en: NTFS (the primary Windows filesystem)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NTFS（主要的 Windows 文件系统）
- en: A type of `0` means *unused*. The fields `lbaStart` and `size` ➌ define the
    location of the partition on disk, expressed in sectors. The `lbaStart` field
    contains the offset of the partition from the beginning of the hard drive, and
    the `size` field contains the size of the partition.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `0` 表示 *未使用*。字段 `lbaStart` 和 `size` ➌ 定义了分区在磁盘上的位置，单位为扇区。`lbaStart` 字段包含分区相对于硬盘起始位置的偏移量，`size`
    字段包含分区的大小。
- en: '**Microsoft Windows Drive Layout**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Microsoft Windows 驱动器布局**'
- en: '[Figure 5-3](ch05.xhtml#ch05fig03) shows the typical bootable hard drive layout
    of a Microsoft Windows system with two partitions.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](ch05.xhtml#ch05fig03) 显示了一个典型的 Microsoft Windows 系统的可启动硬盘布局，包含两个分区。'
- en: The Bootmgr partition contains the *bootmgr* module and some other OS boot components,
    while the OS partition contains a volume that hosts the OS and user data. The
    *bootmgr* module’s main purpose is to determine which particular instance of the
    OS to load. If multiple operating systems are installed on the computer, *bootmgr*
    displays a dialog prompting the user to choose one. The *bootmgr* module also
    provides parameters that determine how the OS is loaded (whether it should be
    in safe mode, using the last-known good configuration, with driver signature enforcement
    disabled, and so on).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Bootmgr 分区包含 *bootmgr* 模块和一些其他的操作系统启动组件，而操作系统分区则包含一个主机操作系统和用户数据的卷。*bootmgr*
    模块的主要作用是决定加载哪个特定的操作系统实例。如果计算机上安装了多个操作系统，*bootmgr* 会显示一个对话框提示用户选择其中一个。*bootmgr*
    模块还提供了一些参数，用以决定操作系统如何加载（例如是否以安全模式启动、使用最后一次良好配置、禁用驱动程序签名强制等）。
- en: '![image](../images/05fig03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig03.jpg)'
- en: '*Figure 5-3: The typical bootable hard drive layout*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：典型的可启动硬盘布局*'
- en: '***The Volume Boot Record and Initial Program Loader***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***卷引导记录和初始程序加载器***'
- en: The hard drive may contain several partitions hosting multiple instances of
    different operating systems, but only one partition should normally be marked
    as active. The MBR does not contain the code to parse the particular filesystem
    used on the active partition, so it reads and executes the first sector of the
    partition, the VBR, shown in the third layer of [Figure 5-2](ch05.xhtml#ch05fig02).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘可能包含多个分区，主机上有多个不同操作系统实例，但通常只有一个分区应该标记为活动分区。MBR 不包含解析活动分区上特定文件系统的代码，因此它读取并执行分区的第一个扇区，即
    VBR，见 [图 5-2](ch05.xhtml#ch05fig02)。
- en: The VBR contains partition layout information, which specifies the type of filesystem
    in use and its parameters, and code that reads the Initial Program Loader (IPL)
    module from the active partition. The IPL module implements filesystem-parsing
    functionality in order to be able to read files from the partition’s filesystem.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 包含分区布局信息，指定正在使用的文件系统类型及其参数，并包含从活动分区读取初始程序加载器（IPL）模块的代码。IPL 模块实现文件系统解析功能，以便能够从分区的文件系统中读取文件。
- en: '[Listing 5-3](ch05.xhtml#ch05list03) shows the layout of the VBR, which is
    composed of `BIOS_PARAMETER_BLOCK_NTFS` and `BOOTSTRAP_CODE` structures. The layout
    of the `BIOS_PARAMETER_BLOCK` (BPB) structure is specific to the volume’s filesystem.
    The `BIOS_PARAMETER_BLOCK_NTFS` and `VOLUME_BOOT_RECORD` structures correspond
    to the NTFS volume.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-3](ch05.xhtml#ch05list03) 显示了 VBR 的布局，由 `BIOS_PARAMETER_BLOCK_NTFS` 和
    `BOOTSTRAP_CODE` 结构组成。`BIOS_PARAMETER_BLOCK`（BPB）结构的布局特定于卷的文件系统。`BIOS_PARAMETER_BLOCK_NTFS`
    和 `VOLUME_BOOT_RECORD` 结构对应于 NTFS 卷。'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: VBR layout*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：VBR 布局*'
- en: Notice that the VBR starts with a `jmp` instruction ➋, which transfers control
    of the system to the VBR code. The VBR code in turn reads and executes the IPL
    from the partition, the location of which is specified by the `HiddenSectors`
    field ➊. The IPL reports its offset (in sectors) from the beginning of the hard
    drive. The layout of the VBR is summarized in [Figure 5-4](ch05.xhtml#ch05fig04).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/05fig04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: The structure of the VBR*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the VBR essentially consists of the following components:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The VBR code responsible for loading the IPL
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BIOS parameter block (a data structure that stores the volume parameters)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text strings displayed to a user if an error occurs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0xAA55, a 2-byte signature of the VBR
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IPL usually occupies 15 consecutive sectors of 512 bytes each and is located
    right after the VBR. It implements just enough code to parse the partition’s filesystem
    and continue loading the *bootmgr* module. The IPL and VBR are used together because
    the VBR can occupy only one sector and cannot implement sufficient functionality
    to parse the volume’s filesystem with so little space available to it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '***The bootmgr Module and Boot Configuration Data***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The IPL reads and loads the OS boot manager’s *bootmgr* module from the filesystem,
    shown in the fourth layer of [Figure 5-2](ch05.xhtml#ch05fig02). Once the IPL
    runs, *bootmgr* takes over the boot process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The *bootmgr* module reads from the Boot Configuration Data (BCD), which contains
    several important system parameters, including those that affect security policies
    such as the Kernel-Mode Code Signing Policy, covered in [Chapter 6](ch06.xhtml#ch06).
    Bootkits often attempt to bypass *bootmgr*’s implementation of code integrity
    verification.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**ORIGINS OF THE BOOTMGR MODULE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The *bootmgr* module was introduced in Windows Vista to replace the `ntldr`
    bootloader found in previous NT-derived versions of Windows. Microsoft’s idea
    was to create an additional layer of abstraction in the boot chain in order to
    isolate the preboot environment from the OS kernel layer. Isolation of the boot
    modules from the OS kernel brought improvements in boot management and security
    to Windows, making it easier to enforce security policies imposed on the kernel-mode
    modules (such as the Kernel-Mode Code Signing Policy). The legacy `ntldr` was
    split into two modules: *bootmgr* and *winload.exe* (or *winresume.exe* if the
    OS is loaded from the hibernation). Each module implements distinct functionality.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The *bootmgr* module manages the boot process until the user chooses a boot
    option (as shown in [Figure 5-5](ch05.xhtml#ch05fig05) for Windows 10). The program
    *winload.exe* (or *winresume.exe*) loads the kernel, boot-start drivers, and some
    system registry data once the user makes a choice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/05fig05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: The* bootmgr *boot menu in Windows 10*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Real Mode vs. Protected Mode**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When a computer is first powered on, the CPU operates in *real mode*, a legacy
    execution mode that uses a 16-bit memory model in which each byte in RAM is addressed
    by a pointer consisting of two words (2 bytes): *segment_start*:*segment_offset*.
    This mode corresponds to the *segment memory model*, where the address space is
    divided into segments. The address of every target byte is described by the address
    of the segment and the offset of the target byte within the segment. Here, *segment_start*
    specifies the target segment, and *segment_offset* is the offset of the referenced
    byte in the target segment.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The real-mode addressing scheme allows the use of only a small amount of the
    available system RAM. Specifically, the real (physical) address in the memory
    is computed as the largest address, represented as ffff:ffff, which is only 1,114,095
    bytes (65,535 × 16 + 65,535), meaning the address space in real mode is limited
    to around 1 MB—obviously not sufficient for modern operating systems and applications.
    To circumvent this limitation and get access to all available memory, *bootmgr*
    and *winload.exe* switch the processor into *protected mode* (called *long mode*
    on 64-bit systems) once *bootmgr* takes over.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The *bootmgr* module consists of 16-bit real-mode code and a compressed PE image,
    which, when uncompressed, is executed in protected mode. The 16-bit code extracts
    and uncompresses the PE from the *bootmgr* image, switches the processor into
    protected mode, and passes control to the uncompressed module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*Bootkits must properly handle the processor execution mode switch in order
    to maintain control of the boot code execution. After the switch, the whole memory
    layout is changed, and parts of the code previously located at one contiguous
    set of memory addresses may be moved to different memory segments. Bootkits must
    implement rather sophisticated functionality to get around this and keep control
    of the boot process.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**BCD Boot Variables**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the *bootmgr* initializes protected mode, the uncompressed image receives
    control and loads boot configuration information from the BCD. When stored on
    the hard drive, the BCD has the same layout as a registry hive. (To browse its
    contents, use `regedit` and navigate to the key *HKEY_LOCAL_MACHINE\BCD000000*.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '*To read from the hard drive,* bootmgr, *operating in protected mode, uses
    the INT 13h disk service, which is intended to be run in real mode. To do so,*
    bootmgr *saves the execution context of the processor in temporary variables,
    temporarily switches to real mode, executes the INT 13h handler, and then returns
    to protected mode, restoring the saved context.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The BCD store contains all the information *bootmgr* needs in order to load
    the OS, including the path to the partition containing the OS instance to load,
    available boot applications, code integrity options, and parameters instructing
    the OS to load in preinstallation mode, safe mode, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](ch05.xhtml#ch05tab01) shows the parameters in the BCD of greatest
    interest to bootkit authors.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-1](ch05.xhtml#ch05tab01)显示了在BCD中最受bootkit作者关注的参数。'
- en: '**Table 5-1:** BCD Boot Variables'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1:** BCD启动变量'
- en: '| **Variable name** | **Description** | **Parameter type** | **Parameter ID**
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **变量名称** | **描述** | **参数类型** | **参数ID** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `BcdLibraryBoolean_DisableIntegrityCheck` | Disables kernel-mode code integrity
    checks | `Boolean` | `0x16000048` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `BcdLibraryBoolean_DisableIntegrityCheck` | 禁用内核模式代码完整性检查 | `Boolean` | `0x16000048`
    |'
- en: '| `BcdOSLoaderBoolean_WinPEMode` | Tells the kernel to load in preinstallation
    mode, disabling kernel-mode code integrity checks as a byproduct | `Boolean` |
    `0x26000022` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `BcdOSLoaderBoolean_WinPEMode` | 告诉内核以预安装模式加载，并作为副作用禁用内核模式代码完整性检查 | `Boolean`
    | `0x26000022` |'
- en: '| `BcdLibraryBoolean_AllowPrereleaseSignatures` | Enables test signing (TESTSIGNING)
    | `Boolean` | `0x1600004` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `BcdLibraryBoolean_AllowPrereleaseSignatures` | 启用测试签名（TESTSIGNING） | `Boolean`
    | `0x1600004` |'
- en: The variable `BcdLibraryBoolean_DisableIntegrityCheck` is used to disable integrity
    checks and allow the loading of unsigned kernel-mode drivers. This option is ignored
    in Windows 7 and higher and cannot be set if Secure Boot (discussed in [Chapter
    17](ch17.xhtml#ch17)) is enabled.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`BcdLibraryBoolean_DisableIntegrityCheck`用于禁用完整性检查并允许加载未签名的内核模式驱动程序。此选项在Windows
    7及更高版本中被忽略，如果启用了安全启动（参见[第17章](ch17.xhtml#ch17)），则无法设置此选项。
- en: The variable `BcdOSLoaderBoolean_WinPEMode` indicates that the system should
    be started in Windows Preinstallation Environment Mode, which is essentially a
    minimal Win32 operating system with limited services that is primarily used to
    prepare a computer for Windows installation. This mode also disables kernel integrity
    checks, including the Kernel-Mode Code Signing Policy mandatory on 64-bit systems.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`BcdOSLoaderBoolean_WinPEMode`表示系统应以Windows预安装环境模式启动，这本质上是一个最小化的Win32操作系统，提供有限的服务，主要用于为Windows安装准备计算机。此模式还会禁用内核完整性检查，包括在64位系统上强制执行的内核模式代码签名策略。
- en: The variable `BcdLibraryBoolean_AllowPrereleaseSignatures` uses test code-signing
    certificates to load kernel-mode drivers for testing purposes. These certificates
    can be generated through tools included in the Windows Driver Kit. (The *Necurs*
    rootkit uses this process to install a malicious kernel-mode driver onto a system,
    signed with a custom certificate.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`BcdLibraryBoolean_AllowPrereleaseSignatures`使用测试代码签名证书加载内核模式驱动程序用于测试目的。这些证书可以通过包含在Windows驱动程序工具包中的工具生成。（*Necurs*根套件利用此过程将恶意的内核模式驱动程序安装到系统中，该驱动程序由自定义证书签名。）
- en: After retrieving boot options, the *bootmgr* performs self-integrity verification.
    If the check fails, the *bootmgr* stops booting the system and displays an error
    message. However, the *bootmgr* doesn’t perform the self-integrity check if either
    `BcdLibraryBoolean_DisableIntegrityCheck` or `BcdOSLoaderBoolean_WinPEMode` is
    set to `TRUE` in the BCD. Thus, if either variable is `TRUE`, the *bootmgr* won’t
    notice if it has been tampered with by malicious code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到启动选项后，*bootmgr*执行自完整性验证。如果验证失败，*bootmgr*会停止启动系统并显示错误信息。然而，如果`BcdLibraryBoolean_DisableIntegrityCheck`或`BcdOSLoaderBoolean_WinPEMode`在BCD中被设置为`TRUE`，*bootmgr*则不会执行自完整性检查。因此，如果任一变量为`TRUE`，*bootmgr*将不会注意到其是否已被恶意代码篡改。
- en: Once all the necessary BCD parameters have been loaded and self-integrity verification
    has been passed, the *bootmgr* chooses the boot application to load. When loading
    the OS afresh from the hard drive, the *bootmgr* chooses *winload.exe*; when resuming
    from hibernation, the *bootmgr* chooses *winresume.exe*. These respective PE modules
    are responsible for loading and initializing OS kernel modules. The *bootmgr*
    checks the integrity of the boot application in the same way, again skipping verification
    if either `BcdLibraryBoolean_DisableIntegrityCheck` or `BcdOSLoaderBoolean_WinPEMode`
    is `TRUE`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有必要的BCD参数已加载且自完整性验证通过，*bootmgr*会选择要加载的启动应用程序。当从硬盘重新加载操作系统时，*bootmgr*选择*winload.exe*；当从休眠状态恢复时，*bootmgr*选择*winresume.exe*。这些各自的PE模块负责加载和初始化操作系统内核模块。*bootmgr*以相同的方式检查启动应用程序的完整性，如果`BcdLibraryBoolean_DisableIntegrityCheck`或`BcdOSLoaderBoolean_WinPEMode`为`TRUE`，则再次跳过验证。
- en: In the final step of the boot process, once the user has chosen a particular
    instance of the OS to load, the *bootmgr* loads *winload.exe*. Once all modules
    are properly initialized, *winload.exe* (layer 5 in [Figure 5-2](ch05.xhtml#ch05fig02))
    passes control to the OS kernel, which continues the boot process (layer 6). Like
    *bootmgr*, *winload.exe* checks the integrity of all modules it is responsible
    for. Many bootkits attempt to circumvent these checks in order to inject a malicious
    module into the operating system kernel-mode address space.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'When *winload.exe* receives control of the operating system boot, it enables
    paging in protected mode and then loads the OS kernel image and its dependencies,
    including these modules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '***bootvid.dll*** A library for video VGA support at boot time'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '***ci.dll*** The code integrity library'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '***clfs.dll*** The common logging filesystem driver'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '***hal.dll*** The hardware abstraction layer library'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '***kdcom.dll*** The kernel debugger protocol communications library'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '***pshed.dll*** The platform-specific hardware error driver'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these modules, *winload.exe* loads boot-start drivers, including
    storage device drivers, Early Launch Anti-Malware (ELAM) modules (explained in
    [Chapter 6](ch06.xhtml#ch06)), and the system registry hive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '*In order to read all the components from the hard drive,* winload.exe *uses
    the interface provided by* bootmgr. *This interface relies on the BIOS INT 13h
    disk service. Therefore, if the INT 13h handler is hooked by a bootkit, the malware
    can spoof all data read by* winload.exe.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: When loading the executables, *winload.exe* verifies their integrity according
    to the system’s code integrity policy. Once all modules are loaded, *winload.exe*
    transfers control to the OS kernel image to initialize them, as discussed in the
    following chapters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about the MBR and VBR in the early boot stages,
    as well as important boot components such as *bootmgr* and *winload.exe*, from
    the point of view of bootkit threats.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, transferring control between the phases of the boot process
    is not as simple as jumping directly to the next stage. Instead, several components
    that are related through various data structures—such as the MBR partition table,
    the VBR BIOS parameter block, and the BCD—determine execution flow in the preboot
    environment. This nontrivial relationship is one reason why bootkits are so complex
    and why they make so many modifications to boot components in order to transfer
    control from the original boot code to their own (and occasionally back and forth,
    to carry out essential tasks).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look at boot process security, focusing on the ELAM
    and the Microsoft Kernel-Mode Code Signing Policy, which defeated the methods
    of early rootkits.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
