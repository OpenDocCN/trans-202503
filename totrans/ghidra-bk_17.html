<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_285"/>
<h2 class="h2" id="ch14"><strong><span class="big">14</span><br/>Basic Ghidra Scripting</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">No application can meet every need of every user. It is just not possible to anticipate every potential use case that may arise. Ghidra’s open source model facilitates feature requests and innovative contributions by developers. However, sometimes you need to immediately address a problem at hand and can’t wait for someone else to implement new functionality. To support unanticipated use cases and programmatic control of Ghidra’s actions, Ghidra includes integrated scripting features.</p>
<p class="indent">Uses for scripts are infinite and can range from simple one-liners to full-blown programs that automate common tasks or perform complex analysis. In this chapter, we focus on the basic scripting that is provided through the CodeBrowser interface. We introduce the internal scripting environment, discuss script development using Java and Python, and then move on to other integrated scripting options in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
<span epub:type="pagebreak" id="page_286"/>
<h3 class="h3" id="ch14lev231"><strong>Script Manager</strong></h3>
<p class="noindent">The Ghidra Script Manager is available through the CodeBrowser menu. Choosing Window ▸ Script Manager opens the window shown in <a href="ch14.xhtml#fig14_1">Figure 14-1</a>. The window can also be opened using the Script Manager icon in the CodeBrowser toolbar (a green circle with an arrow inside, also shown in the top left of the Script Manager window).</p>
<div class="image"><img src="Images/fig14-1.jpg" alt="image" width="844" height="518"/></div>
<p class="figcap" id="fig14_1"><em>Figure 14-1: Script Manager window</em></p>
<h4 class="h4" id="ch14lev232"><strong><em>Script Manager Window</em></strong></h4>
<p class="noindent">In a new Ghidra installation, the Script Manager loads with over 240 scripts organized in a category tree, as seen on the left side of <a href="ch14.xhtml#fig14_1">Figure 14-1</a>. Some of the folders contain subfolders to provide even more detailed classification of the scripts. You can expand and collapse the folders to see the organization of the scripts. Selecting an individual folder or subfolder limits the display to the scripts within the selected folder. To populate this window, Ghidra locates and indexes all scripts in subdirectories named <em>ghidra_scripts</em> within the Ghidra distribution folder. Ghidra also looks for a <em>ghidra_scripts</em> directory within your home directory and indexes any scripts it finds there.</p>
<p class="indentb">The default set of scripts covers a wide range of functionality. Some of the scripts are intended to demonstrate fundamental scripting concepts. The columns in the script list table provide additional detail about the purpose of each script. As with most Ghidra tables, you can control which <span epub:type="pagebreak" id="page_287"/>columns are displayed as well as the sort order for individual columns. By default, all available fields for the table are displayed except Created and Path. The six information columns provide the following insight into a script:</p>
<p class="uln-indent"><strong>Status</strong> Indicates the status of the script. The field is generally blank but can contain a red icon to indicate an error in the script. If you have associated a toolbar icon with the script, the icon will appear in this column.</p>
<p class="uln-indent"><strong>Name</strong> Contains the filename of the script, including its extension.</p>
<p class="uln-indent"><strong>Description</strong> A description pulled from the metadata comment within the script. This field can be quite lengthy, but you can read the entire contents by hovering over the field. This field is discussed in more depth in “<a href="ch14.xhtml#ch14lev234">Script Development</a>” on <a href="ch14.xhtml#page_289">page 289</a>.</p>
<p class="uln-indent"><strong>Key</strong> Indicates if there is a key binding assigned for running the script.</p>
<p class="uln-indent"><strong>Category</strong> Specifies the path at which the script will be listed in the Script Manager’s topic hierarchy. This is a logical hierarchy, <em>not</em> a filesystem directory hierarchy.</p>
<p class="uln-indent"><strong>Modified</strong> The date the script was last saved. For the default scripts the date is the installation date of the Ghidra instance.</p>
<p class="indenta">The filter field on the left side of the window searches through the script categories. The filter on the right searches the script names and descriptions. Finally, at the bottom, an additional window is initially empty. This window displays metadata about a selected script in an easy-to-process format that includes the field extracted from the metadata within the script. The format and meaning of the metadata fields are discussed in “<a href="ch14.xhtml#ch14lev235">Writing Java Scripts (Not JavaScript!)</a>” on <a href="ch14.xhtml#page_289">page 289</a>.</p>
<p class="indent">While the Script Manager provides a significant amount of information, the main power of this window comes from the toolbar it provides. An overview of the toolbar is provided in <a href="ch14.xhtml#fig14_2">Figure 14-2</a>.</p>
<h4 class="h4" id="ch14lev233"><strong><em>Script Manager Toolbar</em></strong></h4>
<p class="noindent">The Script Manager has no menus to help you manage your scripts. Instead, all script management actions are associated with tools on the Script Manager toolbar (<a href="ch14.xhtml#fig14_2">Figure 14-2</a>).</p>
<p class="indent">While most of the menu options are pretty clear from the descriptions in <a href="ch14.xhtml#fig14_2">Figure 14-2</a>, the Edit options merit additional discussion. Editing with Eclipse is covered in <a href="ch15.xhtml#ch15">Chapter 15</a>, as it facilitates more advanced scripting capabilities. The Edit Script option opens a primitive text editor window with its own toolbar, shown in <a href="ch14.xhtml#fig14_3">Figure 14-3</a>. The associated actions provide the basic functionality for editing files. With an editor in hand, we can get down to the business of writing actual scripts.</p>
<span epub:type="pagebreak" id="page_288"/>
<div class="image"><img src="Images/fig14-2.jpg" alt="image" width="676" height="682"/></div>
<p class="figcap" id="fig14_2"><em>Figure 14-2: Script Manager toolbar</em></p>
<div class="image"><img src="Images/fig14-3.jpg" alt="image" width="507" height="394"/></div>
<p class="figcap" id="fig14_3"><em>Figure 14-3: Edit Script toolbar</em></p>
<span epub:type="pagebreak" id="page_289"/>
<h3 class="h3" id="ch14lev234"><strong>Script Development</strong></h3>
<p class="noindent">There are several methods for developing scripts within Ghidra. In this chapter, we focus on scripting using Java and Python, as these are languages used by the existing scripts in the Script Manager window. Most of the 240+ system scripts are written in Java, so we begin with editing and developing scripts in Java.</p>
<h4 class="h4" id="ch14lev235"><strong><em>Writing Java Scripts (Not JavaScript!)</em></strong></h4>
<p class="noindent">In Ghidra, a script written in Java is actually a complete class specification designed to be seamlessly compiled, dynamically loaded into your running Ghidra instance, invoked, and finally unloaded. The class must extend the class <span class="literal">Ghidra.app.script.GhidraScript</span>, implement a <span class="literal">run()</span> method, and be annotated with comments that provide Javadoc-format metadata about the script. We’ll show the structure of a script file, describe the metadata requirements, look at some of the system scripts, and then move on to editing existing scripts and building our own scripts.</p>
<p class="indent"><a href="ch14.xhtml#fig14_4">Figure 14-4</a> shows the script editor opened when the Create New Script option (refer to <a href="ch14.xhtml#fig14_2">Figure 14-2</a>) is selected to create a new Java script. We have named the new script <em>CH14_NewScript</em>.</p>
<div class="image"><img src="Images/fig14-4.jpg" alt="image" width="518" height="642"/></div>
<p class="figcap" id="fig14_4"><em>Figure 14-4: A new, empty script</em></p>
<span epub:type="pagebreak" id="page_290"/>
<p class="indentb">At the top of the file are the metadata comments and tags used to produce the expected Javadoc information. This information is also used to populate the fields in the Script Manager window (refer to <a href="ch14.xhtml#fig14_1">Figure 14-1</a>). Any comments starting with <span class="literal">//</span> before the class, field, or method declarations will become part of the Javadoc Description for the script. Additional comments can be embedded within the script and will not be included in the description. In addition, the following tags within the metadata comments are supported:</p>
<p class="uln-indent"><span class="codestrong">@author</span> Provides information about the author of the script. The information is provided at the discretion of the author and can include any pertinent details (for example, name, contact information, date of creation, and so on).</p>
<p class="uln-indent"><span class="codestrong">@category</span> Determines where the script appears within the category tree. This is the only mandatory tag and must be present in all Ghidra scripts. The period (dot) character acts as a path separator for category names (for example, <span class="literal">@category Ghidrabook.CH14</span>).</p>
<p class="uln-indent"><span class="codestrong">@keybinding</span> Documents a shortcut for accessing the script from the CodeBrowser window (for example, <span class="literal">@keybinding K</span>).</p>
<p class="uln-indent"><span class="codestrong">@menupath</span> Defines a period-delimited menu path for the script as well as provides a means to run the script from a CodeBrowser menu (for example, <span class="literal">@menupath File.Run.ThisScript</span>).</p>
<p class="uln-indent"><span class="codestrong">@toolbar</span> Associates an icon with the script. This icon is displayed as a toolbar button in the CodeBrowser window and may be used to run the script. If Ghidra cannot find the image in the script directory or the Ghidra installation, a default image will be used (for example, <span class="literal">@toolbar myImage.png</span>).</p>
<p class="indenta">When confronted with a new API (such as the Ghidra API), it may take some time before you’re comfortable writing scripts without constantly consulting available API documentation. Java in particular is very sensitive to classpath issues and the proper inclusion of required support packages. A time- and sanity-saving option is to edit an existing program rather than creating a new program. We adopt this approach in presenting a simple example of a script.</p>
<h4 class="h4" id="ch14lev236"><strong><em>Edit Script Example: Regex Search</em></strong></h4>
<p class="noindent">Assume that you are tasked with developing a script to accept a regular expression as input from the user and output matching strings to the console. Further, this script needs to appear in the Script Manager for a particular project. While Ghidra offers many ways to accomplish this task, you have been asked to produce a script. To find a script with similar functionality to use as a base, you look through the categories in the Script Manager and check the contents of the Strings and Search categories, and then filter for the term <em>strings</em> and find other options. Using filters produces a more comprehensive list of string-related scripts for your consideration. For this example, you will edit the first script in the list that shares some functionality with what you want your script to do—<em>CountAndSaveStrings.java</em>.</p>
<span epub:type="pagebreak" id="page_291"/>
<p class="indent">Open the script in the editor to confirm that it’s a good starting point for our new functionality by right-clicking the desired script and selecting <strong>Edit</strong> with basic editor; then save this script with the new name, <em>FindStringsByRegex.java</em>, using the <strong>Save As</strong> option. Ghidra does not allow you to edit the system scripts provided as part of your Ghidra installation within the Script Manager window (although you can in Eclipse and other editors). You could also edit the file prior to using Save As since Ghidra prevents you from accidentally writing any modified content to the existing <em>CountAndSaveStrings.java</em> script.</p>
<p class="indent">The original <em>CountAndSaveStrings.java</em> contains the following metadata:</p>
<p class="programs"><span class="ent">➊</span> /* ###<br/>
   * IP: GHIDRA<br/>
   *<br/>
   * Licensed under the Apache License, Version 2.0 (the "License");<br/>
   * you may not use this file except in compliance with the License.<br/>
   * You may obtain a copy of the License at<br/>
   * http://www.apache.org/licenses/LICENSE-2.0<br/>
   * Unless required by applicable law or agreed to in writing, software<br/>
   * distributed under the License is distributed on an "AS IS" BASIS,<br/>
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/>
   * See the License for the specific language governing permissions and<br/>
   * limitations under the License.<br/>
   */<br/>
<span class="ent">➋</span>  //Counts the number of defined strings in the current selection,<br/>
   //or current program if no selection is made,<br/>
   //and saves the results to a file.<br/>
<span class="ent">➌</span> //@category CustomerSubmission.Strings</p>
<p class="indent">We can leave, modify, or delete the licensing agreement <span class="ent">➊</span> for the script without impacting the execution of the script or the associated Javadoc. We’ll modify the description of the script <span class="ent">➋</span> so that the information displayed in Javadoc and the Script Manager accurately describes the script. The script author has included only one of the five available tags <span class="ent">➌</span>, so we’ll add placeholders for the unpopulated tags and revise the description, as follows:</p>
<p class="programs">// Counts the number of defined strings that match a regex in the current<br/>
// selection, or current program if no selection is made, and displays the<br/>
// number of matching strings to the console.<br/>
//<br/>
//@author Ghidrabook<br/>
//@category Ghidrabook.CH14<br/>
//@keybinding<br/>
//@menupath<br/>
//@toolbar</p>
<p class="indent">The category tag <span class="literal">Ghidrabook.CH14</span> will be added to the Script Manager’s tree display, as shown in <a href="ch14.xhtml#fig14_5">Figure 14-5</a>.</p>
<p class="indent">The next portion of the original script contains Java <span class="literal">import</span> statements. Of the long list of imports Ghidra includes when you create a new script, as <span epub:type="pagebreak" id="page_292"/>shown in <a href="ch14.xhtml#fig14_4">Figure 14-4</a>, only the following imports are necessary for string searching, so we’ll keep the same list as the original <em>CountAndSaveStrings.java</em>:</p>
<p class="programs">import ghidra.app.script.GhidraScript;<br/>
import ghidra.program.model.listing.*;<br/>
import ghidra.program.util.ProgramSelection;<br/><br/>
import java.io.*;</p>
<p class="indent">Save the new script and then select it in the Script Manager to see the content shown in <a href="ch14.xhtml#fig14_5">Figure 14-5</a>. Our new category is included in the script tree, and the script’s metadata is displayed in the information window and script table. The table contains only one script, <em>Ghidrabook.CH14</em>, as it is the only script in the selected category.</p>
<div class="image"><img src="Images/fig14-5.jpg" alt="image" width="844" height="439"/></div>
<p class="figcap" id="fig14_5"><em>Figure 14-5: New script information displayed in the Script Manager window</em></p>
<p class="indent">As this book is not intended to be a Java tutorial, we summarize the changes we made to the script rather than explaining Java syntax and functionality. The following list describes the behavior of <em>CountAndSaveStrings.java</em>:</p>
<ol>
<li class="noindent">Get the program listing content to search.</li>
<li class="noindent">Get the file to save results to.</li>
<li class="noindent">Open the file.</li>
<li class="noindent">Iterate through the program listing: count the number of qualifying strings and write each qualifying string to the file.</li>
<li class="noindent">Close the file.</li>
<li class="noindent">Write the number of qualifying strings to the console.</li>
</ol>
<span epub:type="pagebreak" id="page_293"/>
<p class="indent">The functionality we desire in our modified script is described next:</p>
<ol>
<li class="noindent">Get the program listing content to search.</li>
<li class="noindent">Ask the user for a regular expression (regex) to search for.</li>
<li class="noindent">Iterate through the program listing: count the number of qualifying strings and write each qualifying string to the console.</li>
<li class="noindent">Write the number of qualifying strings to the console.</li>
</ol>
<p class="indent">Our new script will be significantly shorter than the original script, as there is no need to interact with the filesystem and perform associated error checking. Our implementation follows:</p>
<p class="programs">public class FindStringsByRegex extends GhidraScript<span class="ent">➊</span> {<br/>
   @Override<br/>
   public void run() throws Exception {<br/>
      String regex =<br/>
         askString("Please enter the regex",<br/>
         Please enter the regex you're looking to match:);<br/><br/>
      Listing listing = currentProgram.getListing();<br/><br/>
      DataIterator dataIt;<br/>
      if (currentSelection != null) {<br/>
          dataIt = listing.getDefinedData(currentSelection, true);<br/>
      }<br/>
      else {<br/>
         dataIt = listing.getDefinedData(true);<br/>
      }<br/><br/>
      Data data;<br/>
      String type;<br/>
      int counter = 0;<br/>
      while (dataIt.hasNext() &amp;&amp; !monitor.isCancelled()) {<br/>
         data = dataIt.next();<br/>
         type = data.getDataType().getName().toLowerCase();<br/>
         if (type.contains("unicode") || type.contains("string")) {<br/>
            String s = data.getDefaultValueRepresentation();<br/>
            if (s.matches(regex)) {<br/>
               counter++;<br/>
               println(s);<br/>
            }<br/>
         }<br/>
      }<br/>
      println(counter + " matching strings were found");<br/>
   }<br/>
}</p>
<span epub:type="pagebreak" id="page_294"/>
<p class="indent">All Java scripts that you write for Ghidra must extend (inherit from) an existing class named <span class="literal">Ghidra.app.script.GhidraScript</span> <span class="ent">➊</span>. After saving the final version of the script, select it from within the Script Manager and execute it. When the script executes, we see the prompt shown in <a href="ch14.xhtml#fig14_6">Figure 14-6</a>. This figure includes the regular expression that we will be searching for to test our script.</p>
<div class="image"><img src="Images/fig14-6.jpg" alt="image" width="548" height="194"/></div>
<p class="figcap" id="fig14_6"><em>Figure 14-6: New script prompt to enter a regex</em></p>
<p class="indent">The CodeBrowser console displays the following content when our new script has completed execution:</p>
<p class="programs">FindStringsByRegex.java&gt; Running...<br/>
FindStringsByRegex.java&gt; "Fatal error: glibc detected an invalid stdio handle\n"<br/>
FindStringsByRegex.java&gt; "Unknown error "<br/>
FindStringsByRegex.java&gt; "internal error"<br/>
FindStringsByRegex.java&gt; "relocation error"<br/>
FindStringsByRegex.java&gt; "symbol lookup error"<br/>
FindStringsByRegex.java&gt; "Fatal error: length accounting in _dl_exception_create_format\n"<br/>
FindStringsByRegex.java&gt; "Fatal error: invalid format in exception string\n"<br/>
FindStringsByRegex.java&gt; "error while loading shared libraries"<br/>
FindStringsByRegex.java&gt; "Unknown error"<br/>
FindStringsByRegex.java&gt; "version lookup error"<br/>
FindStringsByRegex.java&gt; "sdlerror.o"<br/>
FindStringsByRegex.java&gt; "dl-error.o"<br/>
FindStringsByRegex.java&gt; "fatal_error"<br/>
FindStringsByRegex.java&gt; "strerror.o"<br/>
FindStringsByRegex.java&gt; "strerror"<br/>
FindStringsByRegex.java&gt; "__strerror_r"<br/>
FindStringsByRegex.java&gt; "_dl_signal_error"<br/>
FindStringsByRegex.java&gt; "__dlerror"<br/>
FindStringsByRegex.java&gt; "_dlerror_run"<br/>
FindStringsByRegex.java&gt; "_dl_catch_error"<br/>
FindStringsByRegex.java&gt; 20 matching strings were found<br/>
FindStringsByRegex.java&gt; Finished!</p>
<p class="indent">This simple example demonstrates the low barrier to entry of Ghidra’s extensive Java scripting capabilities. Existing scripts can be easily modified and new scripts can be built from the ground up using the Script Manager. We present some more complex Java scripting capabilities in <a href="ch15.xhtml#ch15">Chapters 15</a> and <a href="ch16.xhtml#ch16">16</a>, but Java is just one of the scripting options provided by Ghidra. Ghidra also allows you to author scripts in Python.</p>
<span epub:type="pagebreak" id="page_295"/>
<h4 class="h4" id="ch14lev237"><strong><em>Python Scripts</em></strong></h4>
<p class="noindent">Of the 240+ scripts in the Script Manager, only a handful are written in Python. You can easily locate the Python scripts by filtering for the <em>.py</em> extension in the Script Manager. The majority of the Python scripts can be found in the Examples.Python category in the tree and includes a disclaimer similar to the one shown in <a href="ch14.xhtml#fig14_7">Figure 14-7</a>.</p>
<div class="image"><img src="Images/fig14-7.jpg" alt="image" width="677" height="384"/></div>
<p class="figcap" id="fig14_7"><em>Figure 14-7: Sample Python script with disclaimer</em></p>
<p class="indentb">Of the examples in this directory, the following three provide a good starting point if you prefer to use Python:</p>
<p class="uln-indent"><strong><em>ghidra_basic.py</em></strong> This script includes examples of basic Python scripting as related to Ghidra.</p>
<p class="uln-indent"><strong><em>python_basics.py</em></strong> This is a very basic introduction to many of the Python commands that you might want to use.</p>
<p class="uln-indent"><strong><em>jython_basic.py</em></strong> This extends the basic Python commands to demonstrate content that is specific to Jython.</p>
<p class="indenta">The Ghidra features demonstrated in these examples barely scratch the surface of the available Ghidra APIs. You’ll likely still need to spend some time reading through Ghidra’s library of Java examples before you’ll be ready to access Ghidra’s full Java API from your Python scripts.</p>
<p class="indent">In addition to running Python scripts, Ghidra provides the Python Interpreter to allow you to use Python/Jython to directly access the Java objects associated with Ghidra, as shown in <a href="ch14.xhtml#fig14_8">Figure 14-8</a>.</p>
<span epub:type="pagebreak" id="page_296"/>
<div class="box5">
<p class="boxtitle-c"><strong>GHIDRA’S PYTHON FUTURE</strong></p>
<p class="noindent">Python is popular for creating scripts because of its simplicity and numerous available libraries. While the majority of the scripts in the Ghidra release are written in Java, the open source RE community likely will use Python as a primary scripting language within Ghidra. Ghidra is reliant on Jython for Python support (which provides the advantage of allowing direct access to Ghidra’s Java objects). Jython is compatible with Python 2 (specifically 2.7.1) but not Python 3. Although Python 2 went end-of-life in January 2020, Python 2 scripts will continue to function within Ghidra, and any new Ghidra Python 2 scripts should be written in a way that makes them as portable as possible to Python 3.</p>
</div>
<div class="image"><img src="Images/fig14-8.jpg" alt="image" width="694" height="318"/></div>
<p class="figcap" id="fig14_8"><em>Figure 14-8: Python Interpreter</em> <span class="codeitalic">print</span> <em>example</em></p>
<p class="indent">The Python Interpreter is accessible through the CodeBrowser by selecting Windows ▸ Python. For more information about using the interpreter, see Ghidra Help. To get API information when using Python and the Python Interpreter, choose Help ▸ Ghidra API Help at the top left of the Interpreter window shown in <a href="ch14.xhtml#fig14_8">Figure 14-8</a>, which opens the Javadoc content on the <span class="literal">GhidraScript</span> class. Alternatively, Python has a built-in function, <span class="literal">help( )</span>, that has been modified in Ghidra to provide direct access to Ghidra’s Javadoc. To use the function, type <span class="literal">help(</span><span class="codeitalic">object</span><span class="literal">)</span> in the interpreter, as shown in <a href="ch14.xhtml#fig14_9">Figure 14-9</a>. For example, <span class="literal">help(currentProgram)</span> displays the Ghidra Javadoc content describing the Ghidra API class <span class="literal">ProgramDB</span>.</p>
<span epub:type="pagebreak" id="page_297"/>
<div class="image"><img src="Images/fig14-9.jpg" alt="image" width="694" height="515"/></div>
<p class="figcap" id="fig14_9"><em>Figure 14-9: Python Interpreter Help example</em></p>
<h4 class="h4" id="ch14lev238"><strong><em>Support for Other Languages</em></strong></h4>
<p class="noindent">Finally, Ghidra can support scripts from languages other than Java and Python, which lets you bring existing scripts from your reverse engineering toolkit into your Ghidra workflow. This functionality is discussed further in Ghidra Help.</p>
<h3 class="h3" id="ch14lev239"><strong>Introduction to the Ghidra API</strong></h3>
<p class="noindent">At this point, you have all the information required to edit and run Ghidra scripts. Now it’s time to use the Ghidra API to extend your scripting capabilities and interact more directly with Ghidra artifacts. Ghidra exposes its API in two rather different styles.</p>
<p class="indent">The <em>Program</em> API defines an object hierarchy, many levels deep, rooted at the top by the <span class="literal">Program</span> class. This API may change from one version of Ghidra to another. The <em>Flat</em> API flattens out the Program API by exposing all levels of that API from a single class, <span class="literal">FlatProgramAPI</span>. The Flat API is often the most convenient way to access many Ghidra constructs. Additionally, it is less likely to change from one version of Ghidra to the next.</p>
<p class="indent">For the remainder of the chapter, we highlight some of the more useful Flat API functionality. When necessary, we also provide detail about specific classes from the Program API. We use Java as the language for this discussion, as it is the native language of Ghidra.</p>
<span epub:type="pagebreak" id="page_298"/>
<p class="indent">The Ghidra API contains many packages, classes, and associated functions to interface with your Ghidra projects and associated files, all detailed in Javadoc-style documentation supplied with Ghidra that can be accessed by clicking the red plus in the Script Manager window. This documentation, in conjunction with the sample scripts supplied with Ghidra, is your primary reference about the APIs and how to use them. The most common way to figure out how to do something is to browse the Ghidra classes looking for one that, based on its name, appears to do what you need. As you gain more experience with Ghidra, your increased understanding of the naming conventions and file organization will help you identify appropriate classes more quickly.</p>
<p class="indent">Ghidra adheres to the Java Swing <em>model-delegate</em> architecture in which data values and characteristics are stored in model objects and displayed by user interface delegate objects such as tree, list, and table views. Delegates handle events, such as mouse clicks, to update and refresh data and views. In the overwhelming majority of cases, your scripts will focus on the data encapsulated in the model classes used to represent various program and reverse engineering constructs.</p>
<p class="indent">The remainder of this section focuses on commonly used model classes, their relationships to each other, and useful APIs for interacting with them. We make no attempt to cover the entire Ghidra API, and many more functions and classes are available. The authoritative documentation for the entire Ghidra API is the Javadoc that ships with Ghidra, and ultimately the Java source code from which Ghidra is built.</p>
<h4 class="h4" id="ch14lev240"><strong><em>The Address Interface</em></strong></h4>
<p class="noindent">The <span class="literal">Address</span> interface describes a model for an address within an address space. All addresses are represented by an offset up to 64 bits in size. Segmented addresses may be further qualified by a segment value. In many cases, an address’s offset is equivalent to a virtual address within a program listing. The <span class="literal">getOffset</span> method retrieves the <span class="literal">long</span> offset value from an <span class="literal">Address</span> instance. Many Ghidra API functions require <span class="literal">Address</span> objects as arguments or return an <span class="literal">Address</span> object as a result.</p>
<h4 class="h4" id="ch14lev241"><strong><em>The Symbol Interface</em></strong></h4>
<p class="noindent">The <span class="literal">Symbol</span> interface defines properties common to all symbols. At a minimum, a symbol is composed of a name and an address. These attributes may be retrieved with the following member functions:</p>
<p class="listhead"><span class="codestrong">Address getAddress()</span></p>
<p class="listbody">Returns the address of the <span class="literal">Symbol</span></p>
<p class="listhead"><span class="codestrong">String getName()</span></p>
<p class="listbody">Returns the name of the <span class="literal">Symbol</span></p>
<span epub:type="pagebreak" id="page_299"/>
<h4 class="h4" id="ch14lev242"><strong><em>The Reference Interface</em></strong></h4>
<p class="noindent">A <span class="literal">Reference</span> models a cross-reference relationship (as described in <a href="ch09.xhtml#ch09">Chapter 9</a>) between a source address and a destination address and is characterized by a reference type. Useful functions associated with a <span class="literal">Reference</span> include these:</p>
<p class="listhead"><span class="codestrong">public Address getFromAddress()</span></p>
<p class="listbody">Returns the source address for this reference</p>
<p class="listhead"><span class="codestrong">public Address getToAddress()</span></p>
<p class="listbody">Returns the destination address for this reference</p>
<p class="listhead"><span class="codestrong">public RefType getReferenceType()</span></p>
<p class="listbody">Returns a <span class="literal">RefType</span> object that describes the nature of the link between the source and destination addresses</p>
<h4 class="h4" id="ch14lev243"><strong><em>The GhidraScript Class</em></strong></h4>
<p class="noindent">Although this class doesn’t model a specific attribute in a binary, every script that you write must be a subclass of <span class="literal">GhidraScript</span>, which, in turn, is a subclass of <span class="literal">FlatProgramAPI</span>. As a result, your scripts have instantaneous access to the entire Flat API and your only obligation is to provide an implementation of</p>
<p class="programs">protected abstract void run() throws Exception;</p>
<p class="noindent">which, hopefully, makes your script do something interesting. The remainder of the <span class="literal">GhidraScript</span> class gives you access to the most common resources for interacting with the Ghidra user and the program that is being analyzed. Some of the more useful functions and data members of this class (including some inherited from <span class="literal">FlatProgramAPI</span>) are summarized in the following sections.</p>
<h5 class="h5" id="ch14lev244"><strong>Useful Data Members</strong></h5>
<p class="noindent">The <span class="literal">GhidraScript</span> class provides convenient access to a number of objects commonly referenced in scripts, including the following:</p>
<p class="listhead"><span class="codestrong">protected Program currentProgram;</span></p>
<p class="listbody">This is the current open program. The <span class="literal">Program</span> class is discussed later. This data member is likely your gateway to retrieving more interesting information, such as instruction and symbol lists.</p>
<p class="listhead"><span class="codestrong">protected Address currentAddress;</span></p>
<p class="listbody">This is the address of the current cursor location. The <span class="literal">Address</span> class is discussed later.</p>
<p class="listhead"><span class="codestrong">protected ProgramLocation currentLocation;</span></p>
<p class="listbody">A <span class="literal">ProgramLocation</span> object that describes the current cursor location, including its address, cursor row, column, and other information.</p>
<span epub:type="pagebreak" id="page_300"/>
<p class="listhead"><span class="codestrong">protected ProgramSelection currentSelection;</span></p>
<p class="listbody">A <span class="literal">ProgramSelection</span> object representing a range of addresses selected in the Ghidra GUI.</p>
<p class="listhead"><span class="codestrong">protected TaskMonitor monitor;</span></p>
<p class="listbody">The <span class="literal">TaskMonitor</span> class updates the status of long-running tasks and checks to determine whether a long-running task has been cancelled by the user (<span class="literal">monitor.isCancelled()</span>). Any long-running loops that you write should incorporate a call to <span class="literal">monitor.isCancelled</span> as an additional termination condition to recognize that the user has attempted to cancel your script.</p>
<h5 class="h5" id="ch14lev245"><strong>User Interface Functions</strong></h5>
<p class="noindent">The GhidraScript class provides convenience functions for basic user interface operations, ranging from simple message output to more interactive dialog elements. Some of the more common user interface functions are described here:</p>
<p class="listhead"><span class="codestrong">public void println(String message)</span></p>
<p class="listbody">Prints <span class="literal">message</span> followed by a linefeed to Ghidra’s console window. This function is useful for printing status messages or results of your scripts in a nonintrusive manner.</p>
<p class="listhead"><span class="codestrong">public void printf(String message, Object... args)</span></p>
<p class="listbody">Uses <span class="literal">message</span> as a Java format string and prints the resulting string of formatted <span class="literal">args</span> to Ghidra’s console window.</p>
<p class="listhead"><span class="codestrong">public void popup(final String message)</span></p>
<p class="listbody">Displays <span class="literal">message</span> in a pop-up dialog that requires the user to click OK before script execution can continue. This is a more intrusive way to display status messages to a user.</p>
<p class="listhead"><span class="codestrong">public String askString(String title, String message)</span></p>
<p class="listbody">One of many available <span class="literal">ask</span> functions. <span class="literal">askString</span> displays a text input dialog, using <span class="literal">message</span> as a prompt, and returns the text entered by the user.</p>
<p class="listhead"><span class="codestrong">public boolean askYesNo(String title, String question)</span></p>
<p class="listbody">Uses a dialog to ask the user a yes-or-no <span class="literal">question</span>. Returns <span class="literal">true</span> for yes, and <span class="literal">false</span> for no.</p>
<p class="listhead"><span class="codestrong">public Address askAddress(String title, String message)</span></p>
<p class="listbody">Displays a dialog, using <span class="literal">message</span> as a prompt, that parses the user’s input into an <span class="literal">Address</span> object.</p>
<p class="listhead"><span class="codestrong">public int askInt(String title, String message)</span></p>
<p class="listbody">Displays a dialog, using <span class="literal">message</span> as a prompt, that parses the user’s input into an <span class="literal">int</span>.</p>
<span epub:type="pagebreak" id="page_301"/>
<p class="listhead"><span class="codestrong">public File askFile(final String title, final String approveButtonText)</span></p>
<p class="listbody">Displays a system file chooser dialog and returns a Java <span class="literal">File</span> object representing the file selected by the user.</p>
<p class="listhead"><span class="codestrong">public File askDirectory(final String title, final String approveButtonText)</span></p>
<p class="listbody">Displays a system file chooser dialog and returns a Java <span class="literal">File</span> object representing the directory selected by the user.</p>
<p class="listhead"><span class="codestrong">public boolean goTo(Address address)</span></p>
<p class="listbody">Repositions all connected Ghidra disassembly windows to <span class="literal">address</span>. Overloaded versions of this function take a <span class="literal">Symbol</span> or a <span class="literal">Function</span> argument and navigate the displays accordingly.</p>
<h5 class="h5" id="ch14lev246"><strong>Address-Related Functions</strong></h5>
<p class="noindent">For a processor, an address is typically just a number that happens to refer to a memory location. Ghidra models addresses using the <span class="literal">Address</span> class. <span class="literal">GhidraScript</span> provides a wrapper function that offers easy conversion from numbers to Ghidra <span class="literal">Address</span> objects:</p>
<p class="listhead"><span class="codestrong">public Address toAddr(long offset)</span></p>
<p class="listbody">Convenience function to create an <span class="literal">Address</span> object in the default address space</p>
<h5 class="h5" id="ch14lev247"><strong>Reading Program Memory</strong></h5>
<p class="noindent">The <span class="literal">Memory</span> class represents contiguous ranges of byte values, such as the contents of an executable file loaded into Ghidra. Within a <span class="literal">Memory</span> object, every byte value is associated with an address, though addresses may be tagged as uninitialized and have no value to retrieve. Ghidra throws a <span class="literal">MemoryAccessException</span> if you attempt to access a location within a memory object with an invalid address. Consult the documentation for the <span class="literal">Memory</span> class for a full description of available API functions. The following convenience functions expose some of the <span class="literal">Memory</span> class via the Flat API:</p>
<p class="listhead"><span class="codestrong">public byte getByte(Address addr)</span></p>
<p class="listbody">Returns the single byte value retrieved from <span class="literal">addr</span>. Data type <span class="literal">byte</span> is a signed type in Java, so this value will be in the range –128..127.</p>
<p class="listhead"><span class="codestrong">public byte[] getBytes(Address addr, int length)</span></p>
<p class="listbody">Returns <span class="literal">length</span> bytes from memory, beginning at <span class="literal">addr</span>.</p>
<p class="listhead"><span class="codestrong">public int getInt(Address addr)</span></p>
<p class="listbody">Returns the 4-byte value, beginning at <span class="literal">addr</span>, as a Java <span class="literal">int</span>. This function is endianness-aware and respects the binary’s underlying architecture when reconstituting the <span class="literal">int</span> value.</p>
<span epub:type="pagebreak" id="page_302"/>
<p class="listhead"><span class="codestrong">public long getLong(Address addr)</span></p>
<p class="listbody">Returns the 8-byte value, beginning at <span class="literal">addr</span>, as a Java <span class="literal">long</span>. This function is endianness-aware and respects the binary’s underlying architecture when reconstituting the <span class="literal">long</span> value.</p>
<h5 class="h5" id="ch14lev248"><strong>Program Search Functions</strong></h5>
<p class="noindent">Ghidra’s search capabilities reside within different Program API classes according to the type of item being searched for. The <span class="literal">Memory</span> class contains raw byte search functionality. Code units (such as <span class="literal">Data</span> and <span class="literal">Instruction</span>), comment text, and associated iterators are obtained from the <span class="literal">Listing</span> class. Symbols/labels and associated iterators are accessed via the <span class="literal">SymbolTable</span> class. The following convenience functions expose some of the available search functionality via the Flat API:</p>
<p class="listhead"><span class="codestrong">public Data getFirstData()</span></p>
<p class="listbody">Returns the first data item in the program.</p>
<p class="listhead"><span class="codestrong">public Data getDataAfter(Data data)</span></p>
<p class="listbody">Returns the next data item after <span class="literal">data</span>, or <span class="literal">null</span> if no such data exists.</p>
<p class="listhead"><span class="codestrong">public Data getDataAt(Address address)</span></p>
<p class="listbody">Returns the data item at <span class="literal">address</span>, or <span class="literal">null</span> if no such data exists.</p>
<p class="listhead"><span class="codestrong">public Instruction getFirstInstruction()</span></p>
<p class="listbody">Returns the first instruction in the program.</p>
<p class="listhead"><span class="codestrong">public Instruction getInstructionAfter(Instruction instruction)</span></p>
<p class="listbody">Returns the next instruction item after <span class="literal">instruction</span>, or <span class="literal">null</span> if no such instruction exists.</p>
<p class="listhead"><span class="codestrong">public Instruction getInstructionAt(Address address)</span></p>
<p class="listbody">Returns the instruction at <span class="literal">address</span>, or <span class="literal">null</span> if no such instruction exists.</p>
<p class="listhead"><span class="codestrong">public Address find(String text)</span></p>
<p class="listbody">Searches for a <span class="literal">text</span> string within the Listing window. Listing components are searched in the following order:</p>
<ol>
<li class="noindent">Plate comments</li>
<li class="noindent">Pre comments</li>
<li class="noindent">Labels</li>
<li class="noindent">Code unit mnemonics and operands</li>
<li class="noindent">EOL comments</li>
<li class="noindent">Repeatable comments</li>
<li class="noindent">Post comments</li>
</ol>
<span epub:type="pagebreak" id="page_303"/>
<p class="listbody">A successful search returns the address containing the match. Note that as a result of the search order, the returned address may <em>not</em> represent the first occurrence of text in the disassembly listing when considered in strictly increasing address order.</p>
<p class="listhead"><span class="codestrong">public Address find(Address start, byte[] values);</span></p>
<p class="listbody">Searches memory, beginning at <span class="literal">addr</span>, for a specified sequence of byte <span class="literal">values</span>. When <span class="literal">addr</span> is <span class="literal">null</span>, the search begins at the lowest valid address in the binary. A successful search returns the address of the first byte in the matching sequence.</p>
<p class="listhead"><span class="codestrong">public Address findBytes(Address start, String byteString)</span></p>
<p class="listbody">Searches memory, beginning at <span class="literal">addr</span>, for a specified <span class="literal">byteString</span> that may contain regular expressions. When <span class="literal">addr</span> is <span class="literal">null</span>, the search begins at the lowest valid address in the binary. A successful search returns the address of the first byte in the matching sequence.</p>
<h5 class="h5" id="ch14lev249"><strong>Manipulating Label and Symbols</strong></h5>
<p class="noindent">The need to manipulate named locations arises fairly often in scripts. The following functions are available for working with named locations in a Ghidra database:</p>
<p class="listhead"><span class="codestrong">public Symbol getSymbolAt(Address address)</span></p>
<p class="listbody">Returns the <span class="literal">Symbol</span> associated with the given address, or <span class="literal">null</span> if the location has no <span class="literal">Symbol</span>.</p>
<p class="listhead"><span class="codestrong">public Symbol createLabel(Address address, String name, boolean makePrimary)</span></p>
<p class="listbody">Assigns the given <span class="literal">name</span> to the given <span class="literal">address</span>. Ghidra allows multiple names to be assigned to a single address. If <span class="literal">makePrimary</span> is <span class="literal">true</span>, the new name will become the primary name associated with <span class="literal">address</span>.</p>
<p class="listhead"><span class="codestrong">public List&lt;Symbol&gt; getSymbols(String name, Namespace namespace)</span></p>
<p class="listbody">Returns a list of all symbols named <span class="literal">name</span> in <span class="literal">namespace</span>. When namespace is <span class="literal">null</span>, the global namespace is searched. If the result is empty, the named symbol does not exist. If the result contains only one element, the name is unique.</p>
<h5 class="h5" id="ch14lev250"><strong>Working with Functions</strong></h5>
<p class="noindent">Many scripts are designed to analyze functions within a program. The following functions can be used to access information about program functions:</p>
<p class="listhead"><span class="codestrong">public final Function getFirstFunction()</span></p>
<p class="listbody">Returns the first <span class="literal">Function</span> object in the program</p>
<span epub:type="pagebreak" id="page_304"/>
<p class="listhead"><span class="codestrong">public Function getGlobalFunctions(String name)</span></p>
<p class="listbody">Returns the first <span class="literal">Function</span> object for the named function, or <span class="literal">null</span> if no such function exists</p>
<p class="listhead"><span class="codestrong">public Function getFunctionAt(Address entryPoint)</span></p>
<p class="listbody">Returns the <span class="literal">Function</span> object for the function at <span class="literal">entryPoint</span>, or <span class="literal">null</span> if no such function exists</p>
<p class="listhead"><span class="codestrong">public Function getFunctionAfter(Function function)</span></p>
<p class="listbody">Returns the <span class="literal">Function</span> object for the successor to <span class="literal">function</span>, or <span class="literal">null</span> if no such function exists</p>
<p class="listhead"><span class="codestrong">public Function getFunctionAfter(Address address)</span></p>
<p class="listbody">Returns the <span class="literal">Function</span> object for the function that starts after address, or <span class="literal">null</span> if no such function exists</p>
<h5 class="h5" id="ch14lev251"><strong>Working with Cross-References</strong></h5>
<p class="noindent">Cross-references were covered in <a href="ch09.xhtml#ch09">Chapter 9</a>. In the Ghidra Program API, the top-level <span class="literal">Program</span> object contains a <span class="literal">ReferenceManager</span>, which, unsurprisingly, manages the references within the program. As with many other program constructs, the Flat API offers convenience functions for accessing cross-references, some of which are detailed here:</p>
<p class="listhead"><span class="codestrong">public Reference[] getReferencesFrom(Address address)</span></p>
<p class="listbody">Returns an array of all <span class="literal">Reference</span> objects originating from <span class="literal">address</span></p>
<p class="listhead"><span class="codestrong">public Reference[] getReferencesTo(Address address)</span></p>
<p class="listbody">Returns an array of all <span class="literal">Reference</span> objects terminating at <span class="literal">address</span></p>
<h5 class="h5" id="ch14lev252"><strong>Program Manipulation Functions</strong></h5>
<p class="noindent">When automating your analysis tasks, you may find yourself wanting to add new information into a program. The Flat API provides a variety of functions for modifying the contents of a program, including the following:</p>
<p class="listhead"><span class="codestrong">public final void clearListing(Address address)</span></p>
<p class="listbody">Removes any instruction or data defined at <span class="literal">address</span>.</p>
<p class="listhead"><span class="codestrong">public void removeFunctionAt(Address address)</span></p>
<p class="listbody">Removes the function at <span class="literal">address</span>.</p>
<p class="listhead"><span class="codestrong">public boolean disassemble(Address address)</span></p>
<p class="listbody">Performs a recursive descent disassembly beginning at <span class="literal">address</span>. Returns <span class="literal">true</span> if the operation is successful.</p>
<p class="listhead"><span class="codestrong">public Data createByte(Address address)</span></p>
<p class="listbody">Converts the item at the specified address into a data byte. Also, <span class="literal">createWord</span>, <span class="literal">createDword</span>, <span class="literal">createQword</span>, and other data creation functions are available.</p>
<span epub:type="pagebreak" id="page_305"/>
<p class="listhead"><span class="codestrong">public boolean setEOLComment(Address address, String comment)</span></p>
<p class="listbody">Adds an EOL comment at the given <span class="literal">address</span>. Additional comment-related functions include <span class="literal">setPlateComment</span>, <span class="literal">setPreComment</span>, and <span class="literal">setPostComment</span>.</p>
<p class="listhead"><span class="codestrong">public Function createFunction(Address entryPoint, String name)</span></p>
<p class="listbody">Creates a function with the given <span class="literal">name</span> at <span class="literal">entryPoint</span>. Ghidra attempts to automatically identify the end of the function by locating the function’s return instruction.</p>
<p class="listhead"><span class="codestrong">public Data createAsciiString(Address address)</span></p>
<p class="listbody">Creates a null-terminated ASCII string at <span class="literal">address</span>.</p>
<p class="listhead"><span class="codestrong">public Data createAsciiString(Address address, int length)</span></p>
<p class="listbody">Creates an ASCII string of the specified <span class="literal">length</span> at <span class="literal">address</span>. If <span class="literal">length</span> is zero or less, Ghidra attempts to automatically locate the string’s null terminator.</p>
<p class="listhead"><span class="codestrong">public Data createUnicodeString(Address address)</span></p>
<p class="listbody">Creates a null-terminated Unicode string at <span class="literal">address</span>.</p>
<h4 class="h4" id="ch14lev253"><strong><em>The Program Class</em></strong></h4>
<p class="noindent">The <span class="literal">Program</span> class represents the root of the Program API hierarchy and outermost layer of the data model of a binary file. You will commonly use a <span class="literal">Program</span> object (often <span class="literal">currentProgram</span>) to access the binary model. Commonly used <span class="literal">Program</span> class member functions include the following:</p>
<p class="listhead"><span class="codestrong">public Listing getListing()</span></p>
<p class="listbody">Retrieves the <span class="literal">Listing</span> object for the current program.</p>
<p class="listhead"><span class="codestrong">public FunctionManager getFunctionManager()</span></p>
<p class="listbody">Retrieves the program’s <span class="literal">FunctionManager</span>, which provides access to all of the functions that have been identified within the binary. This class provides the functionality to map an <span class="literal">Address</span> back to its containing <span class="literal">Function</span> (<span class="literal">Function</span> <span class="literal">getFunctionContaining (</span><span class="literal">Address</span> <span class="literal">addr)</span>). In addition, it provides a <span class="literal">FunctionIterator</span>, which is useful when you want to process every function in the program.</p>
<p class="listhead"><span class="codestrong">public SymbolTable getSymbolTable()</span></p>
<p class="listbody">Retrieves the program’s <span class="literal">SymbolTable</span> object. Using a <span class="literal">SymbolTable</span>, you can work with individual symbols or iterate over every symbol in the program.</p>
<p class="listhead"><span class="codestrong">public Memory getMemory()</span></p>
<p class="listbody">Retrieves the <span class="literal">Memory</span> object associated with this program, which allows you to work with raw program byte content.</p>
<span epub:type="pagebreak" id="page_306"/>
<p class="listhead"><span class="codestrong">public ReferenceManager getReferenceManager()</span></p>
<p class="listbody">Retrieves the program’s <span class="literal">ReferenceManager</span> object. A <span class="literal">ReferenceManager</span> may be used to add and remove references as well as retrieve iterators for many types of references.</p>
<p class="listhead"><span class="codestrong">public Address getMinAddress()</span></p>
<p class="listbody">Returns the lowest valid address within the program. This is most often the binary’s base memory address.</p>
<p class="listhead"><span class="codestrong">public Address getMaxAddress()</span></p>
<p class="listbody">Returns the highest valid address within the program.</p>
<p class="listhead"><span class="codestrong">public LanguageID getLanguageID()</span></p>
<p class="listbody">Returns the object representation of the binary’s language specification. The language specification itself may then be retrieved using the <span class="literal">getIdAsString()</span> function.</p>
<h4 class="h4" id="ch14lev254"><strong><em>The Function Interface</em></strong></h4>
<p class="noindent">The <span class="literal">Function</span> interface defines the required Program API behaviors of function objects. Member functions provide access to various attributes commonly associated with functions and include the following:</p>
<p class="programs55"><span class="codestrong1">public String getPrototypeString(boolean formalSignature,<br/>
                                 boolean includeCallingConvention)</span></p>
<p class="listbody">Returns the <span class="literal">Function</span> object’s prototype as a string. The two arguments influence the format of the returned prototype string.</p>
<p class="listhead"><span class="codestrong">public AddressSetView getBody()</span></p>
<p class="listbody">Returns the address set that contains the function’s body of code. An <em>address set</em> is composed of one or more address ranges, and allows for situations in which a function’s code is distributed among several noncontiguous ranges of memory. Obtain an <span class="literal">AddressIterator</span> to visit all addresses in the set or an <span class="literal">AddressRangeIterator</span> to iterate over each range. Note that you must use a <span class="literal">Listing</span> object to retrieve the actual instructions contained in the function’s body (see <span class="literal">getInstructions</span>).</p>
<p class="listhead"><span class="codestrong">public StackFrame getStackFrame()</span></p>
<p class="listbody">Returns the stack frame associated with the function. The result may be used to retrieve detailed information about the layout of the function’s local variables and stack-based arguments.</p>
<h4 class="h4" id="ch14lev255"><strong><em>The Instruction Interface</em></strong></h4>
<p class="noindent">The <span class="literal">Instruction</span> interface defines the required Program API behaviors of instruction objects. Member functions provide access to various attributes commonly associated with instructions and include the following:</p>
<p class="listhead"><span class="codestrong">public String getMnemonicString()</span></p>
<p class="listbody">Returns the instruction’s mnemonic.</p>
<span epub:type="pagebreak" id="page_307"/>
<p class="listhead"><span class="codestrong">public String getComment(int commentType)</span></p>
<p class="listbody">Returns the <span class="literal">commentType</span> comment associated with the instruction or <span class="literal">null</span> if no comment of the given type is associated with the instruction. A <span class="literal">commentType</span> may be one of <span class="literal">EOL_COMMENT</span>, <span class="literal">PRE_COMMENT</span>, <span class="literal">POST_COMMENT</span>, or <span class="literal">REPEATABLE_COMMENT</span>.</p>
<p class="listhead"><span class="codestrong">public int getNumOperands()</span></p>
<p class="listbody">Returns the number of operands associated with this instruction.</p>
<p class="listhead"><span class="codestrong">public int getOperandType(int opIndex)</span></p>
<p class="listbody">Returns a bitmask of operand type flags defined in class <span class="literal">OperandType</span>.</p>
<p class="listhead"><span class="codestrong">public String toString()</span></p>
<p class="listbody">Returns the string representation of the instruction.</p>
<h3 class="h3" id="ch14lev256"><strong>Ghidra Scripting Examples</strong></h3>
<p class="noindent">For the remainder of the chapter, we present some fairly common situations in which a script can be used to answer a question about a program. For brevity, only the body of each script’s <span class="literal">run</span> function is shown.</p>
<h4 class="h4" id="ch14lev257"><strong><em>Example 1: Enumerating Functions</em></strong></h4>
<p class="noindent">Many scripts operate on individual functions. Examples include generating the call tree rooted at a specific function, generating the control flow graph of a function, and analyzing the stack frames of every function in a program. <a href="ch14.xhtml#exa14_1">Listing 14-1</a> iterates through every function in a program and prints basic information about each function, including the start and end addresses of the function, the size of the function’s arguments, and the size of the function’s local variables. All output is sent to the console window.</p>
<p class="programs">// ch14_1_flat.java<br/>
void run() throws Exception {<br/>
  int ptrSize = currentProgram.getDefaultPointerSize();<br/>
 <span class="ent">➊</span> Function func = getFirstFunction();<br/>
  while (func != null &amp;&amp; !monitor.isCancelled()) {<br/>
     String name = func.getName();<br/>
     long addr = func.getBody().getMinAddress().getOffset();<br/>
     long end = func.getBody().getMaxAddress().getOffset();<br/>
  <span class="ent">➋</span> StackFrame frame = func.getStackFrame();<br/>
  <span class="ent">➌</span> int locals = frame.getLocalSize();<br/>
  <span class="ent">➍</span> int args = frame.getParameterSize();<br/>
     printf("Function: %s, starts at %x, ends at %x\n", name, addr, end);<br/>
     printf("  Local variable area is %d bytes\n", locals);<br/>
     printf("  Arguments use %d bytes (%d args)\n", args, args / ptrSize);<br/>
  <span class="ent">➎</span> func = getFunctionAfter(func);<br/>
  }<br/>
}</p>
<p class="ex-caption" id="exa14_1"><em>Listing 14-1: Function enumeration script</em></p>
<span epub:type="pagebreak" id="page_308"/>
<p class="indent">The script uses Ghidra’s Flat API to iterate over all functions from the first <span class="ent">➊</span> and advancing through each in succession <span class="ent">➎</span>. A reference to each function’s stack frame is obtained <span class="ent">➋</span>, and the size of the local variables <span class="ent">➌</span> and the stack-based arguments <span class="ent">➍</span> retrieved. A summary for each function is printed before continuing the iteration.</p>
<h4 class="h4" id="ch14lev258"><strong><em>Example 2: Enumerating Instructions</em></strong></h4>
<p class="noindent">Within a given function, you may want to enumerate every instruction. <a href="ch14.xhtml#exa14_2">Listing 14-2</a> counts the number of instructions contained in the function identified by the current cursor position:</p>
<p class="programs">// ch14_2_flat.java<br/>
public void run() throws Exception {<br/>
   Listing plist = currentProgram.getListing();<br/>
<span class="ent">➊</span> Function func = getFunctionContaining(currentAddress);<br/>
   if (func != null) {<br/>
   <span class="ent">➋</span> InstructionIterator iter = plist.getInstructions(func.getBody(), true);<br/>
      int count = 0;<br/>
      while (iter.hasNext() &amp;&amp; !monitor.isCancelled()) {<br/>
         count++;<br/>
         Instruction ins = iter.next();<br/>
      }<br/>
   <span class="ent">➌</span> popup(String.format("%s contains %d instructions\n",<br/>
                          func.getName(), count));<br/>
   }<br/>
   else {<br/>
      popup(String.format("No function found at location %x",<br/>
                          currentAddress.getOffset()));<br/>
   }<br/>
}</p>
<p class="ex-caption" id="exa14_2"><em>Listing 14-2: Instruction enumeration script</em></p>
<p class="indent">The function begins by obtaining a reference to the function containing the cursor <span class="ent">➊</span>. If a function is found, the next step is to use the program’s <span class="literal">Listing</span> object to obtain an <span class="literal">InstructionIterator</span> over the function <span class="ent">➋</span>. The iteration loop counts the number of instructions retrieved, and the total is reported to the user with a pop-up message dialog <span class="ent">➌</span>.</p>
<h4 class="h4" id="ch14lev259"><strong><em>Example 3: Enumerating Cross-References</em></strong></h4>
<p class="noindent">Iterating through cross-references can be confusing because of the number of functions available for accessing cross-reference data and the fact that code cross-references are bidirectional. To get the data you want, you need to access the proper type of cross-reference for your situation.</p>
<p class="indent">In our first cross-reference example, shown in <a href="ch14.xhtml#exa14_3">Listing 14-3</a>, we retrieve the list of all function calls made within a function by iterating through each instruction in the function to determine if the instruction calls another function. One method of doing this might be to parse the results of the <span class="literal">getMnemonicString</span> function to look for <span class="literal">call</span> instructions. This would not be a very portable or efficient solution because the instruction used to call a function <span epub:type="pagebreak" id="page_309"/>varies among processor types, and additional parsing would be required to determine exactly which function was being called. Cross-references avoid each of these difficulties because they are processor-independent and directly inform us about the target of the cross-reference.</p>
<p class="programs">// ch14_3_flat.java<br/>
void run() throws Exception {<br/>
   Listing plist = currentProgram.getListing();<br/>
<span class="ent">➊</span> Function func = getFunctionContaining(currentAddress);<br/>
   if (func != null) {<br/>
      String fname = func.getName();<br/>
      InstructionIterator iter = plist.getInstructions(func.getBody(), true);<br/>
   <span class="ent">➋</span> while (iter.hasNext() &amp;&amp; !monitor.isCancelled()) {<br/>
         Instruction ins = iter.next();<br/>
         Address addr = ins.getMinAddress();<br/>
         Reference refs[] = ins.getReferencesFrom();<br/>
     <span class="ent">➌</span> for (int i = 0; i &lt; refs.length; i++) {<br/>
        <span class="ent">➍</span> if (refs[i].getReferenceType().isCall()) {<br/>
               Address tgt = refs[i].getToAddress();<br/>
               Symbol sym = getSymbolAt(tgt);<br/>
               String sname = sym.getName();<br/>
               long offset = addr.getOffset();<br/>
               printf("%s calls %s at 0x%x\n", fname, sname, offset);<br/>
            }<br/>
         }<br/>
      }<br/>
   }<br/>
}</p>
<p class="ex-caption" id="exa14_3"><em>Listing 14-3: Enumerating function calls</em></p>
<span epub:type="pagebreak" id="page_310"/>
<div class="box5">
<p class="boxtitle-c"><strong>DANGEROUS FUNCTIONS</strong></p>
<p class="noindent">The C functions <span class="literal">strcpy</span> and <span class="literal">sprintf</span> are considered dangerous to use because they allow unbounded copying into destination buffers. While each may be safely used by programmers who check the size of source and destination buffers, such checks are all too often forgotten by programmers unaware of the dangers of these functions. The <span class="literal">strcpy</span> function, for example, is declared as follows:</p>
<p class="programs">char *strcpy(char *dest, const char *source);</p>
<p class="indent">The <span class="literal">strcpy</span> function copies all characters up to and including the first null termination character encountered in the source buffer to the given destination buffer (<span class="literal">dest</span>). The fundamental problem is that there is no way to determine, at runtime, the size of any array, and <span class="literal">strcpy</span> can’t determine whether the capacity of the destination buffer is sufficient to hold all of the data to be copied from source. Such unchecked copy operations are a major cause of buffer overflow vulnerabilities.</p>
</div>
<p class="indent">We begin by obtaining a reference to the function containing the cursor <span class="ent">➊</span>. Next, we iterate through each instruction in the function <span class="ent">➋</span>, and for each instruction, we iterate through each cross-reference from the instruction <span class="ent">➌</span>. We are interested only in cross-references that call other functions, so we must test the return value of <span class="literal">getReferenceType</span> <span class="ent">➍</span> to determine whether <span class="literal">isCall</span> is <span class="literal">true</span>.</p>
<h4 class="h4" id="ch14lev260"><strong><em>Example 4: Finding Function Calls</em></strong></h4>
<p class="noindent">Cross-references are also useful for identifying every instruction that references a particular location. In <a href="ch14.xhtml#exa14_4">Listing 14-4</a>, we iterate across all of the cross-references <em>to</em> a particular symbol (as opposed to <em>from</em> in the previous example).</p>
<p class="programs">   // ch14_4_flat.java<br/>
<span class="ent">➊</span> public void list_calls(Function tgtfunc) {<br/>
     String fname = tgtfunc.getName();<br/>
     Address addr = tgtfunc.getEntryPoint();<br/>
     Reference refs[] = getReferencesTo(addr);<br/>
  <span class="ent">➋</span> for (int i = 0; i &lt; refs.length; i++) {<br/>
     <span class="ent">➌</span> if (refs[i].getReferenceType().isCall()) {<br/>
           Address src = refs[i].getFromAddress();<br/>
        <span class="ent">➍</span> Function func = getFunctionContaining(src);<br/>
           if (func.isThunk()) {<br/>
              continue;<br/>
           }<br/>
           String caller = func.getName();<br/>
           long offset = src.getOffset();<br/>
        <span class="ent">➎</span> printf("%s is called from 0x%x in %s\n", fname, offset, caller);<br/>
        }<br/>
      }<br/>
   }<br/>
<span class="ent">➏</span> public void getFunctions(String name, List&lt;Function&gt; list) {<br/>
      SymbolTable symtab = currentProgram.getSymbolTable();<br/>
      SymbolIterator si = symtab.getSymbolIterator();<br/>
      while (si.hasNext()) {<br/>
        Symbol s = si.next();<br/>
        if (s.getSymbolType() != SymbolType.FUNCTION || s.isExternal()) {<br/>
          continue;<br/>
       }<br/>
       if (s.getName().equals(name)) {<br/>
          list.add(getFunctionAt(s.getAddress()));<br/>
       }<br/>
    }<br/>
 }<br/>
 public void run() throws Exception {<br/>
    List&lt;Function&gt; funcs = new ArrayList&lt;Function&gt;();<br/>
    getFunctions("strcpy", funcs);<br/>
    getFunctions("sprintf", funcs);<br/>
    funcs.forEach((f) -&gt; list_calls(f));<br/>
 }</p>
<p class="ex-caption" id="exa14_4"><em>Listing 14-4: Enumerating a function’s callers</em></p>
<span epub:type="pagebreak" id="page_311"/>
<p class="indent">In this example, we have written the helper function <span class="literal">getFunctions</span> <span class="ent">➏</span> to collect <span class="literal">Function</span> objects associated with our functions of interest. For each function of interest, we call a second helper function, <span class="literal">list_calls</span> <span class="ent">➊</span>, to process all cross-references <span class="ent">➋</span> to the function. If the cross-reference type is determined to be a call-type cross-reference <span class="ent">➌</span>, the calling function is retrieved <span class="ent">➍</span> and its name is displayed to the user <span class="ent">➎</span>. Among other things, this approach could be used to create a low-budget security analyzer by highlighting all calls to functions such as <span class="literal">strcpy</span> and <span class="literal">sprintf</span>.</p>
<h4 class="h4" id="ch14lev261"><strong><em>Example 5: Emulating Assembly Language Behavior</em></strong></h4>
<p class="noindent">There are a number of reasons you might need to write a script that emulates the behavior of a program you are analyzing. For example, the program you are studying may be self-modifying, as many malware programs are, or the program may contain some encoded data that gets decoded when needed at runtime. Without running the program and pulling the modified data out of the running process’s memory, how can you understand the behavior of the program?</p>
<p class="indent">If the decoding process is not terribly complex, you may be able to quickly write a script that performs the same actions that are performed by the program when it runs. Using a script to decode data in this way eliminates the need to run the program when you don’t know what the program does or you don’t have access to a platform on which you can run the program. For example, without a MIPS execution environment, you cannot execute a MIPS binary and observe any data decoding it might perform. You could, however, write a Ghidra script to mimic the behavior of the binary and make the required changes within your Ghidra project, all with no need for a MIPS execution environment.</p>
<p class="indent">The following x86 code was extracted from a DEFCON Capture the Flag binary:<sup><a id="ch14fn1a" href="footnotes.xhtml#ch14fn1">1</a></sup></p>
<p class="programs">08049ede  MOV    dword ptr [EBP + local_8],0x0<br/>
        LAB_08049ee5<br/>
08049ee5  CMP    dword ptr [EBP + local_8],0x3c1<br/>
08049eec  JA     LAB_08049f0d<br/>
08049eee  MOV    EDX,dword ptr [EBP + local_8]<br/>
08049ef1  ADD    EDX,DAT_0804b880<br/>
08049ef7  MOV    EAX,dword ptr [EBP + local_8]<br/>
08049efa  ADD    EAX,DAT_0804b880<br/>
08049eff  MOV    AL,byte ptr [EAX]=&gt;DAT_0804b880<br/>
08049f01  XOR    EAX,0x4b<br/>
08049f04  MOV    byte ptr [EDX],AL=&gt;DAT_0804b880<br/>
08049f06  LEA    EAX=&gt;local_8,[EBP + -0x4]<br/>
08049f09  INC    dword ptr [EAX]=&gt;local_8<br/>
08049f0b  JMP    LAB_08049ee5</p>
<span epub:type="pagebreak" id="page_312"/>
<p class="indent">This code decodes a private key that has been embedded within the program binary. Using the script in <a href="ch14.xhtml#exa14_5">Listing 14-5</a>, we can extract the private key without running the program.</p>
<p class="programs">// ch14_5_flat.java<br/>
public void run() throws Exception {<br/>
   int local_8 = 0;<br/>
   while (local_8 &lt;= 0x3C1) {<br/>
      long edx = local_8;<br/>
      edx = edx + 0x804B880;<br/>
      long eax = local_8;<br/>
      eax = eax + 0x804B880;<br/>
      int al = getByte(toAddr(eax));<br/>
      al = al ^ 0x4B;<br/>
      setByte(toAddr(edx), (byte)al);<br/>
      local_8++;<br/>
   }<br/>
}</p>
<p class="ex-caption" id="exa14_5"><em>Listing 14-5: Emulating assembly language with a Ghidra script</em></p>
<p class="indent"><a href="ch14.xhtml#exa14_5">Listing 14-5</a> is a fairly literal translation of the preceding assembly language sequence generated according to the following mechanical rules:</p>
<ul>
<li class="noindent">For each stack variable and register used in the assembly code, declare an appropriately typed script variable.</li>
<li class="noindent">For each assembly language statement, write a statement that mimics its behavior.</li>
<li class="noindent">Emulate reading and writing stack variables by reading and writing the corresponding variable declared in your script.</li>
<li class="noindent">Emulate reading from a nonstack location using the <span class="literal">getByte</span>, <span class="literal">getWord</span>, <span class="literal">getDword</span>, or <span class="literal">getQword</span> function, depending on the amount of data being read (1, 2, 4, or 8 bytes).</li>
<li class="noindent">Emulate writing to a nonstack location using the <span class="literal">setByte</span>, <span class="literal">setWord</span>, <span class="literal">setDword</span>, or <span class="literal">setQword</span> function, depending on the amount of data being written.</li>
<li class="noindent">If the code contains a loop for which the termination condition is not immediately obvious, begin with an infinite loop such as <span class="literal">while(true){...}</span> and then insert a <span class="literal">break</span> statement when you encounter statements that cause the loop to terminate.</li>
<li class="noindent">When the assembly code calls functions, things get complicated. To properly simulate the behavior of the assembly code, you must mimic the behavior of the function that has been called, including providing a return value that makes sense within the context of the code being simulated.</li>
</ul>
<p class="indent">As the complexity of the assembly code increases, it becomes more challenging to write a script that emulates all aspects of an assembly language sequence, but you don’t have to fully understand how the code you are emulating works. Translate one or two instructions at a time. If each instruction <span epub:type="pagebreak" id="page_313"/>has been correctly translated, the script as a whole should properly mimic the complete functionality of the original assembly code. After the script has been completed, you can use the script to better understand the underlying assembly. You will see this approach, and more generic emulation functionality, used again in <a href="ch21.xhtml#ch21">Chapter 21</a> when we discuss the analysis of obfuscated binaries.</p>
<p class="indent">For example, once we translate the sample algorithm and spend some time considering how it works, we can shorten the emulation script as follows:</p>
<p class="programs">public void run() throws Exception {<br/>
   for (int local_8 = 0; local_8 &lt;= 0x3C1; local_8++) {<br/>
      Address addr = toAddr(0x804B880 + local_8);<br/>
      setByte(addr, (byte)(getByte(addr) ^ 0x4B));<br/>
   }<br/>
}</p>
<p class="indent">Once the script executes, you can see the decoded private key starting at address <span class="literal">0x804B880</span>. If you don’t want to modify the Ghidra database when emulating code, replace the <span class="literal">setByte</span> function call with a call to <span class="literal">printf</span>, which will output the results to the CodeBrowser console, or write the data to a disk file for binary data. Don’t forget that in addition to Ghidra’s Java API, you have access to all of the standard Java API classes as well as any other Java packages that you’ve chosen to install on your system.</p>
<h3 class="h3" id="ch14lev262"><strong>Summary</strong></h3>
<p class="noindent">Scripting provides a powerful means for automating repetitive tasks and extending Ghidra’s capabilities. This chapter has introduced Ghidra’s functionality for editing and building new scripts using both Java and Python. The integrated ability to build, compile, and run Java-based scripts within the CodeBrowser environment lets you extend Ghidra’s capabilities without requiring an in-depth understanding of the underlying intricacies of the Ghidra development environment. <a href="ch15.xhtml#ch15">Chapters 15</a> and <a href="ch16.xhtml#ch16">16</a> introduce Eclipse integration and the ability to run Ghidra in headless mode.</p>
<span epub:type="pagebreak" id="page_314"/>
</div>



  </body></html>