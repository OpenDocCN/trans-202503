<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 2: Setting Up a GraphQL Security Lab</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_21" title="21"/><a class="XrefDestination" id="2"/><span class="XrefDestination" id="xref-502840c02-001"/>2</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="SettingupagraphqlSECURITYlab"/><span class="XrefDestination" id="xref-502840c02-002"/>Setting Up a GraphQL Security Lab</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll begin building your GraphQL dojo: a security testing lab environment equipped with GraphQL hacking tools, as well as an intentionally vulnerable server that you can use to safely test newly acquired offensive GraphQL skills.</p>
<p>Understanding how to set up a hacking lab with the right tools becomes more important than usual when you are testing an application whose underlying technologies haven’t been around for many years. Seasoned technologies have gone through many iterations of security reviews and research. With newer technologies, it may take some time for similar knowledge bases to develop, and for security testing methodologies to circulate in the security community.</p>
<p>This lack of a knowledge base can pose problems. Imagine that you’re conducting a penetration test when you discover a server running an application you’ve never seen before. You might start researching the software and looking for known application vulnerabilities or publicly available exploits on websites such as the Exploit Database (<a class="LinkURL" href="https://exploit-db.com">https://exploit-db.com</a>). <span epub:type="pagebreak" id="Page_22" title="22"/>However, the situation could become more complex when the application is using a new framework, such as GraphQL. Testing the application would require knowledge of not only the framework but also how to retool with the relevant penetration testing tools, a time-consuming task when you’re in the midst of a penetration test.</p>
<p>The dedicated lab you’ll build in this chapter will support your hands-on hacking throughout this book so that the next time you run into GraphQL in the wild, you’ll be ready to use the right tools to search and find vulnerabilities. Tinkering in a lab has a lot of other benefits too, such as providing practical experience through experimentation. The best way to learn about hacking is by getting your hands dirty.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, you used a live application that we hosted to experiment with REST and GraphQL APIs. Moving forward, all lab exercises will be done locally, on your computer.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502840c02-0001"><a class="XrefDestination" id="TakingSecurityPrecautions"/><span class="XrefDestination" id="xref-502840c02-003"/>Taking Security Precautions</h2>
<p class="BodyFirst">You should follow a few guidelines whenever you’re building a hacking lab on personal equipment:</p>
<ul class="disc">
<li><b>Avoid connecting the lab directly to the public internet.</b> Hacking lab environments typically involve installing vulnerable code or outdated software. These could pose risks to your network, your computer, and your data if they become accessible from the internet. You don’t want internet bots to deploy malware on your computer or use it as a launchpad to attack others.</li>
<li><b>Work through the lab only on trusted local networks.</b> Anyone on the same network as you can also attack the lab. For this reason, we recommend working through the book only when you’re connected to networks you trust.</li>
<li><b>Deploy the lab in a virtual environment by using a hypervisor, such as Oracle VirtualBox.</b> For VirtualBox (<a class="LinkURL" href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>), choose the platform package for your main computer’s operating system. If you are running Linux, choose a package for the Linux distribution you are using from the list located at <a class="LinkURL" href="https://www.virtualbox.org/wiki/Linux_Downloads">https://www.virtualbox.org/wiki/Linux_Downloads</a>. VirtualBox currently supports all major distributions, such as Ubuntu, Debian, and Fedora. Separating the hacking lab environment from your primary operating system is generally a good idea, as it prevents software conflicts that could potentially break other software on your computer.</li>
<li><b>Make use of the virtual machine snapshot mechanism of your chosen hypervisor.</b> This allows you to take <em>snapshots</em> (versions at a specified point in time) of the virtual machine and restore it to its original state, in case it happens to break in the future. Think of this as clicking the Save button in a video game so that you can resume your game later.</li>
</ul>
<p><span epub:type="pagebreak" id="Page_23" title="23"/>With these best practices in mind, let’s get our hands dirty and our lab up and running!</p>
<h2 id="h1-502840c02-0002"><a class="XrefDestination" id="InstallingKali"/><span class="XrefDestination" id="xref-502840c02-004"/>Installing Kali</h2>
<p class="BodyFirst"><em>Kali</em> is a Linux distribution created for penetration testing. Based on Debian, it was designed by Offensive Security (<a class="LinkURL" href="https://offensive-security.com">https://offensive-security.com</a>). We’ll use Kali as the base operating system for our GraphQL hacking lab because it comes bundled with some of the libraries, dependencies, and tools we’ll need.</p>
<p>You can find Kali virtual machine images for the VMware Workstation and Oracle VirtualBox hypervisors at <a class="LinkURL" href="https://www.kali.org/get-kali">https://www.kali.org/get-kali</a>. Pick the hypervisor of your choice and follow the official installation instructions provided by Offensive Security: <a class="LinkURL" href="https://www.kali.org/docs/installation">https://www.kali.org/docs/installation</a>.</p>
<p>After completing the installation process, you should see the Kali login screen shown in <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>. Kali ships with a default user account named <em>kali</em> whose password is <em>kali</em>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c02/F02001.png"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: The Kali Linux login screen</p></figcaption>
</figure>
<p>After logging in to Kali, you need to make sure it is up to date. Open Kali’s <b>Applications</b> menu and, in the search bar, enter <b>terminal emulator</b> (<a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>). Click the corresponding application.</p>
<span epub:type="pagebreak" id="Page_24" title="24"/><figure>
<img alt="" class="keyline" src="image_fi/502840c02/F02002.png"/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: The Kali Applications menu</p></figcaption>
</figure>
<p>Let’s use a few commands to update your software repositories and upgrade your installed package. In the terminal window, enter the following commands:</p>
<pre><code># <b>sudo apt update -y</b>
# <b>sudo apt upgrade -y</b>
# <b>sudo apt dist-upgrade -y</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">nOTE</span></h2>
<p>	When you use the <code>sudo</code> command, Kali will ask for your password. This is the same password you used to log in to the virtual machine, <em>kali</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>From this point on, we will use our Kali machine for all tasks we cover in the book. We recommend keeping the terminal window open, as you’ll need it for additional installations very soon.</p>
<h2 id="h1-502840c02-0003"><a class="XrefDestination" id="InstallingWebClients"/><span class="XrefDestination" id="xref-502840c02-005"/>Installing Web Clients</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we mentioned that GraphQL APIs can be queried using a variety of specialized utilities, such as GraphiQL Explorer, or simple command line–based HTTP clients, such as cURL. These tools all make HTTP requests under the hood.</p>
<p>We’ll install and use two web clients: cURL and Altair. These will allow you to experiment with crafting and sending GraphQL queries using both command line tools and those with graphical interfaces.</p>
<h3 id="h2-502840c02-0001"><span epub:type="pagebreak" id="Page_25" title="25"/><a class="XrefDestination" id="QueryingGraphQLfromtheCommandLinewithcURL"/><span class="XrefDestination" id="xref-502840c02-006"/>Querying from the Command Line with cURL</h3>
<p class="BodyFirst">One of the most popular command line HTTP clients, cURL, can make HTTP requests just like any graphical web browser. As such, you can use it to query GraphQL APIs.</p>
<p>As a hacker, you should become comfortable with operating from the command line. Aside from allowing you to automate repetitive tasks more easily, knowing your way around the command line gives you the ability to work efficiently when you might not have access to graphical interfaces, such as during a penetration test.</p>
<p>Let’s go ahead and install cURL. Open the terminal and enter the following command:</p>
<pre><code>#<b><i> </i></b><b>sudo apt install -y curl</b></code></pre>
<p>You can verify that cURL was installed and is functioning correctly by issuing the following command:</p>
<pre><code># <b>curl lab.blackhatgraphql.com</b>
Black Hat GraphQL – Hello!</code></pre>
<p>If you see a “Hello!” message, it means cURL successfully sent an HTTP GET request to the application and received a response.</p>
<h3 id="h2-502840c02-0002"><a class="XrefDestination" id="QueryingGraphQLfromaGUIwiththeAltairGraphQLClient"/><span class="XrefDestination" id="xref-502840c02-007"/>Querying from a GUI with Altair</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we queried GraphQL APIs by using GraphiQL Explorer, leveraging its auto-completion features. While GraphiQL is a very useful tool, it won’t always be available to you during a penetration test. To overcome this, you can install graphical GraphQL clients locally on your computer. These clients have the capability to connect to remote GraphQL servers and return results similarly to the way GraphiQL Explorer would. If you provide the remote server address to the graphical client, it will take care of the integration with GraphQL behind the scenes.</p>
<p>One of these tools, Altair, is available as a web browser plug-in, as well as a local desktop application. Both versions provide the same functionality, and there is no downside to choosing either. In this book, we will be using the desktop application. However, if you’d like, you can install the browser plug-in for Firefox through the add-ons store, which you can find by entering <code class="bold">about:addons</code> in the browser’s address bar.</p>
<p>The Altair desktop client is available for macOS, Linux, and Windows at <a class="LinkURL" href="https://altair.sirmuel.design/#download">https://altair.sirmuel.design/#download</a>, as shown in <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>. Choose the icon that represents the operating system you are running. For Kali, you will want to install the Linux version.</p>
<p>Download Altair to the <em>Desktop </em>directory in Kali. You should see a file with the extension <em>AppImage</em> after the download is complete:</p>
<pre><code># <b>cd ~/Desktop</b>
# <b>ls -l altair*</b>
-rwxr--r-- 1 kali kali 88819862 altair_x86_64_linux.AppImage</code></pre>
<span epub:type="pagebreak" id="Page_26" title="26"/><figure>
<img alt="" class="keyline" src="image_fi/502840c02/f02003.png"/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: The available Altair Desktop client versions</p></figcaption>
</figure>
<p>Next, we need to change the permissions on the downloaded file to be able to run it:</p>
<pre><code># <b>chmod u+x altair_x86_64_linux.AppImage</b></code></pre>
<p>Now we can execute the file. It should load the client, as shown in <a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a>.</p>
<pre><code># <b>./altair_x86_64_linux.AppImage</b></code></pre>
<p>After you’ve set the right permissions, you should also be able to run the application directly by clicking the Altair Desktop icon located on your Kali Desktop.</p>
<p>Let’s now verify that the client is working as expected. Open it and, in the Enter URL address bar, enter <b><i>http://lab.blackhatgraphql.com/graphql</i></b>. This will ensure that any query we execute will be sent directly to this address. Now, in the left-side Query pane, remove the existing code comments (lines that start with the <code>#</code> symbol) and enter the following query instead:</p>
<pre><code><b>query {</b>
<b>  users {</b>
<b>    username</b>
<b>  }</b>
<b>}</b></code></pre>
<span epub:type="pagebreak" id="Page_27" title="27"/><figure>
<img alt="" class="" src="image_fi/502840c02/f02004.png"/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: The Altair Desktop client for Linux</p></figcaption>
</figure>
<p>Finally, click <b>Send Request</b>. You should see output similar to that in <a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c02/f02005.png"/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: A GraphQL response in the Altair Desktop client</p></figcaption>
</figure>
<p>Altair is a powerful tool; it will provide us with query auto-completion suggestions, as well as schema documentation, historical records of executed queries, and other features, such as setting custom HTTP headers and saving queries to a collection, making our lives much easier. To learn <span epub:type="pagebreak" id="Page_28" title="28"/>more about the advanced features of Altair, refer to the official documentation page at <a class="LinkURL" href="https://altair.sirmuel.design/docs/features">https://altair.sirmuel.design/docs/features</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">nOTE</span></h2>
<p>	During a penetration test, you may encounter a remote GraphQL API server with authentication and authorization controls. GraphQL clients such as Altair will need special HTTP headers set so they can authenticate themselves to the remote server. Altair allows you to configure custom headers by using the Set Headers menu item on the left. In the absence of authentication HTTP headers, queries may fail with errors such as <em>401 Unauthorized</em>. In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, we will explore GraphQL servers with authentication and authorization controls enabled.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502840c02-0004"><a class="XrefDestination" id="SettingUpaVulnerableGraphQLServer"/><span class="XrefDestination" id="xref-502840c02-008"/>Setting Up a Vulnerable GraphQL Server</h2>
<p class="BodyFirst">Now that we have the client utilities needed to query any GraphQL server, the next step is to install a vulnerable GraphQL server, which we’ll use as our target throughout the book. We will use this vulnerable server in our deeper exploration of GraphQL in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> and throughout the penetration testing exercises in <span class="xref" itemid="xref_target_Chapters 4 through 9">Chapters 4 through 9</span>.</p>
<h3 id="h2-502840c02-0003"><a class="XrefDestination" id="InstallingDocker"/><span class="XrefDestination" id="xref-502840c02-009"/>Installing Docker</h3>
<p class="BodyFirst"><em>Docker</em> (<a class="LinkURL" href="https://www.docker.com">https://www.docker.com</a>) is a tool for deploying and managing containers. <em>Containers</em> are units of software that package up code and its dependencies so an application can run reliably in various environments. Docker is available on Windows, macOS, and Linux.</p>
<p>We’ll use Docker to deploy the application we’ll attack throughout this book. Let’s install it from the Kali software repositories by running the following command:</p>
<pre><code># <b>sudo apt install -y docker.io</b></code></pre>
<p>Next, we want to make sure the Docker process will automatically start upon system reboot:</p>
<pre><code># <b>sudo systemctl enable docker --now</b></code></pre>
<p>Finally, make sure Docker was successfully installed:</p>
<pre><code># <b>sudo docker</b>

Management Commands:
  builder     Manage builds
  completion  generate the autocompletion script for the specified shell
  config      Manage Docker configs
  container   Manage containers
  context     Manage contexts</code></pre>
<h3 id="h2-502840c02-0004"><span epub:type="pagebreak" id="Page_29" title="29"/><a class="XrefDestination" id="DeployingtheDamnVulnerableGraphQLApplicationwithDocker"/><span class="XrefDestination" id="xref-502840c02-010"/>Deploying the Damn Vulnerable GraphQL Application</h3>
<p class="BodyFirst">Our target application must be able to simulate common GraphQL application vulnerabilities. To achieve this, we will use the <em>Damn Vulnerable GraphQL Application (DVGA)</em>, a GraphQL application with design- and configuration-level vulnerabilities deliberately built in. We developed DVGA in February 2021 to educate users about attacking and defending applications backed by GraphQL, and it has since become the de facto target application in the GraphQL security space for learning how to hack GraphQL.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	<em>Damn vulnerable</em> is a phrase commonly associated with applications that are intentionally made insecure for educational purposes.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>DVGA is vulnerable to a variety of issues, including DoS, information disclosure, code execution, authentication bypass, Structured Query Language (SQL) injection, broken authorization, and more. It offers multiple working modes tailored to both beginners and experts and includes built-in functionality to restore itself in case it breaks. We will go into more detail about how to use it in <span class="xref" itemid="xref_target_Chapters 3 and 4">Chapters 3 and 4</span>.</p>
<p>The DVGA code is open source and can be found on GitHub at <a class="LinkURL" href="https://github.com/dolevf/Damn-Vulnerable-GraphQL-Application">https://github.com/dolevf/Damn-Vulnerable-GraphQL-Application</a>. Let’s use Git to clone the DVGA repository and use Docker to deploy it. First, make sure you have Git installed with the following commands:</p>
<pre><code># <b>sudo apt install git -y</b>
# <b>git --help</b>

usage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]
           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
<var class="bold">--snip--</var></code></pre>
<p>Next, clone the DVGA repository from GitHub:</p>
<pre><code># <b>cd ~</b>
# <b>git clone -b blackhatgraphql https://github.com/dolevf/Damn-Vulnerable-GraphQL-Application.git</b>
# <b>ls -l</b>

drwxr-xr-x 9 kali kali 4096 Damn-Vulnerable-GraphQL-Application</code></pre>
<p>Then build the DVGA Docker image with the following commands:</p>
<pre><code># <b>cd Damn-Vulnerable-GraphQL-Application</b>
# <b>sudo docker build -t dvga .</b></code></pre>
<p>Finally, start the DVGA container with the following command. Note that you will want to run this specific command if your DVGA happens to crash at any point throughout the book:</p>
<pre><code># <b>sudo docker run -t --rm -d --name dvga -p 5013:5013 -e WEB_HOST=0.0.0.0 dvga</b></code></pre>
<p><span epub:type="pagebreak" id="Page_30" title="30"/>Next, verify that the container is running by using the following command:</p>
<pre><code># <b>sudo docker container ps</b>

CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
7b33cca84fc1  dvga   "python3 app.py"  About a minute ago
Up  0.0.0.0:5013-&gt;5013/tcp, :::5013-&gt;5013/tcp   dvga</code></pre>
<p>At this point, the target application should be up and running. Verify this by opening a web browser and entering <b><i>http://localhost:5013</i></b> in the address bar. You should be able to access the application shown in <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c02/F02006.png"/>
<figcaption><p><a id="figure2-6">Figure 2-6</a>: The Damn Vulnerable GraphQL Application</p></figcaption>
</figure>
<p>As you can see, DVGA resembles Pastebin (<a class="LinkURL" href="https://pastebin.com">https://pastebin.com</a>), a web application that allows clients to submit random text snippets (such as source code or other text) and share them with others. These text snippets are also called <em>pastes</em>, a term we will use throughout this book as we walk through penetration-testing scenarios using DVGA. Pastes can have metadata, such as titles, content, author information, and so on. You will be able to see this information when we run queries against DVGA. <a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a> shows an example of a paste in DVGA.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c02/F02007.png"/>
<figcaption><p><a id="figure2-7">Figure 2-7</a>: A sample paste in DVGA</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_31" title="31"/>You can see the title and content of the paste, as well as its author (Darcee) and some metadata about them, such as their internet protocol (IP) address (215.0.2.85) and web browser (Mozilla/5.0).</p>
<h3 id="h2-502840c02-0005"><a class="XrefDestination" id="TestingDVGAwithaGraphQLQuery"/><span class="XrefDestination" id="xref-502840c02-011"/>Testing DVGA</h3>
<p class="BodyFirst">Now that you have a target application in your lab environment, verify that the application is up and its GraphQL API is accessible on the network with a simple GraphQL query. For this, we’ll use the Altair client we installed earlier.</p>
<p>Open the Altair client and enter <b><i>http://localhost:5013/graphql</i></b> in the address bar. Next, enter the following GraphQL query in the left pane:</p>
<pre><code><b>query {</b>
<b>  systemHealth</b>
<b>}</b></code></pre>
<p>This query should result in output similar to that shown in <a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c02/f02008.png"/>
<figcaption><p><a id="figure2-8">Figure 2-8</a>: The DVGA response in Altair</p></figcaption>
</figure>
<p>Names in GraphQL are case-sensitive, so make sure you follow the capitalization in <code>systemHealth</code>; otherwise, this query will result in an error.</p>
<h2 id="h1-502840c02-0005"><a class="XrefDestination" id="InstallingGraphQLHackingTools"/><span class="XrefDestination" id="xref-502840c02-012"/>Installing GraphQL Hacking Tools</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we highlighted the differences between REST and GraphQL APIs. These differences required the security industry to build GraphQL support into existing tools. In some cases, hackers also created new tools <span epub:type="pagebreak" id="Page_32" title="32"/>designed exclusively for penetration testing GraphQL applications. The hacking tools we will install in the lab and use in our hacking exercises in later chapters are capable of security-testing GraphQL applications.</p>
<h3 id="h2-502840c02-0006"><a class="XrefDestination" id="BurpSuite"/><span class="XrefDestination" id="xref-502840c02-013"/>Burp Suite</h3>
<p class="BodyFirst"><em>Burp Suite</em> is application security testing software by PortSwigger (<a class="LinkURL" href="https://portswigger.net">https://portswigger.net</a>) that proxies traffic between your web browser and the target application, allowing you to intercept, modify, and replay requests coming in and out of your computer. In our GraphQL security lab, we’ll use Burp Suite to manually interact with our target by observing and modifying GraphQL queries before they are sent to the target server.</p>
<p>Newer versions of Kali should have Burp Suite installed by default. Let’s verify this by opening the terminal and entering the following command:</p>
<pre><code># <b>sudo apt install burpsuite -y</b></code></pre>
<p>Now we’ll open Burp Suite and check that it can successfully intercept traffic. In the Kali Applications menu’s search bar, enter <b>Burp Suite</b> and click the application. If this is the first time you’ve loaded the application, read the Terms and Conditions and click <b>I Accept</b>.</p>
<p>Create a temporary project by selecting the <b>Temporary Project</b> radio button, and click <b>Next</b>. Burp Suite will ask which configuration file to load for the project. Choose <b>Use Burp Defaults</b> and click <b>Start Burp</b>.</p>
<p>Next, let’s ensure that Burp Suite can proxy HTTP traffic to DVGA. Click <b>Proxy</b><span class="MenuArrow">▶</span><b>Intercept</b><span class="MenuArrow">▶</span><b>Open Browser</b>. In the browser, enter <b><i>http://localhost:5013/graphiql</i></b> and press ENTER. This will initiate a GET request to DVGA, which Burp Suite should automatically intercept.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">nOTE</span></h2>
<p>	The Open Browser option in Burp Suite launches the embedded browser, which doesn’t require any additional configuration (such as adding Burp’s certificate to the trusted certificate store). It should be ready to intercept traffic from the get-go.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Burp Suite should now highlight the <b>Intercept</b> tab (typically in orange), indicating it has intercepted the outgoing request. You should see an in-flight HTTP GET request, similar to the one shown in <a href="#figure2-9" id="figureanchor2-9">Figure 2-9</a>.</p>
<p>This request has yet to leave your web browser. Burp Suite allows you to make modifications to it before sending it to the server. Go ahead and click the <b>Intercept Is On</b> button. This will unblock the request and send it to DVGA.</p>
<p>We’ve verified that Burp Suite is installed and configured and can intercept traffic going from your browser to DVGA. Great work! Burp Suite is so feature rich that an entire book can be written on it. To learn more about this tool, we recommend referencing its official documentation (<a class="LinkURL" href="https://portswigger.net/burp/documentation/desktop/penetration-testing">https://portswigger.net/burp/documentation/desktop/penetration-testing</a>).</p>
<span epub:type="pagebreak" id="Page_33" title="33"/><figure>
<img alt="" class="keyline" src="image_fi/502840c02/f02009.png"/>
<figcaption><p><a id="figure2-9">Figure 2-9</a>: Intercepting a request in Burp Suite</p></figcaption>
</figure>
<h3 id="h2-502840c02-0007"><a class="XrefDestination" id="Clairvoyance"/><span class="XrefDestination" id="xref-502840c02-014"/>Clairvoyance</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we introduced GraphQL schemas, which represent the structure of the application’s data model. Developers who want to interact with a GraphQL API will need to know what data they can access, as well as what queries or mutations the API supports. GraphQL exposes this schema information through the introspection query.</p>
<p>In simple terms, <em>introspection</em> is a feature in GraphQL that allows it to describe its own data to the client. <a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a> shows a basic <em>introspection query</em> that returns a list of all the available queries from the schema. We’ll cover these queries in more detail in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>
<pre><code>{
  __schema {
    queryType {
      fields {
        name
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: A basic introspection query</p>
<p><span epub:type="pagebreak" id="Page_34" title="34"/>As you can imagine, companies that allow clients to perform introspection queries against their GraphQL APIs are making a security trade-off. Information about the various fields and objects that the backend application supports can only aid threat actors and increase their chances of successfully finding vulnerabilities. As such, production-grade implementations will often disable introspection. This means you may be required to test GraphQL applications in production setups that don’t allow introspection queries to be executed. In these situations, figuring out how to properly construct queries may pose a challenge.</p>
<p>This is where <em>Clairvoyance</em> comes to the rescue. This Python-based reconnaissance tool for GraphQL APIs, developed by Nikita Stupin (<a href="http://www.twitter.com/@_nikitastupin">@_nikitastupin</a>) and Ilya Tsaturov (<a href="http://www.twitter.com/@itsaturov">@itsaturov</a>), allows you to discover schema information when introspection is disabled. It works by abusing a GraphQL feature called <em>field suggestions</em>. Essentially, it reconstructs the underlying schema by sending queries crafted from a dictionary of common English words and observing the server’s responses. We’ll go into more detail about field suggestions and how they help us extract information about GraphQL schemas in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<p>Let’s go ahead and install Clairvoyance. Open the terminal and enter the following commands:</p>
<pre><code>#<b> cd ~</b>
# <b>git clone https://github.com/nikitastupin/clairvoyance.git</b>
# <b>cd clairvoyance</b></code></pre>
<p>We can verify that Clairvoyance is able to run by passing the <code class="bold">-h</code> flag to the Clairvoyance script:</p>
<pre><code># <b>python3 -m clairvoyance -h</b>

usage: __main__.py [-h] [-v] [-k] [-i &lt;file&gt;]
[-o &lt;file&gt;] [-d &lt;string&gt;] [-H &lt;header&gt;] -w &lt;file&gt; url

positional arguments:
  url

optional arguments:
  -h, --help            show this help message and exit</code></pre>
<h3 id="h2-502840c02-0008"><a class="XrefDestination" id="InQL"/><span class="XrefDestination" id="xref-502840c02-015"/>InQL</h3>
<p class="BodyFirst">Until recently, not many resources for GraphQL security testing were publicly available, even as GraphQL adoption increased. To fill this gap, the security firm Doyensec developed <em>Introspection GraphQL</em> (<em>InQL)</em>.</p>
<p>This security testing tool, based on Python, relies on the introspection query. InQL can export any information it finds about the GraphQL schema to a variety of formats, making the application’s schema easier to read and understand. InQL also can perform other tasks, such as detecting potential DoS conditions.</p>
<p><span epub:type="pagebreak" id="Page_35" title="35"/>Let’s install InQL. Open the terminal and enter the following commands:</p>
<pre><code># <b>cd ~</b>
# <b>git clone https://github.com/doyensec/inql.git</b>
# <b>cd inql</b>
# <b>sudo python3 setup.py install</b></code></pre>
<p>Verify that the installation succeeded and that InQL is able to run by passing it the <code class="bold">-h</code> flag:</p>
<pre><code># <b>inql -h</b>

usage: inql [-h] [-t TARGET] [-f SCHEMA_JSON_FILE] [-k KEY]
[-p PROXY] [--header HEADERS HEADERS] [-d] [--no-generate-html]
[--no-generate-schema] [--no-generate-queries] [--generate-cycles]
[--cycles-timeout CYCLES_TIMEOUT] [--cycles-streaming] [--generate-tsv]
[--insecure] [-o OUTPUT_DIRECTORY]</code></pre>
<p>If you see similar output, InQL was successfully installed. We’ll use the tool in penetration testing exercises later in the book.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">nOTE</span></h2>
<p>	InQL is also available as a Burp Suite extension named <em>Introspection GraphQL Scanner</em> that can be downloaded from Burp Suite’s BApp Store (<a class="LinkURL" href="https://portswigger.net/bappstore">https://portswigger.net/bappstore</a>). We’ll instead use the command line version you just installed.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502840c02-0009"><a class="XrefDestination" id="Graphw00f"/><span class="XrefDestination" id="xref-502840c02-016"/>Graphw00f</h3>
<p class="BodyFirst">Over the years, the GraphQL community has developed GraphQL server implementations in many programming languages, such as graphql-php for PHP, and Graphene and Ariadne for Python. For us hackers, it’s crucial to identify the technologies that our target server is running behind the scenes. Once we gather this information, we’ll be able to tailor attacks to the technology we’re facing, increasing our overall chances of success.</p>
<p><em>Graphw00f</em> is a Python-based GraphQL security tool that we developed to identify a GraphQL API’s specific implementation. We built it primarily because GraphQL doesn’t generally advertise the type of engine it’s using under the hood. We wondered whether you could identify the implementation solely based on API responses; it turns out you can. Graphw00f manages to fingerprint the implementation by sending a mix of valid and malformed queries to the server and observing the subtle differences in the returned error messages. It can currently fingerprint over 24 implementations, including the majority of the popular GraphQL servers in use today.</p>
<p>This implementation information is especially interesting because not all of the available GraphQL implementations available today support the same security features out of the box. For example, some implementations offer external libraries for implementing authorization controls, while others do not. Identifying the backend technology gives us these additional data points to guide our testing.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_36" title="36"/><h2><span class="NoteHead">nOTE</span></h2>
<p>	Fun fact: the name Graphw00f was inspired by another network security tool, <em>WAFW00F</em> (<a class="LinkURL" href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a>). WAFW00F works in a manner similar to Graphw00f, except it attempts to fingerprint WAFs instead of GraphQL implementations.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To install Graphw00f, open the terminal and enter the following:</p>
<pre><code># <b>cd ~</b>
# <b>git</b> <b>clone https://github.com/dolevf/graphw00f.git</b>
# <b>cd graphw00f</b></code></pre>
<p>Verify that Graphw00f can successfully start by using the <code class="bold">-h</code> command:</p>
<pre><code># <b>python3 main.py --help</b>

Usage: main.py -d -f -t http://example.com

Options:
  -h, --help            show this help message and exit
  -r, --noredirect      Do not follow redirections given by 3xx responses</code></pre>
<h3 id="h2-502840c02-0010"><a class="XrefDestination" id="BatchQL"/><span class="XrefDestination" id="xref-502840c02-017"/>BatchQL</h3>
<p class="BodyFirst"><em>BatchQL</em> is a GraphQL security auditing script written in Python and developed by the security firm Assetnote. The tool is named after a GraphQL feature called <em>batching </em>that allows clients to send multiple queries in a single HTTP request. You’ll learn more about batch queries in later chapters.</p>
<p>BatchQL attempts to identify flaws in GraphQL implementations related to the following vulnerability classes: DoS, CSRF, and information disclosure. Install it by executing the following command:</p>
<pre><code># <b>cd ~</b>
# <b>git clone https://github.com/assetnote/batchql.git</b></code></pre>
<p>Verify that BatchQL is working properly by passing it the <code class="bold">-h</code> flag:</p>
<pre><code># <b>cd batchql</b>
# <b>python3 batch.py -h</b>

usage: batch.py [-h] [-e ENDPOINT] [-v VARIABLE] [-P PREFLIGHT]
[-q QUERY] [-w WORDLIST] [-H HEADER [HEADER ...]] [-p PROXY] [-s SIZE] [-o OUTPUT]

optional arguments:
  -h, --help            show this help message and exit
  -e ENDPOINT, --endpoint ENDPOINT
                        GraphQL Endpoint (i.e. https://example.com/graphql).</code></pre>
<h3 id="h2-502840c02-0011"><span epub:type="pagebreak" id="Page_37" title="37"/><a class="XrefDestination" id="Nmap"/><span class="XrefDestination" id="xref-502840c02-018"/>Nmap</h3>
<p class="BodyFirst">Developed by Gordon Lyon (also known as “Fyodor”), Nmap is the Swiss Army knife of port scanning. It’s also one of the oldest security tools out there today, created in September 1997. (It’s quite amazing that it has remained the de facto port-scanning tool decades later.)</p>
<p>We’ll use Nmap’s port-scanning capability and its custom scripting engine, called the <em>Nmap Scripting Engine (NSE)</em>. NSE uses scripts written in the Lua language to extend Nmap into a full-blown vulnerability-assessment tool. We’ll leverage this functionality to scan for GraphQL servers and find vulnerabilities.</p>
<p>Kali comes bundled with Nmap by default. Verify that you have it installed with the following command:</p>
<pre><code># <b>sudo apt install nmap -y</b></code></pre>
<p>Next, download the <em>nmap-graphql-introspection-nse</em> Lua script for Nmap and place it in the NSE <em>scripts</em> folder:</p>
<pre><code># <b>cd ~</b>
# <b>git clone https://github.com/dolevf/nmap-graphql-introspection-nse.git</b>
# <b>cd nmap-graphql-introspection-nse</b>
# <b>sudo cp graphql-introspection.nse /usr/share/nmap/scripts</b></code></pre>
<p>Let’s now verify that Nmap can find and read the script by passing it the <code class="bold">--script-help</code> command argument:</p>
<pre><code># <b>nmap --script-help graphql-introspection.nse</b>

Starting Nmap ( https://nmap.org )

graphql-introspection
Categories: discovery fuzzer vuln intrusive
https://nmap.org/nsedoc/scripts/graphql-introspection.html
Identifies webservers running GraphQL endpoints and attempts an
execution of an Introspection query for information gathering.

This script queries for common graphql endpoints and then sends an
Introspection query and inspects the result.

  Resources
  * https://graphql.org/learn/introspection/</code></pre>
<h3 id="h2-502840c02-0012"><a class="XrefDestination" id="Commix"/><span class="XrefDestination" id="xref-502840c02-019"/>Commix</h3>
<p class="BodyFirst"><em>Command Injection Exploiter (Commix) </em>is an open source project written in Python and developed by Anastasios Stasinopoulos. Commix attempts to find and exploit command injection vulnerabilities in an automated fashion by fuzzing various parts of an HTTP request, such as query parameters or the request body, using specialized payloads. The tool is also capable of <span epub:type="pagebreak" id="Page_38" title="38"/>exploiting these vulnerabilities and can spawn a custom interactive shell, which penetration testers can use to gain a foothold in remote servers.</p>
<p>Commix should be preinstalled in Kali by default, but to ensure that it is indeed available and working properly, run the following set of commands:</p>
<pre><code># <b>sudo apt install commix -y</b>
# <b>commix -h</b>

Usage: commix [option(s)]

Options:
  -h, --help            Show help and exit.

  General:
    These options relate to general matters.

    -v VERBOSE          Verbosity level (0-4, Default: 0).
    --version           Show version number and exit.</code></pre>
<h3 id="h2-502840c02-0013"><a class="XrefDestination" id="graphql-path-enum"/><span class="XrefDestination" id="xref-502840c02-020"/>graphql-path-enum</h3>
<p class="BodyFirst">Written in Rust and developed by dee_see (<a href="http://www.twitter.com/@dee_see">@dee_see</a>), <em>graphql-path-enum</em> is a security testing tool that finds various ways to construct queries that reach a specific piece of data. By doing so, it arms hackers with information that could assist them in identifying authorization flaws. We’ll discuss GraphQL authorization vulnerabilities in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<p>Install graphql-path-enum by running the following commands:</p>
<pre><code># <b>cd ~</b>
# <b>wget "https://gitlab.com/dee-see/graphql-path-enum/-/jobs/artifacts/v1.1/raw</b>
<b>/target/release/graphql-path-enum?job=build-linux"</b>
<b>-O graphql-path-enum</b>
# <b>chmod u+x graphql-path-enum</b></code></pre>
<p>Verify that it can successfully run with its new permissions by passing it the <code class="bold">-h</code> flag:</p>
<pre><code># <b>./graphql-path-enum -h</b>

graphql-path-enum

USAGE:
    graphql-path-enum [FLAGS] --introspect-query-path &lt;FILE_PATH&gt; --type &lt;TYPE_NAME&gt;

FLAGS:
        --expand-connections    Expand connection nodes
        (with pageInfo, edges, etc. edges), they are skipped by default.
    -h, --help                  Prints help information
        --include-mutations     Include paths from the Mutation node.
        Off by default because this often adds a lot of noise.
    -V, --version               Prints version information</code></pre>
<h3 id="h2-502840c02-0014"><span epub:type="pagebreak" id="Page_39" title="39"/><a class="XrefDestination" id="EyeWitness"/><span class="XrefDestination" id="xref-502840c02-021"/>EyeWitness</h3>
<p class="BodyFirst"><em>EyeWitness</em> is a web-scanning tool developed by Chris Truncer and Rohan Vazarkar that is capable of capturing screenshots of target web applications. When scanning many websites in a penetration test, you’ll often find it useful to visually identify what’s running on them. EyeWitness achieves this using a command line–based web browser (also called a <em>headless browser</em>) under the hood, which allows it to load dynamic web content, such as content loaded dynamically using JavaScript.</p>
<p>Install EyeWitness with the following command:</p>
<pre><code># <b>sudo apt install eyewitness -y</b>
#<b> eyewitness -h</b>

Protocols:
  --web                 HTTP Screenshot using Selenium

Input Options:
  -f Filename           Line-separated file containing URLs to capture
  -x Filename.xml       Nmap XML or .Nessus file
  --single Single URL   Single URL/Host to capture
  --no-dns</code></pre>
<h3 id="h2-502840c02-0015"><a class="XrefDestination" id="GraphQLCop"/><span class="XrefDestination" id="xref-502840c02-022"/>GraphQL Cop</h3>
<p class="BodyFirst">We developed GraphQL Cop, a dedicated GraphQL security auditing utility based on Python. GraphQL Cop audits GraphQL servers for information disclosure and DoS-based vulnerabilities. In later chapters, we will use this tool to check whether GraphQL servers are protected against common attacks.</p>
<p>Install GraphQL Cop with the following set of commands:</p>
<pre><code># <b>sudo apt install python3-pip -y</b>
# <b>git clone https://github.com/dolevf/graphql-cop.git</b>
#<b> cd graphql-cop</b>
#<b> pip3 install -r requirements.txt</b>
#<b> python3 graphql-cop.py -h</b>

Options:
  -h, --help            show this help message and exit
  -t URL, --target=URL  target url with the path
  -H HEADER, --header=HEADER
                        Append Header to the request '{"Authorization":
                        "Bearer eyjt"}'
  -o FORMAT, --output=FORMAT
                        json
  -x, --proxy           Sends the request through http://127.0.0.1:8080 proxy
  -v, --version         Print out the current version and exit.</code></pre>
<h3 id="h2-502840c02-0016"><span epub:type="pagebreak" id="Page_40" title="40"/><a class="XrefDestination" id="CrackQL"/><span class="XrefDestination" id="xref-502840c02-023"/>CrackQL</h3>
<p class="BodyFirst">We developed CrackQL, a specialized brute-forcing tool for GraphQL that uses GraphQL language features to better optimize brute-force attacks against API actions that may require authentication. We will use this tool in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, when we perform dictionary-based attacks against our GraphQL target. Install CrackQL as follows:</p>
<pre><code># <b>git clone https://github.com/nicholasaleks/CrackQL.git</b>
#<b> cd CrackQL</b>
#<b> pip3 install -r requirements.txt</b>
#<b> python3 CrackQL.py -h</b>

Options:
  -h, --help            show this help message and exit
  -t URL, --target=URL  Target url with a path to the GraphQL endpoint
  -q QUERY, --query=QUERY
                        Input query or mutation operation with variable
                        payload markers
  -i INPUT_CSV, --input-csv=INPUT_CSV
                        Path to a csv list of arguments (i.e. usernames,
                        emails, ids, passwords, otp_tokens, etc.)</code></pre>
<p>Once you’ve installed all of these tools, we highly encourage you to take a snapshot of your Kali virtual machine to ensure that its state is saved. You’ll then be able to restore it should it break in the future.</p>
<h2 id="h1-502840c02-0006"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c02-024"/>Summary</h2>
<p class="BodyFirst">Let’s summarize what you currently have in your lab: graphical and command line HTTP clients that can interact with GraphQL, a working Docker environment for deploying containers, and the DVGA target application.</p>
<p>This chapter briefly discussed how these tools work under the hood and the needs they fill, such as information gathering, server fingerprinting, network and application scanning, vulnerability assessments, and GraphQL auditing. You’ll explore their use in more depth in the remaining chapters.</p>
<p>This lab is an essential part of this book, but it might also prove valuable for your next real-world penetration test. We encourage you to keep an eye on the Black Hat GraphQL GitHub repository (<a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL.git">https://github.com/dolevf/Black-Hat-GraphQL.git</a>), where we maintain a list of current and future GraphQL security tools to help you keep your lab up to date.</p>
</section>
</body>
</html>