- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: SOFTWARE DEVELOPMENT MODELS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发模型**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: You don’t write great code by following a fixed set of rules for every project.
    For some projects, hacking out a few hundred lines of code might be all you need
    to produce a great program. Other projects, however, could involve millions of
    code lines, hundreds of project engineers, and several layers of management or
    other support personnel; in these cases, the software development process you
    use will greatly affect the project’s success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会通过对每个项目都遵循一套固定的规则来编写出伟大的代码。对于某些项目，可能只需要编写几百行代码就能生产出一个优秀的程序。然而，其他项目可能涉及到数百万行代码，成百上千的项目工程师，以及几层管理或其他支持人员；在这些情况下，你所使用的软件开发过程将极大地影响项目的成功。
- en: In this chapter, we’ll look at various development models and when to use them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论各种开发模型以及何时使用它们。
- en: '**3.1 The Software Development Life Cycle**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.1 软件开发生命周期**'
- en: 'During its life, a piece of software generally goes through eight phases, collectively
    known as the *Software Development Life Cycle (SDLC)*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件的生命周期中，一般会经历八个阶段，统称为*软件开发生命周期（SDLC）*：
- en: Product conceptualization
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品构思
- en: Requirement development and analysis
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求开发与分析
- en: Design
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计
- en: Coding (implementation)
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码（实现）
- en: Testing
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: Deployment
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署
- en: Maintenance
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护
- en: Retirement
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退役
- en: Let’s look at each phase in turn.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看每个阶段。
- en: '**Product conceptualization**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**产品构思**'
- en: A customer or manager develops an idea for some software and creates a business
    case justifying its development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 客户或经理为某个软件构思一个想法，并创建一个业务案例，证明其开发的合理性。
- en: Often, a nonengineer envisions a need for the software and approaches a company
    or individual who can implement it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个非工程师会设想出对软件的需求，并寻求能够实现它的公司或个人。
- en: '**Requirement development and analysis**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求开发与分析**'
- en: Once you have a product concept, the product requirements must be outlined.
    Project managers, stakeholders, and clients (users) meet to discuss and formalize
    what the software system must do to satisfy everyone. Of course, users will want
    the software to do everything under the sun. Project managers will temper this
    expectation based on the available resources (for example, programmers), estimated
    development times, and costs. Other stakeholders might include venture capitalists
    (others financing the project), regulatory agencies (for example, the Nuclear
    Regulatory Commission if you’re developing software for a nuclear reactor), and
    marketing personnel who might provide input on the design to make it saleable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了产品构思，就必须制定产品需求。项目经理、利益相关者和客户（用户）会面，讨论并明确软件系统必须完成的任务，以满足各方需求。当然，用户希望软件能够做到任何事情。项目经理会根据可用资源（例如程序员）、估算的开发时间和成本来调整这一预期。其他利益相关者可能包括风险投资家（为项目提供资金的人）、监管机构（例如，如果你正在开发核反应堆的软件，可能需要核监管委员会的审批），以及可能为设计提供意见以使其具备销售潜力的市场人员。
- en: 'By meeting, discussing, negotiating, and so on, the interested parties develop
    requirements based on questions like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过会议、讨论、谈判等，相关方根据以下问题来制定需求：
- en: For whom is the system intended?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是为谁设计的？
- en: What inputs should be provided to the system?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该提供什么输入？
- en: What output should the system produce (and in what format)?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该产生什么样的输出（以及以何种格式）？
- en: What types of calculations will be involved?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会涉及到什么类型的计算？
- en: If there is a video display, what screen layouts should the system use?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有视频显示，系统应该使用什么屏幕布局？
- en: What are the *expected* response times between input and output?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预期*的输入与输出响应时间应该是多少？'
- en: From this discussion, the developers will put together the *System Requirements
    Specification (SyRS)* document, which specifies all the major requirements for
    hardware, software, and so on. Then the program management and system analysts
    use the SyRS to produce a *Software Requirements Specification (SRS)* document,^([1](ch19_footnote.xhtml#ch03fn1))
    which is the end result of this phase. As a rule, the SRS is for internal consumption
    only, used by the software development team, whereas the SyRS is an external document
    for customer reference. The SRS extracts all the software requirements from the
    SyRS and expands on them. [Chapter 10](ch10.xhtml) discusses these two documents
    in detail (see “[The System Requirements Specification Document](ch10.xhtml#lev-10.3)”
    on [page 193](ch10.xhtml#page_193) and “The Software Requirements Specification
    Document” on [page 194](ch10.xhtml#page_194)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一讨论，开发人员将编写*系统需求规格说明书（SyRS）*，该文档规定了所有硬件、软件等的主要需求。接着，项目管理和系统分析师使用SyRS来生成*软件需求规格说明书（SRS）*，^([1](ch19_footnote.xhtml#ch03fn1))这是本阶段的最终成果。一般而言，SRS是仅供内部使用的，由软件开发团队使用，而SyRS则是供客户参考的外部文档。SRS从SyRS中提取所有软件需求并进行扩展。[第10章](ch10.xhtml)详细讨论了这两份文档（请参见[《系统需求规格说明书》](ch10.xhtml#lev-10.3)，第193页和[《软件需求规格说明书》](ch10.xhtml#lev-10.4)，第194页）。
- en: '**Design**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**'
- en: 'The software design architect (software engineer) uses the software requirements
    from the SRS to prepare the *Software Design Description (SDD)*. The SDD provides
    some combination, but not necessarily all, of the following items:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计架构师（软件工程师）根据SRS中的软件需求准备*软件设计描述（SDD）*。SDD提供了以下项目的某些组合，但不一定是全部：
- en: A system overview
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统概述
- en: Design goals
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计目标
- en: The data (via a *data dictionary*) and databases used
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的数据（通过*数据字典*）和数据库
- en: A data flow (perhaps using data flow diagrams)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流（可能使用数据流图表示）
- en: An interface design (how the software interacts with other software and the
    software’s users)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口设计（软件如何与其他软件以及软件用户进行交互）
- en: Any standards that must be followed
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须遵循的任何标准
- en: Resource requirements (for example, memory, CPU cycles, and disk capacity)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源需求（例如，内存、CPU周期和磁盘容量）
- en: Performance requirements
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能要求
- en: Security requirements
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性要求
- en: See [Chapter 11](ch11.xhtml) for further details on the contents of the SDD.
    The design documentation becomes the input for the next phase, coding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 详见[第11章](ch11.xhtml)，了解SDD内容的更多细节。设计文档将成为下一阶段——编码的输入。
- en: '**Coding**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**'
- en: 'Coding—writing the actual software—is the step most familiar and fun to software
    engineers. A software engineer uses the SDD to write the software. *WGC5: Great
    Coding* will be dedicated to this phase.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '编码——编写实际的软件——是软件工程师最熟悉且最有趣的步骤。软件工程师使用SDD来编写软件。*WGC5: 伟大的编码*将专门讨论这一阶段。'
- en: '**Testing**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**'
- en: 'In this phase, the code is tested against the SRS to ensure the product solves
    the problems listed in the requirements. There are several components in this
    phase, including:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，代码将针对SRS进行测试，以确保产品解决了需求中列出的所有问题。此阶段包含几个组成部分，包括：
- en: '**Unit testing** Checks the individual statements and modules in the program
    to verify that they behave as expected. This actually occurs during coding but
    logically belongs in the testing phase.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试** 检查程序中的各个语句和模块，以验证它们是否按预期工作。虽然这通常发生在编码阶段，但从逻辑上来说，它属于测试阶段。'
- en: '**Integration testing** Verifies that the individual subsystems in the software
    work well together. This also occurs during the coding phase, usually toward the
    end.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试** 验证软件中的各个子系统能够很好地协同工作。这个过程通常发生在编码阶段，通常是在接近尾声时。'
- en: '**System testing** Validates the implementation; that is, it shows that the
    software correctly implements the SRS.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统测试** 验证实现情况；即，证明软件正确地实现了SRS（软件需求规格说明书）。'
- en: '**Acceptance testing** Demonstrates to the customer that the software is suitable
    for its intended purpose.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收测试** 向客户展示软件是否适合其预期用途。'
- en: '*WGC6: Testing, Debugging, and Quality Assurance* will cover the testing phase
    in detail. [Chapter 12](ch12.xhtml) describes the software test case and software
    test procedure documents you’ll create to guide testing.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*WGC6: 测试、调试与质量保证*将详细讨论测试阶段。[第12章](ch12.xhtml)描述了你将在测试过程中创建的软件测试用例和软件测试程序文档。'
- en: '**Deployment**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署**'
- en: The software product is delivered to the customer(s) for their use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 软件产品交付给客户用于使用。
- en: '**Maintenance**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护**'
- en: Once customers begin using the software, chances are fairly high that they’ll
    discover defects and request new functionality. During this time, the software
    engineers might fix the defects or add the new enhancements, and then deploy new
    versions of the software to the customer(s).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户开始使用软件，他们很有可能会发现缺陷并要求新增功能。在这个过程中，软件工程师可能会修复缺陷或增加新的功能，然后将软件的新版本部署给客户。
- en: '**Retirement**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**退休**'
- en: Eventually in some software’s life, development will cease, perhaps because
    the development organization decides to no longer support or work on it, it is
    replaced by a different version, the company making it goes out of business, or
    the hardware on which it runs becomes obsolete.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在一些软件的生命周期中，开发将停止，可能是因为开发组织决定不再支持或开发它，或者它被不同版本的程序取代，或者开发它的公司倒闭，或者它运行的硬件变得过时。
- en: '**3.2 The Software Development Model**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.2 软件开发模型**'
- en: 'A *software development model* describes how all the phases of the SDLC combine
    in a software project. Different models are suitable for different circumstances:
    some emphasize certain phases and deemphasize others, some repeat various phases
    throughout the development process, and others skip some phases entirely.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件开发模型* 描述了 SDLC（软件开发生命周期）中的所有阶段如何在软件项目中结合。不同的模型适用于不同的情况：有些强调某些阶段，忽略其他阶段；有些在开发过程中反复进行各个阶段；还有一些完全跳过某些阶段。'
- en: There are eight well-respected software development models and dozens, if not
    hundreds, of variations of these eight models in use today. Why don’t developers
    just pick one popular model and use it for everything? The reason, as noted in
    [Chapter 1](ch01.xhtml), is that practices that work well for individuals or small
    teams don’t *scale up* well to large teams. Likewise, techniques that work well
    for large projects rarely *scale down* well for small projects. This book will
    focus on techniques that work well for individuals, but great programmers must
    be able to work within all design processes if they want to be great programmers
    on projects of all sizes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有八种受人尊敬的软件开发模型，且这些模型有数十种，甚至数百种变体在使用。那么，为什么开发者不选择一个流行的模型并用它来处理所有的事情呢？如[第1章](ch01.xhtml)中所述，适合个人或小团队的做法，在大型团队中不一定能有效扩展；同样，适合大项目的技术，往往不能很好地适用于小项目。本书将重点讨论适合个人的技术，但伟大的程序员必须能够在所有设计过程中工作，才能在各类项目中成为优秀的程序员。
- en: In this chapter I’ll describe the eight major software models—their advantages,
    disadvantages, and how to apply them appropriately. However, in practice, none
    of these models can be followed blindly or expected to guarantee a successful
    project. This chapter also discusses what great programmers can do to work around
    the limitations of a model forced on them and still produce great code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述八种主要的软件模型——它们的优缺点，以及如何正确地应用它们。然而，在实践中，这些模型中的任何一个都不能盲目跟随，也不能指望它们保证项目的成功。本章还将讨论伟大的程序员如何在被迫使用某个模型的局限性时，依然能够绕开这些限制，编写出优秀的代码。
- en: '***3.2.1 The Informal Model***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.1 非正式模型***'
- en: 'The Informal model describes software development with minimal process or discipline:
    no formal design, no formal testing, and a lack of project management. This model
    was originally known as *hacking*^([2](ch19_footnote.xhtml#ch03fn2)) and those
    who engaged in it were known as *hackers*. However, as those original hackers
    grew up and gained experience, education, and skills, they proudly retained the
    name “hacker,” so the term no longer refers to an inexperienced or unskilled programmer.^([3](ch19_footnote.xhtml#ch03fn3))
    I’ll still use the term *hacking* to mean an informal coding process, but I’ll
    use *informal coder* to describe a person who engages in hacking. This will avoid
    confusion with differing definitions of *hacker*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式模型描述了软件开发过程中的最小化流程或纪律：没有正式的设计，没有正式的测试，缺乏项目管理。这个模型最初被称为 *黑客*^([2](ch19_footnote.xhtml#ch03fn2))，那些参与其中的人被称为
    *黑客*。然而，随着这些最初的黑客成长并获得经验、教育和技能，他们自豪地保留了“黑客”这个称号，所以这个术语不再指代一个缺乏经验或技能的程序员^([3](ch19_footnote.xhtml#ch03fn3))。我仍然会使用
    *黑客* 来表示一种非正式的编码过程，但我会用 *非正式编码者* 来描述那些参与黑客行为的人。这样可以避免与“黑客”一词不同定义的混淆。
- en: In the Informal model, the programmer moves directly from product conceptualization
    to coding, “hacking away” at the program until something is working (often not
    well), rather than designing a robust, flexible, readable program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在非正式模型中，程序员直接从产品概念化进入编码阶段，不断“敲代码”，直到程序有些许功能（通常效果不好），而不是设计一个健壮、灵活、易读的程序。
- en: 'Hacking has a few advantages: it’s fun, done independently (though certainly
    many people participate in group events like hackathons), and the programmer is
    responsible for most design decisions and for moving the project along, so they
    can often get something working faster than could a software engineer following
    a formal development process.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客技术有几个优势：它很有趣，通常是独立完成的（虽然当然许多人参与像黑客马拉松这样的团体活动），程序员负责大多数设计决策并推动项目进展，因此他们通常能够比遵循正式开发过程的软件工程师更快地让某些东西工作。
- en: The problem with the Informal model is that its conscious lack of design may
    lead to an invalid system that doesn’t do what end users want, because their requests
    weren’t considered in the requirements and software specifications—if those even
    exist—and often the software isn’t tested or documented, which makes it difficult
    for anyone other than the original programmer to use it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式模型的问题在于它有意缺乏设计，这可能导致一个无效的系统，无法满足最终用户的需求，因为他们的要求没有被考虑到需求和软件规格中——如果这些需求和规格存在的话——而且通常软件没有经过测试或文档化，这使得除原始程序员外的任何人都很难使用它。
- en: Thus, the Informal model works for small, throwaway programs intended for use
    only by the programmer who coded them. For such projects, it’s far cheaper and
    more efficient to bang out a couple hundred lines of code for limited and careful
    use than to go through the full software development process. (Unfortunately,
    some “throwaway” programs can take on a life of their own and become popular once
    users discover them. Should this happen, the program should be redesigned and
    reimplemented so it can be maintained properly.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，非正式模型适用于那些仅供编写程序的程序员使用的小型一次性程序。对于这样的项目，编写几百行代码用于有限且谨慎的使用，比起完整的软件开发过程要便宜得多且更高效。（不幸的是，一些“一次性”程序可能会因用户的发现而获得生命，并变得流行。发生这种情况时，程序应当重新设计并重新实现，以便能够正确地维护。）
- en: Hacking is also useful for developing small prototypes, especially screen displays
    intended to demonstrate a program in development to a prospective customer. One
    sticky problem here, though, is that clients and managers may look at the prototype
    and assume that a large amount of code is already in place, meaning they may push
    to further develop the hacked code rather than start the development process from
    the beginning, which will lead to problems down the road.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客技术也有助于开发小型原型，特别是那些旨在向潜在客户展示正在开发中的程序的屏幕显示。然而，这里有一个棘手的问题，那就是客户和经理可能会查看这个原型，并假设已经有大量代码就绪，这意味着他们可能会推动进一步开发被“破解”的代码，而不是从头开始开发，这会导致未来的问题。
- en: '***3.2.2 The Waterfall Model***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.2 瀑布模型***'
- en: The Waterfall model is the granddaddy of software development models, and most
    models are a variation of it. In the Waterfall model, each step of the SDLC is
    executed sequentially from beginning to end (see [Figure 3-1](ch03.xhtml#ch3fig1)),
    with the output from each step forming the input for the next step.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布模型是软件开发模型的祖父，大多数模型都是它的变体。在瀑布模型中，SDLC的每个步骤都是按顺序从头到尾执行的（参见[图3-1](ch03.xhtml#ch3fig1)），每个步骤的输出形成下一个步骤的输入。
- en: '![image](Images/fig3-1.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-1.jpg)'
- en: '*Figure 3-1: The Waterfall model*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：瀑布模型*'
- en: You begin the Waterfall model by producing the SyRS. Once the system requirements
    are specified, you produce the SRS from the SyRS. When the software requirements
    are specified, you produce the SDD from the SRS. You then produce source code
    from the SDD and test the software. Then you deploy and maintain the software.
    Everything in the SLDC happens in that order, without deviation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你从生成系统需求说明书（SyRS）开始使用瀑布模型。一旦系统需求被确定，你就可以从SyRS生成软件需求说明书（SRS）。当软件需求被确定后，你可以从SRS生成软件设计文档（SDD）。接着你从SDD生成源代码并进行软件测试。然后你将部署并维护软件。SLDC中的一切都按照这个顺序进行，没有任何偏差。
- en: As the original SDLC model, the Waterfall model is usually very simple to understand
    and apply to a software development project because each step is distinct, with
    well-understood inputs and deliverables. It’s also relatively easy to review work
    performed using this model and verify that the project is on track.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为原始的SDLC模型，瀑布模型通常非常简单，容易理解并应用于软件开发项目，因为每个步骤都是独立的，且有明确的输入和输出交付物。使用该模型进行的工作也相对容易审查，并且可以验证项目是否按计划进行。
- en: 'However, the Waterfall model suffers from some huge problems. The most important
    is that it assumes that you perform each step perfectly before progressing to
    the next step, and that you’ll find errors early in one step and make repairs
    before proceeding. In reality, this is rarely the case: defects in the requirements
    or design phases are typically not caught until testing or deployment. At that
    point, it can be very expensive to back up through the system and correct everything.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，瀑布模型存在一些重大问题。最重要的一点是，它假设你在进行到下一个步骤之前会完美地执行每个步骤，并且会在某个步骤的早期发现错误并进行修复。然而，现实情况是，这种情况很少发生：需求或设计阶段的缺陷通常要到测试或部署时才会被发现。到那时，倒退到系统中并修正所有问题可能非常昂贵。
- en: Another disadvantage is that the Waterfall model doesn’t allow you to produce
    a working system for customers to review until very late in the development process.
    I can’t count the number of times I’ve shown a client static screenshots or diagrams
    of how code would work, received their buy-in, and then had them reject the running
    result. That major disconnect in expectations could have been avoided had I produced
    a working prototype of the code that would have allowed customers to experiment
    with certain aspects of the system during the requirements phase.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，瀑布模型在开发过程的很晚阶段才能提供一个可供客户评审的工作系统。我数不清有多少次，我向客户展示静态截图或代码如何工作图示，获得了他们的认可，但最终他们却拒绝了运行结果。如果我在需求阶段就制作了一个可用的代码原型，让客户能够在某些系统功能上进行实验，这种重大期望上的差距本可以避免。
- en: Ultimately, this model is very risky. Unless you can *exactly* specify what
    the system will do before you start the process, the Waterfall model is likely
    inappropriate for your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个模型是非常有风险的。除非你能*准确*地在开始之前定义系统将要执行的任务，否则瀑布模型很可能不适合你的项目。
- en: The Waterfall model is appropriate for small projects of, say, less than a few
    tens of thousands of code lines involving only a couple of programmers; for very
    large projects (because nothing else works at that level); or when the current
    project is similar to a previous product that employed the Waterfall model during
    development (so you can use the existing documentation as a template).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布模型适用于小型项目，例如代码行数不到几万行，且仅涉及少数几名程序员的情况；或者适用于非常大型的项目（因为在那个层级，别的模型都无法适用）；又或者当当前项目与之前使用瀑布模型开发的产品相似时（因此你可以使用现有的文档作为模板）。
- en: '***3.2.3 The V Model***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.3 V 模型***'
- en: 'The V model, shown in [Figure 3-2](ch03.xhtml#ch3fig2), follows the same basic
    steps as the Waterfall model but emphasizes the development of testing criteria
    early in the development life cycle. The V model is organized so the earlier steps,
    requirements and design, produce two sets of outputs: one for the step that follows
    and one for a parallel step during the testing phase.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: V 模型，如[图 3-2](ch03.xhtml#ch3fig2)所示，遵循与瀑布模型相同的基本步骤，但强调在开发生命周期的早期制定测试标准。V 模型的结构使得早期的步骤——需求和设计——会产生两组输出：一组用于后续步骤，另一组用于测试阶段的平行步骤。
- en: '![image](Images/fig3-2.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-2.jpg)'
- en: '*Figure 3-2: The V model*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：V 模型*'
- en: 'In [Figure 3-2](ch03.xhtml#ch3fig2), the items on the left side of the V link
    straight across to the items on the right side: at each design stage, the programmer
    is thinking about how to test and use the concepts being modeled. For example,
    during the *requirements and architecture* phase, the system architect designs
    the system acceptance tests that will verify that the software correctly implements
    all the requirements. During the *design* phase, the system designer implements
    the software’s unit and integration tests.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-2](ch03.xhtml#ch3fig2)中，V 左侧的项目直接链接到右侧的项目：在每个设计阶段，程序员都在考虑如何测试并使用正在建模的概念。例如，在*需求和架构*阶段，系统架构师设计系统验收测试，以验证软件是否正确实现了所有需求。在*设计*阶段，系统设计师实施软件的单元测试和集成测试。
- en: The big difference here from the Waterfall model is that the engineer implements
    test cases and procedures early on, so by the time coding begins, the software
    engineer can use existing test procedures to verify the code’s behavior during
    development. Known as *test-driven development (TDD)*, in this approach the programmer
    constantly runs tests throughout the development process. Continuous testing allows
    you to find bugs much sooner and makes it cheaper and faster to correct them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与瀑布模型的最大区别在于，工程师在早期就实现了测试用例和程序，因此当编码开始时，软件工程师可以利用现有的测试程序在开发过程中验证代码行为。这种方法被称为*测试驱动开发（TDD）*，在这种方法中，程序员在整个开发过程中不断进行测试。持续的测试可以让你更早发现漏洞，并使修复这些漏洞变得更加便宜和迅速。
- en: That said, the V model is far from perfect. Like its parent, the Waterfall model,
    the V model is too simple, and requires too much perfection in the early stages
    in order to prevent disasters in the later stages. For example, a defect in the
    requirements and architecture phase might not surface until system testing and
    validation, resulting in expensive backtracking through the development. For this
    reason, the V model doesn’t work well for projects whose requirements are subject
    to change throughout a product’s lifetime.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，V模型并不完美。像其母模型瀑布模型一样，V模型过于简单，并且在早期阶段要求过多的完善，以避免后期的灾难。例如，需求和架构阶段的缺陷可能直到系统测试和验证时才显现出来，导致在开发过程中需要付出昂贵的返工成本。因此，V模型并不适用于需求在产品生命周期中可能发生变化的项目。
- en: The model often encourages verification at the expense of validation. *Verification*
    ensures that a product meets certain requirements (such as its software requirements).
    It’s easy to develop tests that show the software is fulfilling requirements laid
    out in the SRS and SyRS. In contrast, *validation* shows that the product meets
    the needs of its end users. Being more open-ended, validation is more difficult
    to achieve.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型通常鼓励验证，而牺牲了验证的效果。*验证*确保产品满足特定的需求（例如软件需求）。开发测试用例来证明软件符合SRS和SyRS中列出的要求是很容易的。相比之下，*确认*证明产品满足最终用户的需求。由于更加开放，确认更难以实现。
- en: It’s difficult, for example, to test that the software doesn’t crash because
    it tries to process a `NULL` pointer. For this reason, validation tests are often
    entirely missing in the test procedures. Most test cases are requirements-driven,
    and rarely are there requirements like “no divisions by zero in this section of
    code” or “no memory leaks in this module” (these are known as *requirement gaps*;
    coming up with test cases without any requirements to base them on can be challenging,
    especially for novices).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试软件是否会因试图处理`NULL`指针而崩溃是困难的。因此，验证测试通常在测试程序中完全缺失。大多数测试用例是需求驱动的，像“这一段代码中没有除以零的情况”或“这个模块没有内存泄漏”等需求则很少见（这些被称为*需求缺口*；在没有任何需求依据的情况下设计测试用例可能会非常具有挑战性，尤其对于初学者来说）。
- en: '***3.2.4 The Iterative Model***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.4 迭代模型***'
- en: Sequential models like Waterfall and V rely on the assumption that specification,
    requirements, and design are all perfect before coding occurs, meaning users won’t
    discover design problems until the software is first deployed. By then it’s often
    too costly (or too late) to repair the design, correct the software, and test
    it. The Iterative model overcomes this problem by taking multiple passes over
    the development model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像瀑布模型和V模型这样的顺序模型假设在编码之前，规格、需求和设计都已经完美无缺，这意味着用户在软件首次部署之前不会发现设计问题。而此时，通常修复设计、修正软件并进行测试的成本已经过高（或者为时已晚）。迭代模型通过多次遍历开发模型克服了这个问题。
- en: The hallmark of the Iterative model is user feedback. The system designers start
    with a general idea of the product from the users and stakeholders and create
    a minimal set of requirements and design documentation. The coders implement and
    test this minimal implementation. The users then play with this implementation
    and provide feedback. The system designers produce a new set of requirements and
    designs based on the user feedback, and the programmers implement and test the
    changes. Finally, users are given a second version for their evaluation. This
    process repeats until the users are satisfied or the software meets the original
    goals.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模型的标志是用户反馈。系统设计师从用户和利益相关者那里获取产品的整体构想，并创建一个最小的需求和设计文档。编码人员实施并测试这个最小实现。然后，用户体验这个实现并提供反馈。系统设计师根据用户反馈产生新的需求和设计，程序员实施并测试这些更改。最后，用户会得到第二个版本进行评估。这个过程会重复，直到用户满意或软件达成最初的目标。
- en: One big advantage of the Iterative model is that it works reasonably well when
    it’s difficult to completely specify the software’s behavior at the beginning
    of the development cycle. System architects can work from a general road map to
    design enough of the system for end users to play with and determine which new
    features are necessary. This avoids spending considerable effort producing features
    end users want implemented differently or don’t want at all.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模型的一个大优点是，当在开发周期开始时很难完全指定软件的行为时，它依然能很好地工作。系统架构师可以从一个大致的路线图出发，设计足够的系统部分，让最终用户可以进行操作并确定哪些新功能是必要的。这避免了花费大量精力去开发那些最终用户希望以不同方式实现或根本不需要的功能。
- en: Another advantage is that the Iterative model reduces *time to market* risk.
    To get the product to market quickly, you decide on a subset of features the final
    product will have and develop those first, get the product working (in a minimalist
    fashion), and ship this *minimum viable product (MVP)*. Then, you add functionality
    to each new iteration to produce a new enhanced version of the product.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是，迭代模型降低了*市场时间*风险。为了快速将产品推向市场，你会决定最终产品的一部分功能并优先开发这些功能，先让产品以最简化的方式工作，并发布这个*最小可行产品
    (MVP)*。然后，在每次新迭代中添加功能，生产出新版本的增强产品。
- en: 'Advantages of the Iterative model include:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模型的优势包括：
- en: You can achieve minimal functionality very rapidly.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以非常迅速地实现最小功能。
- en: Managing risk is easier than in sequential models because you don’t have to
    complete the entire program to determine that it won’t do the job properly.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理风险比顺序模型更容易，因为你不需要完成整个程序就能确定它不能正常工作。
- en: Managing the project as it progresses (toward completion) is easier and more
    obvious than with sequential models.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着项目的进展（接近完成），管理变得比顺序模型更容易和更明显。
- en: Changing requirements is supported.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持需求变化。
- en: Changing requirements costs less.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变需求的成本更低。
- en: Parallel development is possible with two (or more) sets of teams working on
    alternate versions.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行开发是可能的，通过两组（或更多）团队交替工作在不同版本上。
- en: 'Here are some disadvantages of the Iterative model:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是迭代模型的一些缺点：
- en: Managing the project is more work.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理项目的工作量更多。
- en: It doesn’t scale down to smaller projects very well.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不太适合规模较小的项目。
- en: It might take more resources (especially if parallel development takes place).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能需要更多资源（特别是当进行并行开发时）。
- en: Defining the iterations might require a “grander” road map of the system (that
    is, going back to specifying all the requirements before development starts).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义迭代可能需要一个“更宏大的”系统路线图（即，在开发开始前重新指定所有需求）。
- en: There might be no limit on the number of iterations; hence, it could be impossible
    to predict when the project will be complete.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代次数可能没有限制；因此，可能无法预测项目何时完成。
- en: '***3.2.5 The Spiral Model***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.5 螺旋模型***'
- en: 'The Spiral model is also an iterative model that repeats four phases: planning,
    design, evaluation/risk analysis, and construction (see [Figure 3-3](ch03.xhtml#ch3fig3)).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型也是一个迭代模型，它重复四个阶段：规划、设计、评估/风险分析和构建（见[图 3-3](ch03.xhtml#ch3fig3)）。
- en: '![image](Images/fig3-3.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-3.jpg)'
- en: '*Figure 3-3: The Spiral model*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：螺旋模型*'
- en: 'The Spiral model is heavily risk-based: each iteration assesses the risks of
    going forward with the project. Management chooses which features to add and omit
    and which approaches to take by analyzing the risk (that is, the likelihood of
    failure).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型极度依赖于风险：每个迭代都会评估继续推进项目的风险。管理层通过分析风险（即失败的可能性）来选择添加和省略哪些特性，并决定采取哪些方法。
- en: The Spiral is often called a *model generator* or *meta model* because you can
    use further development models—the same type or a different one—on each spiral.
    The drawback is that the resulting model becomes specific to that project, making
    it difficult to apply to others.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型常被称为*模型生成器*或*元模型*，因为你可以在每个螺旋中使用进一步发展的模型——相同类型的或不同类型的。缺点是，最终的模型会变得特定于该项目，难以应用于其他项目。
- en: One key advantage of the Spiral model is that it involves end users with the
    software early and continuously during development by producing working prototypes
    on a regular basis. The end user can play with these prototypes, determine if
    development is on the right track, and redirect the development process if needed.
    This addresses one of the great shortcomings of the Waterfall and V models.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型的一个关键优势是，它在开发过程中通过定期生成工作原型，早期且持续地让最终用户参与进来。最终用户可以与这些原型互动，判断开发是否走在正确的轨道上，并在需要时调整开发过程。这解决了瀑布模型和V模型的一大缺陷。
- en: A drawback of this approach is that it rewards “just good enough” design. If
    the code can be written “just fast enough” or “just small enough,” further optimization
    is delayed until a later phase when it’s necessary. Similarly, testing is done
    only to a level sufficient to achieve a minimal amount of confidence in the code.
    Additional testing is considered a waste of time, money, and resources. The Spiral
    model often leads to compromises in the early work, particularly when it’s managed
    poorly, which leads to problems later in development.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是它奖励“刚刚足够好”的设计。如果代码能写得“足够快”或“足够小”，那么进一步的优化会被推迟到后期阶段，直到确有必要时才进行。类似地，测试只会进行到足以对代码有最低程度信心的程度。额外的测试被认为是浪费时间、金钱和资源。螺旋模型往往会导致在早期工作的妥协，尤其是当管理不善时，这种情况会导致开发后期出现问题。
- en: Another downside is that the Spiral model increases management complexity. This
    model is complex, so project management requires risk analysis experts. Finding
    managers and engineers with this expertise is difficult, and substituting someone
    without appropriate experience is usually a disaster.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是螺旋模型增加了管理的复杂性。这个模型本身很复杂，因此项目管理需要风险分析专家。寻找具备此类专业知识的经理和工程师很困难，且通常无法找到合适的替代人选会导致灾难性后果。
- en: The Spiral model is suitable only for large, risky projects. The effort (especially
    with respect to documentation) expended is hard to justify for low-risk projects.
    Even on larger projects, the Spiral model might cycle indefinitely, never producing
    the final product, or the budget might be completely consumed while development
    is still on an intermediate spiral.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型仅适用于大型、高风险项目。为低风险项目投入的工作量（尤其是在文档方面）是难以证明合理的。即便是在更大的项目中，螺旋模型可能会无限循环，最终产品迟迟无法产生，或者预算在开发仍处于中间阶段时已被完全消耗。
- en: Another concern is that engineers spend considerable time developing prototypes
    and other code needed for intermediate versions that don’t appear in the final
    software release, meaning the Spiral model often costs more than developing software
    with other methodologies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，工程师需要花费大量时间开发原型和其他中间版本的代码，而这些代码最终并不会出现在最终的软件版本中，这意味着螺旋模型通常比使用其他方法开发软件要花费更多。
- en: 'Nevertheless, the Spiral model offers some big advantages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，螺旋模型还是提供了一些巨大的优势：
- en: The requirements don’t need to be fully specified before the project starts;
    the model is ideal for projects with changing requirements.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目开始之前，不需要完全明确需求；螺旋模型非常适合需求不断变化的项目。
- en: It produces working code early in the development cycle.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在开发周期的早期就能产生可用的代码。
- en: It works extremely well with *rapid prototyping* (see the next section, “The
    Rapid Application Development Model”), affording customers and other stakeholders
    a good level of comfort with the application early in its development.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与*快速原型开发*（见下节“快速应用开发模型”）配合得非常好，能让客户和其他利益相关者在应用程序开发的早期就能感到安心。
- en: Development can be divided up and the riskier portions can be created early,
    reducing the overall development risk.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可以被分成若干部分，风险较大的部分可以提前完成，从而降低整体开发风险。
- en: Because requirements can be created as they’re discovered, they are more accurate.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需求可以在发现时就创建，因此更加准确。
- en: As in the Iterative model, functionality can be spread out over time, enabling
    the addition of new features as time/budget allows without impacting the initial
    release.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和迭代模型一样，功能可以随着时间的推移逐步展开，允许在时间或预算允许的情况下添加新功能，而不会影响初始版本的发布。
- en: '***3.2.6 The Rapid Application Development Model***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.6 快速应用开发模型***'
- en: Like the Spiral model, the Rapid Application Development (RAD) model emphasizes
    continuous interaction with users during development. Devised by James Martin,
    a researcher at IBM in the 1990s, the original RAD model divides software development
    into four phases (see [Figure 3-4](ch03.xhtml#ch3fig4)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与螺旋模型类似，快速应用开发（RAD）模型强调在开发过程中与用户的持续互动。RAD 模型由 IBM 的研究员 James Martin 在 1990 年代提出，最初的
    RAD 模型将软件开发分为四个阶段（见[图 3-4](ch03.xhtml#ch3fig4)）。
- en: '![image](Images/fig3-4.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-4.jpg)'
- en: '*Figure 3-4: The RAD model*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：RAD 模型*'
- en: '**Requirements planning** A project’s stakeholders come together to discuss
    business needs, scope, constraints, and system requirements.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求规划** 项目的相关方聚集在一起讨论业务需求、范围、限制和系统需求。'
- en: '**User** **design** End users interact with the development team to produce
    models and prototypes for the system (detailing inputs, outputs, and computations),
    typically using *computer-aided software engineering (CASE)* tools.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户** **设计** 终端用户与开发团队合作，制作系统模型和原型（详细说明输入、输出和计算），通常使用 *计算机辅助软件工程（CASE）* 工具。'
- en: '**Construction** The development team builds the software using tools to automatically
    generate code from the requirements and user design. Users remain involved during
    this phase, suggesting changes as the UI comes to life.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建** 开发团队利用工具从需求和用户设计中自动生成代码来构建软件。在此阶段，用户仍然参与其中，随着用户界面的逐步完善，他们会提出修改建议。'
- en: '**Cutover** The software is deployed.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换** 软件被部署。'
- en: RAD is more lightweight than Spiral, with fewer risk mitigation techniques and
    fairly light documentation needs, meaning it works well for small to medium-sized
    projects. Unlike other models, traditional RAD heavily depends on very-high-level
    languages (VHLLs), user interface modeling tools, complex libraries and frameworks
    of existing code, and CASE tools to automatically generate code from requirements
    and user interface models. In general, RAD is practical only when there are CASE
    tools available for the specific project problems. Today, many generic language
    systems support a high degree of automatic code generation, including Microsoft’s
    Visual Basic and Visual Studio packages, Apple’s Xcode/Interface Builder package,
    Free Pascal/Lazarus, and Embarcadero’s Delphi (Object Pascal) package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: RAD 比螺旋模型更轻量，风险缓解技术较少，文档需求也相对较轻，这使得它更适用于中小型项目。与其他模型不同，传统的 RAD 强烈依赖于高级语言（VHLL）、用户界面建模工具、复杂的现有代码库和框架，以及
    CASE 工具来根据需求和用户界面模型自动生成代码。一般来说，RAD 只有在针对特定项目问题可用 CASE 工具时才实际可行。今天，许多通用语言系统都支持高度自动化的代码生成，包括微软的
    Visual Basic 和 Visual Studio 包、苹果的 Xcode/Interface Builder 包、Free Pascal/Lazarus
    以及 Embarcadero 的 Delphi（Object Pascal）包。
- en: 'The advantages of the RAD model are similar to those of the Spiral model:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RAD 模型的优点与螺旋模型类似：
- en: The customer is involved with the product throughout development, resulting
    in less risk.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户在整个开发过程中都参与其中，从而降低了风险。
- en: RAD reduces development time because less time is spent writing documentation
    that must be rewritten later when the specifications inevitably change.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 缩短了开发时间，因为写文档的时间减少了，避免了文档在规格变更时需要重新编写的情况。
- en: The RAD model encourages the fast delivery of working code, and testing (and
    defect mitigation) is more efficient. Developers spend more time running the code,
    testing for problems.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 模型鼓励快速交付可运行的代码，测试（和缺陷缓解）也更加高效。开发人员将更多时间花在运行代码上，测试问题。
- en: 'Like any development model, RAD has some disadvantages as well:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何开发模型一样，RAD 也有一些缺点：
- en: RAD requires Grand Master–level software engineers who have the experience to
    short-circuit much of the heavyweight development process found in other models.
    Such resources are scarce in many organizations.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 需要具备大宗师级别的开发经验的软件工程师，他们能够缩短其他开发模型中冗长的开发过程。然而，这类资源在许多组织中比较稀缺。
- en: RAD requires continuous interaction with end users, which may be limited on
    many projects.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 需要与终端用户持续互动，这在许多项目中可能会受到限制。
- en: RAD may be difficult to schedule and control. Managers who live and die by Microsoft
    Project will find it difficult to deal with the uncertainties in the RAD model.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 可能很难进行调度和控制。那些依赖 Microsoft Project 的经理会发现很难应对 RAD 模型中的不确定性。
- en: Unless carefully managed, RAD can rapidly devolve into hacking. Software engineers
    might forgo formal design methodologies and just hack away at the code to make
    changes. This can be especially troublesome when end users start making suggestions
    “just to see what the result will look like.”^([4](ch19_footnote.xhtml#ch03fn4))
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管理不当，RAD 很容易变成拼凑式编程。软件工程师可能会放弃正式的设计方法，而直接在代码上“乱改”以实现更改。当最终用户开始提出“只是为了看看结果会是什么样”这样的建议时，这种情况尤为棘手^([4](ch19_footnote.xhtml#ch03fn4))。
- en: RAD doesn’t work well for large system development.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 不适用于大型系统开发。
- en: '***3.2.7 The Incremental Model***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.7 增量模型***'
- en: The Incremental model is very similar to the Iterative model, with the main
    difference being in planning and design. In the Iterative model, the system design
    is created first and software engineers implement various pieces at each iteration;
    the initial design defines only the first piece of working code. Once the program
    is running, new features are designed and added incrementally.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 增量模型与迭代模型非常相似，主要的区别在于规划和设计。在迭代模型中，首先创建系统设计，软件工程师在每次迭代中实现不同的部分；初始设计仅定义第一段工作代码。一旦程序运行，新功能会按阶段逐步设计并添加。
- en: The Incremental model emphasizes the “keep the code working” concept. When a
    base product is operational, the development team adds a minimal amount of new
    functionality at each iteration, and the software is tested and kept functional.
    By limiting new features, the team can more easily locate and solve development
    problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 增量模型强调“保持代码可运行”的理念。当基础产品可操作时，开发团队在每次迭代中添加最少量的新功能，并对软件进行测试并保持其可用性。通过限制新功能，团队可以更容易地定位和解决开发中的问题。
- en: The advantage of the Incremental model is that you always maintain a working
    product. The model also comes naturally to programmers, especially on small projects.
    The disadvantage is that it doesn’t consider the product’s full design in the
    beginning. Often, new features are simply hacked on to the existing design. This
    could result in problems down the road when end users request features that were
    never considered in the original design. The Incremental model is sufficient for
    small projects but doesn’t scale well to large projects, where the Iterative model
    might be a better choice.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 增量模型的优点是始终保持一个可工作的产品。该模型对程序员来说也很自然，特别是在小型项目中。缺点是，它一开始并没有考虑到产品的完整设计。通常，新的功能只是简单地加在现有设计上。当最终用户请求在原始设计中未考虑到的功能时，这可能会导致未来的问题。增量模型适用于小型项目，但对于大型项目而言，扩展性较差，此时迭代模型可能是更好的选择。
- en: '**3.3 Software Development Methodologies**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.3 软件开发方法论**'
- en: A software development model describes *what* work is done but leaves considerable
    leeway as to *how* it is done. This section looks at some development methodologies
    and processes you can apply to many of the models just discussed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发模型描述了*做什么*工作，但在*如何*做的方面留有相当大的余地。本节将介绍一些可以应用于许多前面提到的模型的开发方法论和过程。
- en: 'The Belitsoft company blog^([5](ch19_footnote.xhtml#ch03fn5)) describes software
    methodology as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Belitsoft 公司博客^([5](ch19_footnote.xhtml#ch03fn5))描述了软件方法论如下：
- en: A system of principles, as well as a set of ideas, concepts, methods, techniques,
    and tools that define the style of software development.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一套原则体系，以及一组定义软件开发风格的理念、概念、方法、技术和工具。
- en: 'Thus, we can reduce the concept of software methodology to one word: *style*.
    There are various styles you can use when developing software.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将软件方法论的概念归结为一个词：*风格*。在开发软件时，可以使用各种风格。
- en: '***3.3.1 Traditional (Predictive) Methodologies***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.1 传统（预测型）方法论***'
- en: The traditional methodology is *predictive*, meaning that management predicts
    which activities will take place, when they will take place, and who will do them.
    These methodologies work hand in hand with linear/sequential development models,
    like the Waterfall or V model. You could use prediction with other models, but
    those are designed to purposely avoid the problems that predictive methodologies
    are prone to.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Predictive methodologies fail when it’s impossible to predict changes in future
    requirements, key personnel, or economic conditions (for example, did the company
    receive the expected additional financing at some milestone in the project?).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.2 Adaptive Methodologies***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Spiral, RAD, Incremental, and Iterative models came about specifically because
    it’s usually difficult to correctly predict requirements for a large software
    system. Adaptive methodologies handle these unpredictable changes in the workflow
    and emphasize short-term planning. After all, if you’re planning only 30 days
    in advance on a large project, the worst that can happen is you have to replan
    for the next 30 days; this is nowhere near the disaster you’d face in the middle
    of a large Waterfall/Predictive-based project, when a change would force you to
    resync the entire project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.3 Agile***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Agile is an incremental methodology that focuses on customer collaboration,
    short development iterations that respond to changes quickly, working software,
    and support for individuals’ contributions and interactions. The Agile methodology
    was created as an umbrella to cover several different “lightweight” (that is,
    nonpredictive) methodologies, including Extreme Programming, Scrum, Dynamic System
    Development Model (DSDM), Adaptive Software Development (ASD), Crystal, Feature-Driven
    Development (FDD), Pragmatic Programming, and others. Most of these methodologies
    are considered “Agile,” although they often cover different aspects of the software
    development process. Agile has largely proven itself on real-world projects, making
    it one of the currently most popular methodologies, so we’ll dedicate a fair amount
    of space to it here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '*For a detailed list of the principles behind Agile, see the Agile Manifesto
    at [http://agilemanifesto.org/](http://agilemanifesto.org/)*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3.1 Agile Is Incremental in Nature**'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Agile development is incremental, iterative, and evolutionary in nature, and
    so works best with Incremental or Iterative models (using Spiral or RAD is also
    possible). A project is broken down into tasks that a team can complete in one
    to four weeks, which is often called a *sprint*. During each sprint, the development
    team plans, creates requirements, designs, codes, unit-tests, and acceptance-tests
    the software with the new features.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the sprint, the deliverable is a working piece of software that
    demonstrates the new functionality with as few defects as possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3.2 Agile Requires Face-to-Face Communication**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Throughout the sprint, a customer representative must be available to answer
    questions that arise. Without this, the development process can easily veer off
    in the wrong direction or get bogged down while the team waits for responses.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Efficient communication in Agile requires a face-to-face conversation.^([6](ch19_footnote.xhtml#ch03fn6))
    When a developer demonstrates a product directly to the customer, that customer
    often raises questions that would never come up in an email or if they’d just
    tried the feature on their own. Sometimes, offhand remarks in a demo can result
    in a burst of divergent thinking that would never happen if the conversation weren’t
    in person.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3.3 Agile Is Focused on Quality**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Agile emphasizes various quality-enhancing techniques, such as automated unit
    testing, TDD, design patterns, pair programming, code refactoring, and other well-known
    best software practices. The idea is to produce code with as few defects as possible
    (during initial design and coding).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '*Automated unit testing* creates a test framework that a developer can automatically
    run to verify that the software runs correctly. It’s also important for *regression
    testing*, which tests to ensure the code still works properly after new features
    have been added. Manually running regression tests is too labor-intensive, so
    it generally won’t happen.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, developers write automated tests prior to writing the code, which means
    that the test will initially fail. The developer runs the tests, picks a test
    that fails, writes the software to fix that failure, and then reruns the tests.
    As soon as a test succeeds, the developer moves on to the next failing test. Successfully
    eliminating all the failed tests verifies that the software meets the requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*Pair programming*, one of Agile’s more controversial practices, involves two
    programmers working on each section of code together. One programmer enters the
    code while the other watches, catching mistakes onscreen, offering design tips,
    providing quality control, and keeping the first programmer focused on the project.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3.4 Agile Sprints (Iterations) Are Short**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Agile methodologies work best when the iterations are short—from one week to
    (at most) a couple of months. This is a nod to the old adage “If it weren’t for
    the last minute, nothing would ever get done.” By keeping iterations short, software
    engineers are always working during the last minute, reducing fatigue and procrastination
    and increasing project focus.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Hand in hand with short sprints are short feedback cycles. A common Agile feature
    is a brief daily stand-up meeting, typically no more than 15 minutes,^([7](ch19_footnote.xhtml#ch03fn7))
    where programmers concisely describe what they’re working on, what they’re stuck
    on, and what they’ve finished. This allows project management to rearrange resources
    and provide help if the schedule is slipping. The meetings catch any problems
    early rather than wasting several weeks before the issue comes to project management’s
    attention.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3.5 Agile Deemphasizes Heavyweight Documentation**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One of the Waterfall model’s biggest problems is that it produces reams of
    documentation that is never again read. Overly comprehensive, *heavyweight* documentation
    has a few problems:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Documentation must be maintained. Whenever a change is made in the software,
    the documentation must be updated. Changes in one document have to be reflected
    in many other documents, increasing workload.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many documents are difficult to write prior to the code. More often than not,
    such documents are updated after the code is written and then never read again
    (a waste of time and money).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterative development process quickly destroys coherence between code and
    documentation. Therefore, properly maintaining the documentation at each iteration
    doesn’t fit well with the Agile methodology.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile emphasizes *just barely good enough (JBGE)* documentation—that is, enough
    documentation so the next programmer can pick up where you left off, but no more
    (in fact, Agile emphasizes JBGE for most concepts, including design/modeling).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Many books have been written on Agile development (see “[For More Information](ch03.xhtml#lev-3.5)”
    on [page 69](ch03.xhtml#page_69)). This is not one of them, but we’ll look at
    a couple of the different methodologies under the Agile umbrella. These methodologies
    are not mutually exclusive; two or more can be combined and used on the same project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.4 Extreme Programming***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extreme Programming (XP) is perhaps the most widely used Agile methodology.
    It aims to streamline development practices and processes to deliver working software
    that provides the desired feature set without unnecessary extras.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'XP is guided by five values:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication** Good communication between the customer and the team, among
    team members, and between the team and management is essential for success.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity** XP strives to produce the simplest system today, even if it
    costs more to extend it tomorrow, rather than producing a complicated product
    that implements features that might never be used.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Feedback** XP depends upon continuous feedback: unit and functional tests
    provide programmers with feedback when they make changes to their code; the customer
    provides immediate feedback when a new feature is added; and project management
    tracks the development schedule, providing feedback about estimates.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Respect** XP requires that team members respect one another. A programmer
    will never commit a change to the code base that breaks the compilation or existing
    unit tests (or do anything else that will delay the work of other team members).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Courage** XP’s rules and practices don’t line up with traditional software
    development practices. XP requires the commitment of resources (such as an “always
    available” customer representative or pair programmers) that can be expensive
    or difficult to justify in older methodologies. Some XP policies like “refactor
    early, refactor often” run counter to common practice such as “if it ain’t broke,
    don’t fix it.” Without the courage to fully implement its extreme policies, XP
    becomes less disciplined and can devolve into hacking.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.1 The XP Team**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Paramount to the XP process is the XP *whole team* concept: all members of
    the team work together to produce the final product. Team members are not specialists
    in one field, but often take on different responsibilities or roles, and different
    team members might perform the same role at different times. An XP team fills
    the following roles with various team members.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**A customer representative**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The customer representative is responsible for keeping the project on the right
    track, providing validation, writing *user stories* (requirements, features, and
    use cases) and *functional tests*, and deciding the *priorities* (release planning)
    for new functionality. The customer representative must be available whenever
    the team needs them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Not having an available customer representative is one of the largest impediments
    to successful XP projects. Without continuous feedback and direction from the
    customer, XP degenerates into hacking. XP doesn’t rely on requirements documentation;
    instead, the representative is a “living version” of that documentation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmers**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers have several responsibilities on an XP team: working with the customer
    representative to produce user stories, estimating how resources should be allocated
    for those stories, estimating timelines and costs to implement stories, writing
    unit tests, and writing the code to implement the stories.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Testers**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Testers (programmers who implement or modify a given unit run unit tests) run
    the functional tests. Often, at least one of the testers is the customer representative.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Coach**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The coach is the team leader, typically the lead programmer, whose job is to
    make sure the project succeeds. The coach ensures the team has the appropriate
    work environment; fosters good communication; shields the team from the rest of
    the organization by, for example, acting as a liaison to upper management; helps
    team members maintain self-discipline; and ensures the team maintains the XP process.
    When a programmer is having difficulty, coaches provide resources to help them
    overcome the problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Manager/tracker**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The XP project manager is responsible for scheduling meetings and recording
    their results. The tracker is often, but not always, the same as the manager,
    and is responsible for tracking the project’s progress and determining whether
    the current iteration’s schedule can be met. To do so, the tracker checks with
    each programmer a couple of times a week.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Different XP configurations often include additional team roles, such as analysts,
    designers, doomsayers, and so on. Because of the small size of XP teams (typically
    around 15 members) and the fact that (paired) programmers constitute the majority
    of the team, most roles are shared. See “[For More Information](ch03.xhtml#lev-3.5)”
    on [page 69](ch03.xhtml#page_69) for additional references.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.2 XP Software Development Activities**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'XP uses four basic software development activities: coding, testing, listening,
    and designing.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**Coding**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: XP considers code to be the *only* important output of the development process.
    Contrary to the “think first, code later” philosophy of serial models like Waterfall,
    XP programmers start writing code at the beginning of the software development
    cycle. After all, “at the end of the day, there has to be a working program.”^([8](ch19_footnote.xhtml#ch03fn8))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: XP programmers don’t immediately start coding, but are given a list of small
    and simple features to implement. They work on a basic design for a particular
    feature and then code that feature and make sure it’s working before expanding
    in increments, with each increment working correctly to ensure that the main body
    of code is always running. Programmers make only small changes to the project
    before integrating those changes into the larger system. XP minimizes all noncode
    output, such as documentation, because there is very little benefit to it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'XP emphasizes TDD using automated unit and functional tests. This allows XP
    engineers to develop the *product right* (verification via automated unit tests)
    and develop the *right product* (validation via functional tests). *WGC6: Testing,
    Debugging, and Quality Assurance* will deal more exclusively with testing, so
    we won’t go too far into it here; just know that TDD is very important to the
    XP process because it ensures that the system is always working.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Testing in XP is always automated. If adding one feature breaks an unrelated
    feature for some reason, it’s critical to immediately catch that. By running a
    full set of unit (and functional) tests when adding a new feature, you can ensure
    that your new code doesn’t cause a regression.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: XP developers communicate almost constantly with their customers to ensure they’re
    developing the right product (validation).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: XP is a *change-driven process*, meaning it expects changes in requirements,
    resources, technology, and performance, based on feedback from customers as they
    test the product throughout the process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Designing**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Design occurs constantly throughout the XP process—during release planning,
    iteration planning, refactoring, and so on. This focus prevents XP from devolving
    into hacking.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.3 The XP Process**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each cycle of XP produces a software *release*. Frequent releases ensure constant
    feedback from the customer. Each cycle consists of a couple of fixed-period blocks
    of time known as iterations (with no more than a couple of weeks for each iteration).
    Cycles, as shown in [Figure 3-5](ch03.xhtml#ch3fig5), are necessary for planning;
    the middle box in this figure represents one or more iterations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig3-5.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: An XP cycle*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the planning game, the XP team decides which features to implement, estimates
    their costs, and plans the release. During the exploration step, the customer
    defines the feature set and developers estimate costs and time requirements for
    those features. The next section (under “User stories”) describes the mechanism
    customers use to specify features.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: During release planning, the customer negotiates with the developers on the
    features to implement in the given iteration. The developers commit to the release
    plan, and engineers are assigned various tasks. At the end of release planning,
    the process enters the *steering* phase, during which the customer ensures that
    the project remains on track.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'After the overall plan is determined, the process for the current release enters
    an inner loop consisting of three steps: iteration planning, implementation, and
    functional testing. Iteration planning is the planning game scaled down for a
    single feature.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The implementation step is the coding and unit testing of the feature. The developer
    writes a set of unit tests, implements just enough code to make the unit tests
    succeed, refactors the code as necessary, and integrates the changes into the
    common code base.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: During the last step of the iteration, customers perform functional testing.
    Then the process repeats for the next iteration, or a release is produced if all
    iterations are completed for the current release.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.4 XP Software Development Rules**'
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: XP implements the four software development activities—coding, testing, listening,
    and designing—using 12 simple rules:^([9](ch19_footnote.xhtml#ch03fn9))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: User stories (planning game)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small releases (building blocks)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaphors (standardized naming schemes)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collective ownership
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding standard
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple design
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pair programming
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onsite customer
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sustainable pace
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each rule is described next, along with its advantages and disadvantages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**User stories**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: User stories describe a simplified set of use cases, written by the customer,
    that define the system’s requirements. The project team uses this set, which should
    provide only enough detail to estimate how long it will take to implement the
    feature, to estimate the cost and plan the system’s development.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of a project, the customer generates 50 to 100 user stories
    to use during a release planning session. Then the customer and the team negotiate
    which features the team will implement in the next release. The customer, possibly
    with help from a developer, also creates functional tests from the user stories.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**Small releases**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Once a piece of software is functional, the team adds one feature at a time.
    Other features are not added until that new feature is written, tested, debugged,
    and incorporated into the main build. The team creates a new build of the system
    for each feature it adds.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**Metaphors**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: XP projects revolve around a story about the system’s operation that all stakeholders
    can understand. Metaphors are naming conventions used within the software to ensure
    that operations are obvious to everyone; they replace a complex business process
    name with a simple name. For example, “train conductor” might describe how a data
    acquisition system operates.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Collective ownership**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In XP, the entire team owns and maintains all source code. At any time, any
    team member can check out code and modify it. During reviews, no one is singled
    out for coding mistakes. Collective code ownership prevents delays and means one
    person’s absence doesn’t hinder progress.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '**Coding standard**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: All XP members must adhere to common coding standards concerning styles and
    formats. The team can develop the standards or they can come from an outside source,
    but everyone must follow them. Coding standards make the system easier to read
    and understand, especially for newcomers getting up to speed with the project,
    and help the team avoid having to waste time later refactoring the code to bring
    it into compliance.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple design**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The simplest design that meets all the requirements is always chosen. At no
    time does the design anticipate features that have yet to be added—for example,
    adding “hooks” or application programming interfaces (APIs) that allow future
    code to interface with the current code. Simple design means *just enough to get
    the current job done*. The simplest code will pass all the tests for the current
    iteration. This runs counter to traditional software engineering, where software
    is designed as generically as possible to handle any future enhancements.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code is the process of restructuring or rewriting the code without
    changing its external behavior, to make the code simpler, more readable, or better
    by some other improvement metric.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*WGC5: Great Coding* will go into refactoring in much greater detail. See “[For
    More Information](ch03.xhtml#lev-3.5)” on [page 69](ch03.xhtml#page_69) for additional
    references on refactoring.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: XP uses a TDD methodology, as discussed in “XP Software Development Activities”
    on [page 57](ch03.xhtml#page_57).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '**Pair programming**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In pair programming, one programmer (the *driver*) enters code, and the second
    programmer (the *navigator*) reviews each line of code as it’s written. The two
    engineers change roles throughout and pairs are often created and broken apart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: It’s often difficult to convince management that two programmers working together
    on the same code are more productive than they are working separately on different
    pieces of code. XP evangelists argue that because the navigator is constantly
    reviewing the driver’s code, a separate review session isn’t needed, among other
    benefits:^([10](ch19_footnote.xhtml#ch03fn10))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Economic benefits** Pairs spend about 15 percent more time on programs than
    individuals, but the code has 15 percent fewer defects.^([11](ch19_footnote.xhtml#ch03fn11))'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**Design quality** Two programmers produce a better design because they bring
    more experiences to the project. They think about the problem in different ways,
    and they devise the solution differently based on their driver/navigator roles.
    A better design means the project requires less backtracking and redesign throughout
    its life cycle.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Satisfaction** A majority of programmers enjoy working in pairs rather than
    alone. They feel more confident in their work and, as a result, produce better
    code.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning** Pair programming allows pair members to learn from each other,
    increasing their respective skills. This cannot happen in solo programming.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**Team building and communication** Team members share problems and solutions,
    which helps spread the intellectual property (IP) around and makes it easier for
    others to work on a given code section.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the research on the effectiveness of pair programming is a mixed bag.
    Most published papers from industry sources talk about how well pair programming
    has worked, but papers describing its failure in industry (versus academic) settings
    generally don’t get published. Research by Kim Man Lui and Andreas Hofer considers
    three types of pairings in pair programming: expert–expert, novice–novice, and
    expert–novice.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '*Expert–expert pairing* can produce effective results, but two expert programmers
    are likely to use “tried and true” methods without introducing any new insight,
    meaning the effectiveness of this pairing versus two solo expert programmers is
    questionable.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*Novice–novice pairing* is often more effective than having the partners work
    on solo projects. Novices will have greatly varying backgrounds and experiences,
    and their knowledge is more likely to be complementary than overlapping (as is
    the case for expert pairs). Two novices working together are likely to work faster
    on two projects serially rather than they would working independently on their
    own project in parallel.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '*Expert–novice pairing* is commonly called *mentoring*. Many XP adherents don’t
    consider this to be pair programming, but mentoring is an efficient way to get
    a junior programmer up to speed with the code base. In mentoring, it’s best to
    have the novice act as the driver so they can interact with and learn from the
    code.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: GUIDELINES FOR SIMPLE DESIGN
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Common phrases associated with simple design include:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t repeat yourself (DRY)** Duplicate code is complex code.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Once and only once (OAOO)** All unique functionality should exist as some
    method/procedure in the code and appear only once in the code (this last point
    is DRY).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**You aren’t gonna need it (YAGNI)** Avoid speculative coding. When adding
    a feature to your code base, make sure it’s specified by a user story (requirement).
    Don’t add code in anticipation of future requirements.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**Limit APIs and (published) interfaces** If your code interfaces with other
    systems by publishing an API, limiting the number of interfaces to the bare minimum
    will make it easier to modify your code in the future (without breaking external
    code).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple design is amazingly difficult to achieve. More often than not, you accomplish
    it only by writing complex code and then refactoring it repeatedly until you’re
    happy with the result. A few quotes from some famous computer scientists will
    help drive this point home:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of constructing a software design: one way is to make it
    so simple that there are obviously no deficiencies, and the other way is to make
    it so complicated that there are no obvious deficiencies.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: —C. A. R. Hoare
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The cheapest, fastest, and most reliable components are those that aren’t there.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: —Gordon Bell
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Deleted code is debugged code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: —Jeff Sickle
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is twice as hard as writing the code in the first place. Therefore,
    if you write the code as cleverly as possible, you are, by definition, not smart
    enough to debug it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: —Brian Kernighan and P. J. Plauger
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Any program that tries to be so generalized and configurable that it could handle
    any kind of task will either fall short of this goal or will be horribly broken.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: —Chris Wenham
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The cost of adding a feature isn’t just the time it takes to code it. The cost
    also includes the addition of an obstacle to future expansion. The trick is to
    pick the features that don’t fight each other.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: —John Carmack
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity is hard to build, easy to use, and hard to charge for. Complexity
    is easy to build, hard to use, and easy to charge for.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: —Chris Sacca
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Though supporting evidence for pair programming is anecdotal and essentially
    unproven, XP depends on pair programming to replace formal code reviews, structured
    walk-throughs, and—to a limited extent—design documentation, so it can’t be forgone.
    As is common in the XP methodology, certain heavyweight processes like code reviews
    are often folded into other activities like pair programming. Trying to eliminate
    one rule or subprocess will likely open a gap in the overall methodology.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Not all XP activities are done in pairs. Many nonprogramming activities are
    done solo—for example, reading (and writing) documentation, dealing with emails,
    and doing research on the web—and some are always done solo, like writing *code
    spikes* (throwaway code needed to test a theory or idea). Ultimately, *pair programming
    is essential for successful XP ventures*. If a team cannot handle pair programming
    well, it should use a different development methodology.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Onsite customer**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: As noted many times previously, in XP the customer is part of the development
    team and must be available at all times.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The onsite customer rule is probably the most difficult to follow. Most customers
    aren’t willing or able to provide this resource. However, without the continuous
    availability of a customer representative, the software could go off track, encounter
    delays, or regress from previous working versions. These problems are all solvable,
    but their solution destroys the benefits of using XP.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional software development system like Waterfall, individual components
    of the system, written by different developers, are not tested together until
    some big milestone in the project, and the integrated software may fail spectacularly.
    The problem is that the unit tests don’t behave the same as the code that must
    be integrated with the units, typically due to communication problems or misunderstood
    requirements.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: There will always be miscommunication and misunderstandings, but XP makes integration
    problems easier to solve via *continuous integration*. As soon as a new feature
    is implemented, it’s merged with the main build and tested. Some tests might fail
    because a feature has not yet been implemented, but the entire program is run,
    testing linkages with other units in the application. Software builds are created
    frequently (several times per day). As a result, you’ll discover integration problems
    early when they’re less costly to correct.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '**Sustainable pace**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Numerous studies show that creative people produce their best results when they’re
    not overworked. XP dictates a 40-hour workweek for software engineers. Sometimes
    a crisis might arise that requires a small amount of overtime. But if management
    keeps its programming team in constant crisis mode, the quality of the work suffers
    and the overtime becomes counterproductive.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.5 Other Common Practices**'
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In addition to the previous 12 rules, XP promotes several other common practices:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**Open workspace and collocation**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The XP methodology suggests open work areas for the entire team, who work in
    pairs at adjacent workstations. Having everyone together promotes constant communication
    and keeps the team focused.^([12](ch19_footnote.xhtml#ch03fn12)) Questions can
    be quickly asked and answered, and other programmers can inject comments into
    a discussion as appropriate.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: But open workspaces have their challenges. Some people are more easily distracted
    than others. Loud noise and conversations can be very annoying and break concentration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Open workspaces are a “best practice” in XP, not an absolute rule. If this setup
    doesn’t work for a particular pair, they can use an office or cubicle and work
    without distractions.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrospectives/debriefings**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: When a project is complete, the team meets to discuss the successes and failures,
    disseminating the information to help improve the next project.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-directed teams**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: A self-directed team works on a project without the usual managerial levels
    (project leads, senior and junior level engineers, and so forth). The team makes
    decisions on priorities by consensus. XP teams aren’t completely unmanaged, but
    the idea here is that given a set of tasks and appropriate deadlines, the team
    can manage the task assignments and project progress on its own.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.6 Problems with XP**'
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'XP is not a panacea. There are several problems with it, including:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Detailed specifications aren’t created or preserved. This makes it difficult
    to add new programmers later in the project or for a separate programming team
    to maintain the project.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pair programming is required, even if it doesn’t work. In some cases, it can
    be overkill. Having two programmers work on a relatively simple piece of code
    can double your development costs.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be practical, XP typically requires that all team members be GMPs in order
    to handle the wide range of roles each member must support. This is rarely achievable
    in real life, except on the smallest of projects.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant refactoring can introduce as many problems (new bugs) as it solves.
    It can also waste time when programmers refactor code that doesn’t need it.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No Big Design Up Front (that is, non-Waterfall-like development) often leads
    to excessive redesign.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer representative is necessary. Often, the customer will assign a junior-level
    person to this position because of the perceived costs, resulting in a failure
    point. If the customer representative leaves before the project is complete, all
    the requirements that aren’t written down are lost.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XP is not scalable to large teams. The limit for a productive XP team is approximately
    a dozen engineers.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XP is especially susceptible to “feature creep.” The customer can inject new
    features into the system due to a lack of documented requirements/features.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests, even those created by XP programmers, often fail to point out missing
    features. Unit tests test “the code that is present,” not “the code that *should*
    be present.”
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XP is generally considered an “all or nothing” methodology: if you don’t follow
    every tenet of the “XP religion,” the process fails. Most XP rules have weaknesses
    that are covered by the strengths of other rules. If you fail to apply one rule,
    another rule will likely break (because its weaknesses are no longer covered,
    and that broken rule will break another, ad nauseam).'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This small introduction to XP cannot do the topic justice. For more information
    on XP, see “[For More Information](ch03.xhtml#lev-3.5)” on [page 69](ch03.xhtml#page_69).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.5 Scrum***'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Scrum methodology is not a software development methodology per se, but
    an Agile mechanism for *managing* the software development process. More often
    than not, Scrum is used to manage some other model such as XP.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond engineers, a Scrum team has two special members: the product owner and
    the scrum master. The *product owner* is responsible for guiding the team toward
    building the right product by, for example, maintaining requirements and features.
    The *scrum master* is a coach who guides the team members through the Scrum-based
    development process, managing team progress, maintaining lists of projects, and
    ensuring team members aren’t held up.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Scrum is an iterative development process like all other Agile methodologies,
    and each iteration is a one- to four-week sprint. A sprint begins with a planning
    meeting where the team determines the work to be done. A list of items known as
    a *backlog* is assembled, and the team estimates how much time is required for
    each item on the backlog. Once the backlog is created, the sprint can begin.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Each day the team has a short stand-up meeting during which the members briefly
    mention yesterday’s progress and their plans for today. The scrum master notes
    any progress problems and deals with them after the meeting. No detailed discussions
    about the project take place during the stand-up meeting.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Team members pick items from the backlog and work on those items. As items are
    removed from the backlog, the scrum master maintains a Scrum *burn-down chart*
    that shows the current sprint’s progress. When all the items have been implemented
    to the product owner’s satisfaction, or the team determines that some items cannot
    be finished on time or at all, the team holds an *end meeting*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: At the end meeting, the team demonstrates the features that were implemented
    and explains the failures of the items not completed. If possible, the scrum master
    collects unfinished items for the next sprint.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Also part of the end meeting is the sprint *retrospective*, where team members
    discuss their progress, suggest process improvements, and determine what went
    well and what went wrong.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Note that Scrum doesn’t dictate how the engineers perform their jobs or how
    the tasks are documented, and doesn’t provide a set of rules or best practices
    to follow during development. Scrum leaves these decisions to the development
    team. Many teams, for example, employ the XP methodology under Scrum. Any methodology
    compatible with iterative development will work fine.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Like XP, Scrum works well with small teams fewer than a dozen members and fails
    to scale to larger teams. Some extensions to Scrum have been made to support larger
    teams. Specifically, a “scrum-of-scrums” process allows multiple teams to apply
    a Scrum methodology to a large project. The large project is broken down into
    multiple teams, and then an ambassador from each team is sent to the daily scrum-of-scrums
    meeting to discuss their progress. This doesn’t solve all the communication problems
    of a large team, but it does extend the methodology to work for slightly larger
    projects.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.6 Feature-Driven Development***'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Feature-driven development, one of the more interesting methodologies under
    the Agile umbrella, is specifically designed to scale up to large projects.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: One common thread among most Agile methodologies is that they require expert
    programmers in order to succeed. FDD, on the other hand, allows for large teams
    where it is logistically impossible to ensure you have the best person working
    on every activity of the project, and is worth serious consideration on projects
    involving more than a dozen software engineers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'FDD uses an iterative model. Three processes take place at the beginning of
    the project (often called *iteration zero*), and then the remaining two processes
    are iteratively carried out for the duration of the project. These processes are
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Develop an overall model.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a features list.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plan by feature.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design by feature.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build by feature.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3.3.6.1 Develop an Overall Model**'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Developing an overall model is a collaborative effort between all the stake­holders—clients,
    architects, and developers—where all team members work together to understand
    the system. Unlike the specifications and design documents in the serial methods,
    the overall model concentrates on breadth rather than depth to fill in as many
    generalized features as possible to define the entire project, and then fill in
    the depth of the model design’s future iterations, with the purpose of guiding
    the current project, not documenting it for the future.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach versus other Agile approaches is that most features
    are planned from the beginning of the project. Therefore, the design can’t take
    off in a direction that makes certain features difficult or impossible to add
    at a later date, and new features cannot be added in an ad hoc fashion.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.6.2 Build a Features List**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: During the second step of FDD, the team documents the feature list devised in
    the model development step, which is then formalized by the chief programmer for
    use during design and development. The output of this process is a formal features
    document. Although not as heavyweight as the SRS document found in other models,
    the feature descriptions are formal and unambiguous.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.6.3 Plan by Feature**'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The plan-by-feature process involves creating an initial schedule for the software
    development that dictates which features will be implemented initially and which
    features will be implemented on successive iterations.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Plan by feature also assigns sets of features to various chief programmers
    who, along with their teams, are responsible for implementing them. The chief
    programmer and associated team members take ownership of these features and the
    associated code. This deviates somewhat from standard Agile practice, where the
    entire team owns the code. This is one of the reasons FDD works better for large
    projects than standard Agile processes: collective code ownership doesn’t scale
    well to large projects.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: As a rule, each feature is a small task that a three- to five-person team can
    develop in two or three weeks (and, more often, just days). Each feature class
    is independent of the others, so no feature depends on the development of features
    in classes owned by other teams.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.6.4 Design by Feature**'
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the features for a given iteration are selected, the chief programmer who
    owns each feature set forms a team to design the feature. Feature teams are not
    static; they’re formed and disbanded for each iteration of the design-by-feature
    and build-by-feature processes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The feature team analyzes the requirements and designs the feature(s) for the
    current iteration. The teams decide on that feature’s implementation and its interaction
    with the rest of the system. If the feature is far-reaching, the chief programmer
    might involve other feature class owners to avoid conflicts with other feature
    sets.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: During the design phase, the feature teams decide on the algorithms and processes
    to use, and develop and document tests for the features. If necessary, the chief
    programmer (along with the original set of stakeholders) updates the overall model
    to reflect the design.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.6.5 Build by Feature**'
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The build-by-feature step involves coding and testing the feature. The developers
    unit-test their code and feature teams provide formal system testing of the features.
    FDD doesn’t mandate TDD, but it does insist that all features added to the system
    be tested and reviewed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: FDD requires code reviews (a best practice, but not required by most Agile processes).
    As Steve McConnell points out in *Code Complete* (Microsoft Press, 2004), well-executed
    code inspections uncover many defects that testing alone will never find.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**3.4 Models and Methodologies for the Great Programmer**'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great programmer should be capable of adapting to any software development
    model or methodology in use by their team. That said, some models are more appropriate
    than others. If you’re given the choice of model, this chapter should guide you
    in choosing an appropriate one.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: No methodology is scalable up *or down*, so you’ll need to choose a suitable
    model and methodology based on the project size. For tiny projects, hacking or
    a documentation-less version of the Waterfall model is probably a good choice.
    For medium-sized projects, one of the iterative (Agile) models and methodologies
    is best. For large projects, the sequential models or FDD are the most successful
    (although often quite expensive).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, you won’t get to choose the developmental models for projects
    you work on unless they’re your personal projects. The key is to become familiar
    with the various models so you’re comfortable with any model you’re asked to use.
    The following section provides some resources for learning more about the different
    software development models and methodologies this chapter describes. As always,
    an internet search will provide considerable information on software development
    models and methodologies.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5 For More Information**'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Astels, David R. *Test-Driven Development: A Practical Guide*. Upper Saddle
    River, NJ: Pearson Education, 2003.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Beck, Kent. *Test-Driven Development by Example.* Boston: Addison-Wesley Professional,
    2002.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Beck, Kent, with Cynthia Andres. *Extreme Programming Explained: Embrace Change*.
    2nd ed*.* Boston: Addison-Wesley, 2004.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Boehm, Barry. *Spiral Development: Experience, Principles, and Refinements*.
    (Special Report CMU/SEI-2000-SR-008.) Edited by Wilfred J. Hansen. Pittsburgh:
    Carnegie Mellon Software Engineering Institute, 2000.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Fowler, Martin. *Refactoring: Improving the Design of Existing Code*. Reading,
    MA: Addison-Wesley, 1999.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Kerievsky, Joshua. *Refactoring to Patterns*. Boston: Addison-Wesley, 2004.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Martin, James. *Rapid Application Development*. Indianapolis: Macmillan, 1991.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Martin, Robert C. *Agile Software Development, Principles, Patterns, and Practices*.
    Upper Saddle River, NJ: Pearson Education, 2003.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'McConnell, Steve. *Code Complete*. 2nd ed. Redmond, WA: Microsoft Press, 2004.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '———. *Rapid Development: Taming Wild Software Schedules*. Redmond, WA: Microsoft
    Press, 1996.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Mohammed, Nabil, Ali Munassar, and A. Govardhan. “A Comparison Between Five
    Models of Software Engineering.” *IJCSI International Journal of Computer Science
    Issues* 7, no. 5 (2010).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressman, Robert S. *Software Engineering, A Practitioner’s Approach*. New
    York: McGraw-Hill, 2010.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Schwaber, Ken. *Agile Project Management with Scrum (Developer Best Practices)*.
    Redmond, WA: Microsoft Press, 2004.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Shore, James, and Shane Warden. *The Art of Agile Development*. Sebastopol,
    CA: O’Reilly, 2007.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Stephens, Matt, and Doug Rosenberg. *Extreme Programming Refactored: The Case
    Against XP*. New York: Apress, 2003.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Wake, William C. *Refactoring Workbook*. Boston: Addison-Wesley Professional,
    2004.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Williams, Laurie, and Robert Kessler. *Pair Programming Illuminated*. Reading,
    MA: Addison-Wesley, 2003.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
