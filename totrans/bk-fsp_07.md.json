["```\nmatch ①*test-expression* with\n  | ②*pattern1* -> ③*result-expression1*\n  | ④*pattern2* -> ⑤*result-expression2*\n  | ...\n```", "```\nlet testOption opt =\n  match opt with\n  | Some(v) -> printfn \"Some: %i\" v\n  | None -> printfn \"None\"\n```", "```\nlet testNumber value =\n  match value with\n  | ①v when v < 0 -> printfn \"%i is negative\" v\n  | ②v when v > 0 -> printfn \"%i is positive\" v\n  | _ -> printfn \"zero\"\n```", "```\nlet testNumber value =\n  match value with\n  | v when v > 0 && v % 2 = 0 -> printfn \"%i is positive and even\" v\n  | v -> printfn \"%i is zero, negative, or odd\" v\n```", "```\n> **let testOption =**\n  **function**\n  | **Some(v) -> printfn \"Some: %i\" v**\n  | **None -> printfn \"None\";;**\n\nval testOption : _arg1:int option -> unit\n```", "```\nfun x ->\n  match x with\n  | Some(v) -> printfn \"Some: %i\" v\n  | None -> printfn \"None\";;\n```", "```\n[ Some 10; None; Some 4; None; Some 0; Some 7 ]\n|> List.filter (function | Some(_) -> true\n                         | None -> false)\n```", "```\n> **let numberToString =**\n  **function**\n  **| 0 -> \"zero\"**\n  **| 1 -> \"one\"**\n  **| 2 -> \"two\"**\n  **| 3 -> \"three\";;**\n\n    function\n  --^^^^^^^^\n\nstdin(4,3): warning FS0025: Incomplete pattern matches on this expression. For\nexample, the value '4' may indicate a case not covered by the pattern(s).\n\nval numberToString : _arg1:int -> string\n```", "```\n> **numberToString 4;;**\nMicrosoft.FSharp.Core.MatchFailureException: The match cases were incomplete\n   at FSI_0025.numberToString(Int32 _arg1)\n   at <StartupCode$FSI_0026>.$FSI_0026.main@()\nStopped due to error\n```", "```\nlet numberToString =\n  function\n  | 0 -> \"zero\"\n  | 1 -> \"one\"\n  | 2 -> \"two\"\n  | 3 -> \"three\"\n① | n -> sprintf \"%O\" n\n```", "```\n> **numberToString 4;;**\nval it : string = \"4\"\n```", "```\nlet numberToString =\n  function\n  | 0 -> \"zero\"\n  | 1 -> \"one\"\n  | 2 -> \"two\"\n  | 3 -> \"three\"\n  | _ -> \"unknown\"\n```", "```\nlet numberToString =\n  function\n  | 0 -> \"zero\"\n  | 1 -> \"one\"\n  | 2 -> \"two\"\n  | 3 -> \"three\"\n  | _ -> \"...\"\n```", "```\ntype Shape =\n| Circle of float\n| Rectangle of float * float\n| Triangle of float * float * float\n```", "```\nlet getPerimeter =\n  function\n  | Circle(r) -> 2.0 * System.Math.PI * r\n  | Rectangle(w, h) -> 2.0 * (w + h)\n  | Triangle(l1, l2, l3) -> l1 + l2 + l3\n```", "```\n[<LiteralAttribute>]\nlet Zero = 0\n[<LiteralAttribute>]\nlet One = 1\n[<LiteralAttribute>]\nlet Two = 2\n[<LiteralAttribute>]\nlet Three = 3\n\nlet numberToString =\n  function\n  | Zero -> \"zero\"\n  | One -> \"one\"\n  | Two -> \"two\"\n  | Three -> \"three\"\n  | _ -> \"unknown\"\n```", "```\n> **let matchString =**\n  **function**\n  **| \"\" -> None**\n  **| v -> Some(v.ToString());;**\n\nval matchString : _arg1:string -> string option\n```", "```\n> **matchString null;;**\nSystem.NullReferenceException: Object reference not set to an instance of an object.\n   at FSI_0070.matchString(String _arg1) in C:\\Users\\Dave\\AppData\\Local\\Temp\\~vsE434.fsx:line 68\n   at <StartupCode$FSI_0071>.$FSI_0071.main@()\nStopped due to error\n```", "```\nlet matchString =\n  function\n  **| null**\n  | \"\" -> None\n  | v -> Some(v.ToString())\n```", "```\nlet point = 10, 20\nlet x, y = point\n```", "```\nlet locatePoint p =\n  match p with\n  | ① (0, 0) -> sprintf \"%A is at the origin\" p\n  | ② (_, 0) -> sprintf \"%A is on the x-axis\" p\n  | ③ (0, _) -> sprintf \"%A is on the y-axis\" p\n  | ④ (x, y) -> sprintf \"Point (%i, %i)\" x y\n```", "```\ntype Name = { First : string; Middle : string option; Last : string }\n```", "```\nlet formatName =\n  function\n  | { First = f; Middle = Some(m); Last = l } -> sprintf \"%s, %s %s\" l f m\n  | { First = f; Middle = None; Last = l } -> sprintf \"%s, %s\" l f\n```", "```\nlet hasMiddleName =\n  function\n  | { Middle = Some(_) } -> true\n  | { Middle = None } -> false\n```", "```\nlet hasMiddleName =\n  function\n  | { **Name.**Middle = Some(_) } -> true\n  | { **Name.**Middle = None } -> false\n```", "```\nlet getLength =\n  function\n  | null -> 0\n  | [| |] -> 0\n  | [| _ |] -> 1\n  | [| _; _; |] -> 2\n  | [| _; _; _ |] -> 3\n  | a -> a |> Array.length\n```", "```\nlet getLength =\n  function\n  | [ ] -> 0\n  | [ _ ] -> 1\n  | [ _; _; ] -> 2\n  | [ _; _; _ ] -> 3\n  | lst -> lst |> List.length\n```", "```\nlet getLength n =\n  ① let rec len c l =\n    match l with\n    | ② [] -> c\n    | ③ _ :: t -> len (c + 1) t\n  len 0 n\n```", "```\n// Does not compile\nlet startsWithUpperCase =\n  function\n  | ① s when ② s.Length > 0 && s.[0] = System.Char.ToUpper s.[0] -> true\n  | _ -> false\n```", "```\n~vsD607.fsx(83,12): error FS0072: Lookup on object of indeterminate type based\non information prior to this program point. A type annotation may be needed\nprior to this program point to constrain the type of the object. This may\nallow the lookup to be resolved.\n```", "```\nlet startsWithUpperCase =\n  function\n  | **(s : string)** when s.Length > 0 && s.[0] = System.Char.ToUpper s.[0] ->\n    true\n  | _ -> false\n```", "```\ntype RgbColor = { R : int; G : int; B : int }\ntype CmykColor = { C : int; M : int; Y : int; K : int }\ntype HslColor = { H : int; S : int; L : int }\n\nlet detectColorSpace (cs : obj) =\n  match cs with\n  **| :? RgbColor -> printfn \"RGB\"**\n  **| :? CmykColor -> printfn \"CMYK\"**\n  **| :? HslColor -> printfn \"HSL\"**\n  | _ -> failwith \"Unrecognized\"\n```", "```\n> **let x, y = (10, 20);;**\n\nval y : int = 20\nval x : int = 10\n```", "```\n> **let point = (10, 20)**\n**let x, y = point;;**\n\nval point : int * int = (10, 20)\nval y : int = 20\nval x : int = 10\n```", "```\n> **let x, y as point = (10, 20);;**\n\nval point : int * int = (10, 20)\nval y : int = 20\nval x : int = 10\n```", "```\nlet locatePoint =\n  function\n  | (0, 0) as p -> sprintf \"%A is at the origin\" p\n  | (_, 0) as p -> sprintf \"%A is on the X-Axis\" p\n  | (0, _) as p -> sprintf \"%A is on the Y-Axis\" p\n  | (x, y) as p -> sprintf \"Point (%i, %i)\" x y\n```", "```\nlet locatePoint =\n  function\n  | (0, 0) as p -> sprintf \"%A is at the origin\" p\n  | ① (x, y) & (_, 0) -> sprintf \"(%i, %i) is on the x-axis\" x y\n  | ② (x, y) & (0, _) -> sprintf \"(%i, %i) is on the y-axis\" x y\n  | (x, y) -> sprintf \"Point (%i, %i)\" x y\n```", "```\nlet locatePoint =\n  function\n  | (0, 0) as p -> sprintf \"%A is at the origin\" p\n  | ① (_, 0) | ② (0, _) as p -> ③ sprintf \"%A is on an axis\" p\n  | p -> sprintf \"Point %A\" p\n```", "```\nlet locatePoint =\n  function\n  | (0, 0) as p -> sprintf \"%A is at the origin\" p\n  | (x, y) & ① ((_, 0) | (0, _)) -> sprintf \"(%i, %i) is on an axis\" x y\n  | p -> sprintf \"Point %A\" p\n```", "```\nlet (|CaseName1|CaseName2|...|CaseNameN|) [parameters] -> expression\n```", "```\nlet (|Fizz|Buzz|FizzBuzz|Other|) n =\n  match ① (n % 3, n % 5) with\n  | ② 0, 0 -> FizzBuzz\n  | ③ 0, _ -> Fizz\n  | ④ _, 0 -> Buzz\n  | ⑤ _ -> Other n\n```", "```\nlet fizzBuzz =\n  function\n  | Fizz -> \"Fizz\"\n  | Buzz -> \"Buzz\"\n  | FizzBuzz -> \"FizzBuzz\"\n  | Other n -> n.ToString()\n```", "```\nseq { 1..100 }\n|> Seq.map fizzBuzz\n|> Seq.iter (printfn \"%s\")\n```", "```\nlet (|CaseName|_|) [parameters] = expression\n```", "```\nlet (|Fizz|_|) n = if n % 3 = 0 then Some Fizz else None\nlet (|Buzz|_|) n = if n % 5 = 0 then Some Buzz else None\n```", "```\nlet fizzBuzz =\n  function\n  | Fizz & Buzz -> \"FizzBuzz\"\n  | Fizz -> \"Fizz\"\n  | Buzz -> \"Buzz\"\n  | n -> n.ToString()\n```", "```\nseq { 1..100 }\n|> Seq.map fizzBuzz\n|> Seq.iter (printfn \"%s\")\n```", "```\nlet (|DivisibleBy|_|) d n = if n % d = 0 then Some DivisibleBy else None\n```", "```\nlet fizzBuzz =\n  function\n  | DivisibleBy 3 & DivisibleBy 5 -> \"FizzBuzz\"\n  | DivisibleBy 3 -> \"Fizz\"\n  | DivisibleBy 5 -> \"Buzz\"\n  | n -> n.ToString()\n```", "```\nseq { 1..100 }\n|> Seq.map fizzBuzz\n|> Seq.iter (printfn \"%s\")\n```"]