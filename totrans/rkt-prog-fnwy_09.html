<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_259"/><span class="big">9</span><br/>COMPUTING MACHINES</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">We’re all used to having access to powerful computing devices with complex architectures and instruction sets, but fundamental ideas of computer science are based on far simpler devices. The basic idea is to begin with the simplest possible devices and determine what types of computations are possible. We’ll explore three such devices below, ranging from ones that can only perform simple operations like recognizing strings to ones that can carry out any algorithm.</p>&#13;
<h3 class="h3" id="ch00lev1sec_51">Finite-State Automata</h3>&#13;
<p class="noindent">In this section, we’ll introduce an abstract machine—a computational model, not a physical machine—called a <em>finite-state automaton (FSA)</em> or <em>finite-state machine (FSM)</em>. In spite of its impressive name, a finite-state automaton is really something very simple. The entire raison d’être of finite-state automata is to execute conditional expressions.</p>&#13;
<p class="indent">An FSA has a (metaphorical) tape with a series of symbols as inputs. Each symbol is read exactly once, and the machine then moves to the next <span epub:type="pagebreak" id="page_260"/>symbol in the sequence. An FSM is modeled using a finite number of states and transitions, hence the name finite-state machine. The machine starts in a given initial state and transitions to another state based on the input symbol. It can exist in exactly one state at any given time. Some of the states are <em>accepting states</em>, and if the machine finishes in an accepting state, the input string is valid. It’s possible that, depending on the input and possible transitions from a state, the machine can’t continue, in which case the string is invalid. The key is that for <em>every</em> input, there’s a <em>condition</em> for each transition.</p>&#13;
<p class="indent">Finite-state automata can be used to model many different types of computations, but in this section, we’ll focus on their popular use in computer science as <em>recognizers</em>: programs that, given an input string, indicate whether the sequence is valid or invalid. As an example, we’ll look at a recognizer that will accept strings of the form “HELLO,” “HELLLO,” “HELLOOO,” and so on, and reject all other strings. It’s clear from the nature of this problem that not only does an FSA need to be able to perform computations conditionally, but repetition (and hence, iteration) also comes into play.</p>&#13;
<p class="indent">There are a number of different ways to represent an FSM program; we’ll employ two of them: a <em>state-transitions diagram</em> and a <em>state table</em>. A state-transitions diagram is a directed graph that describes how the FSM transitions from one state to the next. Each state is indicated by a circle. The initial state is identified by an arrow pointing to one of the states, and the accepting states (there can be more than one) are usually indicated by double circles. States are connected by lines or arcs, each of which is labeled with an input symbol. The FSM transitions from one state to the next based on whether the current input symbol matches the label on one of its exiting arcs. A string is said to be accepted if it eventually reaches one of the accepting states; otherwise, it’s rejected.</p>&#13;
<p class="indent">An FSM for recognizing our “HELLO” strings is shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/09fig01.jpg"/></div>&#13;
<p class="figcap" id="ch9fig1"><em>Figure 9-1: An FSM for “HELLO” strings</em></p>&#13;
<p class="indent">The FSM begins in state 0, and when it receives an “H” for input, it moves to state 1; otherwise, it halts at state 0 (indicating a rejected string). Once in state 1, it expects an “E” and accepts or rejects the input value as before. It proceeds in this fashion until it reaches the final accepting state (state 4). Observe that state 3 can accept either an “L” or an “O.” An FSM, such as this one, built in such a way that every state has only a single transition for each input symbol, is called a <em>deterministic FSM</em> (or a <em>DFA</em>). It’s possible to build finite-state automata where one or more states may transition to more than one state for the same input symbol. Such an FSM is called a <em>nondeterministic FSM</em> (or an <em>NFA</em>). For any nondeterministic FSM, we can construct a deterministic FSM so they’re both capable of recognizing the same set of strings. The advantage of nondeterministic FSMs is that in some cases, <span epub:type="pagebreak" id="page_261"/>they’re simpler than their deterministic counterparts. In this text, we’ll only be using deterministic finite-state machines.</p>&#13;
<p class="indent">We can also represent our FSM as a state table (sometimes called an <em>event table</em>). See <a href="ch09.xhtml#ch9tab1">Table 9-1</a>. The first column of the table contains the state number, and the remaining columns represent the input symbols. The table cells contain the next state for a given input symbol. If no state is given, the input symbol is rejected.</p>&#13;
<p class="tabcap" id="ch9tab1"><strong>Table 9-1</strong>: State Table for "HELLO" Strings</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h_right" style="vertical-align: top;"><p class="taba">S</p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="taba">H</p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="taba">E</p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="taba">L</p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="taba">O</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1_right" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"/>&#13;
<td class="table-b1" style="vertical-align: top;"/>&#13;
<td class="table-b1" style="vertical-align: top;"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a_right" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-a" style="vertical-align: top;"/>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-a" style="vertical-align: top;"/>&#13;
<td class="table-a" style="vertical-align: top;"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1_right" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"/>&#13;
<td class="table-b1" style="vertical-align: top;"/>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a_right" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-a" style="vertical-align: top;"/>&#13;
<td class="table-a" style="vertical-align: top;"/>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1_right" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
<td class="table-h1" style="vertical-align: top;"/>&#13;
<td class="table-h1" style="vertical-align: top;"/>&#13;
<td class="table-h1" style="vertical-align: top;"/>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">To implement an FSM to recognize our “HELLO” strings in Racket, we first define a state table as follows:</p>&#13;
<pre>#lang racket&#13;
&#13;
(define state-table&#13;
  (vector&#13;
   ;        H  E  L  O&#13;
   (vector  1 #f #f #f) ; state 0&#13;
   (vector #f  2 #f #f) ; state 1&#13;
   (vector #f #f  3 #f) ; state 2&#13;
   (vector #f #f  3  4) ; state 3&#13;
   (vector #f #f #f  4) ; state 4&#13;
   ))</pre>&#13;
<p class="indent">In this case, we’re using <span class="literal">#f</span> to indicate an invalid transition.</p>&#13;
<p class="indent">Since we’re using vectors for our state table, we need a way to convert characters to indexes. This is done with a hash table, as shown in the following definition.</p>&#13;
<pre>(define chr-&gt;ndx&#13;
  (make-hash '[(#\H . 0) (#\E . 1) (#\L . 2) (#\O . 3)] ))</pre>&#13;
<p class="indent">Given a state number and character, the following <span class="literal">next-state</span> function gives the next state (or <span class="literal">#f</span>) from the state table.</p>&#13;
<pre>(define (next-state i chr)&#13;
  (if (hash-has-key? chr-&gt;ndx chr)&#13;
      (vector-ref (vector-ref state-table i)&#13;
                  (hash-ref chr-&gt;ndx chr) )&#13;
      #f))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/>Finally, here’s the DFA to recognize our “HELLO” strings.</p>&#13;
<pre>  (define (hello-dfa str)&#13;
<span class="ent">➊</span> (let ([chrs (string-&gt;list str)])&#13;
    (let loop ([state 0] [chrs chrs])&#13;
   <span class="ent">➋</span> (if (equal? chrs '()) ; end of string&#13;
       <span class="ent">➌</span> (if (= state 4) &#13;
              #t ;if 4, accepting&#13;
              #f ;not 4, not accepting&#13;
              )&#13;
       <span class="ent">➍</span> (let ([state (next-state state (car chrs))]&#13;
                [tail (cdr chrs)])&#13;
            (if (equal? state #f) #f ; invalid&#13;
             <span class="ent">➎</span> (loop state tail)))))))</pre>&#13;
<p class="indent">First, we convert our string to a list of characters <span class="ent">➊</span>. Then we loop on this list, first checking to see whether all the characters have been read <span class="ent">➋</span>. We then check the state <span class="ent">➌</span>. If we’re in an accepting state (in this case, state 4), we return <span class="literal">#t</span> indicating an accepted string; otherwise, we return <span class="literal">#f</span>. If the entire string hasn’t been processed, we get the next state and the rest of the string <span class="ent">➍</span>. We then start the process over again with the remainder of the string <span class="ent">➎</span>. Here are a few sample runs.</p>&#13;
<pre>&gt; <span class="codestrong1">(hello-dfa "HELP")</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(hello-dfa "HELLO")</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(hello-dfa "HELLLLLOOOO")</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(hello-dfa "HELLOS")</span>&#13;
#f</pre>&#13;
<p class="indent">It turns out that finite-state automata (both deterministic and nondeterministic) have certain limitations. For example, it’s not possible to build a finite-state machine that recognizes matching parentheses (since at any point, we would need a mechanism to remember how many open parentheses had been encountered). In the next section, we’ll introduce the FSM’s smarter brother, the Turing machine.</p>&#13;
<h3 class="h3" id="ch00lev1sec_52">The Turing Machine</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_263"/>The <em>Turing machine</em> is an invention of the brilliant British mathematician Alan Turing. In its simplest form, a Turing machine is an abstract computer that consists of the following components.</p>&#13;
<ul>&#13;
<li class="noindent">An infinite tape of cells that can contain either a zero or a one  (arbitrary symbols are also allowed, but we don’t use them here)</li>&#13;
<li class="noindent">A head that can read or write a value in each cell and move left or  right (see <a href="ch09.xhtml#ch9fig2">Figure 9-2</a>)</li>&#13;
<li class="noindent">A state table</li>&#13;
<li class="noindent">A state register that contains the current state</li>&#13;
</ul>&#13;
<div class="image"><img alt="Image" src="../images/09fig02.jpg"/></div>&#13;
<p class="figcap" id="ch9fig2"><em>Figure 9-2: Turing machine tape and head</em></p>&#13;
<p class="indent">Despite this apparent simplicity, given any computer algorithm, a Turing machine can be constructed that’s capable of simulating that algorithm’s logic. Conversely, any computing device or programming language that can simulate a Turing machine is said to be <em>Turing complete</em>. Thus, a Turing machine is not hampered by the limitations we mentioned for finite-state automata. There’s a large body of literature where the Turing machine plays into the analysis of whether certain functions are theoretically computable. We won’t engage in these speculations, but rather concentrate on the basic operation of the machine itself.</p>&#13;
<p class="indent">The machine we construct will have the simple task of adding two numbers. A number, <em>n</em>, will be represented as a contiguous string of <em>n</em> ones. The numbers to be added will be separated by a single zero, and the head will be positioned at the leftmost one of the first number. The result will be a string of ones, whose length will be the sum of the two numbers. At the end of the computation, the head will be positioned at the leftmost one of the result.</p>&#13;
<p class="indent">In a nutshell, the program works by changing the leftmost one of the leftmost number to zero, then scanning to the right until it reaches the end of the second number and writing a one just after the last one. The head then moves to the left until one of two things happens:</p>&#13;
<ul>&#13;
<li class="noindent">It encounters a zero followed by a one, which means there are more  ones left to move, so it continues to the left so that it can start over.</li>&#13;
<li class="noindent">It encounters two consecutive zeros, in which case the addition is  done (because there are no other ones left from the first number),  and it moves to the right until it is positioned over the leftmost one  of the final number.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/><a href="ch09.xhtml#ch9fig3">Figure 9-3</a> contains some snapshots of the tape at various times during the computation (the triangle shows the head at the start and end of the computation).</p>&#13;
<div class="image"><img alt="Image" src="../images/09fig03.jpg"/></div>&#13;
<p class="figcap" id="ch9fig3"><em>Figure 9-3: The tale of the tape</em></p>&#13;
<p class="indent">You may have already figured out that there are more direct ways to combine the two strings of numbers, but the method described lends itself to being adapted to other computations like multiplication.</p>&#13;
<p class="indent">Programming a Turing machine consists of constructing a <em>state table</em>. Each row in the table represents a particular state. Each state specifies three actions depending on whether the head currently reads a zero or a one. The actions will be to either write a one or a zero to the current cell, whether to move left or right afterward, and what the next state should be. <a href="ch09.xhtml#ch9tab2">Table 9-2</a> contains our adder program.</p>&#13;
<p class="tabcap" id="ch9tab2"><strong>Table 9-2</strong>: Turing Machine State Table</p>&#13;
<div class="image7"><img alt="Image" src="../images/p0264.jpg"/></div>&#13;
<p class="indent">The topmost row indicates the input symbol. The columns labeled with a W indicate the value that should be written, the columns headed by an M indicate the direction to move (left or right), and the columns headed by an N indicate the next state number. Entries marked with an x are states that will never be reached (this is assuming the inputs and start state are properly set)—in such cases, the entries would be irrelevant. The machine starts in state 0. The final state (or halting state) is state 7, indicted by an H in the move column for a one input.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>An alternative (and possibly easier-to-decipher) method of representing a Turing machine’s state changes is with a state-transition diagram, as shown in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>. In the state diagram, each transition label has three components: the symbol being read, the symbol to write, and the direction to move.</p>&#13;
<div class="image"><img alt="Image" src="../images/09fig04.jpg"/></div>&#13;
<p class="figcap" id="ch9fig4"><em>Figure 9-4: Turing machine state-transition diagram</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_70"><strong><em>A Racket Turing Machine</em></strong></h4>&#13;
<p class="noindent">As mentioned at the beginning of this section, a programming language that can simulate a Turing machine is said to be Turing complete. We’ll demonstrate that Racket is itself Turing complete by constructing just such a simulation (using our addition machine as an example program). We’ll of course have to compromise a bit on the infinite tape, so our machine will have a more modest tape, with just 10 cells. The state table will consist of a vector where each cell represents a state. Each state is a two-cell vector where the first cell consists of the actions when a zero is read, and the second cell consists of the actions when a one is read. The actions will be represented by a structure called <span class="literal">act</span>. The <span class="literal">act</span> structure will have fields <span class="literal">write</span>, <span class="literal">move</span>, and <span class="literal">next</span> (with obvious meanings). The state will be given in a variable called <span class="literal">state</span>, and the position of the head will be in <span class="literal">head</span>. Given these initial considerations, we have the following:</p>&#13;
<pre>#lang racket&#13;
&#13;
(define tape (vector 1 1 1 0 1 1 0 0 0 0))&#13;
&#13;
(define head 0)&#13;
&#13;
(struct act (write move next))&#13;
&#13;
(define state-table&#13;
  (vector&#13;
   (vector (act 0 #f 0) (act 0 'R 1)) ; state 0&#13;
   (vector (act 0 'R 2) (act 1 'R 1)) ; state 1&#13;
   (vector (act 1 'L 3) (act 1 'R 2)) ; state 2&#13;
   (vector (act 0 'L 4) (act 1 'L 3)) ; state 3&#13;
   (vector (act 0 'R 6) (act 1 'L 5)) ; state 4&#13;
   (vector (act 0 'R 0) (act 1 'L 5)) ; state 5&#13;
   (vector (act 0 'R 7) (act 1 #f 0)) ; state 6&#13;
   (vector (act 0 #f 0) (act 1 'H 0)) ; state 7&#13;
   ))&#13;
  &#13;
(define state 0)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_266"/>While not strictly required by the definition, we’ve included an <span class="literal">#f</span> value (indicating fail) in the “don’t care” states just in case there was some error introduced in the initial setup of the problem (hey, nobody’s perfect).</p>&#13;
<p class="indent">Before getting to the code that specifies the machine’s execution, we define a few helper functions to get at various components. The first function returns the next state given the current state and input symbol, and the other two get and set the value at the tape head.</p>&#13;
<pre>(define (state-ref s i) (vector-ref (vector-ref state-table s) i))&#13;
(define (head-val) (vector-ref tape head))&#13;
(define (tape-set! v) (vector-set! tape head v))</pre>&#13;
<p class="indent">The program for running the machine is straightforward. Note that this code is the same for <em>any</em> Turing machine you program; only the <span class="literal">tape</span> and <span class="literal">state-table</span> change.</p>&#13;
<pre>(define (run-machine)&#13;
  (let* ([sym (head-val)] ; current input&#13;
      <span class="ent">➊</span> [actions (state-ref state sym)]&#13;
         [move (act-move actions)])&#13;
    (cond [(equal? #f move)&#13;
           (printf "Failure in state ~a, head: ~a\n~a" state head tape)]&#13;
       <span class="ent">➋</span> [(equal? 'H move)&#13;
           (printf "Done!\n")]&#13;
          [else&#13;
        <span class="ent">➌</span> (let* ([write (act-write actions)]&#13;
               <span class="ent">➍</span> [changed (not (equal? sym write))])&#13;
             (tape-set! write)&#13;
          <span class="ent">➎</span> (set! head (if (equal? move 'L) (sub1 head) (add1 head)))&#13;
          <span class="ent">➏</span> (when changed (printf "~a\n" tape))&#13;
          <span class="ent">➐</span> (set! state (act-next actions))&#13;
             (run-machine))])))</pre>&#13;
<p class="indent">First we capture the actions for the current state and input <span class="ent">➊</span>. Then we capture the next symbol to write <span class="ent">➌</span> and update the next state <span class="ent">➐</span>. We also test whether the head is about to change a value on the tape <span class="ent">➍</span>, in which case we print out the updated tape <span class="ent">➏</span>. The head position is updated earlier <span class="ent">➎</span>. Once the final state is reached <span class="ent">➋</span>, the program will print <span class="literal">Done!</span>. Here’s the output.</p>&#13;
<pre>#(1 1 1 0 1 1 0 0 0 0)&#13;
#(0 1 1 0 1 1 0 0 0 0)&#13;
#(0 1 1 0 1 1 1 0 0 0)&#13;
#(0 0 1 0 1 1 1 0 0 0)&#13;
<span epub:type="pagebreak" id="page_267"/>#(0 0 1 0 1 1 1 1 0 0)&#13;
#(0 0 0 0 1 1 1 1 0 0)&#13;
#(0 0 0 0 1 1 1 1 1 0)&#13;
Done!</pre>&#13;
<h3 class="h3" id="ch00lev1sec_53">Pushdown Automata</h3>&#13;
<p class="noindent">The phrase “pushdown automata” is not a call to go out and knock over un-suspecting robots. No, the term <em>pushdown automaton</em> (or <em>PDA</em>) refers to a class of abstract computing devices that use a <em>pushdown stack</em> (or just <em>stack</em> to friends). In terms of computing power, pushdown automata lie squarely between that of finite-state automata and Turing machines.</p>&#13;
<p class="indent">The advantage of a PDA over a finite-state automaton lies in the stack. The stack forms a basic type of memory. Conceptually, a stack is like a stack of plates where you’re only allowed to remove a plate from the top of the stack (called a pop) or add (push) a plate to the top. The rest of the stack can only be accessed via adds or removes from the top. To simulate this in Racket, we define a stack as a string of symbols with two operations:</p>&#13;
<ul>&#13;
<li class="noindent"><strong>Push</strong>. This operation adds a symbol to the top of the stack (front  of the string).</li>&#13;
<li class="noindent"><strong>Pop</strong>. Pop removes the symbol at the top of the stack and returns it.</li>&#13;
</ul>&#13;
<p class="indent">A PDA is allowed to read the top symbol on the stack, but it has no access to other stack values. Stack values don’t necessarily have to match the values used as input symbols.</p>&#13;
<p class="indent">Like an FSA, a PDA sequentially reads its input and uses state transitions to determine the next state, but a PDA has the requirement that in addition to being in an accepting state, the stack must also be empty for a string to be accepted (but for practical purposes, in the example below we pre-populate the stack with a unique marker to indicate an empty stack). Be aware that pushdown automata come in deterministic and nondeterministic varieties. Further, nondeterministic pushdown automata are capable of performing a wider range of computations.</p>&#13;
<p class="indent">While we generally try to keep the presentation informal, we’re going to provide a formal description of a PDA since you’re likely to run across this type of notation if you elect to do further research on abstract computing machines.<sup><a href="footnote.xhtml#ch09foot_1" id="ch09foot1">1</a></sup> If you’re not familiar with set notation, you may want to jump to “Set Theory” in <a href="ch04.xhtml">Chapter 4</a> to brush up.</p>&#13;
<p class="indent">Generally, a PDA is defined as a machine <em>M</em> = (<em>Q</em>, <em>Σ</em>, <em>Γ</em>, <em>q</em><sub>0</sub>, <em>Z</em>, <em>F</em>, <em>δ</em>), where the following is true:</p>&#13;
<ul>&#13;
<li class="noindent"><em>Q</em>  is a finite set of states.</li>&#13;
<li class="noindent"><em>Σ</em>  is the set of input symbols.</li>&#13;
<li class="noindent"><em>Γ</em>  is the set of possible stack values.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_268"/><em>q</em><sub>0</sub> ∈ <em>Q</em>  is the start state.</li>&#13;
<li class="noindent"><em>Z</em> ∈ <em>Γ</em>  is the initial stack symbol.</li>&#13;
<li class="noindent"><em>F</em> ⊆ <em>Q</em>  is the set of accepting states.</li>&#13;
<li class="noindent"><em>δ</em>  is the set of possible transitions.</li>&#13;
</ul>&#13;
<p class="noindent">The set of permissible transitions are then defined by this somewhat intimidating expression (where Γ<sup>*</sup> is used to designate all the possible stack strings, and the symbol ϵ is used to represent the empty string, a string with no symbols in it).</p>&#13;
<p class="center">δ ⊆ (Q × (Σ ∪ {ϵ}) × Γ) × (Q × Γ*)</p>&#13;
<p class="noindent">This isn’t as bad as it looks. It’s basically saying that the set of possible transitions is a subset of all possible combinations of states, input symbols, and stack values (that is, all possibilities pre-transition) with all possible states and stack strings (the possibilities post-transition). The first set of values in parentheses represents inputs to the transition function and consists of the following:</p>&#13;
<ul>&#13;
<li class="noindent">the currents state: <em>q</em> ∈ <em>Q</em></li>&#13;
<li class="noindent">the current input symbol: <em>i</em> ∈ (<em>Σ</em> ∪ {ϵ})  (remember that we use <em>ϵ</em>  to indicate that the remaining string can be empty at some point)</li>&#13;
<li class="noindent">the value at the top of the stack: <em>s</em> ∈ <em>Γ</em></li>&#13;
</ul>&#13;
<p class="noindent">Given these values, a transition defines the next state (the second <em>Q</em>) and the potential new stack values (Γ<sup>*</sup>). For any transition, either the stack will be unaltered, new values will be pushed, or a value will be popped from the top.</p>&#13;
<p class="indent">Changes to the stack are designated by the notation <em>a</em>/<em>b</em>, where <em>a</em> is the symbol at the top of the stack and <em>b</em> is the resulting string at the top of the stack. For example, if we match some input symbol, the value <em>α</em> is at the top of the stack, and we pop this value without replacing it, we designate this by <em>α</em>/<em>ϵ</em>. If we match the input with <em>α</em> at the top of the stack and need to push <em>β</em> to the top of the stack, this would be designated as <em>α</em>/<em>βα</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_71"><strong><em>Recognizing Zeros and Ones</em></strong></h4>&#13;
<p class="noindent">Let’s set the formalities aside for now and look at a simple example. A popular exercise is to build a PDA that recognizes a string of zeros followed by ones such that the string of ones is exactly the same length as the string of zeros. This isn’t possible with a finite-state automaton, since it would need to remember how many zeros it had scanned before it started scanning the ones.</p>&#13;
<p class="indent">The expression 0<sup><em>n</em></sup>1<sup><em>n</em></sup> denotes the string format we’re looking for (zero repeated <em>n</em> times followed by one repeated <em>n</em> times), and our input alphabet is Σ = {0, 1}. Any other inputs won’t be accepted. To recognize this string, we only need to keep track of the number of zeros read so far, so we’ll push a zero to the top of the stack whenever a zero is encountered in the input. When a one is encountered, we pop a <span epub:type="pagebreak" id="page_269"/>zero off the stack; if the number of zeros and ones matches, no zeros will remain on the stack at the end of the input. In order to tell when we have popped the last zero from the stack, we’ll pre-populate the stack with a special marker, <em>ω</em>. So our stack symbols are the set Γ = {0, ω}.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig5">Figure 9-5</a> is the transition diagram for our PDA.</p>&#13;
<div class="image"><img alt="Image" src="../images/09fig05.jpg"/></div>&#13;
<p class="figcap" id="ch9fig5"><em>Figure 9-5: Pushdown automaton for</em> <span class="normal">0</span><sup><em>n</em></sup><span class="normal">1</span><sup><em>n</em></sup></p>&#13;
<p class="indent">The label 0;<em>ω</em>/0<em>ω</em> on the transition looping back to state 0 represents reading a zero on the input with the marker <em>ω</em> at the top of the stack and pushing a zero to the stack. (This is the first transition taken.) Likewise, the label 0;0/00 on this loop represents reading a zero on the input with a zero at the top of the stack and pushing a zero to the stack. The label 1;0/<em>ϵ</em> on the transition from state 0 to state 1 represents reading a one on the input and popping a zero from the stack. The loop on state 1 continues to read ones on the input and pops a zero from the stack for each one read. Once there are no input values and the stack is empty of zeros, the machine moves to state 2, which is an accepting state. Clearly the stack must contain the same number of zeros as the number of ones read in order for the accepting state to be reached.</p>&#13;
<h4 class="h4" id="ch00lev2sec_72"><strong><em>More Zeros and Ones</em></strong></h4>&#13;
<p class="noindent">Suppose we up the ante a bit and allow any string of zeros and ones, with the only requirement being that there’s an equal number of zeros and ones.</p>&#13;
<p class="indent">Again we assume that the stack is preloaded with <em>ω</em>. This time we allow both zero and one onto the stack. The process is basically this:</p>&#13;
<ul>&#13;
<li class="noindent">If the top of the stack is <em>ω</em>  and there’s no more input, the string is accepted.</li>&#13;
<li class="noindent">If the top of the stack is <em>ω</em>,  push the symbol being read.</li>&#13;
<li class="noindent">If the top of the stack is the same as the symbol being read, push  the symbol being read.</li>&#13;
<li class="noindent">Otherwise, pop the symbol being read.</li>&#13;
</ul>&#13;
<p class="noindent">This process is illustrated by the transition diagram in <a href="ch09.xhtml#ch9fig6">Figure 9-6</a>.</p>&#13;
<p class="indent">Neither of these recognizers is possible with finite-state automata. This is due to the fact that in both cases there’s a need to remember the number of symbols previously read. The PDA stack (which is not available in a plain FSA) provides this capability.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_270"/><img alt="Image" src="../images/09fig06.jpg"/></div>&#13;
<p class="figcap" id="ch9fig6"><em>Figure 9-6: PDA to match count of zeros and ones</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_73"><strong><em>A Racket PDA</em></strong></h4>&#13;
<p class="noindent">In this section, we’ll construct a PDA to recognize the strings described in <a href="ch09.xhtml#ch9fig6">Figure 9-6</a>. The input will be a list consisting of some sequence of ones and zeros. To process the input, we’ll define <span class="literal">make-reader</span>, which returns another function.</p>&#13;
<pre>(define (make-reader input)&#13;
  (define (read)&#13;
    (if (null? input) 'ϵ ; return empty string indicator&#13;
        (let ([sym (car input)])&#13;
          (set! input (cdr input))&#13;
          sym)))&#13;
  read)</pre>&#13;
<p class="indent">We call <span class="literal">make-reader</span> with the list we want to use as input, and it returns a function that will return the next value in the list every time it’s called. Here’s an example of how it’s used.</p>&#13;
<pre>&gt; <span class="codestrong1">(define read (make-reader '(1 0 1)))</span>&#13;
&gt; <span class="codestrong1">(read)</span>&#13;
1&#13;
&gt; <span class="codestrong1">(read)</span>&#13;
0&#13;
&gt; <span class="codestrong1">(read)</span>&#13;
1&#13;
&gt; <span class="codestrong1">(read)</span>&#13;
ϵ</pre>&#13;
<p class="indent">The stack will also be represented by a list. The following code gives the definitions we need to perform the various stack operations.</p>&#13;
<pre>(define stack '(ω)) ; ω is the bottom of stack marker&#13;
&#13;
(define (pop)&#13;
  <span epub:type="pagebreak" id="page_271"/>(let ([s (car stack)])&#13;
    (set! stack (cdr stack))&#13;
    s))&#13;
&#13;
(define (push s)&#13;
  (set! stack (cons s stack)))&#13;
&#13;
(define (peek) (car stack))</pre>&#13;
<p class="indent">Since there’s only one state of any significance, we won’t bother building a state table. We’ll instead take this as an opportunity to exercise another of Racket’s hidden treasures, <em>pattern matching</em>. This form of pattern matching is Racket’s built-in pattern matching as distinct from the pattern matching capability provided by the Racklog library introduced in <a href="ch08.xhtml">Chapter 8</a>. Pattern matching uses the <span class="literal">match</span> form included in the <em>racket/match</em> library.<sup><a href="footnote.xhtml#ch09foot_2" id="ch09foot2">2</a></sup></p>&#13;
<p class="indent">A <span class="literal">match</span> expression looks a bit like a <span class="literal">cond</span> expression, but instead of having to use a complex Boolean expression, we simply provide the data structure we want to match against. It’s possible to use a number of different structures as patterns to match against, including literal values, but we’ll simply use a list for this exercise.</p>&#13;
<pre>(define (run-pda input)&#13;
  (let ([read (make-reader input)]) ; initialize the reader&#13;
    (set! stack '(ω)) ; initialize stack&#13;
    (define (pda)&#13;
      (let ([symbol (read)]&#13;
            [top (peek)])&#13;
        (match (cons symbol top)&#13;
          [(cons 'ϵ 'ω ) #t] ; accept input&#13;
          [(cons  0 'ω)   (begin (push 0) (pda))]&#13;
          [(cons  0  0)  (begin (push 0) (pda))]&#13;
          [(cons  1 'ω)   (begin (push 1) (pda))]&#13;
          [(cons  1  1)  (begin (push 1) (pda))]&#13;
          [(cons  0  1)  (begin (pop)    (pda))]&#13;
          [(cons  1  0)  (begin (pop)    (pda))]&#13;
          [_ #f]))) ; reject input&#13;
    (pda)))</pre>&#13;
<p class="indent">Notice how the <span class="literal">match</span> expression closely mirrors the transitions shown in <a href="ch09.xhtml#ch9fig6">Figure 9-6</a>. We use <span class="literal">#t</span> and <span class="literal">#f</span> to signal whether the input is accepted or rejected. A single underscore (<span class="literal">_</span>) serves as a wildcard that matches anything. In this case, matching the wildcard would indicated a rejected string.</p>&#13;
<p class="indent">Let’s take it for a spin.</p>&#13;
<pre>&gt; <span class="codestrong1">(run-pda '(1))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(run-pda '(1 0))</span>&#13;
#t&#13;
&#13;
<span epub:type="pagebreak" id="page_272"/>&gt; <span class="codestrong1">(run-pda '(1 0 0 1 1 0))</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(run-pda '(0 1 0 0 1 1 0))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(run-pda '(1 0 0 1 1 0 0 0 1 1 1))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(run-pda '(1 0 0 1 1 0 0 0 1 1 1 0))</span>&#13;
#t</pre>&#13;
<h4 class="h4" id="ch00lev2sec_74"><strong><em>More Automata Fun</em></strong></h4>&#13;
<p class="noindent">Here are a couple of other PDA exercises you may want to try on your own.</p>&#13;
<ul>&#13;
<li class="noindent">Construct a PDA that matches parentheses (for example, “(())((()))”  okay, “(())((())” not okay).</li>&#13;
<li class="noindent">Build a palindrome recognizer (for example, “madam i’m adam”  or “racecar"). This one is tricky and requires constructing a  nondeterministic PDA (and also ignoring spaces and punctuation).</li>&#13;
</ul>&#13;
<h3 class="h3" id="ch00lev1sec_54">A Few Words About Languages</h3>&#13;
<p class="noindent">Finite-state automata and pushdown automata serve as recognizers for different classes of languages. A set of symbol strings is called a <em>regular language</em> if there’s some finite-state machine that accepts the entire set of strings. Examples of regular languages are the set of strings of digits that represent integers, or strings representing floating-point numbers like 1.246e52.</p>&#13;
<p class="indent">The set of valid arithmetic expressions (for example, <em>a</em> + <em>x</em>(1 + <em>y</em>)) is an example of a context-free grammar (CFG). A language consisting of strings accepted by a pushdown automaton is called a context-free language. This means we can construct a pushdown automaton to recognize arithmetic expressions.</p>&#13;
<p class="indent">Finite-state automata and pushdown automata play a key role in converting modern-day computer language strings into tokens that can then be fed to a PDA to parse the input language. The parser converts the input language into something called an <em>abstract syntax tree</em>, which can then be fed to a compiler or interpreter for further processing.</p>&#13;
<h3 class="h3" id="ch00lev1sec_55"><span epub:type="pagebreak" id="page_273"/>Summary</h3>&#13;
<p class="noindent">In this chapter, we explored a number of simple computing machines: finite-state automata, pushdown automata, and the Turing machine. We saw that, while simple, such machines are capable of solving practical problems. In the next chapter, we’ll make extensive use of these concepts where their capability to recognize general classes of strings and expressions will be used to develop an interactive calculator.</p>&#13;
</body></html>