<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label=" Page 93. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">REST AND GRAPHQL APIS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">An <i>API</i> is a generic pattern used to connect computers or computer programs. Unlike a user interface, it’s designed to be accessed not by a user but by another piece of software. One purpose of APIs is to hide the internal details of a system’s workings while exposing a standardized gateway to the system’s data or functionality.</p>&#13;
<p class="TX">As a full-stack developer, you’ll usually interact with, or <i>consume</i>, two kinds of APIs: internal and third-party. When querying an internal API, you’re consuming data from your own systems, typically from your own database or service. Private APIs are not available to outside parties. For example, your bank might use private APIs to check your credit score or account balance on its internal systems and display them in your online banking profile.</p>&#13;
<p class="TX">Third-party APIs provide access to data from an external system. For example, the OAuth login you’ll implement in <span class="Xref"><a href="part2.xhtml">Part II</a></span> uses an API. You <span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label=" Page 94. "/>might also use an API to fetch a social media feed or weather information from an external provider to display on your website. Because external APIs are exposed to the public, you can reach them through a public URL, and they document the conventions you should use to access their data in an <i>API contract</i>. This contract defines the format of the communications, the parameters the API expects, and the possible responses you might receive for each request. We briefly discussed API and function contracts and why you should type them in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>&#13;
<p class="TX">Full-stack web development primarily uses two types of APIs, REST and GraphQL, both of which transmit data over HTTP. This chapter covers these.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-38"/><samp class="SANS_Futura_Std_Bold_B_11">REST APIs</samp></h3>&#13;
<p class="TNI">REST is an architectural pattern used to design RESTful web APIs. These APIs are essentially a set of URLs, each of which provides access to a single resource. They rely on the use of HTTP methods and the standard HTTP status codes to transmit data and accept URL-encoded or request header parameters. Typically, they respond with the requested data in JSON or plaintext.</p>&#13;
<p class="TX">In fact, you’ve already built your first REST API. Recall the Next.js server you created in <span class="Xref"><a href="chapter5.xhtml#Exe5">Exercise 5</a> on page 89</span>, which provided the <i>api/weather/:zipcode</i> endpoint. So far, we’ve used this endpoint to play with Next.js’s routing, understand dynamic URLs, and learn how to access query parameters. You’ll soon see, however, that this API follows REST conventions: to access it, we used the HTTP GET method to consume the URL endpoint and received a JSON response with an HTTP status code of <i>200: OK</i>. Common status code ranges are <i>2XX</i> for successful requests and <i>3XX</i> for redirects. If the request fails, we see the <i>4XX</i> range to indicate a client-related error, such as <i>401: Unauthorized</i>, and <i>5XX</i> for server errors, often the generic <i>500: Internal Server Error</i>.</p>&#13;
<p class="TX">As full-stack developers, we might sometimes create our own APIs; more often, though, we’ll find ourselves consuming third-party APIs. Why might we consume, say, a third-party weather API? Well, imagine that we want our app to display the current weather at multiple remote locations. Instead of setting up and maintaining various weather stations on our own and then reading the data from the sensors, which would involve both providing and consuming an API for each of them, we could consume data from a third-party API offered by an existing weather service. Our code might call that API, pass in a ZIP code as a parameter, and receive the weather data for this location in a predetermined format. We’d then display this data on our website.</p>&#13;
<p class="TX">RESTful APIs enable us to interact with data without knowing anything about how that data was stored or what underlying technology provided it. If you follow an API’s specifications, you should receive the requested data, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label=" Page 95. "/>even if the underlying technology or architecture changes. Beyond this, there are a handful of requirements for an API to be considered RESTful.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The URL</samp></h4>&#13;
<p class="TNI">A unique URL provides an interface to a RESTful API. Each of a provider’s APIs typically has the same base URL, called the <i>root entry point</i>, such as <i>http://localhost:3000/api</i>. You can think of this as the APIs’ family name. Often, you’ll see a version number added to the root entry point, because a provider might have multiple versions of an API. For example, there might be the legacy <i>http://localhost:3000/api/v1</i> and an updated <i>http://localhost:3000/api/v2</i>. To honor this pattern, you can create a folder <i>v1</i> inside the <i>api</i> folder and move the REST API code there.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Other common ways of versioning an API include custom headers and query strings. In the first case, the client would request the API with a custom Accept-Version header and receive a matching Content-Version header. In the second case, an API request would use</i> <span class="note_Italic">?version</span><span class="note_symbol_Italic">=</span><span class="note_Italic">1.0.0</span> <i>as a query parameter in the URL.</i></p>&#13;
<p class="TX">The next part of the API’s URL is the path, often called the <i>endpoint</i>. It specifies the resource we want to query (for example, the weather API). API specifications usually mention only the endpoint itself, such as <i>/v1/weather</i>, leaving the root entry point implied. The URL generally also accepts parameters. These can be path parameters that are part of the URL, like in our ZIP code API endpoint, <i>/v1/weather/{zipcode}</i>, or they can be query parameters, which are added as encoded key-value pairs after an initial question mark, as in <i>/v1/weather?zipcode</i><span class="symbol_Italic">=&lt;</span><i>zipcode</i><span class="symbol_Italic">&gt;</span>. By convention, path parameters are usually used to refer to a resource or resources, and query parameters are used to perform operations on the data returned, like sorting or filtering.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Specification</samp></h4>&#13;
<p class="TNI">The resources themselves are separate from the representations returned to the client. In other words, the server might send data in formats like HTML, XML, JSON, or others, regardless of the way in which the data is stored in the application’s database. You can learn about an API’s response format in its <i>specification</i>, which serves as the manual for an API. One excellent way to document your APIs is with the OpenAPI format, which is widely used in the industry and is part of the Linux Foundation. You can use the Swagger graphical editor at <a href="https://editor.swagger.io"><i>https://<wbr/>editor<wbr/>.swagger<wbr/>.io</i></a> to experiment with it.</p>&#13;
<p class="TX">For example, <a href="chapter6.xhtml#Lis6-1">Listing 6-1</a> shows a specification for the <i>/v1/weather/ {zipcode}</i> endpoint, written as JSON. Paste the code into the Swagger editor to explore the generated documentation in a more user-friendly manner.</p>&#13;
<span id="Lis6-1"/>&#13;
<pre class="pre-102"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label=" Page 96. "/>{&#13;
    "openapi": "3.0.0",&#13;
    "info": {&#13;
        "title": "Sample Next.js - OpenAPI 3.x",&#13;
        "description": "The example APIs from our Next.js application",&#13;
        "version": "1.0.0"&#13;
    },&#13;
    "servers": [&#13;
        {"url": "https://www.usemodernfullstack.dev/api/"},&#13;
        {"url": "http://localhost:3000/api/"}&#13;
    ],&#13;
    "paths": {&#13;
        "/v1/weather/{zipcode}": {&#13;
            "get": {&#13;
                "summary": "Get weather by zip code",&#13;
                "parameters": [&#13;
                    {&#13;
                        "name": "zipcode",&#13;
                        "in": "path",&#13;
                        "description": "The zip code for the location as string.",&#13;
                        "required": true,&#13;
                        "schema": {&#13;
                          "type": "string",&#13;
                          "example": 96815&#13;
                        }&#13;
                    }&#13;
                ],&#13;
                "responses": {&#13;
                    "200": {&#13;
                        "description": "Successful operation",&#13;
                        "content": {&#13;
                            "application/json": {&#13;
                                "schema": {&#13;
                                    "$ref": "#/components/schemas/weatherDetailType"&#13;
                                }&#13;
                              }&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
          }&#13;
    },&#13;
    "components": {&#13;
        "schemas": {&#13;
            "weatherDetailType": {&#13;
                "type": "object",&#13;
                "properties": {&#13;
                    "zipcode": {&#13;
                        "type": "string",&#13;
                        "example": 96815&#13;
                    },&#13;
                    "weather": {&#13;
                        "type": "string",&#13;
                        "example": "sunny"&#13;
                    },&#13;
                    "temp": {&#13;
                        "type": "integer",&#13;
                        "format": "int64",&#13;
                        "example": 35&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label=" Page 97. "/>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-1: The OpenAPI specification for the</span> <span class="Futura_Std_Book_11">/v1/weather/{zipcode}</span> <span class="Futura_Std_Book_Oblique_BI_11">endpoint</span></p>&#13;
<p class="TX">First we define general information, such as the API’s title and description. The most important value here is the API version. In <span class="Xref"><a href="#Exe6">Exercise 6</a> on page 108</span>, we’ll adjust our server to reflect this version. The next property we set is the server, or the root entry point of the API. We use localhost here, because our Next.js application runs locally for now.</p>&#13;
<p class="TX">Then we specify the unique API endpoints under <samp class="SANS_TheSansMonoCd_W5Regular_11">paths</samp>, setting the path, parameters, and responses for each of them. In this example, we specify the minimum required data for one endpoint, the <i>/v1/weather/{zipcode}</i>, and clarify that it uses the GET method. The curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>) indicate the URL parameter, but we also set the parameter with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> explicitly in the path. In addition, we define the <i>schema</i>, or format, for the parameter, which should be a string.</p>&#13;
<p class="TX">Next, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">responses</samp> section, we set the response that the API should return if the HTTP status code is <i>200: OK</i>. This content, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">application/json</samp> format, is <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetailType</samp>, which you should already be familiar with from previous chapters. It’s similar to the custom type definition in our <i>custom.d.ts</i> file, except here we use JSON instead of TypeScript.</p>&#13;
<p class="TX">Note that the Swagger editor also generates an interactive playground based on the specification that lets us test the API’s endpoints against a running server. In addition, we can generate a server and client directly in the editor’s interface. The generated server will provide the REST API described in the specification, whereas the client will generate a library we can use in any application that consumes the API from the spec. This interactive playground and generated code make working with third-party APIs very easy.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">State and Authentication</samp></h4>&#13;
<p class="TNI">RESTful APIs are <i>stateless</i>, meaning they don’t store session information on the server. <i>Session information</i> is any data about previous user interactions. For example, imagine an online store’s shopping cart. In a stateful design, the application would store the content of your cart on the server and update it whenever you add new items. In a RESTful design, the client instead sends all relevant session data in each request. User–server interactions are understood in isolation, without context from previous requests.</p>&#13;
<p class="TX">Even so, public RESTful APIs often require some form of authentication. In order to distinguish the requests of authenticated users from the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label=" Page 98. "/>requests of unauthenticated users, those APIs typically provide a token that users should include in subsequent requests. Consumers send this token as part of the request’s data or in the HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header. We’ll provide more details about authorization tokens and how they work in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>&#13;
<p class="TX">This stateless design means that the authentication works regardless of whether the client requests the data from the end server directly, a proxy, or a load balancer. Therefore, a RESTful API is capable of handling a layered system. Stateless architectures are also ideal in high-volume situations, because they remove the server load caused by the retrieval of session information from a database.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HTTP Methods</samp></h4>&#13;
<p class="TNI">In REST, there are four standard ways to interact with a dataset: create, read, update, and delete. These interactions are commonly called <i>CRUD</i> operations. REST APIs use the following HTTP methods to perform these operations on the request’s resource:</p>&#13;
<p class="RunInPara1"><b>GET  </b><span class="R">Used to retrieve data from a resource. It’s the most common request; each time you visit a website in your browser, you make a GET request to the website’s address.</span></p>&#13;
<p class="RunInPara"><b>POST  </b>Used to add a new element to a collection resource. Sending the same POST request multiple times creates a new element for each request, resulting in multiple elements with the same content. When you send an email or submit a web form, your client is usually sending a POST request behind the scenes, because you’re creating a new resource in a database.</p>&#13;
<p class="RunInPara"><b>PUT  </b>Used to overwrite or update an existing resource. Sending the same PUT request multiple times creates or overwrites a single element with updated content. For example, when you re-upload a picture on Instagram or Facebook, you might send a PUT request.</p>&#13;
<p class="RunInPara"><b>PATCH  </b>Used to partially update an existing resource. Unlike with PUT, you’re sending only the data that differs from the current dataset. Hence, it’s a smaller and more performant operation. For example, an update to your profile on a social media page might be done with a PATCH request.</p>&#13;
<p class="RunInPara2"><b>DELETE  </b>Used to delete a resource (for example, to remove a picture on Instagram).</p>&#13;
<p class="TX">REST API requests suffer from the same performance implications as do all HTTP requests. Developers must consider critical factors such as network bandwidth, latency, and server load. While the application usually can’t influence the network latency or user bandwidth, it can increase its performance by caching the requests and responding with the previously cached results.</p>&#13;
<p class="TX">In general, the recommended approach is to cache requests aggressively. By avoiding additional server requests, we can speed up our application significantly. Unfortunately, not all HTTP requests are cacheable. The <span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label=" Page 99. "/>responses for GET requests are cacheable by default, but PUT and DELETE answers aren’t cacheable at all, because they don’t guarantee a predictable response. Between two similar PUT requests, a DELETE request might have deleted the resource, or vice versa. POST and PATCH request responses can, in theory, be cached if the response provides an <samp class="SANS_TheSansMonoCd_W5Regular_11">Expire</samp> header or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Cache-Control</samp> header and your subsequent calls are GET requests to the same resource. Still, servers frequently won’t cache those two types.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1" id="sec6"><span id="h1-39"/><samp class="SANS_Futura_Std_Bold_B_11">Working with REST</samp></h3>&#13;
<p class="TNI">Let’s practice working with REST by taking a look at our fictional weather service. Say we read the API contract and see that an authorized user can receive and update datasets from the service by using its public REST API. The API returns JSON data, the server’s URL is <i>https://www.usemodernfullstack.dev</i>, and the endpoint at <i>/api/v2/weather/{zipcode}</i> accepts GET and PUT requests. In this section, we walk through the requests and responses for getting the current weather data for a specific ZIP code with a GET request to the API, as well as for updating the stored weather data with a PUT request.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading Data</samp></h4>&#13;
<p class="TNI">To receive the weather for your location, you might make a GET request containing the ZIP code 96815 and an authorization token. We can make such a GET request with a command line tool like cURL, which should be part of your system. If necessary, you can install it from <a href="https://curl.se"><i>https://<wbr/>curl<wbr/>.se</i></a>. A typical cURL request looks like this:</p>&#13;
&#13;
<pre class="pre-103"><code>$ <b>curl -i </b><b><var>url</var></b></code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag displays the header details we are interested in. We can set the HTTP method with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-X</samp> flag and send an additional header with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-H</samp> flag. Use the escape character to send a multiline command (<samp class="SANS_TheSansMonoCd_W7Bold_B_11">\</samp> on macOS and <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp> on Windows). Avoid adding a space character behind the escape character. If you’re curious, try using cURL to query one of the API endpoints in the app you created in <span class="Xref"><a href="chapter5.xhtml#Exe5">Exercise 5</a> on page 89</span>. A cURL call for a GET request to the weather API <i>v2/weather/{zipcode}</i> at <i>https://www.usemodernfullstack.dev/api</i> would look like this:</p>&#13;
&#13;
<pre class="pre-104"><code>$ <b>curl -i \</b>&#13;
    <b>-X GET \</b>&#13;
    <b>-H "Accept: application/json" \</b>&#13;
    <b>-H "Authorization: Bearer 83dedad0728baaef3ad3f50bd05ed030" \</b>&#13;
    <b>https://www.usemodernfullstack.dev/api/v2/weather/96815</b>&#13;
</code></pre>&#13;
<p class="TX">We make this request to the API endpoint <i>v2/weather/{zipcode}</i> on the server at <i>https://www.usemodernfullstack.dev/api.</i> The ZIP code is included in the URL. We set the return format to JSON in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> header and pass an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label=" Page 100. "/>access token in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header. Because this is an example API, it accepts any token; if one is not supplied, the API returns a status code of <i>401</i>.</p>&#13;
<p class="TX">Here is what the API’s response to our GET request looks like:</p>&#13;
&#13;
<pre class="pre-105"><code>HTTP/2 200&#13;
content-type: application/json ; charset=utf-8&#13;
access-control-allow-origin: *&#13;
&#13;
{"weather":"sunny","tempC":"25","tempF":"77","friends":["96814","96826"]}&#13;
</code></pre>&#13;
<p class="TX">The API responds with an HTTP status code of <i>200</i>, indicating that the request was successful. We asked for a JSON response, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">content-type</samp> header confirms that the response data is indeed of that type.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Access-Control-Allow-Origin</samp> header, which we discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, here allows access to any domain. With this setting, a browser whose client-side JavaScript wants to access the API will allow these requests regardless of the website’s domain. Without the CORS header, the browser would block the request and the script’s access to the response and instead throw a CORS error.</p>&#13;
<p class="TX">Finally, we see that the response’s body contains a JSON string with the API response.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-89"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating Data</samp></h4>&#13;
<p class="TNI">Now imagine that you want to add display data from your neighborhood (96814) and the adjacent one (96826) to your website. Unfortunately, these ZIP codes aren’t yet available on the API. Luckily, because it’s open source, we can hook up our own weather station and extend the system. Say we’ve set up our weather sensors and connected them to the API. As soon as the weather changes, we add the dataset to it.</p>&#13;
<p class="TX">Here is the PUT request we make to update the weather for the ZIP code 96814. PUT requests store data in the request body; therefore, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag in the cURL command to send the encoded JSON:</p>&#13;
&#13;
<pre class="pre-106"><code>$<b> curl -i \</b>&#13;
    <b>-X PUT \</b>&#13;
    <b>-H "Accept: application/json" \</b>&#13;
    <b>-H "Authorization: Bearer 83dedad0728baaef3ad3f50bd05ed030" \</b>&#13;
    <b>-H "Content-Type: application/json" \</b>&#13;
    <b>-d "{\"weather\":\"sunny\",\"tempC\":\"20\",\"tempF\":\"68\",</b>&#13;
        <b>\"friends\":\"['96815','96826']\"}" \</b>&#13;
    <b>https://www.usemodernfullstack.dev/api/v2/weather/96815</b>&#13;
</code></pre>&#13;
<p class="TX">We request the same API endpoint, <i>/api/v2/weather/</i>, but replace the GET method with PUT, because we don’t want to get the data from the database; instead, we want to add data. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> header to tell the API provider that the payload in the request body is a JSON string. The API updates the dataset and responds with a status code of <i>200</i> and a JSON object with additional status details:</p>&#13;
&#13;
<pre class="pre-107"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label=" Page 101. "/>HTTP/2 200&#13;
content-type: application/json ; charset=utf-8&#13;
access-control-allow-origin: *&#13;
{"status":"ok"}&#13;
</code></pre>&#13;
<p class="TX">You can learn more about RESTful APIs at <a href="https://restfulapi.net"><i>https://<wbr/>restfulapi<wbr/>.net</i></a>, which covers more specific topics, such as compression and security models, and guides you through designing your own RESTful APIs. Now let’s turn our attention to GraphQL, a different, more advanced type of API.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-40"/><samp class="SANS_Futura_Std_Bold_B_11">GraphQL APIs</samp></h3>&#13;
<p class="TNI">Unlike REST, GraphQL isn’t merely an architectural pattern. It’s a complete, open source data query and manipulation language for APIs. It’s also the most popular REST alternative in full-stack web development, used by Airbnb, GitHub, PayPal, and many other companies. In fact, 10 percent of the top 10,000 sites reportedly use GraphQL. This section covers only certain of its features but should give you a solid understanding of GraphQL principles.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Despite its name, GraphQL doesn’t require the use of a graph database like Neo4j. We can use it to query any data source connected to the GraphQL server, including common databases such as MySQL and MongoDB.</i></p>&#13;
<p class="TX">Like REST, GraphQL APIs operate over HTTP. However, a GraphQL implementation exposes only a single API endpoint, typically called <i>/graphql</i>, for accessing all resources and performing all CRUD operations. By contrast, REST has one dedicated endpoint per resource.</p>&#13;
<p class="TX">Another difference is that we connect to the GraphQL server by using POST requests exclusively. Rather than using HTTP methods to define a desired CRUD operation, we use queries and mutations in the POST request body. <i>Queries</i> are read operations, while <i>mutations</i> are operations for creating, updating, and deleting data.</p>&#13;
<p class="TX">And unlike REST, which relies on standard HTTP status codes, GraphQL returns <i>500</i>, that is, an <i>Internal Server Error</i>, when an operation cannot be executed at all. Otherwise, the response uses <i>200</i> even if there are problems with the queries or mutations. The reason for this is that the resolver might have partially executed before encountering an issue. Keep this in mind when deploying a GraphQL API in production. Many standard operational practices and tools may need to change to account for this behavior.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Schema</samp></h4>&#13;
<p class="TNI">A GraphQL API defines the available queries and mutations in its schema, which is equivalent to the REST API’s specification. Also called a <i>typedef</i>, the schema is written in the Schema Definition Language (SDL). SDL’s core elements are <i>types</i>, which are objects that contain typed <i>fields</i> defining their properties, and optional <i>directives</i> that add additional information, for example, to specify caching rules for queries or mark fields as deprecated.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label=" Page 102. "/><a href="chapter6.xhtml#Lis6-2">Listing 6-2</a> shows a GraphQL schema for our fictional weather API, which returns the weather data for a location.</p>&#13;
<span id="Lis6-2"/>&#13;
<pre class="pre-108"><code>export const typeDefs = gql`&#13;
&#13;
    type LocationWeatherType {&#13;
        zip: String!&#13;
        weather: String!&#13;
        tempC: String!&#13;
        tempF: String!&#13;
        friends: [String]!&#13;
    }&#13;
&#13;
    input LocationWeatherInput {&#13;
        zip: String!&#13;
        weather: String&#13;
        tempC: String&#13;
        tempF: String&#13;
        friends: [String]&#13;
    }&#13;
&#13;
    type Query {&#13;
        weather(zip: String): [LocationWeatherType]!&#13;
    }&#13;
&#13;
    type Mutation {&#13;
        weather(data: LocationWeatherInput): [LocationWeatherType]!&#13;
    }&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-2: The GraphQL schema for the weather API</span></p>&#13;
<p class="TX">You should notice that the schema is a tagged template literal, which you learned about in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. We begin by describing custom GraphQL object types. These object types represent the data that the API returns. They are similar to the custom types we defined in TypeScript. A type has a name and can implement an interface. Each of these custom object types contains fields, which have a name and a type. GraphQL has the built-in scalar types <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Float</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ID</samp>. Exclamation marks (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>) denote non-nullable fields, and lists within square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) indicate arrays.</p>&#13;
<p class="TX">The first custom object type is <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationWeatherType</samp>, which describes the location information for a weather query. Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">String!</samp> expression to mark the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZIP</samp> field as non-nullable. Hence, the GraphQL service always returns a value for this field. We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field as an array of strings to represent related weather stations by ZIP code. It is also non-nullable, so it will always contain an array (with zero or more items) when added to the return values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array ensures that every item will be a string.</p>&#13;
<p class="TX">Then we define the input type object for our first mutation. These types are necessary for mutations, and they represent the input received from the API’s consumer. Because consumers should be able to pass in only the fields they’d like to update, we omit the exclamation marks to make the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label=" Page 103. "/>fields optional. In GraphQL, we need to define input objects and types for the return value separately, with the built-in types. Unlike in TypeScript, we can’t use generic custom types.</p>&#13;
<p class="TX">The schema also defines the query and mutation functions. These are the operations that consumers can send to the API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> query takes a ZIP code as a parameter and always returns an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp> objects. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationInput</samp> parameter and always returns the modified <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp> object.</p>&#13;
<p class="TX">Our schema doesn’t contain any directives, and we won’t go deep into their syntax in this chapter. However, one reason to use directives is for caching. Because GraphQL queries use POST, which isn’t cacheable using the default HTTP cache, we must implement caching manually, on the server side. We can configure caching statically on the type definitions with the directive <samp class="SANS_TheSansMonoCd_W5Regular_11">@cacheControl</samp> or dynamically, in the resolver functions, with <samp class="SANS_TheSansMonoCd_W5Regular_11">cacheControl.setCacheHint</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Resolvers</samp></h4>&#13;
<p class="TNI">In GraphQL, the <i>resolvers</i> are the functions that implement the schema. Each resolver function maps to a field. Query resolvers implement the reading of data, whereas mutation resolvers implement the creation, updating, and deletion of data. Together they provide complete CRUD functionality.</p>&#13;
<p class="TX">To understand how resolvers work, you can think of each GraphQL operation as a tree of nested function calls. In such an <i>abstract syntax tree (AST)</i>, each part of the operation represents a node. For example, consider a complex, nested GraphQL query, which asks for the location’s current weather, as well as the weather of all its neighbors. Our GraphQL schema for this example looks like <a href="chapter6.xhtml#Lis6-3">Listing 6-3</a>.</p>&#13;
<span id="Lis6-3"/>&#13;
<pre class="pre-109"><code>export const typeDefs = gql`&#13;
&#13;
    <b>type FriendsType {</b>&#13;
<b>        zip: String!</b>&#13;
<b>        weather: String!</b>&#13;
    <b>}</b>&#13;
&#13;
    type LocationWeatherType {&#13;
        zip: String!&#13;
        weather: String!&#13;
        tempC: String!&#13;
        tempF: String!&#13;
        friends: [<b>FriendsType</b>]!&#13;
    }&#13;
&#13;
    type Query {&#13;
        weather(zip: String): [LocationWeatherType]!&#13;
    }&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-3: The GraphQL schema for the nested GraphQL query example</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label=" Page 104. "/>In the schema for the example, we replace the content of the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array. Instead of a simple string, we want it to contain an object with a ZIP code and weather information. Therefore, we define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">FriendsType</samp> and use this type for the array items.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#Lis6-4">Listing 6-4</a> defines the complex example query.</p>&#13;
<span id="Lis6-4"/>&#13;
<pre class="pre-110"><code>query GetWeatherWithFriends {&#13;
    weather(zip: "96815") {&#13;
        weather&#13;
        friends {&#13;
            weather&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-4: The nested GraphQL query</span></p>&#13;
<p class="TX">This query takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp> and then returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> property, as well as all of its friends’ <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> properties, as strings. But how does the query work under the hood?</p>&#13;
<p class="TX"><a href="chapter6.xhtml#fig6-1">Figure 6-1</a> shows the resolver chain and corresponding AST. The GraphQL server would first parse the query into this structure and then validate the AST against the type-definition schema to ensure that the query can be executed without running into logical problems. Finally, the server would execute the query.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig6-1" src="../images/Figure6-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-1: Querying the GraphQL AST</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s examine the resolver chain for the query. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Query.weather</samp> function takes one argument, the ZIP code, and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> object for this ZIP code. Then the server continues along each branch separately. For the weather in the query, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label=" Page 105. "/>object, <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.weather</samp>, at which point the branch ends. The second part of the query, which asks for all friends from the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> object and their <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> properties, runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.Friends</samp> query and then returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">Friends.weather</samp> property for each result. The resolver object of each step contains the result returned by the parent field’s resolver.</p>&#13;
<p class="TX">Let’s return to our weather schema and define the resolvers. We’ll keep these simple. In <a href="chapter6.xhtml#Lis6-5">Listing 6-5</a>, you can see that their names match those defined in the schema.</p>&#13;
<span id="Lis6-5"/>&#13;
<pre class="pre-111"><code>export const resolvers = {&#13;
    Query: {&#13;
        weather: async (_: any, param: WeatherInterface) =&gt; {&#13;
            return [&#13;
                {&#13;
                    zip: param.zip,&#13;
                    weather: "sunny",&#13;
                    tempC: "25C",&#13;
                    tempF: "70F",&#13;
                    friends: []&#13;
                }&#13;
            ];&#13;
        },&#13;
    },&#13;
    Mutation: {&#13;
        weather: async (_: any, param: {data: WeatherInterface}) =&gt; {&#13;
            return [&#13;
                {&#13;
                    zip: param.data.zip,&#13;
                    weather: "sunny",&#13;
                    tempC: "25C",&#13;
                    tempF: "70F",&#13;
                    friends: []&#13;
                }&#13;
            ];&#13;
        }&#13;
    },&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-5: The GraphQL resolvers for the weather API</span></p>&#13;
<p class="TX">We first define async functions for the query and mutation properties and assign the object to the const <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp>. Each takes two parameters. The first one represents the previous resolver object in the resolver chain. We aren’t using a nested or complex query; hence, here it is always undefined. For this reason, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type to avoid a TypeScript error and use the underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>) convention you learned in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> to mark it as unused. The second parameter is an object containing the data passed to the function on invocation. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> query and the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation, it is an object that implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.</p>&#13;
<p class="TX">For now, both functions ignore this parameter for the most part, using only the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> property to reflect the input. Also, they return a static JSON <span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label=" Page 106. "/>object similar to the REST API we created in the previous listings. The static data is just a placeholder, which we’ll replace with the result from our database queries later. The response honors the API contract we defined in the GraphQL schema, as this data consists of arrays with weather location datasets.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-41"/><samp class="SANS_Futura_Std_Bold_B_11">Comparing GraphQL to REST</samp></h3>&#13;
<p class="TNI">We’ve already implemented RESTful APIs in our Next.js application, and as you saw in this chapter, REST is fairly simple to work with. You might be wondering why you’d even consider using GraphQL. Well, GraphQL solves two problems common in REST APIs: over-fetching and under-fetching.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Over-Fetching</samp></h4>&#13;
<p class="TNI">When a client queries a REST endpoint, the API always returns the complete dataset for that endpoint. This means that, often, the API delivers more data than necessary, a common performance problem called <i>over-fetching</i>. For example, our example RESTful weather API at <i>/api/v2/weather/zip/96815</i> delivers all weather data for a ZIP code even if all you need is the temperature in Celsius. You’d then need to manually filter the results. In GraphQL, the API requests explicitly define the data they want returned.</p>&#13;
<p class="TX">Let’s look at an example to see how GraphQL lets us keep the API response data to a minimum. The following GraphQL query returns only the temperature in Celsius for the location with the ZIP code 96815:</p>&#13;
&#13;
<pre class="pre-112"><code>query Weather {&#13;
    weather(zip: "96815") {&#13;
        tempC&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">In GraphQL, we send the query as a JSON string with the POST request’s data:</p>&#13;
&#13;
<pre class="pre-113"><code>$ <b>curl -i \</b>&#13;
<b>    -X POST \</b>&#13;
<b>    -H "Accept: application/json" \</b>&#13;
<b>    -H "Authorization: Bearer 83dedad0728baaef3ad3f50bd05ed030" \</b>&#13;
<b>    -H "Content-Type: application/json" \</b>&#13;
<b>    -d '{"query":"\nquery Weather  {\n  weather(zip: \"96815\") {\n    tempC  \n  }\n}"}' \</b>&#13;
<b>    https://www.usemodernfullstack.dev/api/graphql</b>&#13;
</code></pre>&#13;
<p class="TX">We consume the API with a POST request to the <i>/api/graphql</i> endpoint, then set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> header and <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> header to JSON to explicitly tell the API that we’re sending a JSON object in the request body and expect a JSON response. We set the access token in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header, as in a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label=" Page 107. "/>RESTful request. The POST body contains the query for the weather data, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> control characters indicate the newlines in the GraphQL query. As defined in the contract, the query expects a parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>, for which we pass in the ZIP code <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp>. In addition, we request that the API return only the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> field of the weather node.</p>&#13;
<p class="TX">Here is the response from the GraphQL API:</p>&#13;
&#13;
<pre class="pre-114"><code>HTTP/2 200&#13;
content-type: application/json ; charset=utf-8&#13;
access-control-allow-origin: *&#13;
&#13;
{"data":{"weather":[{"tempC":"25C"}]}}&#13;
</code></pre>&#13;
<p class="TX">The API responds with a status code of <i>200</i>. We specified in the request’s query that we are interested in only the requested field <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> object, so this is what we received. The API doesn’t return the ZIP code, temperature in Fahrenheit, weather string, or friends array.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Under-Fetching</samp></h4>&#13;
<p class="TNI">On the other hand, a REST dataset might not contain all the data you need, requiring you to send follow-up requests. This problem is called <i>under-fetching</i>. Imagine that your friends also have weather stations and that you want to get the current weather at their ZIP codes. The RESTful weather API returns an array with related ZIP codes (<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>). However, you’d need to make additional requests for each ZIP code to receive their weather information, potentially causing performance issues.</p>&#13;
<p class="TX">GraphQL treats datasets as nodes in a graph, with relationships between them. Therefore, extending a single query to receive related data is pretty simple. Our example GraphQL server’s resolvers are set up to fetch additional data about friends if the request’s query contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field. We define the GraphQL query as follows:</p>&#13;
&#13;
<pre class="pre-115"><code>query Weather {&#13;
    weather(zip: "96815") {&#13;
        tempC&#13;
        friends {&#13;
            tempC&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The following shows an example request that fetches all related nodes through the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array. Again, we define the return data and query the friends only for the field <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>:</p>&#13;
&#13;
<pre class="pre-116"><code>$<b> curl -i \</b>&#13;
<b>    -X POST \</b>&#13;
<b>    -H "Accept: application/json" \</b>&#13;
<b>    -H "Authorization: Bearer 83dedad0728baaef3ad3f50bd05ed030" \</b>&#13;
<b>    -H "Content-Type: application/json" \</b>&#13;
<b>    -d '{"query":"query Weather  {\n  weather(zip: \"96815\")</b>&#13;
<b>        {\n    tempC\n    friends {\n      tempC\n    }\n  }\n}"}' \</b>&#13;
<b>    https://www.usemodernfullstack.dev/api/graphql</b>&#13;
</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label=" Page 108. "/>&#13;
<p class="TX">The POST body contains the query for weather data pertaining to the 96815 ZIP code in one line and asks for the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> field, as in the previous request. To extend the query, we add a sub-selection on the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field. Now GraphQL traverses the related nodes and their fields and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> field of the nodes whose ZIP codes match the ones in the 96815 node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array.</p>&#13;
<p class="TX">Here is the response from the GraphQL server. We see that it contains data from the related nodes:</p>&#13;
&#13;
<pre class="pre-117"><code>HTTP/2 200&#13;
content-type: application/json ; charset=utf-8&#13;
access-control-allow-origin: *&#13;
&#13;
{"data":{"weather":[{"tempC":"25C","friends":&#13;
[{"tempC":"20C"},{"tempC":"30C"}]}]}}&#13;
</code></pre>&#13;
<p class="TX">As you’ve discovered, GraphQL lets us easily extend queries by adjusting the data in the request.</p>&#13;
<p class="HeadProject"><span id="Exe6"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 6: Add a GraphQL API to Next.js</samp></p>&#13;
<p class="TNI">Let’s rework our weather application’s API to use GraphQL. To do so, we must first add GraphQL to the project. GraphQL isn’t a pattern but an environment that consists of a server and a query language, both of which we must add to Next.js.</p>&#13;
<p class="TX">We’ll install the stand-alone Apollo server, one of the most popular GraphQL servers, which also provides a Next.js integration. Open your terminal and navigate to the refactored application you built in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. In the directory’s top level, next to the <i>package.json</i> file, execute this command:</p>&#13;
&#13;
<pre class="pre-118"><code>$ <b>npm install @apollo/server @as-integrations/next graphql graphql-tag</b></code></pre>&#13;
<p class="TX">This command also installs the GraphQL language and the GraphQL tag modules we’ll need.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Schema</samp></h4>&#13;
<p class="TNI">As we discussed, every GraphQL API starts with a schema definition. Create a folder called <i>graphql</i> next to the <i>pages</i> folder in the Next.js directory. This is where we’ll add all GraphQL-related files.</p>&#13;
<p class="TX">Now create a file called <i>schema.ts</i> and paste the code you wrote back in <span class="Xref"><a href="chapter6.xhtml#Lis6-2">Listing 6-2</a></span>. We’ve already defined and discussed the type definition used here. Simply add one line to the top of the file:</p>&#13;
&#13;
<pre class="pre-119"><code>import gql from "graphql-tag";</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label=" Page 109. "/>This line imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">qql</samp> tagged template literal we use to define the schema.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Data</samp></h4>&#13;
<p class="TNI">We want our API to return different data depending on the parameters and properties of the queries sent to it. Therefore, we need to add datasets to our project. GraphQL can query any database, even static JSON data. So let’s implement a JSON dataset. Create the file <i>data.ts</i> inside the <i>graphql</i> directory and add the code from <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a>.</p>&#13;
<span id="Lis6-6"/>&#13;
<pre class="pre-120"><code>export const db = [&#13;
    {&#13;
        zip: "96815",&#13;
        weather: "sunny",&#13;
        tempC: "25C",&#13;
        tempF: "70F",&#13;
        friends: ["96814", "96826"]&#13;
    },&#13;
    {&#13;
        zip: "96826",&#13;
        weather: "sunny",&#13;
        tempC: "30C",&#13;
        tempF: "86F",&#13;
        friends: ["96814", "96814"]&#13;
    },&#13;
    {&#13;
        zip: "96814",&#13;
        weather: "sunny",&#13;
        tempC: "20C",&#13;
        tempF: "68F",&#13;
        friends: ["96815", "96826"]&#13;
    }&#13;
];&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-6: The</span> <span class="Futura_Std_Book_11">graphql/data.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file for the GraphQL API</span></p>&#13;
<p class="TX">This JSON defines three weather locations and their properties. A consumer will be able to query our API for these datasets.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Resolvers</samp></h4>&#13;
<p class="TNI">Now we can define our resolvers. Add the file <i>resolvers.ts</i> to the <i>graphql</i> directory and paste in the code from <a href="chapter6.xhtml#Lis6-7">Listing 6-7</a>. This is similar to the code we previously discussed when we introduced resolvers, but instead of returning the same static JSON object to the consumer, we query our new dataset.</p>&#13;
<span id="Lis6-7"/>&#13;
<pre class="pre-121"><code>import {db} from "./data";&#13;
&#13;
declare interface WeatherInterface {&#13;
    zip: string;&#13;
    weather: string;&#13;
    tempC: string;&#13;
    tempF: string;&#13;
    friends: string[];&#13;
}&#13;
&#13;
export const resolvers = {&#13;
    Query: {&#13;
        weather: async (_: any, param: WeatherInterface) =&gt; {&#13;
            return [db.find((item) =&gt; item.zip === param.zip)];&#13;
        }&#13;
    },&#13;
    Mutation: {&#13;
        weather: async (_: any, param: {data: WeatherInterface}) =&gt; {&#13;
            return [db.find((item) =&gt; item.zip === param.data.zip)];&#13;
        }&#13;
    }&#13;
};&#13;
</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label=" Page 110. "/>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-7: The</span> <span class="Futura_Std_Book_11">graphql/resolvers.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file for the GraphQL API</span></p>&#13;
<p class="TX">We import the array of JSON objects we created earlier and define an interface for the resolvers. The query resolver finds an object by using the ZIP code passed to it and returns it to the Apollo server. The mutation does the same, except that the parameter structure is slightly different: it is accessible through the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> property. Alas, we can’t actually change the data by using the mutation, as the data is a static JSON file. We’ve implemented the mutation here for illustration purposes only.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the API Route</samp></h4>&#13;
<p class="TNI">The Apollo GraphQL server exposes one endpoint, <i>graphql/</i>, which we’ll implement now. Create a new file, <i>graphql.ts</i>, in the <i>api</i> folder and add the code from <a href="chapter6.xhtml#Lis6-8">Listing 6-8</a>. This code initializes the GraphQL server and adds a CORS header so that we can access the API from different domains and use the built-in GraphQL sandbox explorer to play with GraphQL later. You saw this header in the previous cURL responses.</p>&#13;
<span id="Lis6-8"/>&#13;
<pre class="pre-122"><code>import {ApolloServer} from "@apollo/server";&#13;
import {startServerAndCreateNextHandler} from "@as-integrations/next";&#13;
import {resolvers} from "../../graphql/resolvers";&#13;
import {typeDefs} from "../../graphql/schema";&#13;
import {NextApiHandler, NextApiRequest, NextApiResponse} from "next";&#13;
&#13;
//@ts-ignore&#13;
const server = new ApolloServer({&#13;
    resolvers,&#13;
    typeDefs&#13;
});&#13;
&#13;
const handler = startServerAndCreateNextHandler(server);&#13;
&#13;
const allowCors =&#13;
    (fn: NextApiHandler) =&gt; async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
        res.setHeader("Allow", "POST");&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label=" Page 111. "/>        res.setHeader("Access-Control-Allow-Origin", "*");&#13;
        res.setHeader("Access-Control-Allow-Methods", "POST");&#13;
        res.setHeader("Access-Control-Allow-Headers", "*");&#13;
        res.setHeader("Access-Control-Allow-Credentials", "true");&#13;
&#13;
        if (req.method === "OPTIONS") {&#13;
            res.status(200).end();&#13;
        }&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
export default allowCors(handler);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 6-8: The</span> <span class="Futura_Std_Book_11">api/graphql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file, which creates the API entry point for GraphQL</span></p>&#13;
<p class="TX">This code is all we need to create the GraphQL entry point. First we import the necessary modules, including our GraphQL schema and the resolvers, both of which we created previously. Then we initialize a new GraphQL server with typedefs and resolvers.</p>&#13;
<p class="TX">We start the server and continue by creating the API handler. To do this, we use the Next.js integration helper to start the server and return the Next.js handler. The integration helper connects the serverless Apollo instance to the Next.js custom server. Before we define the default export as an async function that takes the API’s request and response objects as parameters, we create a wrapper to add the CORS headers to the request. The first block inside the function sets up the CORS headers, and we limit the allowed request to POST requests. We need the CORS headers here to make our GraphQL API publicly available. Otherwise, we wouldn’t be able to connect to the API from a website running on a different domain or even use the server’s built-in GraphQL sandbox.</p>&#13;
<p class="TX">Part of the CORS setup here is that we immediately return <i>200</i> for any OPTIONS requests. The CORS patterns use OPTIONS requests as preflight checks. Here the browser requests only headers, and then checks the response’s CORS headers to verify that the domain from which it calls the API is allowed to access the resource before making the actual request.</p>&#13;
<p class="TX">However, our Apollo server allows only POST and GET requests and would return <i>405: Method Not Allowed</i> for the preflight OPTIONS request. So, instead of passing this request to the Apollo server, we end the request and return <i>200</i> with the previous CORS headers. The browser should then proceed with the CORS pattern. Finally, we start the server and create the API handler on the desired path, <i>api/graphql</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-98"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Apollo Sandbox</samp></h4>&#13;
<p class="TNI">Start your Next.js server with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp>. You should see the Next.js application running on <i>http://localhost:3000</i>. If you navigate to the GraphQL API at <i>http://localhost:3000/api/graphql</i>, you’ll find the Apollo sandbox interface for querying the API, as in <a href="chapter6.xhtml#fig6-2">Figure 6-2</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label=" Page 112. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig6-2" src="../images/Figure6-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-2: The Apollo sandbox’s API querying interface</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the Documentation pane on the left side, we see the available queries as fields of the query object we defined earlier. As expected, we see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> query here, and when we click it, a new query appears in the Operation pane in the middle. At the same time, the interface changes, and we see the available arguments and fields. Clicking each provides more information. Using the plus (+) button, we can add fields to the Query pane and run them against the data.</p>&#13;
<p class="TX">Try creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> query that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> properties. This query requires a ZIP code as an argument; add it through the user interface on the left-hand side, and then add the ZIP code 96826 as a string to the JSON object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">variables</samp> section of the lower pane. Now run the query by clicking the <b>Weather</b> button at the top of the Operation pane. You should receive the result for this ZIP code in the Response pane on the right as JSON. Compare your screen with <a href="chapter6.xhtml#fig6-3">Figure 6-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label=" Page 113. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig6-3" src="../images/Figure6-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-3: The GraphQL query and response from the server</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Play around with crafting queries, accessing properties, and creating errors with invalid arguments to get a feel for GraphQL before moving on to the next chapter.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H1" id="sec20"><span id="h1-42"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">This chapter explored RESTful and GraphQL web APIs and their role in full-stack development. Although we used a REST design in previous chapters, you should now be familiar with the concept of stateless servers, as well as the five HTTP methods for performing CRUD operations in REST. You also practiced working with a public REST API to read and update data, then evaluated its requests and responses.</p>&#13;
<p class="TX">GraphQL APIs require a bit more work to implement, but they reduce the over-fetching and under-fetching issues often experienced in REST. You learned to define the API contract with a schema and implement its functionality with resolvers. Then you queried an API and defined the dataset to return in the request.</p>&#13;
<p class="TX">Finally, you added a GraphQL API to your existing Next.js application by adding the Apollo server to it. You should now be able to create your own GraphQL API and consume third-party resources. To learn more about GraphQL, I recommend the tutorials at <a href="https://www.howtographql.com"><i>https://<wbr/>www<wbr/>.howtographql<wbr/>.com</i></a> and the official GraphQL introduction at <a href="https://graphql.org/learn/"><i>https://<wbr/>graphql<wbr/>.org<wbr/>/learn<wbr/>/</i></a>.</p>&#13;
<p class="TX">In the next chapter, you’ll explore the MongoDB database and Mongoose, an object data modeling library, for storing data.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>