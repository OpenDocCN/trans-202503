<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_183"/><strong><span class="big">7</span><br/>EXAMINATION OF INSTALLED SOFTWARE PACKAGES</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">This chapter covers the analysis of software installed on a Linux system, which includes software copied during the initial creation of a Linux system and software packages installed, updated, and removed during normal system administration. From a digital forensics perspective, we are interested in when software packages were installed on a system, what was installed, who installed them, and why. These same questions apply to software that has been removed (uninstalled). Linux systems and package managers have package databases and logs with timestamps that help to answer these questions.</p>&#13;
<p class="indent">In the very early days of Linux, there were no installation GUIs or package management systems. People installed software by downloading source files directly from the developer (usually via FTP), compiling source files into binaries, and installing them with provided install scripts, <code>make install</code> <span epub:type="pagebreak" id="page_184"/>commands, or even just simple file copying. Fetching and installing software dependencies was done manually after reading the requirements listed in the documentation (<em>README</em> files, and so on). The initial installation was a similar manual process. Partitions and filesystems were created by hand, system directories were made, the kernel was copied into place, and the bootloader was installed. You can still experience this manual process today with the <em>Linux From Scratch (LFS)</em><sup><a id="ch07foot01" href="footnotes.xhtml#ch07foot_01">1</a></sup> distribution, which is also an excellent way to learn Linux in depth.</p>&#13;
<p class="indent">Some of a Linux distribution’s defining features include its installation process and its package management system. These areas of Linux largely lack common standardization, and most distributions still have their own tools, scripts, remote package repositories, local package databases, and package file formats.</p>&#13;
<p class="indent">The Linux community is experiencing some fundamental changes in how it manages software. Some distributions are now using a <em>rolling-release</em> model, in which the system is updated as new software becomes available without having fixed version numbers or release dates. This model allows users to have the latest versions of software with the newest features and security fixes. Gentoo and Arch Linux were the first major distros to pioneer the rolling release concept. Complexity and compatibility has driven another change toward software bundled in self-contained archives with all the files needed to function (including files that are normally shared, like libraries). Both of these software packaging concepts are interesting from a forensics perspective, and digital evidence can be found in the metadata and logfiles.</p>&#13;
<p class="indent">Most distros use a traditional software development life cycle which has well-defined release dates, names, and version numbers. Version numbers are especially important when analyzing compromised systems and intrusions. Known vulnerabilities in a particular software version can be potentially linked to malicious activity and exploitation. This vulnerability identification also applies to rolling release distros, as they install released versions of individual software packages or Git-cloned packages from a specific date.</p>&#13;
<h3 class="h3" id="ch00lev1_32"><strong>System Identification</strong></h3>&#13;
<p class="noindent">When a Linux PC, laptop, or acquired image file arrives in your forensic lab for analysis, one of the first tasks is to determine which Linux distribution is installed. This knowledge helps focus an investigation along a more distro-specific analysis. Other artifacts to look for are unique identifiers that can be used to link and corroborate evidence from multiple sources. For example, a randomly generated unique identification string created during installation might be used to positively identify the machine in backup archives or in logs found on other machines.</p>&#13;
<h4 class="h4" id="ch00lev2_89"><strong><em>Distro Release Information</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_185"/>The typical software development life cycle involves releasing software at distinct points in time, with alphas, betas, release candidates, and releases. This model includes pre-release testing, a fixed (frozen) stable release, and post-release updates. Fixed releases provide a higher degree of stability and allow for easier support. The distro version number is independent of the kernel version (even though it’s the kernel that makes it Linux in the first place). The individual software packages each have their own version numbers, which are also independent of the distro version number.</p>&#13;
<p class="indent">Modern Linux installations based on systemd provide detailed release information in the <em>/etc/os-release</em> file (usually a symlink to <em>/usr/lib/os-release</em>); for example:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/os-release</span>&#13;
NAME="Ubuntu"&#13;
VERSION="20.04.1 LTS (Focal Fossa)"&#13;
ID=ubuntu&#13;
ID_LIKE=debian&#13;
PRETTY_NAME="Ubuntu 20.04.1 LTS"&#13;
VERSION_ID="20.04"&#13;
HOME_URL="https://www.ubuntu.com/"&#13;
SUPPORT_URL="https://help.ubuntu.com/"&#13;
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"&#13;
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"&#13;
VERSION_CODENAME=focal&#13;
UBUNTU_CODENAME=focal</pre>&#13;
<p class="noindent">This file is designed to be readable from shell scripts (each line is an assigned variable). The variables in this example are mostly self-explanatory, but you can see the os-release(5) man page for more information. A systemd-based distro may also place information about the local machine (location, deployment, and so on) in the <em>/etc/machine-info</em> file. See the machine-info(5) man page for more information.</p>&#13;
<p class="indent">The <em>Linux Standard Base (LSB)</em> also defines <em>/etc/</em>distro<em>.release</em> and <em>/etc/ lsb-release</em> files that provide distro release information, and some distributions may include LSB information files. See the lsb_release(1) man page and <code>lsb_release</code> source code (it is a simple script) for more information. Here is one example:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/lsb-release</span>&#13;
DISTRIB_ID=LinuxMint&#13;
DISTRIB_RELEASE=20&#13;
DISTRIB_CODENAME=ulyana&#13;
DISTRIB_DESCRIPTION="Linux Mint 20 Ulyana"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>Some distros write version information to other small text files in the <em>/etc/</em> directory. For example, in Fedora:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/fedora-release</span>&#13;
Fedora release 33 (Thirty Three)</pre>&#13;
<p class="noindent">Debian stores information in the <em>/etc/debian_version</em> file. A search for all files matching <em>/etc/*release</em> or <em>/etc/*version</em> will provide the most common distro and release information files.</p>&#13;
<p class="indent">Some distros also put version and release information into the <em>/etc/issue</em> or <em>/etc/motd</em> files, which are displayed when a user logs in via the shell or network. For example:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/issue</span>&#13;
Welcome to openSUSE Tumbleweed 20201111 - Kernel \r (\l).</pre>&#13;
<p class="noindent">Rolling release distros will often use the date of the last update as the version number.</p>&#13;
<h4 class="h4" id="ch00lev2_90"><strong><em>Unique Machine ID</em></strong></h4>&#13;
<p class="noindent">Modern Linux systems have a unique identifier that’s created during installation. The <em>/etc/machine-id</em> file (may be copied or symlinked with the D-Bus machine ID stored in <em>/var/lib/dbus/machine-id</em>) contains a randomly generated 128-bit hexadecimal string, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/machine-id</span>&#13;
8635db7eed514661b9b1f0ad8b249ffd</pre>&#13;
<p class="noindent">This unique identification string can be used for matching identical copied/ duplicated machines deployed in multiple places, or for matching a system with full system backups. The creation timestamp of this file is a potential indicator of the installation time. See the machine-id(5) man page for details. Raspberry Pi images initially contain an empty <em>/etc/machine-id</em> file that’s initialized during the first boot.</p>&#13;
<p class="indent">POSIX-compliant systems also have a hostid that’s typically a hexadecimal representation of the IP address (derived from the <em>/etc/hosts</em> file or a DNS lookup). This ID can be stored in the <em>/etc/hostid</em> file (though most distros don’t have it) and is found on a running system by executing the <code>hostid</code> command or calling <code>gethostid()</code> from a program.</p>&#13;
<h4 class="h4" id="ch00lev2_91"><strong><em>System Hostname</em></strong></h4>&#13;
<p class="noindent">The machine’s hostname is another identifier. This hostname is set in the kernel at boot time or during network reconfiguration. The hostname can be manually specified during installation or dynamically assigned during DHCP network configuration. The system administrator chooses the hostname, which is likely to be unique among the machines under their responsibility or within a DNS domain. However, the hostname is not guaranteed</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_187"/>to be unique in general. The name of the system is typically stored in the <em>/etc/hostname</em> file in a non-FQDN format. Fully qualified domain names (FQDNs) are allowed but not preferred.</p>&#13;
<p class="indent">If a hostname is specified in <em>/etc/hostname</em> (or another distro-specific location) or returned from a DHCP request, the running kernel is configured accordingly. Hosts with multiple interfaces, multiple IP addresses (each resolving to a different DNS name), or roaming machines (laptops and mobile devices) will still have one hostname representing the whole system. Network configuration involving hostnames, DNS domain names, interfaces, and so on is explained in <a href="ch08.xhtml">Chapter 8</a>.</p>&#13;
<h3 class="h3" id="ch00lev1_33"><strong>Distro Installer Analysis</strong></h3>&#13;
<p class="noindent">Analysis of the initial installation of a Linux system involves identifying the locations of logs and files containing potentially interesting information. An initial Linux installation can be either user-interactive or automated/unattended (enterprise deployment). In both cases, a set of basic configuration parameters are specified to guide the installation process. The typical decision information needed for installing a system is as follows:</p>&#13;
<ul>&#13;
<li class="noindent">Language, locale, keyboard layout, and time zone</li>&#13;
<li class="noindent">Drive partitioning, filesystems, and mount points</li>&#13;
<li class="noindent">Encryption of drives or home directories</li>&#13;
<li class="noindent">Initial username and password, and root password (unless using sudo)</li>&#13;
<li class="noindent">Basic system type (choice of desktop, headless server, and so on)</li>&#13;
<li class="noindent">Basic services (web server, remote access with SSH, printing, and so on)</li>&#13;
<li class="noindent">Choice of software repositories, non-free software</li>&#13;
</ul>&#13;
<p class="noindent">Automated enterprise installations (such as Red Hat’s Kickstart or SUSE’s AutoYaST, for example) are outside the scope of this book.</p>&#13;
<p class="indent">When analyzing the installation process, a digital forensic investigator is trying to answer several basic questions:</p>&#13;
<ul>&#13;
<li class="noindent">When was the system installed?</li>&#13;
<li class="noindent">What were the initial settings provided during install?</li>&#13;
<li class="noindent">Is there any useful or interesting information that was saved?</li>&#13;
<li class="noindent">Was there anything unusual about the installation (or about the repositories)?</li>&#13;
</ul>&#13;
<p class="noindent">Depending on the type of incident or investigation in progress, other more specific questions related to the installation will need answering.</p>&#13;
<p class="indent">When building timelines, keep in mind that a system installation is not a single point in time, but rather a period with starting and ending timestamps. <span epub:type="pagebreak" id="page_188"/>Depending on the speed of the machine, network connection, and number of installed packages, an installation may take more than a few minutes to complete. If an installation is interactive, and a user is not there to answer the prompted questions, the installation may appear to take hours or more to complete (whenever the user returned to the installation prompt).</p>&#13;
<p class="indent">Also note that the starting timestamps of an installation may be unreliable. When a computer is booted with the installation media, time has not yet been synchronized and the time zone has not been chosen. The installer might still generate logs, but it will use whatever time the PC or virtual machine (VM) host happened to have (in some obscure cases, this time difference could also be interesting from an investigative perspective). Once the network has been configured, the time zone has been determined, and the clock has been synchronized, the logs will contain more reliable timestamps.</p>&#13;
<p class="indent">A systemd service called <code>systemd-firstboot</code> is able to provide automated or interactive configuration on the first boot of a system. See the systemd-firstboot(1) man page for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_92"><strong><em>Debian Installer</em></strong></h4>&#13;
<p class="noindent">The initial installation of a Debian system uses <em>Debian Installer</em>.<sup><a id="ch07foot02" href="footnotes.xhtml#ch07foot_02">2</a></sup> Debian Installer itself is a Linux system that can be booted from CD/DVD, USB stick, over a network, or from a downloaded image file (for VMs). The documentation defines multiple stages of a Debian installation:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Booting and initialization</strong> Initial booting of the installer; choice of keyboard, language, and locale; and hardware detection</p>&#13;
<p class="noindentin"><strong>Loading additional components</strong> Choice of mirror, fetching and unpacking additional components</p>&#13;
<p class="noindentin"><strong>Network configuration</strong> Detect network hardware and configure network</p>&#13;
<p class="noindentin"><strong>Partitioning</strong> Detect attached storage, partition drives, create file systems, and define mount points</p>&#13;
<p class="noindentin"><strong>Installing the target system</strong> Install base system and user-selected packages, set up user accounts, finalize install, and reboot</p>&#13;
</div>&#13;
<p class="indent">Logs from a completed Debian installation are saved in <em>/var/log/installer/</em> and provide a snapshot of information from the time the initial installation was made. This snapshot can be interesting. For example, consider this installer log directory from a typical Debian installation:</p>&#13;
<pre>$ <span class="codestrong1">ls -lR /var/log/installer/</span>&#13;
/var/log/installer/:&#13;
total 1208&#13;
<span epub:type="pagebreak" id="page_189"/>drwxr-xr-x 2 root root   4096 Mar 5 02:43 cdebconf&#13;
-rw-r--r-- 1 root root  35283 Mar 5 02:43 hardware-summary&#13;
-rw-r--r-- 1 root root    160 Mar 5 02:43 lsb-release&#13;
-rw------- 1 root root  81362 Mar 5 02:43 partman&#13;
-rw-r--r-- 1 root root  72544 Mar 5 02:43 status&#13;
-rw------- 1 root root 988956 Mar 5 02:43 syslog&#13;
-rw------- 1 root root  43336 Mar 5 02:43 Xorg.0.log&#13;
&#13;
/var/log/installer/cdebconf:&#13;
total 14668&#13;
-rw------- 1 root root   119844 Mar 5 02:43 questions.dat&#13;
-rw------- 1 root root 14896576 Mar 5 02:43 templates.dat</pre>&#13;
<p class="noindent">The <em>hardware-summary</em> file provides information about the machine hardware at the time of installation, including a list of devices on the PCI bus and attached USB devices. The <em>lsb-release</em> file contains information about the originally installed release (before any upgrades). The <em>partman</em> file is the output from the drive setup process, and it includes storage devices, partition information, and created filesystems. The <em>status</em> file contains a detailed list of all installed packages (including versions) at the time of installation. The <em>syslog</em> file contains information sent to the standard syslog during the entire installation process (with timestamps). Desktop systems may also have an <em>Xorg.0.log</em> file containing the startup output of the X11 server, which has information about the graphics card, monitors, and attached peripheral input devices. The <em>cdebconf</em> package has files containing the options and choices made during the install process. These files provide insight into the system’s state at the time of installation.</p>&#13;
<p class="indent">Ubuntu-based systems have a bootable live system (called <em>Casper</em>) with a graphical installer program called <em>Ubiquity</em>. The Debian Installer is used as a backend to Ubiquity and leaves files in <em>/var/log/installer/</em> but with slightly different contents. Following is an example:</p>&#13;
<pre>$ <span class="codestrong1">ls -l /var/log/installer/</span>&#13;
total 1096&#13;
-rw------- 1 root root   1529 Mar 5 11:22 casper.log&#13;
-rw------- 1 root root 577894 Mar 5 11:22 debug&#13;
-rw-r--r-- 1 root root 391427 Mar 5 11:22 initial-status.gz&#13;
-rw-r--r-- 1 root root     56 Mar 5 11:22 media-info&#13;
-rw------- 1 root root 137711 Mar 5 11:22 syslog</pre>&#13;
<p class="noindent">The <em>casper.log</em> and <em>debug</em> files are the output from the installer scripts and contain error messages. The <em>media-info</em> file shows the release information at the time of install. Some Ubuntu-based distros (Mint, for example) may also have a version file. The <em>initial-status.gz</em> file (compressed) contains a list of initially installed packages.</p>&#13;
<h4 class="h4" id="ch00lev2_93"><span epub:type="pagebreak" id="page_190"/><strong><em>Raspberry Pi Raspian</em></strong></h4>&#13;
<p class="noindent">The Raspberry Pi uses a Debian-based distribution called Raspian. Debian Installer isn’t necessary, because Raspian is available as a preinstalled image file for download. This preinstalled image is available in two formats:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>NOOBS</strong> A beginner-friendly process in which the user formats the SD card (FAT) and copies files and no special tools needed</p>&#13;
<p class="noindentin"><strong>Drive image</strong> A raw image that needs to be unzipped and transferred to the SD card with <code>dd</code> or a similar tool</p>&#13;
</div>&#13;
<p class="indent">Because there is no “installation” in the usual sense, investigators will want to determine the time when the user first powered on the Pi and saved the initial settings. However, finding this initial setup time is tricky for a number of reasons. The initial filesystem timestamps are from the Raspian image that was downloaded, and not created from local installer scripts. The Raspberry Pi has no hardware clock with battery backup,<sup><a id="ch07foot03" href="footnotes.xhtml#ch07foot_03">3</a></sup> so every time the Pi is powered on, the clock starts with the Unix epoch (00:00 January 1, 1970). The booting operating system sets the clock to the time nearest to the last power-off until network time synchronization is achieved (see <a href="ch09.xhtml">Chapter 9</a> for more details on system time). By default, the filesystem is mounted with the <code>noatime</code> option, so the last-accessed timestamps are not updated. Other timestamps may have been updated and log entries written before the correct time was established, rendering those times unreliable.</p>&#13;
<p class="indent">When a Raspberry Pi is used for the first time, the filesystem is resized to fit the SD card. After a reboot, the <code>piwiz</code> application starts,<sup><a id="ch07foot04" href="footnotes.xhtml#ch07foot_04">4</a></sup> which allows the user to configure a network, reset the password (the default is <code>raspberry</code>), and specify the country, language, and time-zone settings. The <code>piwiz</code> app starts automatically from the file <em>/etc/xdg/autostart/piwiz.desktop</em>, which is deleted after the user provides their initial preferences. If this <em>piwiz.desktop</em> file still exists, it indicates an unused Raspberry Pi installation. If your filesystem forensic analysis tool can determine the time when the file <em>/etc/xdg/ autostart/piwiz.desktop</em> was deleted, that would indicate an approximate time of a completed installation. An alternative is to find the timestamp of the first entry in the <em>/var/log/dpkg.log</em> file (or the oldest saved log rotation). Packages are updated for the first time when <code>piwiz</code> runs, which happens only after time synchronization was successful.</p>&#13;
<h4 class="h4" id="ch00lev2_94"><strong><em>Fedora Anaconda</em></strong></h4>&#13;
<p class="noindent">Fedora-based systems (CentOS, Red Hat, and so on) use an installer called Anaconda.<sup><a id="ch07foot05" href="footnotes.xhtml#ch07foot_05">5</a></sup> After the initial desktop installation is complete and the new system reboots for the first time, a separate application called <code>Initial Setup</code> is run. This application can provide additional configuration possibilities, including the user acceptance of end-user licensing agreements (EULAs).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/>The Anaconda installer leaves logfiles of the initial installation in <em>/var/ log/anaconda/</em> that look like this:</p>&#13;
<pre># <span class="codestrong1">ls -l /var/log/anaconda/</span>&#13;
total 3928&#13;
-rw-------. 1 root root   36679 Mar 24 11:01 anaconda.log&#13;
-rw-------. 1 root root    3031 Mar 24 11:01 dbus.log&#13;
-rw-------. 1 root root  120343 Mar 24 11:01 dnf.librepo.log&#13;
-rw-------. 1 root root     419 Mar 24 11:01 hawkey.log&#13;
-rw-------. 1 root root 2549099 Mar 24 11:01 journal.log&#13;
-rw-------. 1 root root       0 Mar 24 11:01 ks-script-sot00yjg.log&#13;
-rw-------. 1 root root  195487 Mar 24 11:01 lvm.log&#13;
-rw-------. 1 root root  327396 Mar 24 11:01 packaging.log&#13;
-rw-------. 1 root root    7044 Mar 24 11:01 program.log&#13;
-rw-------. 1 root root    2887 Mar 24 11:01 storage.log&#13;
-rw-------. 1 root root  738078 Mar 24 11:01 syslog&#13;
-rw-------. 1 root root   22142 Mar 24 11:01 X.log</pre>&#13;
<p class="noindent">The <em>anaconda.log</em> file tracks the progress of various installation tasks. The <em>X.log</em> file shows the output from the Xorg server used by Anaconda and contains information about the graphics card, monitors, and attached peripheral input devices at the time of installation.</p>&#13;
<p class="indent">The <em>journal.log</em> and <em>syslog</em> files are very similar, with the main difference being that <em>journal.log</em> shows more dracut activity (see <a href="ch06.xhtml">Chapter 6</a>). They both include the initialization of the kernel (dmesg output) and systemd at the time of first installation. These logs can help determine the start and end times of an installation. Information about storage devices, partitioning, and volume management can be found in <em>storage.log</em> and <em>lvm.log</em>. The <em>dnf.librepo.log</em> file lists all of the packages downloaded for installation. The <em>ks-script-*.log</em> files contain log output from kickstart scripts. Other files contain logs with D-Bus activity and library calls. See <em><a href="https://fedoraproject.org/wiki/Anaconda/Logging">https://fedoraproject.org/wiki/Anaconda/Logging</a></em> for more information about Anaconda logging.</p>&#13;
<p class="indent">These logs provide information about the user-specified configuration, the hardware of the original machine, packages installed, and storage configuration at the time of installation.</p>&#13;
<h4 class="h4" id="ch00lev2_95"><strong><em>SUSE YaST</em></strong></h4>&#13;
<p class="noindent">SUSE Linux has one of the oldest distro installers still maintained today. <em>YaST</em>, or “Yet another Setup Tool,” was designed to combine the initial installation with other system configuration tasks into one tool.<sup><a id="ch07foot06" href="footnotes.xhtml#ch07foot_06">6</a></sup> YaST can be used to install the system, set up peripherals like printers, install packages, configure hardware, configure the network, and more. SUSE also provides AutoYaST for unattended enterprise deployment.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>The YaST log directory is <em>/var/log/YaST2/</em>. It contains logs from both the installation and other regular configuration tasks. Logs from the installation are stored in the compressed archive file <em>yast-installation-logs.tar.xz</em>, and are of particular interest from a forensics perspective. The following is an example (partial) list of contents:<sup><a id="ch07foot07" href="footnotes.xhtml#ch07foot_07">7</a></sup></p>&#13;
<pre># <span class="codestrong1">tar -tvf yast-installation-logs.tar.xz</span>&#13;
-rw-r--r-- root/root     938 2020-03-05 08:35 etc/X11/xorg.conf&#13;
drwxr-xr-x root/root       0 2020-02-12 01:14 etc/X11/xorg.conf.d/&#13;
-rw-r--r-- root/root     563 2020-03-03 20:30 linuxrc.config&#13;
-rw-r--r-- root/root     322 2020-02-26 01:00 etc/os-release&#13;
...&#13;
-rw-r--r-- root/root   21188 2020-03-05 08:35 Xorg.0.log&#13;
-rw-r--r-- root/root   25957 2020-03-05 08:38 linuxrc.log&#13;
-rw-r--r-- root/root   17493 2020-03-05 08:34 wickedd.log&#13;
-rw-r--r-- root/root   46053 2020-03-05 08:35 boot.msg&#13;
-rw-r--r-- root/root  104518 2020-03-05 08:55 messages&#13;
-rw-r--r-- root/root    5224 2020-03-05 08:55 dmesg&#13;
-rw-r--r-- root/root      17 2020-03-05 08:55 journalctl-dmesg&#13;
-rw-r--r-- root/root     738 2020-03-05 08:55 install.inf&#13;
-rw------- root/root    3839 2020-03-05 08:55 pbl-target.log&#13;
-rw-r--r-- root/root     141 2020-03-05 08:55 rpm-qa&#13;
-rw-r--r-- root/root   27563 2020-03-05 08:55 _packages.root</pre>&#13;
<p class="noindent">The release information at the time of install is found in the sub-directory <code>etc/os-release</code>. The file <em>Xorg.0.log</em> contains information about the graphics card, monitors, and attached peripheral input devices at the time of installation. The <em>boot.msg</em>, <em>dmesg</em>, and <em>messages</em> files contain logs from the installation, the kernel ring buffer, and other information at the time of install. The <em>wickedd.log</em> file from the network manager records the configuring of the network, including the system’s IP and other network configuration from the time of installation.</p>&#13;
<p class="indent">The start and end times of the logfile entries from this directory provide an approximate time period of when the installation took place.</p>&#13;
<h4 class="h4" id="ch00lev2_96"><strong><em>Arch Linux</em></strong></h4>&#13;
<p class="noindent">The native Arch Linux system does not have a comfortable installer. Booting the Arch installation media drops the user into a root shell with a reference to the wiki installation guide (earlier versions had an <em>install.txt</em> file containing further instructions). The user is expected to create the partitions and filesystem manually, and then run the <code>pacstrap</code> script that populates the mounted install target directory. After that, the user chroots into the directory and manually completes the installation. The installation process is documented at <em><a href="https://wiki.archlinux.org/index.php/Installation_guide">https://wiki.archlinux.org/index.php/Installation_guide</a></em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_193"/>A basic installer script called <code>archinstall</code> is included with Arch Linux install media. If used, this script logs the initial configuration settings and activity in <em>/var/log/archinstall/install.log</em>.</p>&#13;
<p class="indent">The creation (<code>Birth:</code>) timestamp of the root directory (if the filesystem supports it) is a rough indicator of the start of installation:</p>&#13;
<pre># <span class="codestrong1">stat /</span>&#13;
  File: /&#13;
  Size: 4096       Blocks: 16     IO Block: 4096  directory&#13;
Device: fe01h/65025dInode: 2       Links: 17&#13;
Access: (0755/drwxr-xr-x) Uid: (  0/  root)  Gid: (  0/  root)&#13;
Access: 2020-03-05 10:00:42.629999954 +0100&#13;
Modify: 2020-02-23 10:29:55.000000000 +0100&#13;
Change: 2020-03-05 09:59:36.896666639 +0100&#13;
 Birth: 2020-03-05 09:58:55.000000000 +0100</pre>&#13;
<p class="indent">Installing Arch is a manual and ongoing process. A user may continue installing and tweaking the system indefinitely, and an install “end” time may not make sense in this context.</p>&#13;
<p class="indent">The terse and non-intuitive process of installing Arch Linux has spawned several distros for users who want all the benefits of a bleeding-edge rolling distro, but with a comfortable installation. The most popular Arch-based distro is Manjaro.</p>&#13;
<p class="indent">Manjaro’s installer is called Calamares, and it provides minimal logging of the installation process. These logs are found in <em>/var/log/Calamares.log</em>. The content of <em>Calamares.log</em> includes specified configuration (time zone, locale, and so on), partition information, user information, and more. Calamares (on Manjaro) doesn’t log an IP address, but it does perform a Geo-IP lookup to determine the location of the system being installed:</p>&#13;
<pre># <span class="codestrong1">grep Geo /var/log/Calamares.log</span>&#13;
2020-03-05 - 08:57:31 [6]: GeoIP result for welcome= "CH"&#13;
2020-03-05 - 08:57:33 [6]: GeoIP reporting "Europe/Zurich"</pre>&#13;
<p class="indent">Calamares has become well known because of Manjaro, but it was developed with the intention of being a general installer for any distribution. See <em><a href="https://calamares.io/">https://calamares.io/</a></em> for more information on Calamares.</p>&#13;
<h3 class="h3" id="ch00lev1_34"><strong>Package File Format Analysis</strong></h3>&#13;
<p class="noindent">This section covers the file formats of the individual software packages used in common Linux distributions. Linux distribution software packages are single archive files containing all the information and files needed to install and remove them from the Linux system. In addition, Linux systems typically have package management systems that keep track of installed packages, manage dependencies, perform updates, and so on.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_194"/>Analysis of a software package file can reveal interesting artifacts. Some forensic analysis tasks that can be performed on a package file include:</p>&#13;
<ul>&#13;
<li class="noindent">Discovering when a package was built</li>&#13;
<li class="noindent">Verifying package integrity</li>&#13;
<li class="noindent">Showing package metadata</li>&#13;
<li class="noindent">Listing package file contents</li>&#13;
<li class="noindent">Extracting supporting scripts</li>&#13;
<li class="noindent">Extracting individual files</li>&#13;
<li class="noindent">Identifying additional timestamps</li>&#13;
</ul>&#13;
<p class="noindent">In addition, a vulnerability assessment may involve matching the version numbers of individual packages with known published vulnerabilities; for example, matching a particular software version installed on a system with a CVE published by Mitre (<em><a href="https://cve.mitre.org/">https://cve.mitre.org/</a></em>). This is typically the task of an enterprise vulnerability management function within an organization.</p>&#13;
<h4 class="h4" id="ch00lev2_97"><strong><em>Debian Binary Package Format</em></strong></h4>&#13;
<p class="noindent">The Debian binary package format (DEB), is used by Debian and Debian-based distributions. See the deb(5) man page on a Debian or Debian-based system for more information. A DEB file has the <em>*.deb</em> extension and an initial magic string of seven characters (<code>!&lt;arch&gt;</code>). <a href="ch07.xhtml#ch07fig01">Figure 7-1</a> on the following page shows the structure of a DEB file.</p>&#13;
<p class="indent">DEB files use the <code>ar</code> archive format and contain three standard components. In this example, the <code>ed</code> package (a line-oriented text editor) is listed using the GNU <code>ar</code> command:</p>&#13;
<pre>$ <span class="codestrong1">ar -tv ed_1.15-1_amd64.deb</span>&#13;
rw-r--r-- 0/0     4 Jan 3 15:07 2019 debian-binary&#13;
rw-r--r-- 0/0  1160 Jan 3 15:07 2019 control.tar.xz&#13;
rw-r--r-- 0/0 58372 Jan 3 15:07 2019 data.tar.xz</pre>&#13;
<p class="noindent">In this example, the flags (<code>-tv</code>) for <code>ar</code> specify a verbose listing of the contents. The file timestamps indicate when the DEB package archive was built.</p>&#13;
<p class="indent">The three files in the archive have the following contents:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>debian-binary</em></strong> A file containing the package format version string</p>&#13;
<p class="noindentin"><strong><em>control</em></strong> A compressed archive with scripts/metadata about the package</p>&#13;
<p class="noindentin"><strong><em>data</em></strong> A compressed archive containing the files to be installed</p>&#13;
</div>&#13;
<p class="noindent">These components can be extracted with <code>ar</code>:</p>&#13;
<pre>$ <span class="codestrong1">ar -xov ed_1.15-1_amd64.deb</span>&#13;
x - debian-binary&#13;
x - control.tar.xz&#13;
x - data.tar.xz</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_195"/>The (<code>-xov</code>) flags instruct <code>ar</code> to extract files, keep original timestamps, and show verbose output. The <em>control.tar.xz</em> and <em>data.tar.xz</em> files are compressed archives that can be further examined.</p>&#13;
<div class="image"><img id="ch07fig01" src="Images/ch07fig01.jpg" alt="Image" width="591" height="971"/></div>&#13;
<p class="figcap"><em>Figure 7-1: Debian “DEB” package format (modified from Wikipedia:</em> <span class="normal"><a href="https://upload.wikimedia.org/wikipedia/commons/6/67/Deb_File_Structure.svg">https://upload.wikimedia.org/wikipedia/commons/6/67/Deb_File_Structure.svg</a></span><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>The <em>debian-binary</em> file contains a single line with the package format version number (2.0). To list the contents of the archives, we rely on <code>tar</code> to decompress the file and list the archive contents:</p>&#13;
<pre>$ <span class="codestrong1">cat debian-binary</span>&#13;
2.0&#13;
$ <span class="codestrong1">tar -tvf control.tar.xz</span>&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./&#13;
-rw-r--r-- root/root     506 2019-01-03 15:07 ./control&#13;
-rw-r--r-- root/root     635 2019-01-03 15:07 ./md5sums&#13;
-rwxr-xr-x root/root     287 2019-01-03 15:07 ./postinst&#13;
-rwxr-xr-x root/root     102 2019-01-03 15:07 ./prerm&#13;
$ <span class="codestrong1">tar -tvf data.tar.xz</span>&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./bin/&#13;
-rwxr-xr-x root/root   55424 2019-01-03 15:07 ./bin/ed&#13;
-rwxr-xr-x root/root      89 2019-01-03 15:07 ./bin/red&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./usr/&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./usr/share/&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./usr/share/doc/&#13;
drwxr-xr-x root/root       0 2019-01-03 15:07 ./usr/share/doc/ed/&#13;
-rw-r--r-- root/root     931 2012-04-28 19:56 ./usr/share/doc/ed/AUTHORS&#13;
-rw-r--r-- root/root     576 2019-01-01 19:04 ./usr/share/doc/ed/NEWS.gz&#13;
-rw-r--r-- root/root    2473 2019-01-01 18:57 ./usr/share/doc/ed/README.gz&#13;
-rw-r--r-- root/root     296 2016-04-05 20:28 ./usr/share/doc/ed/TODO&#13;
...</pre>&#13;
<p class="indent">If we want to extract a particular file from the <em>*.tar.xz</em> archives, we can use the same command, but give <code>tar</code> specific instructions to extract the file:</p>&#13;
<pre>$ <span class="codestrong1">tar xvf control.tar.xz ./control</span>&#13;
./control&#13;
$ <span class="codestrong1">cat ./control</span>&#13;
Package: ed&#13;
Version: 1.15-1&#13;
Architecture: amd64&#13;
Maintainer: Martin Zobel-Helas &lt;zobel@debian.org&gt;&#13;
Installed-Size: 111&#13;
Depends: libc6 (&gt;= 2.14)&#13;
Section: editors&#13;
Priority: optional&#13;
Multi-Arch: foreign&#13;
Homepage: https://www.gnu.org/software/ed/&#13;
Description: classic UNIX line editor&#13;
 ed is a line-oriented text editor. It is used to&#13;
...</pre>&#13;
<p class="noindent">The contents of the extracted control file list the version, CPU architecture, maintainer, dependencies, and other information. The <em>control</em> file is <span epub:type="pagebreak" id="page_197"/>mandatory and the other files within the <em>control.tar.xz</em> component are optional. Other common package control files include pre-install, post-install, pre-remove, and post-remove scripts (<code>preinst</code>, <code>postinst</code>, <code>prerm</code>, and <code>postrm</code>, respectively). See the deb-control(5) man page for more information about the <em>control</em> file.</p>&#13;
<p class="indent">We can extract files and directories from the data archive the same way. However, doing so will extract a full directory tree to the current working directory with the file(s) specified. It is also possible to extract individual files to <code>stdout</code>, allowing redirection to a file or program. In this example, a single file is extracted to <code>stdout</code> using the <code>-xOf</code> flags (<code>O</code> is an uppercase O, not zero):</p>&#13;
<pre>$ <span class="codestrong1">tar -xOf data.tar.xz ./usr/share/doc/ed/AUTHORS</span>&#13;
Since 2006 GNU ed is maintained by Antonio Diaz Diaz.&#13;
&#13;
Before version 0.3, GNU ed and its man page were written and maintained&#13;
(sic) by Andrew L. Moore.&#13;
&#13;
The original info page and GNUification of the code were graciously&#13;
provided by FranÃğois Pinard.&#13;
...</pre>&#13;
<p class="noindent">Individual files can be saved using file redirection, or the entire archive can be unpacked to a local analysis directory.</p>&#13;
<p class="indent">Although not mandatory, it is normal practice for DEB packages to contain a list of MD5 hashes to verify file integrity. These are stored in the <em>md5sums</em> file in the control component of the package archive file. This example displays the list of expected MD5 hashes in the package, followed by the verification of an installed binary file:</p>&#13;
<pre>$ <span class="codestrong1">tar -xOf control.tar.xz ./md5sums</span>&#13;
9a579bb0264c556fcfe65bda637d074c bin/ed&#13;
7ee1c42c8afd7a5fb6cccc6fa45c08de bin/red&#13;
318f005942f4d9ec2f19baa878f5bd14 usr/share/doc/ed/AUTHORS&#13;
ad0755fb50d4c9d4bc23ed6ac28c3419 usr/share/doc/ed/NEWS.gz&#13;
f45587004171c32898b11f8bc96ead3c usr/share/doc/ed/README.gz&#13;
3eef2fe85f82fbdb3cda1ee7ff9a2911 usr/share/doc/ed/TODO&#13;
...&#13;
$ <span class="codestrong1">md5sum /bin/ed</span>&#13;
9a579bb0264c556fcfe65bda637d074c /bin/ed</pre>&#13;
<p class="noindent">The <code>md5sum</code> tool has a flag (<code>-c</code>) that reads a list of MD5s from files like <em>md5sums</em> and performs checks on all files listed. There has been discussion of replacing the <em>md5sums</em> file with SHA hashes (for more information, see <em><a href="https://wiki.debian.org/Sha256sumsInPackages">https://wiki.debian.org/Sha256sumsInPackages</a></em>).</p>&#13;
<p class="indent">On a Debian system, the <code>dpkg-deb</code> tool performs all the above analysis tasks of listing files, extracting files, viewing control data, and so on. If you are trying to recover data from a corrupted DEB file, <code>ar -tO</code> (<code>O</code> is uppercase O, not <span epub:type="pagebreak" id="page_198"/>zero) will provide hexadecimal offsets to the three components, which may allow extraction with tools such as <code>dd</code>.</p>&#13;
<h4 class="h4" id="ch00lev2_98"><strong><em>Red Hat Package Manager</em></strong></h4>&#13;
<p class="noindent">The <em>Red Hat Package Manager (RPM)</em> is a binary package format developed by Red Hat. RPM packages can be identified by an <em>.rpm</em> extension and a four-byte magic string (<code>ED AB EE DB</code>) at the start of the file. The structure of RPM package files is documented in the <code>rpm</code> tool’s source code, and the file <em>/doc/manual/format</em> describes four logical sections:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Lead</strong> 96 bytes of “magic” and other information</p>&#13;
<p class="noindentin"><strong>Signature</strong> Collection of “digital signatures”</p>&#13;
<p class="noindentin"><strong>Header</strong> Holding area for all the package information (aka, metadata)</p>&#13;
<p class="noindentin"><strong>Payload</strong> Compressed archive of the file(s) in the package (aka, payload)</p>&#13;
</div>&#13;
<p class="indent">The <code>rpm</code> command, which can also be installed on non–Red Hat distros, can be used on a separate analysis machine. The query flag (<code>-q</code>) can be used to analyze various aspects of RPM files. In this example, the <code>-q</code> and <code>-i</code> flags provide an informational overview of the <em>xwrits</em> RPM package file:</p>&#13;
<pre>$ <span class="codestrong1">rpm -q -i xwrits-2.26-17.fc32.x86_64.rpm</span>&#13;
Name        : xwrits&#13;
Version     : 2.26&#13;
Release     : 17.fc32&#13;
Architecture: x86_64&#13;
Install Date: (not installed)&#13;
Group       : Unspecified&#13;
Size        : 183412&#13;
License     : GPLv2&#13;
Signature   : RSA/SHA256, Sat 01 Feb 2020 01:17:59 AM, Key ID 6c13026d12c944d0&#13;
Source RPM  : xwrits-2.26-17.fc32.src.rpm&#13;
Build Date  : Fri 31 Jan 2020 09:43:09 AM&#13;
Build Host  : buildvm-04.phx2.fedoraproject.org&#13;
Packager    : Fedora Project&#13;
Vendor      : Fedora Project&#13;
URL         : http://www.lcdf.org/xwrits/&#13;
Bug URL     : https://bugz.fedoraproject.org/xwrits&#13;
Summary     : Reminds you take wrist breaks&#13;
Description :&#13;
Xwrits reminds you to take wrist breaks, which&#13;
should help you prevent or manage a repetitive&#13;
stress injury. It pops up an X window when you&#13;
...</pre>&#13;
<p class="indent">You can view other RPM metadata with the following flags (after <code>rpm -q</code>) together with the RPM filename:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_199"/><span class="codestrong">-lv</span>    Verbose list of files in package</p>&#13;
<p class="noindentin"><span class="codestrong">–dump</span> Dumps file information (path, size, mtime, digest, mode, owner, group, isconfig, isdoc, rdev, and symlink)</p>&#13;
<p class="noindentin"><span class="codestrong">–changes</span> Displays change information for the package with full timestamps (<code>--changelog</code> is the same, but with dates)</p>&#13;
<p class="noindentin"><span class="codestrong">–provides</span> Lists the capabilities this package provides</p>&#13;
<p class="noindentin"><span class="codestrong">–enhances</span> Lists capabilities enhanced by package(s)</p>&#13;
<p class="noindentin"><span class="codestrong">–obsoletes</span> Lists packages this package obsoletes</p>&#13;
<p class="noindentin"><span class="codestrong">–conflicts</span> Lists capabilities this package conflicts with</p>&#13;
<p class="noindentin"><span class="codestrong">–requires</span> Lists capabilities on which this package depends</p>&#13;
<p class="noindentin"><span class="codestrong">–recommends</span> Lists capabilities recommended by package(s)</p>&#13;
<p class="noindentin"><span class="codestrong">–suggests</span> Lists capabilities suggested by package(s)</p>&#13;
<p class="noindentin"><span class="codestrong">–supplements</span> Lists capabilities supplemented by package(s)</p>&#13;
<p class="noindentin"><span class="codestrong">–scripts</span> Lists the package-specific scriptlet(s) that are used as part of the installation and deinstallation processes</p>&#13;
<p class="noindentin"><span class="codestrong">–filetriggers</span> Lists file-trigger scriptlets from package(s)</p>&#13;
<p class="noindentin"><span class="codestrong">–triggerscripts</span> Displays the trigger scripts, if any, that are contained in the package</p>&#13;
</div>&#13;
<p class="noindent">This list was taken from the rpm(9) man page, where you can find further information about rpm files. If a flag returns no output, that header field is empty.</p>&#13;
<p class="indent">Extracting individual files from RPM packages is a two-step process. First, the payload is extracted from the RPM, and then the desired file is extracted from that payload. The <code>rpm2cpio</code> and <code>rpm2archive</code> tools create a <em>cpio</em> or compressed tar (<em>*.tgz</em>) archive file containing the payload of the RPM. These are files that most file managers and forensic tools should be able to browse for file exporting/extracting.</p>&#13;
<p class="indent">In the following example, an individual file is extracted from an RPM. First, the RPM payload is extracted, and then an individual file is identified and extracted:</p>&#13;
<pre>$ <span class="codestrong1">rpm2cpio xwrits-2.26-17.fc32.x86_64.rpm &gt; xwrits-2.26-17.fc32.x86_64.rpm.cpio</span>&#13;
$ <span class="codestrong1">cpio -i -tv &lt; xwrits-2.26-17.fc32.x86_64.rpm.cpio</span>&#13;
...&#13;
-rw-r--r--  1 root   root     1557 Oct 16 2008 ./usr/share/doc/xwrits/README&#13;
...&#13;
$ <span class="codestrong1">cpio -i --to-stdout ./usr/share/doc/xwrits/README &lt; xwrits-2.26-17.fc32.x86_64.rpm.cpio</span>&#13;
XWRITS VERSION 2.25&#13;
===================&#13;
<span epub:type="pagebreak" id="page_200"/>ABOUT XWRITS&#13;
------------&#13;
  Xwrits was written when my wrists really hurt. They don't any more --&#13;
...</pre>&#13;
<p class="noindent">The <code>rpm2cpio</code> command is run and the output is redirected to a file (it can be any name, but for clarity, I used same filename with a <em>*.cpio</em> extension). The next command lists the <em>cpio</em> archive to find the desired file for extraction. The final command extracts the file to <code>stdout</code> where it can be piped or redirected to a program or file.</p>&#13;
<p class="indent">RPM package headers contain cryptographic signatures and hashes for verifying the payload’s integrity. Integrity checking is done with the <code>rpmkeys</code><sup><a id="ch07foot08" href="footnotes.xhtml#ch07foot_08">8</a></sup> command and can be viewed (verbose) with the <code>-Kv</code> flags:</p>&#13;
<pre>$ <span class="codestrong1">rpmkeys -Kv xwrits-2.26-17.fc32.x86_64.rpm</span>&#13;
xwrits-2.26-17.fc32.x86_64.rpm:&#13;
    Header V3 RSA/SHA256 Signature, key ID 12c944d0: OK&#13;
    Header SHA256 digest: OK&#13;
    Header SHA1 digest: OK&#13;
    Payload SHA256 digest: OK&#13;
    V3 RSA/SHA256 Signature, key ID 12c944d0: OK&#13;
    MD5 digest: OK</pre>&#13;
<p class="noindent">The GPG keys for signed RPM packages can be imported using the <code>rpmkeys</code> command. See the rpmkeys(8) man page for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_99"><strong><em>Arch Pacman Packages</em></strong></h4>&#13;
<p class="noindent">Packages for Arch Linux are compressed tar files. The default compression is currently in transition from XZ to Zstandard, with file extensions <em>*.xz</em> and <em>*.zst</em>, respectively.<sup><a id="ch07foot09" href="footnotes.xhtml#ch07foot_09">9</a></sup> The tar file contains both the package metadata and the files to be installed.</p>&#13;
<p class="indent">We can use <code>tar</code> to view the contents of a <code>pacman</code> package:</p>&#13;
<pre>$ <span class="codestrong1">tar -tvf acpi-1.7-2-x86_64.pkg.tar.xz</span>&#13;
-rw-r--r-- root/root     376 2017-08-15 19:06 .PKGINFO&#13;
-rw-r--r-- root/root    3239 2017-08-15 19:06 .BUILDINFO&#13;
-rw-r--r-- root/root     501 2017-08-15 19:06 .MTREE&#13;
drwxr-xr-x root/root       0 2017-08-15 19:06 usr/&#13;
drwxr-xr-x root/root       0 2017-08-15 19:06 usr/share/&#13;
drwxr-xr-x root/root       0 2017-08-15 19:06 usr/bin/&#13;
-rwxr-xr-x root/root   23560 2017-08-15 19:06 usr/bin/acpi&#13;
drwxr-xr-x root/root       0 2017-08-15 19:06 usr/share/man/&#13;
<span epub:type="pagebreak" id="page_201"/>drwxr-xr-x root/root       0 2017-08-15 19:06 usr/share/man/man1/&#13;
-rw-r--r-- root/root     729 2017-08-15 19:06 usr/share/man/man1/acpi.1.</pre>&#13;
<p class="noindent">This example shows the simplicity of the package format. Several files in the root of the archive contain the package metadata. They are described in the Arch Linux Wiki (<em><a href="https://wiki.archlinux.org/index.php/Creating_packages">https://wiki.archlinux.org/index.php/Creating_packages</a></em>) and include:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>.PKGINFO</em></strong> Contains all the metadata needed by <code>pacman</code> to deal with packages, dependencies, and so on.</p>&#13;
<p class="noindentin"><strong><em>.BUILDINFO</em></strong> Contains information needed for reproducible builds. This file is present only if a package is built with Pacman 5.1 or newer.</p>&#13;
<p class="noindentin"><strong><em>.MTREE</em></strong> Contains hashes and timestamps of the files, which are included in the local database so <code>pacman</code> can verify the package’s integrity.</p>&#13;
<p class="noindentin"><strong><em>.INSTALL</em></strong> An optional file used to execute commands after the install/upgrade/remove stage (this file is present only if specified in the <code>PKGBUILD</code>).</p>&#13;
<p class="noindentin"><strong><em>.Changelog</em></strong> An optional file kept by the package maintainer documenting the changes of the package.</p>&#13;
</div>&#13;
<p class="noindent">The <em>.PKGINFO</em> file is regular text and can be easily viewed, but using the <code>pacman</code> tool provides more complete output (including fields that are undefined). The <code>-Qip</code> flags specify a query operation, information option, and a package filename for a target, respectively:</p>&#13;
<pre>$ <span class="codestrong1">pacman -Qip acpi-1.7-2-x86_64.pkg.tar.xz</span>&#13;
Name            : acpi&#13;
Version         : 1.7-2&#13;
Description     : Client for battery, power, and thermal readings&#13;
Architecture    : x86_64&#13;
URL             : https://sourceforge.net/projects/acpiclient/files/acpiclient/&#13;
Licenses        : GPL2&#13;
Groups          : None&#13;
Provides        : None&#13;
Depends On      : glibc&#13;
Optional Deps   : None&#13;
Conflicts With  : None&#13;
Replaces        : None&#13;
Compressed Size : 10.47 KiB&#13;
Installed Size  : 24.00 KiB&#13;
Packager        : Alexander RÃÿdseth &lt;rodseth@gmail.com&gt;&#13;
Build Date      : Di 15 Aug 2017 19:06:50&#13;
Install Script  : No&#13;
Validated By    : None&#13;
Signatures      : None</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>The <em>.MTREE</em> file is a compressed list of timestamps, permissions, file sizes, and cryptographic hashes. We can extract it by piping the <code>tar</code> output into <code>zcat</code>:</p>&#13;
<pre>$ <span class="codestrong1">tar -xOf acpi-1.7-2-x86_64.pkg.tar.xz .MTREE | zcat</span>&#13;
#mtree&#13;
/set type=file uid=0 gid=0 mode=644&#13;
./.BUILDINFO time=1502816810.765987104 size=3239 md5digest=0fef5fa26593908cb0958537839f35d6&#13;
sha256digest=75eea1aee4d7f2698d662f226596a3ccf76e4958b57e8f1b7855f2eb7ca50ed5&#13;
./.PKGINFO time=1502816810.745986656 size=376 md5digest=c6f84aeb0bf74bb8a1ab6d0aa174cb13&#13;
sha256digest=83b005eb477b91912c0b782808cc0e87c27667e037766878651b39f49d56a797&#13;
/set mode=755&#13;
./usr time=1502816810.602650109 type=dir&#13;
./usr/bin time=1502816810.685985311 type=dir&#13;
./usr/bin/acpi time=1502816810.682651903 size=23560 md5digest=4ca57bd3b66a9afd517f49e13f19688f&#13;
sha256digest=c404597dc8498f3ff0c1cc026d76f7a3fe71ea729893916effdd59dd802b5181&#13;
./usr/share time=1502816810.592649885 type=dir&#13;
./usr/share/man time=1502816810.592649885 type=dir&#13;
./usr/share/man/man1 time=1502816810.699318943 type=dir&#13;
./usr/share/man/man1/acpi.1.gz time=1502816810.609316926 mode=644 size=729&#13;
md5digest=fb0da454221383771a9396afad250a44&#13;
sha256digest=952b21b357d7d881f15942e300e24825cb3530b2262640f43e13fba5a6750592</pre>&#13;
<p class="noindent">This can be used to verify the integrity of the files in the package and provides timestamps for timeline reconstruction. We can use this information to analyze packages that are rogue, malicious, or have been tampered with.</p>&#13;
<h3 class="h3" id="ch00lev1_35"><strong>Package Management System Analysis</strong></h3>&#13;
<p class="noindent">The previous section focused on the file formats of individual software packages before they are installed. Here we shift the focus to the package management systems for software already installed (or previously installed) on a machine. This includes analysis of the repositories from where packages were downloaded, where the package contents were placed on the filesystem, databases to track the installed packages, installation logs, and more.</p>&#13;
<p class="indent">A Linux distribution’s software packaging system typically has the following components:</p>&#13;
<ul>&#13;
<li class="noindent">Repositories to download compiled binary packages</li>&#13;
<li class="noindent">Repositories to download package source code</li>&#13;
<li class="noindent">Repositories with non-free or varying licenses</li>&#13;
<li class="noindent">Information to resolve dependencies and conflicts</li>&#13;
<li class="noindent">A database with a record of installed software</li>&#13;
<li class="noindent">Logfiles of package management activity (including uninstalls)</li>&#13;
<li class="noindent">Frontend user interfaces interacting with backend tools and libraries</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_203"/>Package management systems across Linux distributions are very similar. See <em><a href="https://wiki.archlinux.org/index.php/Pacman/Rosetta">https://wiki.archlinux.org/index.php/Pacman/Rosetta</a></em> for a comparison of package management commands.</p>&#13;
<p class="indent">From a forensics perspective, we can ask many questions related to package management, such as the following:</p>&#13;
<ul>&#13;
<li class="noindent">What packages are currently installed, and which versions?</li>&#13;
<li class="noindent">Who installed them, when, and how?</li>&#13;
<li class="noindent">Which packages were upgraded and when?</li>&#13;
<li class="noindent">Which packages were removed and when?</li>&#13;
<li class="noindent">Which repositories were used?</li>&#13;
<li class="noindent">Can we confirm the integrity of the packages?</li>&#13;
<li class="noindent">What logs, databases, and cached data can be analyzed?</li>&#13;
<li class="noindent">Given a particular file on the filesystem, to which package does it belong?</li>&#13;
<li class="noindent">What other timestamps are relevant?</li>&#13;
</ul>&#13;
<p class="noindent">Answering these questions will help reconstruct past activity, build timelines, and identify possible malicious or suspicious activity. Finding and validating cryptographic hashes can also be useful when using NSRL hashsets to exclude known software. Packages that have been removed may leave behind traces of custom or modified configuration files and data that was not deleted.</p>&#13;
<p class="indent">The next few sections describe the analysis of the most common distributions. Each section provides an introduction to the packaging system and describes the various files, databases, and directory locations that are of interest to a forensic examiner.</p>&#13;
<h4 class="h4" id="ch00lev2_100"><strong><em>Debian apt</em></strong></h4>&#13;
<p class="noindent">The Debian package management system is a collection of programs that manage package searching/selection, external repositories, downloads, dependency/conflict resolution, installation, removal, updates and upgrades, and other package housekeeping functions. The end user interacts with high-level programs like Apt, Aptitude, Synaptic, and others to choose which packages to install, remove, or upgrade. These high-level programs interact with the <code>dpkg</code> command,<sup><a id="ch07foot010" href="footnotes.xhtml#ch07foot_010">10</a></sup> which manages the installation, removal, and querying of packages on a Debian-based system. Forensic investigators are mainly interested in the current package state of a system, reconstructing past package activity, and identifying other interesting artifacts.</p>&#13;
<p class="indent">The current installed package state of a Debian-based system is stored in the <em>/var/lib/dpkg/status</em> file (the package “database”). This is a plaintext file with each package entry starting with the string <code>Package:</code> and ending with a <span epub:type="pagebreak" id="page_204"/>blank line (similar style to the email mbox format). Backup copies of this file are in the same directory, and may be named <em>status-old</em> or <em>/var/backups/ dpkg.status.*</em> (multiple copies of previous versions may also be available in compressed form).</p>&#13;
<p class="indent">The <em>status</em> file can be easily viewed and searched with any text editor or text-processing tool. In this example, the <code>awk</code><sup><a id="ch07foot011" href="footnotes.xhtml#ch07foot_011">11</a></sup> tool is used to search the status file for a package name (<code>Package: bc</code>) and print the entire block of information:</p>&#13;
<pre>$ <span class="codestrong1">awk</span> ' <span class="codestrong1">/^Package: bc$/ , /^$/</span> ' <span class="codestrong1">/var/lib/dpkg/status</span>&#13;
Package: bc&#13;
Status: install ok installed&#13;
Priority: standard&#13;
Section: math&#13;
Installed-Size: 233&#13;
Maintainer: Ryan Kavanagh &lt;rak@debian.org&gt;&#13;
Architecture: amd64&#13;
Multi-Arch: foreign&#13;
Source: bc (1.07.1-2)&#13;
Version: 1.07.1-2+b1&#13;
Depends: libc6 (&gt;= 2.14), libncurses6 (&gt;= 6), libreadline7 (&gt;= 6.0), libtinfo6 (&gt;= 6)&#13;
Description: GNU bc arbitrary precision calculator language&#13;
 GNU bc is an interactive algebraic language with arbitrary precision which&#13;
 follows the POSIX 1003.2 draft standard, with several extensions including&#13;
 multi-character variable names, an `else' statement and full Boolean&#13;
 expressions. GNU bc does not require the separate GNU dc program.&#13;
Homepage: http://ftp.gnu.org/gnu/bc/</pre>&#13;
<p class="indent">The Status: line is interesting from a forensic reconstruction perspective. A normal installed package file will have Status: install ok installed. Packages that have been removed but still have user-modified configuration files are listed with a status of Status: deinstall ok config-files. Some packages may have a Conffiles: line followed by several lines indicating configuration files an administrator might modify, and the MD5 hash of the originally installed version of the file. For example, the default configuration files of the Apache web server are shown here:</p>&#13;
<pre>Package: apache2&#13;
Status: install ok installed&#13;
...&#13;
Conffiles:&#13;
 /etc/apache2/apache2.conf 20589b50379161ebc8cb35f761af2646&#13;
...&#13;
 /etc/apache2/ports.conf a961f23471d985c2b819b652b7f64321&#13;
 /etc/apache2/sites-available/000-default.conf f3066f67070ab9b1ad9bab81ca05330a&#13;
 <span epub:type="pagebreak" id="page_205"/>/etc/apache2/sites-available/default-ssl.conf 801f4c746a88b4228596cb260a4220c4&#13;
 ...</pre>&#13;
<p class="noindent">The MD5 hashes can help identify configuration files that deviate from the package defaults. See the dpkg-query(1) man page for more information about the fields in the <em>status</em> file.</p>&#13;
<p class="indent">The <em>status</em> file does not contain installation timestamps. For installation dates, you must analyze the logfiles. Several logfiles record the activity of the package management system and the frontend package manager tools. Common package management logs found on Debian-based systems include the following:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>/var/log/dpkg.log</em></strong> <code>dpkg</code> activity, including changes to package status (install, remove, upgrade, and so on)</p>&#13;
<p class="noindentin"><strong><em>/var/log/apt/history.log</em></strong> Start/end times of <code>apt</code> commands and which user ran them</p>&#13;
<p class="noindentin"><strong><em>/var/log/apt/term.log</em></strong> Start/end times of <code>apt</code> command output (stdout)</p>&#13;
<p class="noindentin"><strong><em>/var/log/apt/eipp.log.*</em></strong> Logs the current state of the External Installation Planner Protocol (EIPP), a system that manages dependency ordering</p>&#13;
<p class="noindentin"><strong><em>/var/log/aptitude</em></strong> Aptitude actions that were run</p>&#13;
<p class="noindentin"><strong><em>/var/log/unattended-upgrades/*</em></strong> Logs from automated/unattended upgrades</p>&#13;
</div>&#13;
<p class="noindent">Rotated logs may be compressed and renamed to filenames with a number indicating the relative age of the logfile (<em>dpkg.log.1.gz</em>, for example). The larger the number, the older the log.</p>&#13;
<p class="indent">Configuration information for <code>dpkg</code> is stored in the <em>/etc/dpkg/</em> directory. Configuration information for <code>apt</code> is stored in the <em>/etc/apt/</em> directory. The <em>/etc/apt/</em> directory contains the <em>sources.list</em> and <em>sources.list.d/*</em> files. These files are interesting because they define the configured external repositories for a particular Debian release. Explicitly added (legitimate or rogue) repositories will be appended to this file or saved to a file in the <em>sources.list.d/</em> directory. Ubuntu also has Personal Package Archives (PPAs) that use its central Launchpad server to help users add sources for individual packages.</p>&#13;
<p class="indent">The <em>/var/lib/dpkg/info/</em> directory contains several files for each installed package (this is the metadata from the DEB files). This information includes the file list (<em>*.list</em>), cryptographic hashes (<em>*.md5sums</em>), preinstall/postinstall and remove scripts, and more. The <em>*.conffiles</em> (if they exist) are a potentially useful resource for forensic investigators, as they list the location of configuration files and are often modified by the system owner.</p>&#13;
<p class="indent">The <em>/var/cache/apt/archives/</em> directory contains <em>*.deb</em> files that have been downloaded in the past. The <em>/var/cache/debconf/</em> directory is a central location for package configuration information and templates. Of potential interest here is the <em>passwords.dat</em> file that contains system-generated passwords needed for local daemons.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>See the dpkg(1) and apt(8) man pages, as well as the Debian manual (<em><a href="https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_the_dpkg_command">https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_the_dpkg_command</a></em>) for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_101"><strong><em>Fedora dnf</em></strong></h4>&#13;
<p class="noindent">Fedora-based systems manage packages using <code>dnf</code> (Dandified Yum), the successor to yum (Yellow Dog Update Manager). The <code>dnf</code> tool is written in Python and uses the <code>librpm</code> library to manage the installed <code>rpm</code> packages.</p>&#13;
<p class="indent">The current installed package state is stored in a collection of Berkeley database files in the <em>/var/lib/rpm/</em> directory. The easiest way to analyze this is to use the <code>rpm</code> command on a separate analysis machine<sup><a id="ch07foot012" href="footnotes.xhtml#ch07foot_012">12</a></sup> with the <code>--dbpath</code> flag pointing to a read-only copy of the database files. For example, to list the installed packages in a collection of database files stored in a separate directory, use the <span class="codestrong">--dbpath</span> and <span class="codestrong">-qa</span> flags:</p>&#13;
<pre>$ <span class="codestrong1">rpm --dbpath=/evidence/ -qa</span>&#13;
...&#13;
rootfiles-8.1-25.fc31.noarch&#13;
evince-libs-3.34.2-1.fc31.x86_64&#13;
python3-3.7.6-2.fc31.x86_64&#13;
perl-Errno-1.30-450.fc31.x86_64&#13;
OpenEXR-libs-2.3.0-4.fc31.x86_64&#13;
man-pages-de-1.22-6.fc31.noarch&#13;
...</pre>&#13;
<p class="indent">To see the metadata for a specific installed package, use the <span class="codestrong">--dbpath</span> and <span class="codestrong">-qai</span> flags with the package name. Several examples using the Evince document viewer package are shown here:</p>&#13;
<pre>$ <span class="codestrong1">rpm --dbpath=/evidence/ -qai evince</span>&#13;
Name        : evince&#13;
Version     : 3.34.2&#13;
Release     : 1.fc31&#13;
Architecture: x86_64&#13;
Install Date: Tue Mar 3 06:21:23 2020&#13;
Group       : Unspecified&#13;
Size        : 9978355&#13;
License     : GPLv2+ and GPLv3+ and LGPLv2+ and MIT and Afmparse&#13;
Signature   : RSA/SHA256, Wed Nov 27 16:13:20 2019, Key ID 50cb390b3c3359c4&#13;
Source RPM  : evince-3.34.2-1.fc31.src.rpm&#13;
Build Date  : Wed Nov 27 16:00:47 2019&#13;
Build Host  : buildhw-02.phx2.fedoraproject.org&#13;
Packager    : Fedora Project&#13;
Vendor      : Fedora Project&#13;
URL         : https://wiki.gnome.org/Apps/Evince&#13;
<span epub:type="pagebreak" id="page_207"/>Bug URL     : https://bugz.fedoraproject.org/evince&#13;
Summary     : Document viewer&#13;
Description :&#13;
Evince is simple multi-page document viewer. It can display and print&#13;
...</pre>&#13;
<p class="indent">To see a list of files belonging to a package, use the <span class="codestrong">--dbpath</span> and <span class="codestrong">-ql</span> flags (lowercase letter L, as in “list”) flags:</p>&#13;
<pre>$ <span class="codestrong1">rpm --dbpath /evidence/ -ql evince</span>&#13;
/usr/bin/evince&#13;
/usr/bin/evince-previewer&#13;
/usr/bin/evince-thumbnailer&#13;
/usr/lib/.build-id&#13;
/usr/lib/.build-id/21&#13;
/usr/lib/.build-id/21/15823d155d8af74a2595fa9323de1ee2cf10b8&#13;
...</pre>&#13;
<p class="indent">To determine which package a file belongs to, use the <span class="codestrong">--dbpath</span> and <span class="codestrong">-qf</span> flags with the full path and filename:</p>&#13;
<pre>$ <span class="codestrong1">rpm --dbpath /evidence/ -qf /usr/bin/evince</span>&#13;
evince-3.34.2-1.fc31.x86_64</pre>&#13;
<p class="indent">All of these commands can be used with read-only offline copies of the RPM database files found in the <em>/var/lib/rpm/</em> directory of the Linux image under analysis. Be aware that running the <code>rpm</code> command on your forensic workstation will use the local RPM configuration (for example, <em>/usr/lib/rpm/ rpmrc</em>), but that shouldn’t affect the accuracy of the output shown in the examples above.</p>&#13;
<p class="indent">The RPM database files traditionally have been standard Berkeley DB files and could be analyzed individually with tools like <code>db_dump</code>. Fedora 33 transitioned to SQLite for the RPM database, and associated tools can be used to examine package data. In addition, the <em>/var/lib/dnf/</em> directory contains SQLite databases with dnf package information, allowing analysis with SQLite tools.</p>&#13;
<p class="indent">The <code>dnf</code> command generates multiple logs, which are stored in the <em>/var/ log/</em> directory and listed here:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/var/log/dnf.librepo.log</em></li>&#13;
<li class="noindent"><em>/var/log/dnf.log</em></li>&#13;
<li class="noindent"><em>/var/log/dnf.rpm.log</em></li>&#13;
<li class="noindent"><em>/var/log/dnf.librepo.log</em></li>&#13;
<li class="noindent"><em>/var/log/hawkey.log</em></li>&#13;
</ul>&#13;
<p class="noindent">Some of these are less interesting from a forensics perspective and may show only that a machine was online at a particular time (checking for updates, and so on).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>The <em>dnf.log</em> (or rotated versions) contain activity performed using the <code>dnf</code> command. Here’s an example:</p>&#13;
<pre>2020-08-03T19:56:04Z DEBUG DNF version: 4.2.23&#13;
2020-08-03T19:56:04Z DDEBUG Command: dnf install -y openssh-server&#13;
2020-08-03T19:56:04Z DDEBUG Installroot: /&#13;
2020-08-03T19:56:04Z DDEBUG Releasever: 32</pre>&#13;
<p class="noindent">Here, the <code>dnf install</code> command was used to install <code>openssh-server</code> at a particular time.</p>&#13;
<p class="indent">The configuration data for <code>dnf</code> is potentially found in several locations:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>/etc/dnf/</em></strong> Configuration data and modules for <code>dnf</code></p>&#13;
<p class="noindentin"><strong><em>/etc/rpm/</em></strong> Configuration data and macros for <code>rpm</code></p>&#13;
<p class="noindentin"><strong><em>/etc/yum.repos.d/</em></strong> Remote package repositories</p>&#13;
</div>&#13;
<p class="indent">See the dnf.conf(5) man page for more information about <code>dnf</code> configuration.</p>&#13;
<h4 class="h4" id="ch00lev2_102"><strong><em>SUSE zypper</em></strong></h4>&#13;
<p class="noindent">SUSE Linux originally had its own package manager tightly integrated with its YaST configuration tool. SUSE later switched to using RPM for the package format and developed the ZYpp package manager. The primary tool for interfacing with the ZYpp library (libzypp) is <code>zypper</code>. The configuration information is in the <em>/etc/zypp/zypper.conf</em> and <em>/etc/zypp/zypp.conf</em> files, which control the <code>zypper</code> tool and ZYpp library, respectively. The configuration files specify various parameters, including the locations of files and directories. See the zypper(8) man page for more information.</p>&#13;
<p class="indent">The ZYpp library calls the <code>rpm</code> tool to perform the low-level installation and removal tasks. Because the packages are standard RPMs, the installed package state can be analyzed in the same way as Fedora-based systems. The <em>/var/lib/rpm/</em> directory contains the installed package databases, as described in the previous section.</p>&#13;
<p class="indent">ZYpp has several detailed logs of package management activity. The <em>/var/log/zypp/history</em> log records the actions of the ZYpp library, which multiple frontend tools might use. The following example shows logs for the installation and removal of the <code>cowsay</code> package:</p>&#13;
<pre># cat /var/log/zypp/history&#13;
...&#13;
2020-04-11 12:38:20|command|root@pc1|'zypper' 'install' 'cowsay'|&#13;
2020-04-11 12:38:20|install|cowsay|3.03-5.2|noarch|root@pc1|download.opensuse.&#13;
org-oss| a28b7b36a4e2944679e550c57b000bf06078ede8fccf8dfbd92a821879ef8b80|&#13;
2020-04-11 12:42:52|command|root@pc1|'zypper' 'remove' 'cowsay'|&#13;
2020-04-11 12:42:52|remove |cowsay|3.03-5.2|noarch|root@pc1|&#13;
...</pre>&#13;
<p class="noindent">The log contains basic <code>libzypp</code> actions, including package install/remove, repository add/remove, repository changes, and the commands used.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_209"/>The <em>/var/log/zypper.log</em> file shows detailed activity of the <code>zypper</code> command line tool, and the <em>/var/log/pk_backend_zypp</em> has logs of PackageKit activity. Both of these logs contain a field with the local system’s hostname. This could be interesting from a forensics perspective if the hostname is dynamically generated from DHCP because it indicates the hostname during the time the tools were run. If the hostname is an FQDN, it could have a valid domain name resolving to an IP address.</p>&#13;
<p class="indent">The SUSE <code>zypper-log</code> tool can print formatted output of a <em>zypper.log</em> file:</p>&#13;
<pre>$ <span class="codestrong1">zypper-log -l zypper.log</span>&#13;
===============================================================================&#13;
Collect from zypper.log ...&#13;
&#13;
TIME                PID      VER   CMD&#13;
2020-08-03 09:08   1039  1.14.37   /usr/bin/zypper appstream-cache&#13;
2020-08-03 09:08   1074  1.14.37   /usr/bin/zypper -n purge-kernels&#13;
2020-08-03 09:08   1128  1.14.37   zypper -n lr&#13;
2020-11-12 20:52  29972  1.14.37   zypper search hex&#13;
2020-11-12 20:52  30002  1.14.37   zypper search kcrash&#13;
2020-11-12 20:52  30048  1.14.37   zypper search dr.conqi&#13;
2020-11-13 09:21   2475  1.14.37   zypper updaet&#13;
2020-11-13 09:21   2485  1.14.37   zypper -q subcommand&#13;
2020-11-13 09:21   2486  1.14.37   zypper -q -h&#13;
2020-11-13 09:21   2489  1.14.37   /usr/bin/zypper -q help&#13;
2020-11-13 09:21   2492  1.14.37   zypper update&#13;
2020-11-13 09:22   2536  1.14.37   zypper dup&#13;
2020-11-13 10:02    671  1.14.40   /usr/bin/zypper -n purge-kernels</pre>&#13;
<p class="noindent">This output is similar to shell history in that all <code>zypper</code> commands entered are shown, including misspelled or failed attempts. The <code>-l</code> (lowercase letter L) flag specifies the name of the logfile to use if the log has been copied to an analysis machine.</p>&#13;
<p class="indent">The configuration of repositories is stored in definition files in the <em>/etc/ repos.d/</em> and <em>/etc/services.d/</em> directories. Service definition files manage the repositories and contain the <code>lrf_dat</code> variable, which is a timestamp (in Unix epoch format) indicating the date of last refresh. Information about remote package repositories (metadata) is cached locally in the <em>/var/cache/zypp/*</em> directories.</p>&#13;
<p class="indent">Some SUSE installations are configured to save bug report information whenever a distribution upgrade (<code>zypper dist-upgrade</code>) is run. This will create a directory in <em>/var/log/updateTestcase-*</em>, where <em>*</em> is a date and time. The directory will contain compressed XML files of available repository packages and installed packages (such as <em>solver-system.xml.gz</em>).</p>&#13;
<p class="indent">The <code>zypper</code> tool can also be run as an interactive shell (<code>zypper shell</code>), in which case, histories of commands are stored in the <em>~/.zypper_history</em> file of the user who ran them.</p>&#13;
<p class="indent">The <em>/var/lib/zypp/</em> directory also contains persistent information about the installed system. A unique identifier is generated during installation <span epub:type="pagebreak" id="page_210"/>and used for statistics every time files are downloaded from SUSE. The file <em>AnonymousUniqueId</em> contains the string, as shown here:</p>&#13;
<pre># <span class="codestrong1">cat /var/lib/zypp/AnonymousUniqueId</span>&#13;
61d1c49b-2bee-4ff0-bc8b-1ba51f5f9ab2</pre>&#13;
<p class="noindent">This string is embedded in the HTTP user-agent (<code>X-ZYpp-AnonymousId:</code>) and sent to SUSE’s servers when files are requested.</p>&#13;
<h4 class="h4" id="ch00lev2_103"><strong><em>Arch pacman</em></strong></h4>&#13;
<p class="noindent">Arch Linux uses the <code>pacman</code> command line tool for downloading and managing packages. The configuration file <em>/etc/pacman.conf</em> is used to control how <code>pacman</code> and the associated <code>libalpm</code> library are used. Packages are fetched from remote mirror sites, which are configured in <em>/etc/pacman.d/mirrorlist</em> and used in the order listed.</p>&#13;
<p class="indent">Arch Linux systems typically install packages from one of four sources:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>core</em></strong> Packages needed for a basic operational Arch system</p>&#13;
<p class="noindentin"><strong><em>extra</em></strong> Packages that add non-core functionality (desktops and such)</p>&#13;
<p class="noindentin"><strong><em>community</em></strong> Packages from the Arch User Repository (AUR) that have sufficient community votes and are managed by trusted users (TUs)</p>&#13;
<p class="noindentin"><span class="codestrong">PKGBUILD</span> Community-driven scripts in the AUR to build a package from source or proprietary binaries (where trust is unknown)</p>&#13;
</div>&#13;
<p class="noindent">The first three sources are official Arch repositories with compiled binary packages. The list of available packages in the official repositories are synchronized with files in the <em>/var/lib/pacman/sync/</em> directory. These files are simply zipped tar archives (with a different filename extension) and can be extracted with regular tools:</p>&#13;
<pre>$ <span class="codestrong1">file /var/lib/pacman/sync/*</span> &#13;
/var/lib/pacman/sync/community.db: gzip compressed data, last modified:&#13;
Mon Apr 6 07:38:29 2020, from Unix, original size modulo 2^32 18120192&#13;
/var/lib/pacman/sync/core.db:   gzip compressed data, last modified:&#13;
Sun Apr 5 19:10:08 2020, from Unix, original size modulo 2^32 530944&#13;
/var/lib/pacman/sync/extra.db:   gzip compressed data, last modified:&#13;
Mon Apr 6 07:43:58 2020, from Unix, original size modulo 2^32 6829568&#13;
...&#13;
$ <span class="codestrong1">tar tvf /var/lib/pacman/sync/core.db</span>&#13;
drwxr-xr-x lfleischer/users 0 2019-11-13 00:49 acl-2.2.53-2/&#13;
-rw-r--r-- lfleischer/users 979 2019-11-13 00:49 acl-2.2.53-2/desc&#13;
drwxr-xr-x lfleischer/users  0 2020-04-04 07:11 amd-ucode-20200316.8eb0b28-1/&#13;
-rw-r--r-- lfleischer/users 972 2020-04-04 07:11 amd-ucode-20200316.8eb0b28-1/desc&#13;
drwxr-xr-x lfleischer/users  0 2020-01-09 08:14 archlinux-keyring-20200108-1/&#13;
-rw-r--r-- lfleischer/users 899 2020-01-09 08:14 archlinux-keyring-20200108-1/desc&#13;
...</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_211"/>The timestamps indicate when the repository package lists and individual packages were last updated.</p>&#13;
<p class="indent">The integrity of signed<sup><a id="ch07foot013" href="footnotes.xhtml#ch07foot_013">13</a></sup> packages and databases is verified using GnuPG and described in the pacman(8) man page. The GPG keys used to verify signatures are stored in the <em>/etc/pacman.d/gnupg/</em> directory.</p>&#13;
<p class="indent">The default location of installed package metadata is the <em>/var/lib/pacman/ local/</em> directory. A separate directory for every installed package exists on the system and contains these files:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>desc</em></strong> Provides a description of the installed package (the metadata) and an install timestamp</p>&#13;
<p class="noindentin"><strong><em>files</em></strong> A list of files and directories installed by the package</p>&#13;
<p class="noindentin"><strong><em>mtree</em></strong> A zipped text file with information about individual files and directories</p>&#13;
<p class="noindentin"><strong><em>install</em></strong> An optional file containing commands after install, upgrade, or removal</p>&#13;
<p class="noindentin"><strong><em>changelog</em></strong> An optional file documenting changes to the package</p>&#13;
</div>&#13;
<p class="noindent">These correspond to the files listed earlier when describing the Arch Linux package format.</p>&#13;
<p class="indent">The <em>mtree</em> file contains the package’s filenames, timestamps, cryptographic hashes, and permissions needed to install the package. See the mtree(5) man page for more information about the format. The contents of <em>mtree</em> are gzip-compressed (but without a filename extension) and can be viewed with <code>zless</code> or <code>zcat</code>. In this example, the <em>mtree</em> file from the sfsimage<sup><a id="ch07foot014" href="footnotes.xhtml#ch07foot_014">14</a></sup> package is analyzed:</p>&#13;
<pre>$ <span class="codestrong1">zcat /var/lib/pacman/local/sfsimage-1.0-1/mtree</span>&#13;
#mtree&#13;
/set type=file uid=0 gid=0 mode=644&#13;
./.BUILDINFO time=1586180739.0 size=58974 md5digest=352b893f2396fc6454c78253d5a3be5a&#13;
sha256digest=681193c404391246a96003d4372c248df6a977a05127bc64d49e1610fbea1c72&#13;
./.PKGINFO time=1586180739.0 size=422 md5digest=32a5ef1a7eab5b1f41def6ac57829a55&#13;
sha256digest=3dd26a5ca710e70e7c9b7c5b13043d6d3b8e90f17a89005c7871313d5e49a426&#13;
...&#13;
./usr/bin/sfsimage time=1586180739.0 size=10168&#13;
md5digest=e3dcfcb6d3ab39c64d733d8fa61c3097&#13;
sha256digest=1c19cc2697e214cabed75bd49e3781667d4abb120fd231f9bdbbf0fa2748c4a3&#13;
...&#13;
./usr/share/man/man1/sfsimage.1.gz time=1586180739.0 mode=644 size=1641&#13;
md5digest=2d868b34b38a3b46ad8cac6fba20a323&#13;
sha256digest=cb8f7d824f7e30063695725c897adde71938489d5e84e0aa2db93b8945aea4c1</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_212"/>When a package is removed, the installed files are deleted together with this package metadata directory.</p>&#13;
<p class="indent">The history of package installation, updates, and removal is logged in the <em>/var/log/pacman.log</em> file. The following example shows a package being installed and then removed:</p>&#13;
<pre>$ cat /var/log/pacman.log&#13;
[2020-04-06T16:17:16+0200] [PACMAN] Running 'pacman -S tcpdump'&#13;
[2020-04-06T16:17:18+0200] [ALPM] transaction started&#13;
[2020-04-06T16:17:18+0200] [ALPM] installed tcpdump (4.9.3-1)&#13;
[2020-04-06T16:17:18+0200] [ALPM] transaction completed&#13;
...&#13;
[2020-04-06T16:18:01+0200] [PACMAN] Running 'pacman -R tcpdump'&#13;
[2020-04-06T16:18:02+0200] [ALPM] transaction started&#13;
[2020-04-06T16:18:02+0200] [ALPM] removed tcpdump (4.9.3-1)&#13;
[2020-04-06T16:18:02+0200] [ALPM] transaction completed&#13;
...</pre>&#13;
<p class="noindent">In the logs, <code>PACMAN</code> refers to <code>pacman</code> commands executed by the user, and <code>ALPM</code> refers to <code>libalpm</code> library activity (which includes installing dependencies).</p>&#13;
<p class="indent">Packages downloaded from the various repositories are cached in the <em>/var/cache/pacman/pkg/</em> directory. This can be interesting from a forensics perspective because the directory contains previous versions of updated package files and does not delete removed package files. The filesystem timestamps will indicate when a package was downloaded for installation or update.</p>&#13;
<p class="indent">Packages in the AUR that are not part of the Arch community repository require several manual steps to install. This process is typically automated using AUR helper scripts (two examples of popular AUR helpers are <code>yay</code> and <code>pacaur</code>). These programs download the <em>PKGBUILD</em> and source files, unpack and compile source code, create and install a package, and then clean up any temporary files. These helper scripts may leave files and data in the user’s <em>~/.cache/</em> directory with filesystem timestamps from when the package was built. Many AUR helper programs are available, and each one might have its own configuration and save log information. See <em><a href="https://wiki.archlinux.org/index.php/AUR_helpers">https://wiki.archlinux.org/index.php/AUR_helpers</a></em> for a list of AUR helpers.</p>&#13;
<h3 class="h3" id="ch00lev1_36"><strong>Universal Software Package Analysis</strong></h3>&#13;
<p class="noindent">Some software installation and packaging systems bypass the standard mechanisms of Linux distributions. These are sometimes called <em>universal software packages</em> or <em>universal package systems</em> if they were designed to function independently of the chosen Linux distribution (or version of some particular distribution).</p>&#13;
<p class="indent">Some software packaging systems also are designed to function across non-Linux operating systems or enterprise container platforms (Docker, for example). This section focuses primarily on Linux-specific local packaging systems.</p>&#13;
<h4 class="h4" id="ch00lev2_104"><strong><em>AppImage</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_213"/>AppImage was designed to provide compatible binaries that would work across multiple Linux distributions and versions by creating a self-contained portable file format. The most popular use of AppImage is to have the latest versions of desktop apps running on stable Linux distributions that have older app versions in their native package repository. AppImage can also be used to run old versions of software. The example presented later in this section will analyze a working AppImage of the NCSA Mosaic browser from the mid-1990s.</p>&#13;
<p class="indent">The AppImage format bundles all the needed binaries, libraries, and supporting files into a single executable file. Any user can download an AppImage file, give it execute permissions, and then run it. No further installation or root privileges are necessary. An AppImage binary embeds a squashfs filesystem where the directory structure of files is stored. When the binary is run, this squashfs filesystem is mounted (via FUSE), and execution is passed to an internal program called AppRun. AppImage binaries are not running in an isolated sandbox and have access to the rest of the filesystem. The user’s home directory may have configs, cache, and other files related to the AppImage program.</p>&#13;
<p class="indent">Every AppImage executable includes flags for file extraction, squashfs mounting, and more. The most interesting flag from a forensics perspective is <code>--appimage-offset</code>, which provides the byte offset of the embedded squashfs filesystem. This offset allows us to access the filesystem with the <code>unsquashfs</code> command to extract detailed information and files (including preserved timestamps). The problem with this flag is that we must execute the binary, which is a security risk (especially when analyzing suspicious or malicious files). To avoid this risk, the offset can be independently calculated using the <code>readelf</code> command.</p>&#13;
<p class="indent">The <code>readelf</code> tool provides information about the executable header with the <code>-h</code> flag:</p>&#13;
<pre>$ <span class="codestrong1">readelf -h NCSA_Mosaic-git.6f488cb-x86_64.AppImage</span>&#13;
ELF Header:&#13;
  Magic:  7f 45 4c 46 02 01 01 00 41 49 02 00 00 00 00 00&#13;
  Class:                             ELF64&#13;
  Data:                              2's complement, little endian&#13;
  Version:                           1 (current)&#13;
  OS/ABI:                            UNIX - System V&#13;
  ABI Version:                       65&#13;
  Type:                              EXEC (Executable file)&#13;
  Machine:                           Advanced Micro Devices X86-64&#13;
  Version:                           0x1&#13;
  Entry point address:               0x401fe4&#13;
  Start of program headers:          64 (bytes into file)&#13;
  Start of section headers:          110904 (bytes into file)&#13;
  Flags:                             0x0&#13;
  Size of this header:               64 (bytes)&#13;
  <span epub:type="pagebreak" id="page_214"/>Size of program headers:           56 (bytes)&#13;
  Number of program headers:         8&#13;
  Size of section headers:           64 (bytes)&#13;
  Number of section headers:         31&#13;
  Section header string table index: 30</pre>&#13;
<p class="indent">The squashfs filesystem starts after the section headers. This offset is easily calculated from the section header lines:</p>&#13;
<pre>Start of section headers:      110904 (bytes into file)&#13;
Size of section headers:       64 (bytes)&#13;
Number of section headers:     31</pre>&#13;
<p class="indent">The byte offset is calculated from the <code>Start</code> + (<code>Size</code> * <code>Number</code>) of the section headers, or in our example:</p>&#13;
<pre>110904 + ( 64 * 31 ) = 112888</pre>&#13;
<p class="noindent">This byte offset number (112888) can be used with <code>unsquashfs</code> to extract information and files.</p>&#13;
<p class="indent">In the following <code>unsquashfs</code> example, the <code>-o</code> specifies the offset within the AppImage file, and the <code>-s</code> displays information about the filesystem (including a timestamp):</p>&#13;
<pre>$ <span class="codestrong1">unsquashfs -s -o 112888 NCSA_Mosaic-git.6f488cb-x86_64.AppImage</span>&#13;
Found a valid SQUASHFS 4:0 superblock on NCSA_Mosaic-git.6f488cb-x86_64.AppImage.&#13;
Creation or last append time Tue Apr 18 23:54:38 2017&#13;
Filesystem size 3022295 bytes (2951.46 Kbytes / 2.88 Mbytes)&#13;
Compression gzip&#13;
Block size 131072&#13;
...</pre>&#13;
<p class="indent">We can use the offset and <code>-ll</code> flag (two lowercase Ls) for a more detailed file listing:</p>&#13;
<pre>$ <span class="codestrong1">unsquashfs -ll -o 112888 NCSA_Mosaic-git.6f488cb-x86_64.AppImage</span>&#13;
Parallel unsquashfs: Using 4 processors&#13;
19 inodes (75 blocks) to write&#13;
&#13;
drwxrwxr-x root/root           96 2017-04-18 23:54 squashfs-root&#13;
-rw-rw-r-- root/root          653 2017-04-18 23:54 squashfs-root/.DirIcon&#13;
lrwxrwxrwx root/root           14 2017-04-18 23:54 squashfs-root/AppRun -&gt; usr/bin/Mosaic&#13;
-rw-rw-r-- root/root          149 2017-04-18 23:54 squashfs-root/mosaic.desktop&#13;
-rw-rw-r-- root/root          653 2017-04-18 23:54 squashfs-root/mosaic.png&#13;
drwxrwxr-x root/root           50 2017-04-18 23:54 squashfs-root/usr&#13;
drwxrwxr-x root/root           29 2017-04-18 23:54 squashfs-root/usr/bin&#13;
-rwxrwxr-x root/root      2902747 2017-04-18 23:54 squashfs-root/usr/bin/Mosaic&#13;
...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>The entire filesystem tree can be extracted, or we can extract individual files. In this example, a single file is extracted (unsquashfs will create the <em>squashfs-root</em> directory if it doesn’t exist):</p>&#13;
<pre>$ <span class="codestrong1">unsquashfs -o 112888 NCSA_Mosaic-git.6f488cb-x86_64.AppImage mosaic.desktop</span>&#13;
...&#13;
created 1 files&#13;
created 1 directories&#13;
created 0 symlinks&#13;
created 0 devices&#13;
created 0 fifos&#13;
$ ls -l squashfs-root/&#13;
total 4&#13;
-rw-r----- 1 sam sam 149 18. Apr 2017 mosaic.desktop</pre>&#13;
<p class="indent">The byte offset can also be used to mount the embedded filesystem on your forensic analysis machine, where it can be browsed with other programs:</p>&#13;
<pre>$ <span class="codestrong1">sudo mount -o offset=112888 NCSA_Mosaic-git.6f488cb-x86_64.AppImage /mnt</span>&#13;
...&#13;
$ <span class="codestrong1">ls -l /mnt</span>&#13;
total 2&#13;
lrwxrwxrwx 1 root root 14 18. Apr 2017 AppRun -&gt; usr/bin/Mosaic&#13;
-rw-rw-r-- 1 root root 149 18. Apr 2017 mosaic.desktop&#13;
-rw-rw-r-- 1 root root 653 18. Apr 2017 mosaic.png&#13;
drwxrwxr-x 5 root root 50 18. Apr 2017 usr/</pre>&#13;
<p class="noindent">Because this is squashfs, it’s read-only, so there is no danger of accidentally modifying the mounted directory contents.</p>&#13;
<p class="indent">AppImage files can be found anywhere a user has write permission. Because they are normal ELF executables, they have the same magic string and other properties as other executables. The <em>*.AppImage</em> filename extension might be the only indicator of the file type. The filesystem timestamps (<code>Birth</code> and <code>Modify</code>) of the AppImage file may indicate when the file was downloaded, and the timestamps inside squashfs indicate when the AppImage file was built.</p>&#13;
<h4 class="h4" id="ch00lev2_105"><strong><em>Flatpak</em></strong></h4>&#13;
<p class="noindent">Flatpak (renamed from <code>xdg-app</code>) is designed for Linux distro-independent packaging and distribution of desktop apps. Flatpak uses repositories to transfer and update files using the <em>OSTree</em> system. OSTree is similar to Git, but it tracks binary files rather than source code. The apps are run in containers with explicit permissions to access local system resources.</p>&#13;
<p class="indent">Flatpak has several configuration files to examine. System-wide configuration in <em>/etc/flatpak/</em> may contain config files (<em>*.conf</em> ) that override defaults and also configure the repositories used in a system.</p>&#13;
<pre><span epub:type="pagebreak" id="page_216"/>$ <span class="codestrong1">cat /etc/flatpak/remotes.d/flathub.flatpakrepo</span>&#13;
[Flatpak Repo]&#13;
Title=Flathub&#13;
Url=https://dl.flathub.org/repo/&#13;
Homepage=https://flathub.org/&#13;
Comment=Central repository of Flatpak applications&#13;
Description=Central repository of Flatpak applications&#13;
Icon=https://dl.flathub.org/repo/logo.svg&#13;
GPGKey=mQINBFlD2sABEADsiUZUOYBg1UdDaWkEdJYkTSZD682&#13;
...</pre>&#13;
<p class="noindent">The configuration file describes the repository, or repo, specifies the URL location, and stores the GPG public key used to verify signatures.</p>&#13;
<p class="indent">The system-wide directory is <em>/var/lib/flatpak/</em>, which contains runtime data and further configuration. Configuration describing the basic behavior of repos can be found in the <em>/var/lib/flatpak/repo/config</em> file:</p>&#13;
<pre>$ <span class="codestrong1">cat /var/lib/flatpak/repo/config</span>&#13;
[core]&#13;
repo_version=1&#13;
mode=bare-user-only&#13;
min-free-space-size=500MB&#13;
xa.applied-remotes=flathub;&#13;
&#13;
[remote "flathub"]&#13;
url=https://dl.flathub.org/repo/&#13;
xa.title=Flathub&#13;
gpg-verify=true&#13;
gpg-verify-summary=true&#13;
xa.comment=Central repository of Flatpak applications&#13;
xa.description=Central repository of Flatpak applications&#13;
xa.icon=https://dl.flathub.org/repo/logo.svg&#13;
xa.homepage=https://flathub.org/</pre>&#13;
<p class="noindent">Individual users can also install Flatpak repos, data, and configuration, which are fully contained in their local home directory (<em>~/.local/share/flatpak/</em>).</p>&#13;
<p class="indent">Applications are installed into their own subdirectories and found in <em>/var/lib/flatpak/app/*</em>. Multiple versions may exist, and symlinks indicate the current or active version. The <em>current/active/metadata</em> file in the Flatpak application’s directory provides configuration data for running and setting up the sandbox environment; for example:</p>&#13;
<pre>$ <span class="codestrong1">cat /var/lib/flatpak/app/org.jitsi.jitsi-meet/current/active/metadata</span>&#13;
[Application]&#13;
name=org.jitsi.jitsi-meet&#13;
runtime=org.freedesktop.Platform/x86_64/20.08&#13;
&#13;
<span epub:type="pagebreak" id="page_217"/>sdk=org.freedesktop.Sdk/x86_64/20.08&#13;
base=app/org.electronjs.Electron2.BaseApp/x86_64/20.08&#13;
command=jitsi-meet-run&#13;
&#13;
[Context]&#13;
shared=network;ipc;&#13;
sockets=x11;pulseaudio;&#13;
devices=all;&#13;
&#13;
[Session Bus Policy]&#13;
org.gnome.SessionManager=talk&#13;
org.freedesktop.Notifications=talk&#13;
org.freedesktop.ScreenSaver=talk&#13;
org.freedesktop.PowerManagement=talk&#13;
&#13;
[Extension org.jitsi.jitsi_meet.Debug]&#13;
directory=lib/debug&#13;
autodelete=true&#13;
no-autodownload=true&#13;
&#13;
[Build]&#13;
built-extensions=org.jitsi.jitsi_meet.Debug;org.jitsi.jitsi_meet.Sources;</pre>&#13;
<p class="noindent">Here, the different permissions, policies, paths, and more can be defined. See the flatpak-metadata(5) man page for a description of this file format.</p>&#13;
<p class="indent">Flatpak explicitly records installations, updates, and uninstalls in the systemd journal, which can be viewed with the <code>flatpak history</code> command. See the flatpak-history(1) man page for more information about Flatpak logging.</p>&#13;
<p class="indent">The installing and uninstalling of Flatpaks is logged to the systemd journal, as shown here:</p>&#13;
<pre>...&#13;
Dec 05 10:14:07 pc1 flatpak-system-helper[131898]: system:&#13;
Installed app/org.sugarlabs.MusicKeyboard/x86_64/stable from flathub&#13;
...&#13;
Dec 05 10:18:24 pc1 flatpak-system-helper[131898]: system:&#13;
Uninstalled app/org.sugarlabs.MusicKeyboard/x86_64/stable&#13;
...</pre>&#13;
<p class="noindent">Here, two log entries in the systemd journal show that the Flatpak for Sugar Labs’s Music Keyboard was installed and then uninstalled a few minutes later.</p>&#13;
<p class="indent">The starting and stopping of Flatpak apps may also be logged in the journal:</p>&#13;
<pre>...&#13;
Dec 05 10:14:44 pc1 systemd[400]: Started&#13;
app-flatpak-org.sugarlabs.MusicKeyboard-144497.scope.&#13;
...&#13;
<span epub:type="pagebreak" id="page_218"/>Dec 05 10:16:42 pc1 systemd[400]:&#13;
app-flatpak-org.sugarlabs.MusicKeyboard-144497.scope: Succeeded.&#13;
...</pre>&#13;
<p class="noindent">Here, two log entries show the application was started and run for a few minutes before being closed. This information is also stored in the systemd user journal and can be used in a forensic examination to reconstruct past application usage.</p>&#13;
<p class="indent">It’s also possible to have Flatpak package bundles. They are called single-file bundles, and they have a <em>*.flatpak</em> file extension. Flatpak files start with a magic string of <code>flatpak</code> and contain the files needed to install:</p>&#13;
<pre>00000000  66 6C 61 74 70 61 6B flatpak</pre>&#13;
<p class="noindent">This file format is taken from Docker’s Open Container Initiative (OCI). Using single-file bundles is less common than the developer-recommended use of repositories.</p>&#13;
<h4 class="h4" id="ch00lev2_106"><strong><em>Snap</em></strong></h4>&#13;
<p class="noindent">Software developers at Canonical created a self-contained package format called Snap together with a central app store (<em><a href="https://snapcraft.io/">https://snapcraft.io/</a></em>). Snap packages are designed to be distribution-independent, but Ubuntu is the only mainstream distro that uses them by default. In a forensic investigation of a system using snaps, we can determine which snaps are installed, when they were installed or updated, and information about the snap contents (files, configs, and so on).</p>&#13;
<p class="indent">Snap packages have a <em>*.snap</em> extension, but they are regular squashfs compressed filesystems. They can be easily mounted and browsed for additional information:</p>&#13;
<pre>$ <span class="codestrong1">sudo mount gnome-calculator_238.snap /mnt</span>&#13;
$ <span class="codestrong1">ls -l /mnt</span>&#13;
total 1&#13;
drwxr-xr-x 2 root root  37 10. Sep 2018 bin/&#13;
-rwxr-xr-x 1 root root 237 10. Sep 2018 command-gnome-calculator.wrapper&#13;
-rw-r--r-- 1 root root  14 10. Sep 2018 flavor-select&#13;
drwxr-xr-x 2 root root   3 10. Sep 2018 gnome-platform/&#13;
drwxr-xr-x 2 root root  40 10. Sep 2018 lib/&#13;
drwxr-xr-x 3 root root  43 10. Sep 2018 meta/&#13;
drwxr-xr-x 3 root root  82 10. Sep 2018 snap/&#13;
drwxr-xr-x 5 root root  66 10. Sep 2018 usr/</pre>&#13;
<p class="noindent">Once installed, these squashfs files are mounted under the <em>/snap/</em> directory on a running system (not visible during a postmortem forensic examination). Information about the package is found in <em>meta/snap.yaml</em> file.</p>&#13;
<p class="indent">Installed snaps can be found in the <em>/var/lib/snapd/snaps/</em> directory, with a single file per application (and version), as shown in this example:</p>&#13;
<pre><span epub:type="pagebreak" id="page_219"/># <span class="codestrong1">ls -l /var/lib/snapd/snaps/*</span> &#13;
-rw------- 1 root root 179642368 Nov 20 23:34 /var/lib/snapd/snaps/brave_87.snap&#13;
-rw------- 1 root root 187498496 Dez 4 00:31 /var/lib/snapd/snaps/brave_88.snap&#13;
-rw------- 1 root root 254787584 Nov 18 18:49 /var/lib/snapd/snaps/chromium_1411.snap&#13;
-rw------- 1 root root 254418944 Dez 3 18:51 /var/lib/snapd/snaps/chromium_1421.snap&#13;
...</pre>&#13;
<p class="noindent">The example output here shows multiple versions of the Brave and Chromium browsers. The mounting is done using systemd mount unit files, which can be found in the <em>/etc/systemd/system/</em> directory with a <em>snap-*.mount</em> filename.</p>&#13;
<p class="indent">Snaps rely on the snapd daemon to manage basic housekeeping. Various snapd actions are logged in the journal (or syslog):</p>&#13;
<pre>...&#13;
Apr 07 15:21:25 pc1 snapd[22206]: api.go:985: Installing snap "subsurface" revision unset&#13;
...&#13;
Sep 28 14:41:32 pc1 snapd[8859]: storehelpers.go:438: cannot refresh snap "subsurface":&#13;
snap has no updates available&#13;
...&#13;
Nov 14 16:10:14 pc1 systemd[1]: Unmounting Mount unit for subsurface, revision 3248...&#13;
...&#13;
Nov 14 16:10:59 pc1 systemd[1]: Mounting Mount unit for subsurface, revision 3231...&#13;
...</pre>&#13;
<p class="noindent">This journal output shows the snapd logs for the Subsurface snap package.<sup><a id="ch07foot015" href="footnotes.xhtml#ch07foot_015">15</a></sup> The output indicates the installation date, refresh (update) checks, and mounting/unmounting activity (which also corresponds to system reboots).</p>&#13;
<p class="indent">See the snap(8) man page and <em><a href="https://snapcraft.io/">https://snapcraft.io/</a></em> for more information about snap packages.</p>&#13;
<h4 class="h4" id="ch00lev2_107"><strong><em>Software Centers and GUI Frontends</em></strong></h4>&#13;
<p class="noindent">Historically, package management has been highly distro specific. A collaborative effort between the major distributions began working toward a common solution to this problem. PackageKit was developed to unify package management across different distros. It provides an interface between generic frontend software management applications and backend (distro-specific) package management systems (apt, dnf, and so on). Universal package systems like Flatpak or Snap can also be managed through the same PackageKit applications. A specification for generic package metadata called AppStream was created for use across distributions and package management systems.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_220"/>Installed applications can store an AppStream metadata XML file in the <em>/usr/share/metainfo/</em> directory. This file contains information such as descriptions (including translations), license and version information, the project team’s homepage and contact person, the URL of screenshots displayed, and more. The screenshots are fetched from the URL specified by the project team when the user views the application in the software center. This web location and associated network traffic may be of interest in a forensic investigation. See <em><a href="https://www.freedesktop.org/software/appstream/docs/chap-Quickstart.html">https://www.freedesktop.org/software/appstream/docs/chap-Quickstart.html</a></em> for more information about what is stored in the AppStream metadata.</p>&#13;
<p class="indent">The configuration files for PackageKit are found in the <em>/etc/PackageKit/</em> directory. An SQLite database of packages installed by PackageKit is stored in the file <em>/var/lib/PackageKit/transactions.db</em>.</p>&#13;
<p class="indent">This effort to harmonize package management resulted in the development of universal package managers called software centers that are easy-to-use graphical applications that run on any Linux distribution. The concept of software centers is analogous to the app store programs that are popular on mobile devices and other operating systems. The following list includes some examples of Linux software centers with their command line and graphical app names:</p>&#13;
<div class="bqparan">&#13;
<table>&#13;
<tbody>&#13;
<tr>&#13;
<td><span class="codestrong">gnome-software</span></td>&#13;
<td>(Software) for GNOME systems</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="codestrong">plasma-discover</span></td>&#13;
<td>(Discover) for KDE Plasma systems</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="codestrong">pamac-manager</span></td>&#13;
<td>(Pamac) for Arch Linux systems</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="codestrong">mintinstall</span></td>&#13;
<td>(Software Manager) for Linux Mint systems</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="codestrong">pi-packages</span></td>&#13;
<td>(PiPackages) for Raspberry Pi systems</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="noindent">These tools all have a similar look and feel (see <a href="ch07.xhtml#ch07fig02">Figure 7-2</a> for an example).</p>&#13;
<div class="image"><img id="ch07fig02" src="Images/ch07fig02.jpg" alt="Image" width="557" height="397"/></div>&#13;
<p class="figcap"><em>Figure 7-2: GNOME Software</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_221"/>In addition to generic frontends using PackageKit and AppStream, many distributions have graphical frontend tools that interface directly with their local package management system. Examples include Debian’s Synaptic or SUSE’s YaST.</p>&#13;
<p class="indent">In the background, these graphical tools are typically running low-level tools (like apt or dnf) or calling libraries (like libalpm or libdnf). For a forensic examination, the package management activity should be seen in the logs and local package databases as discussed earlier in this chapter. Individual tools may have their own logs (for example, they may have a daemon logging to a file or to syslog). Persistent or cache data may also reside in the user’s <em>~/.cache/</em> or <em>~/.local/</em> directories. Configuration information will usually be in <em>/etc/</em> (for system-wide defaults) and in <em>~/.config/</em> (for user-customized settings).</p>&#13;
<h3 class="h3" id="ch00lev1_37"><strong>Other Software Installation Analysis</strong></h3>&#13;
<p class="noindent">Several other methods exist for adding software either manually or as plug-ins to existing software packages. These examples completely bypass the software package management done by the Linux distribution. However, they may still leave traces of information useful in a forensic context.</p>&#13;
<h4 class="h4" id="ch00lev2_108"><strong><em>Manually Compiled and Installed Software</em></strong></h4>&#13;
<p class="noindent">GNU software packages can be compiled and installed manually, bypassing any package management systems (leaving no traces in the package management logs or databases). The GNU Coding Standards documentation can be found at <em><a href="https://www.gnu.org/prep/standards/">https://www.gnu.org/prep/standards/</a></em>. The typical process involves finding the source software package online (usually a compressed tar file), downloading it to a working directory, unpacking, and running <code>configure</code> and <code>make</code> scripts. Here’s an example:</p>&#13;
<pre>$ <span class="codestrong1">wget http://ftp.gnu.org/gnu/bc/bc-1.07.1.tar.gz</span>&#13;
...&#13;
Length: 419850 (410K) [application/x-gzip]&#13;
Saving to: 'bc-1.07.1.tar.gz'&#13;
...&#13;
$ <span class="codestrong1">tar -xvf bc-1.07.1.tar.gz</span>&#13;
...&#13;
bc-1.07.1/bc/bc.h&#13;
bc-1.07.1/bc/bc.c&#13;
...&#13;
$ <span class="codestrong1">cd bc-1.07.1/</span>&#13;
$ <span class="codestrong1">./configure</span>&#13;
checking for a BSD-compatible install... /bin/install -c&#13;
checking whether build environment is sane... yes&#13;
...&#13;
$ <span class="codestrong1">make</span>&#13;
make all-recursive&#13;
<span epub:type="pagebreak" id="page_222"/>make[1]: Entering directory '/home/sam/Downloads/bc/bc-1.07.1'&#13;
...&#13;
$ <span class="codestrong1">sudo make install</span>&#13;
Making install in lib&#13;
...&#13;
 /bin/mkdir -p '/usr/local/bin'&#13;
 /bin/install -c bc '/usr/local/bin'&#13;
...</pre>&#13;
<p class="indent">The install directory can be specified and non-privileged users may install software in their home directory (like <em>~/.local/bin/</em>, for example). Typically, the download site will include a separate file containing a cryptographic hash of the compressed archive file so it can be verified.</p>&#13;
<p class="indent">Manual downloads may also involve synchronizing (or cloning) with a software development repository like Git. A manual installation may also involve simply copying stand-alone scripts and binaries to a location in the executable path. With manual installs, there is no package management or tracking with install timestamps. The filesystem timestamps are the best indicator of when a file was installed (in particular, matching timestamps of files in the compile directory with timestamps of the installed files). The manual removal of software may involve a <code>make uninstall</code> command or script. If source code directories are found, it is worth examining the Makefiles to understand what was modified on the filesystem during the install (and uninstall) process. The shell history can also be examined for evidence of manual downloading, compiling, and installing of software packages.</p>&#13;
<h4 class="h4" id="ch00lev2_109"><strong><em>Programming Language Packages</em></strong></h4>&#13;
<p class="noindent">Some programming languages, especially interpreted languages, have their own package manager for adding additional code modules and libraries that provide extended functionality. These packages may use the distribution’s package management system or bypass it completely. This section describes a few examples of software packages that were installed directly using the programming language’s package management system.</p>&#13;
<p class="indent">The Python programming language has several package managers, the most popular being <code>pip</code>, the Python Package Installer. The <code>pip</code> tool is used to fetch, install, and manage Python packages. If a non-privileged user installs a package, it will be written to their home directory in <em>~/.local/lib/python*/ site-packages/</em>. If it is a site installation (intended for all users) it is installed in <em>/usr/lib/python*/site-packages/</em>. Files or directories with the extension <em>.egg-info</em> contain the package metadata.</p>&#13;
<p class="indent">The Perl programming language has CPAN, the Comprehensive Perl Archive Network. The <code>cpan</code> command is used to fetch, install, and manage Perl modules. The user’s installed modules are found in <em>~/.cpan</em>.</p>&#13;
<p class="indent">Another example is Ruby Gems (<em><a href="https://rubygems.org/">https://rubygems.org/</a></em>), which downloads Ruby code from a central repository and stores it in a user’s home directory or to a site-wide location.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>During a forensic examination, every user’s home directory should be analyzed to determine whether they were programmers and under which programming languages they developed. The programming languages may have a module or library package management system that was used.</p>&#13;
<h4 class="h4" id="ch00lev2_110"><strong><em>Application Plug-ins</em></strong></h4>&#13;
<p class="noindent">Application plug-ins are mentioned only briefly here, as the analysis is outside the scope of this book. Many large applications are extensible with themes, plug-ins, add-ons, or extensions, which are installed from within the app. This is typical of web browsers, file managers, office suites, window environments, and other programs. Plug-ins are not only used by big graphical programs, but also smaller utilities (for example, vim or neovim).</p>&#13;
<p class="indent">In some cases, these plug-ins are available from the distro’s package repository and are installed in standard locations that are available to other users. In other cases, a user may install plug-ins for their own use. In the latter case, the plug-ins are usually stored in the user’s home directory (in a hidden dot “.” directory together with other files associated with the application). If the application has a log or history of activity, a timestamp of installation might be found; otherwise, the filesystem timestamps are the best indicator of when the installation happened.</p>&#13;
<h3 class="h3" id="ch00lev1_38"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, I’ve described how to examine the installed software on a Linux system. You now should be able to identify the installed distro and version numbers, and reconstruct the initial installation process. You also should be able to determine which additional software packages are installed and how to analyze the details of those packages.<span epub:type="pagebreak" id="page_224"/></p>&#13;
</div></body></html>