["```\n\n\t\t\ttype\n    student =\n        record\n            Name:     string [64];\n            Major:    smallint;    // 2-byte integer in Delphi\n            SSN:      string[11];\n            Mid1:     smallint;\n            Mid2:     smallint;\n            Final:    smallint;\n            Homework: smallint;\n            Projects: smallint;\n        end;\n```", "```\n\n\t\t\ttypedef\n    struct\n    {\n        // Room for a 64-character zero-terminated string:\n\n        char Name[65];\n\n        // Typically a 2-byte integer in C/C++:\n\n        short Major;\n\n        // Room for an 11-character zero-terminated string:\n\n        char SSN[12];\n\n        short Mid1;\n        short Mid2;\n        short Final;\n        short Homework;\n        short Projects;\n\n    } student;\n```", "```\n\n\t\t\tstruct student\n {\n    // Room for a 64-character zero-terminated string:\n\n    public char[] Name;\n\n    // Typically a 2-byte integer in C/C++:\n\n    public short Major;\n\n    // Room for an 11-character zero-terminated string:\n\n    public char[] SSN;\n\n    public short Mid1;\n    public short Mid2;\n    public short Final;\n    public short Homework;\n    public short Projects;\n };\n```", "```\n\n\t\t\ttype\n    student:\n        record\n            sName:    char[65];\n            Major:    int16;\n            SSN:      char[12];\n            Mid1:     int16;\n            Mid2:     int16;\n            Final:    int16;\n            Homework: int16;\n            Projects: int16;\n        endrecord;\n```", "```\n\n\t\t\t( value[1], value[2], ..., value[n] )\n```", "```\n\n\t\t\tfunc returns3Ints()->(Int, Int, Int )\n{\n    return(1, 2, 3)\n}\nvar (r1, r2, r3) = returns3Ints();\nprint( r1, r2, r3 )\n```", "```\nvar (r1, r2, r3) = returns3Ints();\n```", "```\n\n\t\t\tlet rTuple = ( \"a\", \"b\", \"c\" )\nprint( rTuple.0, rTuple.1, rTuple.2 ) // Prints \"a b c\"\n```", "```\n\n\t\t\ttypealias record = ( field1:Int, field2:Int, field3:Float64 )\n\nvar r = record(1, 2, 3.0 )\nprint( r.field1, r.field2, r.field3 )  // prints \"1 2 3.0\"\n```", "```\n\n\t\t\tvar\n    automaticStudent :student;\n\nstatic\n    staticStudent :student;\n```", "```\n\n\t\t\tstudent *ptrToStudent;\n        .\n        .\n        .\n    ptrToStudent = malloc( sizeof( student ));\n```", "```\n\n\t\t\t// Room for a 64-character zero-terminated string:\n\nchar someStudent_Name[65];\n\n// Typically a 2-byte integer in C/C++:\n\nshort someStudent_Major;\n\n// Room for an 11-character zero-terminated string:\n\nchar someStudent_SSN[12];\n\nshort someStudent_Mid1;\nshort someStudent_Mid2;\nshort someStudent_Final;\nshort someStudent_Homework;\nshort someStudent_Projects;\n```", "```\ns2 := s1;\n```", "```\n\n\t\t\t#include <stdio.h>\n\n// A good-sized but otherwise arbitrary structure that\n// demonstrates how a C++ compiler can handle structure\n// assignments.\n\ntypedef struct\n{\n    int x;\n    int y;\n    char *z;\n    int a[16];\n}aStruct;\n\nint main( int argc, char **argv )\n{\n    static aStruct s1;\n    aStruct s2;\n    int i;\n\n    // Give s1 some nonzero values so\n    // that the optimizer doesn't simply\n    // substitute zeros everywhere fields\n    // of s1 are referenced:\n\n    s1.x = 5;\n    s1.y = argc;\n    s1.z = *argv;\n\n    // Do a whole structure assignment\n    // (legal in C++!)\n\n    s2 = s1;\n\n    // Make an arbitrary change to S2\n    // so that the compiler's optimizer\n    // won't eliminate the code to build\n    // s2 and just use s1 because s1 and\n    // s2 have the same values.\n\n    s2.a[2] = 2;\n\n    // The following loop exists, once again,\n    // to thwart the optimizer from eliminating\n    // s2 from the code:\n\n    for( i=0; i<16; ++i)\n    {\n        printf( \"%d\\n\", s2.a[i] );\n    }\n\n    // Now demonstrate a field-by-field assignment\n    // so we can see the code the compiler generates:\n\n    s1.y = s2.y;\n    s1.x = s2.x;\n    s1.z = s2.z;\n    for( i=0; i<16; ++i )\n    {\n        s1.a[i] = s2.a[i];\n    }\n    for( i=0; i<16; ++i)\n    {\n        printf( \"%d\\n\", s2.a[i] );\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t; Storage for the s1 array in the BSS segment:\n\n_BSS    SEGMENT\n?s1@?1??main@@9@9 DB 050H DUP (?)                       ; `main'::`2'::s1\n_BSS    ENDS\n;\ns2$1$ = 32\ns2$2$ = 48\ns2$3$ = 64\ns2$ = 80\n__$ArrayPad$ = 160\nargc$ = 192\nargv$ = 200\n\n; Note: on entry to main, rcx = argc, rdx = argv\n\nmain    PROC                                            ; COMDAT\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 20\n$LN27:\n        mov     r11, rsp\n        mov     QWORD PTR [r11+24], rbx\n        push    rdi\n;\n; Allocate storage for the local variables\n; (including s2):\n\n        sub     rsp, 176                                ; 000000b0H\n        mov     rax, QWORD PTR __security_cookie\n        xor     rax, rsp\n        mov     QWORD PTR __$ArrayPad$[rsp], rax\n\n        xor     ebx, ebx   ; ebx = 0\n        mov     edi, ebx  ; edi = 0\n\n     ; s1.z = *argv\n        mov     rax, QWORD PTR [rdx] ;rax = *argv\n        mov     QWORD PTR ?s1@?1??main@@9@9+8, rax\n\n     ; s1.x = 5\n        mov     DWORD PTR ?s1@?1??main@@9@9, 5\n\n     ;s1.y = argc\n        mov     DWORD PTR ?s1@?1??main@@9@9+4, ecx\n;     s2 = s1;\n;\n;       xmm1=s1.a[0..1]\n        movaps  xmm1, XMMWORD PTR ?s1@?1??main@@9@9+16\n        movaps  XMMWORD PTR s2$[rsp+16], xmm1 ;s2.a[0..1] = xmm1\n        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9\n        movaps  XMMWORD PTR s2$[rsp], xmm0\n        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9+32\n        movaps  XMMWORD PTR s2$[rsp+32], xmm0\n        movups  XMMWORD PTR s2$1$[rsp], xmm0\n        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9+48\n        movaps  XMMWORD PTR [r11-56], xmm0\n        movups  XMMWORD PTR s2$2$[rsp], xmm0\n        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9+64\n        movaps  XMMWORD PTR [r11-40], xmm0\n        movups  XMMWORD PTR s2$3$[rsp], xmm0\n\n    ; s2.a[2] = 2\n\n        mov     DWORD PTR s2$[rsp+24], 2\n        npad    14\n\n;    for (i = 0; i<16; ++i)\n;    {\n\n$LL4@main:\n; Line 53\n        mov     edx, DWORD PTR s2$[rsp+rdi*4+16]\n        lea     rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6?$AA@\n        call    printf\n        inc     rdi\n        cmp     rdi, 16\n        jl      SHORT $LL4@main\n\n.;     } //endfor\n\n; Line 59 // s1.y = s2.y\n        mov     eax, DWORD PTR s2$[rsp+4]\n        mov     DWORD PTR ?s1@?1??main@@9@9+4, eax\n\n       ;s1.x = s2.x\n        mov     eax, DWORD PTR s2$[rsp]\n        mov     DWORD PTR ?s1@?1??main@@9@9, eax\n\n       ; s1.z = s2.z\n        mov     rax, QWORD PTR s2$[rsp+8]\n        mov     QWORD PTR ?s1@?1??main@@9@9+8, rax\n\n;    for (i = 0; i<16; ++i)\n;    {\n;        printf(\"%d\\n\", s2.a[i]);\n;    }\n; Line 64\n        movups  xmm1, XMMWORD PTR s2$1$[rsp]\n        movaps  xmm0, XMMWORD PTR s2$[rsp+16]\n        movups  XMMWORD PTR ?s1@?1??main@@9@9+32, xmm1\n        movups  xmm1, XMMWORD PTR s2$3$[rsp]\n        movups  XMMWORD PTR ?s1@?1??main@@9@9+16, xmm0\n        movups  xmm0, XMMWORD PTR s2$2$[rsp]\n        movups  XMMWORD PTR ?s1@?1??main@@9@9+64, xmm1\n        movups  XMMWORD PTR ?s1@?1??main@@9@9+48, xmm0\n        npad    7\n\n$LL10@main:\n; Line 68\n        mov     edx, DWORD PTR s2$[rsp+rbx*4+16]\n        lea     rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6?$AA@\n        call    printf\n        inc     rbx\n        cmp     rbx, 16\n        jl      SHORT $LL10@main\n\n; Return 0\n; Line 70\n        xor     eax, eax\n; Line 71\n        mov     rcx, QWORD PTR __$ArrayPad$[rsp]\n        xor     rcx, rsp\n        call    __security_check_cookie\n        mov     rbx, QWORD PTR [rsp+208]\n        add     rsp, 176                                ; 000000b0H\n        pop     rdi\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\t#include <stdlib.h>\n\n// Arbitrary structure that consumes a nontrival\n// amount of space:\n\ntypedef struct\n{\n    int x;\n    int y;\n    char *z;\n    int a[4];\n}initStruct;\n\n// The following exists just to thwart\n// the optimizer and make it think that\n// all the fields of the structure are\n// needed.\n\nextern void thwartOpt( initStruct *i );\n\nint main( int argc, char **argv )\n{\n    static initStruct staticStruct = {1,2,\"Hello\", {3,4,5,6}};\n    initStruct autoStruct = {7,8,\"World\", {9,10,11,12}};\n\n    thwartOpt( &staticStruct );\n    thwartOpt( &autoStruct );\n    return 0;\n\n}\n```", "```\n\n\t\t\t; Static structure declaration.\n; Note how each of the fields is\n; initialized with the initial values\n; specified in the C source file:\n\n; String used in static initStruct:\n\nCONST   SEGMENT\n??_C@_05COLMCDPH@Hello?$AA@ DB 'Hello', 00H       ; `string'\nCONST   ENDS\n\n_DATA   SEGMENT\n; `main'::`2'::staticStruct\n?staticStruct@?1??main@@9@9 DD 01H ;x field\n        DD      02H ;y field\n        DQ      FLAT:??_C@_05COLMCDPH@Hello?$AA@  ; z field\n        DD      03H ;a[0] field\n        DD      04H ;a[1] field\n        DD      05H ;a[2] field\n        DD      06H ;a[3] field\n_DATA   ENDS\n\n; String used to initialize autoStruct:\n\nCONST   SEGMENT\n??_C@_05MFLOHCHP@World?$AA@ DB 'World', 00H       ; `string'\nCONST   ENDS\n;\n_TEXT   SEGMENT\nautoStruct$ = 32\n__$ArrayPad$ = 64\nargc$ = 96\nargv$ = 104\nmain    PROC                                      ; COMDAT\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 26\n$LN9: ;Main program startup code:\n        sub     rsp, 88                           ; 00000058H\n        mov     rax, QWORD PTR __security_cookie\n        xor     rax, rsp\n        mov     QWORD PTR __$ArrayPad$[rsp], rax\n\n; Line 28\n;\n; Initialize autoStruct:\n\n        lea     rax, OFFSET FLAT:??_C@_05MFLOHCHP@World?$AA@\n        mov     DWORD PTR autoStruct$[rsp], 7 ;autoStruct.x\n        mov     QWORD PTR autoStruct$[rsp+8], rax\n        mov     DWORD PTR autoStruct$[rsp+4], 8 ;autoStruct.y\n        lea     rcx, QWORD PTR autoStruct$[rsp+16] ;autoStruct.a\n        mov     eax, 9\n        lea     edx, QWORD PTR [rax-5] ;edx = 4\n$LL3@main:\n; autoStruct.a[0] = 9, 10, 11, 12 (this is a loop)\n        mov     DWORD PTR [rcx], eax\n        inc     eax\n\n; point RCX at next element of autoStruct.a\n        lea     rcx, QWORD PTR [rcx+4]\n        sub     rdx, 1\n        jne     SHORT $LL3@main\n\n; Line 30\n; thwartOpt(&staticStruct );\n\n        lea     rcx, OFFSET FLAT:?staticStruct@?1??main@@9@9\n        call    thwartOpt\n\n; Line 31\n; thwartOpt( &autoStruct );\n\n        lea     rcx, QWORD PTR autoStruct$[rsp]\n        call    thwartOpt\n; Line 32\n; Return 0\n        xor     eax, eax ;EAX = 0\n; Line 34\n        mov     rcx, QWORD PTR __$ArrayPad$[rsp]\n        xor     rcx, rsp\n        call    __security_check_cookie\n        add     rsp, 88                                 ; 00000058H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n        END\n```", "```\n\n\t\t\t#include <stdlib.h>\ntypedef struct\n{\n    int x;\n    int y;\n    char *z;\n    int a[4];\n}initStruct;\n\n// The following exists just to thwart\n// the optimizer and make it think that\n// all the fields of the structure are\n// needed.\n\nextern void thwartOpt( initStruct *i );\n\nint main( int argc, char **argv )\n{\n    static initStruct staticStruct = {1,2,\"Hello\", {3,4,5,6}};\n\n    // initAuto is a \"readonly\" structure used to initialize\n    // autoStruct upon entry into this function:\n\n    static initStruct initAuto = {7,8,\"World\", {9,10,11,12}};\n\n    // Allocate autoStruct on the stack and assign the initial\n    // values kept in initAuto to this new structure:\n\n    initStruct autoStruct = initAuto;\n\n    thwartOpt( &staticStruct );\n    thwartOpt( &autoStruct );\n    return 0;\n\n}\n```", "```\n\n\t\t\t; Static initialized data for the staticStruct structure:\n\n_DATA   SEGMENT\n\n; Initialized data for staticStruct:\n\n?staticStruct@?1??main@@9@9 DD 01H                      ; `main'::`2'::staticStruct\n        DD      02H\n        DQ      FLAT:??_C@_05COLMCDPH@Hello?$AA@\n        DD      03H\n        DD      04H\n        DD      05H\n        DD      06H\n\n; Initialization data to be copied to autoStruct:\n\n?initAuto@?1??main@@9@9 DD 07H                          ; `main'::`2'::initAuto\n        DD      08H\n        DQ      FLAT:??_C@_05MFLOHCHP@World?$AA@\n        DD      09H\n        DD      0aH\n        DD      0bH\n        DD      0cH\n_DATA   ENDS\n\n_TEXT   SEGMENT\nautoStruct$ = 32\n__$ArrayPad$ = 64\nargc$ = 96\nargv$ = 104\nmain    PROC                                    ; COMDAT\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 23\n$LN4:\n; Main startup code:\n\n        sub     rsp, 88                         ; 00000058H\n        mov     rax, QWORD PTR __security_cookie\n        xor     rax, rsp\n        mov     QWORD PTR __$ArrayPad$[rsp], rax\n; Line 34\n; Initialize autoStruct by copying the data from the static\n; initializer to the automatic variable:\n\n        movups  xmm0, XMMWORD PTR ?initAuto@?1??main@@9@9\n        movups  xmm1, XMMWORD PTR ?initAuto@?1??main@@9@9+16\n        movups  XMMWORD PTR autoStruct$[rsp], xmm0\n        movups  XMMWORD PTR autoStruct$[rsp+16], xmm1\n\n; thwartOpt( &staticStruct );\n\n        lea     rcx, OFFSET FLAT:?staticStruct@?1??main@@9@9\n        call    thwartOpt  ; Arg is passed in RCX.\n\n; thwartOpt( &autoStruct );\n\n        lea     rcx, QWORD PTR autoStruct$[rsp]\n        call    thwartOpt\n\n; Return 0;\n        xor     eax, eax\n; Line 40\n        mov     rcx, QWORD PTR __$ArrayPad$[rsp]\n        xor     rcx, rsp\n        call    __security_check_cookie\n        add     rsp, 88                         ; 00000058H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n        END\n```", "```\n\n\t\t\tvar\n    John: student;\n```", "```\n\n\t\t\tJohn.Mid1 = 80;           // C/C++ example\nJohn.Final := 93;         (* Pascal example *)\nmov( 75, John.Projects ); // HLA example\n```", "```\n\n\t\t\ttype\n    aRecord = record\n\n        (* assume Pascal compiler supports a\n        ** byte, word, and dword type\n        *)\n\n        bField : byte;\n        wField : word;\n        dField : dword;\n\n    end; (* record *)\n```", "```\n\n\t\t\ttype\n    aRecord = packed record\n        bField   :byte;  (* Offset 0 *)\n\n        (* add padding to dword align wField *)\n\n        padding0 :array[0..2] of byte;\n\n        wField   :word; (* offset 4 *)\n\n        (* add padding to dword align dField *)\n\n        padding1 :word;\n\n        dField   :dword;  (* offset 8 *)\n\n    end; (* record *)\n```", "```\n\n\t\t\tint i;\nint j = 5;\nint cnt = 0;\nchar a = 'a';\nchar b;\n```", "```\n\n\t\t\tPUBLIC  j\nPUBLIC  cnt\nPUBLIC  a\n_DATA   SEGMENT\nCOMM    i:DWORD\n_DATA   ENDS\n_BSS    SEGMENT\ncnt     DD      01H DUP (?)\n_BSS    ENDS\n_DATA   SEGMENT\nCOMM    b:BYTE\n_DATA   ENDS\n_DATA   SEGMENT\nj       DD      05H\na       DB      061H\n_DATA   ENDS\n```", "```\n\n\t\t\ttypedef union\n{\n    unsigned int  i;\n    float         r;\n    unsigned char c[4];\n\n} unionType;\n```", "```\n\n\t\t\ttype\n    typeName =\n        record\n\n            <<nonvariant/union record fields go here>>\n\n            case tag of\n                const1:( field_declaration );\n                const2:( field_declaration );\n                    .\n                    .\n                    .\n                constn:( field_declaration )\n\n        end;\n```", "```\n\n\t\t\ttype\n    noTagRecord=\n        record\n            someField: integer;\n            case boolean of\n                true:( i:integer );\n                false:( b:array[0..3] of char)\n        end; (* record *)\n\n    hasTagRecord=\n        record\n            case which:0..2 of\n                0:( i:integer );\n                1:( r:real );\n                2:( c:array[0..3] of char )\n        end; (* record *)\n```", "```\n\n\t\t\ttype\n    unionType:\n        union\n            i: int32;\n            r: real32;\n            c: char[4];\n        endunion;\n```", "```\n\n\t\t\ttype\n    numericRec:\n        record\n            i: int32;\n            u: uns32;\n            r: real64;\n        endrecord;\n\n    numericUnion:\n        union\n            i: int32;\n            u: uns32;\n            r: real64;\n        endunion;\n```", "```\n\n\t\t\ttype\n    CharOrUns:\n        union\n            c:char;\n            u:uns32;\n        endunion;\n\nstatic\n    v:CharOrUns;\n```", "```\n\n\t\t\tmov( eax, v.u );\nstdout.put( \"v, as a character, is '\", v.c, \"'\" nl );\n```", "```\n\n\t\t\ttypedef union\n{\n    unsigned int u;\n    unsigned char bytes[4];\n} asBytes;\n\nasBytes composite;\n        .\n        .\n        .\n    composite.u = 1234567890;\n    printf\n    (\n        \"HO byte of composite.u is %u, LO byte is %u\\n\",\n        composite.bytes[3],\n        composite.bytes[0]\n    );\n```", "```\n\n\t\t\ttype\n    dataTypes =\n           (\n               vBoolean, paBoolean, vChar, paChar,\n               vInteger, paInteger, vReal, paReal,\n               vString, paString\n           );\n\n       varType =\n           record\n               elements : integer;\n               case theType: dataTypes of\n                   vBoolean:  ( b:boolean );\n                   paBoolean: ( pb:array[0..0] of ^boolean );\n                   vChar:     ( c:char );\n                   paChar:    ( pc:array [0..0] of ^char );\n                   vInteger:  ( i:integer );\n                   paInteger: ( pi:array[0..0] of ^integer );\n                   vReal:     ( r:real );\n                   paReal:    ( pr:array[0..0] of ^real );\n                   vString:   ( s:string[255] );\n                   paString:  ( ps:array[0..0] of ^string[255] )\n          end;\n```", "```\n\n\t\t\t// Handle the addition operation:\n\n// Load variable theType with either left.theType\n// or right.theType (which, presumably, contain\n// the same value at this point).\n\ncase( theType ) of\n\n    vBoolean: writeln( \"Cannot add two Boolean values!\" );\n    vChar: writeln( \"Cannot add two character values!\" );\n    vString: writeln( \"Cannot add two string values!\" );\n    vInteger: intResult := left.vInteger + right.vInteger;\n    vReal: realResult := left.vReal + right.vReal;\n    paBoolean: writeln( \"Cannot add two Boolean arrays!\" );\n    paChar: writeln( \"Cannot add two character arrays!\" );\n    paInteger: writeln( \"Cannot add two integer arrays!\" );\n    paReal: writeln( \"Cannot add two real arrays!\" );\n    paString: writeln( \"Cannot add two Boolean arrays!\" );\n\nend;\n```", "```\n\n\t\t\tcase( left.theType ) of\n\n    vInteger:\n        case( right.theType ) of\n            vInteger:\n                (* code to handle integer + integer operands *)\n            vReal:\n                (* code to handle integer + real operands *)\n            vBoolean:\n                (* code to handle integer + boolean operands *)\n            vChar:\n                (* code to handle integer + char operands *)\n            vString:\n                (* code to handle integer + string operands *)\n            paInteger:\n                (* code to handle integer + intArray operands *)\n            paReal:\n                (* code to handle integer + realArray operands *)\n            paBoolean:\n                (* code to handle integer + booleanArray operands *)\n            paChar:\n                (* code to handle integer + charArray operands *)\n            paString:\n                (* code to handle integer + stringArray operands *)\n        end;\n\n    vReal:\n        case( right.theType ) of\n            (* cases for each of the right operand types\n                REAL + type *)\n        end;\n\n    Boolean:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                BOOLEAN + type *)\n        end;\n\n    vChar:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                CHAR + type *)\n        end;\n\n    vString:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                STRING + type *)\n        end;\n\n    paInteger:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                intArray + type *)\n        end;\n\n    paReal:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                realArray + type *)\n        end;\n\n    paBoolean:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                booleanArray + type *)\n        end;\n\n    paChar:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                charArray + type *)\n        end;\n\n    paString:\n        case( right.theType ) of\n            (* cases for each of the right operand types:\n                stringArray + type *)\n        end;\n\nend;\n```", "```\n\n\t\t\tvar\n    myNameSpace:\n        record\n            i: integer;\n            j: integer;\n            name: string[64];\n            date: string[10];\n            grayCode: integer;\n        end;\n\n    yourNameSpace:\n        record\n            i: integer;\n            j: integer;\n            profits: real;\n            weekday: integer;\n        end;\n```", "```\n\n\t\t\tmyNameSpace.i, myNameSpace.j,\nyourNameSpace.i, yourNameSpace.j\n```", "```\n\n\t\t\tnamespace nsIdentifier;\n\n    << constant, type, variable, procedure,\n            and other declarations >>\n\nend nsIdentifier;\n```", "```\n\n\t\t\tnamespace aNS\n{\n    int i;\n    int j;\n}\n\nint i;  // Outside the namespace, so this is unique.\nint j;  // ditto.\nnamespace aNS\n{\n    int k;\n}\n```", "```\n\n\t\t\tstruct student\n{\n        // Room for a 64-character zero-terminated string:\n\n        char Name[65];\n\n        // Typically a 2-byte integer in C/C++:\n\n        short Major;\n\n        // Room for an 11-character zero-terminated string:\n\n        char SSN[12];\n\n        // Each of the following is typically a 2-byte integer\n\n        short Mid1;\n        short Mid2;\n        short Final;\n        short Homework;\n        short Projects;\n};\n\nclass myClass\n{\npublic:\n\n// Room for a 64-character zero-terminated string:\n\n        char Name[65];\n\n        // Typically a 2-byte integer in C/C++:\n\n        short Major;\n\n        // Room for an 11-character zero-terminated string:\n\n        char SSN[12];\n\n        // Each of the following is typically a 2-byte integer\n\n        short Mid1;\n        short Mid2;\n        short Final;\n        short Homework;\n        short Projects;\n};\n```", "```\n\n\t\t\tclass myClass\n{\npublic:\n\n// Room for a 64-character zero-terminated string:\n\n        char Name[65];\n\n        // Typically a 2-byte integer in C/C++:\n\n        short Major;\n\n        // Room for an 11-character zero-terminated string:\n\n        char SSN[12];\n\n        // Each of the following is typically a 2-byte integer\n\n        short Mid1;\n        short Mid2;\n        short Final;\n        short Homework;\n        short Projects;\n\n        // Member functions:\n\n        double computeGrade( void );\n        double testAverage( void );\n};\n```", "```\n\n\t\t\tclass student\n{\n        // Room for a 64-character zero-terminated string:\n\n        public char[] Name;\n\n        // Typically a 2-byte integer in C/C++:\n\n        public short Major;\n\n        // Room for an 11-character zero terminated string:\n\n        public char[] SSN;\n\n        public short Mid1;\n        public short Mid2;\n        public short Final;\n        public short Homework;\n        public short Projects;\n\n        public double computeGrade()\n        {\n            return Mid1 * 0.15 + Mid2 * 0.15 + Final *\n                   0.2 + Homework * 0.25 + Projects * 0.25;\n        }\n        public double testAverage()\n        {\n            return (Mid1 + Mid2 + Final) / 3.0;\n        }\n    };\n```", "```\n\n\t\t\ttype\n  student =\n    class\n      Name:     string [64];\n      Major:    smallint;    // 2-byte integer in Delphi\n      SSN:      string[11];\n      Mid1:     smallint;\n      Mid2:     smallint;\n      Final:    smallint;\n      Homework: smallint;\n      Projects: smallint;\n\n      function computeGrade:real;\n      function testAverage:real;\n  end;\n```", "```\n\n\t\t\ttype\n    student:\n        class\n          var\n            sName:    char[65];\n            Major:    int16;\n            SSN:      char[12];\n            Mid1:     int16;\n            Mid2:     int16;\n            Final:    int16;\n            Homework: int16;\n            Projects: int16;\n\n            method computeGrade;\n            method testAverage;\n\n        endclass;\n```", "```\n\n\t\t\tclass myclass\n{\n    public:\n        int a;\n        int b;\n        virtual int f( void );\n};\n```", "```\n\n\t\t\t#include <stdlib.h>\n\n// A C++ class with two trivial\n// member functions (so the VMT\n// will have two entries).\n\nclass myclass\n{\n    public:\n        int a;\n        int b;\n        virtual int f( void );\n        virtual int g( void );\n};\n\n// Some trivial member functions.\n// We're really only interested\n// in looking at the calls, so\n// these functions will suffice\n// for now.\n\nint myclass::f( void )\n{\n    return b;\n}\n\nint myclass::g( void )\n{\n    return a;\n}\n\n// A main function that creates\n// a new instance of myclass and\n// then calls the two member functions\n\nint main( int argc, char **argv )\n{\n    myclass *c;\n\n    // Create a new object:\n\n    c = new myclass;\n\n    // Call both member functions:\n\n    c->a = c->f() + c->g();\n    return 0;\n\n}\n```", "```\n\n\t\t\t; Here is the VMT for myclass. It contains\n; three entries:\n; a pointer to the constructor for myclass,\n; a pointer to the myclass::f member function,\n; and a pointer to the myclass::g member function.\n\nCONST   SEGMENT\n??_7myclass@@6B@ DQ FLAT:??_R4myclass@@6B@ ; myclass::`vftable'\n        DQ      FLAT:?f@myclass@@UEAAHXZ\n        DQ      FLAT:?g@myclass@@UEAAHXZ\nCONST   ENDS\n;\n    .\n    .\n    .\n;\n; Allocate storage for a new instance of myclass:\n; 16 = two 4-byte ints plus 8-byte VMT pointer\n        mov     ecx, 16\n\n        call    ??2@YAPEAX_K@Z             ; operator new\n        mov     rdi, rax                   ; Save pointer to allocated object\n        test    rax, rax                   ; Did NEW FAIL (returning NULL)?\n        je      SHORT $LN3@main\n\n; Initialize VMT field with the address of the VMT:\n\n        lea     rax, OFFSET FLAT:??_7myclass@@6B@\n        mov     QWORD PTR [rdi], rax\n        jmp     SHORT $LN4@main\n$LN3@main:\n        xor     edi, edi                   ; For failure, put NULL in EDI\n\n; At this point, RDI contains the \"THIS\" pointer\n; that refers to the object in question. In this\n; particular code sequence, \"THIS\" is the address\n; of the object whose storage we allocated above.\n\n; Get the VMT into RAX (first indirect access\n; needed to make a virtual member function call)\n\n        mov     rax, QWORD PTR [rdi]\n\n        mov     rcx, rdi                   ; Pass THIS in RCX\n        call    QWORD PTR [rax+8]          ; Call c->f()\n        mov     ebx, eax                   ; Save function result\n\n        mov     rdx, QWORD PTR [rdi]       ; Load VMT into RDX\n        mov     rcx, rdi                   ; Pass THIS in RCX\n        call    QWORD PTR [rdx]            ; Call c->g()\n\n; Compute sum of function results:\n\n        add     ebx, eax\n        mov     DWORD PTR [rdi+8], ebx     ; Save sum in c->a\n```", "```\n\n\t\t\tclass myclass\n{\npublic:\n    int a;\n    int b;\n    virtual int f(void);\n    virtual int g(void);\n    virtual int h(void) = 0;\n};\n```", "```\n\n\t\t\tCONST   SEGMENT\n??_7myclass@@6B@ DQ FLAT:??_R4myclass@@6B@              ; myclass::`vftable'\n        DQ      FLAT:?f@myclass@@UEAAHXZ\n        DQ      FLAT:?g@myclass@@UEAAHXZ\n        DQ      FLAT:_purecall\nCONST   ENDS\n```", "```\n\n\t\t\tclass point\n{\n    public:\n        float x;\n        float y;\n\n        virtual float distance( void );\n};\n```", "```\n\n\t\t\tfloat point::distance( void )\n{\n    return sqrt( x*x + y*y );\n}\n```", "```\n\n\t\t\tclass point3D :public point\n{\n    public:\n        float z;\n\n        virtual void rotate( float angle1, float angle2 );\n};\n```", "```\n\n\t\t\tclass point3D :public point\n{\n    public:\n        float z;\n\n        virtual float distance( void );\n        virtual void rotate( float angle1, float angle2 );\n};\nfloat point3D::distance( void )\n{\n    return sqrt( x*x + y*y + z*z );\n}\n```", "```\n\n\t\t\tfloat f;\nint *i;\n    .\n    .\n    .\ni = &f; // C++ isn't going to allow this.\n```", "```\n\n\t\t\tpoint *p;\npoint3D *t;\npoint *generic;\n\n    p = new point;\n    t = new point3D;\n        .\n        .\n        .\n    generic = t;\n```", "```\n\n\t\t\tclass a\n{\n    public:\n        int i;\n        virtual void setI(int i) { this->i = i; }\n};\n\nclass b\n{\n    public:\n        int j;\n        virtual void setJ(int j) { this->j = j; }\n};\n\nclass c : public a, public b\n{\n    public:\n        int k;\n        virtual void setK(int k) { this->k = k; }\n};\n```", "```\n\n\t\t\tprotocol someProtocol\n{\n    func doSomething()->Void;\n    func doSomethingElse() ->Void;\n}\nprotocol anotherProtocol\n{\n    func doThis()->Void;\n    func doThat() ->Void;\n}\n\nclass supportsProtocols: someProtocol, anotherProtocol\n{\n    var i:Int = 0;\n    func doSomething()->Void\n    {        // appropriate function body\n    }\n    func doSomethingElse()->Void\n    {        // appropriate function body\n    }\n    func doThis()->Void\n    {        // appropriate function body\n    }\n    func doThat()->Void\n    {        // appropriate function body\n    }\n\n}\n```", "```\n\n\t\t\tinterface someInterface\n{\n    void doSomething();\n    void doSomethingElse();\n}\ninterface anotherInterface\n{\n    void doThis();\n    void doThat();\n}\n\nclass supportsInterfaces  implements someInterface, anotherInterface\n{\n    int i;\n    public void doSomething()\n    {\n        // appropriate function body\n    }\n    public void doSomethingElse()\n    {\n        // appropriate function body\n    }\n    public void doThis()\n    {\n        // appropriate function body\n    }\n    public void doThat()\n    {\n        // appropriate function body\n    }\n}\n```", "```\n\n\t\t\tsomeInterface some = new supportsInterfaces();\n\n// We can call the member functions defined for someInterface:\n\nsome.doSomething();\nsome.doSomethingElse();\n\n// Note that it is illegal to try and call doThis or doThat\n// (or access the i data field)\n// using the \"some\" variable.\n```", "```\n\n\t\t\timport Foundation\n\nprotocol a\n{\n    func b()->Void;\n    func c()->Void;\n}\n\nprotocol d\n{\n    func e()->Void;\n    func f()->Void;\n}\nclass g : a, d\n{\n    var i:Int = 0;\n\n    func b()->Void {print(\"b\")}\n    func c()->Void {print(\"c\")}\n    func e()->Void {print(\"e\")}\n    func f()->Void {print(\"f\")}\n\n    func local()->Void {print( \"local to g\" )}\n}\n\nvar x:a = g()\nx.b()\nx.c()\n```"]