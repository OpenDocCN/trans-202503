- en: A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jargon
  prefs: []
  type: TYPE_NORMAL
- en: This was never intended to be a technical book for engineers who love all the
    geeky details. Instead, it’s supposed to be a book for everyone who is interested
    in the meteoric rise of a business and technology, and of the people behind that
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: But when these people write code and create highly technical things that lead
    to that result, it’s difficult to not get lost in the techy weeds every now and
    then. So when I’m explaining, for example, that Ficus Kirkpatrick enjoyed working
    on drivers at the lower levels of the system, or that Brian Swetland worked on
    the kernel at Danger and Android, or that the engineers at Be and PalmSource were
    creating a platform and APIs for software developers, it’s necessary to use terms
    that might lose or confuse the non-engineers in the audience.
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to keep the techy noise to a minimum, I’m cramming many of the
    explanations of that stuff into this appendix. Hopefully this brief section will
    help explain the salient terms and, more important, how the different pieces of
    the system relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: First, a System Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is typical in my industry, when discussing platform software, to end up at
    the whiteboard drawing what we call a “layer cake diagram,” which shows the relationship
    of the various components of the system to each other. This diagram typically
    shows the components going down toward the hardware. At the top of the diagram,
    we see the pieces that users interact with, and at the bottom we see the components
    that talk directly to the hardware. All the pieces in between are layers of software
    written by the engineers to get from the higher-level user actions (for example,
    clicking a button) to the hardware (for example, displaying the button in a pressed
    state, launching an application, firing the nukes, whatever).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a (very simplified) diagram for the Android operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![b01001](image_fi/502680b01/b01001.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s actually nothing specific to Android here; this is a very typical view
    of most operating systems. Android obviously has elements that are unique to that
    OS, which are explained elsewhere. But in general, the Android platform is similar
    to most other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the diagram from the top to the bottom to talk about what
    these pieces are and how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: Apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *apps* on Android are the main entry points for users. Users launch apps
    from their icons, they interact with the buttons, lists, and other pieces inside
    of apps, they click on links in apps that launch other apps, and so on. This is
    basically the world in which users live, interacting with the apps directly, while
    accessing all of the platform functionality only indirectly, through what these
    apps expose.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the system-provided functionality of the home screen, the navigation
    bar, the status bar, and the lock screen are all considered apps. Even though
    they are provided by the platform (either Android itself, or in some cases by
    a manufacturer like Samsung, which provides its own system apps), they’re still
    just apps.
  prefs: []
  type: TYPE_NORMAL
- en: APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Application programming interfaces (APIs)* are the pieces of functionality
    in the platform that applications interact with. The platform APIs are the functions,
    variables, and other code pieces that are public-facing in the platform. For example,
    if an application needs to compute a square root, they might call a square root
    API function provided by the platform. Or if the application wants to display
    a button to the user, they might use a button API to handle its functionality
    and visuals.'
  prefs: []
  type: TYPE_NORMAL
- en: The APIs are the tip of the iceberg for the platform. Although there are thousands
    of APIs in Android, they are really just the entry point to the platform functionality,
    most of which is embedded in the code that implements these APIs. So, for example,
    an application may create a button by calling a couple of API functions to do
    that, but under the hood the platform is doing a lot of work to satisfy all of
    the details that a button entails (including how to display it, how to handle
    click events on the screen, and how to draw the text for the button’s label).
  prefs: []
  type: TYPE_NORMAL
- en: Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *framework* is the large layer of system software that handles all the functionality
    exposed through the public APIs. That is, the framework is responsible for both
    the APIs as well as the implementation of those APIs. In the previous example,
    this is where the button functionality lives, among other bits. The framework
    encompasses, really, everything that the entire platform is capable of, like location
    services, data storage, telephony, graphics, UI, and, well, everything. The UI
    toolkit for Android is a subset of framework functionality that is specific to
    user interface APIs and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The system piece in the diagram above denotes software that is running that
    is not directly accessible by applications, but that is responsible for the device's
    overall functionality. For example, on Android, the *window manager* is responsible
    for displaying applications in their own windows and navigating between those
    windows as different applications are launched. There is also a service running
    that handles low-memory situations by killing applications that have not been
    used recently so that more recently used applications can have the memory they
    need. All of those things are running indirectly, on the user’s behalf.
  prefs: []
  type: TYPE_NORMAL
- en: The system calls public APIs for various pieces of necessary framework functionality,
    but the system may also call functions in the framework directly (which is why
    it is shown in the diagram beside, rather than on top of, the APIs layer).
  prefs: []
  type: TYPE_NORMAL
- en: Kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *kernel*, with its device drivers, is the lowest level of software running
    on the device. It handles the fundamental capabilities of the device that the
    overall system needs. For example, each application runs in a *process*; the management
    of the many processes running on the device (isolating them from each other and
    scheduling time for them to run on the CPU) is the kernel's responsibility. The
    kernel is also responsible for loading and executing the drivers on the system.
    All of the software we’ve talked about so far is generic to any device, but drivers
    are specific to particular pieces of hardware. For example, to receive clicks
    on a button, a piece of hardware in the device is able to turn touches on the
    screen into information about where those touches occurred. A driver in the kernel
    does this, routing the information from hardware-specific data into events that
    are then sent into the framework for processing. Similarly, there are drivers
    for storage, sensors, display, camera, and any other hardware that a device may
    have. The kernel loads these drivers when the device boots and communicates to
    these pieces of hardware through the drivers when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, I use the term *platform* to encompass everything here except the
    applications. It’s a very generic term, and I use it broadly to refer to everything
    that Android provides for application developers and for users. The platform software
    for Android is all of the stuff that provides facilities for developers writing
    applications as well as everything that the device needs overall to display the
    basic UI and functionality to users. So when I talk about the platform team on
    Android, it’s basically everyone that works on all of the stuff above other than
    the applications: the engineers working on the kernel, the framework, the system
    software, and the APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Geeky Terms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to everything that fit conveniently in the previous diagram, a few
    other technical terms used in the book are also worth explaining. I’m sure I’ll
    miss a few. If only there were some kind of “search engine” capability on the
    internet so that readers could easily look up terms that I inadvertently forgot
    to include. . . .
  prefs: []
  type: TYPE_NORMAL
- en: Changelist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Changelist (CL)* refers to the code change required to fix a bug, implement
    a new feature, update the docs—whatever. A CL can be as little as a one-line fix
    or as much as thousands of lines of code to implement a large swath of new APIs
    and capabilities. Peer developers far prefer the former because one-liners are
    easy to review and approve. Woe be unto the developer that leans on their team
    to review a 10,000-line CL when everyone is under the gun already to deliver their
    own fixes and features.'
  prefs: []
  type: TYPE_NORMAL
- en: Changelist is apparently a term used primarily by Google engineering. Other
    software systems use terms like *patch* or *PR* (pull request) to mean the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *emulator* is a software program that mimics a hardware device. Developers
    use emulators (in particular, they use the Android emulator) to make it easier
    to run and test their programs on the host computer they are using to write their
    applications. Instead of requiring a physical device to test an app (and perhaps
    to suffer delays downloading the program to the device every time it is recompiled),
    they can simply run a virtual device on their powerful desktop computer instead.
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference between an *emulator* and a *simulator*; an emulator actually
    mimics everything happening on a real device, down to the CPU and the instructions
    running on it. A simulator is usually a simpler (and, often, faster) program because
    it does not bother emulating everything on a device, but rather just enough to
    make it work essentially like a device. A simulator is good enough for testing
    basic functionality of a program but might miss out on enough important details
    (such as how the hardware sensors work), so a developer is better off using an
    emulator or a real device to validate the actual functionality in the real world.
    Android had a simulator in the very early days, but eventually stopped maintaining
    it and switched to having only an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *IDE (integrated development environment)* is a suite of tools that programmers
    use for writing, building, running, debugging, and testing their applications.
    This includes things like a text editor—which is usually knowledgeable about the
    language(s) that programmers use, with shortcuts for formatting and highlighting
    code written in that language, plus other features like code completion and linking—as
    well as a compiler for building the application. For example, Android Studio (the
    IDE provided to developers by the Android team) includes a large and growing suite
    of tools, including various editors (for Java, XML, and C/C++), the compiler for
    building the code into an Android application, a debugger for stepping through
    the program as it runs on a device, and various other specific utilities for analyzing
    performance, monitoring memory usage, and building UI assets.
  prefs: []
  type: TYPE_NORMAL
- en: Java ME/J2ME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java ME (or J2ME,^([1](#b01-footnote-1)) during the early days of Android development)
    is short for Java Platform, Micro Edition, a software platform for early mobile
    devices. Java ME used the Java programming language and provided functionality
    that application developers needed to write apps for those devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'J2ME promised something in the mobile space that developers desperately wanted:
    a common platform that would allow them to write applications for many different
    devices, as opposed to having to re-tune their apps for vastly different hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: However, unlike the desktop or server versions of Java, Java ME came in a large
    variety of versions, called *profiles*, which meant that the capabilities of any
    particular implementation of Java ME on a device did not necessarily match that
    of another device, so Java ME developers had to deal with device variety issues
    after all.
  prefs: []
  type: TYPE_NORMAL
- en: OEM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *OEM (original equipment manufacturer)* is a company that makes the actual
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-Oriented Programming: Classes, Fields, and Methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The software used to write the Android platform, and to write Android applications,
    uses an approach called *object-oriented programming (OOP)*. Most popular/modern
    languages use a similar approach, including Java, C++, Kotlin, and more. In an
    OOP system, there are functional blocks called *classes* that present an API for
    doing a particular set of things. For example, Android has a `String` class for
    performing operations on text strings.
  prefs: []
  type: TYPE_NORMAL
- en: Each class may contain a set of *fields* or *properties*, which hold values.
    For example, a `String` object might hold the value of a text string, such as
    `"I want a sandwich."`
  prefs: []
  type: TYPE_NORMAL
- en: Each class may also contain a set of *methods* or *functions* that perform operations
    on that class (and potentially on other classes as well). For example, Android’s
    `String` class has a method named `toUpperCase()`, which does exactly what it
    says. So our sandwich string from before, if called with `toUpperCase()`, would
    return a value of `"I WANT A SANDWICH."`
  prefs: []
  type: TYPE_NORMAL
- en: Classes, with their various methods and fields, can be bundled together to create
    a *library*. The classes, fields, and methods in that library represent the API
    of that library, which applications (or other libraries) can call from their code
    to perform the operations that the library’s API offers.
  prefs: []
  type: TYPE_NORMAL
- en: SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *SDK (software development kit)* contains the pieces a programmer needs to
    write programs for a given platform. This includes the APIs they can call to perform
    functionality on the platform as well as the libraries that implement those APIs.
    Using an SDK, a programmer can write their application. Then using tools (usually
    supplied with the SDK), they can build the application (compile it into a form
    that is understandable by devices running the platform). Finally, they can run
    and debug their program on a device (or emulator) that is compatible with their
    compiled application.
  prefs: []
  type: TYPE_NORMAL
- en: Toolkit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Toolkit* overlaps in meaning, and usage, with framework, library, and APIs.
    In general, toolkit is used to mean a framework that is specific to user interface
    (UI) components. On Android, the toolkit is synonymous with the *UI* *toolkit*,
    or the APIs and implementation for the user interface technology of Android. It
    is considered a part of the overall Android framework, specifically the subset
    of the framework that deals with most of the visual aspects of the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All UI platforms have the concept of some kind of UI element, for things like
    buttons, or checkboxes, or sliders, or text, or containers of all of these objects.
    But the way that they refer to those things differs between platforms, so it’s
    confusing to tell what platform developers are talking about because they use
    different terms. Java’s Swing toolkit called them *components*, some platforms
    call them *elements* or *widgets*. On Android, UI elements are referred to as
    *Views*, named for the class that all of these elements inherit from (View). The
    container of Views (including other containers) is a view called ViewGroup. Finally,
    a *View hierarchy* is, well, it’s what it sounds like; a hierarchy of Views and
    ViewGroups, descending from the top-level parent ViewGroup, with its set of children,
    and down into any ViewGroups contained therein with their child Views, and so
    on.
  prefs: []
  type: TYPE_NORMAL
