["```\n$ gcc -O1 -o program program.c\n```", "```\n#define N 5\n\nint debug = N - 5; //constant folding changes this statement to debug = 0;\n```", "```\nint debug = 0;\n\n//sums up all the elements in an array\n\nint doubleSum(int *array, int length){\n\n    int i, total = 0;\n\n    for (i = 0; i < length; i++){\n\n        total += array[i];\n\n        if (debug) {\n\n            printf(\"array[%d] is: %d\\n\", i, array[i]);\n\n        }\n\n    }\n\n    return 2 * total;\n\n}\n\n```", "```\nint debug = 0;\n\n//sums up all the elements in an array\n\nint doubleSum(int *array, int length){\n\n    int i, total = 0;\n\n    for (i = 0; i < length; i++){\n\n        total += array[i];\n\n        if (0) { //debug replaced by constant propagation by compiler\n\n            printf(\"array[%d] is: %d\\n\", i, array[i]);\n\n        }\n\n    }\n\n    return 2 * total;\n\n}\n```", "```\n//declaration of debug removed through dead-code elimination\n\n//sums up all the elements in an array\n\nint doubleSum(int *array, int length){\n\n    int i, total = 0;\n\n    for (i = 0; i < length; i++){\n\n        total += array[i];\n\n        //if statement removed through data-flow analysis\n\n    }\n\n    return total + total; //simplifying expression\n\n}\n\n```", "```\nint silly(int a) {\n\n  return (a + 1) > a;\n\n}\n\n```", "```\nvoid shiftAdd(int *a, int *b){\n\n    *a = *a * 10; //multiply by 10\n\n    *a += *b; //add b\n\n}\n\n```", "```\nvoid shiftAddOpt(int *a, int *b){\n\n    *a = (*a * 10) + *b;\n\n}\n\n```", "```\nint main(void){\n\n    int x = 5;\n\n    int y = 6;\n\n    shiftAdd(&x, &y); //should produce 56\n\n    printf(\"shiftAdd produces: %d\\n\", x);\n\n    x = 5; //reset x\n\n    shiftAddOpt(&x, &y); //should produce 56\n\n    printf(\"shiftAddOpt produces: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n$ gcc -o shiftadd shiftadd.c\n\n$ ./shiftadd\n\nshiftAdd produces: 56\n\nshiftAddOpt produces: 56\n\n```", "```\nint main(void){\n\n    int x = 5;\n\n    shiftAdd(&x, &x); //should produce 55\n\n    printf(\"shiftAdd produces: %d\\n\", x);\n\n    x = 5; //reset x\n\n    shiftAddOpt(&x, &x); //should produce 55\n\n    printf(\"shiftAddOpt produces: %d\\n\", x);\n\n    return 0;\n\n}\n\n```", "```\n$ gcc -o shiftadd shiftadd.c\n\n$ ./shiftadd\n\nshiftAdd produces: 100\n\nshiftAddOpt produces: 55\n\n```", "```\nvoid shiftAdd(int *a, int b){\n\n    *a = *a * 10; //multiply by 10\n\n    *a += b; //add b\n\n}\n\n```", "```\nvoid shiftAddOpt(int *a, int b){\n\n    *a = (*a * 10) + b;\n\n}\n\n```", "```\n//helper function: checks to see if a number is prime\n\nint isPrime(int x) {\n\n    int i;\n\n    for (i = 2; i < sqrt(x) + 1; i++) { //no prime number is less than 2\n\n        if (x % i == 0) { //if the number is divisible by i\n\n            return 0; //it is not prime\n\n        }\n\n    }\n\n    return 1; //otherwise it is prime\n\n}\n\n// finds the next prime\n\nint getNextPrime(int prev) {\n\n    int next = prev + 1;\n\n    while (!isPrime(next)) { //while the number is not prime\n\n        next++; //increment and check again\n\n    }\n\n    return next;\n\n}\n\n// generates a sequence of primes\n\nint genPrimeSequence(int *array, int limit) {\n\n    int i;\n\n    int len = limit;\n\n    if (len == 0) return 0;\n\n    array[0] = 2; //initialize the first number to 2\n\n    for (i = 1; i < len; i++) {\n\n        array[i] = getNextPrime(array[i-1]); //fill in the array\n\n        if (array[i] > limit) {\n\n            len = i;\n\n            return len;\n\n        }\n\n    }\n\n    return len;\n\n}\n\nint main(int argc, char **argv) {\n\n  //error-handling and timing code omitted for brevity\n\n  int *array = allocateArray(limit);\n\n  int length = genPrimeSequence(array, limit);\n\n  return 0;\n\n}\n```", "```\n$ gcc -o optExample optExample.c -lm\n```", "```\nint main(int argc, char **argv) {\n\n    //error-handling and timing code omitted for brevity\n\n    int limit = strtol(argv[1], NULL, 10);\n\n    int length = limit;\n\n    int *array = allocateArray(length); //allocates array of specified length\n\n    genPrimeSequence(array, limit, &length); //generates sequence of primes\n\n    return 0;\n\n}\n\n```", "```\n$ gcc -o optExample optExample.c -lm\n\n$ time -p ./optExample 5000000\n\nTime to allocate: 5.5e-05\n\nTime to generate primes: 3.85525\n\n348513 primes found.\n\nreal 3.85\n\nuser 3.86\n\nsys 0.00\n```", "```\n// helper function: checks to see if a number is prime\n\nint isPrime(int x) {\n\n    int i;\n\n    for (i = 2; i < sqrt(x) + 1; i++) { //no prime number is less than 2\n\n        if (x % i == 0) { //if the number is divisible by i\n\n            return 0; //it is not prime\n\n        }\n\n    }\n\n    return 1; //otherwise it is prime\n\n}\n\n// finds the next prime\n\nint getNextPrime(int prev) {\n\n    int next = prev + 1;\n\n    while (!isPrime(next)) { //while the number is not prime\n\n        next++; //increment and check again\n\n    }\n\n    return next;\n\n}\n\n// generates a sequence of primes\n\nint genPrimeSequence(int *array, int limit) {\n\n    int i;\n\n    int len = limit;\n\n    if (len == 0) return 0;\n\n    array[0] = 2; //initialize the first number to 2\n\n    for (i = 1; i < len; i++) {\n\n        array[i] = getNextPrime(array[i-1]); //fill in the array\n\n        if (array[i] > limit) {\n\n            len = i;\n\n            return len;\n\n        }\n\n    }\n\n    return len;\n\n}\n\n```", "```\n$ gcc -g -o optExample optExample.c -lm\n\n$ valgrind --tool=callgrind ./optExample 100000\n\n==32590== Callgrind, a call-graph generating cache profiler\n\n==32590== Copyright (C) 2002-2015, and GNU GPL'd, by Josef Weidendorfer et al.\n\n==32590== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n\n==32590== Command: ./optExample 100000\n\n==32590==\n\n==32590== For interactive control, run 'callgrind_control -h'.\n\nTime to allocate: 0.003869\n\nTime to generate primes: 0.644743\n\n9592 primes found.\n\n==32590==\n\n==32590== Events    : Ir\n\n==32590== Collected : 68338759\n\n==32590==\n\n==32590== I   refs:      68,338,759\n\n```", "```\n$ callgrind_annotate --auto=yes callgrind.out.32590\n\n ----------------------------------------------------------------\n\nProfile data file 'callgrind.out.32393' (creator: callgrind-3.11.0)\n\n ----------------------------------------------------------------\n\n...\n\n  .  //helper function: checks to see if a number is prime\n\n   400,004  int isPrime(int x) {\n\n         .      int i;\n\n36,047,657      for (i = 2; i < sqrt(x)+1; i++) { //no prime is less than 2\n\n13,826,015  => ???:sqrt (2765204x)\n\n16,533,672          if (x % i == 0) { //if the number is divisible by i\n\n   180,818              return 0; //it is not prime\n\n         .          }\n\n         .      }\n\n     9,592      return 1; //otherwise it is prime\n\n   200,002  }\n\n         .\n\n         .  // finds the next prime\n\n    38,368  int getNextPrime(int prev) {\n\n    28,776      int next = prev + 1;\n\n   509,597      while (!isPrime(next)) { //while the number is not prime\n\n67,198,556  => optExample.c:isPrime (100001x)\n\n    90,409          next++; //increment and check again\n\n         .      }\n\n     9,592      return next;\n\n    19,184  }\n\n         .\n\n         .  // generates a sequence of primes\n\n         6  int genPrimeSequence(int * array, int limit) {\n\n         .      int i;\n\n         2      int len = limit;\n\n         2      if (len == 0) return 0;\n\n         2      array[0]=2; //initialize the first number to 2\n\n    38,369      for (i = 1; i < len; i++) {\n\n   143,880          array[i] = getNextPrime(array[i-1]); //fill in the array\n\n67,894,482  => optExample.c:getNextPrime (9592x)\n\n    76,736          if (array[i] > limit){\n\n         2              len = i;\n\n         2              return len;\n\n         .          }\n\n         .      }\n\n         .      return len;\n\n         4  }\n\n```", "```\n//helper function: checks to see if a number is prime\n\nint isPrime(int x) {\n\n    int i;\n\n    int max = sqrt(x)+1;\n\n    for (i = 2; i < max; i++) { //no prime number is less than 2\n\n        if (x % i == 0) { //if the number is divisible by i\n\n            return 0; //it is not prime\n\n        }\n\n    }\n\n    return 1; //otherwise it is prime\n\n}\n\n```", "```\n$ gcc -g -o optExample2 optExample2.c -lm\n\n$ valgrind --tool=callgrind ./optExample2 100000\n\n$ callgrind_annotate --auto=yes callgrind.out.30086\n\n ------------------------------------------------------------------\n\nProfile data file 'callgrind.out.30086' (creator: callgrind-3.11.0)\n\n ------------------------------------------------------------------\n\n ...\n\n   400,004  int isPrime(int x) {\n\n         .      int i;\n\n   900,013      int max = sqrt(x)+1;\n\n   500,000  => ???:sqrt (100001x)\n\n11,122,449      for (i = 2; i < max; i++) { //no prime number is less than 2\n\n16,476,120          if (x % i == 0) { //if the number is divisible by i\n\n   180,818              return 0; //it is not prime\n\n         .          }\n\n         .      }\n\n     9,592      return 1; //otherwise it is prime\n\n   200,002  }\n\n         .\n\n         .  // finds the next prime\n\n    38,368  int getNextPrime(int prev) {\n\n    28,776      int next = prev + 1;\n\n   509,597      while (!isPrime(next)) { //while the number is not prime\n\n29,789,794  => optExample2.c:isPrime (100001x)\n\n    90,409          next++; //increment and check again\n\n         .      }\n\n     9,592      return next;\n\n    19,184  }\n\n```", "```\nint main(int argc, char **argv) {\n\n    // omitted for brevity\n\n    // some variables shortened for space considerations\n\n    int lim = strtol(argv[1], NULL, 10);\n\n    // allocation of array\n\n    int *a = allocateArray(lim);\n\n    // generates sequence of primes\n\n    int len = genPrimeSequence(a, lim);\n\n    return 0;\n\n}\n\n```", "```\nint main(int argc, char **argv) {\n\n    // omitted for brevity\n\n    // some variables shortened for space considerations\n\n    int lim = strtol(argv[1], NULL, 10);\n\n    // allocation of array (in-lined)\n\n    int *a = malloc(lim * sizeof(int));\n\n    // generates sequence of primes\n\n    int len = genPrimeSequence(a, lim);\n\n    return 0;\n\n}\n\n```", "```\n// helper function: checks to see if a number is prime\n\nint isPrime(int x) {\n\n    int i;\n\n    int max = sqrt(x) + 1;\n\n    // no prime number is less than 2\n\n    for (i = 2; i < max; i++) {\n\n        // if the number is divisible by i\n\n        if (x % i == 0) {\n\n            return 0; // it's not prime\n\n        }\n\n    }\n\n    return 1; // otherwise it is\n\n}\n\n```", "```\n// helper function: checks to see if a number is prime\n\nint isPrime(int x) {\n\n    int i;\n\n    int max = sqrt(x)+1;\n\n    // no prime number is less than 2\n\n    for (i = 2; i < max; i+=2) {\n\n        // if the number is divisible by i or i+1\n\n        if ( (x % i == 0) || (x % (i+1) == 0) ) {\n\n            return 0; // it's not prime\n\n        }\n\n    }\n\n    return 1; // otherwise it is\n\n}\n\n```", "```\n$ gcc -o matrixVector matrixVector.c\n\n$ ./matrixVector 10000 10000\n\nTime to allocate and fill matrices: 1.2827\n\nTime to allocate vector: 9.6e-05\n\nTime to matrix-vector multiply: 1.98402\n```", "```\nvoid matrixVectorMultiply(int **m,\n\n                          int *v,\n\n                          int **res,\n\n                          int row,\n\n                          int col) {\n\n    int i, j;\n\n    //cycles through every matrix column\n\n    //in inner-most loop (inefficient)\n\n    for (j = 0; j < col; j++){\n\n        for (i = 0; i < row; i++){\n\n            res[i][j] = m[i][j] * v[j];\n\n        }\n\n    }\n\n}\n\n```", "```\nvoid matrixVectorMultiply(int **m,\n\n                          int *v,\n\n                          int **res,\n\n                          int row,\n\n                          int col) {\n\n    int i, j;\n\n    //cycles through every row of matrix\n\n    //in inner-most loop\n\n    for (i = 0; i < row; i++){\n\n        for (j = 0; j < col; j++){\n\n            res[i][j] = m[i][j] * v[j];\n\n        }\n\n    }\n\n}\n\n```", "```\n$ gcc -o matrixVector2 matrixVector2.c\n\n$ ./matrixVector2 10000 10000\n\nTime to allocate and fill matrices: 1.29203\n\nTime to allocate vector: 0.000107\n\nTime to matrix-vector multiply: 0.271369\n```", "```\n//fill matrices\n\nfor (i = 0; i < rows; i++){\n\n    fillArrayRandom(matrix[i], cols);\n\n    fillArrayZeros(result[i], cols);\n\n}\n\n```", "```\nfor (i = 0; i < rows; i++) {\n\n    fillArrayRandom(matrix[i], cols);\n\n    fillArrayZeros(result[i], cols);\n\n } \n```", "```\nfor (i = 0; i < rows; i++) {\n\n    fillArrayRandom(matrix[i], cols);\n\n}\n\nfor (i = 0; i < rows; i++) {\n\n    fillArrayZeros(result[i], cols);\n\n}\n\n```", "```\nfor (i = 0; i < rows; i++) {\n\n    matrix[i] = allocateArray(cols);\n\n    result[i] = allocateArray(cols);\n\n}\n\nfor (i = 0; i < rows; i++) {\n\n    fillArrayRandom(matrix[i], cols);\n\n    fillArrayZeros(result[i], cols);\n\n}\n\n```", "```\nfor (i = 0; i < rows; i++) {\n\n    matrix[i] = allocateArray(cols);\n\n    result[i] = allocateArray(cols);\n\n}\n\nfor (i = 0; i < rows; i++) {\n\n    fillArrayRandom(matrix[i], cols);\n\n    //fillArrayZeros(result[i], cols); //no longer needed\n\n}\n\n```", "```\n$ gcc -o matrixVector3 matrixVector3.c\n\n$ ./matrixVector3 10000 10000\n\nTime to allocate matrices: 0.049073\n\nTime to fill matrices: 0.946801\n\nTime to allocate vector: 9.3e-05\n\nTime to matrix-vector multiply: 0.359525\n```", "```\n$ valgrind --tool=massif ./matrixVector3 10000 10000\n\n==7030== Massif, a heap profiler\n\n==7030== Copyright (C) 2003-2015, and GNU GPL'd, by Nicholas Nethercote\n\n==7030== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n\n==7030== Command: ./matrixVector3 10000 10000\n\n==7030==\n\nTime to allocate matrices: 0.049511\n\nTime to fill matrices: 4.31627\n\nTime to allocate vector: 0.001015\n\nTime to matrix-vector multiply: 0.62672\n\n==7030==\n```", "```\n$ ms_print massif.out.7030\n\n-----------------------------------------------------------------------------\n\nCommand:            ./matrixVector3 10000 10000\n\nMassif arguments:   (none)\n\nms_print arguments: massif.out.7030\n\n-----------------------------------------------------------------------------\n\n    MB\n\n763.3^                                                ::::::::::::::::::::::#\n\n     |:::::::::::::::::::::::::::::::::::::::::::::::::                     #\n\n     |:                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n     |@                                               :                     #\n\n   0 +-------------------------------------------------------------------->Gi\n\n     0                                                                  9.778\n\nNumber of snapshots: 80\n\n Detailed snapshots: [3, 12, 17, 22, 49, 59, 69, 79 (peak)]\n\n```", "```\n····\n\n------------------------------------------------------------------------------\n\n  n        time(i)         total(B)   useful-heap(B) extra-heap(B)   stacks(B)\n\n------------------------------------------------------------------------------\n\n 70      1,081,926      727,225,400      727,080,000       145,400          0\n\n 71      1,095,494      737,467,448      737,320,000       147,448          0\n\n 72      1,109,062      747,709,496      747,560,000       149,496          0\n\n 73      1,122,630      757,951,544      757,800,000       151,544          0\n\n 74      1,136,198      768,193,592      768,040,000       153,592          0\n\n 75      1,149,766      778,435,640      778,280,000       155,640          0\n\n 76      1,163,334      788,677,688      788,520,000       157,688          0\n\n 77      1,176,902      798,919,736      798,760,000       159,736          0\n\n 78  7,198,260,935      800,361,056      800,201,024       160,032          0\n\n 79 10,499,078,349      800,361,056      800,201,024       160,032          0\n\n99.98% (800,201,024B) (heap allocations) malloc/new/new[], --alloc-fns, etc.\n\n->99.96% (800,040,000B) 0x40089D: allocateArray (in matrixVector3)\n\n```", "```\n$ gcc -o genPrimes genPrimes.c\n\n$ ./genPrimes 5000000\n\nFound 348513 primes (0.122245 s)\n\n```"]