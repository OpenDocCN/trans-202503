- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: WRITING CODE THAT LOOPS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写循环代码
- en: '![Image](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00001.jpg)'
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到，条件语句可以根据满足的条件执行不同的代码分支。*循环*是你控制程序顺序的另一种方式。使用循环，你可以告诉计算机执行一段代码若干次。这使得你能够反复使用代码块，而不必每次都重写它们！
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有两种主要类型的循环：for-in 循环和 while 循环。for-in 循环告诉计算机执行一个确定次数的循环，它在你一开始就知道代码需要重复多少次时非常有用。while
    循环则告诉计算机在满足某个条件之前一直重复执行循环，这对于你更关注基于程序中的事件或条件重复代码的情况非常合适。让我们深入了解每种类型的循环，并进一步学习它！
- en: '**OPEN THE DEBUG AREA**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打开调试区域**'
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写循环之前，让我们确保你的 Playground 已经设置好显示调试区域。当你在 Playground 中编写 for-in 循环时，右侧的结果边栏只会告诉你循环执行了多少次。要查看循环的输出，你需要通过选择
    **视图** ▸ **调试区域** ▸ **显示调试区域**（⌘ -SHIFT -Y）来显示调试区域。如果这个菜单显示的是“隐藏调试区域”，那说明调试区域已经显示了，你无需做任何操作。
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示调试区域时，它默认出现在 Playground 的底部，你可以拖动其上方的分隔线来调整其高度。
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 FOR-IN 遍历范围和集合**'
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: A for-in 循环告诉计算机遍历一系列数字或集合中的每一项。我们将在[第六章](text00016.html#ch06)中详细讨论集合，但现在可以把集合想象成一组物品——比如一袋弹珠或一箱奖杯。让我们先看看如何遍历一系列数字。
- en: '![image](Image00091.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00091.jpg)'
- en: '**SAY HELLO!**'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打招呼！**'
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环告诉计算机类似这样的意思：“我想让这段代码执行 4 次。”要做到这一点，你首先写上 for 关键字，后面跟一个变量来计数循环执行了多少次，然后是
    in 关键字，最后是你希望循环遍历的数字范围。让我们编写一个简单的 for-in 循环，打印你的名字 4 次：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环以关键字 for 开始，后面跟着一个变量 ➊，它将用作计数器来遍历数字范围。我们将计数器变量命名为 number，但你可以给这个变量任何你想要的名字。计数器变量后面跟着关键字
    in。这个关键字告诉计算机期望一个整数范围。在 in 后，我们提供了一个我们希望 for-in 循环使用的范围 1...4 ➋。这叫做从 1 到 4 的 *闭区间*，它表示计数从
    1 开始，到 4 结束。三点符号（...）是 *闭区间运算符*。
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 for-in 循环中添加一行，这样我们就能看到 number 从 1 增加到 4。将以下代码行添加到循环中打印你名字的那一行后面：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环内部，我们像使用任何其他变量一样使用 number。这个语句打印一个包含 number 值的字符串。要将变量和常量嵌入到字符串中，你输入一个反斜杠，然后在括号内输入你想要打印的变量或常量，就像我们在
    ➊ 处做的那样。这会将变量的值与字符串的其余部分一起打印。很酷吧！
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出更加美观，在➋处我们还在句子的末尾添加了一个空的新行，方法是写下表示新行的特殊字符 \n。当该句子被打印时，计算机不会打印 \n，而是添加一个新行，就像你按下键盘上的
    RETURN 或 ENTER 键时一样。
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应该看起来像[图 4-1](text00014.html#ch04fig1)。如果你没有看到打印的文本，请确保通过按 ⌘ -SHIFT -Y 打开调试区域。
- en: '![image](Image00092.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00092.jpg)'
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：for-in 循环的调试区域显示*'
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环将运行 4 次。第一次循环时，number 等于 1；第二次循环时，它等于 2；依此类推，直到最后一次循环时，它等于 4。当 number
    达到 1 到 4 的范围的结束时，循环结束。
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环中，当计数器 number 在循环中循环，从 1 增加到 4 时，我们说计数器 *迭代* 了从 1 到 4 的范围。每次运行 for-in
    循环中的代码时，我们称之为一次 *迭代*。
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改这些数字以设置不同的范围进行循环。试试看，看看会发生什么！
- en: '**SAY GOOD MORNING!**'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**说早安！**'
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遍历数字范围外，for-in 循环对于遍历集合也很有用。在这里，你将使用一个称为 *数组* 的集合。我们将在[第 6 章](text00016.html#ch06)
    中详细讨论数组，但现在你只需要知道数组是存储在常量或变量中的一组项目。当你使用 for-in 循环遍历数组时，你是在告诉计算机“对于数组中的每一项，做某些事情！”让我们编写代码来向孩子们打招呼。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个叫做 kidsInClass 的数组，其中包含七个字符串。方括号告诉计算机我们正在创建一个数组，每个字符串用逗号分隔。(箭头表示长行在页面上换行—你不需要输入箭头。)
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印“Good Morning *kidsName* !”给每个名字在 kidsInClass 数组中，在 ➋ 处我们写 for kidsName in
    kidsInClass ，接着是大括号和我们的代码。大括号中的代码会针对数组中的每一项执行一次。这种类型的循环总是遵循格式 for *constantName*
    in *collectionName* ，其中 *constantName* 是你选择的名字，用来在循环内调用集合中的每个项。
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，for-in 循环内，我们写下代码来为每个名字打印问候语。为此，我们像使用其他常量一样使用 kidsName。kidsName 只在这个循环的大括号内存在，它临时存储当前孩子的名字，随着
    for-in 循环遍历数组。这样，我们可以在循环的每个周期打印每个名字，向大家说早安！
- en: '![image](Image00094.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00094.jpg)'
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 while 循环测试条件**'
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道计算机需要做多少次某件事时，使用 for-in 循环非常合适，但有时你可能希望计算机反复执行某个操作，直到满足特定条件。为此，你应该使用 while
    循环。
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环有两种类型：while 和 repeat-while 。它们都包含在条件为真时会重复执行的代码块。while 循环和 repeat-while
    循环的区别在于，while 循环在执行代码块之前检查条件，而 repeat-while 循环在执行代码块之后检查条件。让我们来看一些例子，看看它们如何工作！
- en: '**GUESS MY NUMBER**'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**猜猜我的数字**'
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环会一直执行某个操作，直到某个条件为真。这对于猜数字游戏非常有效，比如当你想出一个数字，并让朋友猜它是什么，直到他们猜对为止。我们可以写一个程序来实现这一点！你将选择一个
    1 到 20 之间的数字，计算机会尝试猜出它是什么。写下以下代码到一个新的 playground 中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个特殊的库，叫做 Foundation 框架，它包含了我们需要的函数来生成随机数。为了使用这个库，我们在我们的 playground
    顶部写下导入 Foundation 的代码 ➊ 。(我们将在[第7章](text00017.html#ch07)中更详细地讨论函数。)
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个常量叫做 numberIAmThinkingOf，并将其设定为 1 到 20 之间的任何数字。然后，在 ➋ 处，我们创建一个变量叫做
    currentGuess，代表计算机的猜测，并将其设置为 -1 。将 currentGuess 变量设置为 -1 是一种很好的方式，表示计算机还没有进行猜测。
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环从关键字 `while` 开始，在 ➌ 处，后面跟着一个条件 ➍ 。在这个例子中，条件检查当前的 `currentGuess` 是否不等于
    `numberIAmThinkingOf` 。如果条件为真，意味着计算机还没有正确猜到我们的秘密数字，while 循环内部的语句就会执行。
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 while 循环依赖于条件，所以非常重要的一点是，你必须确保在 while 循环内部有某种方式改变条件，否则循环将永远执行下去，永远不会进入程序的下一部分！与
    for-in 循环不同，while 循环没有自动增加或减少的计数器，完全由你来控制！
- en: '![image](Image00095.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00095.jpg)'
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➎ 处通过让计算机猜测 1 到 20 之间的新数字，然后将该新数字赋值给 `currentGuess` 来实现这一点。别太担心完全理解那行代码的含义；只需知道
    `Int(arc4random_uniform(20))` 会生成一个 0 到 19 之间的随机整数，然后我们在该行末尾加上 `+ 1`，这样就能得到 1
    到 20 之间的数字。
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不小心陷入了一个无限循环，最好的方法是通过在 `while` 关键字前加上两个斜杠来将其注释掉。这将停止循环，方便你找出问题所在。
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机最终猜到正确的数字时，while 循环结束，并向控制台打印一条友好的信息。输出应该类似于 [图 4-2](text00014.html#ch04fig2)。
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 playground 中输入这个程序时，你的循环运行了多少次？它可能与 [图 4-2](text00014.html#ch04fig2) 中的次数不同。这个数字猜测程序是一个使用
    while 循环可以做到的例子，而 for-in 循环无法做到。我们无法知道计算机需要多少次随机猜测才能猜中正确的数字，因此不能用 for-in 循环来做这个任务。while
    循环允许计算机继续猜测，直到它猜到正确的答案。
- en: '![image](Image00096.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00096.jpg)'
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：数字猜测程序的输出*'
- en: '**SHRINK AWAY**'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**缩小**'
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: repeat-while 循环与 while 循环非常相似，只是它的写法不同，并且结束循环的条件是在循环运行后才进行检查的。我们将通过删除句子中的字母直到它消失来测试
    repeat-while 循环。
- en: 'Try out the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下代码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要使用一种方法来截取字符串中的最后一个字符。我们需要使用之前在猜数字游戏中用到的相同的**Foundation**框架，因此在你的
    playground 顶部输入 `import Foundation`。
- en: '![image](Image00097.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00097.jpg)'
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的计算机看到一个repeat-while循环时，它会执行repeat关键字后的代码块 ➊，然后检查while关键字后面的条件 ➌ 是否为真。在我们的示例中，我们从创建一个名为shrink的字符串变量开始。在repeat代码块中，我们打印字符串，然后删除最后一个字符。你不需要记住或理解dropLast()方法的具体实现；只需知道➋处的代码会删除字符串中的最后一个字符。
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过删除最后一个字符并将这个更短的字符串保存在shrink变量中，来制作一个更短的字符串。这将更新shrink变量的值为新的、更短的字符串。在这种情况下，我们想要不断地删除字符，直到没有字符剩下。所以，我们的while循环的条件是，当shrink中的字符数量大于0时，重复这个过程。要确定字符串中的字符数量，你可以在字符串名称后面输入.characters.count。查看[图
    4-3](text00014.html#ch04fig3)来看看那个不可思议的缩小句子！
- en: '![image](Image00098.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00098.jpg)'
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：救命！我在缩小！*'
- en: '**WHICH LOOP TO USE?**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用哪个循环？**'
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在代码中有多种方式可以创建循环。作为程序员，你可以选择最适合你需求的方式。请记住，通常没有唯一的正确答案，因为根据编写方式，for-in、while和repeat-while循环都可以完成相同的任务。当你不知道循环需要执行多少次时，你可能会选择while或repeat-while循环，但几乎可以通过while循环实现每个for-in循环。通常，最好选择你最理解的一种。
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为另一种类型的循环更适合某个特定情况，改变主意并尝试新技巧也是完全可以的。你编写的第一段代码不必是完美的，实际上（即便是经验丰富的程序员）几乎永远也不会完美！但编程的重点是练习和解决问题：写一点代码，看看它如何工作，然后再回来改进它。
- en: '**NESTING AND SCOPE**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套和作用域**'
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何编写循环和条件语句来做出选择了。你还可以将这些元素几乎以任何你想要的方式组合在一起。例如，你可以在for-in循环中放入if语句，可以在if块中放入while循环，或者将一个for-in循环放入另一个for-in循环中。当你将循环和条件语句组合时，有两个重要概念需要牢记：嵌套和作用域。
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码块的嵌套**'
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个代码块放在另一个代码块内时，这就叫做*嵌套*。所以，如果你在一个`while`循环中写了一个 if 语句，我们就称它为*嵌套的* if 语句。记住，当我们说*代码块*时，我们指的是在大括号`{}`之间的代码。举个例子，输入以下代码，它将输出一个星号和破折号组成的三角形模式：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看[图 4-4](text00014.html#ch04fig4)。我们为 Xcode 添加了一些颜色，帮助你看清每个嵌套的代码块。
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要嵌套任意数量的代码块。在这个例子中，我们将每个代码块分别称为 Nest A、Nest B、Nest C，依此类推。正如你在[图 4-4](text00014.html#ch04fig4)中看到的，我们的程序包含一个最外层的
    Nest A，它包含了`for count in 1...10`语句内的所有代码。Nest A 包含两个嵌套的代码块，Nest B 和 Nest D。每个嵌套的代码块中也包含一个嵌套：Nest
    C 位于 Nest B 内，而 Nest E 位于 Nest D 内。
- en: '![image](Image00099.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00099.jpg)'
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：一个嵌套的 if-else 语句与嵌套的 for-in 循环*'
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入代码，看看发生了什么。在 ➊ 位置，有一个最外层的`for-in`循环，我们称之为 Nest A，它会运行 10 次，count 从 1
    增加到 10。在那个`for-in`循环内部，在 ➋ 位置有一个嵌套的 if-else 语句，它会检查 count 是偶数还是奇数。那个 if 语句包含了
    Nest B。为了检查一个数是否是偶数，我们使用模运算符（%），它告诉我们当一个整数被另一个整数除时，余数是多少。如果一个数除以 2 的余数是 0，那么它一定是偶数。因此，为了判断
    count 是否是偶数，我们检查是否 `count % 2 == 0`。
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 count 是偶数，我们打印一串星号（*）。我们使用 count 来决定打印多少个星号。我们通过创建一个空的 starString 字符串，并使用一个嵌套的`for-in`循环，Nest
    C，在 ➌ 位置每次让 starCount 从 1 迭代到 count 时，添加一个星号。在嵌套的`for-in`循环结束后，在 ➍ 位置我们打印我们的 starString，它现在包含了
    count 个星号。我们打印一个嵌套的 else 语句 ➎，我们称之为 Nest D。当 count 为奇数时，我们按照 Nest E 中的指示，打印出一串破折号而不是星号。
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的作用域**'
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，变量有*作用域*，作用域指的是变量存在的位置以及可以使用它的地方。当你在嵌套的代码块内声明一个常量或变量时，该常量或变量在外部是不存在的。这意味着它的作用域仅限于它所在的代码块以及该代码块内的所有嵌套代码。[图
    4-5](text00014.html#ch04fig5)展示了我们嵌套代码中变量的作用域。
- en: '![image](Image00100.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00100.jpg)'
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：变量或常量的作用域仅限于其声明所在的嵌套块，以及该嵌套块中所有嵌套的代码。*'
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中声明了五个变量：count、starString、starCount、dashString 和 dashCount。最外层的嵌套，Nest
    A，只能看到 count。它无法访问其内部嵌套代码块中的任何变量或常量，这意味着你不能使用在 Nest B 或 C 中声明的变量或常量。变量 starString
    在 Nest B 中声明。因此，Nest B 可以访问 starString 以及在 Nest A 中创建的任何内容，包括 count。Nest C 可以访问
    starCount、starString 和 count。类似地，在 else 子句中，Nest D 可以访问 count 和 dashString，Nest
    E 可以访问 count、dashString 和 dashCount。如果你尝试使用一个块无法访问的变量，因为它在其作用域之外，你将遇到错误。例如，你不能在最外层的
    Nest A 中打印 dashString。
- en: '![image](Image00101.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00101.jpg)'
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我们将编写代码来创建一个问候语。如果是早晨，我们希望问候语为“Good Morning”。否则，我们希望问候语为“Good Afternoon”。请输入以下代码到你的
    playground 中：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在这个 if-else 语句之后打印 greeting 时，你会遇到错误，如[图 4-6](text00014.html#ch04fig6)所示。变量
    greeting 超出了 if-else 块的作用域，因此计算机不知道 greeting 是什么。
- en: '![image](Image00102.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00102.jpg)'
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：尝试在作用域外访问 greeting 会导致错误。*'
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你必须在 if-else 块外声明 greeting。按照下面的方式重写 greeting 代码以输出问候语：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在 if-else 块之前（在 ➊ 处）声明了 greeting 为空字符串。然后，根据 isMorning 是否为 true 或 false，将
    greeting 设置为“Good Morning”或“Good Afternoon”。最后，我们在 ➋ 处打印 greeting，因为它与打印语句在同一作用域内。
- en: '**WHAT YOU LEARNED**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用循环重复代码。你了解了你可以使用 for-in 循环或 while 循环来实现许多相同的目标。for-in 循环非常适合循环遍历一组项目并对每个项目执行某些操作，而
    while 循环更适用于你不知道循环需要运行多少次的情况。
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，我们将介绍 Swift 中的一种新变量类型——可选类型（optionals）。可选类型是可以有值也可以没有值的变量。当你需要创建一个变量，但又不知道它的值时，可选类型非常有用。
- en: WRITING CODE THAT LOOPS
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写循环代码
- en: '![Image](Image00001.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00001.jpg)'
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到，使用条件语句可以根据满足的条件执行不同的代码分支。*循环*是你控制程序执行顺序的另一种方式。通过循环，你可以告诉计算机执行某个代码块若干次。这使得你可以反复使用代码块，而不需要每次都重新编写它们！
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有两种主要类型的循环：for-in 循环和 while 循环。for-in 循环告诉计算机运行循环一定次数，它在你知道需要多少次重复时非常有用。while
    循环告诉计算机不断运行循环，直到满足某个条件，这在你更关心根据程序中的事件或条件来重复代码时非常有用。让我们深入了解每种循环类型，学习更多内容！
- en: '**OPEN THE DEBUG AREA**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打开调试区域**'
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写循环之前，让我们确保你的 playground 已经设置好显示调试区域。当你在 playground 中编写 for-in 循环时，右侧的结果侧边栏仅告诉你循环执行了多少次。要查看循环的输出，你需要通过选择
    **视图** ▸ **调试区域** ▸ **显示调试区域** (⌘ -SHIFT -Y) 来显示 playground 的调试区域。如果此菜单显示“隐藏调试区域”，那么调试区域已经显示，你不需要做任何操作。
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示调试区域时，它默认会出现在 playground 的底部，你可以拖动它上方的分隔线来调整它的高度。
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 FOR-IN 遍历范围和集合**'
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环告诉计算机在一个数字范围内或在集合中的每个项目上运行循环。我们将在[第6章](text00016.html#ch06)中详细讨论集合，但现在可以将集合理解为一组项目——比如一袋弹珠或一箱奖杯。让我们先看看如何遍历一个数字范围。
- en: '![image](Image00091.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00091.jpg)'
- en: '**SAY HELLO!**'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打个招呼！**'
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环告诉计算机类似于“我想运行这段代码 4 次”。为此，你需要编写 for 关键字，后面跟着一个计数循环执行次数的变量，然后是
    in 关键字，最后是你希望循环遍历的数字范围。让我们编写一个简单的 for-in 循环，打印你的名字 4 次：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环以关键字 for 开始，后面跟着一个变量 ➊，它将用作计数器，用来遍历数字范围。我们将计数器变量命名为 number，但你可以为这个变量取任何你喜欢的名字。在计数器变量后面是关键字
    in。这个关键字告诉计算机预期一个整数范围。在 in 后面，我们提供想要 for-in 循环使用的范围 1...4 ➋。这是一个从 1 到 4 的*闭区间*，表示计数从
    1 开始，直到 4 结束。三个点符号（...）是*闭区间运算符*。
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 for-in 循环中添加一行代码，这样我们就可以看到 number 从 1 到 4 是如何变化的。在打印你名字的那行代码之后，添加以下代码：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环内部，我们像使用任何其他变量一样使用 number。此语句打印包含 number 值的字符串。要将变量和常量嵌入字符串中，你只需要输入反斜杠，然后在括号中输入你想要打印的变量或常量，就像我们在
    ➊ 所做的那样。这会将变量的值与字符串的其余部分一起打印出来。非常酷吧！
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出更漂亮，在 ➋ 我们还在句子的末尾添加了一个空的新行，通过写特殊字符 `\n` 来实现。当那句话被打印时，计算机会不打印 `\n`，而是换行，就像你按下
    RETURN 或 ENTER 键时那样。
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应该显示像[图 4-1](text00014.html#ch04fig1)那样。如果你没有看到打印的文本，请确保调试区域已打开，按下 ⌘ -SHIFT
    -Y。
- en: '![image](Image00092.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00092.jpg)'
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：for-in 循环的调试区域显示*'
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环将执行 4 次。第一次循环时，number 等于 1；第二次循环时，number 等于 2；依此类推，直到最后一次循环，number
    等于 4。当 number 达到范围 1 到 4 的末尾时，循环结束。
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环中，当计数器 number 在循环中从 1 增加到 4 时，我们说计数器 *遍历* 从 1 到 4 的范围。每次 for-in 循环中的代码运行时，我们称之为一次
    *迭代*。
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改变这些数字来设置不同的循环范围。试试看，看看会发生什么！
- en: '**SAY GOOD MORNING!**'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**早上好！**'
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遍历数字范围外，for-in 循环还可以用于遍历集合。在这里，你将使用一个叫做 *数组* 的集合。我们将在[第 6 章](text00016.html#ch06)
    中更详细地讨论数组，但现在你只需要知道数组是存储在常量或变量中的项目列表。当你使用 for-in 循环遍历数组时，你是在告诉计算机“对数组中的每一项执行某些操作！”让我们编写代码来向孩子们问好。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们创建了一个名为 kidsInClass 的数组，包含七个字符串。方括号告诉计算机我们正在创建一个数组，数组中的每个字符串之间用逗号分隔。（箭头表示长行已在页面上换行——你不需要输入箭头。）
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印每个名字的 “早上好 *kidsName* !”，在 ➋ 我们写 `for kidsName in kidsInClass`，然后是花括号和我们的代码。花括号中的代码会对数组中的每一项运行一次。这种循环始终遵循格式
    `for *constantName* in *collectionName*`，其中 *constantName* 是你选择的名称，用于在循环中调用集合中的每一项。
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，在for-in循环内部，我们编写代码以打印每个名字的问候语。为此，我们像使用任何其他常量一样使用kidsName。kidsName仅存在于此循环的花括号内，并暂时存储当前孩子的名字，在for-in循环遍历数组时进行更新。通过这种方式，我们可以在每次循环中打印每个名字，向大家说早安！
- en: '![image](Image00094.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00094.jpg)'
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用while循环测试条件**'
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道计算机需要执行多少次操作时，for-in循环非常适合，但有时你可能希望计算机不断地执行某个操作，直到满足特定条件。对此，你应该使用while循环。
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: while循环有两种类型：while和repeat-while。它们都包含会反复执行的代码块，只要条件为真。while循环和repeat-while循环的区别在于，while循环在执行代码块之前检查条件，而repeat-while循环在执行代码块之后检查条件。让我们来看一些例子，看看它们如何工作！
- en: '**GUESS MY NUMBER**'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**猜我的数字**'
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: while循环会一直执行某些操作，直到某个条件为真。这在猜数字游戏中非常有效，比如你想到一个数字，并让朋友猜测它是什么，直到他们猜对为止。我们可以编写一个程序来实现这个功能！你会从1到20之间选择一个数字，然后计算机将尝试猜测它是什么。请在新的playground中编写以下代码：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个特殊的库，叫做Foundation框架，它具有我们需要的功能来生成一个随机数字。要使用这个库，我们需要在playground的顶部写上import
    Foundation ➊这行代码。（我们将在[第7章](text00017.html#ch07)中详细讨论函数。）
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为numberIAmThinkingOf的常量，并将其设置为1到20之间的任何数字。然后，在➋处，我们创建一个名为currentGuess的变量，用来表示计算机的猜测，并将其设置为-1。将currentGuess变量设置为-1是一个很好的方法，用来表示计算机尚未进行猜测。
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: while循环从关键词while在➌处开始，接着是一个条件在➍处。在这个例子中，条件检查currentGuess是否不等于numberIAmThinkingOf。如果条件为真，说明计算机还没有正确猜到我们的秘密数字，那么while循环内部的语句就会执行。
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为while循环依赖于一个条件，所以非常重要的是在while循环内部包含某种方式来改变条件，否则它会无限执行下去，永远无法进入程序的下一部分！与for-in循环不同，while循环没有一个自动增加或减少的计数器，控制它的工作完全由你来掌控！
- en: '![image](Image00095.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00095.jpg)'
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➎ 处让计算机猜测一个 1 到 20 之间的新数字，然后将这个新数字放入 currentGuess 中。你无需过于担心完全理解那行代码的细节；只需知道
    Int(arc4random_uniform(20)) 会生成一个介于 0 和 19 之间的随机整数，我们在该行的末尾加上 + 1，这样最终得到的数字就在
    1 到 20 之间。
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不小心陷入了一个无限循环，最好的做法是通过在 while 关键字前加上两个斜杠来将其注释掉。这样可以停止循环，让你找出问题所在。
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机最终猜到正确的数字时，while 循环结束，并且会向控制台打印出一条友好的消息。输出应该类似于[图 4-2](text00014.html#ch04fig2)。
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个程序输入到 playground 中时，你的循环运行了多少次？这个次数很可能与[图 4-2](text00014.html#ch04fig2)中的次数不同。这个数字猜测程序是一个使用
    while 循环的例子，而这种循环是 for-in 循环无法做到的。我们无法知道计算机需要多少次随机猜测才能猜中正确的数字，因此无法用 for-in 循环来实现这一点。while
    循环让计算机可以不停地猜测，直到猜出正确的答案。
- en: '![image](Image00096.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00096.jpg)'
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：数字猜测程序的输出*'
- en: '**SHRINK AWAY**'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**缩小吧**'
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: repeat-while 循环与 while 循环非常相似，只不过它的写法不同，并且结束循环的条件是在循环执行 *后* 检查的。我们将通过删除一个句子中的字母直到它消失来测试
    repeat-while 循环。
- en: 'Try out the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下代码：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要使用一个方法来去掉字符串中的最后一个字符。我们需要使用与猜数字游戏中相同的 Foundation 框架，因此在 playground
    顶部输入 import Foundation。（我们将在[第 8 章](text00018.html#ch08)中更详细地讨论方法。）
- en: '![image](Image00097.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00097.jpg)'
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的计算机看到一个 repeat-while 循环时，它会运行 repeat 关键字后面的代码块 ➊，然后检查 while 关键字后面的条件 ➌ 是否为真。在我们的示例中，我们首先创建了一个名为
    shrinking 的变量字符串。在 repeat 块中，我们打印我们的字符串，然后去掉最后一个字符。你不必记住或理解实现这一功能的 dropLast()
    方法；只需知道 ➋ 处的代码会从我们的字符串中移除最后一个字符。
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过去掉最后一个字符并将这个更短的字符串保存在 shrinking 变量中，来让我们的 shrinking 字符串变得更短。这会将 shrinking
    的值更新为新的、更短的字符串。在这种情况下，我们希望不断去除字符，直到没有字符剩下。所以我们的 while 循环的条件是只要 shrinking 中的字符数大于
    0，就重复这个过程。要确定字符串中的字符数，可以在字符串名称后输入 .characters.count。查看 [图 4-3](text00014.html#ch04fig3)，看看不可思议的缩短句子！
- en: '![image](Image00098.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00098.jpg)'
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：救命！我在缩小！*'
- en: '**WHICH LOOP TO USE?**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用哪个循环？**'
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以通过多种方式在代码中创建循环。由你这个程序员来决定哪种方式适合你需要做的事情。请记住，通常没有唯一正确的答案，因为 for-in、while
    和 repeat-while 循环可以做相同的事情，具体取决于它们的写法。当你不知道循环需要运行多少次时，你可能会需要使用 while 或 repeat-while
    循环，但你几乎可以用 while 循环完成几乎所有的 for-in 循环。通常最好选择你最理解的那一个。
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为其他类型的循环在特定情况下会更有效，稍后改变主意并尝试新技术也是完全可以的。你写的第一段代码不需要完美，事实上（即使是经验丰富的程序员）它几乎永远不会是完美的！但编码的重点是练习和解决问题：写一点代码，看看它是如何工作的，然后再回来改进它。
- en: '**NESTING AND SCOPE**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套和作用域**'
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你知道如何编写循环和条件语句来做出选择了。你还可以将这些元素几乎以任何你想要的方式组合起来。例如，你可以在 for-in 循环中放入 if 语句，在
    if 块中放入 while 循环，或在另一个 for-in 循环中放入 for-in 循环。当你组合循环和条件语句时，有两个重要的概念需要牢记：嵌套和作用域。
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码块的嵌套**'
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把一个代码块嵌套在另一个代码块内时，这叫做 *嵌套*。因此，如果你在 while 循环中写一个 if 语句，你就可以称它为 *嵌套的* if 语句。记住，当我们说
    *代码块* 时，是指在大括号 {} 之间的代码。作为示例，输入以下代码，它会输出一个由星号和破折号组成的三角形图案：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 [图 4-4](text00014.html#ch04fig4)。我们为 Xcode 增加了一些颜色，帮助你看到每个嵌套的代码块。
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌套任意数量的代码块。在这个示例中，我们将每个代码块称为Nest A、Nest B、Nest C，以此类推。如[图4-4](text00014.html#ch04fig4)所示，我们的程序包含一个最外层的Nest
    A，它包含了for count in 1...10语句中的所有代码。Nest A包含了两个嵌套的代码块，Nest B和Nest D。而这些嵌套代码块中的每一个也包含了一个嵌套：Nest
    B中包含了Nest C，Nest D中包含了Nest E。
- en: '![image](Image00099.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00099.jpg)'
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：一个包含嵌套for-in循环的嵌套if-else语句*'
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入代码，看看发生了什么。在➊处，有一个最外层的for-in循环，我们称之为Nest A，它将运行10次，当count从1增加到10时。这个for-in循环内部，在➋处有一个嵌套的if-else语句，它将检查count是偶数还是奇数。这个if语句包含Nest
    B。为了检查一个数字是否为偶数，我们使用模运算符（%），它告诉我们当一个整数被另一个整数除时，余数是多少。如果一个数字除以2后余数为0，那么它必须是一个偶数。因此，为了确定count是否为偶数，我们检查count
    % 2 == 0。
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果count是偶数，我们打印出一串星号（*）。我们用count来决定打印多少个星号。我们通过创建一个空的starString，然后使用嵌套的for-in循环（Nest
    C），在➌处每次starCount从1迭代到count时添加一个星号。当嵌套的for-in循环完成后，在➍处我们打印出我们的starString，它现在包含了count个星号。我们打印出一个嵌套的else语句➎，我们称之为Nest
    D。当count是奇数时，我们根据Nest E的指示打印出一串破折号，而不是星号。
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的作用域**'
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，变量有*作用域*，它指的是变量的存在范围以及它可以在哪些地方使用。当你在嵌套的代码块中声明常量或变量时，该常量或变量在该嵌套代码块外部并不存在。这意味着它的作用域仅限于它被声明的代码块以及该块中的任何嵌套代码。[图4-5](text00014.html#ch04fig5)展示了我们嵌套代码中变量的作用域。
- en: '![image](Image00100.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00100.jpg)'
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：变量或常量的作用域仅限于声明它的嵌套块，以及任何嵌套在该嵌套块中的代码。*'
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序中声明了五个变量：count、starString、starCount、dashString和dashCount。最外层的嵌套，Nest A，只能看到count。它无法访问其内部嵌套代码块中的任何变量或常量，这意味着你不能使用在Nest
    B或C中声明的变量或常量。变量starString在Nest B中声明。因此，Nest B可以访问starString以及在Nest A中创建的所有内容，包括count。Nest
    C可以访问starCount、starString和count。同样，在else分支中，Nest D可以访问count和dashString，而Nest E可以访问count、dashString和dashCount。如果你试图使用一个代码块无法访问的变量，因为它超出了作用域，你将会得到一个错误。例如，你不能在最外层的Nest
    A中打印dashString。
- en: '![image](Image00101.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00101.jpg)'
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。我们将编写一段代码来创建一个问候语。如果是早晨，我们希望问候语是“Good Morning”。否则，我们希望问候语是“Good Afternoon”。在你的playground中输入以下代码：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在if-else语句之后打印greeting时，你会得到一个错误，如[图4-6](text00014.html#ch04fig6)所示。变量greeting位于if-else块的作用域外，因此计算机不知道greeting是什么。
- en: '![image](Image00102.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00102.jpg)'
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：尝试在作用域之外访问greeting会导致错误。*'
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你必须在if-else块外声明greeting。按照如下方式重写greeting代码以输出问候语：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在if-else块之前声明了greeting为空字符串，在➊处。然后，根据isMorning是否为true或false，我们将greeting设置为“Good
    Morning”或“Good Afternoon”。最后，在➋处，if-else块之后，我们打印greeting，因为它在与print语句相同的作用域内声明。
- en: '**WHAT YOU LEARNED**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何使用循环来重复代码。你了解到，你可以使用for-in循环或while循环来完成许多相同的目标。for-in循环非常适合遍历一个集合并对每个项目执行同样的操作，而while循环更适合在你不知道循环需要运行多少次的情况下使用。
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，我们将介绍Swift中一种新的变量类型——可选值。可选值是可以有值也可以没有值的变量。当你需要创建一个变量，但还不知道它的值时，可选值非常有用。
- en: '![Image](Image00001.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00001.jpg)'
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到了使用条件语句来根据满足的条件执行不同的代码分支。*循环*是另一种控制程序顺序的方式。通过循环，你可以告诉计算机执行一个代码块多次。这让你能够反复使用代码块，而不需要重新编写它们！
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有两种主要的循环类型：for-in 循环和 while 循环。for-in 循环告诉计算机循环一定次数，它非常适用于你一开始就知道代码需要重复多少次的情况。while
    循环则告诉计算机在满足某个条件之前一直运行循环，它非常适用于你更关心基于程序中的事件或条件来重复执行代码的场景。让我们深入了解每种循环类型，并学习更多内容！
- en: '**OPEN THE DEBUG AREA**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打开调试区域**'
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写循环之前，确保你的 playground 已经设置好显示调试区域。当你在 playground 中编写 for-in 循环时，右侧的结果侧边栏仅告诉你循环运行了多少次。要查看循环的输出，你需要通过选择
    **视图** ▸ **调试区域** ▸ **显示调试区域**（⌘ -SHIFT -Y）来显示调试区域。如果该菜单显示为“隐藏调试区域”，那么调试区域已经显示，你不需要做任何操作。
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示调试区域时，它默认出现在你的 playground 底部，你可以拖动上方的分隔线来调整其高度。
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过 for-in 遍历范围和集合**'
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环告诉计算机在一系列数字或集合中的每个项上运行循环。我们将在[第 6 章](text00016.html#ch06)中更详细地讨论集合，但现在，可以把集合想象成一组物品——比如一袋弹珠或一箱奖杯。让我们先来看如何遍历一系列数字。
- en: '![image](Image00091.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00091.jpg)'
- en: '**SAY HELLO!**'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打招呼！**'
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环告诉计算机类似于“我想运行这段代码 4 次”的指令。为此，你写下 for 关键字，后面跟一个变量，用于计数循环运行的次数，再加上
    in 关键字，最后是你希望循环遍历的数字范围。让我们写一个简单的 for-in 循环，打印你的名字 4 次：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环以关键字 for 开始，后面跟一个变量 ➊，它将用作计数器来遍历数字范围。我们将计数器变量命名为 number，但你可以给这个变量任何你喜欢的名称。在计数器变量后面是
    in 关键字。这个关键字告诉计算机预期一个整数范围。在 in 后，我们提供 for-in 循环将使用的范围 1...4 ➋。这叫做从 1 到 4 的 *闭区间*，表示计数从
    1 开始，到 4 结束。三个点符号（...）是 *闭区间操作符*。
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 for-in 循环中添加一行代码，这样我们就能看到数字从 1 增加到 4。请在循环内打印你名字的那一行代码之后添加如下内容：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环内部，我们像使用任何其他变量一样使用 number。这个语句打印了一个包含 number 值的字符串。要将变量和常量嵌入到字符串中，你只需键入反斜杠，然后在括号中输入你想要打印的变量或常量，就像我们在
    ➊ 处所做的那样。这会打印出变量的值以及字符串的其余部分。挺酷的！
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出更美观，在 ➋ 处，我们还在句子的末尾添加了一个空的新行，方法是写入表示新行的特殊字符 \n。当该句子被打印时，计算机不会打印 \n，而是会添加一个新行，就像你按下
    RETURN 或 ENTER 键时一样。
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应该显示 [图 4-1](text00014.html#ch04fig1)。如果你没有看到打印的文本，请确保通过按 ⌘ -SHIFT -Y 打开调试区域。
- en: '![image](Image00092.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00092.jpg)'
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：for-in 循环的调试区域显示*'
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 for-in 循环将执行 4 次。第一次循环时，number 的值为 1；第二次循环时，number 的值为 2；依此类推，直到最后一次循环，number
    的值为 4。当 number 达到范围 1 到 4 的末尾时，循环结束。
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 for-in 循环中，当计数器 number 在循环中从 1 增加到 4 时，我们说计数器 *迭代* 了从 1 到 4 的范围。每次 for-in
    循环中的代码被执行时，我们称之为一次 *迭代*。
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改这些数字来设置不同的范围进行循环。试试看，看看会发生什么！
- en: '**SAY GOOD MORNING!**'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**早上好！**'
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环遍历数字范围外，for-in 循环对于遍历集合也非常有用。在这里，你将使用一个名为 *数组* 的集合。我们将在 [第 6 章](text00016.html#ch06)
    中进一步讲解数组，但现在你只需要知道的是，数组是存储在常量或变量中的一组项。当你使用 for-in 循环遍历数组时，你是在告诉计算机：“对于数组中的每个项，做点什么！”让我们写一些代码来问候孩子们。
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个名为 kidsInClass 的数组，里面包含了七个字符串。方括号告诉计算机我们正在创建一个数组，数组中的每个字符串由逗号分隔。（箭头表示长行在页面上换行——你不需要输入箭头。）
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对 kidsInClass 数组中的每个名字打印“Good Morning *kidsName* !”，在 ➋ 处我们写了 `for kidsName
    in kidsInClass`，后跟花括号和我们的代码。花括号中的代码将为数组中的每个项执行一次。这种类型的循环始终遵循 *constantName* in
    *collectionName* 的格式，其中 *constantName* 是你选择的用于在循环内调用集合中每一项的名称。
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，在 for-in 循环内部，我们编写代码打印每个名字的问候语。为此，我们像使用其他常量一样使用 kidsName。kidsName 只在这个循环的花括号内存在，并且它临时存储当前孩子的名字，随着
    for-in 循环遍历数组。这样，我们就可以在每次循环时打印每个名字，向每个人道早安！
- en: '![image](Image00094.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00094.jpg)'
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 while 循环测试条件**'
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道计算机需要执行某个操作的次数时，for-in 循环是很好的选择，但有时你可能希望计算机重复执行某个操作，直到满足特定条件。为了实现这一点，你应该使用
    while 循环。
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的 while 循环：while 和 repeat-while。两者都包含会重复执行的代码块，只要条件为真。while 循环和 repeat-while
    循环的区别在于，while 循环在运行代码块之前检查条件，而 repeat-while 循环在运行代码块之后检查条件。让我们看一些例子，看看它们是如何工作的！
- en: '**GUESS MY NUMBER**'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**猜我的数字**'
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环会不断执行某个操作，直到特定条件为真。这对于猜数字游戏非常有效，例如，当你想出一个数字并让朋友猜这个数字，直到他们猜对为止。我们可以编写一个程序来实现这个功能！你将选择一个
    1 到 20 之间的数字，计算机会尝试猜测它是什么。请在新的 playground 中编写以下代码：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个特殊的库，叫做 Foundation 框架，它提供了我们需要的函数来创建一个随机数。为了使用这个库，我们在 playground
    的顶部写入行 `import Foundation` ➊。（我们将在[第7章](text00017.html#ch07)中更详细地讨论函数。）
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个常量叫做 `numberIAmThinkingOf`，并将它设置为 1 到 20 之间的任意数字。然后，在 ➋ 处，我们创建一个变量叫做
    `currentGuess` 来代表计算机的猜测，并将其设置为 -1。将 `currentGuess` 变量设置为 -1 是一个好方法，表示计算机还没有猜测过。
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环从关键字 `while` 开始，位于 ➌ 处，接着是一个条件，位于 ➍ 处。在这个例子中，条件检查 `currentGuess` 是否不等于
    `numberIAmThinkingOf`。如果条件为真，表示计算机还没有正确猜出我们的秘密数字，那么 while 循环中的语句将被执行。
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 while 循环依赖于条件，因此非常重要的是，你需要在 while 循环内部提供某种方式来改变条件，否则它将无限运行，永远无法进入程序的下一个部分！与
    for-in 循环不同，while 循环没有自动增加或减少的计数器。控制它完全取决于你！
- en: '![image](Image00095.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00095.jpg)'
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➎ 处让计算机猜一个 1 到 20 之间的新数字，然后将这个新数字放入 currentGuess。你不必完全理解执行此操作的那一行代码；只需知道
    Int(arc4random_uniform(20)) 会生成一个 0 到 19 之间的随机整数，我们在那行代码的末尾加上 + 1，这样我们得到的是一个 1
    到 20 之间的数字。
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不小心进入了一个永远运行的循环，最好的做法是通过在 while 关键字前加上两个斜杠来注释掉它。这样会停止循环，方便你找出哪里出了问题。
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机最终猜中正确数字时，while 循环结束，并在控制台打印出一条提示信息。输出应该类似于[图 4-2](text00014.html#ch04fig2)。
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个程序输入到一个 playground 中时，你的循环运行了多少次？这个次数很可能与[图 4-2](text00014.html#ch04fig2)
    中的不同。这个猜数字程序是使用 while 循环可以做到的，而用 for-in 循环做不到的一个例子。我们无法知道需要多少次随机猜测，直到计算机猜中正确的数字，所以我们不能用
    for-in 循环来做这个。while 循环让计算机可以一直猜，直到猜中正确答案。
- en: '![image](Image00096.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00096.jpg)'
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：数字猜测程序的输出*'
- en: '**SHRINK AWAY**'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**收缩**'
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: repeat-while 循环与 while 循环非常相似，不同之处在于它的写法不同，而且结束循环的条件是在循环运行*之后*才会检查。我们将通过删除句子中的字母直到它消失来测试
    repeat-while 循环。
- en: 'Try out the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下代码：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要使用一种方法来删除字符串中的最后一个字符。我们需要使用在猜数字游戏中使用过的 Foundation 框架，所以在 playground
    的顶部输入 import Foundation。（我们将在[第 8 章](text00018.html#ch08) 中更详细地讨论方法。）
- en: '![image](Image00097.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00097.jpg)'
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的计算机看到 repeat-while 循环时，它会运行 repeat 关键字后面的代码块 ➊，然后检查 while 关键字后面的条件 ➌ 是否为真。在我们的例子中，我们首先创建一个名为
    shrinking 的变量字符串。在 repeat 块中，我们打印出字符串，然后切掉最后一个字符。你不需要记住或理解执行此操作的 dropLast() 方法；只需知道
    ➋ 处的代码会删除我们字符串中的最后一个字符。
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过去掉最后一个字符，并将这个较短的字符串保存在`shrinking`变量中，从而把我们的字符串缩短。这会更新`shrinking`变量的值为新的、更短的字符串。在这种情况下，我们希望不断去除字符，直到没有字符剩下。所以，我们的`while`循环的条件是：只要`shrinking`中的字符数大于0，就重复这个过程。要确定字符串中的字符数，你可以在字符串名后面输入`.characters.count`。查看[图
    4-3](text00014.html#ch04fig3)，看看这个神奇的缩短句子！
- en: '![image](Image00098.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00098.jpg)'
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：救命！我正在缩小！*'
- en: '**WHICH LOOP TO USE?**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用哪个循环？**'
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有多种方法可以在代码中创建循环。选择哪种方法取决于你，作为程序员，需要选择最适合你需求的那一种。请记住，通常没有单一的正确答案，因为`for-in`、`while`和`repeat-while`循环都可以完成相同的任务，具体取决于它们的写法。当你不知道循环需要运行多少次时，你可能会选择`while`或`repeat-while`循环，但几乎每个`for-in`循环都可以通过`while`循环来完成。通常最好选择你最了解的那种。
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你后来改变主意，认为其他类型的循环可能更适合某个特定情况，尝试使用新的技术也是完全可以的。你写的第一段代码不需要完美，实际上（即使是对于有经验的程序员）它几乎永远也不会完美！但是，编写代码的关键在于练习和解决问题：写一点代码，看看它是如何工作的，然后再回来改进它。
- en: '**NESTING AND SCOPE**'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套与作用域**'
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何编写循环和条件语句来做选择。你还可以将这些元素以几乎任何你想要的方式组合。例如，你可以将`if`语句放在`for-in`循环中，将`while`循环放在`if`块中，或者将`for-in`循环嵌套在另一个`for-in`循环中。当你将循环和条件语句结合起来时，有两个重要的概念你需要记住：嵌套和作用域。
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**嵌套代码块**'
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把一个代码块放在另一个代码块里时，这叫做*嵌套*。所以，如果你在`while`循环中写一个`if`语句，你就可以称之为*嵌套*的`if`语句。记住，当我们说*代码块*时，我们指的是位于大括号`{}`之间的代码。例如，输入以下代码，输出一个由星号和破折号组成的三角形图案：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[图 4-4](text00014.html#ch04fig4)。我们为Xcode添加了一些颜色，帮助你看到每个嵌套的代码块。
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要嵌套任意多的代码块。在这个例子中，我们将每个代码块分别称为 Nest A、Nest B、Nest C 等。如[图 4-4](text00014.html#ch04fig4)所示，我们的程序包含最外层的
    Nest A，它包含了 for count in 1...10 语句内的所有代码。Nest A 包含两个嵌套的代码块，Nest B 和 Nest D。每个嵌套的代码块也包含一个嵌套：Nest
    B 内部有 Nest C，Nest D 内部有 Nest E。
- en: '![image](Image00099.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00099.jpg)'
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：带有嵌套 for-in 循环的嵌套 if-else 语句*'
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入分析代码，看看发生了什么。在 ➊，有一个最外层的 for-in 循环，我们称之为 Nest A，它将运行 10 次，因为 count 从
    1 增加到 10。在这个 for-in 循环内部，在 ➋ 有一个嵌套的 if-else 语句，用来检查 count 是偶数还是奇数。这个 if 语句包含 Nest
    B。为了检查一个数字是否为偶数，我们使用模运算符（%），它告诉我们当一个整数被另一个整数除时的余数是多少。如果一个数字被 2 除余数为 0，那么它一定是偶数。所以，为了判断
    count 是否为偶数，我们检查 count % 2 == 0。
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 count 是偶数，我们打印一串星号（*）。我们用 count 来确定要打印多少颗星。我们通过创建一个空的 starString，然后在 ➌ 使用嵌套的
    for-in 循环 Nest C，每次 starCount 从 1 迭代到 count 时就添加一个星号。嵌套的 for-in 循环结束后，在 ➍ 我们打印
    starString，它现在包含 count 数量的星号。我们打印一个嵌套的 else 语句 ➎，它被称为 Nest D。当 count 是奇数时，我们打印一串破折号而不是星号，这是
    Nest E 中的指令。
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的作用域**'
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，变量有*作用域*，它指的是变量存在的范围以及可以使用变量的地方。当你在嵌套的代码块内部声明常量或变量时，该常量或变量在该嵌套块外部是不存在的。也就是说，它的作用域仅限于声明它的代码块以及该代码块中嵌套的任何代码。[图
    4-5](text00014.html#ch04fig5)展示了我们嵌套代码中变量的作用域。
- en: '![image](Image00100.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00100.jpg)'
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：变量或常量的作用域仅限于其声明所在的嵌套块以及该嵌套块中的任何代码。*'
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中声明了五个变量：count、starString、starCount、dashString和dashCount。最外层的嵌套，Nest A，只能看到count。它无法访问其嵌套代码块中的任何变量或常量，这意味着你不能使用在Nest
    B或Nest C中声明的变量或常量。变量starString在Nest B中声明，因此Nest B可以访问starString以及Nest A中创建的任何内容，包括count。Nest
    C可以访问starCount、starString和count。同样，在else分支中，Nest D可以访问count和dashString，而Nest E可以访问count、dashString和dashCount。如果你试图使用一个块无法访问的变量，因为它超出了作用域，你会得到一个错误。例如，你不能在最外层的嵌套Nest
    A中打印dashString。
- en: '![image](Image00101.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00101.jpg)'
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我们将编写代码来创建一个问候语。如果是早晨，我们希望问候语是“早上好”。否则，我们希望问候语是“下午好”。在你的playground中输入以下代码：
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在if-else语句后打印greeting时，会出现错误，如[图 4-6](text00014.html#ch04fig6)所示。变量greeting超出了if-else块的作用域，因此计算机不知道greeting是什么。
- en: '![image](Image00102.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00102.jpg)'
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：尝试在作用域外访问greeting会导致错误。*'
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你必须在if-else块外声明greeting。按以下方式重写greeting代码以输出问候语：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在if-else块之前，在 ➊ 处声明了greeting为一个空字符串。然后，根据isMorning是否为真，我们将greeting设置为“早上好”或“下午好”。最后，我们在
    ➋ 处打印greeting，位于if-else块之后，因为它与print语句处于同一作用域。
- en: '**WHAT YOU LEARNED**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用循环重复代码。你了解到，可以使用for-in循环或while循环来完成许多相同的目标。for-in循环非常适合遍历一组项目，并对每个项目执行相同的操作，而while循环则更适合在你不知道循环需要执行多少次时使用。
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，我们将介绍Swift中的一种新变量类型——可选项。可选项是可以有值也可以没有值的变量。当你需要创建一个变量，但还不知道它的值时，可选项非常有用。
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到了如何使用条件语句根据满足的条件执行不同的代码分支。*循环*是另一种控制程序顺序的方式。使用循环，你可以告诉计算机执行某段代码任意次数。这让你能够重复使用代码块，而不必每次都重新编写！
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有两种主要的循环类型：for-in 循环和 while 循环。for-in 循环告诉计算机运行一定次数的循环，当你一开始就知道希望代码重复多少次时，它非常有用。while
    循环则告诉计算机不断运行一个循环，直到满足某个条件，这对于你更关心基于程序中的事件或条件来重复代码时非常有用。让我们深入了解每种类型的循环，学习更多内容！
- en: '**OPEN THE DEBUG AREA**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打开调试区域**'
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写循环之前，先确保你的 playground 已经设置为显示调试区域。当你在 playground 中编写 for-in 循环时，右侧的结果侧边栏只会告诉你循环执行了多少次。要查看循环的输出，你需要通过选择
    **视图** ▸ **调试区域** ▸ **显示调试区域** (⌘ -SHIFT -Y) 来显示 playground 的调试区域。如果此菜单显示为“隐藏调试区域”，则说明调试区域已经显示，你无需做任何操作。
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示调试区域时，它默认出现在你的 playground 底部，你可以拖动它上方的分隔线来调整它的高度。
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过 for-in 循环遍历范围和集合**'
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环告诉计算机在一系列数字范围内或在一个集合中的每个项目上运行循环。我们将在[第 6 章](text00016.html#ch06)中进一步讨论集合，但现在，暂时把集合看作是一组项目——就像一袋弹珠或一箱奖杯。首先，我们来看如何在数字范围内进行循环。
- en: '![image](Image00091.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00091.jpg)'
- en: '**SAY HELLO!**'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打个招呼！**'
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环告诉计算机类似“我要运行这段代码 4 次”这样的指令。为此，你需要编写关键字 for，后面跟着一个变量用于计数循环执行多少次，然后是
    in 关键字，最后是你希望循环遍历的数字范围。让我们编写一个简单的 for-in 循环，打印你的名字 4 次：
- en: '[PRE24]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环以关键字 for 开始，后面跟着一个变量 ➊，它将作为计数器用于遍历数字范围。我们把我们的计数器变量命名为 number，但你可以给这个变量起任何你想要的名字。计数器变量之后是关键字
    in。这个关键字告诉计算机期望一个整数范围。在 in 之后，我们提供我们希望 for-in 循环使用的范围，即 1...4 ➋。这被称为从 1 到 4 的*闭区间*，它表示计数从
    1 开始，到 4 结束。三个点符号（...）是*闭区间运算符*。
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 for-in 循环中添加一行代码，这样我们就能看到 number 从 1 增加到 4。将以下代码添加到打印你名字的那一行之后：
- en: '[PRE25]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环中，我们像使用任何其他变量一样使用 number。这个语句打印包含 number 值的字符串。要将变量和常量嵌入到字符串中，你需要输入反斜杠，然后输入你想打印的变量或常量名称，就像我们在➊位置做的那样。这会将变量的值与其他字符串一起打印。很酷吧！
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出更美观，在➋位置我们还通过编写换行符号 \n 在句子的末尾添加了一个空行。当句子打印时，计算机不会打印 \n，而是添加一个新行，就像你在键盘上按RETURN或ENTER键时一样。
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应该看起来像[图4-1](text00014.html#ch04fig1)。如果你没有看到打印的文本，请确保调试区域已开启，可以通过按 ⌘ -SHIFT
    -Y 来打开。
- en: '![image](Image00092.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00092.jpg)'
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：for-in循环的调试区域显示*'
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: for-in循环将执行4次。第一次循环时，number的值为1；第二次循环时，值为2；依此类推，直到最后一次循环，值为4。当number达到范围1到4的末尾时，循环结束。
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环中，当计数器 number 在循环中进行迭代，从1增加到4时，我们称计数器*迭代*了从1到4的范围。每次for-in循环中的代码执行时，我们称之为一次*迭代*。
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改这些数字，以设置不同的范围来进行循环。试试看，看看会发生什么！
- en: '**SAY GOOD MORNING!**'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**说早安！**'
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环遍历数字范围，for-in循环还可用于遍历集合。在这里，你将使用一个名为*数组*的集合。我们将在[第6章](text00016.html#ch06)中深入讨论数组，但目前你只需要知道，数组是存储在常量或变量中的一组项目。当你使用for-in循环遍历数组时，你是在告诉计算机：“对于数组中的每个项目，做一些事情！”让我们编写一个代码来向孩子们打招呼。
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，我们创建了一个名为 kidsInClass 的数组，其中包含七个字符串。方括号告诉计算机我们正在创建一个数组，数组中的每个字符串之间用逗号分隔。（箭头表示长行被换行显示——你不需要输入箭头。）
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印“Good Morning *kidsName*！”对每个在 kidsInClass 数组中的名字，在➋位置我们写了 `for kidsName
    in kidsInClass`，然后是大括号和我们的代码。大括号内的代码会在数组中的每个项目上运行一次。这种类型的循环总是遵循格式 `for *constantName*
    in *collectionName*`，其中 *constantName* 是你选择的名字，用来代表循环中每个集合项。
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，在for-in循环内部，我们编写代码为每个名字打印一个问候语。为此，我们像使用其他常量一样使用kidsName。kidsName仅在此循环的花括号内存在，并暂时存储当前孩子的名字，随着for-in循环遍历数组。这样，我们可以在每次循环时打印每个名字，祝大家早上好！
- en: '![image](Image00094.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00094.jpg)'
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用while循环测试条件**'
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道计算机需要执行多少次某个操作时，for-in循环非常合适，但有时你可能希望计算机重复执行某个操作，直到满足特定条件。这时，你应该使用while循环。
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: while循环有两种类型：while和repeat-while。两者都包含一些代码块，这些代码块会在条件为真时重复执行。while循环和repeat-while循环之间的区别在于，while循环在运行代码块*之前*检查条件，而repeat-while循环在运行代码块*之后*检查条件。让我们来看一些例子，看看每种如何工作！
- en: '**GUESS MY NUMBER**'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**猜我的数字**'
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: while循环会一直执行某个操作，直到某个条件为真。这对于猜数字游戏非常有效，就像你想到一个数字，并让朋友一直猜，直到他们猜对为止。我们可以编写一个程序来实现这一点！你将选择一个1到20之间的数字，计算机会尝试猜出它是什么。请在新的playground中编写以下代码：
- en: '[PRE27]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个名为Foundation框架的特殊库，它包含我们需要创建随机数的函数。为了使用这个库，我们在playground的顶部写入行`import
    Foundation` ➊。（我们将在[第7章](text00017.html#ch07)中更详细地讨论函数。）
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为numberIAmThinkingOf的常量，并将其设置为1到20之间的任意数字。然后，在➋处，我们创建一个名为currentGuess的变量来表示计算机的猜测，并将其设置为-1。将currentGuess变量设置为-1是一个很好的方式来表示计算机尚未进行猜测。
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: while循环从关键词while开始，在➌处跟随一个条件，在➍处进行判断。在这种情况下，条件检查currentGuess是否不等于numberIAmThinkingOf。如果条件为真，那意味着计算机仍然没有正确猜出我们的秘密数字，while循环中的语句会执行。
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于while循环依赖于条件，因此非常重要的是你要在while循环*内部*包含某种方式来改变条件，否则它会一直运行下去，永远无法进入程序的下一个部分！与for-in循环不同，while循环没有一个自动增加或减少的计数器。控制它的责任在于你！
- en: '![image](Image00095.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00095.jpg)'
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➎ 让计算机猜一个新的 1 到 20 之间的数字，然后将这个新数字放入 currentGuess 中来实现这一点。不要太担心完全理解这行代码的作用；只要知道
    `Int(arc4random_uniform(20))` 会生成一个 0 到 19 之间的随机整数，而我们在这一行代码的末尾加上了 `+ 1`，这样就能得到一个
    1 到 20 之间的数字。
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不小心进入了一个永远运行的循环，最好的办法是通过在 `while` 关键字前面加上两个斜杠来注释掉它。这样就会停止循环，方便你查明出错的原因。
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机最终猜中正确的数字时，while 循环结束，并且一个友好的消息会打印到控制台。输出应该像[图 4-2](text00014.html#ch04fig2)一样。
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个程序输入到 Playground 时，你的循环运行了多少次？它可能和[图 4-2](text00014.html#ch04fig2)中的次数不同。这个数字猜测程序是
    while 循环能做到的，而 for-in 循环做不到的一个例子。我们无法知道计算机需要多少次随机猜测才能猜中正确的数字，因此我们无法使用 for-in 循环来实现这一点。while
    循环允许计算机根据需要猜测任意次数，直到得到正确答案。
- en: '![image](Image00096.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00096.jpg)'
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：数字猜测程序的输出*'
- en: '**SHRINK AWAY**'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**缩小消失**'
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: repeat-while 循环与 while 循环非常相似，只是它的写法不同，且结束循环的条件是在循环运行*之后*检查的。我们将通过删除句子中的字母，直到它消失，来测试
    repeat-while 循环。
- en: 'Try out the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下代码：
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要使用一种方法来去掉字符串中的最后一个字符。我们需要使用在猜数字游戏中使用的相同的 Foundation 框架，因此在 Playground
    的顶部输入 `import Foundation`。（我们将在[第8章](text00018.html#ch08)中更详细地讨论方法。）
- en: '![image](Image00097.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00097.jpg)'
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的计算机看到 repeat-while 循环时，它会运行 repeat 关键字后面的代码块 ➊，然后检查 while 关键字后面的条件 ➌ 是否为真。在我们的例子中，我们首先创建一个名为
    shrinking 的字符串变量。在 repeat 块中，我们打印出我们的字符串，然后去掉最后一个字符。你不需要记住或理解执行这一操作的 `dropLast()`
    方法；只需知道 ➋ 这行代码会移除我们字符串中的最后一个字符。
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过去掉字符串的最后一个字符来制作一个更短的字符串，然后将这个更短的字符串保存在 shrinking 变量中。这会将 shrinking 的值更新为新的、更短的字符串。在这种情况下，我们希望不断去除字符，直到没有字符剩下。所以我们的
    while 循环的条件是：只要 shrinking 中的字符数大于 0，就重复这个过程。要确定字符串中的字符数，可以在字符串名称后输入 .characters.count。查看[图
    4-3](text00014.html#ch04fig3)，看看那个不可思议的缩小句子！
- en: '![image](Image00098.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00098.jpg)'
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：救命！我在缩小！*'
- en: '**WHICH LOOP TO USE?**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用哪个循环？**'
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在代码中创建循环有几种方法。由你来决定，作为程序员，你需要选择适合你的需求的那种方法。请记住，通常没有单一的正确答案，因为 for-in、while
    和 repeat-while 循环可以做相同的事情，具体取决于它们的写法。当你不知道循环需要执行多少次时，你可能会发现需要使用 while 或 repeat-while
    循环，但你几乎可以通过 while 循环完成所有的 for-in 循环。通常，最好选择你最理解的那种。
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为不同类型的循环在特定情况下会更有效，完全可以在以后改变主意并尝试新的技巧。你写的第一段代码不必完美，事实上（即使是对于有经验的程序员）几乎从来不会完美！但是编码的关键是练习和解决问题：写一点代码，看看它如何工作，然后再回去优化它。
- en: '**NESTING AND SCOPE**'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套和作用域**'
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何编写循环和条件语句来做出选择。你还可以将这些元素以几乎任何你想要的方式结合起来。例如，你可以将 if 语句放在 for-in 循环内，将
    while 循环放在 if 块内，或者将 for-in 循环放在另一个 for-in 循环内。当你将循环和条件语句结合时，有两个重要的概念需要记住：嵌套和作用域。
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**嵌套代码块**'
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个代码块放在另一个代码块内时，这叫做*嵌套*。因此，如果你在 while 循环中写一个 if 语句，你可以称之为*嵌套*的 if 语句。记住，当我们说*代码块*时，是指在大括号
    {} 之间的代码。例如，输入以下代码，它将输出一个星号和破折号组成的三角形模式：
- en: '[PRE29]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 4-4](text00014.html#ch04fig4)。我们在 Xcode 中添加了一些颜色，帮助你看到每个嵌套的代码块。
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要嵌套任意多的代码块。在这个示例中，我们将每个代码块称为 Nest A、Nest B、Nest C 等等。正如你在 [图 4-4](text00014.html#ch04fig4)
    中看到的，我们的程序包含一个最外层的 Nest A，它包括了所有在 for count in 1...10 语句内部的代码。Nest A 包含两个嵌套的代码块，Nest
    B 和 Nest D。而每个嵌套的代码块也包含一个嵌套：Nest B 中有 Nest C，Nest D 中有 Nest E。
- en: '![image](Image00099.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00099.jpg)'
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：一个包含嵌套 for-in 循环的嵌套 if-else 语句*'
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入代码，看看发生了什么。在 ➊ 处，有一个最外层的 for-in 循环，我们称之为 Nest A，它将在 count 从 1 增加到 10
    时运行 10 次。在这个 for-in 循环内部，在 ➋ 处有一个嵌套的 if-else 语句，用于检查 count 是偶数还是奇数。这个 if 语句包含了
    Nest B。要检查一个数字是否为偶数，我们使用取模运算符（%），它告诉我们一个整数除以另一个整数后的余数是什么。如果一个数字除以 2 后余数为 0，那么它一定是偶数。因此，为了确定
    count 是否为偶数，我们检查 count % 2 == 0。
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 count 是偶数，我们打印一个星号字符串（*）。我们使用 count 来决定打印多少个星号。我们通过创建一个空的 starString，然后使用一个嵌套的
    for-in 循环（Nest C）在 ➌ 处每次 starCount 从 1 迭代到 count 时，添加一个星号。嵌套的 for-in 循环结束后，在 ➍
    处我们打印我们的 starString，它现在包含了 count 个星号。接着，我们打印一个嵌套的 else 语句 ➎，我们称之为 Nest D。当 count
    是奇数时，我们根据 Nest E 的指示打印出一串破折号，而不是星号。
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的作用域**'
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，变量有 *作用域*，指的是变量存在的范围以及它可以被使用的地方。当你在一个嵌套的代码块中声明常量或变量时，该常量或变量在该嵌套代码块之外是不存在的。这意味着它的作用域仅限于它所在的代码块以及该代码块中的任何嵌套代码。
    [图 4-5](text00014.html#ch04fig5) 展示了我们嵌套代码中变量的作用域。
- en: '![image](Image00100.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00100.jpg)'
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：变量或常量的作用域仅限于其声明所在的嵌套及嵌套中包含的代码。*'
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序中声明了五个变量：`count`、`starString`、`starCount`、`dashString` 和 `dashCount`。最外层的嵌套，A
    层，只能访问 `count`。它无法访问其嵌套代码块中的任何变量或常量，这意味着你不能使用在 B 层或 C 层声明的变量或常量。`starString` 变量在
    B 层声明，因此 B 层可以访问 `starString` 以及 A 层中创建的任何内容，包括 `count`。C 层可以访问 `starCount`、`starString`
    和 `count`。类似地，在 else 语句中，D 层可以访问 `count` 和 `dashString`，E 层可以访问 `count`、`dashString`
    和 `dashCount`。如果你尝试在代码块无法访问的情况下使用一个变量（因为它超出了作用域），你将会遇到错误。例如，你不能在最外层的嵌套 A 层中打印
    `dashString`。
- en: '![image](Image00101.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00101.jpg)'
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。我们将编写一段代码来创建一个问候语。如果是早晨，我们希望问候语是“早上好”。否则，我们希望问候语是“下午好”。请输入以下代码到你的操作区：
- en: '[PRE30]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 if-else 语句后打印问候语时，会发生错误，如[图4-6](text00014.html#ch04fig6)所示。变量问候语在 if-else
    语句块的作用域之外，因此计算机无法识别问候语是什么。
- en: '![image](Image00102.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00102.jpg)'
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：尝试在作用域外访问问候语会导致错误。*'
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你必须在 if-else 语句块外声明问候语。请按以下方式重写问候语代码，以便输出问候语：
- en: '[PRE31]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们在 if-else 语句块之前声明了问候语为一个空字符串，在➊位置。然后，根据 `isMorning` 是否为真，我们将问候语设置为“早上好”或“下午好”。最后，我们在➋位置打印问候语，放在
    if-else 语句块之后，因为它在与打印语句相同的作用域内声明。
- en: '**WHAT YOU LEARNED**'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用循环来重复代码。你了解了可以使用 `for-in` 循环或 `while` 循环来完成许多相同的目标。`for-in` 循环非常适合遍历一组项目并对每个项目执行相同的操作，而
    `while` 循环更适合用于你不知道循环需要运行多少次的情况。
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，我们将介绍 Swift 中一种新的变量类型——可选类型（optionals）。可选类型是可以有值或者没有值的变量。当你需要创建一个变量，但还不知道它的值时，可选类型非常有用。
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有两种主要的循环类型：for-in 循环和 while 循环。for-in 循环告诉计算机执行一个固定次数的循环，当你一开始就知道需要重复多少次代码时，它非常有用。而
    while 循环告诉计算机持续执行循环，直到满足某个条件，当你更关心根据程序中的事件或条件来重复代码时，它非常合适。让我们深入了解每种循环类型，学习更多细节！
- en: '**OPEN THE DEBUG AREA**'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打开调试区域**'
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写循环之前，先确保你的 Playground 已经设置好显示调试区域。当你在 Playground 中编写 for-in 循环时，右侧的结果侧边栏只会告诉你循环运行了多少次。要查看循环的输出，你需要通过选择
    **视图** ▸ **调试区域** ▸ **显示调试区域** (⌘ -SHIFT -Y) 来显示 Playground 的调试区域。如果菜单上显示的是“隐藏调试区域”，说明调试区域已经显示，你无需做任何操作。
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示调试区域时，默认情况下它会出现在 Playground 的底部，你可以拖动其上方的分隔线来调整它的高度。
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过 for-in 循环遍历范围和集合**'
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环告诉计算机在一个数字范围内或在集合中的每一项上运行循环。我们将在[第6章](text00016.html#ch06)中讨论更多关于集合的内容，但现在可以将集合看作是一组物品——比如一袋弹珠或一箱奖杯。让我们先看看如何遍历一个数字范围。
- en: '![image](Image00091.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00091.jpg)'
- en: '**SAY HELLO!**'
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打个招呼！**'
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环告诉计算机类似“我想让这段代码执行 4 次”的指令。为此，你需要编写 for 关键字，后跟一个变量来计数循环运行的次数，然后是
    in 关键字，最后是你希望循环遍历的数字范围。让我们写一个简单的 for-in 循环，打印你的名字 4 次：
- en: '[PRE32]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环以关键字 for 开始，后跟一个变量 ➊，这个变量将作为计数器，用来遍历数字范围。我们将计数器变量命名为 number，但你可以给这个变量起任何你喜欢的名字。计数器变量后面跟着关键字
    in 。这个关键字告诉计算机接下来将会是一个整数范围。在 in 后面，我们提供了我们希望 for-in 循环使用的范围 1...4 ➋ 。这被称为从 1 到
    4 的 *闭区间*，表示计数从 1 开始，到 4 结束。三点符号（...）是 *闭区间运算符*。
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 for-in 循环中添加一行代码，这样我们就可以看到数字从 1 到 4 的递增过程。在打印名字的那行代码后，添加以下这一行：
- en: '[PRE33]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环中，我们像使用任何其他变量一样使用number。这个语句打印一个包含number值的字符串。要将变量和常量嵌入字符串中，你输入反斜杠，然后在括号中输入你想打印的变量或常量，就像我们在➊处所做的那样。这样可以将变量的值和其他字符串一起打印出来。挺酷的吧！
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出更加美观，在➋处，我们还通过编写特殊字符`\n`在句子的末尾添加了一个空的新行。当该句子被打印时，计算机不会打印`\n`，而是添加一个新行，就像你按下RETURN或ENTER键时一样。
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应显示类似于[图 4-1](text00014.html#ch04fig1)的内容。如果你没有看到打印的文本，请确保通过按⌘-SHIFT-Y打开调试区域。
- en: '![image](Image00092.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00092.jpg)'
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：for-in循环的调试区域显示*'
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: for-in循环将执行4次。第一次循环时，number等于1；第二次循环时，number等于2；以此类推，直到最后一次循环，number等于4。当number到达范围1到4的末尾时，循环结束。
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环中，当计数器number循环遍历从1到4的范围时，我们称计数器*迭代*了从1到4的范围。每次for-in循环内的代码执行时，我们称之为一次*迭代*。
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改这些数字来设置不同的循环范围。试试看，看看会发生什么！
- en: '**SAY GOOD MORNING!**'
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**说早安！**'
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环遍历数字范围，for-in循环还用于遍历集合。在这里，你将使用一个叫做*数组*的集合。我们将在[第6章](text00016.html#ch06)中详细讨论数组，但你现在只需要知道数组是一个存储在常量或变量中的项目列表。当你使用for-in循环遍历数组时，你是在告诉计算机“对于数组中的每一项，做点什么！”让我们写一些代码来问候孩子们。
- en: '[PRE34]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们创建了一个名为kidsInClass的数组，其中包含七个字符串。方括号告诉计算机我们正在创建一个数组，每个字符串之间用逗号分隔。（箭头表示一行很长，已在页面上换行——你不需要输入箭头。）
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印“Good Morning *kidsName*！”对于kidsInClass数组中的每个名字，在➋处我们写了`for kidsName in
    kidsInClass`，然后是大括号和我们的代码。大括号内的代码将对数组中的每一项执行一次。这种类型的循环总是遵循格式`for *constantName*
    in *collectionName*`，其中*constantName*是你选择的名称，用来表示循环中集合的每一项。
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，在 for-in 循环内部，我们写入代码为每个名字打印问候语。为此，我们像使用其他常量一样使用 kidsName。kidsName 只在这个循环的括号内存在，并暂时存储当前孩子的名字，随着
    for-in 循环遍历数组。这样，我们就可以在每个循环周期中打印每个名字，向大家说早安！
- en: '![image](Image00094.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00094.jpg)'
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 while 循环测试条件**'
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环非常适合当你知道计算机需要执行多少次操作时，但有时你可能希望计算机不断执行某个操作，直到满足特定条件。为此，你应该使用 while 循环。
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环有两种类型：while 和 repeat-while。两者都包含会反复执行的代码块，只要条件为真。while 循环和 repeat-while
    循环的区别在于，while 循环会在运行代码块之前检查条件，而 repeat-while 循环会在运行代码块之后检查条件。让我们通过一些示例来看每种方式如何工作！
- en: '**GUESS MY NUMBER**'
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**猜我的数字**'
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环会不断执行某个操作，直到某个条件为真。这对于猜数字游戏非常有效，比如当你想到一个数字，并让朋友猜测直到他们猜对为止。我们可以编写一个程序来实现这个功能！你将选择一个
    1 到 20 之间的数字，计算机会尝试猜测它是什么。请在新的 playground 中写入以下代码：
- en: '[PRE35]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个名为 Foundation 框架的特殊库，它包含了我们需要创建随机数的函数。要使用这个库，我们在 playground 顶部写入
    import Foundation ➊ 这一行。（我们将在[第 7 章](text00017.html#ch07) 中更详细地讨论函数。）
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 numberIAmThinkingOf 的常量，并将其设置为 1 到 20 之间的任意数字。然后，在 ➋ 处，我们创建一个名为
    currentGuess 的变量来表示计算机的猜测，并将其设置为 -1。将 currentGuess 变量设置为 -1 是一个很好的方法，表示计算机还没有进行猜测。
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环以关键字 while 开始，在 ➌ 处，后面跟着一个条件，在 ➍ 处。在这个例子中，条件检查 currentGuess 是否不等于 numberIAmThinkingOf。如果条件为真，意味着计算机还没有正确猜出我们的秘密数字，while
    循环内部的语句就会执行。
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 while 循环依赖于条件，所以非常重要的是你需要在 while 循环内部提供某种方式来改变条件，否则它会一直运行，永远无法进入程序的下一个部分！与
    for-in 循环不同，while 循环没有一个自动增加或减少的计数器。你需要自己控制它！
- en: '![image](Image00095.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00095.jpg)'
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➎ 处通过让计算机猜一个介于 1 和 20 之间的新数字，然后将这个新数字放入 currentGuess 来实现。你不需要完全理解执行这一操作的代码行；只需知道
    Int(arc4random_uniform(20)) 会生成一个介于 0 和 19 之间的随机整数，最后我们在这一行代码末尾加上 + 1，这样就能得到一个介于
    1 和 20 之间的数字。
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不小心陷入了一个永远运行的循环，最好的做法是通过在 while 关键字前加上两个斜杠来将其注释掉。这样就能停止循环，方便你查找出错的地方。
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机最终猜对正确的数字时，while 循环结束，控制台将打印出一条提示信息。输出应该像 [图 4-2](text00014.html#ch04fig2)
    中的那样。
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个程序输入到 Playground 中时，你的循环运行了多少次？这个次数可能与 [图 4-2](text00014.html#ch04fig2)
    中的次数不同。这个数字猜测程序就是你可以用 while 循环做的，而用 for-in 循环做不到的一个例子。我们无法预知计算机需要多少次随机猜测才能得到正确的数字，所以无法使用
    for-in 循环来做这件事。while 循环让计算机可以不断猜测，直到猜到正确的答案。
- en: '![image](Image00096.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00096.jpg)'
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：数字猜测程序的输出*'
- en: '**SHRINK AWAY**'
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**收缩消失**'
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: repeat-while 循环与 while 循环非常相似，不同之处在于它的写法不同，并且结束循环的条件是在循环运行*后*检查的。我们将通过删除句子中的字母直到它消失来测试
    repeat-while 循环。
- en: 'Try out the following code:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下代码：
- en: '[PRE36]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要使用一种方法来删除字符串中的最后一个字符。我们需要在猜数字游戏中使用的同一个 Foundation 框架，所以在 Playground
    的顶部输入 import Foundation。（我们将在 [第 8 章](text00018.html#ch08) 中更详细地讨论方法。）
- en: '![image](Image00097.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00097.jpg)'
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机看到 repeat-while 循环时，它会先执行 repeat 关键字 ➊ 后面的代码块，然后检查 while 关键字 ➌ 后面的条件是否为真。在我们的示例中，我们首先创建一个名为
    shrinking 的字符串变量。在 repeat 块中，我们打印这个字符串，然后删除最后一个字符。你不需要记住或理解执行这一操作的 dropLast()
    方法；只需知道在 ➋ 处的代码会删除字符串的最后一个字符。
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过删除字符串的最后一个字符，来从不断缩小的字符串中制作出更短的字符串，然后将这个更短的字符串保存在 shrinking 变量中。这会更新 shrinking
    的值为新的、更短的字符串。在这种情况下，我们希望不断删除字符，直到没有字符剩下。所以，我们的 while 循环的条件是，只要 shrinking 中的字符数量大于
    0，就重复这个过程。要确定字符串中的字符数量，你可以在字符串名称后输入 .characters.count。看看[图 4-3](text00014.html#ch04fig3)，看看这个不可思议的缩小句子！
- en: '![image](Image00098.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00098.jpg)'
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：救命！我在变小！*'
- en: '**WHICH LOOP TO USE?**'
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择哪种循环？**'
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有多种方式可以在代码中创建循环。作为程序员，你可以选择最适合你需求的方式。请记住，通常没有单一的正确答案，因为根据写法的不同，for-in、while
    和 repeat-while 循环都可以完成相同的任务。当你不知道循环需要执行多少次时，可能需要使用 while 或 repeat-while 循环，但几乎可以通过
    while 循环实现任何 for-in 循环。通常，选择你最理解的循环方式是最好的。
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为另一种循环方式更适合特定情况，完全可以稍后改变主意并尝试新的技术。你编写的第一段代码不必完美，事实上（即使是经验丰富的程序员）几乎永远不会完美！但是编程的重点是练习和解决问题：写一点代码，看看它如何运行，然后再回来改进它。
- en: '**NESTING AND SCOPE**'
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套和作用域**'
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何编写循环和条件语句来做选择了。你也可以几乎以任何方式将这些元素结合起来。例如，你可以将一个 if 语句放在一个 for-in 循环内，或者将一个
    while 循环放在一个 if 语句块内，或者将一个 for-in 循环放在另一个 for-in 循环内。当你将循环和条件语句结合时，有两个重要的概念需要牢记：嵌套和作用域。
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码块的嵌套**'
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把一个代码块放入另一个代码块中时，这叫做*嵌套*。所以，如果你在 while 循环中写了一个 if 语句，你可以称其为*嵌套的* if 语句。记住，当我们说*代码块*时，我们指的是大括号{}之间的代码。例如，输入以下代码，它会输出一个星号和破折号组成的三角形图案：
- en: '[PRE37]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 4-4](text00014.html#ch04fig4)。我们在 Xcode 中为你添加了一些颜色，帮助你看到每个嵌套的代码块。
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要嵌套任意多的代码块。在这个例子中，我们将每个代码块称为 Nest A、Nest B、Nest C 等等。如[图 4-4](text00014.html#ch04fig4)所示，我们的程序包含一个最外层的
    Nest A，它包含了 for count in 1...10 语句中的所有代码。Nest A 包含两个嵌套代码块，Nest B 和 Nest D。而这些嵌套的代码块中，每个也包含一个嵌套：Nest
    B 内有 Nest C，Nest D 内有 Nest E。
- en: '![image](Image00099.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00099.jpg)'
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：包含嵌套 for-in 循环的嵌套 if-else 语句*'
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入代码，看看发生了什么。在 ➊ 处，有一个最外层的 for-in 循环，我们称之为 Nest A，它将随着 count 从 1 增加到 10
    执行 10 次。在这个 for-in 循环内，在 ➋ 处有一个嵌套的 if-else 语句，它将检查 count 是偶数还是奇数。这个 if 语句包含 Nest
    B。为了检查一个数字是否为偶数，我们使用取余运算符（%），它会告诉我们当一个整数被另一个整数除时的余数。如果一个数字除以 2 后余数为 0，那么它一定是偶数。因此，为了判断
    count 是否为偶数，我们检查 count % 2 == 0。
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 count 是偶数，我们打印出一串星号（*）。我们使用 count 来决定打印多少颗星号。我们通过创建一个空的 starString，然后使用嵌套的
    for-in 循环 Nest C（在 ➌ 处）来在 starCount 从 1 遍历到 count 时每次添加一个星号。在嵌套的 for-in 循环完成后，在
    ➍ 处我们打印出我们的 starString，它现在包含了 count 个星号。接着我们打印出一个嵌套的 else 语句 ➎，我们称之为 Nest D。当
    count 为奇数时，我们打印出一串破折号，而不是星号，这一部分是在 Nest E 中进行的。
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量作用域**'
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，变量具有*作用域*，它指的是变量存在的范围以及它可以使用的地方。当你在一个嵌套代码块内声明常量或变量时，该常量或变量在嵌套代码块外是不存在的。这意味着它的作用域仅限于声明它的代码块以及该代码块中的任何嵌套代码。[图
    4-5](text00014.html#ch04fig5) 显示了我们嵌套代码中的变量作用域。
- en: '![image](Image00100.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00100.jpg)'
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：变量或常量的作用域仅限于其声明所在的嵌套以及该嵌套中的任何代码。*'
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序中声明了五个变量：count、starString、starCount、dashString 和 dashCount。最外层的嵌套块 A 只能访问
    count。它无法访问其嵌套代码块中的任何变量或常量，这意味着你不能使用在嵌套块 B 或 C 中声明的变量或常量。变量 starString 在嵌套块 B
    中声明。因此，嵌套块 B 可以访问 starString 以及在嵌套块 A 中创建的任何内容，包括 count。嵌套块 C 可以访问 starCount、starString
    和 count。类似地，在 else 条件中，嵌套块 D 可以访问 count 和 dashString，嵌套块 E 可以访问 count、dashString
    和 dashCount。如果你尝试使用一个代码块无法访问的变量，因为它超出了其作用域，就会出现错误。例如，你不能在最外层的嵌套块 A 中打印 dashString。
- en: '![image](Image00101.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00101.jpg)'
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。我们将编写代码来创建一个问候语。如果是早晨，我们希望问候语是“Good Morning”。否则，我们希望问候语是“Good Afternoon”。将以下代码输入到你的
    playground 中：
- en: '[PRE38]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在此 if-else 语句后打印 greeting 时，会出现错误，如[图 4-6](text00014.html#ch04fig6)所示。变量 greeting
    超出了 if-else 块的作用域，因此计算机无法识别 greeting 是什么。
- en: '![image](Image00102.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00102.jpg)'
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：尝试在作用域外访问 greeting 会导致错误。*'
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你必须在 if-else 块外声明 greeting。将 greeting 代码重写如下，以输出 greeting：
- en: '[PRE39]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在 if-else 块之前的 ➊ 处声明了 greeting 为一个空字符串。然后，根据 isMorning 是否为 true 或 false，我们将
    greeting 设置为 “Good Morning” 或 “Good Afternoon”。最后，我们在 ➋ 处打印 greeting，因为它在与打印语句相同的作用域内声明。
- en: '**WHAT YOU LEARNED**'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用循环来重复代码。你了解到可以使用 for-in 循环或 while 循环来完成许多相同的任务。for-in 循环非常适合循环遍历一组项目，并对每个项目执行相同的操作，而
    while 循环则更适合在你不知道循环需要运行多少次的情况下使用。
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，我们将介绍 Swift 中的一种新类型变量——可选类型（optionals）。可选类型是可以有值或没有值的变量。当你需要创建一个变量，但尚不知道其值时，可选类型非常有用。
- en: '**OPEN THE DEBUG AREA**'
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打开调试区域**'
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写循环之前，确保你的 playground 已经设置好显示调试区域。当你在 playground 中编写 for-in 循环时，右侧的结果侧边栏只会告诉你循环运行了多少次。要查看循环的输出，你需要通过选择
    **查看** ▸ **调试区域** ▸ **显示调试区域**（⌘-SHIFT-Y）来显示调试区域。如果该菜单显示“隐藏调试区域”，那么调试区域已经显示了，你不需要做任何事情。
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当你显示调试区域时，它默认出现在你的 playground 底部，你可以拖动它顶部的分隔线来调整其高度，使其更高或更低。
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 FOR-IN 遍历范围和集合**'
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环告诉计算机在一系列数字或集合中的每个项目上运行循环。我们将在[第 6 章](text00016.html#ch06)中详细讨论集合，但现在可以将集合视为一组物品——比如一袋弹珠或一个奖杯盒。让我们先看看如何遍历数字范围。
- en: '![image](Image00091.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00091.jpg)'
- en: '**SAY HELLO!**'
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打招呼！**'
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环告诉计算机类似于“我要运行这段代码 4 次”。为此，你写下关键字 for，后跟一个变量来计算循环运行的次数，然后是 in
    关键字，最后是你希望循环遍历的数字范围。让我们写一个简单的 for-in 循环，打印你的名字 4 次：
- en: '[PRE40]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环以关键字 for 开始，后跟一个变量 ➊，这个变量将用作计数器，用于遍历数字范围。我们将计数器变量命名为 number，但你可以给这个变量任何你想要的名字。在计数器变量之后是关键字
    in。这个关键字告诉计算机期待一个整数范围。在 in 后，我们提供了 for-in 循环要使用的范围 1...4 ➋。这叫做从 1 到 4 的*闭区间*，表示计数从
    1 开始，到 4 结束。三个点符号（...）是*闭区间运算符*。
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 for-in 循环中添加一行代码，以便查看 number 从 1 到 4 是如何增加的。请在打印你的名字的那行代码后面添加以下代码：
- en: '[PRE41]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环中，我们像使用任何其他变量一样使用 number。这个语句打印包含 number 值的字符串。要将变量和常量嵌入字符串中，你需要键入反斜杠，然后在括号中输入你想要打印的变量或常量，就像我们在
    ➊ 中做的那样。这将打印变量的值与其他字符串一起。非常酷吧！
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让输出更美观，在 ➋ 处我们还通过写特殊字符来添加了一个空的新行 \n。打印该句子时，计算机不会打印 \n，而是像按下 RETURN 或 ENTER
    键时一样添加一个新行。
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕应该像[图 4-1](text00014.html#ch04fig1)一样。如果你没有看到打印的文本，请确保通过按 ⌘ -SHIFT -Y 打开调试区域。
- en: '![image](Image00092.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00092.jpg)'
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：for-in 循环的调试区域显示*'
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环将运行 4 次。第一次运行时，number 等于 1；第二次运行时，它等于 2；以此类推，直到最后一次循环，它等于 4。当 number
    达到范围 1 到 4 的末尾时，循环结束。
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环中，当计数器 number 遍历循环，数字从 1 增加到 4 时，我们说计数器 *迭代* 了从 1 到 4 的范围。每次执行 for-in
    循环中的代码时，我们称之为一次 *迭代*。
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改这些数字来设置不同的循环范围。试试看，看看会发生什么！
- en: '**SAY GOOD MORNING!**'
  id: totrans-460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**说早安！**'
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遍历数字范围，for-in 循环在遍历集合时也很有用。在这里，你将使用一个名为 *数组* 的集合。我们将在[第 6 章](text00016.html#ch06)中详细讨论数组，但目前你只需要知道的是，数组是存储在常量或变量中的项目列表。当你使用
    for-in 循环遍历数组时，你是在告诉计算机“对于数组中的每个项目，做某事！”让我们写一段代码来向孩子们打招呼。
- en: '[PRE42]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个名为 kidsInClass 的数组，它包含七个字符串。方括号告诉计算机我们正在创建一个数组，数组中的每个字符串由逗号分隔。（箭头表示一行很长已经换行了——你无需输入箭头。）
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 kidsInClass 数组中的每个名字前打印“Good Morning *kidsName* !”，在 ➋ 处我们写 for kidsName
    in kidsInClass ，然后是花括号和我们的代码。花括号中的代码会为数组中的每个元素执行一次。这类循环总是遵循格式 for *constantName*
    in *collectionName*，其中 *constantName* 是你选择的名称，用来表示在循环中从集合中获取的每个元素。
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，在 for-in 循环内部，我们写下代码，为每个名字打印问候语。为此，我们像使用其他常量一样使用 kidsName。kidsName 仅在这个循环的花括号内存在，它暂时存储当前孩子的名字，当
    for-in 循环遍历数组时。这样，我们就可以在循环的每个周期中打印每个名字，向每个人说早安！
- en: '![image](Image00094.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00094.jpg)'
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 while 循环测试条件**'
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道计算机需要做某件事情多少次时，for-in 循环非常有效，但有时你可能希望计算机反复做某件事，直到满足特定条件。为此，你应该使用 while 循环。
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: while循环有两种类型：while和repeat-while。它们都包含在条件为真时会反复执行的代码块。while循环和repeat-while循环的区别在于，while循环在执行代码块之前检查条件，*而*repeat-while循环在执行代码块之后检查条件。让我们通过一些例子来看它们是如何工作的！
- en: '**GUESS MY NUMBER**'
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**猜我的数字**'
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: while循环会一直执行某些操作，直到某个条件为真。这对于猜数字游戏非常适用，例如，当你想出一个数字并让朋友猜是什么，直到他们猜对为止。我们可以编写一个这样的程序！你将选择一个1到20之间的数字，而计算机将尝试猜测它是什么。请在新的playground中编写以下代码：
- en: '[PRE43]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个特殊的库，叫做Foundation框架，它包含了我们需要的生成随机数的函数。为了使用这个库，我们在playground的顶部写下import
    Foundation ➊这一行。（我们将在[第7章](text00017.html#ch07)中更详细地讨论函数。）
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为numberIAmThinkingOf的常量，并将其设置为1到20之间的任意数字。然后，在➋处，我们创建一个名为currentGuess的变量，表示计算机的猜测，并将其设置为-1。将currentGuess变量设置为-1是一种很好的方式，表示计算机还没有做出猜测。
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: while循环从关键词while开始，在➌处，接着是条件在➍处。在这个例子中，条件检查currentGuess是否不等于numberIAmThinkingOf。如果条件为真，意味着计算机还没有正确猜测我们的秘密数字，那么while循环中的语句将会执行。
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 因为while循环依赖于条件，所以非常重要的是，在while循环内部包含某种方式来改变条件，*否则*循环会一直运行下去，永远不会进入程序的下一部分！与for-in循环不同，while循环没有自动增加或减少的计数器。必须由你来控制！
- en: '![image](Image00095.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00095.jpg)'
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➎处通过让计算机猜一个介于1和20之间的新数字，然后将该新数字放入currentGuess来做到这一点。不要太担心完全理解那行代码；只需知道Int(arc4random_uniform(20))将创建一个0到19之间的随机整数，我们在那行代码的末尾加上+1，这样就能得到1到20之间的数字。
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不小心陷入了一个永远运行的循环，最好的做法是通过在while关键字前加两个斜杠来注释掉它。这样就能停止循环，让你找出问题所在。
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机最终猜对数字时，while循环结束，并且会在控制台打印出一条友好的消息。输出应该类似于[图4-2](text00014.html#ch04fig2)。
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个程序输入到 playground 时，你的循环运行了多少次？它的次数可能与[图 4-2](text00014.html#ch04fig2)中的次数不同。这个数字猜测程序就是一个
    while 循环能做到的例子，而 for-in 循环做不到。我们无法知道猜对数字需要多少次随机猜测，因此不能写一个 for-in 循环来实现这个功能。while
    循环允许计算机一直猜，直到它猜对为止。
- en: '![image](Image00096.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00096.jpg)'
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：数字猜测程序的输出*'
- en: '**SHRINK AWAY**'
  id: totrans-484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**缩小吧**'
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: repeat-while 循环与 while 循环非常相似，区别在于它的写法不同，而且检查结束循环的条件是在循环运行*之后*进行的。我们将通过删除句子中的字母直到它消失来测试
    repeat-while 循环。
- en: 'Try out the following code:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行以下代码：
- en: '[PRE44]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要使用一个方法来去掉字符串中的最后一个字符。我们需要和在猜数字游戏中使用的相同的 Foundation 框架，因此在 playground
    的顶部输入 import Foundation。（我们将在[第 8 章](text00018.html#ch08)中详细讨论方法。）
- en: '![image](Image00097.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00097.jpg)'
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的计算机看到 repeat-while 循环时，它会执行 repeat 关键字后面的代码块 ➊，然后检查 while 关键字后面的条件 ➌ 是否为真。在我们的示例中，我们首先创建一个名为
    shrinking 的字符串变量。在我们的 repeat 块中，我们打印出这个字符串，然后删除最后一个字符。你不必记住或理解执行这一操作的 dropLast()
    方法；只需要知道 ➋ 处的代码会从我们的字符串中删除最后一个字符。
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过去掉最后一个字符并将缩短后的字符串保存在 shrinking 变量中，来从原本的字符串中创建一个更短的字符串。这会将 shrinking 的值更新为新的、更短的字符串。在这种情况下，我们希望不断删除字符，直到没有字符剩下。因此，我们的
    while 循环的条件是，只要 shrinking 中的字符数量大于 0，就继续执行这个过程。要确定字符串中的字符数量，可以在字符串名称后输入 .characters.count。查看[图
    4-3](text00014.html#ch04fig3)，看看那个令人难以置信的缩短句子！
- en: '![image](Image00098.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00098.jpg)'
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：救命！我在缩短！*'
- en: '**WHICH LOOP TO USE?**'
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用哪种循环？**'
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以用几种方式在代码中创建循环。由你，作为程序员，来选择最适合你需求的方式。请记住，通常没有唯一正确的答案，因为for-in、while和repeat-while循环可以做相同的事情，具体取决于它们的写法。当你不知道循环需要运行多少次时，可能会发现需要使用while或repeat-while循环，但几乎所有的for-in循环都可以通过while循环来完成。通常，最好选择你最理解的那一个。
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你后来改变主意，觉得使用另一种类型的循环会更适合某个特定情况，那也是完全可以的。你写的第一段代码不必完美，事实上（即便是对有经验的程序员来说）它几乎永远不会完美！但编程的关键是练习和解决问题：写一点代码，看看它如何工作，然后再回来改进它。
- en: '**NESTING AND SCOPE**'
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套和作用域**'
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何编写循环和条件语句来做选择了。你还可以将这些元素以几乎任何你想要的方式组合。例如，你可以将if语句嵌套在for-in循环中，while循环嵌套在if块中，或者将for-in循环嵌套在另一个for-in循环中。当你将循环和条件语句结合时，有两个重要的概念需要记住：嵌套和作用域。
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**嵌套代码块**'
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个代码块嵌套在另一个代码块内部时，这叫做*嵌套*。比如，如果你在while循环中写了一个if语句，那就叫做*嵌套*的if语句。记住，当我们说*代码块*时，我们指的是在花括号（{}）之间的代码。例如，输入以下代码，它将输出一个星号和破折号组成的三角形图案：
- en: '[PRE45]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[图 4-4](text00014.html#ch04fig4)。我们在Xcode中添加了一些颜色，帮助你看到每个嵌套的代码块。
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要嵌套任意多个代码块。在这个示例中，我们将每个代码块分别称为Nest A、Nest B、Nest C，以此类推。正如你在[图 4-4](text00014.html#ch04fig4)中看到的，我们的程序包含了最外层的Nest
    A，它包括了`for count in 1...10`语句内的所有代码。Nest A包含了两个嵌套的代码块，Nest B和Nest D。而这些嵌套的代码块中，每一个也都包含了一个嵌套：Nest
    C位于Nest B内部，Nest E位于Nest D内部。
- en: '![image](Image00099.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00099.jpg)'
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：带有嵌套for-in循环的嵌套if-else语句*'
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-592
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  id: totrans-613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-622
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-627
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-684
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  id: totrans-695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-738
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-766
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  id: totrans-776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-790
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-807
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-812
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-819
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-838
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-840
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-843
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  id: totrans-855
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  id: totrans-856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-892
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-899
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY HELLO!**'
  id: totrans-935
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-959
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-978
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-981
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-999
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1002
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1006
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1022
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1027
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1034
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1037
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1044
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1049
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1056
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1059
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1064
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1071
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1075
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1099
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1110
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1136
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1148
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1157
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1161
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1175
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1186
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1197
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1209
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1212
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1224
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1230
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1233
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1237
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1250
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1261
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1272
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1277
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1284
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1299
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1305
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1308
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1312
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1324
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1335
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1346
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1358
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1361
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1373
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1379
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1382
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1386
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1397
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1419
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1424
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1431
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1434
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1446
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1452
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1455
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1459
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1469
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1480
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1491
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1496
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1503
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1506
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1518
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1524
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1527
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1531
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1540
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1551
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1562
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1567
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1574
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1577
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1589
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1595
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1598
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1602
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  id: totrans-1610
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1621
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1632
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1637
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1644
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1647
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1659
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1665
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1668
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1672
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1690
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1701
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1706
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1713
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1716
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1728
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1732
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1734
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1737
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1741
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1758
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1769
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1774
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1781
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1784
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1796
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1802
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1805
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1809
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1825
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1836
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1841
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1848
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1851
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1856
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1863
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1867
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1869
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1872
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1876
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1891
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1902
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1907
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1914
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1917
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1924
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1929
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1933
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-1935
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-1938
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-1942
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  id: totrans-1950
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-1956
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-1957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-1960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-1967
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-1972
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-1974
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-1979
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-1982
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-1984
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-1987
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-1989
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-1994
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-1998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2000
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2003
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2007
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-2016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-2020
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-2026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2031
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2036
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-2041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2043
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2046
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2048
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2051
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2053
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-2055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2058
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2062
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2064
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2067
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-2069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2071
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-2074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2076
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-2079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-2083
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2087
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-2089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2094
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2099
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-2104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2106
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2109
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-2118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2121
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2127
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2130
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-2132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2134
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-2137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-2145
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-2151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2156
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2161
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-2166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2168
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2171
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-2180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2189
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2192
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-2194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-2199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-2206
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-2212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2217
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2229
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2232
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-2241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2244
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2250
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2253
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-2260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-2266
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-2272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2277
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2282
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-2287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2289
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2292
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2304
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2310
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2313
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2317
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-2320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  id: totrans-2325
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-2331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2336
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2341
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-2346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2348
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2351
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-2360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2363
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2369
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2372
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-2374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2376
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-2379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  id: totrans-2384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-2389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2394
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2399
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-2404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2406
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2409
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-2418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2421
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2427
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2430
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-2432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2434
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-2437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-2446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2451
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2456
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2463
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2466
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-2475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2478
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2484
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2487
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-2489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2491
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-2494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-2502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2507
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2512
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-2517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2519
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2522
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-2531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2534
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2540
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2543
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-2545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2547
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-2550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  id: totrans-2555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-2557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2562
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2567
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-2572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2574
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2577
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-2586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2589
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2595
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2598
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-2600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2602
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-2605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-2611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2616
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2621
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-2626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2628
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2631
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-2640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2643
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2649
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2652
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-2654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2656
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-2659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-2664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2669
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2674
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-2679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2681
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2684
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-2693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2696
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2702
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2705
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2709
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-2712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2721
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2726
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-2731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2733
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2736
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-2745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2748
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2754
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2757
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-2759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2761
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-2764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2772
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2777
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-2782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2784
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2787
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-2796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2799
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2805
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2808
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2812
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-2815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2822
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2827
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-2832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2834
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2837
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2844
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-2846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2849
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2855
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2858
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-2860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2862
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-2865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2871
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2876
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-2881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2883
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2886
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2891
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2893
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-2895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2898
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2902
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2904
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2907
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-2909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2911
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-2914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  id: totrans-2919
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2924
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2926
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-2929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2931
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2934
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-2943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2946
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2950
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2952
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-2955
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-2957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-2959
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-2971
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-2973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-2976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-2978
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-2981
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-2983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-2986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-2988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-2990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-2993
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-2997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-2999
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3002
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-3004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3006
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-3009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-3017
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-3019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-3022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3024
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3027
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-3036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3039
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3043
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3045
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3048
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-3050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3052
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-3055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-3062
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-3064
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-3067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3069
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3072
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3077
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-3081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3084
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3090
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3092
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3093
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-3095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3097
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-3100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-3106
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-3108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-3111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3113
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3116
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-3125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3128
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3134
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3137
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-3139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-3144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  id: totrans-3149
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-3151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-3154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3156
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3158
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3159
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3163
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-3168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3171
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3177
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3180
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-3182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3184
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-3187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-2: Output from the number-guessing program*'
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-3193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-3196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3198
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3201
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-3210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3213
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3219
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3222
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-3224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3226
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-3229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  id: totrans-3234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-3237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3239
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3242
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-3251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3254
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3260
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3263
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-3265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3267
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-3270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-3277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3279
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3282
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-3291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3294
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3300
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3303
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-3305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3307
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-3310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-3316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3318
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3321
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3324
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-3330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3333
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3339
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3342
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-3344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3346
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-3349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-3354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3355
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3356
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3359
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-3368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3371
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3372
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3377
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3380
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-3382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3384
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-3387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3393
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3396
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-3405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3408
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3414
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3417
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-3419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3421
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-3424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  id: totrans-3429
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3432
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3436
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-3441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3444
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3450
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3453
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-3455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3457
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-3460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3467
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-3476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3479
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3481
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3485
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3486
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3488
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-3490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3492
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-3495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3501
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-3510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3513
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3519
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3522
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-3524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3526
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3527
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-3529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  id: totrans-3534
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-3543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3546
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3547
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3552
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3554
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3555
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-3557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3559
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-3562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3569
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-3575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3578
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3584
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3586
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3587
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-3589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3591
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-3594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  id: totrans-3599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-3606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3609
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3615
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3618
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-3620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3622
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-3625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3629
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-3636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3639
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3645
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3648
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-3650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3652
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-3655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-3665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3666
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3668
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3674
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3676
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3677
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-3679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3680
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3681
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-3684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  id: totrans-3689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  id: totrans-3693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3696
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3702
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3705
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-3707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3709
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-3712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  id: totrans-3720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3721
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3723
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3729
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3732
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  id: totrans-3734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3736
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  id: totrans-3739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  id: totrans-3744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  id: totrans-3746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3749
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3755
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3758
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-3760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3762
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  id: totrans-3765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  id: totrans-3771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3774
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3778
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3780
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3783
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-3785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3787
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  id: totrans-3790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  id: totrans-3795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3798
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3799
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3801
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3802
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3804
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3806
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3807
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  id: totrans-3809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3811
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3812
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  id: totrans-3814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3815
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3816
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3817
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  id: totrans-3819
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3821
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3823
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3824
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3825
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3827
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3829
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3830
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-3832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3834
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-3837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3838
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3840
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3843
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3847
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3848
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3849
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3851
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3852
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  id: totrans-3854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3856
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  id: totrans-3859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3862
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  id: totrans-3864
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3866
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3867
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3870
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3872
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3873
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  id: totrans-3875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3877
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3878
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3879
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  id: totrans-3880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3881
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3883
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  id: totrans-3885
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3887
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3888
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3889
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3890
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3892
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3893
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  id: totrans-3895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3896
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3897
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3898
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  id: totrans-3900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3904
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3906
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3909
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3912
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  id: totrans-3914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3915
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3916
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3917
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3918
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  id: totrans-3919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3921
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3922
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3923
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3926
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3927
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3928
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3929
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3930
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  id: totrans-3932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3934
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  id: totrans-3937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  id: totrans-3942
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3944
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3947
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  id: totrans-3949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3951
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  id: totrans-3954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3960
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3963
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  id: totrans-3965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3967
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-3970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3973
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  id: totrans-3975
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3977
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3978
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3979
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  id: totrans-3980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3981
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3982
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3983
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3984
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  id: totrans-3985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3987
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-3988
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-3991
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-3992
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  id: totrans-3994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-3996
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-3997
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  id: totrans-3999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4001
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4002
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4003
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-4005
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  id: totrans-4007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-4009
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  id: totrans-4012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4016
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  id: totrans-4017
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-4018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-4019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-4020
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-4021
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4022
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  id: totrans-4024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4028
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  id: totrans-4030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-4031
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-4032
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4033
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  id: totrans-4035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4036
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4038
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  id: totrans-4040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-4041
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-4042
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  id: totrans-4045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4047
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-4051
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4052
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  id: totrans-4054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4058
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  id: totrans-4059
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  id: totrans-4062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4064
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  id: totrans-4069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4071
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  id: totrans-4075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4077
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  id: totrans-4080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4083
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4093
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
