- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WRITING CODE THAT LOOPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPEN THE DEBUG AREA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: WRITING CODE THAT LOOPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPEN THE DEBUG AREA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPEN THE DEBUG AREA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: You just learned that you use conditional statements to run different branches
    of code depending on which conditions are met. *Loops* are another way you can
    control the order of your programs. With a loop, you can tell the computer to
    execute a block of code as many times as you want. This lets you reuse chunks
    of code again and again so that you don’t have to rewrite them!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPEN THE DEBUG AREA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are two main types of loops: for-in loops and while loops.
    The for-in loop tells the computer to run a loop a certain number of times, and
    it’s useful when you know right off the bat how many times you want the code to
    repeat. The while loop tells the computer to keep running a loop over and over
    until a certain condition is met, which is great when you’re more interested in
    repeating code based on events or conditions in your program. Let’s dig into each
    type of loop and learn more about it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPEN THE DEBUG AREA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**OPEN THE DEBUG AREA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started writing loops, let’s make sure your playground is set
    up to display the debug area. When you write for-in loops in the playground, the
    results sidebar on the right tells you only how many times a loop runs. To see
    the loop’s output, you need to display the debug area of the playground by selecting
    **View** ▸ **Debug Area** ▸ **Show Debug Area** (⌘ -SHIFT -Y). If this menu says
    Hide Debug Area, then it’s already showing the debug area, and you don’t need
    to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: When you show the debug area, it appears at the bottom of your playground by
    default, and you can drag the divider line at the top of it to make it taller
    or shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**LOOPING THROUGH RANGES AND COLLECTIONS WITH FOR-IN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: A for-in loop tells the computer to run the loop over a range of numbers or
    for each item in a collection. We’ll talk more about collections in [Chapter 6](text00016.html#ch06)
    , but for now, think of a collection as a group of items—like a bag of marbles
    or a case of trophies. Let’s see how we loop through a range of numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY HELLO!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a for-in loop to tell the computer something like, “I want to run
    this bit of code 4 times.” To do this, you write the for keyword, followed by
    a variable to count how many times the loop runs, then the in keyword, and finally
    the range of numbers that you want the loop to run through. Let’s write a simple
    for-in loop that prints your name 4 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop begins with the keyword for , followed by a variable ➊ that
    will be used as a counter to go through the range of numbers. We named our counter
    variable number , but you can give this variable any name you want. After the
    counter variable comes the keyword in . This keyword tells the computer to expect
    a range of integers. After in , we provide the range that we want the for-in loop
    to use, 1...4 ➋ . This is called a *closed range* from 1 to 4 , and it indicates
    that the count starts at 1 and ends at 4 . The three-dot symbol (... ) is the
    *closed range operator* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a line to our for-in loop so that we can see how number increases
    from 1 through 4\. Add the following line right after the line that prints your
    name inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the for-in loop, we use number just as we would any other variable. This
    statement prints a string that contains the value of number . To embed variables
    and constants into strings, you type a backslash and then enter the variable or
    constant you want to print in parentheses, just like we did at ➊ . This prints
    the variable’s value with the rest of your string. Pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: To make the output prettier, at ➋ we also added an empty new line at the end
    of the sentence by writing the special character for a new line, \n . When that
    sentence is printed, the computer does not print \n but instead adds a new line,
    like when you press RETURN or ENTER on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Your screen should look like [Figure 4-1](text00014.html#ch04fig1) . If you
    don’t see the printed text, make sure the debug area is turned on by pressing
    ⌘ -SHIFT -Y.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-1: Debug area display of a for-in loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop will run 4 times. The first time the loop runs, number is equal
    to 1; the second time it runs, it’s equal to 2; and so on until the final loop,
    when it’s equal to 4\. When number reaches the end of the range 1 through 4, the
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In a for-in loop, when the counter, number , cycles through the loop, increasing
    from 1 to 4, we say that the counter *iterates* over the range from 1 to 4\. Each
    time the code inside a for-in loop is run, we call that an *iteration* .
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: You can change these numbers to set different ranges to loop through. Try it
    out and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**SAY GOOD MORNING!**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to looping through a range of numbers, the for-in loop is useful
    for looping through collections. Here, you’ll use a collection called an *array*
    . We’ll talk more about arrays in [Chapter 6](text00016.html#ch06) , but all you
    need to know right now is that an array is a list of items stored in a constant
    or variable. When you use a for-in loop to go through an array, you’re telling
    your computer “for each item in the array, do something!” Let’s write code that
    greets kids.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we make our array called kidsInClass , which contains seven strings.
    The square brackets tell the computer that we’re creating an array, and each string
    in our array is separated by a comma. (The arrow means that a long line has wrapped
    on the page—you don’t need to enter the arrow.)
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: To print “Good Morning *kidsName* !” for each name in the kidsInClass array,
    at ➋ we write for kidsName in kidsInClass , followed by braces and our code. The
    code inside the braces will run once for each item in the array. These kinds of
    loops always follow the format for *constantName* in *collectionName* , where
    *constantName* is a name you choose to call each item from the collection inside
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌ , inside the for-in loop, we write the code to print a greeting for each
    name. To do that, we use kidsName just like it’s any other constant. kidsName
    exists only inside the braces of this loop, and it temporarily stores the current
    kid’s name as the for-in loop loops through the array. This way, we can print
    each name on each cycle of the loop to wish everyone a good morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**TESTING CONDITIONS WITH WHILE LOOPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: A for-in loop is great when you know how many times you want the computer to
    do something, but sometimes you might want the computer to do something over and
    over until a specific condition is met. For that, you should use a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of while loops: while and repeat-while . Both contain blocks
    of code that will be executed over and over again as long as a condition is true.
    The difference between the while loop and repeat-while loop is that the while
    loop checks the condition *before* it runs its block of code, and the repeat-while
    loop checks the condition *after* it runs its block of code. Let’s look at some
    examples to see how each works!'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**GUESS MY NUMBER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The while loop keeps doing something until a certain condition is true. This
    works well for a guessing game, such as when you think of a number and make a
    friend guess what it is until they get it right. We can write a program that does
    this! You’ll pick a number between 1 and 20, and the computer will try to guess
    what it is. Write the following code in a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use a special library, called the Foundation framework,
    that has the function we need to create a random number. To use this library,
    we write the line import Foundation ➊ at the top of our playground. (We’ll discuss
    functions in more detail in [Chapter 7](text00017.html#ch07) .)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constant called numberIAmThinkingOf and set it to be any number
    between 1 and 20\. Then, at ➋ , we create a variable called currentGuess to represent
    the computer’s guess and set it to -1 . Setting the currentGuess variable to -1
    is a good way to indicate that the computer hasn’t guessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop starts with the keyword while at ➌ , followed by a condition
    at ➍ . In this case, the condition checks whether currentGuess is not equal to
    numberIAmThinkingOf . If the condition is true , that means the computer still
    hasn’t correctly guessed our secret number, and the statements inside the while
    loop run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Because the while loop depends on a condition, it’s really important that you
    include some way for the condition to change *inside* the while loop, or it will
    run forever and never get to the next part of your program! Unlike a for-in loop,
    a while loop doesn’t have a counter that automatically increases or decreases.
    It’s up to you to control it!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: We do that at ➎ by having the computer guess a new number between 1 and 20 and
    then put that new number into currentGuess . Don’t worry too much about completely
    understanding the line of code that does that; just know that Int(arc4random_uniform(20))
    will create a random integer between 0 and 19, and we add a + 1 at the end of
    that line so we end up with a number between 1 and 20.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you’ve accidentally gotten yourself stuck in a loop that is
    running forever, the best thing to do is to comment out the while keyword by putting
    two slashes in front of it. That will stop the loop so you can figure out what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: When the computer finally guesses the correct number, the while loop ends and
    a nice message is printed to the console. The output should look something like
    [Figure 4-2](text00014.html#ch04fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: When you typed this program into a playground, how many times did your loop
    run? It’s likely a different number of times than in [Figure 4-2](text00014.html#ch04fig2)
    . This number-guessing program is an example of something you can do with a while
    loop that you couldn’t do with a for-in loop. We have no way of knowing how many
    random guesses it will take until the computer gets the correct number, so we
    couldn’t write a for-in loop to do this. A while loop lets the computer keep guessing
    as many times as it needs until it gets the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-2: Output from the number-guessing program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHRINK AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: The repeat-while loop is very similar to the while loop except it’s written
    differently and the condition to end the loop is checked *after* the loop runs.
    We will test the repeat-while loop by deleting the letters in a sentence until
    it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we need to use a method that chops off the last character in
    a string. We need that same Foundation framework that we used in our guessing
    game, so enter import Foundation at the top of your playground. (We’ll discuss
    methods in more detail in [Chapter 8](text00018.html#ch08) .)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: When your computer sees a repeat-while loop, it runs the block of code after
    the repeat keyword ➊ and then checks whether the condition after the while keyword
    ➌ is true . In our example, we start by creating a variable string called shrinking
    . In our repeat block, we print our string, and then we cut off the last character.
    You don’t have to memorize or understand the dropLast() method that does this;
    just know that the code at ➋ removes the last character from our string.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: We are making a shorter string out of our shrinking string by taking off the
    last character and then saving that shorter string in the shrinking variable.
    This updates the value of shrinking to the new, shorter string. And in this case,
    we want to keep removing characters until we have no characters left. So the condition
    of our while loop is to repeat this process as long as the number of characters
    in shrinking is greater than 0\. To determine the number of characters in a string,
    you enter .characters.count after the string name. Check out [Figure 4-3](text00014.html#ch04fig3)
    to see the incredible shrinking sentence!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-3: Help! I’m shrinking away!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH LOOP TO USE?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are several ways to create a loop in your code. It’s up
    to you, the programmer, to pick the one that’s right for what you need to do.
    Keep in mind there is often no single right answer because the for-in , while
    , and repeat-while loops can do the same thing, depending on how they’re written.
    You may find that you need a while or repeat-while loop when you don’t know how
    many times a loop needs to run, but you can accomplish almost every for-in loop
    with a while loop. It’s usually best to pick the one that you understand the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also perfectly fine to change your mind later and try a new technique
    if you think that a different type of loop will work better for a particular situation.
    The first code you write doesn’t have to be perfect, and in fact (even for experienced
    programmers) it almost never will be! But the point of coding is to practice and
    problem-solve: write a little code, see how it works, and then go back and make
    it better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING AND SCOPE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now you know how to write loops and conditional statements to make choices.
    You can also combine those elements in just about any way that you want. For example,
    you can put an if statement inside a for-in loop, a while loop inside an if block,
    or a for-in loop inside another for-in loop. When you combine loops and conditional
    statements, there are two important concepts you need to keep in mind: nesting
    and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTING BLOCKS OF CODE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you put one code block inside another block, it’s called *nesting* . So
    if you write an if statement in a while loop, you would call that a *nested* if
    statement. Remember that when we say *code block* , we are referring to the code
    between opening and closing braces, {} . As an example, enter the following code,
    which outputs a triangle-shaped pattern of asterisks and dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 4-4](text00014.html#ch04fig4) . We added some color to
    Xcode to help you see each nested block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest as many blocks of code as you want. In this example, we’ll refer
    to each block of code as Nest A, Nest B, Nest C, and so on. As you can see in
    [Figure 4-4](text00014.html#ch04fig4) , our program contains an outermost Nest
    A, which includes all of the code inside the for count in 1...10 statement. Nest
    A contains two nested blocks of code, Nest B and Nest D. And each of those nested
    blocks of code also contains a nest: Nest C is inside of Nest B, and Nest E is
    inside of Nest D.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-4: A nested if-else statement with nested for-in loops*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the code and see what’s going on. At ➊ , there’s an outermost
    for-in loop, which we call Nest A, that will run 10 times as count increases from
    1 to 10\. Inside that for-in loop, there’s a nested if-else statement at ➋ that
    will check whether count is even or odd. That if statement contains Nest B. To
    check if a number is even, we use the modulo operator (% ), which tells us what
    the remainder will be when an integer is divided by another integer. If a number
    is divided by 2 and the remainder is 0, then it must be an even number. So to
    figure out if count is even, we check whether count % 2 == 0 .
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: If count is even, we print a string of stars (* ). We use count to determine
    how many stars to print. We do this by creating an empty starString and then using
    a nested for-in loop, Nest C, at ➌ to add a star each time starCount iterates
    from 1 to count . After the nested for-in loop is finished, at ➍ we print our
    starString , which now has count number of stars. We print a nested else statement
    ➎ , which we’re calling Nest D. When count is odd, we print out a string of dashes
    instead of stars, as instructed in Nest E.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANT AND VARIABLE SCOPE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a variable has *scope* , which refers to where the variable
    exists and where it can be used. When you declare a constant or variable inside
    a nested block of code, that constant or variable does not exist outside that
    nested block. That means its scope is limited to the block of code in which it
    was declared and to any nested code in that block. [Figure 4-5](text00014.html#ch04fig5)
    shows the scope of the variables of our nested code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-5: The scope of a variable or constant is limited to the nest in
    which it was declared, as well as any code nested in that nest.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five variables declared in our program: count , starString , starCount
    , dashString , and dashCount . The outermost nest, Nest A, can see only count
    . It doesn’t have access to any variables or constants inside its nested blocks
    of code, which means you can’t use variables or constants that are declared in
    Nests B or C. The variable starString is declared in Nest B. Nest B therefore
    has access to starString as well as anything created in Nest A, which includes
    count . Nest C has access to starCount , starString , and count . Similarly, in
    the else clause, Nest D has access to count and dashString , and Nest E has access
    to count , dashString , and dashCount . If you try to use a variable that a block
    of code can’t access because it’s outside its scope, you’ll get an error. For
    example, you can’t print dashString inside the outermost nest, Nest A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at another example. We’ll write code that creates a greeting.
    If it is morning, we want the greeting to be “Good Morning.” Otherwise, we want
    the greeting to be “Good Afternoon.” Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: When you print greeting after this if-else statement, you get an error, as shown
    in [Figure 4-6](text00014.html#ch04fig6) . The variable greeting is outside the
    scope of the if-else block, so the computer doesn’t know what greeting is.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4-6: Trying to access greeting outside of its scope gives an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you must declare greeting outside the if-else block.
    Rewrite the greeting code as follows to output the greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we declared greeting as an empty string before the if-else block,
    at ➊ . Then, we set greeting to be either “Good Morning” or “Good Afternoon” depending
    on whether isMorning is true or false . Finally, we print the greeting at ➋ ,
    after the if-else block, because it was declared in the same scope as the print
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to repeat code using loops. You learned that
    you can use either a for-in loop or a while loop to accomplish many of the same
    goals. A for-in loop is perfect for looping through a collection of items and
    doing one thing for each item, and a while loop is better suited when you do not
    know how many times a loop needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00015.html#ch05) , we’ll introduce a new kind of variable
    in Swift—optionals. Optionals are variables that can either have a value or no
    value at all. They are useful when you need to create a variable, but you don’t
    yet know its value.
  prefs: []
  type: TYPE_NORMAL
