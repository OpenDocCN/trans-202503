<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_97"/><span class="big">4</span><br/>FORTH</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Forth is the quintessential minimalist programming language. Parsing Forth is nothing more than extracting tokens separated by whitespace. There is no interpretation of formulas and everything is a discrete word operating on the stack. Programs are a collection of functions, called <em>words</em>, that are compiled, function by function, to an ever expanding memory space known as the <em>dictionary</em>. Words are executed when encountered, or compiled to the dictionary when defined. This is in contrast to languages like Python, C++, or Java, which require sophisticated parsers and compilers and a rigid structure, and are well-abstracted from the hardware of the computer.</p>&#13;
<p class="indent">In this chapter, we’ll install Forth, discuss the origins and philosophy behind the language, and then dive into the language itself. We’ll include some examples along the way and end with a discussion.</p>&#13;
<h3 class="h3" id="lev1sec35"><span epub:type="pagebreak" id="page_98"/><strong>Installation</strong></h3>&#13;
<p class="noindent">Installing Forth is particularly easy.</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install gforth</span></pre>&#13;
<p class="indent">Forth runs interactively. To see if our installation is working, we can type</p>&#13;
<pre>&gt; <span class="codestrong1">gforth</span>&#13;
Gforth 0.7.3, Copyright (C) 1995-2008 Free Software Foundation, Inc.&#13;
Gforth comes with ABSOLUTELY NO WARRANTY; for details type `license'&#13;
Type `bye' to exit</pre>&#13;
<p class="indent">Forth is quietly waiting for us to type something. Forth interprets tokens separated by one or more spaces. If the token is a known word, that is, a defined function, it is executed. If the token is a number, then it’s pushed on the stack. Input lines are executed when you press ENTER. Try the following command:</p>&#13;
<pre><span class="codestrong1">cr 1 2 + 3 * .</span>&#13;
9  ok</pre>&#13;
<p class="noindent">This will tell Forth to move to the next line (<code>cr</code>), push 1 on the stack followed by 2, and then add (<code>+</code>) the 1 and the 2, leaving 3 on the stack. Next, we push another 3 on the stack and multiply them (<code>*</code>). Lastly, the period (<code>.</code>) prints the top stack value, which is now 9. Forth signals it’s ready for more commands with the <code>ok</code> prompt. To exit, enter <span class="codestrong">bye</span>.</p>&#13;
<p class="indent">Forth uses <em>postfix notation</em>, meaning the operator comes after the operands. To get 1 + 2, we entered <code>1 2 +</code>. Postfix notation was developed by Jan Łukasiewicz in 1924 and, because of his nationality, is often known as <em>reverse Polish notation</em> or <em>RPN</em>. Some early desk calculators also used postfix notation. The nice thing about postfix is that it never requires parentheses.</p>&#13;
<h3 class="h3" id="lev1sec36"><strong>Origins and Philosophy</strong></h3>&#13;
<p class="noindent">Forth was created by Charles “Chuck” Moore and evolved through the 1960s, coming of age in the early 1970s. As an interactive system in an age of punch cards, Forth was ahead of the curve. One of its primary uses early on was telescope control. Over time, Forth found its niche in small systems, though full-blown, object-oriented Forths appeared for personal computers.</p>&#13;
<p class="indent">Forth, originally spelled FORTH, was meant as a fourth-generation programming language, but the assembler only allowed five-character names. So instead of “FOURTH,” it was “FORTH,” and later “Forth.” The term <em>fourth generation</em> dates to when programming languages were grouped by the vague concept of a generation. The first generation was machine code and the second was assembly. Languages like C were the third generation. And that’s where the term <em>generation</em> started to falter—most languages were third generation.</p>&#13;
<p class="indent">Freedom to the programmer sums up Forth’s philosophy. The extreme openness of the language includes extending the compiler itself, which is <span epub:type="pagebreak" id="page_99"/>functionality seldom seen in other languages. We’ll see how to do this later in the chapter.</p>&#13;
<p class="indent">Forth conceives of programs as documents written in a custom language using words (functions) compiled into a dictionary. The dictionary stores all the words needed to implement the program, along with all necessary data. Each new word or block of data is added to the end of the dictionary.</p>&#13;
<p class="indent">Historically, the Forth community frowned upon code reuse. Building a library for later use was deemed a recipe for disaster. The modern approach of pulling pieces from many different libraries of pre-built code, like the standard modules of Python or the standard template library of C++, was alien to Forth and considered distasteful. A “good” Forth programmer developed the appropriate set of words to implement the specified task: no more and no less. If done well, the code itself reads much like a document. Good Forth is self documenting.</p>&#13;
<p class="indent">I ran across an email signature many moons ago, source long lost, that read: “C makes you think it is the best programming language in the world. Forth makes you think you are the best programmer in the world.” This captures the philosophy of Forth quite nicely. Instead of only using what the language designers gave, the Forth programmer manipulates the raw material of Forth, turning it into the ideal language for the task at hand.</p>&#13;
<h3 class="h3" id="lev1sec37"><strong>The Language</strong></h3>&#13;
<p class="noindent">Forth is, in essence, a system and not simply a compiler or interpreter. Early Forths <em>were</em> the operating system. They accessed disks in 1024-byte blocks—there was no filesystem—and they compiled code from those blocks. There is a top-level <em>REPL</em> (read, evaluate, print, loop) that, by convention, uses <code>ok</code> as the prompt. Forth programs are a sequence of tokens separated by whitespace. In most Forths, any combination of characters, excluding space, tab, and newline, is a valid token.</p>&#13;
<p class="indent">Tokens are evaluated as encountered. If the token is found in the dictionary, it is executed. If the token is not in the dictionary, Forth tries to interpret it as a number. If Forth fails at this, Forth throws an error message and returns to the <code>ok</code> prompt.</p>&#13;
<p class="indent">Executing a word when encountered makes sense. But what does Forth do with numbers? Forth pushes them on the <em>stack</em>. All operations use the stack, either pulling arguments from or pushing results onto the stack. Tokens interpreted as numbers are pushed onto the stack. Words often pull values from the stack, operate on them, and push new values onto the stack.</p>&#13;
<p class="indent">The stack is central to Forth and several of the esolangs we’ll encounter later in the book, so let’s spend a bit of time understanding what a stack is and how to work with one.</p>&#13;
<h4 class="h4" id="lev2sec31"><strong><em>Understanding the Stack</em></strong></h4>&#13;
<p class="noindent">Stacks are basic computer science data structures, often referred to as <em>last in, first out</em>, or <em>LIFO</em>, data structures. They are the opposite of a queue, which is a <span epub:type="pagebreak" id="page_100"/><em>first in, first out</em>, or <em>FIFO</em>, data structure. I think of the stack of trays at a buffet. When trays are put on the stack, the first tray is set down, then the second, then the third, and so on. When someone takes a tray, they don’t take the first tray; they take the last one put on the stack. In contrast, the first thing out of the queue is the first thing put into it, not the last.</p>&#13;
<p class="indent">Most programming languages use stacks. An example is the return stack for function calls. Forth uses a stack for data and, as we’ll see below, a separate one for returning from function calls. It’s the data stack that Forth programmers use most frequently, though they can temporarily use the return stack with care.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04fig1">Figure 4-1</a> illustrates the operation of the stack.</p>&#13;
<div class="image"><img id="ch04fig1" src="Images/04fig01.jpg" alt="Image" width="589" height="277"/></div>&#13;
<p class="figcap"><em>Figure 4-1: Pushing values on the Forth stack (top), and popping values off (bottom)</em></p>&#13;
<p class="indent">Let’s walk through <a href="ch04.xhtml#ch04fig1">Figure 4-1</a>, beginning with the top row going from left to right. We have three values—1, 2, and 3—and an empty stack. Next, we <em>push</em> 1 on the stack. The top item on the stack is marked with an arrow. Then we push 2 on the stack, which is now on top of 1 and is thus the new top stack item. Lastly, we push 3 on the stack, making it the top stack item.</p>&#13;
<p class="indent">To remove items from the stack, we <em>pop</em> them. This is shown in the bottom row of <a href="ch04.xhtml#ch04fig1">Figure 4-1</a>. Again, moving from left to right, we pop the stack to get 3. Notice that 3 was the <em>last</em> item pushed onto the stack, so it is the first item popped off of the stack. We then pop the stack again to get 2, and pop one last time to get 1, leaving the stack empty. Attempting to pop an empty stack is a common Forth error. You’ll make it yourself, eventually.</p>&#13;
<h4 class="h4" id="lev2sec32"><strong><em>Using the Stack</em></strong></h4>&#13;
<p class="noindent">Manipulating the stack is perhaps the most frustrating part of Forth. However, Forth comes with many intrinsic words to help you control the stack. Let’s introduce some of them and see how they work. We’ll start with a simple example.</p>&#13;
<pre>&gt; <span class="codestrong1">gforth</span>&#13;
<span class="codestrong1">1 2 3</span>  ok&#13;
<span class="codestrong1">.</span> 3  ok<span epub:type="pagebreak" id="page_101"/>&#13;
<span class="codestrong1">. .</span> 2 1  ok&#13;
<span class="codestrong1">bye</span></pre>&#13;
<p class="noindent">First, we push 1, then 2, then 3 on the stack. To pop the stack and print the popped value, use a period (<code>.</code>). Doing so gives us 3, the last item pushed on the stack. Popping and printing the stack two more times gives us 2 and then 1, leaving the stack empty. To exit Forth, enter <span class="codestrong">bye</span>. Forth is case insensitive, so <code>BYE</code> works just as well.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04tab1">Table 4-1</a> introduces several words and an essential Forth convention.</p>&#13;
<p class="tabcap" id="ch04tab1"><strong>Table 4-1:</strong> Stack Manipulation Words</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Word</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Effect</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>dup</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a -- a a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Duplicate the top stack item</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>drop</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a b -- a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Drop the top of stack item</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>swap</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a b -- b a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Swap the top two stack items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>2dup</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a b -- a b a b )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Duplicate the top two stack items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>2drop</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a b c -- a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Drop the top two stack items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>over</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a b -- a b a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Copy the next to top of stack item</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>rot</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a b c -- b c a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Rotate the top three stack items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>nip</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a b c -- a c )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Drop the next to top of stack item</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa_bottom-border"><p class="taba"><code>.s</code></p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa_bottom-border"><p class="taba"><code>( -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa_bottom-border"><p class="taba">Print the stack without altering it</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The words are somewhat descriptive, and Forth is case insensitive, but the Effect column is important. The Effect column contains <em>stack-effect comments</em>, which we’ll describe below. Forth comments begin with a left parenthesis, <code>(</code>, and end with a right parenthesis, <code>)</code>. Note that a space after the <code>(</code> is required. Forth ignores anything after <code>(</code> until the first <code>)</code>. Comments may not be nested. Many Forth systems, including ours, use <code>\</code> as a comment running to the end of the line, like <code>//</code> in C++.</p>&#13;
<p class="indent">The comment itself illustrates how the word affects the stack. On the left is the stack as the word expects it with the top stack item on the right, next to the dashes. On the right of the dashes is the stack as the word leaves it, again with the top stack item on the right. There are conventions for the characters used, though they are more like guidelines than actual rules.</p>&#13;
<p class="indent">For example, <code>dup</code> duplicates the top stack item, so <code>a</code> becomes <code>a a</code>. If the word does not affect the stack, the empty <code>( -- )</code> comment is used. By convention, every word definition has a stack-effect comment after its name, much like the convention of adding a documentation string after the definition of a function in Python.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04tab1">Table 4-1</a> includes the word <code>.s</code> to print the contents of the stack without changing it. As you work with Forth, especially when getting a feel for the stack words, you’ll use <code>.s</code> often. It’s a good idea to use it to check that your words are not leaving extra junk on the stack.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_102"/>Let’s explore the stack some more.</p>&#13;
<pre><span class="codestrong1">1 2 3 .s</span> &lt;3&gt; 1 2 3  ok&#13;
<span class="codestrong1">dup .s</span> &lt;4&gt; 1 2 3 3  ok&#13;
<span class="codestrong1">2drop .s</span> &lt;2&gt; 1 2  ok&#13;
<span class="codestrong1">3 nip .s</span> &lt;2&gt; 1 3  ok&#13;
<span class="codestrong1">swap .s</span> &lt;2&gt; 3 1  ok&#13;
<span class="codestrong1">2drop .s</span> &lt;0&gt;  ok</pre>&#13;
<p class="noindent">The example above ends by calling <code>2drop</code> to remove the remaining two stack items, which is why <code>.s</code> shows no items on the stack (<code>&lt;0&gt;</code>). Work with the stack until you feel comfortable with the stack manipulation words.</p>&#13;
<p class="indent">All Forth systems support integer arithmetic using the expected operators: addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and modulo (<code>mod</code>). Many Forth systems, including gforth, work with floating-point numbers as well.</p>&#13;
<p class="indent">As practice, you might try implementing the following expressions using the standard arithmetic words:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabar">(1200 × 3) ÷ 4</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(ans: 900)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabar">8 × (127 <em>–</em> 9) ÷ 11</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(ans: 85)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabar">8 × (127 <em>–</em> 9) mod 11</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(ans: 9)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabar">((33 <em>–</em> 45) ÷ (7 + 9)) × 3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(ans: -3)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">You’ll need to convert the expressions into postfix, meaning instead of <em>a</em> + <em>b</em> you’ll write <em>a</em> <em>b</em> +, and so on. Leave subexpression values on the stack and combine them with operations later: (<em>a</em> + <em>b</em>) × (<em>c</em> + <em>d</em>) becomes <em>a</em> <em>b</em> + <em>c</em> <em>d</em> + ×.</p>&#13;
<p class="indent">To use floating-point with gforth, you must do two things. First, enter floating-point constants using scientific notation. So to push 3.1415 on the floating-point stack, separate from the data stack, which is integer only, use <code>3.1415e0</code>. For example, to calculate 1/1,121 using first integer then floating-point math, enter the following:</p>&#13;
<pre><span class="codestrong1">1 1121 / .</span> 0  ok&#13;
<span class="codestrong1">1e0 1121e0 f/ f.</span> 0.000892060660124888  ok</pre>&#13;
<p class="indent">For simplicity, we’ll stick with integer operations for the remainder of this chapter.</p>&#13;
<div class="box5">&#13;
<p class="boxtitle-d"><strong>FORTHS NOT FORTH</strong></p>&#13;
<p class="noindent">You’ve likely noticed by now that I’ve referred several times to “Forths” instead of just “Forth.” There is a reason for that. The “freedom to the programmer” philosophy extends to Forth itself. Excluding the minor differences between versions, there is only one Python. Similarly, C++ is C++ and Java is Java. In contrast, there are, or were, legions of Forths. Most are now forgotten or virtually unusable because the computers they were written for are long gone. For <span epub:type="pagebreak" id="page_103"/>example, few have ever heard of QForth for the Apple II, let alone the Jupiter ACE, the only 1980s-era personal computer to run Forth instead of BASIC. Because of this proliferation of Forth systems, what works nicely on one Forth implementation often fails on another. In 1994, ANSI standard Forth was defined (see ANSI X3.215-1994). Gforth follows this standard; however, the standard seems to have had little effect overall, as there are many homegrown Forth systems still in existence, most of which are non-standard and often highly customized.</p>&#13;
</div>&#13;
<p class="indent">Now let’s learn how to define our own Forth words.</p>&#13;
<h4 class="h4" id="lev2sec33"><strong><em>Words and Loops</em></strong></h4>&#13;
<p class="noindent">“Hello, world!” in Forth is</p>&#13;
<pre>: hi ( -- ) ." Hello, world!" cr ;</pre>&#13;
<p class="noindent">Here, we’ve defined our own word to print <code>Hello, world!</code>. Word definitions begin with a colon (<code>:</code>), followed by the name of the word, which in this case is <code>hi</code>. Next comes the stack-effect comment, which isn’t required, but strongly encouraged.</p>&#13;
<p class="indent">The word <code>hi</code> consumes nothing from the stack and leaves nothing on the stack, so the comment is empty: <code>( -- )</code>. The next token is <code>."</code> which begins compiling a string to print. Don’t forget the space after <code>."</code>; it’s required. The string ends with a double quote (<code>"</code>), followed by <code>cr</code> to move to the next line. The definition ends with a semicolon (<code>;</code>). We just defined our first word. To use it, enter <span class="codestrong">hi</span> at the <code>ok</code> prompt. Not too exciting, but it’s a start.</p>&#13;
<p class="indent">What if we are feeling particularly happy today and want to greet the world repeatedly? That’s easy to do as well. We just need a word that knows how to say <code>hi</code> many times:</p>&#13;
<pre>: hello ( -- ) 10 0 do  hi  loop ;</pre>&#13;
<p class="noindent">The new word, <code>hello</code>, uses a <code>do</code> loop. This is Forth’s version of a <code>for</code> loop, and may only be used within a word definition.</p>&#13;
<p class="indent">The general form of a <code>do</code> loop is</p>&#13;
<pre><span class="codeitalic1">&lt;end&gt;</span> <span class="codeitalic1">&lt;start&gt;</span> do <span class="codeitalic1">&lt;body&gt;</span> loop</pre>&#13;
<p class="noindent">Here, the ending and starting values are on the stack, with the ending value first, then the starting value, followed by the word <code>do</code>, the body of the loop, and the word <code>loop</code> to end the loop. Why so convoluted? It has to do with how Forth works. Comments about Forth being the exposed core of a compiler aren’t all that far from the truth. The words <code>do</code> and <code>loop</code> are not keywords, but rather words that execute immediately when encountered by Forth. Their action sets up the code to make the loop. All of Forth’s flow <span epub:type="pagebreak" id="page_104"/>control words operate this way. The core Forth compiling words are no different from those a programmer might create, which is why the Forth compiler can be extended on the fly if desired.</p>&#13;
<p class="indent">Some Forth systems, especially those implemented in C, define most of Forth in Forth using a small core set of words to build the rest of the system. For example, <code>lbForth</code> (<em><a href="https://gist.github.com/lbruder/10007431/">https://gist.github.com/lbruder/10007431/</a></em>) is one such C-based Forth in the public domain. Here’s how it defines <code>do</code> and <code>loop</code> in terms of other Forth words.</p>&#13;
<pre>: do here @ ' swap , ' &gt;r , ' &gt;r , ; immediate&#13;
: loop ' r&gt; , ' r&gt; , ' swap , ' 1+ , ' 2dup , ' = , ' 0branch , here @ - , ' 2drop , ; immediate</pre>&#13;
<p class="noindent">Many of the words in these definitions will not make sense right now, but they will over time if you continue to work with Forth. The <code>immediate</code> tag after <code>;</code> marks the word to make sure it is executed when encountered, even when defining another word. Also, the single quote (<code>'</code>) takes the next token, looks up its execution address in the dictionary, and places that address on the stack. The comma (<code>,</code>) adds the top-of-stack number to the end of the dictionary, which in this case is the address of the word before it. The word <code>here</code> places the address of the end of the dictionary on the stack. Thus, <code>do</code>’s net effect is to put the current end of the dictionary address on the stack and then compile references to order and store the loop limits that are already on the stack on the return stack. That’s <code>swap &gt;r &gt;r</code>. I mentioned above that the return stack, which holds the address of where to go after the current word ends, is available to programmers if they are careful and remove anything they place on it.</p>&#13;
<p class="indent">Notice how <code>loop</code> pulls the limits from the return stack with <code>r&gt;</code> and orders them, after which it increments the lower limit and compares it with the upper limit. If the limits are not equal, a branch back to the initial starting address placed on the stack by <code>do</code> happens courtesy of <code>0branch</code>. The number of bytes to branch backward is calculated with <code>here @ -</code>.</p>&#13;
<p class="indent">A firm understanding of how these words operate isn’t required. I’ve only highlighted them so we notice how even the compiler itself is Forth. The openness that allows flow control words like <code>do</code> and <code>loop</code> to be implemented in Forth is available to all Forth programmers. I know of no other programming language that is so open in this way.</p>&#13;
<p class="indent">The loop of <code>hello</code> above ran 10 times even though the limits were 0 and 10. This is because the upper limit is not included, making the <code>do</code> loop act like a C <code>for</code> loop:</p>&#13;
<pre>for(int i=0; i &lt; 10; i++)&#13;
    printf("Hello, world!\n");</pre>&#13;
<p class="noindent">The C code above used <code>i</code> as the loop counter. In Forth, the word <code>i</code> supplies the loop counter. Consider the following:</p>&#13;
<pre><span class="codestrong1">: counter ( -- )  10 0 do  i .  loop ;</span>  ok&#13;
<span class="codestrong1">counter</span> 0 1 2 3 4 5 6 7 8 9  ok</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>In this example, note that <code>do</code> uses <code>i</code> to access the current value of the loop counter.</p>&#13;
<p class="indent">There are times when incrementing by one isn’t sufficient. Forth uses <code>+loop</code> in those cases, with the increment on the stack. The following example counts by threes.</p>&#13;
<pre><span class="codestrong1">: counter2 ( -- )  20 0 do i . 3 +loop ;</span>  ok&#13;
<span class="codestrong1">counter2</span> 0 3 6 9 12 15 18  ok</pre>&#13;
<p class="indent">It is also possible to use the index as the increment.</p>&#13;
<pre><span class="codestrong1">: counter3 ( -- )  100 1 do i dup . +loop ;</span>  ok&#13;
<span class="codestrong1">counter3</span> 1 2 4 8 16 32 64  ok</pre>&#13;
<p class="indent">Nested <code>do</code> loops are allowed. Use <code>i</code> to access the counter of the inner-most loop and <code>j</code> to access the counter of the next outer loop.</p>&#13;
<pre><span class="codestrong1">: nested0 ( -- ) 3 0 do 3 0 do j . i . space loop loop ;</span>  ok&#13;
<span class="codestrong1">nested0</span> 0 0  0 1  0 2  1 0  1 1  1 2  2 0  2 1  2 2   ok</pre>&#13;
<p class="noindent">In this example, <code>i</code> refers to the counter of the inner loop and <code>j</code> the outer. The word <code>space</code> prints a blank, as you likely surmised from the output. Note that we’re writing the double loop in one line for simplicity. Forth is quite happy if you split up the code in a way that is easier to read.</p>&#13;
<pre>: nested0 ( -- )&#13;
  3 0 do&#13;
    3 0 do&#13;
      j . i . space&#13;
    loop&#13;
  loop ;</pre>&#13;
<p class="indent">Let’s experiment a bit more with <code>i</code> and <code>j</code>. Consider the following:</p>&#13;
<pre><span class="codestrong1">: nested1 ( -- ) 5 1 do i 0 do j . loop loop ;</span>  ok&#13;
<span class="codestrong1">nested1</span> 1 2 2 3 3 3 4 4 4 4  ok&#13;
<span class="codestrong1">: nested2 ( -- ) 5 1 do i 0 do i . loop loop ;</span>  ok&#13;
<span class="codestrong1">nested2</span> 0 0 1 0 1 2 0 1 2 3  ok</pre>&#13;
<p class="indent">Look at the definition of <code>nested1</code>. There are two <code>do</code> loops here. The first loop goes from 1 up to, but not including, 5. The inner loop runs from 0 up to, but not including, the current value of <code>i</code>. The output reflects the counter of the outer loop and runs the inner loop that many times: first once, then twice, then three times, and so on, each time printing the value of the outer loop because of <code>j</code>.</p>&#13;
<p class="indent">Now, look at <code>nested2</code>. In this case, the inner loop references <code>i</code>, which is the counter of the inner loop. Therefore, the first pass of the outer loop sets <code>i</code> to 1, causing the inner loop to iterate one time from 0. This explains the first 0. On the next pass, <code>i</code> is 2 in the outer loop, thereby causing the inner <span epub:type="pagebreak" id="page_106"/>loop to run twice. The inner loop then references <code>i</code> as well; however, this time, the second <code>i</code> refers to the <em>inner</em> loop counter, which is why the output, on separate lines, is</p>&#13;
<pre>0&#13;
0 1&#13;
0 1 2&#13;
0 1 2 3</pre>&#13;
<p class="indent">What if you have three or more nested loops? How do you get the outer-most counter? There is no Forth word for that, so you’d need to stash the counter with <code>i</code> before starting the next two nested loops and access it that way. You can either leave it on the stack, push it to the return stack, or dump it to a variable and reference it when needed.</p>&#13;
<h4 class="h4" id="lev2sec34"><strong><em>What Is Truth?</em></strong></h4>&#13;
<p class="noindent">Forth is unusual, so it should come as no surprise that Forth’s definition of truth is unusual as well. In most languages, if there is no explicit Boolean data type, like <code>False</code> and <code>True</code> in Python, 0 is false and 1 (or not 0) is true. In Forth, false is 0, but true is <em>–</em>1. Forth also supports the usual comparison operators such as <code>&lt;</code> and <code>&gt;</code>.</p>&#13;
<pre><span class="codestrong1">1 2 &lt; .</span> -1  ok&#13;
<span class="codestrong1">-123 321 &lt; .</span> -1  ok&#13;
<span class="codestrong1">45 3 &gt; .</span> -1  ok&#13;
<span class="codestrong1">3 45 &gt; .</span> 0  ok</pre>&#13;
<p class="noindent">The above tells us that 1 &lt; 2, <em>–</em> 123 &lt; 321, and 45 &gt; 3 but not 3 &gt; 45.</p>&#13;
<p class="indent">To test for equal and not equal, use <code>=</code> and <code>&lt;&gt;</code>.</p>&#13;
<pre><span class="codestrong1">1 2 = .</span> 0  ok&#13;
<span class="codestrong1">1 2 &lt;&gt; .</span> -1  ok</pre>&#13;
<p class="indent">Forth works with both signed and unsigned integers, but the comparison operators above work only with signed integers. However, Forth also supports unsigned versions, indicated with a letter <code>u</code> before the operator.</p>&#13;
<pre><span class="codestrong1">1 2 u&lt; .</span> -1  ok&#13;
<span class="codestrong1">-123 321 u&lt; .</span> 0  ok</pre>&#13;
<p class="noindent">The first result makes sense, but the second might not; however, it is correct. The unsigned comparison looks only at the bit pattern representing <em>–</em>123. In two’s complement format, assuming 16-bit integers even though our Forth system uses 64-bit integers, the bit pattern for <em>–</em>123 is 1111111110000101 whereas the bit pattern for 321 is 0000000101000001. This means that <em>–</em>123 is greater than 321 when using an unsigned comparison.</p>&#13;
<p class="indent">Forth wouldn’t be of much use without some form of conditional expression. Thankfully, it supports <code>if</code>, <code>else</code>, and <code>then</code>. The general format for a conditional expression is</p>&#13;
<pre><span epub:type="pagebreak" id="page_107"/><span class="codeitalic1">&lt;condition&gt;</span> if <span class="codeitalic1">&lt;true_instructions&gt;</span> then&#13;
<span class="codeitalic1">&lt;condition&gt;</span> if <span class="codeitalic1">&lt;true_instructions&gt;</span> else <span class="codeitalic1">&lt;false_instructions&gt;</span> then</pre>&#13;
<p class="noindent">Here, <code>&lt;condition&gt;</code> is a condition flag on the stack, with 0 indicating false and <em>–</em>1 indicating true. If true, the words in <code>&lt;true_instructions&gt;</code> are executed. If there is an <code>else</code> and the condition is false, the words in <code>&lt;false_instructions&gt;</code> are executed.</p>&#13;
<p class="indent">For example, Goldilocks might want to know something about the state of the bowl of porridge she’s just stumbled upon based on its temperature. In Python, she might write the following:</p>&#13;
<pre>def porridge(n):&#13;
    print("The porridge is ", end="")&#13;
    if (n &lt; 90):&#13;
       print("too cold")&#13;
    elif (n &gt; 100):&#13;
         print("too hot")&#13;
    else:&#13;
         print("just right")</pre>&#13;
<p class="noindent">In Forth, she might write what’s shown in <a href="ch04.xhtml#ch04list1">Listing 4-1</a>.</p>&#13;
<pre>: porridge ( n -- )&#13;
  ." The porridge is "&#13;
  dup  90 &lt; if  drop ." too cold"  else&#13;
      100 &lt; if  ." just right"     else&#13;
                ." too hot" &#13;
  then then cr ;</pre>&#13;
<p class="caption" id="ch04list1"><em>Listing 4-1: Too cold, too hot, or just right</em></p>&#13;
<p class="noindent">She’d then test her Forth code like so:</p>&#13;
<pre><span class="codestrong1">80 porridge</span> The porridge is too cold&#13;
 ok&#13;
<span class="codestrong1">99 porridge</span> The porridge is just right&#13;
 ok&#13;
<span class="codestrong1">111 porridge</span> The porridge is too hot</pre>&#13;
<p class="indent">Let’s walk through the example in <a href="ch04.xhtml#ch04list1">Listing 4-1</a>. The word <code>porridge</code> expects a number on the stack, which in this case is the porridge’s temperature in degrees Fahrenheit. With the temperature still on the stack, <code>porridge</code> prints the first part of the output sentence. Note that there is no <code>cr</code>, so by default, the output does not move to the next line.</p>&#13;
<p class="indent">Next comes the set of nested <code>if</code> statements. Let’s start with the first one.</p>&#13;
<pre>dup  90 &lt; if  drop ." too cold"    else</pre>&#13;
<p class="indent">The word <code>dup</code> duplicates the temperature. This is necessary, as <code>&lt;</code> will consume it along with 90 to test <em>n</em> &lt; 90. The result, either 0 or <em>–</em>1, is then pushed onto <span epub:type="pagebreak" id="page_108"/>the stack. The value is consumed in this test, so if the first <code>if</code> fails, the nested second <code>if</code> will need a copy of <em>n</em> for its test.</p>&#13;
<p class="indent">At this point, the stack contains <em>n</em> and the output of <code>&lt;</code>. Next, <code>if</code> consumes the 0 or <em>–</em>1. If –1, <code>porridge</code> prints the rest of the sentence: too cold. What’s the <code>drop</code> doing there? Because <em>n</em> was duplicated to preserve it in case the first <code>if</code> failed, it’s still on the stack. Therefore, it must be dropped before <code>porridge</code> exits.</p>&#13;
<p class="indent">The second <code>if</code> is like the first; it checks to see if <em>n</em> is less than 100. If so, the porridge is just right; otherwise, it’s too hot. Note that there is no <code>dup</code> before the second <code>if</code> as <em>n</em> is not needed after the comparison, so it’s consumed by <code>&lt;</code>.</p>&#13;
<p class="indent">The way <a href="ch04.xhtml#ch04list1">Listing 4-1</a> is written follows classic Forth convention. As mentioned, early Forths accessed disks in 1024-byte blocks, so writing compact code was essential. The Forth editor split the 1024 bytes of a block, a <em>screen</em>, into 16 lines of 64 characters each.</p>&#13;
<p class="indent">Modern Forth is more flexible. The following code works just as well as <a href="ch04.xhtml#ch04list1">Listing 4-1</a>.</p>&#13;
<pre>: porridge (n -- )&#13;
  ." The porridge is "&#13;
  dup 90 &lt; if&#13;
    drop ." too cold"&#13;
  else&#13;
    100 &lt; if&#13;
      ." just right"&#13;
    else&#13;
      ." too hot"&#13;
    then&#13;
  then cr ;</pre>&#13;
<p class="indent">Some Forth systems, including gforth, support a <code>case</code> selection structure that mirrors <code>switch</code> in C. For example, in a menu-driven program, the proper action to take depends on which option the user selects—a natural place to use <code>case</code>.</p>&#13;
<pre>: menu ( n -- )&#13;
  case&#13;
    0 of ." option 0" endof&#13;
    1 of ." option 1" endof&#13;
    2 of ." option 2" endof&#13;
    ." bad option"&#13;
  endcase ;&#13;
<span class="codestrong1">0 menu</span> option 0 ok&#13;
<span class="codestrong1">1 menu</span> option 1 ok&#13;
<span class="codestrong1">2 menu</span> option 2 ok&#13;
<span class="codestrong1">5 menu</span> bad option ok</pre>&#13;
<p class="indent">Notice that <code>case</code> expects the option to be on the stack when the word is executed. Forth then searches through the cases looking for a match. <span epub:type="pagebreak" id="page_109"/>If a match is found, Forth executes the case’s body, which consists of the words between <code>of</code> and <code>endof</code>. If no case matches, Forth can use a default case (“bad option”).</p>&#13;
<h4 class="h4" id="lev2sec35"><strong><em>Other Control Structures</em></strong></h4>&#13;
<p class="noindent">Forth’s remaining control structures include a top-tested loop, a bottom-tested loop, and an infinite loop.</p>&#13;
<pre>begin <span class="codeitalic1">&lt;condition&gt;</span> while <span class="codeitalic1">&lt;body&gt;</span> repeat&#13;
begin <span class="codeitalic1">&lt;body&gt;</span> <span class="codeitalic1">&lt;condition&gt;</span> until&#13;
begin <span class="codeitalic1">&lt;body&gt;</span> again</pre>&#13;
<p class="noindent">The first two are similar to <code>while</code> and <code>do-while</code> in C, but the last one is a bit curious. It’s an infinite loop, which is easily written in other languages by making the <code>while</code> condition always true. However, when considering Forth implemented in Forth, it’s easy to see why <code>begin-again</code> might exist:</p>&#13;
<pre>: begin here @ ; immediate&#13;
: again ' branch , here @ - , ; immediate</pre>&#13;
<p class="noindent">Both <code>begin</code> and <code>again</code> are immediate words, that is, those that execute even when defining a word; <code>begin</code> places the current end-of-dictionary value on the stack, and <code>again</code> branches backward from the end of the dictionary to the location that <code>begin</code> initially placed on the stack. The branch is backward because <code>again</code> happens after the body of the loop, so <code>here</code> will report a higher address than the address placed on the stack by <code>begin</code>. I won’t show it here, but with a little imagination, one can guess how <code>while</code>, <code>repeat</code>, and <code>until</code> might be implemented as Forth words.</p>&#13;
<p class="indent">A simple example of <code>begin-again</code> is</p>&#13;
<pre>: infinity ( -- ) 0 begin  dup . cr 1+  again ;</pre>&#13;
<p class="noindent">The word <code>infinity</code> places 0 on the stack, duplicates it so it can be printed, and then increments it and starts repeating until you press CTRL-C or the power goes out.</p>&#13;
<p class="indent">Of more immediate utility are the top- and bottom-tested loops. A top-tested loop, the <code>while</code> loop, tests its condition before executing the body of the loop. Therefore, the body of the loop might never execute if the condition fails initially. For a bottom-tested loop, the body executes at least once to get to <code>until</code>. Let’s see <code>while</code> in action.</p>&#13;
<p class="indent">One way to estimate the square root of a number using integer operations is to start at 0, square 0, and ask if that result is equal to or greater than the number. If it isn’t, move on to try 1, then 2, 3, 4, and so on. Eventually, we’ll get to the point where the number squared is equal to or greater than the given number. <a href="ch04.xhtml#ch04list2">Listing 4-2</a> implements this inefficient algorithm with <code><em>while</em></code> .</p>&#13;
<pre>: dsqr ( n -- )  0 begin  2dup dup * &gt; while 1+ repeat nip ;</pre>&#13;
<p class="caption" id="ch04list2"><em>Listing 4-2: A brute-force square root word</em></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_110"/>We’ll call the word <code>dsqr</code> for “dumb square root” because it implements the simplest algorithm possible. The word pushes an initial 0, which is the counter, and then starts the loop with <code>begin</code>. Note that the number we want the square root of, <em>n</em>, is already on the stack.</p>&#13;
<p class="indent">There are two pieces to the <code>while</code> loop: the condition and the body. Here the condition is <code>2dup dup * &gt;</code>. We have the given number and 0 on the stack for <code>2dup</code> to duplicate. Next, <code>dup</code> duplicates the counter so it can be multiplied by itself to square it. This sets up <code>&gt;</code>, which leaves a 0 or <em>–</em>1 on the stack. Remember, because of <code>2dup</code>, the given number and counter are still on the stack.</p>&#13;
<p class="indent">Next, <code>while</code> uses the condition’s state to decide whether or not to execute the body of the loop, <code>1+</code>, which increments the counter still on the top of the stack. The <code>repeat</code> word does nothing as far as the loop is concerned, but again, we’ve seen enough of the internals of Forth to know that <code>repeat</code> is calculating how far back in the dictionary to branch to start again at <code>begin</code>. The word completes once the square root is found by removing the given number, the second-to-top stack item (<code>nip</code>).</p>&#13;
<p class="indent">As dumb as it is, <code>dsqr</code> works and is exact for perfect squares (but not for other numbers). Later, we’ll implement a different integer square root algorithm, one that is surely less computationally demanding (we think).</p>&#13;
<p class="indent">In Forth, <code>begin-until</code> loops always execute the body of the loop at least once. For example, here’s a word that plays a little guessing game.</p>&#13;
<pre>: guess ( -- ) 0 begin 1+ key 15 and 7 = until . ." guesses" ;</pre>&#13;
<p class="indent">Execute <code>guess</code> and press keys on the keyboard. The game ends when the lowest four bits of the ASCII character code for the key are 7. The counter is initially 0 and placed on the stack before <code>begin</code>. It is immediately incremented (<code>1+</code>) as there will always be at least one guess. Next, a keystroke is read and placed on the stack with <code>key</code>. The lowest four bits of the key’s character code are kept by <code>and</code>ing with 15 (0xF = 1111 in binary). That’s <code>15 and</code>. If the result is 7, <code>=</code> leaves <em>–</em>1 on the stack for <code>until</code>. If the result isn’t 7, <code>until</code> branches back to <code>begin</code>.</p>&#13;
<p class="indent">Earlier, I said that <code>begin-until</code> is similar to <code>do-while</code> in C; however, there is an important difference. Consider the C equivalent of <code>guess</code>:</p>&#13;
<pre>int main(int argc, char *argv[]) {&#13;
    int count = 0;&#13;
        &#13;
    do {&#13;
        count++;&#13;
    } while ((key() &amp; 0xF) != 7); &#13;
        &#13;
    printf("\n%d guesses\n", count);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="indent">This program uses <code>do-while</code>, but the condition on the <code>while</code> part is written so it is <em>true</em> if the low-order nibble (that is, the lowest four bits) of the key <span epub:type="pagebreak" id="page_111"/>entered is not 7. The Forth loop condition is <em>false</em> until the condition is met. In C, the logic is reversed: the <code>do-while</code> loop continues while the condition is true and the <code>begin-until</code> loop continues while the condition is false. Note that <code>key()</code> is not a standard C library function; it’s just a stand-in for a function that waits for a keystroke and returns the ASCII key code without requiring a newline.</p>&#13;
<p class="indent">This example introduced <code>key</code> to wait for a character from the keyboard. We’ll examine other Forth input and output functions later in the chapter. For now, let’s get a handle on how Forth works with memory.</p>&#13;
<h4 class="h4" id="lev2sec36"><strong><em>How Forth Uses Memory</em></strong></h4>&#13;
<p class="noindent">Forth relies heavily on its stack, but that’s not the only means it has to work with data. Forth supports constants and variables natively, and can allocate space on the dictionary for any use. Let’s see how.</p>&#13;
<h5 class="h5" id="lev3sec12"><strong>Variables and Constants</strong></h5>&#13;
<p class="noindent">To define constants and variables, use code like what’s shown in <a href="ch04.xhtml#ch04list3">Listing 4-3</a>.</p>&#13;
<pre><span class="codestrong1">variable f</span>&#13;
<span class="codestrong1">variable c</span>&#13;
<span class="codestrong1">32 constant b</span>&#13;
<span class="codestrong1">: c2f c @ 9 * 5 / b + f ! ;</span>  ok&#13;
<span class="codestrong1">: f2c f @ b - 5 * 9 / c ! ;</span>  ok&#13;
<span class="codestrong1">212 f !  f2c  c @ .</span> 100  ok&#13;
<span class="codestrong1">22 c !  c2f  f @ .</span> 71  ok&#13;
<span class="codestrong1">32 f !  f2c  c @ .</span> 0  ok</pre>&#13;
<p class="caption" id="ch04list3"><em>Listing 4-3: Variables and constants in Forth</em></p>&#13;
<p class="indent">The first two lines define variables <code>f</code> and <code>c</code>. The next line defines a constant, <code>b</code>, which is set to the top stack value, in this case 32.</p>&#13;
<p class="indent">Two short definitions come next. The first converts Celsius to Fahrenheit, <em>F</em> = (9/5)<em>C</em> + 32, and the second does the opposite, <em>C</em> = (5/9)(<em>F –</em> 32). Both definitions use the variables <code>f</code> and <code>c</code> instead of the stack—a very <em>un</em>-Forth-like thing to do. As an exercise, rewrite <code>c2f</code> and <code>f2c</code> to use the stack.</p>&#13;
<p class="indent">The word definitions in <a href="ch04.xhtml#ch04list3">Listing 4-3</a> have strange <code>@</code> and <code>!</code> characters in them. When a Forth variable is referenced, the value of the variable is <em>not</em> placed on the stack; only the address of the variable goes on the stack. To get at the value, the address must be dereferenced, just like in C, where a pointer must be dereferenced to get at the thing it points to. Therefore, the expression <code>c @</code> first places the address of <code>c</code> on the stack, then executes <code>@</code>, which is the word that takes an address and returns the 64-bit integer at that address. Equivalent C code for <code>c @</code> is <code>*&amp;c</code>, assuming that <code>c</code> is declared to be an <code>int</code>. First, use <code>&amp;</code> to get the address of <code>c</code>, then use <code>*</code> to return the contents of <code>c</code>.</p>&#13;
<p class="indent">Look again at the definition of <code>c2f</code> in <a href="ch04.xhtml#ch04list3">Listing 4-3</a>. The definition ends with <code>f !</code>. As you’ve likely already guessed, <code>!</code> stores values at the address on the top of the stack, in this case the Fahrenheit temperature. The stack effect for <code>!</code> is <code>( n a -- )</code> to store value <em>n</em> at address <em>a</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>There is an elegance to how Forth handles variables, as other data areas also leave their address on the stack. However, all the <code>@</code> and <code>!</code> characters flying around quickly become distracting. For example, to increment a variable <code>x</code> by 1, use <code>x @ 1+ x !</code>, which isn’t particularly easy to read. Note that <code>1+</code> is not a typo. Incrementing the top stack item is common enough that Forth implements a special word for it that executes faster than <code>1+</code> will. In truth, though, I’m being a bit unfair here. Forth does have the word <code>+!</code>, which adds a value to a variable. So <code>x @ 1+ x !</code> might be written as <code>1 x +!</code>, which is slightly more readable.</p>&#13;
<p class="indent">Forth supplies, at a minimum, two other words for memory access: <code>c@</code> and <code>c!</code>. Here the <code>c</code> refers to “character,” meaning old 8-bit ASCII. These words access <em>bytes</em>, not 64-bit integers. Consider this code:</p>&#13;
<pre><span class="codestrong1">variable x</span>  ok&#13;
<span class="codestrong1">hex 1122334455667788 x !</span>  ok&#13;
<span class="codestrong1">x @ .</span> 1122334455667788  ok&#13;
<span class="codestrong1">x c@ .</span> 88  ok&#13;
<span class="codestrong1">x 1+ c@ .</span> 77  ok&#13;
<span class="codestrong1">x 2 + c@ .</span> 66  ok&#13;
<span class="codestrong1">x 3 + c@ .</span> 55  ok&#13;
<span class="codestrong1">x 4 + c@ .</span> 44  ok&#13;
<span class="codestrong1">x 5 + c@ .</span> 33  ok&#13;
<span class="codestrong1">x 6 + c@ .</span> 22  ok&#13;
<span class="codestrong1">x 7 + c@ .</span> 11  ok</pre>&#13;
<p class="indent">First, we define <code>x</code> as a variable. Then, we assign a value to <code>x</code> by introducing a new word, <code>hex</code>, to place Forth in hexadecimal mode. All numbers will be interpreted as base-16 until <code>decimal</code> is executed to restore base-10. So the second and third lines when written in C become</p>&#13;
<pre>long long x = 0x1122334455667788;&#13;
printf("%llx", x);</pre>&#13;
<p class="indent">What of all the lines with <code>c@</code> in them? As <code>x</code> pushes the <em>address</em> of <code>x</code> on the stack, using <code>c@</code> returns the first <em>byte</em> at that address. Because Intel machines are little-endian, the first byte at the address of <code>x</code> is the lowest-order byte, <code>0x88</code> (to use C notation). Adding 1 to the address of <code>x</code> before accessing it moves to the next byte in memory to return <code>0x77</code>, and so on for all eight bytes of <code>x</code>.</p>&#13;
<p class="indent">This freedom makes it easy to modify memory in interesting ways. For example, the following code defines <code>x</code> as before, but then uses <code>c!</code> to modify the low-order byte of <code>x</code>, changing it from <code>88</code> to <code>ee</code>:</p>&#13;
<pre><span class="codestrong1">variable x hex</span>  ok&#13;
<span class="codestrong1">1122334455667788 x !</span>  ok&#13;
<span class="codestrong1">x @ . 1122334455667788</span>  ok&#13;
<span class="codestrong1">ee x c!</span>  ok&#13;
<span class="codestrong1">x @ . 11223344556677EE</span>  ok</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>Constants are just that: constants. Once fixed, they cannot be changed. Forth enforces this rule as well. However, consider these words:</p>&#13;
<pre><span class="codestrong1">1 constant 2</span>  ok&#13;
<span class="codestrong1">4 constant 1</span>  ok&#13;
<span class="codestrong1">1 1 + . 8</span>  ok&#13;
<span class="codestrong1">2 2 * . 1</span>  ok</pre>&#13;
<p class="noindent">Not every Forth system will allow this, but gforth does. What on Earth is happening? Recall what Forth does when it encounters a token on input. If it finds the token in the dictionary, it executes it; otherwise, it interprets it as a number and pushes it on the stack. The first two lines above define constants, <code>2</code> and <code>1</code>. In this case, the constants’ names really are “2” and “1” as characters. The value of the constant “2” is 1, and the value of the constant “1” is 4.</p>&#13;
<p class="indent">So the next time “2” is encountered, Forth first searches the dictionary, finds a constant with that name, and dutifully executes it to place a 1 on the stack. The same is true for “1” to place a 4 on the stack. Therefore, while confusing, Forth is perfectly correct to present output that seems to us to say 1 + 1 = 8 and 2 × 2 = 1.</p>&#13;
<p class="indent">There is a historical reason for allowing such shenanigans. Let’s face it: old computers were slow. Programmers were always on the lookout for tricks to speed things up. When dealing with a new token, Forth scans the dictionary from beginning to end, so many Forth programs started with strange definitions like <code>0 CONSTANT 0</code> because it was faster to look up zero as a word than scan the entire dictionary and then interpret the token as a number.</p>&#13;
<h5 class="h5" id="lev3sec13"><strong>Allocating Memory</strong></h5>&#13;
<p class="noindent">We’ll introduce several new words in this section. There will be a table at the end that contains all of them.</p>&#13;
<p class="indent">Forth puts all new data at the end of the dictionary. This includes word definitions, variables, and constants. To allocate arbitrary amounts of dictionary space, say for a buffer or a sequence of data structures of some kind, Forth provides several useful words: <code>create</code>, <code>does&gt;</code>, <code>allot</code>, <code>cells</code>, a comma (<code>,</code>), and <code>c,</code>. Let’s see how they work.</p>&#13;
<p class="indent">The word <code>create</code> defines a word that does nothing more than place its address on the stack. For memory allocation, <code>create</code> is often followed by <code>allot</code>, like so:</p>&#13;
<pre><span class="codestrong1">create buf 1000 allot</span>  ok</pre>&#13;
<p class="noindent">The word <code>buf</code> is created, and immediately following it, 1,000 bytes of dictionary space are allocated. Effectively, this means there is a 1,000-byte buffer at the end of the dictionary, and the first byte of the buffer is the address that <code>buf</code> leaves on the stack when executed. This alone is already useful, as shown next.</p>&#13;
<pre><span epub:type="pagebreak" id="page_114"/><span class="codestrong1">1 buf c!</span>  ok&#13;
<span class="codestrong1">2 buf 1+ c!</span>  ok&#13;
<span class="codestrong1">3 buf 2 + c!</span>  ok&#13;
<span class="codestrong1">buf c@ .</span> 1  ok&#13;
<span class="codestrong1">buf 1+ c@ .</span> 2  ok&#13;
<span class="codestrong1">buf 2 + c@ .</span> 3  ok</pre>&#13;
<p class="noindent">The first three lines store byte values 1, 2, and 3 in the first three bytes of the 1,000-byte buffer pointed to by <code>buf</code>. We’re using <code>buf</code> as an array of bytes. Continuing with the example above, try the following:</p>&#13;
<pre><span class="codestrong1">123456789 buf 3 + !</span>  ok&#13;
<span class="codestrong1">buf 1+ c@ .</span> 2  ok&#13;
<span class="codestrong1">buf 3 + @ .</span> 123456789  ok</pre>&#13;
<p class="noindent">The first line stores a 64-bit value beginning at byte 4 of <code>buf</code>. The next line shows that the second byte of <code>buf</code> is still 2, as we set it above, and the third line that there is still a 64-bit value beginning at byte 4 of the buffer.</p>&#13;
<p class="indent">Although it’s definitely possible to work with a block of memory byte by byte, it’s tedious and error prone. <a href="ch04.xhtml#ch04list4">Listing 4-4</a> shows how <code>create</code> works with <code>allot</code> and <code>does&gt;</code> to create a word that defines 1D arrays:</p>&#13;
<pre><span class="codestrong1">: bArray ( n -- )  create allot does&gt; + ;</span>  ok&#13;
<span class="codestrong1">100 bArray x</span>  ok&#13;
<span class="codestrong1">123 0 x c!</span>  ok&#13;
<span class="codestrong1">124 1 x c!</span>  ok&#13;
<span class="codestrong1">125 2 x c!</span>  ok&#13;
<span class="codestrong1">1 x c@ .</span> 124  ok&#13;
<span class="codestrong1">0 x c@ .</span> 123  ok&#13;
<span class="codestrong1">2 x c@ .</span> 125  ok</pre>&#13;
<p class="caption" id="ch04list4"><em>Listing 4-4: Defining a byte array</em></p>&#13;
<p class="indent">The first line defines <code>bArray</code>, which expects a number on the stack, which is the number of bytes to <code>allot</code>. First, <code>create</code> makes the new word and leaves the stack untouched. Next, <code>allot</code> reserves <em>n</em> bytes of dictionary space. So far, this makes sense; we saw this above. However, things get interesting when <code>does&gt;</code> is executed.</p>&#13;
<p class="indent">The word <code>bArray</code> has two parts. The first part uses <code>create</code> and <code>allot</code> to reserve dictionary space for the byte array. This happens when <code>bArray</code> is executed. However, the <code>does&gt;</code> portion is <em>not</em> executed just yet. The word <code>does&gt;</code> details what happens when a word defined by <code>bArray</code> is itself executed. Additionally, when the word is executed, it pushes its address on the stack, after which <code>does&gt;</code> the rest of the definition. Let’s walk through it.</p>&#13;
<p class="indent">The second line, <code>100 bArray x</code>, creates a byte array word, <code>x</code>. The <code>create</code> and <code>allot</code> words have executed to create <code>x</code> and reserve 100 bytes of dictionary space. When <code>x</code> itself is executed, its address is pushed on the stack, and the remainder of the definition of <code>bArray</code>, the part after <code>does&gt;</code>, is also executed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>For <code>bArray</code>, there is a plus (<code>+</code>) after <code>does&gt;</code>. The address of the word, <code>x</code>, is on the top of the stack, so the <code>+</code> adds the address to the value just below it on the stack <code>( n a -- a+n )</code>, with <em>a</em> representing the address and <em>n</em> the value below, that is, an offset. Adding an offset to a base address is precisely how almost all programming languages index into arrays stored in contiguous memory. So if we supply an index before <code>x</code>, after <code>x</code> is executed, the stack contains the address of an element in the byte array assigned to <code>x</code>. Now the <code>c!</code> and <code>c@</code> lines in <a href="ch04.xhtml#ch04list4">Listing 4-4</a> make sense: <code>125 2 x c!</code> is equivalent to <code>x[2] = 125</code> in other languages. Likewise, <code>2 x c@ .</code> is <code>print(x[2])</code>, if using Python. The combination of <code>create</code> and <code>does&gt;</code> has allowed us to create words that implement byte arrays. Excellent. But what if we want not an array of bytes, but an array of integers? The word <code>array</code> does what we want:</p>&#13;
<pre><span class="codestrong1">: array ( n -- )  create cells allot does&gt; swap cells + ;</span>  ok&#13;
<span class="codestrong1">100 array y</span>  ok&#13;
<span class="codestrong1">111111 66 y !</span>  ok&#13;
<span class="codestrong1">222222 67 y !</span>  ok&#13;
<span class="codestrong1">333333 68 y !</span>  ok&#13;
<span class="codestrong1">66 y @ .</span> 111111  ok&#13;
<span class="codestrong1">68 y @ .</span> 333333  ok&#13;
<span class="codestrong1">67 y @ .</span> 222222  ok</pre>&#13;
<p class="indent">The only difference between <code>bArray</code> and <code>array</code> is the appearance of <code>cells</code>. In Forth, the basic unit of memory is a <em>cell</em>. For gforth, a cell is 64 bits or 8 bytes. If we want an array to store 100 values, we should allocate 800 bytes. Likewise, to index the array, we need addresses that are not just the base plus the index, but the base plus the index times the size of a cell. The word <code>cells</code> expects a number on the stack and returns the number of bytes in that many cells: <code>100 cells .</code> returns <code>800</code>.</p>&#13;
<p class="indent">So adding <code>cells</code> after <code>create</code> simply calculates the number of bytes <code>allot</code> should reserve at the end of the dictionary. When we index, the part after <code>does&gt;</code>, we first convert the index from cells to bytes and add the result to the base address. That’s what <code>swap cells +</code> accomplishes. After these changes, <code>array</code> works just like <code>bArray</code>, but one should use <code>!</code> and <code>@</code> to set and get values from the array.</p>&#13;
<p class="indent">Sometimes, allocating the array isn’t all that we want. We also want to initialize it at the same time. The Forth way to do this uses a comma (<code>,</code>) or <code>c,</code>. These words compile the top stack item into the dictionary, either as a 64-bit integer or a byte. For example,</p>&#13;
<pre>create ABCDEF 65 c, 66 c, 67 c, 68 c, 69 c, 70 c,</pre>&#13;
<p class="indent">creates <code>ABCDEF</code> and allocates six values, the ASCII values for ABCDEF. The same is true if using the comma, but instead of bytes, it allocates cells (64-bit integers). These words are useful for setting up tables of constants or even arrays of words.</p>&#13;
<pre><span class="codestrong1">: one ." one" ;</span>  ok&#13;
<span class="codestrong1">: two ." two" ;</span>  ok<span epub:type="pagebreak" id="page_116"/>&#13;
<span class="codestrong1">: three ." three" ;</span>  ok&#13;
<span class="codestrong1">create tbl ' one , ' two , ' three ,</span>  ok&#13;
<span class="codestrong1">tbl 2 cells + @ execute</span> three ok&#13;
<span class="codestrong1">tbl 1 cells + @ execute</span> two ok&#13;
<span class="codestrong1">tbl @ execute</span> one ok</pre>&#13;
<p class="indent">This example introduces two new words: single quote (<code>'</code>) and <code>execute</code>. The first takes the execution address of the next token, a word, and places it on the stack. The next word, <code>execute</code>, runs the word whose execution address is on the stack. So <code>tbl</code> is an array of three “function pointers” as it were, to use C terminology. Once the proper offset to <code>tbl</code> is known, and the execution address is on the stack courtesy of <code>@</code>, <code>execute</code> calls the word.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04tab2">Table 4-2</a> summarizes the words we introduced in this section.</p>&#13;
<p class="tabcap" id="ch04tab2"><strong>Table 4-2:</strong> Forth Words for Manipulating Memory</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Word</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Effect</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>@</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a -- n )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Get the 64-bit integer at address <em>a</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>!</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( n a -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Store a 64-bit integer in address <em>a</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>,</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( n -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Compile an integer into the dictionary</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>c@</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a -- b )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Get the byte at address <em>a</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>c!</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( b a -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Store a byte in address <em>a</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>c,</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( b -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Compile a byte to the dictionary</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>create</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Create a new word</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>does&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( -- a )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Define the word’s behavior</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>allot</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( b -- )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Allocate dictionary space (bytes)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>cells</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>( n -- b )</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Convert cells to bytes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s set memory aside for now and investigate Forth’s input and output mechanisms.</p>&#13;
<h4 class="h4" id="lev2sec37"><strong><em>Input and Output</em></strong></h4>&#13;
<p class="noindent">A programming language without input or output is essentially useless. Forth, of course, has words for basic input and output, to say nothing of low-level I/O via serial and other mechanisms. We saw <code>key</code> in the <code>begin-until</code> example above. Modern Forth, like gforth, also has file access words as part of its interface to the operating system. We’ll ignore those here to save space. Additionally, we already mentioned classic Forth’s block-level disk access. Surprisingly, gforth emulates this, if desired, using a disk file as a representation of the disk itself. Therefore, if you care to explore it, gforth will let you relive the classic Forth experience.</p>&#13;
<p class="indent">We already know <code>.</code>, which prints the top stack item as a signed integer. To print the top stack value as an unsigned integer, use <code>u.</code>:</p>&#13;
<pre><span class="codestrong1">hex -aa dup . cr u. cr decimal</span> -AA &#13;
FFFFFFFFFFFFFF56</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_117"/>This example works in hexadecimal to make it easier to understand what is happening. We push <code>-0xAA</code> on the stack, duplicate it, and print it twice, once with <code>.</code> as a signed integer and again with <code>u.</code> as an unsigned integer.</p>&#13;
<p class="indent">As expected, <code>.</code> produces <code>-AA</code>. However, <code>u.</code> produces <code>FFFFFFFFFFFFFF56</code>, a large, positive number, which is the value found by interpreting the signed 64-bit binary value as a positive number.</p>&#13;
<p class="indent">Forth grew up in an age of terminals and teletypes. Therefore, it supports many words that are variations of <code>.</code> and <code>u.</code>, including words for highly structured formatting. One useful variation is <code>u.r</code>. It prints right-justified unsigned numbers <code>(n d -- )</code>, with <em>n</em> the number and <em>d</em> the width of the field. For example:</p>&#13;
<pre><span class="codestrong1">create x 10 , 100 , 1000 , 10000 , 100000 ,</span>  ok&#13;
<span class="codestrong1">: aligned cr 5 0 do  i cells x + @  6 u.r cr  loop ;</span>  ok&#13;
<span class="codestrong1">aligned</span>&#13;
    10&#13;
   100&#13;
  1000&#13;
 10000&#13;
100000</pre>&#13;
<p class="noindent">First, we create a small array, <code>x</code>, with five numbers. Next, we define <code>aligned</code> to iterate through the array using <code>u.r</code> to display each number.</p>&#13;
<p class="indent">The word <code>key</code> reads a key from the user and pushes its character code on the stack. The analogous output word is <code>emit</code>, which takes the character code on the stack and displays it.</p>&#13;
<pre><span class="codestrong1">: alpha 26 0 do  [char] A i + emit loop cr ;</span>  ok&#13;
<span class="codestrong1">alpha</span> ABCDEFGHIJKLMNOPQRSTUVWXYZ</pre>&#13;
<p class="noindent">The word <code>alpha</code> displays the alphabet using <code>emit</code> to output the characters. We’ve also introduced <code>[char]</code>, which is used during compilation to take the next character token, which here is <code>A</code>, and push its code on the stack. We could just as easily have used <code>65</code> instead of <code>[char] A</code>, as that is the ASCII code for “A.”</p>&#13;
<p class="indent">To get a string of input from the user, use <code>accept</code>, which expects two values on the stack: the address of where the string should go and the maximum number of characters to input.</p>&#13;
<pre><span class="codestrong1">create str 80 allot</span>  ok&#13;
<span class="codestrong1">str 80 accept</span> (press enter here) <span class="codestrong1">How now brown cow?</span>  ok&#13;
<span class="codestrong1">.</span> 18  ok</pre>&#13;
<p class="noindent"><code>accept</code> returns the number of characters actually entered. The buffer, <code>str</code> , now holds the text. To see it, use <code>type</code>.</p>&#13;
<pre><span class="codestrong1">str 18 type</span> How now brown cow? ok</pre>&#13;
<p class="noindent">This also expects the address and count on the stack.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>Creating a special buffer for input is a bit tedious, so Forth provides <code>pad</code>, a pre-allocated buffer of at least 84 characters (for gforth). Let’s use <code>pad</code> to learn how to input numbers instead of strings.</p>&#13;
<pre><span class="codestrong1">pad 80 accept</span> (press enter here) <span class="codestrong1">-2211333</span>  ok&#13;
<span class="codestrong1">pad swap evaluate .</span> -2211333  ok</pre>&#13;
<p class="noindent">The first line reads a character string of up to 80 characters and puts it in <code>pad</code>. Recall that <code>accept</code> returns the actual number of characters read, which is used in the next line.</p>&#13;
<p class="indent">The second line puts the address of <code>pad</code> on the stack, swaps to make the number of characters entered the top stack item, and calls <code>evaluate</code> to interpret the string as a number.</p>&#13;
<p class="indent">We could spend many more pages describing all the various, sometimes quirky, input and output options Forth provides, but the examples discussed so far are a good start.</p>&#13;
<h3 class="h3" id="lev1sec38"><strong>Square Root Redux</strong></h3>&#13;
<p class="noindent">In this section, we’ll make good on a promise made earlier in the chapter. While discussing <code>dsqr</code> above, we said we’d develop a better method for finding integer square roots. To see that we can, let’s do it now.</p>&#13;
<p class="indent"><code>dsqr</code> found the square root of an integer by testing all options to see which one was the square root. Although this approach works, it’s at first blush quite computationally inefficient. Instead, let’s try an implementation based on Equation 4.1:</p>&#13;
<div class="imagec"><img src="Images/04eqa01.jpg" alt="Image" width="406" height="65"/></div>&#13;
<p class="noindent">This equation says that the sum of the first <em>n</em> odd numbers is <em>n</em><sup>2</sup>. Therefore, if we count the number of times an increasing odd number can be subtracted from another number, we’ll have an estimate of the square root of that number.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04list5">Listing 4-5</a> implements the algorithm implied by Equation 4.1.</p>&#13;
<pre>: sqrt ( n -- sqrt[n] )&#13;
  0 &gt;r 1 swap begin&#13;
    dup 0 &gt; &#13;
  while &#13;
    over - swap 1+ 1+ swap r&gt; 1+ &gt;r &#13;
  repeat 2drop r&gt; ;</pre>&#13;
<p class="caption" id="ch04list5"><em>Listing 4-5: Integer square root in Forth</em></p>&#13;
<p class="indent">The stack contains <em>n</em>, the number whose square root is sought, and <em>x</em>, an ever-increasing odd number, first 1, then 3, 5, 7, and so on. Each iteration sets <em>n</em> ←<em>n – x</em> and <em>x</em> ←<em>x</em> + 2. When <em>n</em> is less than or equal to 0, the loop ends. To get the square root, we count the number of passes through the <span epub:type="pagebreak" id="page_119"/>loop and use the return stack to hold the counter, initializing it with <code>0 &gt;r</code> and incrementing it with <code>r&gt; 1+ &gt;r</code>. When the loop ends, <em>n</em> and <em>x</em> are dropped, and the count is returned.</p>&#13;
<p class="indent">A few examples demonstrate that <code>sqrt</code> works as advertised (with 7 as the estimated square root of 42).</p>&#13;
<pre><span class="codestrong1">25 sqrt .</span> 5  ok&#13;
<span class="codestrong1">36 sqrt .</span> 6  ok&#13;
<span class="codestrong1">42 sqrt .</span> 7  ok&#13;
<span class="codestrong1">144 sqrt .</span> 12  ok&#13;
<span class="codestrong1">152399025 sqrt .</span> 12345  ok</pre>&#13;
<p class="indent">Surely, <code>sqrt</code> is a better option than <code>dsqr</code> from <a href="ch04.xhtml#ch04list2">Listing 4-2</a>. Let’s set up a test and see. The code we want is in the <em>examples</em> directory in the file <em>sqrt.4th</em>.</p>&#13;
<pre>( Park and Miller PRNG )&#13;
variable seed  8675309 seed ! ( default seed )&#13;
: rand ( -- n ) 48271 seed @ * 2147483647 mod  dup seed ! ;&#13;
: random ( m -- n ) rand swap mod ;&#13;
&#13;
( Time to find the square root by method )&#13;
variable x&#13;
utime drop dup seed ! x ! ( keep seed )&#13;
&#13;
: run0 ( -- ) 100000 0 do  1000 random 1+ dup * sqrt drop  loop ;&#13;
: run1 ( -- ) 100000 0 do  1000 random 1+ dup * dsqr drop  loop ;&#13;
&#13;
: main ( -- )&#13;
  utime  run0  utime 2swap d- d. cr&#13;
  x @ seed !  ( use the same sequence )&#13;
  utime  run1  utime 2swap d- d. cr ;&#13;
&#13;
main  bye</pre>&#13;
<p class="caption" id="ch04list6"><em>Listing 4-6: Testing <span class="codeitalic1">sqrt</span> and <span class="codeitalic1">dsqr</span></em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04list6">Listing 4-6</a> presents the relevant portion of <em>sqrt.4th</em>. The file first defines <code>sqrt</code> and <code>dsqr</code> (not shown) before defining a simple 32-bit linear congruential pseudorandom number generator. The word <code>random</code> takes an upper limit, which is never returned, and replies with a random integer in the range [0, <em>n</em>).</p>&#13;
<p class="indent">Gforth uses <code>utime</code> to return a double-precision (128-bit) time value, the lower 64 bits of which become the seed for the random number generator. A copy of the seed is kept in <code>X</code> as well so we can repeat the sequence later.</p>&#13;
<p class="indent">Two short words come next: <code>run0</code> and <code>run1</code>. Both calculate the square root of 100,000 random values in [1,10<sup>6</sup>], each of which is a perfect square. We don’t actually want the answers; we’re only interested in how long the calculation takes, so each square root is immediately discarded (<code>drop</code>). Next, <code>run0</code> uses <code>sqrt</code> and <code>run1</code> uses <code>dsqr</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>The <code>main</code> word grabs the start time, leaving it on the stack, calls <code>run0</code>, and prints the time it takes to run in microseconds (<code>2swap d- d.</code>). It then resets the pseudorandom seed and repeats the calculation using <code>run1</code>.</p>&#13;
<p class="indent">Executing <em>sqrt.4th</em> 10 times (<code>gforth sqrt.4th</code>) gives us the following mean runtimes for the two square root methods.</p>&#13;
<pre>SQRT: 0.7457714&#13;
DSQR: 0.4978122</pre>&#13;
<p class="noindent">Time is now in seconds. Clearly, our intuition was incorrect. The more elegant algorithm takes about 1.5 times longer to execute, on average, than the brute-force method. This reminds me of physicist Ludwig Boltzmann’s famous quote: “If you are out to describe the truth, leave elegance to the tailor.” In this case, elegance loses out to raw computing power. It is simply faster to check all possibilities compared to the number of calculations and stack manipulations necessary to implement the subtraction method.</p>&#13;
<p class="indent">Is this the final word, though? There is one more algorithm we can try: Newton’s method. Newton’s method finds the roots of equations, the values of <em>x</em> that make the equation zero. If the equation is <em>x</em><sup>2</sup> <em>– n</em>, then it’s clear this equation is zero when <img src="Images/f00120.jpg" alt="Image" width="50" height="16"/>.</p>&#13;
<p class="indent">Newton’s method is iterative based on an initial guess. It is powerful and converges quickly. Equation 4.2 shows us how to iterate with</p>&#13;
<div class="imagec"><img src="Images/04eqa02.jpg" alt="Image" width="449" height="50"/></div>&#13;
<p class="noindent">for some initial guess, <em>x</em><sub>0</sub> = <em>n</em>/2.</p>&#13;
<p class="indent">The code we need, also in <em>sqrt.4th</em>, is</p>&#13;
<pre>: step ( n xi -- n xi x_{i+1} )  &#13;
  2dup dup rot swap dup 0= if 2drop else / + then 2/ ;&#13;
: newton ( n -- sqr[n] )&#13;
  dup 2/ step begin 2dup swap &lt; while nip step repeat drop nip ;</pre>&#13;
<p class="indent">The word <code>step</code> performs one update step (Equation 4.2) with <em>n</em> and <em>x</em><sub><em>i</em></sub> on the stack as input and <em>n</em>, <em>x</em><sub><em>i</em></sub>, <em>x</em><sub><em>i</em>+1</sub> as output. The <code>if</code> handles things if <em>x</em><sub><em>i</em></sub> is 0.</p>&#13;
<p class="indent"><code>newton</code> performs the iterations for as long as <em>x</em><sub><em>i</em>+1</sub> &lt; <em>x</em><sub><em>i</em></sub>. The first <code>dup 2/</code> sets the initial guess, <em>x</em><sub>0</sub>. The body of the loop keeps <em>x</em><sub><em>i</em>+1</sub> as the new <em>x</em><sub><em>i</em></sub> and then takes another step. After the loop, the last <em>x</em><sub><em>i</em>+1</sub> is dropped, along with <em>n</em>, leaving only <em>x</em><sub><em>i</em></sub> as the answer.</p>&#13;
<p class="indent">Running <code>newton</code> 10 times lets us complete our list of average runtimes.</p>&#13;
<pre>SQRT:   0.7457714&#13;
DSQR:   0.4978122&#13;
NEWTON: 0.0493205</pre>&#13;
<p class="indent">We have a clear winner. Newton’s method is, on average, an order of magnitude faster than the brute force method. Boltzmann is wrong in this case; elegance and truth do go together.</p>&#13;
<h3 class="h3" id="lev1sec39"><span epub:type="pagebreak" id="page_121"/><strong>Discussion</strong></h3>&#13;
<p class="noindent">What should we make of Forth? It’s definitely a curious language, but with its own charm. However, it seems best suited to a computing environment that is largely bygone. Figuring out how to manipulate the stack to accomplish what can be done in a simple statement or two in other languages is both frustrating and rewarding, but not particularly practical for day-to-day use. Forth’s learning curve is rather high, though experts can do amazing things with it.</p>&#13;
<p class="indent">Because the code can be difficult to read, Forth is often characterized as a “write-only” programming language. Expert practitioners will disagree, and strict adherence to Forth style guidelines might mitigate some of the effects, but the charge is not without merit.</p>&#13;
<p class="indent">Back in the Introduction, you can see <a href="ch00.xhtml#ch00fig1">Figure 1</a>, which shows a functional brain imaging system I wrote in Forth for the Macintosh nearly 25 years ago. It worked well, and I used it often. Now, some 25 years later, thanks to the power of open source emulators like BasiliskII, I was able to run the code and pull out the source. Here’s the code for accessing a single pixel of what amounts to a 3D block of data, a time series of magnetic resonance images.</p>&#13;
<pre>: }Pixel ( x y z -- n )&#13;
  ( Return value of x,y pixel in image z of current slice )&#13;
  rot matsize @ m* zTmp 2! swap s&gt;d zTmp 2@ d+ 2dup d+ zTmp 2!&#13;
  s&gt;d d&gt;f imgsz 2@ d&gt;f f* f&gt;d  ( z*image_size )&#13;
  zTmp 2@ d+  ( offset into slice )&#13;
  slcoff 2@ d+  ( slice offset )&#13;
  mem 2@ dl@ d+ l@ ;  ( fetch pixel value )</pre>&#13;
<p class="noindent">I agree that this probably deserves the label of write-only code. The comments explain what is happening, but I doubt anyone would say it’s easy to read. For comparison purposes, here’s how to do the same thing in Python with NumPy: <code>n = images[z,x,y]</code>.</p>&#13;
<p class="indent">Lest readers think me unfair in my criticism, I still use Forth for different projects, usually to simulate the small microcontrollers that a larger system communicates with via RS-232 serial. Forth works well in this case, even on old Apple II computers.</p>&#13;
<p class="indent">The Forth words of this chapter took time and some effort with pen and paper to work out. However, that adds to the charm of achieving success with the language, even as it subtracts from the practical utility.</p>&#13;
<p class="indent">Forth’s popularity has definitely waned in recent years. However, the embedded development world still holds a place for Forth. There are small, single-board computers that run Forth as well as C, but they are few and far between. Increasingly, the embedded world is moving to tiny computers supporting more modern languages. Later in this book, for example, we’ll use the BBC micro:bit, which uses Python as its primary language, though hobbyists have developed a version of Forth that runs on the micro:bit. Full-blown Linux environments for small boards, like the Raspberry Pi Zero and BeagleBoard, are common. The world that motivated the development of Forth has changed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>So why consider Forth?</p>&#13;
<p class="indent">Because Forth is a perfect exemplar for what this book intends to present to you: an opportunity to look at programming in a new light.</p>&#13;
<p class="indent">To succeed with Forth, you must think not only at the higher level of algorithm, though that is still necessary, but also at the lower level of <em>how</em> each algorithm step can be implemented, in minute detail.</p>&#13;
<p class="indent">Forth is close to what the computer is doing and not abstracted away from it like Python or Java. Bytes, addresses, order of operations on a stack, and how much limited dictionary memory is available all require a different kind of thinking, a more parsimonious approach to programming.</p>&#13;
<p class="indent">Those bitten by the Forth bug seldom recover. I recall many times reading posts on the old comp.lang.forth newsgroup (remember those?) that were almost spiritual in their expression of the joy one might feel when working with Forth. A tad excessive, perhaps, but there is definitely a joy to using Forth. Please do continue to play with the language.</p>&#13;
<h3 class="h3" id="lev1sec40"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter introduced Forth, a unique language with a long history. We explored the language, how it works, its programming model, and its philosophy. We looked at some examples and saw that Forth is often implemented in Forth, building itself by pulling itself up by its bootstraps.</p>&#13;
<p class="indent">Thinking in Forth takes time and effort. Indeed, <em>Thinking FORTH</em> is the name of a classic Forth text by Leo Brodie (<em><a href="http://thinking-forth.sourceforge.net/">http://thinking-forth.sourceforge.net/</a></em>). Take a look. If you want, you might also take a gander at Brodie’s <em>Starting FORTH</em> (<em><a href="http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf">http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf</a></em>). Between these two books, you’ll get a thorough understanding of what it means to work with Forth.</p>&#13;
<p class="indent">Now, it’s time for something completely different. We leave the low-level world of Forth behind and move into the oddly wonderful world of text processing with SNOBOL.</p>&#13;
</div></body></html>