["```\n\n     FUSES      = -U lfuse:w:0xff:m -U hfuse:w:0xde:m -U efuse:w:0x05:m\n\n```", "```\n\n       void I2Cenable()\n\n       {\n\n       TWBR = 72;           // 100 kHz I2C bus\n\n       TWCR |= (1 << TWEN); // Enable I2C on PORTC4 and 5\n\n       }\n\n```", "```\n\n       void I2Cwait()\n\n       {\n\n       while (!(TWCR & (1<<TWINT)));\n\n       }\n\n```", "```\n\n       void I2CstartWait(unsigned char address)\n\n       {\n\n       uint8_t status;\n\n       while (1)\n\n       {\n\n       ❶ TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\n\n       ❷ I2Cwait();\n\n       ❸ status = TWSR & 0b11111000;\n\n       if ((status != 0b00001000) && (status != 0b00010000)) continue;\n\n       ❹ TWDR = address;\n\n       TWCR = (1<<TWINT) | (1<<TWEN);\n\n       I2Cwait();\n\n       ❺ status = TWSR & 0b11111000;\n\n       if ((status == 0b00100000)||(status == 0b01011000))\n\n       {\n\n       ❻ TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);\n\n       while(TWCR & (1<<TWSTO));\n\n       continue;\n\n       }\n\n       break;\n\n       }\n\n       }\n\n```", "```\n\n       void I2Cwrite(uint8_t data)\n\n       {\n\n       TWDR = data;\n\n       TWCR |= (1 << TWINT)|(1 << TWEN);\n\n       I2Cwait();\n\n       }\n\n```", "```\n\n       void I2Cstop()\n\n       {\n\n       TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWSTO);\n\n       }\n\n```", "```\n\n      // Project 49 - Using the MCP23017 16-Bit I/O Expander\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      void I2Cenable()\n\n      // Enable the I2C bus\n\n      {\n\n      TWBR = 72;           // 100 kHz I2C bus\n\n      TWCR |= (1 << TWEN); // Enable I2C on PORTC4 and 5\n\n      }\n\n      void I2Cwait()\n\n      // Wait until I2C finishes an operation\n\n      {\n\n      // Wait until bit TWINT in TWCR is set to 1\n\n      while (!(TWCR & (1<<TWINT)));\n\n      }\n\n      void I2CstartWait(unsigned char address)\n\n      {\n\n      uint8_t status;\n\n      while (1)\n\n      {\n\n      // Send START condition\n\n      TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status != 0b00001000) && (status != 0b00010000)) continue;\n\n      // Send device address\n\n      TWDR = address;\n\n      TWCR = (1<<TWINT) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status == 0b00100000 )||(status == 0b01011000))\n\n      {\n\n      // Secondary device is busy, send stop to terminate write operation\n\n      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);\n\n      // Wait until stop condition is executed and I2C bus is released\n\n      while(TWCR & (1<<TWSTO));\n\n      continue;\n\n      }\n\n      break;\n\n      }\n\n      }\n\n      void I2Cstop()\n\n      // Stop I2C bus and release GPIO pins\n\n      {\n\n      // Clear interrupt, enable I2C, generate stop condition\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWSTO);\n\n      }\n\n      void I2Cwrite(uint8_t data)\n\n      // Send ′data′ to I2C bus\n\n      {\n\n      TWDR = data;\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      }\n\n      ❶ void initMCP23017()\n\n      // Configure MCP23017 ports for all outputs\n\n      {\n\n      I2CstartWait(0x20<<1); // 0x20 write mode\n\n      I2Cwrite(0x00);        // IODIRA register\n\n      I2Cwrite(0x00);        // Set all register A to outputs\n\n      I2Cstop();\n\n      I2CstartWait(0x20<<1); // 0x20 write mode\n\n      I2Cwrite(0x01);        // IODIRB register\n\n      I2Cwrite(0x00);        // Set all register B to outputs\n\n      I2Cstop();\n\n      }\n\n      int main(void)\n\n      {\n\n      uint8_t i;\n\n      ❷ I2Cenable();\n\n      initMCP23017();\n\n      while (1)\n\n      {\n\n      for (i = 0; i< 256; i++)\n\n      {\n\n      ❸ I2CstartWait(0x20<<1);\n\n      ❹ I2Cwrite(0x12);  // Control register A 0x12\n\n      ❺ I2Cwrite(i);     // Value to send\n\n      ❻ I2Cstop();\n\n      I2CstartWait(0x20<<1);\n\n      ❼ I2Cwrite(0x13);  // Control register B 0x13\n\n      ❽ I2Cwrite(i);     // Value to send\n\n      ❾ I2Cstop();\n\n      _delay_ms(100);\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n     I2CstartWait(\n     `address` \n     );\n\n```", "```\n\n     uint8_t I2Cread()\n\n     {\n\n     TWCR |= (1 << TWINT)|(1 << TWEN);\n\n     I2Cwait();\n\n     // Incoming byte is placed in TWDR register\n\n     return TWDR;\n\n     }\n\n```", "```\n\n     uint8_t I2CreadACK()\n\n     {\n\n     TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWEA);\n\n     I2Cwait();\n\n     // Incoming byte is placed in TWDR register\n\n     return TWDR;\n\n     }\n\n```", "```\n\n      // Project 50 - 24LC512 I2C EEPROM\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      void I2Cenable()\n\n      // Enable I2C bus\n\n      {\n\n      TWBR = 72;           // 100 kHz I2C bus\n\n      TWCR |= (1 << TWEN); // Enable I2C on PORTC4 and 5\n\n      }\n\n      void I2Cwait()\n\n      // Wait until I2C finishes an operation\n\n      {\n\n      // Wait until bit TWINT in TWCR is set to 1\n\n      while (!(TWCR & (1<<TWINT)));\n\n      }\n\n      void I2CstartWait(unsigned char address)\n\n      {\n\n      uint8_t status;\n\n      while (1)\n\n      {\n\n      // Send START condition\n\n      TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status != 0b00001000) && (status != 0b00010000)) continue;\n\n      // Send device address\n\n      TWDR = address;\n\n      TWCR = (1<<TWINT) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status == 0b00100000 )||(status == 0b01011000))\n\n      {   // Secondary device is busy, so send stop condition to terminate\n\n      // write operation\n\n      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);\n\n      // Wait until stop condition is executed and I2C bus released\n\n      while(TWCR & (1<<TWSTO));\n\n      continue;\n\n      }\n\n      break;\n\n      }\n\n      }\n\n      void I2Cstop()\n\n      // Stop I2C bus and release GPIO pins\n\n      {\n\n      // Clear interrupt, enable I2C, generate stop condition\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWSTO);\n\n      }\n\n      void I2Cwrite(uint8_t data)\n\n      // Send ′data′ to I2C bus\n\n      {\n\n      TWDR = data;\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      }\n\n      uint8_t I2Cread()\n\n      // Read incoming byte of data from I2C bus\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      uint8_t I2CreadACK()\n\n      // Read incoming byte of data from I2C bus and ACK signal\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWEA);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      void writeMAX7219(char hexdata1, char hexdata2)\n\n      // Sends two bytes in hexadecimal to MAX7219\n\n      {\n\n      PORTB &= ~(1 << PORTB0);    // SS pin LOW\n\n      SPDR = hexdata1;            // Send value of hexdata1\n\n      while(!(SPSR & (1<<SPIF))); // Wait for SPI transmission to finish\n\n      SPDR = hexdata2;            // Send value of hexdata2\n\n      while(!(SPSR & (1<<SPIF))); // Wait for SPI transmission to finish\n\n      PORTB |= (1 << PORTB0);     // SS pin HIGH\n\n      }\n\n      void blankMAX7219()\n\n      // Blanks all digits\n\n      {\n\n      uint8_t i;\n\n      for (i=1; i<9; i++)         // Blank all digits\n\n      {\n\n      writeMAX7219(i,15);\n\n      }\n\n      }\n\n      void initMAX7219()\n\n      // Set up MAX7219 for use\n\n      {\n\n      PORTB |= (1 << 0);          // SS pin HIGH\n\n      SPCR = (1<<SPE)|(1<<MSTR);  // Set up SPI bus for MAX7219\n\n      // Mode decode for digits (table 4 page 7 - 0x09 + 0xFF)\n\n      writeMAX7219(0x09,0xFF);\n\n      writeMAX7219(0x0B,0x07);    // Set scan limit to 8 digits - 0x09 + 0xFF)\n\n      writeMAX7219(0x0A,0x01);    // Set intensity to 8 - 0x0A + 0x08)\n\n      // Mode display on (table 4 page 7 - 0x09 + 0xFF)\n\n      writeMAX7219(0x0C,0x01);\n\n      blankMAX7219();\n\n      }\n\n      void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)\n\n      // Displays \"number\" in location \"digit\" with decimal point on/off\n\n      // Digit: 1~8 for location 1~8\n\n      // Number: 0~15 for 0~9, - E, H, L, P, blank\n\n      // dp: 1 on, 0 off\n\n      {\n\n      if (dp==1)                       // Add decimal point\n\n      {\n\n      number = number + 128;\n\n      }\n\n      writeMAX7219(digit, number);\n\n      }\n\n      void numberMAX7219(uint32_t value)\n\n      // Displays a number between 0–99999999 on MAX7219-controlled 8-digit display\n\n      {\n\n      uint8_t digits[8];\n\n      uint8_t i = 1;\n\n      for (i=1; i<9; i++)\n\n      {\n\n      digits[i]=15;\n\n      }\n\n      i = 1;\n\n      while (value > 0)                // Continue until value > 0\n\n      {  // Determine and store last digit of number\n\n      digits[i] = value % 10;\n\n      value = value / 10;           // Divide value by 10\n\n      i++;\n\n      }\n\n      for (i=1; i<9; i++)\n\n      {\n\n      dispMAX7219(i, digits[i],0);\n\n      }\n\n      }\n\n      int main(void)\n\n      {\n\n      uint16_t i;\n\n      uint16_t j;\n\n      DDRB = 0b11111111;               // Set PORTB as outputs\n\n      I2Cenable();\n\n      initMAX7219();\n\n      while (1)\n\n      {\n\n      dispMAX7219(0,10,0);\n\n      for (i = 0; i<256; i++)       // Write loop\n\n      {\n\n      ❶ I2CstartWait(0x50<<1);     // 0x50 << 1 - 0b10100000\n\n      ❷ I2Cwrite(i >> 8);\n\n      ❸ I2Cwrite(i);\n\n      ❹ I2Cwrite(i);\n\n      I2Cstop();\n\n      numberMAX7219(i);\n\n      _delay_ms(1);\n\n      }\n\n      for (i = 0; i<256; i++)       // Read loop\n\n      {\n\n      ❺ I2CstartWait(0x50<<1);     // Write address\n\n      ❻ I2Cwrite(i >> 8);\n\n      ❼ I2Cwrite(i);\n\n      ❽ I2CstartWait((0x50<<1)+1); // Read address - 0b10100001\n\n      ❾ j = I2Cread();\n\n      ⓿ I2Cstop();\n\n      numberMAX7219(j);\n\n      _delay_ms(5);\n\n      }\n\n      _delay_ms(100);\n\n      }\n\n      }\n\n```", "```\n\n      setTimeDS3231(14,32,0,3,6,11,22);\n\n```", "```\n\n      // Project 51 - Using the DS3231 I2C Real-Time Clock\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      // Variables to store time and date\n\n      ❶ uint8_t hours, minutes, seconds, dow, dom, mo, years;\n\n      void I2Cenable()\n\n      // Enable I2C bus\n\n      {\n\n      TWBR = 72;           // 100 kHz I2C bus\n\n      TWCR |= (1 << TWEN); // Enable I2C on PORTC4 and 5\n\n      }\n\n      void I2Cwait()\n\n      // Wait until I2C finishes an operation\n\n      {\n\n      // Wait until bit TWINT in TWCR is set to 1\n\n      while (!(TWCR & (1<<TWINT)));\n\n      }\n\n      void I2CstartWait(unsigned char address)\n\n      {\n\n      uint8_t status;\n\n      while (1)\n\n      {\n\n      // Send START condition\n\n      TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status != 0b00001000) && (status != 0b00010000)) continue;\n\n      // Send device address\n\n      TWDR = address;\n\n      TWCR = (1<<TWINT) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status == 0b00100000 )||(status == 0b01011000))\n\n      {\n\n      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);\n\n      // Wait until stop condition is executed and I2C bus is released\n\n      while(TWCR & (1<<TWSTO));\n\n      continue;\n\n      }\n\n      break;\n\n      }\n\n      }\n\n      void I2Cstop()\n\n      // Stop I2C bus and release GPIO pins\n\n      {\n\n      // Clear interrupt, enable I2C, generate stop condition\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWSTO);\n\n      }\n\n      void I2Cwrite(uint8_t data)\n\n      // Send 'data' to I2C bus\n\n      {\n\n      TWDR = data;\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      }\n\n      uint8_t I2Cread()\n\n      // Read incoming byte of data from I2C bus\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      uint8_t I2CreadACK()\n\n      // Read incoming byte of data from I2C bus and ACK signal\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWEA);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      void writeMAX7219(char hexdata1, char hexdata2)\n\n      // Sends two bytes in hexadecimal to MAX7219\n\n      {\n\n      PORTB &= ~(1 << PORTB0);      // SS pin LOW\n\n      SPDR = hexdata1;              // Send value of hexdata1\n\n      while(!(SPSR & (1<<SPIF)));   // Wait for SPI transmission to finish\n\n      SPDR = hexdata2;              // Send value of hexdata2\n\n      while(!(SPSR & (1<<SPIF)));   // Wait for SPI transmission to finish\n\n      PORTB |= (1 << PORTB0);       // SS pin HIGH\n\n      }\n\n      void blankMAX7219()\n\n      // Blanks all digits\n\n      {\n\n      uint8_t i;\n\n      for (i=1; i<9; i++)           // Blank all digits\n\n      {\n\n      writeMAX7219(i,15);\n\n      }\n\n      }\n\n      void initMAX7219()\n\n      // Set up MAX7219 for use\n\n      {\n\n      PORTB |= (1 << 0);            // SS pin HIGH (SS)\n\n      SPCR = 0b01010000;            // Set up SPI bus for MAX7219\n\n      // Mode decode for digits (table 4 page 7 - 0x09 + 0xFF\n\n      writeMAX7219(0x09,0xFF);\n\n      writeMAX7219(0x0B,0x07);      // Set scan limit to 8 digits - 0x09 + 0xFF)\n\n      writeMAX7219(0x0A,0x01);      // Set intensity to 8 - 0x0A + 0x08)\n\n      // Mode display on (table 4 page 7 - 0x09 + 0xFF)\n\n      writeMAX7219(0x0C,0x01);\n\n      blankMAX7219();\n\n      }\n\n      void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)\n\n      // Displays \"number\" in location \"digit\" with decimal point on/off\n\n      // Digit: 1~8 for location 1~8\n\n      // Number: 0~15 for 0~9, - E, H, L, P, blank\n\n      // dp: 1 on, 0 off\n\n      {\n\n      if (dp==1)                   // Add decimal point\n\n      {\n\n      number = number + 128;\n\n      }\n\n      writeMAX7219(digit, number);\n\n      }\n\n      void numberMAX7219(uint32_t value)\n\n      // Displays a number between 0–99999999 on MAX7219-controlled 8-digit display\n\n      {\n\n      uint8_t digits[8];\n\n      uint8_t i = 1;\n\n      for (i=1; i<9; i++)\n\n      {\n\n      digits[i]=15;\n\n      }\n\n      i = 1;\n\n      while (value > 0)            // Continue until value > 0\n\n      {\n\n      // Determine and store last digit of number\n\n      digits[i] = value % 10;\n\n      value = value / 10;        // Divide value by 10\n\n      i++;\n\n      }\n\n      for (i=1; i<9; i++)\n\n      {\n\n      dispMAX7219(i, digits[i],0);\n\n      }\n\n      }\n\n      ❷ uint8_t decimalToBcd(uint8_t val)\n\n      // Convert integer to BCD\n\n      {\n\n      return((val/10*16)+(val%10));\n\n      }\n\n      uint8_t bcdToDec(uint8_t val)\n\n      // Convert BCD to integer\n\n      {\n\n      return((val/16*10)+(val%16));\n\n      }\n\n      ❸ void setTimeDS3231(uint8_t hh, uint8_t mm, uint8_t ss, uint8_t dw,\n\n      uint8_t dd, uint8_t mo, uint8_t yy)\n\n      // Set the time on DS3231\n\n      {\n\n      I2CstartWait(0xD0);           // DS3231 write\n\n      I2Cwrite(0x00);               // Start with seconds register\n\n      I2Cwrite(decimalToBcd(ss));   // Seconds\n\n      I2Cwrite(decimalToBcd(mm));   // Minutes\n\n      I2Cwrite(decimalToBcd(hh));   // Hours\n\n      I2Cwrite(decimalToBcd(dw));   // Day of week\n\n      I2Cwrite(decimalToBcd(dd));   // Date\n\n      I2Cwrite(decimalToBcd(mo));   // Month\n\n      I2Cwrite(decimalToBcd(yy));   // Year\n\n      I2Cstop();\n\n      }\n\n      ❹ void readTimeDS3231()\n\n      // Retrieve time and date from DS3231\n\n      {\n\n      I2CstartWait(0xD0);           // DS3231 write\n\n      I2Cwrite(0x00);               // Seconds register\n\n      I2CstartWait(0xD1);           // DS3231 read\n\n      seconds = bcdToDec(I2CreadACK());\n\n      minutes = bcdToDec(I2CreadACK());\n\n      hours = bcdToDec(I2CreadACK());\n\n      dow = bcdToDec(I2CreadACK());\n\n      dom = bcdToDec(I2CreadACK());\n\n      mo = bcdToDec(I2CreadACK());\n\n      years = bcdToDec(I2CreadACK());\n\n      }\n\n      ❺ void displayTimeMAX7219()\n\n      // Display time then date on MAX7219 module\n\n      {\n\n      blankMAX7219();\n\n      readTimeDS3231();\n\n      // Display seconds\n\n      if (seconds == 0)\n\n      {  // Display '00'\n\n      dispMAX7219(1,0,0);\n\n      dispMAX7219(2,0,0);\n\n      } else if (seconds >0 && seconds <10)\n\n      {  // Display leading zero\n\n      dispMAX7219(1,seconds,0);\n\n      dispMAX7219(2,0,0);\n\n      } else\n\n      {  // Seconds > 10\n\n      numberMAX7219(seconds);\n\n      }\n\n      dispMAX7219(3,10,0);          // Display a dash\n\n      // Display minutes\n\n      if (minutes == 0)\n\n      {  // Display '00'\n\n      dispMAX7219(4,0,0);\n\n      dispMAX7219(5,0,0);\n\n      } else if (minutes >0 && minutes <10)\n\n      {  // Display leading zero\n\n      dispMAX7219(4,minutes,0);\n\n      dispMAX7219(5,0,0);\n\n      } else\n\n      {  // Minutes > 10\n\n      dispMAX7219(4,(minutes % 10),0);\n\n      dispMAX7219(5,(minutes / 10),0);\n\n      }\n\n      dispMAX7219(6,10,0);          // Display a dash\n\n      // Display hours\n\n      if (hours == 0)\n\n      {  // Display '00'\n\n      dispMAX7219(7,0,0);\n\n      dispMAX7219(8,0,0);\n\n      } else if (hours >0 && hours <10)\n\n      {  // Display leading zero\n\n      dispMAX7219(7,hours,0);\n\n      dispMAX7219(8,0,0);\n\n      } else\n\n      {  // Hours > 10\n\n      dispMAX7219(7,(hours % 10),0);\n\n      dispMAX7219(8,(hours / 10),0);\n\n      }\n\n      _delay_ms(1000);\n\n      // Display date\n\n      if (dom >0 && dom <10)\n\n      {  // Display leading zero\n\n      dispMAX7219(7,dom,0);\n\n      dispMAX7219(8,0,0);\n\n      } else\n\n      {  // Seconds > 10\n\n      dispMAX7219(8,(dom / 10), 0);\n\n      dispMAX7219(7,(dom % 10), 0);\n\n      }\n\n      dispMAX7219(6,10,0);                // Display a dash\n\n      // Display month\n\n      if (mo >0 && mo <10)\n\n      {  // Display leading zero\n\n      dispMAX7219(4,mo,0);\n\n      dispMAX7219(5,0,0);\n\n      } else\n\n      {  // Seconds > 10\n\n      dispMAX7219(5,(mo / 10), 0);\n\n      dispMAX7219(4,(mo % 10), 0);\n\n      }\n\n      dispMAX7219(3,10,0);                // Display a dash\n\n      // Display year\n\n      if (years == 0)\n\n      {   // Display '00'\n\n      dispMAX7219(1,0,0);\n\n      dispMAX7219(2,0,0);\n\n      } else\n\n      if (years >0 && years <10)\n\n      {  // Display leading zero\n\n      dispMAX7219(1,years,0);\n\n      dispMAX7219(2,0,0);\n\n      } else\n\n      {  // Years > 10\n\n      dispMAX7219(2,(years / 10), 0);\n\n      dispMAX7219(1,(years % 10), 0);\n\n      }\n\n      _delay_ms(1000);\n\n      }\n\n      int main(void)\n\n      {\n\n      DDRB = 0b11111111;                  // Set PORTB as outputs\n\n      I2Cenable();\n\n      initMAX7219();\n\n      // Uncomment to set time and date, then comment and reflash code\n\n      // setTimeDS3231(9,13,0,5,29,4,21); // h,m,s,dow,dom,m,y\n\n      while (1)\n\n      {\n\n      ❻ displayTimeMAX7219();\n\n      _delay_ms(250);\n\n      }\n\n      }\n\n```"]