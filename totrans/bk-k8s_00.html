<html><head></head><body>
<h2 class="h2" id="ch00"><span epub:type="pagebreak" id="page_xix"/>INTRODUCTION</h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Containers and Kubernetes together are changing the way that applications are architected, developed, and deployed. Containers ensure that software runs reliably no matter where it’s deployed, and Kubernetes lets you manage all of your containers from a single control plane.</p>&#13;
<p class="indent">This book is designed to help you take full advantage of these essential new technologies, using hands-on examples not only to try out the major features but also to explore how each feature works. In this way, beyond simply being ready to deploy an application to Kubernetes, you’ll gain the skills to architect applications to be performant and reliable in a Kubernetes cluster, and to quickly diagnose problems when they arise.</p>&#13;
<h3 class="h3" id="ch00lev1sec1">The Approach</h3>&#13;
<p class="noindent">The biggest advantage of a Kubernetes cluster is that it hides the work of running containers across multiple hosts behind an abstraction layer. A Kubernetes cluster is a “black box” that runs what we tell it to run, with automatic scaling, failover, and upgrades to new versions of our application.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xx"/>Even though this abstraction makes it easier to deploy and manage applications, it also makes it difficult to understand what a cluster is doing. For this reason, this book presents each feature of container runtimes and Kubernetes clusters from a “debugging” perspective. Every good debugging session starts by treating the application as a black box and observing its behavior, but it doesn’t end there. Skilled problem solvers know how to open the black box, diving below the current abstraction layer to see how the program runs, how data is stored, and how traffic flows across the network. Skilled architects use this deep knowledge of a system to avoid performance and reliability issues. This book provides the detailed understanding of containers and Kubernetes that only comes from exploring not only what these technologies do but also how they work.</p>&#13;
<p class="indent">In <a href="part01.xhtml#part01">Part I</a>, we’ll begin by running a container, but then we’ll dive into the container runtime to understand what a container is and how we can simulate a container using normal operating system commands. In <a href="part02.xhtml#part02">Part II</a>, we’ll install a Kubernetes cluster and deploy containers to it. We’ll also see how the cluster works, including how it interacts with the container runtime and how packets flow from container to container across the host network. The purpose is not to duplicate the reference documentation to show every option offered by every feature but to demonstrate how each feature is implemented so that all that documentation will make sense and be useful.</p>&#13;
<p class="indent">A Kubernetes cluster is complicated, so this book includes extensive hands-on examples, with enough automation to allow you to explore each chapter independently. This automation, which is available at <em><a href="https://github.com/book-of-kubernetes/examples">https://github.com/book-of-kubernetes/examples</a></em>, is published under a permissive open source license, so you can explore, experiment, and use it in your own projects.</p>&#13;
<h3 class="h3" id="ch00lev1sec2">Running Examples</h3>&#13;
<p class="noindent">In many of this book’s example exercises, you’ll be combining multiple hosts together to make a cluster, or working with low-level features of the Linux kernel. For this reason, and to help you feel more comfortable with experimentation, you’ll be running examples entirely on temporary virtual machines. That way, if you make a mistake, you can quickly delete the virtual machine and start over.</p>&#13;
<p class="indent">The example repository for this book is available at <em><a href="https://github.com/book-of-kubernetes/examples">https://github.com/book-of-kubernetes/examples</a></em>. All of the instructions for setting up to run examples are provided in a <em>README.md</em> file within the <em>setup</em> folder of the example repository.</p>&#13;
<h4 class="h4" id="ch00lev2sec1">What You Will Need</h4>&#13;
<p class="noindent">Even though you’ll be working in virtual machines, you’ll need a control machine to start from that can run Windows, macOS, or Linux. It can even be a Chromebook that supports Linux. If you are running Windows, you’ll need to use the Windows Subsystem for Linux (WSL) in order to get Ansible working. See the <em>README.md</em> in the <em>setup</em> folder for instructions.</p>&#13;
<h4 class="h4" id="ch00lev2sec2"><span epub:type="pagebreak" id="page_xxi"/>Run in the Cloud or Local</h4>&#13;
<p class="noindent">To make these examples as accessible as possible, I’ve provided automation to run them either using Vagrant or Amazon Web Services (AWS). If you have access to a Windows, macOS, or Linux computer with at least eight cores and 8GB of memory, try installing VirtualBox and Vagrant and work with local virtual machines. If not, you can set yourself up to work with AWS.</p>&#13;
<p class="indent">We use Ansible to perform AWS setup and automate some of the tedious steps. Each chapter includes a separate Ansible playbook that makes use of common roles and collections. This means that you can work examples from chapter to chapter, starting with a fresh installation each time. In some cases, I’ve also provided an “extra” provisioning playbook that you can optionally use to skip some of the detailed installation steps and get straight to the learning. See the <em>README.md</em> in each chapter’s directory for more information.</p>&#13;
<h4 class="h4" id="ch00lev2sec3">Terminal Windows</h4>&#13;
<p class="noindent">After you’ve used Ansible to provision your virtual machines, you’ll need to get at least one terminal window connected to run commands. The <em>README.md</em> file in each chapter will tell you how to do that. Before running any examples, you’ll first need to become the root user, as follows:</p>&#13;
<pre><span class="codestrong1">sudo su -</span></pre>&#13;
<p class="indent">This will give you a root shell and set up your environment and home directory to match.</p>&#13;
<div class="box5">&#13;
<p class="boxtitle-d"><strong>RUNNING AS ROOT</strong></p>&#13;
<p class="noindents">If you’ve worked with Linux before, you probably have a healthy aversion to working as root on a regular basis, so it might surprise you that all of the examples in this book are run as the root user. This is a big advantage of using temporary virtual machines and containers; when we act as the root user, we are doing so in a temporary, confined space that can’t reach out and affect anything else.</p>&#13;
<p class="noindents">As you move from learning about containers and Kubernetes to running applications in production, you’ll be applying security controls to your cluster that will limit administrative access and will ensure that containers cannot break out of their isolated environment. This often includes configuring your containers so that they run as a non-root user.</p>&#13;
</div>&#13;
<p class="indent">In some examples, you’ll need to open multiple terminal windows in order to leave one process running while you inspect it from another terminal. How you do that is up to you; most terminal applications support multiple tabs or multiple windows. If you need a way to open multiple terminals within a single tab, try exploring a terminal multiplexer application. All of the temporary virtual machines used in the examples come with both <span class="literal">screen</span> and <span class="literal">tmux</span> installed and ready to use.<span epub:type="pagebreak" id="page_xxii"/></p>&#13;
</body></html>