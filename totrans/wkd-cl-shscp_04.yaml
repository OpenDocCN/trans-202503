- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CREATING UTILITIES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the main purposes of creating shell scripts is to drop complex command
    line sequences into files, making them replicable and easy to tweak. It should
    be no surprise, then, that user commands are sprawled across this book. What is
    surprising? That we haven’t written a wrapper for every single command on our
    Linux, Solaris, and OS X systems.
  prefs: []
  type: TYPE_NORMAL
- en: Linux/Unix is the only major operating system where you can decide that you
    don’t like the default flags of a command and fix it forever with just a few keystrokes,
    or where you can emulate the behavior of your favorite utilities from other operating
    systems by using an alias or a dozen lines of script. That’s what makes Unix so
    tremendously fun—and what led to writing this book in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: '**#22 A Reminder Utility**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows and Mac users have appreciated simple utilities like Stickies for years,
    the streamlined applications that let you keep tiny notes and reminders stuck
    on your screen. They’re perfect for jotting down phone numbers or other reminders.
    Unfortunately, there’s no analog if you want to take notes while working on a
    Unix command line, but the problem is easily solved with this pair of scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The first script, `remember` (shown in [Listing 3-1](ch03.xhtml#ch3ex1)), lets
    you easily save your snippets of information into a single `rememberfile` in your
    home directory. If invoked without any arguments, it reads standard input until
    the end-of-file sequence (`^D`) is given by pressing CTRL-D. If invoked with arguments,
    it just saves those arguments directly to the data file.
  prefs: []
  type: TYPE_NORMAL
- en: The other half of this duo is `remindme`, a companion shell script shown in
    [Listing 3-2](ch03.xhtml#ch3ex2), which either displays the contents of the whole
    `rememberfile` when no arguments are given or displays the results of searching
    through it using the arguments as a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: The* `*remember*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](ch03.xhtml#ch3ex2) details the companion script, `remindme`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: The* `*remindme*` *shell script, a companion to the* `*remember*`
    *shell script in [Listing 3-1](ch03.xhtml#ch3ex1)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `remember` shell script in [Listing 3-1](ch03.xhtml#ch3ex1) can work as
    an interactive program, requesting the user to enter the details to remember,
    or it could actually be scripted since it can also accept anything to store simply
    as a command line argument. If a user does not pass any arguments to the script,
    then we do a little tricky coding. After printing a user-friendly message on how
    to enter an item, we read the data from the user with `cat` ➊:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In previous chapters, we have used the `read` command to get input from the
    user. This line of code reads from `stdin` (the `-` in the command is shorthand
    for `stdin` or `stdout`, depending on the context) using `cat` until the user
    presses CTRL-D, which tells the `cat` utility that the file has ended. As `cat`
    prints the data it reads from `stdin`, and appends this data to the `rememberfile`.
  prefs: []
  type: TYPE_NORMAL
- en: If an argument is specified to the script, however, all arguments are simply
    appended as is to the `rememberfile` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The `remindme` script in [Listing 3-2](ch03.xhtml#ch3ex2) cannot work if the
    `rememberfile` doesn’t exist, so we first check if the `rememberfile` exists before
    attempting to do anything. If the `rememberfile` doesn’t exist, we exit immediately
    after printing a message to the screen alerting the user why.
  prefs: []
  type: TYPE_NORMAL
- en: If no arguments are passed to the script, we assume the user just wants to see
    the contents of the `rememberfile`. Using the `more` utility to allow paging through
    the `rememberfile`, we simply display the contents to the user ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if arguments are passed to the script, we perform a case-insensitive
    `grep` to search for any matching terms in the `rememberfile`, and then display
    these results with paging as well ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use the `remindme` utility, first add notes, phone numbers, or anything else
    to the `rememberfile` with the `remember` script, as in [Listing 3-3](ch03.xhtml#ch3ex3).
    Then search this freeform database with `remindme`, specifying as long or short
    a pattern as you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Testing the* `*remember*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: Then, when you want to remember that note months later, [Listing 3-4](ch03.xhtml#ch3ex4)
    shows how you can find the reminder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: Testing the* `*remindme*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: Or if there’s an 800 number you can’t quite recall, [Listing 3-5](ch03.xhtml#ch3ex5)
    demonstrates locating a partial phone number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: Locating a partial phone number with the* `*remindme*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While certainly not any sort of shell script programming tour de force, these
    scripts neatly demonstrate the extensibility of the Unix command line. If you
    can envision something, the odds are good that there’s a simple way to accomplish
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These scripts could be improved in any number of ways. For instance, you could
    introduce the concept of *records*: each `remember` entry is timestamped, and
    multiline input can be saved as a single record that can be searched for using
    regular expressions. This approach lets you store phone numbers for a group of
    people and retrieve them all just by remembering the name of one person in the
    group. If you’re really into scripting, you might also want to include edit and
    delete capabilities. Then again, it’s pretty easy to edit the *~/.remember* file
    by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**#23 An Interactive Calculator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ll remember, `scriptbc` ([Script #9](ch01.xhtml#ch01lev1sec10) on [page
    34](ch01.xhtml#page_34)) allowed us to invoke floating-point `bc` calculations
    as inline command arguments. The logical next step is to write a wrapper script
    to turn this script into a fully interactive command line–based calculator. The
    script (shown in [Listing 3-6](ch03.xhtml#ch3ex6)) ends up being really short!
    Ensure that the `scriptbc` script is in the `PATH`, otherwise this script will
    fail to run.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: The* `*calc*` *command line calculator shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Perhaps the most interesting part of this code is the `while read` statement
    ➊, which creates an infinite loop that displays the `calc>` prompt until the user
    exits, either by entering `quit` or by entering an end-of-file sequence (`^D`).
    The simplicity of this script is what makes it extra wonderful: shell scripts
    don’t need to be complex to be useful!'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script uses `scriptbc`, the floating-point calculator we wrote in [Script
    #9](ch01.xhtml#ch01lev1sec10), so make sure you have that script available in
    your `PATH` as `scriptbc` (or set a variable like `$scriptbc` to the script’s
    current name) before running it. By default, this script runs as an interactive
    tool that prompts the user for the desired actions. If invoked with arguments,
    those arguments are passed along to the `scriptbc` command instead. [Listing 3-7](ch03.xhtml#ch3ex7)
    shows both usage options at work.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: Testing the* `*calc*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating-point calculations, even those that are easy for us humans, can be
    tricky on computers. Unfortunately, the* `*bc*` *command can reveal some of these
    glitches in unexpected ways. For example, in* `*bc*`*, set* `***scale=0***` *and
    enter* `***7 % 3***`*. Now try it with* `***scale=4***`*. This produces* `*.0001*`*,
    which is clearly incorrect.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whatever you can do in `bc` on a command line you can do in this script, with
    the caveat that `calc.sh` has no line-to-line memory or state retention. This
    means you could add more mathematical functions to the help system, if you were
    so inclined. For example, the variables `obase` and `ibase` let you specify input
    and output numeric bases, though since there’s no line-by-line memory, you’d have
    to either modify `scriptbc` ([Script #9](ch01.xhtml#ch01lev1sec10) on [page 34](ch01.xhtml#page_34))
    or learn to enter the setting and the equation all on a single line.'
  prefs: []
  type: TYPE_NORMAL
- en: '**#24 Converting Temperatures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The script in [Listing 3-8](ch03.xhtml#ch3ex8), which marks the first use of
    sophisticated mathematics in this book, can translate any temperature between
    Fahrenheit, Celsius, and Kelvin units. It uses the same trick of piping an equation
    to `bc` as we used in [Script #9](ch01.xhtml#ch01lev1sec10) on [page 34](ch01.xhtml#page_34).'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: The* `*convertatemp*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point in the book, most of the script is probably clear, but let’s
    have a closer look at the math and regular expressions that do all the work. “Math
    first,” as most school-age children would undoubtedly *not* appreciate hearing!
    Here is the formula for converting degrees Fahrenheit to degrees Celsius:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0086-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Converted into a sequence that can be fed to `bc` and solved, it looks like
    the code at ➌. The reverse conversion, Celsius to Fahrenheit, is at ➍. The script
    also converts the temperature from Celsius to Kelvin ➎. This script demonstrates
    one big reason to use mnemonic variable names: it makes the code a whole lot easier
    to read and debug.'
  prefs: []
  type: TYPE_NORMAL
- en: The other bits of code here that are interesting are the regular expressions,
    the gnarliest of which is easily the one at ➊. What we’re doing is pretty straightforward,
    if you can unwrap the `sed` substitution. Substitutions always look like `s/*old*/*new*/`;
    the `*old*` pattern here is zero or more occurrences of `-`, followed by any of
    the set of digits (recall that `[:digit:]` is the ANSI character set notation
    for any digit and `*` matches zero or more occurrences of the previous pattern).
    The `*new*` pattern then is what we want to replace the `*old*` pattern with,
    and in this case it is simply `//`, which signifies an empty pattern; this pattern
    is useful when you just want to remove the old one. This substitution effectively
    removes all the digits so that inputs like `-31f` turn into just `f`, giving us
    the type of units. Finally, the `tr` command normalizes everything to uppercase
    so, for example, `-31f` turns into `F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other `sed` expression does the opposite ➋: it removes anything that isn’t
    numeric by using the `^` operator to negate matches for any characters in the
    class `[:digit:]`. (Most languages use `!` as negation.) This provides us with
    the value we eventually convert using the appropriate equation.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script has a nice, intuitive input format, even if it is pretty unusual
    for a Unix command. Input is entered as a numeric value, with an optional suffix
    that indicates the units of the temperature entered; when no suffix is given,
    the code assumes the units are Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: To see the Celsius and Kelvin equivalents of 0° Fahrenheit, enter `0F`. To see
    what 100° Kelvin is in Fahrenheit and Celsius, use `100K`. And to get 100° Celsius
    in Kelvin and Fahrenheit, enter `100C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see this same single-letter suffix approach again in [Script #60](ch07.xhtml#ch07lev1sec08)
    on [page 190](ch07.xhtml#page_190), which converts currency values.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch3ex9) shows conversion across many different temperatures.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: Testing the* `*convertatemp*` *shell script with a few conversions*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can add a few input flags to generate succinct output for only one conversion
    at a time. Something like `convertatemp -c 100F` could output just the Celsius
    equivalent of 100° Fahrenheit, for example. This approach will help you use converted
    values in other scripts as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**#25 Calculating Loan Payments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common calculation users might deal with is estimation of loan payments.
    The script in [Listing 3-10](ch03.xhtml#ch3ex10) also helps answer the question
    “What can I do with that bonus?” and the related question “Can I finally afford
    that new Tesla?”
  prefs: []
  type: TYPE_NORMAL
- en: While the formula to calculate payments based on the principal, interest rate,
    and duration of the loan is a bit tricky, some judicious use of shell variables
    can tame the mathematical beast and make it surprisingly understandable.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-10: The* `*loancalc*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Exploring the formula itself is beyond the scope of this book, but it’s worth
    noting how a complex mathematical formula can be implemented directly in a shell
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire calculation could be solved using a single long input stream to
    `bc`, because that program also supports variables. However, being able to manipulate
    the intermediate values within the script itself proves beyond the capabilities
    of the `bc` command alone. Also, frankly, breaking up the equation into a number
    of intermediate equations ➋ also facilitates debugging. For example, here’s the
    code that splits the computed monthly payment into dollars and cents and ensures
    that it’s presented as a properly formatted monetary value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `cut` command proves useful here ➌. The second line of this code grabs the
    portion of the monthly payment value that follows the decimal point and then chops
    off anything after the second character. If you would prefer to round this number
    to the next nearest cent instead, just add 0.005 to the value before truncating
    the cents at two digits.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also how at ➊, the script library from earlier in the book is neatly
    included with the `. library.sh` command in the script, ensuring that all the
    functions (for our purposes in this script, the `nicenumber()` function from [Chapter
    1](ch01.xhtml#ch01)) are then accessible to the script.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This minimalist script expects three parameters: the amount of the loan, the
    interest rate, and the duration of the loan (in years).'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you’ve been eyeing a new Tesla Model S, and you’re curious about how much
    your payments would be if you bought the car. The Model S starts at about $69,900
    out the door, and the latest interest rates are running at 4.75 percent for an
    auto loan. Assuming your current car is worth about $25,000 and that you can trade
    it in at that price, you’ll be financing the difference of $44,900\. If you haven’t
    already had second thoughts, you’d like to see what the difference is in total
    payments between a four-year and five-year car loan—easily done with this script,
    as [Listing 3-11](ch03.xhtml#ch3ex11) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-11: Testing the* `*loancalc*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can afford the higher payments on the four-year loan, the car will be
    paid off sooner, and your total payments (monthly payment times number of payments)
    will be significantly less. To calculate the exact savings, we can use the interactive
    calculator from [Script #23](ch03.xhtml#ch03lev1sec02) on [page 82](ch03.xhtml#page_82),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems like a worthwhile savings: $1,142.16 could buy a nice laptop!'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script could really do with a way to prompt for each field if the user
    doesn’t provide any parameters. An even more useful version of this script would
    let a user specify *any* three parameters of the four (principal, interest rate,
    number of payments, and monthly payment amount) and automatically solve for the
    fourth value. That way, if you knew you could afford only $500 per month in payments
    and that the maximum duration of a 6 percent auto loan was 5 years, you could
    ascertain the largest amount of principal that you could borrow. You could accomplish
    this calculation by implementing flags that users can use to pass in the values
    they want.
  prefs: []
  type: TYPE_NORMAL
- en: '**#26 Keeping Track of Events**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is actually a pair of scripts that together implement a simple calendar
    program, similar to our reminder utility from [Script #22](ch03.xhtml#ch03lev1sec01)
    on [page 80](ch03.xhtml#page_80). The first script, `addagenda` (shown in [Listing
    3-12](ch03.xhtml#ch3ex12)), enables you to specify a recurring event (with either
    a day of the week for weekly events or a day and month for annual ones) or a one-time
    event (with the day, month, and year). All the dates are validated and saved,
    along with a one-line event description, in an *.agenda* file in your home directory.
    The second script, `agenda` (shown in [Listing 3-13](ch03.xhtml#ch3ex13)), checks
    all known events to show which ones are scheduled for the current date.'
  prefs: []
  type: TYPE_NORMAL
- en: This kind of tool is particularly useful for remembering birthdays and anniversaries.
    If you have trouble remembering events, this handy script can save you a lot of
    grief!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-12: The* `*addagenda*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: The second script, in [Listing 3-13](ch03.xhtml#ch3ex13), is shorter but is
    used more often.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-13: The* `*agenda*` *shell script, a companion to the* `*addagenda*`
    *script in [Listing 3-12](ch03.xhtml#ch3ex12)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `addagenda` and `agenda` scripts support three types of recurring events:
    weekly events (“every Wednesday”), annual events (“every August 3”), and one-time
    events (“January 1, 2017”). As entries are added to the agenda file, their specified
    dates are normalized and compressed so that `3 August` becomes `3Aug` and `Thursday`
    becomes `Thu`. This is accomplished with the `normalize` function in `addagenda`
    ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: This function chops any value entered down to three characters, ensuring that
    the first character is uppercase and the second and third are lowercase. This
    format matches the standard abbreviated day and month name values from the `date`
    command output, which will be critical for the correct functioning of the `agenda`
    script. The rest of the `addagenda` script has nothing particularly complex happening
    in it; the bulk of it is devoted to error tests for bad data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at ➋ it saves the now normalized record data to the hidden file. The
    ratio of error-checking code to actual functional code is pretty typical of a
    well-written program: clean up the data on input and you’ll be able to confidently
    make assumptions about its formatting in subsequent apps.'
  prefs: []
  type: TYPE_NORMAL
- en: The `agenda` script checks for events by transforming the current date into
    the three possible date string formats (*dayname*, *day+month*, and *day+month+year*)
    ➌. It then compares these date strings to each line in the *.agenda* data file.
    If there’s a match, that event is shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The coolest hack in this pair of scripts is probably how an `eval` is used to
    assign variables to each of the four date values needed ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s possible to extract the values one by one (for example, `weekday="$(date
    +%a)"`), but in very rare cases, this method can fail if the date rolls over to
    a new day in the middle of the four `date` invocations, so a succinct single invocation
    is preferable. Plus, it’s just cool.
  prefs: []
  type: TYPE_NORMAL
- en: Since `date` returns a day as a number with either a leading zero or a leading
    space, neither of which are desired, the next line of code at ➎ strips both from
    the value, if present, before proceeding. Go have a peek to see how that works!
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `addagenda` script prompts the user for the date of a new event. Then, if
    it accepts the date format, the script prompts for a one-line description of the
    event.
  prefs: []
  type: TYPE_NORMAL
- en: The companion `agenda` script has no parameters and, when invoked, produces
    a list of all events scheduled for the current date.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see how this pair of scripts works, let’s add a number of new events to the
    database, as [Listing 3-14](ch03.xhtml#ch3ex14) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-14: Testing the* `*addagenda*` *script and adding many agenda items*'
  prefs: []
  type: TYPE_NORMAL
- en: Now the `agenda` script offers a quick and handy reminder of what’s happening
    today, detailed in [Listing 3-15](ch03.xhtml#ch3ex15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-15: Using the* `*agenda*` *script to see what our agenda items are
    for today*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that it matched entries formatted as *dayname*, *day+month*, and *day+month+year*.
    For completeness, [Listing 3-16](ch03.xhtml#ch3ex16) shows the associated *.agenda*
    file, with a few additional entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-16: The raw contents of the* .agenda *file storing the agenda items*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script really just scratches the surface of this complex and interesting
    topic. It’d be nice to have it look a few days ahead, for example; this could
    be accomplished in the `agenda` script by doing some date math. If you have the
    GNU `date` command, date math is easy. If you don’t, well, enabling date math
    solely in the shell requires a complex script. We’ll look more closely at date
    math later in the book, notably in [Script #99](ch15.xhtml#ch15lev1sec01) on [page
    330](ch15.xhtml#page_330), [Script #100](ch15.xhtml#ch15lev1sec02) on [page 332](ch15.xhtml#page_332),
    and [Script #101](ch15.xhtml#ch15lev1sec03) on [page 335](ch15.xhtml#page_335).'
  prefs: []
  type: TYPE_NORMAL
- en: Another (easier) hack would be to have `agenda` output `Nothing scheduled for
    today` when there are no matches for the current date, rather than the sloppier
    `On the agenda for today:` followed by nothing.
  prefs: []
  type: TYPE_NORMAL
- en: This script could also be used on a Unix box for sending out systemwide reminders
    about events like backup schedules, company holidays, and employee birthdays.
    First, have the `agenda` script on each user’s machine additionally check a shared
    read-only *.agenda* file. Then add a call to the `agenda` script in each user’s
    *.login* or similar file that’s invoked on login.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rather surprisingly, date implementations vary across different Unix and Linux
    systems, so if you try something more complicated with your own date command and
    it fails, make sure to check the man page to see what your system can and cannot
    do.*'
  prefs: []
  type: TYPE_NORMAL
