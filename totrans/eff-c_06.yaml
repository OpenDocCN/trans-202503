- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DYNAMICALLY
    ALLOCATED MEMORY</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 2](chapter2.xhtml), you learned that every object has a storage
    duration that determines its lifetime and that C defines four storage durations:
    static, thread, automatic, and allocated. In this chapter, you’ll learn about
    *dynamically allocated memory*, which is allocated from the heap at runtime. Dynamically
    allocated memory is useful when the exact storage requirements for a program are
    unknown before runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first describe the differences between allocated, static, and automatic
    storage duration. We’ll skip thread storage allocation as this involves parallel
    execution, which we don’t cover here. We’ll then explore the functions you can
    use to allocate and deallocate dynamic memory, common memory allocation errors,
    and strategies for avoiding them. The terms *memory* and *storage* are used interchangeably
    in this chapter, similar to the way they’re used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Objects occupy *storage*, which might be read-write memory, read-only memory,
    or central processing unit (CPU) registers. Storage of allocated duration has
    significantly different properties from storage of either automatic or static
    storage duration. First, we’ll review automatic and static storage duration.
  prefs: []
  type: TYPE_NORMAL
- en: Objects of *automatic storage duration* are declared within a block or as a
    function parameter. The lifetime of these objects begins when the block in which
    they are declared begins execution and ends when execution of the block ends.
    If the block is entered recursively, a new object is created each time, each with
    its own storage.
  prefs: []
  type: TYPE_NORMAL
- en: Objects declared at file scope have *static storage duration*. The lifetime
    of these objects is the entire execution of the program, and their stored value
    is initialized prior to program startup. You can also declare a variable within
    a block to have static storage duration by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage-class specifier.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Heap and Memory
    Managers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamically allocated memory has *allocated storage duration*. The lifetime
    of an allocated object extends from the allocation until the deallocation. Dynamically
    allocated memory is allocated from the *heap*, which is simply one or more large,
    subdividable blocks of memory managed by the memory manager.
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory managers* are libraries that manage the heap for you by providing implementations
    of the standard memory management functions described in this chapter. A memory
    manager runs as part of the client process. The memory manager requests one or
    more blocks of memory from the operating system (OS) and then allocates this memory
    to the client process when it invokes a memory allocation function. Allocation
    requests don’t go directly to the OS because it’s slower and works only in big
    chunks of memory, whereas allocators split up those big chunks into little chunks
    and are faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory managers manage unallocated and deallocated memory only. Once memory
    has been allocated, the caller manages the memory until it’s returned. It’s the
    caller’s responsibility to ensure that the memory is deallocated, although most
    implementations will reclaim dynamically allocated memory when the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When to Use Dynamically
    Allocated Memory</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously mentioned, dynamically allocated memory is used when the exact
    storage requirements for a program are unknown before runtime. Dynamically allocated
    memory is less efficient than statically allocated memory because the memory manager
    needs to find appropriately sized blocks of memory in the runtime heap, and the
    caller must explicitly free those blocks when no longer needed, all of which requires
    additional processing. Dynamically allocated memory also requires additional processing
    for housekeeping operations such as *defragmentation* (the consolidation of adjacent
    free blocks), and the memory manager often uses extra storage for control structures
    to facilitate these processes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory leaks* occur when dynamically allocated memory that’s no longer needed
    isn’t returned to the memory manager. If these memory leaks are severe, the memory
    manager eventually won’t be able to satisfy new requests for storage.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, you should declare objects with either automatic or static storage
    duration for objects whose sizes are known at compilation time. Dynamically allocate
    memory when the size of the storage or the number of objects is unknown before
    runtime. For example, you might use dynamically allocated memory to read a table
    from a file at runtime, especially if you do not know the number of rows in the
    table at compile time. Similarly, you might use dynamically allocated memory to
    create linked lists, hash tables, binary trees, or other data structures for which
    the number of data elements held in each container is unknown at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory Management</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C standard library defines memory management functions for allocating (for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>) and deallocating
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>) dynamic memory. The
    OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    is not defined by the C standard library but can be useful for memory allocation.
    C23 added two additional deallocation functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocated memory is required to be suitably aligned for objects
    up to the requested size, including arrays and structures. C11 introduced the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function for
    hardware with stricter-than-normal memory alignment requirements.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">malloc</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates
    space for an object of a specified size. The representation of the returned storage
    is indeterminate. In [Listing 6-1](chapter6.xhtml#Lis6-1), we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function to dynamically allocate storage for an object the size of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    widget</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Allocating storage
    for a widget with the</samp> <samp class="I">malloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: All memory allocation functions accept an argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    that specifies the number of bytes of memory to be allocated ❶. For portability,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator
    when calculating the size of objects, because the size of objects of distinct
    types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, may differ among implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function returns
    either a null pointer to indicate an error or a pointer to the allocated space.
    Therefore, we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    returns a null pointer ❷ and appropriately handles the error.
  prefs: []
  type: TYPE_NORMAL
- en: After the function successfully returns the allocated storage, we can reference
    members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp> structure
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">p->i</samp> accesses the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> member of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>,
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">p->d</samp> accesses the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> member.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Allocating Memory Without
    Declaring a Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can store the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> pointer to avoid
    declaring a type for the referenced object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    pointer, which was the convention before the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type was introduced to C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In either case, the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    points to has no type until an object is copied into this storage. Once that occurs,
    the object has the *effective type* of the last object copied into this storage,
    which imprints the type onto the allocated object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references has an effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>,
    the change of effective type influences optimizations and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Because allocated memory can store any sufficiently small object type, pointers
    returned by allocation functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    must be sufficiently aligned. For example, if an implementation has objects with
    1-, 2-, 4-, 8-, and 16-byte alignments and 16 or more bytes of storage are allocated,
    the alignment of the returned pointer is a multiple of 16.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reading Uninitialized Memory</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The contents of memory returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    are *uninitialized*, which means it has an indeterminate representation. Reading
    uninitialized memory is never a good idea; think of it as undefined behavior.
    If you’d like to know more, I wrote an in-depth article on uninitialized reads
    (Seacord 2017). The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function doesn’t initialize the returned memory because you are expected to overwrite
    this memory anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, beginners commonly make the mistake of assuming that the memory <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns contains zeros.
    The program shown in [Listing 6-2](chapter6.xhtml#Lis6-2) makes this exact error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An initialization
    error</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to allocate 16 bytes of memory and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>
    to copy the first 15 bytes of a string into the allocated memory. The programmer
    attempts to create a properly null-terminated string by copying one fewer byte
    than the size of the allocated memory. In doing so, the programmer assumes that
    the allocated storage already contains a zero value to serve as the null byte.
    However, the storage could easily contain nonzero values, in which case the string
    wouldn’t be properly null terminated, and the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    would result in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common solution is to write a null character into the last byte of the allocated
    storage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the source string (the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"123456789abcdef"</samp>
    in this example) has fewer than 15 bytes, the null termination character will
    be copied, and the assignment ❶ is unnecessary. If the source string has 15 bytes
    or longer, adding this assignment ensures that the string is properly null terminated.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">aligned_alloc</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function
    is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function, except that it requires you to provide an alignment as well as a size
    for the allocated object. The function has the following signature, where <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> specifies the object’s size
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> specifies its
    alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although C requires the dynamically allocated memory from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to be sufficiently aligned for all standard types, including arrays and structures,
    you might occasionally need to override the compiler’s default choices. You can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function
    to request stricter alignment than the default (in other words, a larger power
    of two). If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    is not a valid alignment supported by the implementation, the function fails by
    returning a null pointer. See [Chapter 2](chapter2.xhtml) for more information
    on alignment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">calloc</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> function allocates
    storage for an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    objects, each of whose size is <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    bytes. It has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function initializes the storage to all zero-valued bytes. These zero values
    might not be the same one used to represent floating-point zero or null-pointer
    constants. You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    function to allocate storage for a single object, which can be thought of as an
    array of one element.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    function works by multiplying <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to determine the
    required number of bytes to allocate. Historically, some <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    implementations failed to validate that these values wouldn’t wrap around when
    multiplied. C23 requires this test, and modern implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    return a null pointer if the space cannot be allocated or if the product <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nmemb * size</samp> would wrap around.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">realloc</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function increases
    or decreases the size of previously allocated storage. It takes a pointer to memory
    allocated by an earlier call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned
    _alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    (or a null pointer) and a size and has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function to grow or (less commonly) shrink the size of an array.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Avoiding Memory Leaks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid introducing bugs when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    you should understand how this function is specified. If the newly allocated storage
    is larger than the old contents, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    leaves the additional storage uninitialized. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    succeeds in allocating the new object, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to deallocate the old object. The pointer to the new object may have the same
    value as a pointer to the old object. If the allocation fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function retains the old object data at the same address and returns a null pointer.
    A call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> can fail,
    for example, when insufficient memory is available to allocate the requested number
    of bytes. The following use of <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    might be erroneous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is
    incremented by 50 before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    to increase the size of the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references. If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    fails, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned a null
    pointer value, but <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    doesn’t deallocate the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references, resulting in this memory being leaked.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-3](chapter6.xhtml#Lis6-3) demonstrates the correct use of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An example of
    the correct use of the</samp> <samp class="I">realloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-3](chapter6.xhtml#Lis6-3) declares two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>. The variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp> refers to the dynamically allocated
    memory <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> starts out uninitialized.
    Eventually, this memory is resized, which we accomplish by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer
    and the new <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp> size. The
    return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    is assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> to avoid
    overwriting the pointer stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> returns a null
    pointer, the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references
    is freed, and the function returns a null pointer. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    succeeds and returns a pointer to an allocation of size <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned the pointer
    to the newly reallocated storage, and execution continues.'
  prefs: []
  type: TYPE_NORMAL
- en: This code also includes a test for a zero-byte allocation. Avoid passing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function a value
    of 0 as the size argument, as that is undefined behavior (as clarified in C23).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the following call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function doesn’t return a null pointer, the address stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is invalid and can no longer be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, the following test is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Any pointers that reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    previously pointed to must be updated to reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">newp</samp>
    pointed to after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    kept the same address for the storage.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem is to go through an extra indirection, sometimes
    called a *handle*. If all uses of the reallocated pointer are indirect, they’ll
    all be updated when that pointer is reassigned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling realloc with a Null
    Pointer</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> with a
    null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>.
    Provided <samp class="SANS_TheSansMonoCd_W5Regular_11">newsize</samp> isn’t equal
    to 0, we can replace the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first, longer version of this code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    for the initial allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    to adjust the size later as required. Because calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    with a null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    the second version concisely accomplishes the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">reallocarray</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in previous chapters, both signed integer overflow and unsigned
    integer wraparound are serious problems that can result in buffer overflows and
    other security vulnerabilities. In the following code snippet, for example, the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">num * size</samp> might
    wrap around before being passed as the size argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function can reallocate storage for an array, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    it checks for wraparound during array size calculations, which saves you from
    having to perform these checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    allocates storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    members of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> and
    checks for wraparound in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb
    * size</samp> calculation. Other platforms, including the GNU C Library (libc),
    have adopted this function, and it has been proposed for inclusion in the next
    revision of the POSIX standard. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function does not zero out the allocated storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    is useful when two values are multiplied to determine the size of the allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function will fail and return a null pointer if <samp class="SANS_TheSansMonoCd_W5Regular_11">num
    * size</samp> would wrap around.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it’s no longer needed, memory can be deallocated using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function. Deallocating memory allows that memory to be reused, reducing the chances
    that you’ll exhaust the available memory and often providing more efficient use
    of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can deallocate memory by passing a pointer to that memory to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function, which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> value must have
    been returned by a previous call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc,
    aligned_alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>. CERT C rule MEM34-C,
    “Only free memory allocated dynamically,” discusses what happens when the value
    is not returned. Memory is a limited resource and so must be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> with a
    null-pointer argument, nothing happens, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function simply returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Freeing the same pointer twice, on the other hand, is a serious error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_sized</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C23 introduced two new memory deallocation functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer
    or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is equal to the
    requested allocation size, this function behaves the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>.
    You cannot pass the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    to this function; you must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function (described in the next section). By *reminding* the allocator of the
    size of that allocation, you can reduce deallocation cost and allow extra security-hardening
    functionality. However, if you specify the size incorrectly, the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp> function,
    we could improve the performance and safety of the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'by rewriting it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is feasible and practical when the size of the allocation is retained or
    can be inexpensively re-created.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_aligned_sized</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second of the two new memory deallocation functions that C23 introduced
    is the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer
    or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> is equal
    to the requested allocation alignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    is equal to the requested allocation size, this function is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>. Otherwise, the behavior
    is undefined. In other words, this function may be used only for deallocating
    explicitly aligned memory.
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function, we could improve the performance and safety of the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'by rewriting it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is feasible and practical when the alignment and size of the allocation
    is retained or can be inexpensively re-created.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Dangling Pointers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you call one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    functions on the same pointer more than once, undefined behavior occurs. These
    defects can result in a security flaw known as a *double-free vulnerability*.
    One consequence is that they might be exploited to execute arbitrary code with
    the permissions of the vulnerable process. The full effects of double-free vulnerabilities
    are beyond the scope of this book, but I discuss them in detail in *Secure Coding
    in C and C++* (Seacord 2013). Double-free vulnerabilities are especially common
    in error-handling code, as programmers attempt to free allocated resources.
  prefs: []
  type: TYPE_NORMAL
- en: Another common error is to access memory that has already been freed. This type
    of error frequently goes undetected because the code might appear to work but
    then fails in an unexpected manner away from the actual error. In [Listing 6-4](chapter6.xhtml#Lis6-4),
    taken from an actual application, the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>
    is invalid because the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    has reclaimed the storage <samp class="SANS_TheSansMonoCd_W5Regular_11">dirp</samp>
    formerly pointed to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Accessing already
    freed memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We refer to pointers to already freed memory as *dangling pointers*. Dangling
    pointers are a potential source of errors (like a banana peel on the floor). Every
    use of a dangling pointer (not just dereferencing) is undefined behavior. When
    used to access memory that has already been freed, dangling pointers can result
    in use-after-free vulnerabilities (CWE 416). When passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function, dangling pointers can result in double-free vulnerabilities (CWE 415).
    See CERT C rule MEM30-C, “Do not access freed memory,” for more information on
    these topics.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting the Pointer to Null</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To limit the opportunity for defects involving dangling pointers, set the pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> after completing
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Any future attempt to dereference the pointer will usually result in a crash,
    increasing the likelihood that the error is detected during implementation and
    testing. If the pointer is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>,
    the memory can be freed multiple times without consequence. Unfortunately, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function cannot set
    the pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> itself
    because it’s passed a copy of the pointer and not the actual pointer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory States</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamically allocated memory can exist in one of three states shown in [Figure
    6-1](chapter6.xhtml#fig6-1): unallocated and uninitialized within the memory manager,
    allocated but uninitialized, and allocated and initialized. Calls to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    functions, as well as writing the memory, cause the memory to transition between
    states.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f06001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Memory states</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Different operations are valid depending on the state of the memory. Avoid any
    operation on memory that’s not shown as valid or explicitly listed as invalid.
    Following execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function in this code snippet
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: the first 50 bytes are allocated and initialized, while the last 50 bytes are
    allocated but uninitialized. Initialized bytes can be read, but uninitialized
    bytes must not be read.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Flexible Array Members</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allocating storage for a structure that contains an array has always been a
    little tricky in C. There’s no problem if the array has a fixed number of elements,
    as the size of the structure can easily be determined. Developers, however, frequently
    need to declare an array whose size is unknown until runtime, and originally,
    C offered no straightforward way to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible array members let you declare and allocate storage for a structure
    with any number of fixed members, where the last member is an array of unknown
    size. Starting with C99, the last member of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    with more than one member can have an *incomplete array type*, which means that
    the array has an unknown size that you can specify at runtime. A flexible array
    member allows you to access a variable-length object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 6-5](chapter6.xhtml#Lis6-5) shows the use of a flexible
    array member <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>. We dynamically allocate
    storage for the object by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Flexible array
    members</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We first declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    whose last member, the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    array ❶, is an incomplete type (with no specified size). We then allocate storage
    for the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> ❷.
    When computing the size of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    containing a flexible array member using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, the flexible array member is ignored. Therefore, we must explicitly
    include an appropriate size for the flexible array member when allocating storage.
    To accomplish that, we allocate additional bytes for the array by multiplying
    the number of elements in the array (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>)
    by the size of each element (<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>).
    This program assumes that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>
    is such that when multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>,
    wraparound won’t occur.
  prefs: []
  type: TYPE_NORMAL
- en: We can access this storage by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator ❸, as if the
    storage had been allocated as <samp class="SANS_TheSansMonoCd_W5Regular_11">data[num_elem]</samp>.
    See CERT C rule MEM33-C, “Allocate and copy structures containing a flexible array
    member dynamically,” for more information on allocating and copying structures
    containing flexible array members.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C99, multiple compilers supported a similar “<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    hack” using a variety of syntaxes. CERT C rule DCL38-C, “Use the correct syntax
    when declaring a flexible array member, ” is a reminder to use the syntax specified
    in C99 and later versions of the C standard.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Dynamically Allocated Storage</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C has language and library features beyond the memory management functions that
    support dynamically allocated storage. This storage is typically allocated in
    the stack frame of the caller (the C standard does not define a stack, but it’s
    a common implementation feature). A *stack* is a last-in-first-out (LIFO) data
    structure that supports nested invocation of functions at runtime. Each function
    invocation creates a *stack frame* in which local variables (of automatic storage
    duration) and other data specific to that invocation of the function can be stored.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">alloca</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For performance reasons, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    (a nonstandard function supported by some implementations) allows dynamic allocation
    at runtime from the stack rather than the heap. This memory is automatically released
    when the function that called <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function
    is an *intrinsic* (or *built-in*) function, which is specially handled by the
    compiler. This allows the compiler to substitute a sequence of automatically generated
    instructions for the original function call. For example, on the x86 architecture,
    the compiler substitutes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    with a single instruction to adjust the stack pointer to accommodate the additional
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function originated
    in an early version of the Unix operating system from Bell Laboratories but is
    not defined by the C standard library or POSIX. [Listing 6-6](chapter6.xhtml#Lis6-6)
    shows an example function called <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function
    to allocate storage for an error string before printing it out to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The</samp> <samp
    class="I">printerr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> function takes
    a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">errnum</samp>,
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp> type. We call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> function
    ❶ to determine the length of the error string associated with this error number.
    Once we know the size of the array that we need to allocate to hold the error
    string, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function ❷ to efficiently allocate storage for the array. We then retrieve the
    error string by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function ❸ and store the result in the newly allocated storage <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>
    references. Assuming the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function succeeds, we output the error message ❹; otherwise, we output <samp class="SANS_TheSansMonoCd_W5Regular_11">unknown
    error</samp> ❺. This <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    function is written to demonstrate the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    and is more complicated than it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function can
    be tricky to use. First, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    can make allocations that exceed the bounds of the stack. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function doesn’t return a null pointer value, so there’s no way to check for the
    error. For this reason, it’s critically important to avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    with large or unbounded allocations. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    in this example should return a reasonable allocation size.
  prefs: []
  type: TYPE_NORMAL
- en: A further problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function is that programmers may become confused by having to free memory allocated
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> but not <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>.
    Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> on a pointer
    not obtained by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> is a serious error.
    Due to those issues, the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Both GCC and Clang provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca</samp>
    compiler flag that diagnoses all calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function. GCC also provides a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> compiler flag that
    diagnoses any call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function when the requested memory is more than <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable-Length Arrays</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variable-length arrays (VLAs) were introduced in C99\. A VLA is an object of
    a variably modified type (covered in [Chapter 2](chapter2.xhtml)). Storage for
    the VLA is allocated at runtime and is equal to the size of the base type of the
    variably modified type multiplied by the runtime extent.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the array cannot be modified after you create it. All VLA declarations
    must be at *block scope*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example declares the VLA <samp class="SANS_TheSansMonoCd_W5Regular_11">vla</samp>
    of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> as an automatic
    variable in function <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: VLAs are useful when you don’t know the number of elements in the array until
    runtime. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, VLAs are freed when the corresponding block ends, just like any other
    automatic variable. [Listing 6-7](chapter6.xhtml#Lis6-7) replaces the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    function from [Listing 6-6](chapter6.xhtml#Lis6-6) with a VLA. The change modifies
    just a single line of code (shown in bold).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The</samp> <samp
    class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    rewritten to use a VLA</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using VLAs instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function is that the syntax matches the programmer’s model of how arrays with
    automatic storage duration work. VLAs work just like automatic variables (because
    they are). Another advantage is that memory does not accumulate while iterating
    (which can accidentally happen with <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    because memory is released at the end of the function).
  prefs: []
  type: TYPE_NORMAL
- en: VLAs share some of the problems of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, in that they can attempt to make allocations that exceed the bounds
    of the stack. Unfortunately, there’s no portable way to determine the remaining
    stack space to detect such an error. Also, the calculation of the array’s size
    could wrap around when the size you provide is multiplied by the size of each
    element. For those reasons, it’s important to validate the size of the array before
    declaring it to avoid overly large or incorrectly sized allocations. This can
    be especially important in functions that are called with untrusted inputs or
    are called recursively, because a complete new set of automatic variables for
    the functions (including these arrays) will be created for each recursion. Untrusted
    inputs must be validated before being used for any allocations, including from
    the heap.
  prefs: []
  type: TYPE_NORMAL
- en: You should determine whether you have sufficient stack space in the worst-case
    scenario (maximum-sized allocations with deep recursions). On some implementations,
    it’s also possible to pass a negative size to the VLA, so make sure your size
    is represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    or other unsigned type. See CERT C rule ARR32-C, “Ensure size arguments for variable-length
    arrays are in a valid range,” for more information. VLAs reduce stack usage when
    compared to using worst-case fixed-sized arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file-scope declarations demonstrate another confusing aspect
    of VLAs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Is this code valid? If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    is a VLA, then the code is invalid, because the declaration is at file scope.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a constant-sized
    array, then the code is valid. GCC currently rejects this example because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a VLA. However, C23 allows
    implementations to extend the definition of an integer constant expression, which
    Clang does by making <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    a constant-sized array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite these declarations to be portable using <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    on all C23-conforming implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, another interesting and unexpected behavior occurs when calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> on a VLA. The compiler usually
    performs the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operation
    at compile time. However, if the expression changes the size of the array, it
    will be evaluated at runtime, including any side effects. The same is true of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>, as the program in
    [Listing 6-8](chapter6.xhtml#Lis6-8) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: Unexpected side
    effects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this simple test program, we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> and initialize
    it to <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The operand in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(size++)</samp> isn’t evaluated
    because the type of the operand is not a VLA. Consequently, the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> doesn’t change. We then call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int[size++]</samp> as the argument.
    Because this expression changes the size of the array, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    is incremented and is now equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> similarly increments
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">14</samp>. Finally, we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to be of <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof(int[size++])</samp>,
    which further increments <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>.
    Because these behaviors aren’t well understood, avoid using expressions with side
    effects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operators, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>s to improve understandability.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging Allocated Storage Problems</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, improper memory management can lead to errors
    like leaking memory, reading from or writing to freed memory, and freeing memory
    more than once. One way to avoid some of these problems is to set pointers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> null pointer value after
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, as we’ve already
    discussed. Another strategy is to keep your dynamic memory management as simple
    as possible. For example, you should allocate and free memory in the same module,
    at the same level of abstraction, rather than freeing memory in subroutines, which
    leads to confusion about if, when, and where memory is freed.
  prefs: []
  type: TYPE_NORMAL
- en: A third option is to use *dynamic analysis tools*, such as AddressSanitizer,
    Valgrind, or <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to detect
    and report memory errors. AddressSanitizer, as well as general approaches to debugging,
    testing, and analysis, are discussed in [Chapter 11](chapter11.xhtml), while <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> is covered in this section.
    AddressSanitizer or Valgrind are effective tools and better choices if they are
    available for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">dmalloc</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *debug memory allocation* (<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>)
    library Gray Watson created replaces <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, and other memory management
    features with routines that provide debugging facilities that you can configure
    at runtime. The library has been tested on a variety of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the installation directions provided at *[https://<wbr>dmalloc<wbr>.com](https://dmalloc.com)*
    to configure, build, and install the library. [Listing 6-9](chapter6.xhtml#Lis6-9)
    contains a short program that prints out usage information and exits (it would
    typically be part of a longer program). This program has several intentional errors
    and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Catching a memory
    bug with</samp> <samp class="I">dmalloc</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent versions of glibc will detect at least one of the vulnerabilities from
    this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After repairing this error, include the lines shown in bold font to allow <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to report the file and
    line numbers of calls that cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll show the output later, but we need to discuss a few things first. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> distribution also
    comes with a command line utility. You can run the following command to get further
    information on how to use this utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Before debugging your program with <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>,
    enter the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This command sets the logfile name to *logfile* and instructs the library to
    perform a check after <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    invocations, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> argument
    specifies. If you specify a larger number as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> will check
    the heap less often, and your code will run faster; lower numbers are more likely
    to catch memory problems. The third argument enables a <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp>
    number of debug features. Other options include <samp class="SANS_TheSansMonoCd_W5Regular_11">runtime</samp>
    for minimal checking or <samp class="SANS_TheSansMonoCd_W5Regular_11">medium</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">high</samp> for more extensive
    heap verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing this command, we can compile the program by using GCC as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the program, you should see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you examine the logfile, you’ll find the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These messages indicate that we’ve attempted to free the storage referenced
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">errmsg</samp> twice, first in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">usage</samp> function and then
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, which constitutes
    a double-free vulnerability. Of course, this is just a single example of the types
    of bugs that <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> can
    detect, and other defects exist in the simple program we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safety-Critical Systems</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Systems with high safety requirements frequently ban the use of dynamic memory
    because memory managers can have unpredictable behavior that significantly impacts
    performance. Forcing all applications to live within a fixed, preallocated area
    of memory can eliminate these problems and make it easier to verify memory use.
    In the absence of recursion, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>,
    and VLAs (also prohibited in safety-critical systems), an upper bound on the use
    of stack memory can be derived statically, making it possible to prove that sufficient
    storage exists to execute the functionality of the application for all possible
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Both GCC and Clang have a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla</samp>
    flag that warns if a VLA is used. GCC also has a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp> flag that warns
    for declarations of VLAs whose size is either unbounded or bounded by an argument
    that allows the array size to exceed <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp>
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about working with memory that has allocated storage
    duration and how this differs from objects of either automatic or static storage
    duration. We described the heap and memory managers and each of the standard memory
    management functions. We identified some common causes of errors when using dynamic
    memory, such as leaks and double-free vulnerabilities, and introduced some mitigations
    to help avoid these problems.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered some more specialized memory allocation topics such as flexible
    array members, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, and VLAs. We concluded the chapter with a discussion of debugging allocated
    storage problems by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about characters and strings.
  prefs: []
  type: TYPE_NORMAL
