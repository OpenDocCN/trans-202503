- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DYNAMICALLY
    ALLOCATED MEMORY</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 2](chapter2.xhtml), you learned that every object has a storage
    duration that determines its lifetime and that C defines four storage durations:
    static, thread, automatic, and allocated. In this chapter, you’ll learn about
    *dynamically allocated memory*, which is allocated from the heap at runtime. Dynamically
    allocated memory is useful when the exact storage requirements for a program are
    unknown before runtime.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first describe the differences between allocated, static, and automatic
    storage duration. We’ll skip thread storage allocation as this involves parallel
    execution, which we don’t cover here. We’ll then explore the functions you can
    use to allocate and deallocate dynamic memory, common memory allocation errors,
    and strategies for avoiding them. The terms *memory* and *storage* are used interchangeably
    in this chapter, similar to the way they’re used in practice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Objects occupy *storage*, which might be read-write memory, read-only memory,
    or central processing unit (CPU) registers. Storage of allocated duration has
    significantly different properties from storage of either automatic or static
    storage duration. First, we’ll review automatic and static storage duration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Objects of *automatic storage duration* are declared within a block or as a
    function parameter. The lifetime of these objects begins when the block in which
    they are declared begins execution and ends when execution of the block ends.
    If the block is entered recursively, a new object is created each time, each with
    its own storage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Objects declared at file scope have *static storage duration*. The lifetime
    of these objects is the entire execution of the program, and their stored value
    is initialized prior to program startup. You can also declare a variable within
    a block to have static storage duration by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage-class specifier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Heap and Memory
    Managers</samp>
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamically allocated memory has *allocated storage duration*. The lifetime
    of an allocated object extends from the allocation until the deallocation. Dynamically
    allocated memory is allocated from the *heap*, which is simply one or more large,
    subdividable blocks of memory managed by the memory manager.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory managers* are libraries that manage the heap for you by providing implementations
    of the standard memory management functions described in this chapter. A memory
    manager runs as part of the client process. The memory manager requests one or
    more blocks of memory from the operating system (OS) and then allocates this memory
    to the client process when it invokes a memory allocation function. Allocation
    requests don’t go directly to the OS because it’s slower and works only in big
    chunks of memory, whereas allocators split up those big chunks into little chunks
    and are faster.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存管理器*是通过提供本章所描述的标准内存管理函数实现的库，负责为你管理堆。内存管理器作为客户端进程的一部分运行。当客户端进程调用内存分配函数时，内存管理器会向操作系统（OS）请求一个或多个内存块，并将这些内存分配给客户端进程。分配请求不会直接发送到操作系统，因为操作系统较慢，并且只能处理大块内存，而分配器则将这些大块内存分割成小块，从而提高速度。'
- en: Memory managers manage unallocated and deallocated memory only. Once memory
    has been allocated, the caller manages the memory until it’s returned. It’s the
    caller’s responsibility to ensure that the memory is deallocated, although most
    implementations will reclaim dynamically allocated memory when the program terminates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理器仅管理未分配和已释放的内存。一旦内存被分配，调用者将管理该内存，直到它被归还。确保内存被释放是调用者的责任，尽管大多数实现会在程序终止时回收动态分配的内存。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When to Use Dynamically
    Allocated Memory</samp>
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">何时使用动态分配的内存</samp>
- en: As previously mentioned, dynamically allocated memory is used when the exact
    storage requirements for a program are unknown before runtime. Dynamically allocated
    memory is less efficient than statically allocated memory because the memory manager
    needs to find appropriately sized blocks of memory in the runtime heap, and the
    caller must explicitly free those blocks when no longer needed, all of which requires
    additional processing. Dynamically allocated memory also requires additional processing
    for housekeeping operations such as *defragmentation* (the consolidation of adjacent
    free blocks), and the memory manager often uses extra storage for control structures
    to facilitate these processes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当程序的确切存储需求在运行时之前无法确定时，会使用动态分配的内存。动态分配的内存比静态分配的内存效率低，因为内存管理器需要在运行时堆中找到合适大小的内存块，而且调用者必须在不再需要时显式释放这些内存块，所有这些都需要额外的处理。动态分配的内存还需要额外的处理用于日常维护操作，例如*碎片整理*（合并相邻的空闲块），并且内存管理器通常会使用额外的存储来存放控制结构，以便支持这些操作。
- en: '*Memory leaks* occur when dynamically allocated memory that’s no longer needed
    isn’t returned to the memory manager. If these memory leaks are severe, the memory
    manager eventually won’t be able to satisfy new requests for storage.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存泄漏*发生在动态分配的内存不再需要时没有归还给内存管理器。如果内存泄漏严重，内存管理器最终将无法满足新的存储请求。'
- en: By default, you should declare objects with either automatic or static storage
    duration for objects whose sizes are known at compilation time. Dynamically allocate
    memory when the size of the storage or the number of objects is unknown before
    runtime. For example, you might use dynamically allocated memory to read a table
    from a file at runtime, especially if you do not know the number of rows in the
    table at compile time. Similarly, you might use dynamically allocated memory to
    create linked lists, hash tables, binary trees, or other data structures for which
    the number of data elements held in each container is unknown at compile time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对于那些在编译时已知大小的对象，应声明为具有自动或静态存储持续时间的对象。当存储大小或对象数量在运行时才能确定时，应动态分配内存。例如，你可能会使用动态分配的内存在运行时从文件中读取表格，尤其是在编译时不知道表格的行数时。类似地，你可能会使用动态分配的内存来创建链表、哈希表、二叉树或其他数据结构，这些结构中每个容器所包含的数据元素的数量在编译时是无法知道的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory Management</samp>
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内存管理</samp>
- en: 'The C standard library defines memory management functions for allocating (for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>) and deallocating
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>) dynamic memory. The
    OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    is not defined by the C standard library but can be useful for memory allocation.
    C23 added two additional deallocation functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocated memory is required to be suitably aligned for objects
    up to the requested size, including arrays and structures. C11 introduced the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function for
    hardware with stricter-than-normal memory alignment requirements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">malloc</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates
    space for an object of a specified size. The representation of the returned storage
    is indeterminate. In [Listing 6-1](chapter6.xhtml#Lis6-1), we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function to dynamically allocate storage for an object the size of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    widget</samp>.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Allocating storage
    for a widget with the</samp> <samp class="I">malloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: All memory allocation functions accept an argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    that specifies the number of bytes of memory to be allocated ❶. For portability,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator
    when calculating the size of objects, because the size of objects of distinct
    types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, may differ among implementations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function returns
    either a null pointer to indicate an error or a pointer to the allocated space.
    Therefore, we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    returns a null pointer ❷ and appropriately handles the error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: After the function successfully returns the allocated storage, we can reference
    members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp> structure
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">p->i</samp> accesses the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> member of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>,
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">p->d</samp> accesses the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> member.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数成功返回分配的存储后，我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    指针引用 <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp> 结构体的成员。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p->i</samp> 访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 成员，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">p->d</samp>
    访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 成员。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Allocating Memory Without
    Declaring a Type</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在不声明类型的情况下分配内存</samp>
- en: 'You can store the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> pointer to avoid
    declaring a type for the referenced object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的返回值存储为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 指针，以避免为引用的对象声明类型：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    pointer, which was the convention before the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type was introduced to C:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 指针，这是在引入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型之前的惯例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In either case, the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    points to has no type until an object is copied into this storage. Once that occurs,
    the object has the *effective type* of the last object copied into this storage,
    which imprints the type onto the allocated object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 指向的对象在将对象复制到此存储中之前是没有类型的。一旦发生这种情况，该对象将具有最后一个复制到此存储中的对象的*有效类型*，这会将类型印在分配的对象上。
- en: 'In the following example, the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references has an effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 所引用的存储具有有效的类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>,
    the change of effective type influences optimizations and nothing else.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> 之后，有效类型的变化会影响优化，但不会产生其他影响。
- en: Because allocated memory can store any sufficiently small object type, pointers
    returned by allocation functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    must be sufficiently aligned. For example, if an implementation has objects with
    1-, 2-, 4-, 8-, and 16-byte alignments and 16 or more bytes of storage are allocated,
    the alignment of the returned pointer is a multiple of 16.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分配的内存可以存储任何足够小的对象类型，因此分配函数返回的指针，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>，必须具有足够的对齐。例如，如果实现中有对齐为1字节、2字节、4字节、8字节和16字节的对象，并且分配了16字节或更多字节的存储，则返回指针的对齐方式是16的倍数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reading Uninitialized Memory</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">读取未初始化的内存</samp>
- en: The contents of memory returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    are *uninitialized*, which means it has an indeterminate representation. Reading
    uninitialized memory is never a good idea; think of it as undefined behavior.
    If you’d like to know more, I wrote an in-depth article on uninitialized reads
    (Seacord 2017). The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function doesn’t initialize the returned memory because you are expected to overwrite
    this memory anyway.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 返回的内存内容是*未初始化的*，这意味着它具有不确定的表示。读取未初始化的内存从来都不是一个好主意；可以将其视为未定义行为。如果你想了解更多，我写了一篇关于未初始化读取的深入文章（Seacord
    2017）。<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 函数不会初始化返回的内存，因为你预计最终会覆盖这块内存。
- en: Even so, beginners commonly make the mistake of assuming that the memory <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns contains zeros.
    The program shown in [Listing 6-2](chapter6.xhtml#Lis6-2) makes this exact error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An initialization
    error</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to allocate 16 bytes of memory and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>
    to copy the first 15 bytes of a string into the allocated memory. The programmer
    attempts to create a properly null-terminated string by copying one fewer byte
    than the size of the allocated memory. In doing so, the programmer assumes that
    the allocated storage already contains a zero value to serve as the null byte.
    However, the storage could easily contain nonzero values, in which case the string
    wouldn’t be properly null terminated, and the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    would result in undefined behavior.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'A common solution is to write a null character into the last byte of the allocated
    storage, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the source string (the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"123456789abcdef"</samp>
    in this example) has fewer than 15 bytes, the null termination character will
    be copied, and the assignment ❶ is unnecessary. If the source string has 15 bytes
    or longer, adding this assignment ensures that the string is properly null terminated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">aligned_alloc</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function
    is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function, except that it requires you to provide an alignment as well as a size
    for the allocated object. The function has the following signature, where <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> specifies the object’s size
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> specifies its
    alignment:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although C requires the dynamically allocated memory from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to be sufficiently aligned for all standard types, including arrays and structures,
    you might occasionally need to override the compiler’s default choices. You can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function
    to request stricter alignment than the default (in other words, a larger power
    of two). If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    is not a valid alignment supported by the implementation, the function fails by
    returning a null pointer. See [Chapter 2](chapter2.xhtml) for more information
    on alignment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">calloc</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> function allocates
    storage for an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    objects, each of whose size is <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    bytes. It has the following signature:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>函数为一个包含<samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>个对象的数组分配存储，每个对象的大小为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp>字节。它具有以下签名：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function initializes the storage to all zero-valued bytes. These zero values
    might not be the same one used to represent floating-point zero or null-pointer
    constants. You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    function to allocate storage for a single object, which can be thought of as an
    array of one element.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将存储初始化为全零字节。这些零值可能不同于用来表示浮点零或空指针常量的值。你还可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>函数为单个对象分配存储，可以将其视为一个包含一个元素的数组。
- en: Internally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    function works by multiplying <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to determine the
    required number of bytes to allocate. Historically, some <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    implementations failed to validate that these values wouldn’t wrap around when
    multiplied. C23 requires this test, and modern implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    return a null pointer if the space cannot be allocated or if the product <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nmemb * size</samp> would wrap around.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>函数通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>乘以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp>来确定所需的字节数。历史上，一些<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>实现没有验证这些值在相乘时是否会发生溢出。C23要求进行此测试，现代的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>实现如果无法分配空间，或者如果乘积<samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb
    * size</samp>会发生溢出，则返回空指针。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">realloc</samp>
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">realloc</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function increases
    or decreases the size of previously allocated storage. It takes a pointer to memory
    allocated by an earlier call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned
    _alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    (or a null pointer) and a size and has the following signature:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数增加或减少先前分配的存储空间的大小。它接受一个指向由先前调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned _alloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>（或者一个空指针）分配的内存的指针，以及一个大小，并具有以下签名：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function to grow or (less commonly) shrink the size of an array.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数来增加或（较少见的情况）减少数组的大小。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Avoiding Memory Leaks</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">避免内存泄漏</samp>
- en: 'To avoid introducing bugs when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    you should understand how this function is specified. If the newly allocated storage
    is larger than the old contents, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    leaves the additional storage uninitialized. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    succeeds in allocating the new object, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to deallocate the old object. The pointer to the new object may have the same
    value as a pointer to the old object. If the allocation fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function retains the old object data at the same address and returns a null pointer.
    A call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> can fail,
    for example, when insufficient memory is available to allocate the requested number
    of bytes. The following use of <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    might be erroneous:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is
    incremented by 50 before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    to increase the size of the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references. If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    fails, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned a null
    pointer value, but <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    doesn’t deallocate the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references, resulting in this memory being leaked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-3](chapter6.xhtml#Lis6-3) demonstrates the correct use of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An example of
    the correct use of the</samp> <samp class="I">realloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-3](chapter6.xhtml#Lis6-3) declares two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>. The variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp> refers to the dynamically allocated
    memory <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> starts out uninitialized.
    Eventually, this memory is resized, which we accomplish by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer
    and the new <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp> size. The
    return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    is assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> to avoid
    overwriting the pointer stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> returns a null
    pointer, the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references
    is freed, and the function returns a null pointer. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    succeeds and returns a pointer to an allocation of size <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned the pointer
    to the newly reallocated storage, and execution continues.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](chapter6.xhtml#Lis6-3)声明了两个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>。变量<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>引用动态分配的内存，这是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>返回的内存，<samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>初始时未初始化。最终，这块内存会被调整大小，我们通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数，并传入<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>指针和新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>大小来完成。<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>的返回值会被赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>，以避免覆盖存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>中的指针。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>返回一个空指针，那么<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>引用的内存将会被释放，并且函数将返回空指针。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>成功并返回指向大小为<samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>的分配的指针，则<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>将被赋值为指向新分配内存的指针，程序继续执行。'
- en: This code also includes a test for a zero-byte allocation. Avoid passing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function a value
    of 0 as the size argument, as that is undefined behavior (as clarified in C23).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还包括了对零字节分配的测试。避免将值为 0 的大小参数传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数，因为这会导致未定义行为（如C23中所阐明）。
- en: 'If the following call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function doesn’t return a null pointer, the address stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is invalid and can no longer be read:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下对<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数的调用没有返回空指针，那么存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>中的地址就是无效的，不能再进行读取：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In particular, the following test is not allowed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，以下测试是不允许的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Any pointers that reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    previously pointed to must be updated to reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">newp</samp>
    pointed to after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    kept the same address for the storage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任何引用<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>之前所指向内存的指针，都必须更新为引用调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>之后指向的新内存<samp class="SANS_TheSansMonoCd_W5Regular_11">newp</samp>，无论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>是否保留了相同的内存地址。
- en: One solution to this problem is to go through an extra indirection, sometimes
    called a *handle*. If all uses of the reallocated pointer are indirect, they’ll
    all be updated when that pointer is reassigned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是通过额外的间接方式，有时称为*句柄*。如果重新分配的指针的所有使用都是间接的，当该指针重新赋值时，它们都会被更新。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling realloc with a Null
    Pointer</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">调用 realloc 时传递空指针</samp>
- en: Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> with a
    null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>.
    Provided <samp class="SANS_TheSansMonoCd_W5Regular_11">newsize</samp> isn’t equal
    to 0, we can replace the following code
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'with this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first, longer version of this code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    for the initial allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    to adjust the size later as required. Because calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    with a null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    the second version concisely accomplishes the same thing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">reallocarray</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in previous chapters, both signed integer overflow and unsigned
    integer wraparound are serious problems that can result in buffer overflows and
    other security vulnerabilities. In the following code snippet, for example, the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">num * size</samp> might
    wrap around before being passed as the size argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function can reallocate storage for an array, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    it checks for wraparound during array size calculations, which saves you from
    having to perform these checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function has the following signature:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    allocates storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    members of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> and
    checks for wraparound in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb
    * size</samp> calculation. Other platforms, including the GNU C Library (libc),
    have adopted this function, and it has been proposed for inclusion in the next
    revision of the POSIX standard. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function does not zero out the allocated storage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    is useful when two values are multiplied to determine the size of the allocation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function will fail and return a null pointer if <samp class="SANS_TheSansMonoCd_W5Regular_11">num
    * size</samp> would wrap around.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it’s no longer needed, memory can be deallocated using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function. Deallocating memory allows that memory to be reused, reducing the chances
    that you’ll exhaust the available memory and often providing more efficient use
    of the heap.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'We can deallocate memory by passing a pointer to that memory to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function, which has the following signature:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> value must have
    been returned by a previous call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc,
    aligned_alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>. CERT C rule MEM34-C,
    “Only free memory allocated dynamically,” discusses what happens when the value
    is not returned. Memory is a limited resource and so must be reclaimed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> with a
    null-pointer argument, nothing happens, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function simply returns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Freeing the same pointer twice, on the other hand, is a serious error.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_sized</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C23 introduced two new memory deallocation functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    function has the following signature:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer
    or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is equal to the
    requested allocation size, this function behaves the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>.
    You cannot pass the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    to this function; you must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function (described in the next section). By *reminding* the allocator of the
    size of that allocation, you can reduce deallocation cost and allow extra security-hardening
    functionality. However, if you specify the size incorrectly, the behavior is undefined.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp> function,
    we could improve the performance and safety of the following code
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'by rewriting it as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is feasible and practical when the size of the allocation is retained or
    can be inexpensively re-created.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_aligned_sized</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second of the two new memory deallocation functions that C23 introduced
    is the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function has the following signature:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer
    or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> is equal
    to the requested allocation alignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    is equal to the requested allocation size, this function is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>. Otherwise, the behavior
    is undefined. In other words, this function may be used only for deallocating
    explicitly aligned memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function, we could improve the performance and safety of the following code
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'by rewriting it as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is feasible and practical when the alignment and size of the allocation
    is retained or can be inexpensively re-created.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Dangling Pointers</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you call one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    functions on the same pointer more than once, undefined behavior occurs. These
    defects can result in a security flaw known as a *double-free vulnerability*.
    One consequence is that they might be exploited to execute arbitrary code with
    the permissions of the vulnerable process. The full effects of double-free vulnerabilities
    are beyond the scope of this book, but I discuss them in detail in *Secure Coding
    in C and C++* (Seacord 2013). Double-free vulnerabilities are especially common
    in error-handling code, as programmers attempt to free allocated resources.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Another common error is to access memory that has already been freed. This type
    of error frequently goes undetected because the code might appear to work but
    then fails in an unexpected manner away from the actual error. In [Listing 6-4](chapter6.xhtml#Lis6-4),
    taken from an actual application, the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>
    is invalid because the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    has reclaimed the storage <samp class="SANS_TheSansMonoCd_W5Regular_11">dirp</samp>
    formerly pointed to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Accessing already
    freed memory</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We refer to pointers to already freed memory as *dangling pointers*. Dangling
    pointers are a potential source of errors (like a banana peel on the floor). Every
    use of a dangling pointer (not just dereferencing) is undefined behavior. When
    used to access memory that has already been freed, dangling pointers can result
    in use-after-free vulnerabilities (CWE 416). When passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function, dangling pointers can result in double-free vulnerabilities (CWE 415).
    See CERT C rule MEM30-C, “Do not access freed memory,” for more information on
    these topics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting the Pointer to Null</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To limit the opportunity for defects involving dangling pointers, set the pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> after completing
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Any future attempt to dereference the pointer will usually result in a crash,
    increasing the likelihood that the error is detected during implementation and
    testing. If the pointer is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>,
    the memory can be freed multiple times without consequence. Unfortunately, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function cannot set
    the pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> itself
    because it’s passed a copy of the pointer and not the actual pointer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory States</samp>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamically allocated memory can exist in one of three states shown in [Figure
    6-1](chapter6.xhtml#fig6-1): unallocated and uninitialized within the memory manager,
    allocated but uninitialized, and allocated and initialized. Calls to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    functions, as well as writing the memory, cause the memory to transition between
    states.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f06001.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Memory states</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Different operations are valid depending on the state of the memory. Avoid any
    operation on memory that’s not shown as valid or explicitly listed as invalid.
    Following execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function in this code snippet
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: the first 50 bytes are allocated and initialized, while the last 50 bytes are
    allocated but uninitialized. Initialized bytes can be read, but uninitialized
    bytes must not be read.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Flexible Array Members</samp>
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allocating storage for a structure that contains an array has always been a
    little tricky in C. There’s no problem if the array has a fixed number of elements,
    as the size of the structure can easily be determined. Developers, however, frequently
    need to declare an array whose size is unknown until runtime, and originally,
    C offered no straightforward way to do so.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Flexible array members let you declare and allocate storage for a structure
    with any number of fixed members, where the last member is an array of unknown
    size. Starting with C99, the last member of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    with more than one member can have an *incomplete array type*, which means that
    the array has an unknown size that you can specify at runtime. A flexible array
    member allows you to access a variable-length object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 6-5](chapter6.xhtml#Lis6-5) shows the use of a flexible
    array member <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>. We dynamically allocate
    storage for the object by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Flexible array
    members</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We first declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    whose last member, the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    array ❶, is an incomplete type (with no specified size). We then allocate storage
    for the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> ❷.
    When computing the size of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    containing a flexible array member using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, the flexible array member is ignored. Therefore, we must explicitly
    include an appropriate size for the flexible array member when allocating storage.
    To accomplish that, we allocate additional bytes for the array by multiplying
    the number of elements in the array (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>)
    by the size of each element (<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>).
    This program assumes that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>
    is such that when multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>,
    wraparound won’t occur.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We can access this storage by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator ❸, as if the
    storage had been allocated as <samp class="SANS_TheSansMonoCd_W5Regular_11">data[num_elem]</samp>.
    See CERT C rule MEM33-C, “Allocate and copy structures containing a flexible array
    member dynamically,” for more information on allocating and copying structures
    containing flexible array members.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C99, multiple compilers supported a similar “<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    hack” using a variety of syntaxes. CERT C rule DCL38-C, “Use the correct syntax
    when declaring a flexible array member, ” is a reminder to use the syntax specified
    in C99 and later versions of the C standard.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Dynamically Allocated Storage</samp>
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C has language and library features beyond the memory management functions that
    support dynamically allocated storage. This storage is typically allocated in
    the stack frame of the caller (the C standard does not define a stack, but it’s
    a common implementation feature). A *stack* is a last-in-first-out (LIFO) data
    structure that supports nested invocation of functions at runtime. Each function
    invocation creates a *stack frame* in which local variables (of automatic storage
    duration) and other data specific to that invocation of the function can be stored.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">alloca</samp>
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For performance reasons, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    (a nonstandard function supported by some implementations) allows dynamic allocation
    at runtime from the stack rather than the heap. This memory is automatically released
    when the function that called <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function
    is an *intrinsic* (or *built-in*) function, which is specially handled by the
    compiler. This allows the compiler to substitute a sequence of automatically generated
    instructions for the original function call. For example, on the x86 architecture,
    the compiler substitutes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    with a single instruction to adjust the stack pointer to accommodate the additional
    storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function originated
    in an early version of the Unix operating system from Bell Laboratories but is
    not defined by the C standard library or POSIX. [Listing 6-6](chapter6.xhtml#Lis6-6)
    shows an example function called <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function
    to allocate storage for an error string before printing it out to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The</samp> <samp
    class="I">printerr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> function takes
    a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">errnum</samp>,
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp> type. We call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> function
    ❶ to determine the length of the error string associated with this error number.
    Once we know the size of the array that we need to allocate to hold the error
    string, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function ❷ to efficiently allocate storage for the array. We then retrieve the
    error string by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function ❸ and store the result in the newly allocated storage <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>
    references. Assuming the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function succeeds, we output the error message ❹; otherwise, we output <samp class="SANS_TheSansMonoCd_W5Regular_11">unknown
    error</samp> ❺. This <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    function is written to demonstrate the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    and is more complicated than it needs to be.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function can
    be tricky to use. First, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    can make allocations that exceed the bounds of the stack. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function doesn’t return a null pointer value, so there’s no way to check for the
    error. For this reason, it’s critically important to avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    with large or unbounded allocations. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    in this example should return a reasonable allocation size.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A further problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function is that programmers may become confused by having to free memory allocated
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> but not <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>.
    Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> on a pointer
    not obtained by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> is a serious error.
    Due to those issues, the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    is discouraged.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Both GCC and Clang provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca</samp>
    compiler flag that diagnoses all calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function. GCC also provides a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> compiler flag that
    diagnoses any call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function when the requested memory is more than <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp>.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable-Length Arrays</samp>
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variable-length arrays (VLAs) were introduced in C99\. A VLA is an object of
    a variably modified type (covered in [Chapter 2](chapter2.xhtml)). Storage for
    the VLA is allocated at runtime and is equal to the size of the base type of the
    variably modified type multiplied by the runtime extent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The size of the array cannot be modified after you create it. All VLA declarations
    must be at *block scope*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example declares the VLA <samp class="SANS_TheSansMonoCd_W5Regular_11">vla</samp>
    of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> as an automatic
    variable in function <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: VLAs are useful when you don’t know the number of elements in the array until
    runtime. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, VLAs are freed when the corresponding block ends, just like any other
    automatic variable. [Listing 6-7](chapter6.xhtml#Lis6-7) replaces the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    function from [Listing 6-6](chapter6.xhtml#Lis6-6) with a VLA. The change modifies
    just a single line of code (shown in bold).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The</samp> <samp
    class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    rewritten to use a VLA</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using VLAs instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function is that the syntax matches the programmer’s model of how arrays with
    automatic storage duration work. VLAs work just like automatic variables (because
    they are). Another advantage is that memory does not accumulate while iterating
    (which can accidentally happen with <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    because memory is released at the end of the function).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: VLAs share some of the problems of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, in that they can attempt to make allocations that exceed the bounds
    of the stack. Unfortunately, there’s no portable way to determine the remaining
    stack space to detect such an error. Also, the calculation of the array’s size
    could wrap around when the size you provide is multiplied by the size of each
    element. For those reasons, it’s important to validate the size of the array before
    declaring it to avoid overly large or incorrectly sized allocations. This can
    be especially important in functions that are called with untrusted inputs or
    are called recursively, because a complete new set of automatic variables for
    the functions (including these arrays) will be created for each recursion. Untrusted
    inputs must be validated before being used for any allocations, including from
    the heap.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: You should determine whether you have sufficient stack space in the worst-case
    scenario (maximum-sized allocations with deep recursions). On some implementations,
    it’s also possible to pass a negative size to the VLA, so make sure your size
    is represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    or other unsigned type. See CERT C rule ARR32-C, “Ensure size arguments for variable-length
    arrays are in a valid range,” for more information. VLAs reduce stack usage when
    compared to using worst-case fixed-sized arrays.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file-scope declarations demonstrate another confusing aspect
    of VLAs:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Is this code valid? If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    is a VLA, then the code is invalid, because the declaration is at file scope.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a constant-sized
    array, then the code is valid. GCC currently rejects this example because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a VLA. However, C23 allows
    implementations to extend the definition of an integer constant expression, which
    Clang does by making <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    a constant-sized array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite these declarations to be portable using <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    on all C23-conforming implementations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, another interesting and unexpected behavior occurs when calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> on a VLA. The compiler usually
    performs the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operation
    at compile time. However, if the expression changes the size of the array, it
    will be evaluated at runtime, including any side effects. The same is true of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>, as the program in
    [Listing 6-8](chapter6.xhtml#Lis6-8) shows.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: Unexpected side
    effects</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In this simple test program, we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> and initialize
    it to <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The operand in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(size++)</samp> isn’t evaluated
    because the type of the operand is not a VLA. Consequently, the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> doesn’t change. We then call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int[size++]</samp> as the argument.
    Because this expression changes the size of the array, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    is incremented and is now equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> similarly increments
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">14</samp>. Finally, we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to be of <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof(int[size++])</samp>,
    which further increments <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>.
    Because these behaviors aren’t well understood, avoid using expressions with side
    effects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operators, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>s to improve understandability.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging Allocated Storage Problems</samp>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, improper memory management can lead to errors
    like leaking memory, reading from or writing to freed memory, and freeing memory
    more than once. One way to avoid some of these problems is to set pointers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> null pointer value after
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, as we’ve already
    discussed. Another strategy is to keep your dynamic memory management as simple
    as possible. For example, you should allocate and free memory in the same module,
    at the same level of abstraction, rather than freeing memory in subroutines, which
    leads to confusion about if, when, and where memory is freed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A third option is to use *dynamic analysis tools*, such as AddressSanitizer,
    Valgrind, or <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to detect
    and report memory errors. AddressSanitizer, as well as general approaches to debugging,
    testing, and analysis, are discussed in [Chapter 11](chapter11.xhtml), while <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> is covered in this section.
    AddressSanitizer or Valgrind are effective tools and better choices if they are
    available for your environment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">dmalloc</samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *debug memory allocation* (<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>)
    library Gray Watson created replaces <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, and other memory management
    features with routines that provide debugging facilities that you can configure
    at runtime. The library has been tested on a variety of platforms.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Follow the installation directions provided at *[https://<wbr>dmalloc<wbr>.com](https://dmalloc.com)*
    to configure, build, and install the library. [Listing 6-9](chapter6.xhtml#Lis6-9)
    contains a short program that prints out usage information and exits (it would
    typically be part of a longer program). This program has several intentional errors
    and vulnerabilities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Catching a memory
    bug with</samp> <samp class="I">dmalloc</samp>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent versions of glibc will detect at least one of the vulnerabilities from
    this program:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After repairing this error, include the lines shown in bold font to allow <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to report the file and
    line numbers of calls that cause problems.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll show the output later, but we need to discuss a few things first. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> distribution also
    comes with a command line utility. You can run the following command to get further
    information on how to use this utility:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before debugging your program with <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>,
    enter the following at the command line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command sets the logfile name to *logfile* and instructs the library to
    perform a check after <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    invocations, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> argument
    specifies. If you specify a larger number as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> will check
    the heap less often, and your code will run faster; lower numbers are more likely
    to catch memory problems. The third argument enables a <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp>
    number of debug features. Other options include <samp class="SANS_TheSansMonoCd_W5Regular_11">runtime</samp>
    for minimal checking or <samp class="SANS_TheSansMonoCd_W5Regular_11">medium</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">high</samp> for more extensive
    heap verification.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing this command, we can compile the program by using GCC as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you run the program, you should see the following error:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And if you examine the logfile, you’ll find the following information:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These messages indicate that we’ve attempted to free the storage referenced
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">errmsg</samp> twice, first in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">usage</samp> function and then
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, which constitutes
    a double-free vulnerability. Of course, this is just a single example of the types
    of bugs that <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> can
    detect, and other defects exist in the simple program we are testing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safety-Critical Systems</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Systems with high safety requirements frequently ban the use of dynamic memory
    because memory managers can have unpredictable behavior that significantly impacts
    performance. Forcing all applications to live within a fixed, preallocated area
    of memory can eliminate these problems and make it easier to verify memory use.
    In the absence of recursion, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>,
    and VLAs (also prohibited in safety-critical systems), an upper bound on the use
    of stack memory can be derived statically, making it possible to prove that sufficient
    storage exists to execute the functionality of the application for all possible
    inputs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Both GCC and Clang have a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla</samp>
    flag that warns if a VLA is used. GCC also has a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp> flag that warns
    for declarations of VLAs whose size is either unbounded or bounded by an argument
    that allows the array size to exceed <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp>
    bytes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about working with memory that has allocated storage
    duration and how this differs from objects of either automatic or static storage
    duration. We described the heap and memory managers and each of the standard memory
    management functions. We identified some common causes of errors when using dynamic
    memory, such as leaks and double-free vulnerabilities, and introduced some mitigations
    to help avoid these problems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We also covered some more specialized memory allocation topics such as flexible
    array members, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, and VLAs. We concluded the chapter with a discussion of debugging allocated
    storage problems by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about characters and strings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
