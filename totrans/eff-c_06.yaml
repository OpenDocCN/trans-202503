- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DYNAMICALLY
    ALLOCATED MEMORY</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">动态分配内存</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In [Chapter 2](chapter2.xhtml), you learned that every object has a storage
    duration that determines its lifetime and that C defines four storage durations:
    static, thread, automatic, and allocated. In this chapter, you’ll learn about
    *dynamically allocated memory*, which is allocated from the heap at runtime. Dynamically
    allocated memory is useful when the exact storage requirements for a program are
    unknown before runtime.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](chapter2.xhtml)中，你学到了每个对象都有一个存储持续时间，决定了它的生命周期，C语言定义了四种存储持续时间：静态、线程、自动和分配。在本章中，你将学习*动态分配内存*，它是在运行时从堆中分配的。动态分配内存在程序运行前无法确定精确的存储需求时非常有用。
- en: We’ll first describe the differences between allocated, static, and automatic
    storage duration. We’ll skip thread storage allocation as this involves parallel
    execution, which we don’t cover here. We’ll then explore the functions you can
    use to allocate and deallocate dynamic memory, common memory allocation errors,
    and strategies for avoiding them. The terms *memory* and *storage* are used interchangeably
    in this chapter, similar to the way they’re used in practice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述分配存储、静态存储和自动存储持续时间之间的区别。我们将跳过线程存储分配，因为它涉及并行执行，而我们在此不涉及。然后我们将探讨你可以使用的函数来分配和释放动态内存、常见的内存分配错误以及避免这些错误的策略。在本章中，*内存*和*存储*这两个术语可以互换使用，类似于它们在实际应用中的用法。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">存储持续时间</samp>'
- en: Objects occupy *storage*, which might be read-write memory, read-only memory,
    or central processing unit (CPU) registers. Storage of allocated duration has
    significantly different properties from storage of either automatic or static
    storage duration. First, we’ll review automatic and static storage duration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对象占用*存储空间*，存储空间可能是可读写内存、只读内存或中央处理单元（CPU）寄存器。分配持续时间的存储与自动或静态存储持续时间的存储具有显著不同的特性。首先，我们将回顾自动和静态存储持续时间。
- en: Objects of *automatic storage duration* are declared within a block or as a
    function parameter. The lifetime of these objects begins when the block in which
    they are declared begins execution and ends when execution of the block ends.
    If the block is entered recursively, a new object is created each time, each with
    its own storage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动存储持续时间*的对象在一个代码块内声明，或作为函数参数声明。这些对象的生命周期从包含它们的代码块开始执行时开始，到代码块执行结束时结束。如果该代码块递归进入，每次都会创建一个新的对象，每个对象都有自己的存储空间。'
- en: Objects declared at file scope have *static storage duration*. The lifetime
    of these objects is the entire execution of the program, and their stored value
    is initialized prior to program startup. You can also declare a variable within
    a block to have static storage duration by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage-class specifier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件作用域内声明的对象具有*静态存储持续时间*。这些对象的生命周期是程序执行的整个过程，它们的存储值在程序启动前就已经初始化。你还可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp>存储类说明符，在一个代码块内声明一个变量，使其具有静态存储持续时间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Heap and Memory
    Managers</samp>
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">堆和内存管理器</samp>
- en: Dynamically allocated memory has *allocated storage duration*. The lifetime
    of an allocated object extends from the allocation until the deallocation. Dynamically
    allocated memory is allocated from the *heap*, which is simply one or more large,
    subdividable blocks of memory managed by the memory manager.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的内存具有*分配存储持续时间*。分配对象的生命周期从分配开始，一直到释放为止。动态分配内存是从*堆*中分配的，堆只是一个或多个由内存管理器管理的大型、可细分的内存块。
- en: '*Memory managers* are libraries that manage the heap for you by providing implementations
    of the standard memory management functions described in this chapter. A memory
    manager runs as part of the client process. The memory manager requests one or
    more blocks of memory from the operating system (OS) and then allocates this memory
    to the client process when it invokes a memory allocation function. Allocation
    requests don’t go directly to the OS because it’s slower and works only in big
    chunks of memory, whereas allocators split up those big chunks into little chunks
    and are faster.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存管理器*是通过提供本章所描述的标准内存管理函数实现的库，负责为你管理堆。内存管理器作为客户端进程的一部分运行。当客户端进程调用内存分配函数时，内存管理器会向操作系统（OS）请求一个或多个内存块，并将这些内存分配给客户端进程。分配请求不会直接发送到操作系统，因为操作系统较慢，并且只能处理大块内存，而分配器则将这些大块内存分割成小块，从而提高速度。'
- en: Memory managers manage unallocated and deallocated memory only. Once memory
    has been allocated, the caller manages the memory until it’s returned. It’s the
    caller’s responsibility to ensure that the memory is deallocated, although most
    implementations will reclaim dynamically allocated memory when the program terminates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理器仅管理未分配和已释放的内存。一旦内存被分配，调用者将管理该内存，直到它被归还。确保内存被释放是调用者的责任，尽管大多数实现会在程序终止时回收动态分配的内存。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When to Use Dynamically
    Allocated Memory</samp>
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">何时使用动态分配的内存</samp>
- en: As previously mentioned, dynamically allocated memory is used when the exact
    storage requirements for a program are unknown before runtime. Dynamically allocated
    memory is less efficient than statically allocated memory because the memory manager
    needs to find appropriately sized blocks of memory in the runtime heap, and the
    caller must explicitly free those blocks when no longer needed, all of which requires
    additional processing. Dynamically allocated memory also requires additional processing
    for housekeeping operations such as *defragmentation* (the consolidation of adjacent
    free blocks), and the memory manager often uses extra storage for control structures
    to facilitate these processes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当程序的确切存储需求在运行时之前无法确定时，会使用动态分配的内存。动态分配的内存比静态分配的内存效率低，因为内存管理器需要在运行时堆中找到合适大小的内存块，而且调用者必须在不再需要时显式释放这些内存块，所有这些都需要额外的处理。动态分配的内存还需要额外的处理用于日常维护操作，例如*碎片整理*（合并相邻的空闲块），并且内存管理器通常会使用额外的存储来存放控制结构，以便支持这些操作。
- en: '*Memory leaks* occur when dynamically allocated memory that’s no longer needed
    isn’t returned to the memory manager. If these memory leaks are severe, the memory
    manager eventually won’t be able to satisfy new requests for storage.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存泄漏*发生在动态分配的内存不再需要时没有归还给内存管理器。如果内存泄漏严重，内存管理器最终将无法满足新的存储请求。'
- en: By default, you should declare objects with either automatic or static storage
    duration for objects whose sizes are known at compilation time. Dynamically allocate
    memory when the size of the storage or the number of objects is unknown before
    runtime. For example, you might use dynamically allocated memory to read a table
    from a file at runtime, especially if you do not know the number of rows in the
    table at compile time. Similarly, you might use dynamically allocated memory to
    create linked lists, hash tables, binary trees, or other data structures for which
    the number of data elements held in each container is unknown at compile time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对于那些在编译时已知大小的对象，应声明为具有自动或静态存储持续时间的对象。当存储大小或对象数量在运行时才能确定时，应动态分配内存。例如，你可能会使用动态分配的内存在运行时从文件中读取表格，尤其是在编译时不知道表格的行数时。类似地，你可能会使用动态分配的内存来创建链表、哈希表、二叉树或其他数据结构，这些结构中每个容器所包含的数据元素的数量在编译时是无法知道的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory Management</samp>
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内存管理</samp>
- en: 'The C standard library defines memory management functions for allocating (for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>) and deallocating
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>) dynamic memory. The
    OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    is not defined by the C standard library but can be useful for memory allocation.
    C23 added two additional deallocation functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库定义了内存管理函数，用于分配（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>）和释放（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp>）动态内存。OpenBSD 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    函数不是 C 标准库的一部分，但在内存分配中可能会有所帮助。C23 增加了两个额外的内存释放函数：<samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>。
- en: Dynamically allocated memory is required to be suitably aligned for objects
    up to the requested size, including arrays and structures. C11 introduced the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function for
    hardware with stricter-than-normal memory alignment requirements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的内存需要根据请求的大小进行适当对齐，包括数组和结构体。C11 引入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    函数，以支持具有更严格内存对齐要求的硬件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">malloc</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">malloc</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates
    space for an object of a specified size. The representation of the returned storage
    is indeterminate. In [Listing 6-1](chapter6.xhtml#Lis6-1), we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function to dynamically allocate storage for an object the size of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    widget</samp>.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 函数为指定大小的对象分配空间。返回的存储表示是未确定的。在
    [Listing 6-1](chapter6.xhtml#Lis6-1) 中，我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    函数为一个大小为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct widget</samp> 的对象动态分配存储空间。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Allocating storage
    for a widget with the</samp> <samp class="I">malloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: 使用</samp> <samp
    class="I">malloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数为一个
    widget 分配存储空间</samp>'
- en: All memory allocation functions accept an argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    that specifies the number of bytes of memory to be allocated ❶. For portability,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator
    when calculating the size of objects, because the size of objects of distinct
    types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, may differ among implementations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内存分配函数都接受一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    的参数，指定要分配的内存字节数 ❶。为了移植性，我们在计算对象的大小时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    运算符，因为不同类型的对象（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>）的大小在不同实现中可能不同。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function returns
    either a null pointer to indicate an error or a pointer to the allocated space.
    Therefore, we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    returns a null pointer ❷ and appropriately handles the error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 函数返回一个空指针表示错误，或者返回指向分配空间的指针。因此，我们检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 是否返回空指针 ❷，并适当地处理错误。
- en: After the function successfully returns the allocated storage, we can reference
    members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp> structure
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">p->i</samp> accesses the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> member of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>,
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">p->d</samp> accesses the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> member.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数成功返回分配的存储后，我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    指针引用 <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp> 结构体的成员。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p->i</samp> 访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 成员，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">p->d</samp>
    访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 成员。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Allocating Memory Without
    Declaring a Type</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在不声明类型的情况下分配内存</samp>
- en: 'You can store the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> pointer to avoid
    declaring a type for the referenced object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的返回值存储为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 指针，以避免为引用的对象声明类型：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    pointer, which was the convention before the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type was introduced to C:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 指针，这是在引入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型之前的惯例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In either case, the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    points to has no type until an object is copied into this storage. Once that occurs,
    the object has the *effective type* of the last object copied into this storage,
    which imprints the type onto the allocated object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 指向的对象在将对象复制到此存储中之前是没有类型的。一旦发生这种情况，该对象将具有最后一个复制到此存储中的对象的*有效类型*，这会将类型印在分配的对象上。
- en: 'In the following example, the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references has an effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 所引用的存储具有有效的类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>,
    the change of effective type influences optimizations and nothing else.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> 之后，有效类型的变化会影响优化，但不会产生其他影响。
- en: Because allocated memory can store any sufficiently small object type, pointers
    returned by allocation functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    must be sufficiently aligned. For example, if an implementation has objects with
    1-, 2-, 4-, 8-, and 16-byte alignments and 16 or more bytes of storage are allocated,
    the alignment of the returned pointer is a multiple of 16.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分配的内存可以存储任何足够小的对象类型，因此分配函数返回的指针，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>，必须具有足够的对齐。例如，如果实现中有对齐为1字节、2字节、4字节、8字节和16字节的对象，并且分配了16字节或更多字节的存储，则返回指针的对齐方式是16的倍数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reading Uninitialized Memory</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">读取未初始化的内存</samp>
- en: The contents of memory returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    are *uninitialized*, which means it has an indeterminate representation. Reading
    uninitialized memory is never a good idea; think of it as undefined behavior.
    If you’d like to know more, I wrote an in-depth article on uninitialized reads
    (Seacord 2017). The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function doesn’t initialize the returned memory because you are expected to overwrite
    this memory anyway.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 返回的内存内容是*未初始化的*，这意味着它具有不确定的表示。读取未初始化的内存从来都不是一个好主意；可以将其视为未定义行为。如果你想了解更多，我写了一篇关于未初始化读取的深入文章（Seacord
    2017）。<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 函数不会初始化返回的内存，因为你预计最终会覆盖这块内存。
- en: Even so, beginners commonly make the mistake of assuming that the memory <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns contains zeros.
    The program shown in [Listing 6-2](chapter6.xhtml#Lis6-2) makes this exact error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，初学者常常犯一个错误，认为通过<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>返回的内存已包含零值。程序中[示例6-2](chapter6.xhtml#Lis6-2)就犯了这个错误。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An initialization
    error</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例6-2：初始化错误</samp>
- en: This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to allocate 16 bytes of memory and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>
    to copy the first 15 bytes of a string into the allocated memory. The programmer
    attempts to create a properly null-terminated string by copying one fewer byte
    than the size of the allocated memory. In doing so, the programmer assumes that
    the allocated storage already contains a zero value to serve as the null byte.
    However, the storage could easily contain nonzero values, in which case the string
    wouldn’t be properly null terminated, and the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    would result in undefined behavior.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序调用<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>分配16字节内存，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>将字符串的前15个字节复制到分配的内存中。程序员试图通过复制比分配的内存大小少一个字节来创建一个正确的空终止字符串。这样，程序员假设分配的存储区域已经包含零值，作为空字符。然而，存储区域很可能包含非零值，这样字符串就无法正确地以空字符终止，而调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>将导致未定义行为。
- en: 'A common solution is to write a null character into the last byte of the allocated
    storage, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是将空字符写入分配的存储区域的最后一个字节，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the source string (the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"123456789abcdef"</samp>
    in this example) has fewer than 15 bytes, the null termination character will
    be copied, and the assignment ❶ is unnecessary. If the source string has 15 bytes
    or longer, adding this assignment ensures that the string is properly null terminated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源字符串（本例中的字符串字面量<samp class="SANS_TheSansMonoCd_W5Regular_11">"123456789abcdef"</samp>）的字节数少于15字节，则会复制空终止字符，此时不需要执行赋值操作❶。如果源字符串的字节数为15字节或更多，添加此赋值操作可以确保字符串正确地以空字符终止。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">aligned_alloc</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">aligned_alloc</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function
    is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function, except that it requires you to provide an alignment as well as a size
    for the allocated object. The function has the following signature, where <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> specifies the object’s size
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> specifies its
    alignment:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>函数与<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>函数类似，不同之处在于它要求你提供对齐方式以及分配对象的大小。该函数具有以下签名，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp>指定对象的大小，<samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>指定其对齐方式：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although C requires the dynamically allocated memory from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to be sufficiently aligned for all standard types, including arrays and structures,
    you might occasionally need to override the compiler’s default choices. You can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function
    to request stricter alignment than the default (in other words, a larger power
    of two). If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    is not a valid alignment supported by the implementation, the function fails by
    returning a null pointer. See [Chapter 2](chapter2.xhtml) for more information
    on alignment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C语言要求通过<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>分配的动态内存对所有标准类型（包括数组和结构体）进行适当对齐，但有时你可能需要覆盖编译器的默认选择。你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>函数来请求比默认值更严格的对齐（换句话说，使用更大的2的幂次）。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>的值不是实现所支持的有效对齐，函数会返回一个空指针来表示失败。有关对齐的更多信息，请参见[第2章](chapter2.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">calloc</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">calloc</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> function allocates
    storage for an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    objects, each of whose size is <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    bytes. It has the following signature:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>函数为一个包含<samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>个对象的数组分配存储，每个对象的大小为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp>字节。它具有以下签名：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function initializes the storage to all zero-valued bytes. These zero values
    might not be the same one used to represent floating-point zero or null-pointer
    constants. You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    function to allocate storage for a single object, which can be thought of as an
    array of one element.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将存储初始化为全零字节。这些零值可能不同于用来表示浮点零或空指针常量的值。你还可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>函数为单个对象分配存储，可以将其视为一个包含一个元素的数组。
- en: Internally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    function works by multiplying <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to determine the
    required number of bytes to allocate. Historically, some <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    implementations failed to validate that these values wouldn’t wrap around when
    multiplied. C23 requires this test, and modern implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    return a null pointer if the space cannot be allocated or if the product <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nmemb * size</samp> would wrap around.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>函数通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>乘以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp>来确定所需的字节数。历史上，一些<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>实现没有验证这些值在相乘时是否会发生溢出。C23要求进行此测试，现代的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>实现如果无法分配空间，或者如果乘积<samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb
    * size</samp>会发生溢出，则返回空指针。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">realloc</samp>
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">realloc</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function increases
    or decreases the size of previously allocated storage. It takes a pointer to memory
    allocated by an earlier call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned
    _alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    (or a null pointer) and a size and has the following signature:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数增加或减少先前分配的存储空间的大小。它接受一个指向由先前调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned _alloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>（或者一个空指针）分配的内存的指针，以及一个大小，并具有以下签名：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function to grow or (less commonly) shrink the size of an array.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数来增加或（较少见的情况）减少数组的大小。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Avoiding Memory Leaks</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">避免内存泄漏</samp>
- en: 'To avoid introducing bugs when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    you should understand how this function is specified. If the newly allocated storage
    is larger than the old contents, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    leaves the additional storage uninitialized. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    succeeds in allocating the new object, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to deallocate the old object. The pointer to the new object may have the same
    value as a pointer to the old object. If the allocation fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function retains the old object data at the same address and returns a null pointer.
    A call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> can fail,
    for example, when insufficient memory is available to allocate the requested number
    of bytes. The following use of <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    might be erroneous:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 时引入 bug，你应该理解该函数的具体规格。如果新分配的存储空间大于原有内容，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 会将额外的存储空间置为未初始化状态。如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 成功分配了新的对象，它会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    来释放旧对象的存储空间。指向新对象的指针可能与指向旧对象的指针值相同。如果分配失败，<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    函数会保留旧对象的数据并返回空指针。<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    调用可能会失败，例如，当没有足够的内存来分配所请求的字节数时。以下使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    的方式可能是错误的：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is
    incremented by 50 before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    to increase the size of the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references. If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    fails, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned a null
    pointer value, but <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    doesn’t deallocate the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    references, resulting in this memory being leaked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> 在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    增加 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 所引用的存储空间的大小之前，增加了 50。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 调用失败，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    会被赋值为空指针，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 不会释放 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 所引用的存储空间，导致内存泄漏。
- en: '[Listing 6-3](chapter6.xhtml#Lis6-3) demonstrates the correct use of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-3](chapter6.xhtml#Lis6-3) 演示了正确使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    函数的示例。'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An example of
    the correct use of the</samp> <samp class="I">realloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-3：正确使用</samp> <samp class="I">realloc</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数的示例</samp>
- en: '[Listing 6-3](chapter6.xhtml#Lis6-3) declares two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>. The variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp> refers to the dynamically allocated
    memory <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> starts out uninitialized.
    Eventually, this memory is resized, which we accomplish by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer
    and the new <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp> size. The
    return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    is assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> to avoid
    overwriting the pointer stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> returns a null
    pointer, the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references
    is freed, and the function returns a null pointer. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    succeeds and returns a pointer to an allocation of size <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned the pointer
    to the newly reallocated storage, and execution continues.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](chapter6.xhtml#Lis6-3)声明了两个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>。变量<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>引用动态分配的内存，这是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>返回的内存，<samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>初始时未初始化。最终，这块内存会被调整大小，我们通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数，并传入<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>指针和新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>大小来完成。<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>的返回值会被赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>，以避免覆盖存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>中的指针。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>返回一个空指针，那么<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>引用的内存将会被释放，并且函数将返回空指针。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>成功并返回指向大小为<samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>的分配的指针，则<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>将被赋值为指向新分配内存的指针，程序继续执行。'
- en: This code also includes a test for a zero-byte allocation. Avoid passing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function a value
    of 0 as the size argument, as that is undefined behavior (as clarified in C23).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还包括了对零字节分配的测试。避免将值为 0 的大小参数传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数，因为这会导致未定义行为（如C23中所阐明）。
- en: 'If the following call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    function doesn’t return a null pointer, the address stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is invalid and can no longer be read:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下对<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>函数的调用没有返回空指针，那么存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>中的地址就是无效的，不能再进行读取：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In particular, the following test is not allowed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，以下测试是不允许的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Any pointers that reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    previously pointed to must be updated to reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">newp</samp>
    pointed to after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    kept the same address for the storage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任何引用<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>之前所指向内存的指针，都必须更新为引用调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>之后指向的新内存<samp class="SANS_TheSansMonoCd_W5Regular_11">newp</samp>，无论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>是否保留了相同的内存地址。
- en: One solution to this problem is to go through an extra indirection, sometimes
    called a *handle*. If all uses of the reallocated pointer are indirect, they’ll
    all be updated when that pointer is reassigned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是通过额外的间接方式，有时称为*句柄*。如果重新分配的指针的所有使用都是间接的，当该指针重新赋值时，它们都会被更新。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling realloc with a Null
    Pointer</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">调用 realloc 时传递空指针</samp>
- en: Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> with a
    null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>.
    Provided <samp class="SANS_TheSansMonoCd_W5Regular_11">newsize</samp> isn’t equal
    to 0, we can replace the following code
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用空指针调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 等同于调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>。只要 <samp class="SANS_TheSansMonoCd_W5Regular_11">newsize</samp>
    不等于 0，我们就可以用以下代码替代：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'with this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下代码：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first, longer version of this code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    for the initial allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    to adjust the size later as required. Because calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    with a null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    the second version concisely accomplishes the same thing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个较长版本的代码首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 进行初始分配，然后根据需要调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 来调整大小。因为用空指针调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 等价于调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>，所以第二个版本简洁地完成了相同的操作。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">reallocarray</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">reallocarray</samp>'
- en: 'As we have seen in previous chapters, both signed integer overflow and unsigned
    integer wraparound are serious problems that can result in buffer overflows and
    other security vulnerabilities. In the following code snippet, for example, the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">num * size</samp> might
    wrap around before being passed as the size argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中看到的，带符号整数溢出和无符号整数回绕是严重的问题，可能导致缓冲区溢出和其他安全漏洞。例如，在下面的代码片段中，表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">num
    * size</samp> 可能会在作为大小参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>
    时发生回绕：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function can reallocate storage for an array, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    it checks for wraparound during array size calculations, which saves you from
    having to perform these checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function has the following signature:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    函数可以重新分配数组的存储空间，但像 <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>
    一样，它在数组大小计算过程中会检查回绕，从而省去了你自己执行这些检查的需要。<samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    函数的函数签名如下：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    allocates storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    members of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> and
    checks for wraparound in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb
    * size</samp> calculation. Other platforms, including the GNU C Library (libc),
    have adopted this function, and it has been proposed for inclusion in the next
    revision of the POSIX standard. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function does not zero out the allocated storage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> 函数为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp> 个大小为 <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    的成员分配存储，并检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb * size</samp>
    计算是否发生回绕。包括 GNU C 库 (libc) 在内的其他平台已经采用了此函数，并且该函数已被提议纳入下一个 POSIX 标准版本中。<samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    函数不会将分配的存储空间清零。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function
    is useful when two values are multiplied to determine the size of the allocation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> 函数在需要通过两个值相乘来确定分配大小时非常有用：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp>
    function will fail and return a null pointer if <samp class="SANS_TheSansMonoCd_W5Regular_11">num
    * size</samp> would wrap around.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">num * size</samp> 会发生回绕，则调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> 函数将失败，并返回空指针。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free</samp>
- en: When it’s no longer needed, memory can be deallocated using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function. Deallocating memory allows that memory to be reused, reducing the chances
    that you’ll exhaust the available memory and often providing more efficient use
    of the heap.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要时，可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>函数释放内存。释放内存允许该内存被重用，减少了内存耗尽的机会，并且通常提供了更高效的堆使用。
- en: 'We can deallocate memory by passing a pointer to that memory to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function, which has the following signature:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将指向该内存的指针传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>函数来释放内存，该函数具有以下签名：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> value must have
    been returned by a previous call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc,
    aligned_alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>. CERT C rule MEM34-C,
    “Only free memory allocated dynamically,” discusses what happens when the value
    is not returned. Memory is a limited resource and so must be reclaimed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>值必须是之前调用<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>返回的值。CERT C规则MEM34-C，“仅释放动态分配的内存”，讨论了当值没有被返回时会发生什么。内存是有限资源，因此必须回收。
- en: 'If we call <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> with a
    null-pointer argument, nothing happens, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function simply returns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用空指针参数调用<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>，什么也不会发生，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp>函数只是返回：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Freeing the same pointer twice, on the other hand, is a serious error.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，重复释放同一指针是一个严重的错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_sized</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_sized</samp>
- en: 'C23 introduced two new memory deallocation functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>
    function has the following signature:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C23引入了两个新的内存释放函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>函数具有以下签名：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer
    or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is equal to the
    requested allocation size, this function behaves the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>.
    You cannot pass the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    to this function; you must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function (described in the next section). By *reminding* the allocator of the
    size of that allocation, you can reduce deallocation cost and allow extra security-hardening
    functionality. However, if you specify the size incorrectly, the behavior is undefined.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>是空指针，或者是通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>获得的结果，其中<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>等于请求的分配大小，则此函数的行为与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>相同。不能将<samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>的结果传递给此函数；必须使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>函数（将在下一节中描述）。通过*提醒*分配器该分配的大小，您可以减少释放成本，并允许额外的安全性强化功能。但是，如果指定的大小不正确，则行为是未定义的。
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp> function,
    we could improve the performance and safety of the following code
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp>函数，我们可以提高以下代码的性能和安全性。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'by rewriting it as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其重写为：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is feasible and practical when the size of the allocation is retained or
    can be inexpensively re-created.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当保留分配的大小或能够廉价地重新创建时，这是可行且实用的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_aligned_sized</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_aligned_sized</samp>
- en: 'The second of the two new memory deallocation functions that C23 introduced
    is the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function has the following signature:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C23 引入的两个新的内存释放函数中的第二个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp> 函数具有以下签名：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer
    or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> is equal
    to the requested allocation alignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    is equal to the requested allocation size, this function is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>. Otherwise, the behavior
    is undefined. In other words, this function may be used only for deallocating
    explicitly aligned memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 是一个空指针，或者是通过调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> 得到的结果，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    等于请求的分配对齐，且 <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> 等于请求的分配大小，那么此函数等同于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>。否则，行为是未定义的。换句话说，只有在释放显式对齐的内存时，才能使用此函数。
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>
    function, we could improve the performance and safety of the following code
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp> 函数，我们可以通过以下方式提高以下代码的性能和安全性：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'by rewriting it as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其重写为：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is feasible and practical when the alignment and size of the allocation
    is retained or can be inexpensively re-created.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配的对齐和大小得以保留或可以低成本重新创建时，这种做法是可行且实用的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Dangling Pointers</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理悬空指针</samp>
- en: If you call one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    functions on the same pointer more than once, undefined behavior occurs. These
    defects can result in a security flaw known as a *double-free vulnerability*.
    One consequence is that they might be exploited to execute arbitrary code with
    the permissions of the vulnerable process. The full effects of double-free vulnerabilities
    are beyond the scope of this book, but I discuss them in detail in *Secure Coding
    in C and C++* (Seacord 2013). Double-free vulnerabilities are especially common
    in error-handling code, as programmers attempt to free allocated resources.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对同一个指针调用了多次 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 函数，会导致未定义的行为。这些缺陷可能会导致一个被称为
    *双重释放漏洞* 的安全漏洞。一个后果是，它们可能被利用来以易受攻击进程的权限执行任意代码。双重释放漏洞的完整影响超出了本书的范围，但我在《C和C++中的安全编码》（Seacord
    2013）中详细讨论了它们。双重释放漏洞在错误处理代码中尤其常见，因为程序员在尝试释放已分配资源时可能会遇到这些问题。
- en: Another common error is to access memory that has already been freed. This type
    of error frequently goes undetected because the code might appear to work but
    then fails in an unexpected manner away from the actual error. In [Listing 6-4](chapter6.xhtml#Lis6-4),
    taken from an actual application, the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>
    is invalid because the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    has reclaimed the storage <samp class="SANS_TheSansMonoCd_W5Regular_11">dirp</samp>
    formerly pointed to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是访问已释放的内存。这种类型的错误通常不易察觉，因为代码可能看起来正常，但在实际错误发生时，它可能以一种意外的方式失败。在[列表 6-4](chapter6.xhtml#Lis6-4)中，取自一个实际应用，传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp> 的参数无效，因为第二次调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 已经回收了之前由 <samp class="SANS_TheSansMonoCd_W5Regular_11">dirp</samp>
    指向的存储。
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Accessing already
    freed memory</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-4：访问已释放的内存</samp>
- en: We refer to pointers to already freed memory as *dangling pointers*. Dangling
    pointers are a potential source of errors (like a banana peel on the floor). Every
    use of a dangling pointer (not just dereferencing) is undefined behavior. When
    used to access memory that has already been freed, dangling pointers can result
    in use-after-free vulnerabilities (CWE 416). When passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function, dangling pointers can result in double-free vulnerabilities (CWE 415).
    See CERT C rule MEM30-C, “Do not access freed memory,” for more information on
    these topics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称指向已释放内存的指针为 *悬空指针*。悬空指针是潜在的错误来源（就像地板上的香蕉皮）。每次使用悬空指针（不仅仅是解引用）都是未定义行为。当悬空指针用于访问已释放的内存时，可能会导致“释放后使用”漏洞（CWE
    416）。当悬空指针传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 函数时，可能会导致“双重释放”漏洞（CWE
    415）。有关这些主题的更多信息，请参见 CERT C 规则 MEM30-C，“不要访问已释放的内存”。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting the Pointer to Null</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将指针设置为 Null</samp>
- en: 'To limit the opportunity for defects involving dangling pointers, set the pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> after completing
    a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少悬空指针带来的缺陷风险，在完成对 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    函数的调用后，将指针设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Any future attempt to dereference the pointer will usually result in a crash,
    increasing the likelihood that the error is detected during implementation and
    testing. If the pointer is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>,
    the memory can be freed multiple times without consequence. Unfortunately, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function cannot set
    the pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> itself
    because it’s passed a copy of the pointer and not the actual pointer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续尝试解引用指针通常会导致崩溃，从而增加在实施和测试过程中检测到错误的可能性。如果指针被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>，内存可以多次释放而不会产生后果。不幸的是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 函数无法将指针设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>，因为它接收到的是指针的副本，而不是实际的指针。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory States</samp>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内存状态</samp>
- en: 'Dynamically allocated memory can exist in one of three states shown in [Figure
    6-1](chapter6.xhtml#fig6-1): unallocated and uninitialized within the memory manager,
    allocated but uninitialized, and allocated and initialized. Calls to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    functions, as well as writing the memory, cause the memory to transition between
    states.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配的内存可以处于以下三种状态之一，如[图6-1](chapter6.xhtml#fig6-1)所示：内存管理器中未分配且未初始化、已分配但未初始化、已分配且已初始化。对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    函数的调用，以及写入内存，会导致内存在这些状态之间转换。
- en: '![](../images/f06001.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f06001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Memory states</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-1：内存状态</samp>
- en: Different operations are valid depending on the state of the memory. Avoid any
    operation on memory that’s not shown as valid or explicitly listed as invalid.
    Following execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function in this code snippet
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据内存的状态，不同的操作是有效的。避免对未显示为有效或明确列为无效的内存执行任何操作。在此代码片段中执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    函数后，
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: the first 50 bytes are allocated and initialized, while the last 50 bytes are
    allocated but uninitialized. Initialized bytes can be read, but uninitialized
    bytes must not be read.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前50个字节被分配并初始化，而最后50个字节被分配但未初始化。已初始化的字节可以读取，但未初始化的字节不得读取。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Flexible Array Members</samp>
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">灵活数组成员</samp>
- en: Allocating storage for a structure that contains an array has always been a
    little tricky in C. There’s no problem if the array has a fixed number of elements,
    as the size of the structure can easily be determined. Developers, however, frequently
    need to declare an array whose size is unknown until runtime, and originally,
    C offered no straightforward way to do so.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，为包含数组的结构分配存储一直是一个有些棘手的问题。如果数组的元素数量是固定的，那么问题不大，因为结构的大小可以很容易地确定。然而，开发人员经常需要声明一个数组，其大小在运行时才会确定，而
    C 最初并没有提供一种直接的方式来实现这一点。
- en: Flexible array members let you declare and allocate storage for a structure
    with any number of fixed members, where the last member is an array of unknown
    size. Starting with C99, the last member of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    with more than one member can have an *incomplete array type*, which means that
    the array has an unknown size that you can specify at runtime. A flexible array
    member allows you to access a variable-length object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活数组成员让你能够声明并为具有任意数量固定成员的结构分配存储空间，其中最后一个成员是一个大小未知的数组。从 C99 开始，具有多个成员的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> 的最后一个成员可以是 *不完整的数组类型*，这意味着数组的大小未知，可以在运行时指定。灵活数组成员允许你访问一个可变长度的对象。
- en: For example, [Listing 6-5](chapter6.xhtml#Lis6-5) shows the use of a flexible
    array member <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>. We dynamically allocate
    storage for the object by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单 6-5](chapter6.xhtml#Lis6-5)展示了在 <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>
    中使用灵活数组成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>。我们通过调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 函数动态分配该对象的存储空间。
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Flexible array
    members</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-5: 灵活数组成员</samp>'
- en: We first declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    whose last member, the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    array ❶, is an incomplete type (with no specified size). We then allocate storage
    for the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> ❷.
    When computing the size of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    containing a flexible array member using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, the flexible array member is ignored. Therefore, we must explicitly
    include an appropriate size for the flexible array member when allocating storage.
    To accomplish that, we allocate additional bytes for the array by multiplying
    the number of elements in the array (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>)
    by the size of each element (<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>).
    This program assumes that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>
    is such that when multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>,
    wraparound won’t occur.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>，其最后一个成员，即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> 数组 ❶，是一个不完整类型（没有指定大小）。然后，我们为整个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> ❷ 分配存储空间。当使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符计算包含灵活数组成员的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    的大小时，灵活数组成员会被忽略。因此，在分配存储时，我们必须明确地为灵活数组成员指定适当的大小。为此，我们通过将数组元素的数量（<samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>）乘以每个元素的大小（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>）来为数组分配额外的字节。该程序假定 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp> 的值是合适的，以至于当与 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>
    相乘时，不会发生溢出。
- en: We can access this storage by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator ❸, as if the
    storage had been allocated as <samp class="SANS_TheSansMonoCd_W5Regular_11">data[num_elem]</samp>.
    See CERT C rule MEM33-C, “Allocate and copy structures containing a flexible array
    member dynamically,” for more information on allocating and copying structures
    containing flexible array members.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符 ❸ 访问这个存储空间，就像存储空间已经分配为 <samp class="SANS_TheSansMonoCd_W5Regular_11">data[num_elem]</samp>
    一样。有关分配和复制包含灵活数组成员的结构的更多信息，请参见 CERT C 规则 MEM33-C，“动态分配并复制包含灵活数组成员的结构”。
- en: Prior to C99, multiple compilers supported a similar “<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    hack” using a variety of syntaxes. CERT C rule DCL38-C, “Use the correct syntax
    when declaring a flexible array member, ” is a reminder to use the syntax specified
    in C99 and later versions of the C standard.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C99 之前，多个编译器支持一种类似的“`<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    hack”方法，采用不同的语法。CERT C 规则 DCL38-C，“声明灵活数组成员时使用正确的语法”，提醒开发者使用 C99 及更高版本 C 标准中指定的语法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Dynamically Allocated Storage</samp>
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">其他动态分配的存储</samp>
- en: C has language and library features beyond the memory management functions that
    support dynamically allocated storage. This storage is typically allocated in
    the stack frame of the caller (the C standard does not define a stack, but it’s
    a common implementation feature). A *stack* is a last-in-first-out (LIFO) data
    structure that supports nested invocation of functions at runtime. Each function
    invocation creates a *stack frame* in which local variables (of automatic storage
    duration) and other data specific to that invocation of the function can be stored.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言除了支持动态分配存储的内存管理函数之外，还具有语言和库特性。这些存储通常在调用者的栈帧中分配（C 标准并未定义栈，但栈是常见的实现特性）。*栈*
    是一种后进先出（LIFO）的数据结构，支持在运行时的函数嵌套调用。每次函数调用都会创建一个*栈帧*，其中存储了局部变量（自动存储持续时间）和与该函数调用相关的其他数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">alloca</samp>
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">alloca</samp>
- en: For performance reasons, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    (a nonstandard function supported by some implementations) allows dynamic allocation
    at runtime from the stack rather than the heap. This memory is automatically released
    when the function that called <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function
    is an *intrinsic* (or *built-in*) function, which is specially handled by the
    compiler. This allows the compiler to substitute a sequence of automatically generated
    instructions for the original function call. For example, on the x86 architecture,
    the compiler substitutes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    with a single instruction to adjust the stack pointer to accommodate the additional
    storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 出于性能原因，`<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>`（一个由某些实现支持的非标准函数）允许在运行时从栈中动态分配内存，而不是从堆中分配。这块内存会在调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 的函数返回时自动释放。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 函数是一个*内建*（或*内置*）函数，专门由编译器处理。这使得编译器能够用一系列自动生成的指令替代原始的函数调用。例如，在
    x86 架构下，编译器用一条指令来调整栈指针，以容纳额外的存储空间，从而替代对 `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>`
    的调用。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function originated
    in an early version of the Unix operating system from Bell Laboratories but is
    not defined by the C standard library or POSIX. [Listing 6-6](chapter6.xhtml#Lis6-6)
    shows an example function called <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function
    to allocate storage for an error string before printing it out to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 函数起源于贝尔实验室的早期
    Unix 操作系统版本，但并未由 C 标准库或 POSIX 定义。[清单 6-6](chapter6.xhtml#Lis6-6) 显示了一个名为 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>` 的示例函数，该函数使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>`
    函数在打印错误信息到 `<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>` 之前分配存储空间。'
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The</samp> <samp
    class="I">printerr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-6： </samp><samp class="I">printerr</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11"> 函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> function takes
    a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">errnum</samp>,
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp> type. We call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> function
    ❶ to determine the length of the error string associated with this error number.
    Once we know the size of the array that we need to allocate to hold the error
    string, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function ❷ to efficiently allocate storage for the array. We then retrieve the
    error string by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function ❸ and store the result in the newly allocated storage <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>
    references. Assuming the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function succeeds, we output the error message ❹; otherwise, we output <samp class="SANS_TheSansMonoCd_W5Regular_11">unknown
    error</samp> ❺. This <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    function is written to demonstrate the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    and is more complicated than it needs to be.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>` 函数接受一个参数，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">errnum</samp>`，类型为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp>`。我们调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>` 函数❶来确定与该错误号关联的错误字符串的长度。一旦我们知道了需要分配的数组大小来存储错误字符串，我们可以调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 函数❷来高效地为该数组分配存储空间。然后，我们通过调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>` 函数❸来检索错误字符串，并将结果存储在新分配的存储空间
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>` 引用中。假设 `<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>`
    函数成功执行，我们输出错误信息❹；否则，我们输出 `<samp class="SANS_TheSansMonoCd_W5Regular_11">unknown
    error</samp>`❺。这个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>`
    函数是为了演示 `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 的使用，写得比实际需要的要复杂。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function can
    be tricky to use. First, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    can make allocations that exceed the bounds of the stack. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function doesn’t return a null pointer value, so there’s no way to check for the
    error. For this reason, it’s critically important to avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    with large or unbounded allocations. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    in this example should return a reasonable allocation size.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 函数的使用可能比较棘手。首先，调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 可能会导致分配超过堆栈的边界。然而，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 函数不会返回空指针值，因此无法检查错误。由于这个原因，避免使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 进行大规模或不定界的内存分配至关重要。本文中的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>` 调用应该返回一个合理的分配大小。'
- en: A further problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function is that programmers may become confused by having to free memory allocated
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> but not <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>.
    Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> on a pointer
    not obtained by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> is a serious error.
    Due to those issues, the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    is discouraged.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 函数的另一个问题是，程序员可能会因需要释放由
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>` 分配的内存而非由 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>` 分配的内存而感到困惑。在一个没有通过 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>`、`<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>`、`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>` 或 `<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>`
    调用获得的指针上调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>` 是一个严重的错误。由于这些问题，建议避免使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>`。'
- en: Both GCC and Clang provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca</samp>
    compiler flag that diagnoses all calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function. GCC also provides a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> compiler flag that
    diagnoses any call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function when the requested memory is more than <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp>.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 和 Clang 都提供了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca</samp>
    编译器标志，用于诊断所有对 <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> 函数的调用。GCC
    还提供了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> 编译器标志，用于诊断任何对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> 函数的调用，当请求的内存大于 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp>
    时。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable-Length Arrays</samp>
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可变长度数组（VLA）</samp>
- en: Variable-length arrays (VLAs) were introduced in C99\. A VLA is an object of
    a variably modified type (covered in [Chapter 2](chapter2.xhtml)). Storage for
    the VLA is allocated at runtime and is equal to the size of the base type of the
    variably modified type multiplied by the runtime extent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度数组（VLA）是在 C99 中引入的。VLA 是一种变体类型的对象（见[第 2 章](chapter2.xhtml)）。VLA 的存储空间在运行时分配，其大小等于变体类型的基本类型的大小乘以运行时的大小。
- en: The size of the array cannot be modified after you create it. All VLA declarations
    must be at *block scope*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小在创建后不能修改。所有 VLA 声明必须在 *块作用域* 内。
- en: 'The following example declares the VLA <samp class="SANS_TheSansMonoCd_W5Regular_11">vla</samp>
    of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> as an automatic
    variable in function <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例声明了一个大小为 <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> 的 VLA
    <samp class="SANS_TheSansMonoCd_W5Regular_11">vla</samp>，作为函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>
    中的自动变量：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: VLAs are useful when you don’t know the number of elements in the array until
    runtime. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, VLAs are freed when the corresponding block ends, just like any other
    automatic variable. [Listing 6-7](chapter6.xhtml#Lis6-7) replaces the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp>
    function from [Listing 6-6](chapter6.xhtml#Lis6-6) with a VLA. The change modifies
    just a single line of code (shown in bold).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在运行时才知道数组中元素的数量时，VLA 非常有用。与 <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    函数不同，VLA 会在对应的代码块结束时自动释放，就像其他任何自动变量一样。[列表 6-7](chapter6.xhtml#Lis6-7) 将 [列表 6-6](chapter6.xhtml#Lis6-6)
    中 <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> 函数对 <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    的调用替换为 VLA。此更改仅修改了一行代码（如粗体所示）。
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The</samp> <samp
    class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    rewritten to use a VLA</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-7：重新编写的</samp> <samp class="I">print_error</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数，使用了 VLA</samp>
- en: The main advantage of using VLAs instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function is that the syntax matches the programmer’s model of how arrays with
    automatic storage duration work. VLAs work just like automatic variables (because
    they are). Another advantage is that memory does not accumulate while iterating
    (which can accidentally happen with <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    because memory is released at the end of the function).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VLA 代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> 函数的主要优势在于语法与程序员对具有自动存储持续时间的数组工作的理解模型相匹配。VLA
    的工作方式与自动变量相同（因为它们就是自动变量）。另一个优势是，迭代时内存不会积累（而使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    时，内存可能会在函数结束时释放，但也可能发生意外积累）。
- en: VLAs share some of the problems of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, in that they can attempt to make allocations that exceed the bounds
    of the stack. Unfortunately, there’s no portable way to determine the remaining
    stack space to detect such an error. Also, the calculation of the array’s size
    could wrap around when the size you provide is multiplied by the size of each
    element. For those reasons, it’s important to validate the size of the array before
    declaring it to avoid overly large or incorrectly sized allocations. This can
    be especially important in functions that are called with untrusted inputs or
    are called recursively, because a complete new set of automatic variables for
    the functions (including these arrays) will be created for each recursion. Untrusted
    inputs must be validated before being used for any allocations, including from
    the heap.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: VLAs 共享与 <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> 函数相似的问题，因为它们可能会尝试进行超出栈空间的分配。不幸的是，目前没有一种可移植的方式来确定剩余的栈空间以检测此类错误。此外，当你提供的大小乘以每个元素的大小时，数组大小的计算可能会发生溢出。因此，在声明数组之前验证其大小非常重要，以避免分配过大或大小错误。特别是在处理不可信输入或递归调用的函数时，这一点尤为重要，因为每次递归都会为函数（包括这些数组）创建一组全新的自动变量。在进行任何分配之前，必须验证不可信的输入，包括堆上的分配。
- en: You should determine whether you have sufficient stack space in the worst-case
    scenario (maximum-sized allocations with deep recursions). On some implementations,
    it’s also possible to pass a negative size to the VLA, so make sure your size
    is represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    or other unsigned type. See CERT C rule ARR32-C, “Ensure size arguments for variable-length
    arrays are in a valid range,” for more information. VLAs reduce stack usage when
    compared to using worst-case fixed-sized arrays.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在最坏情况下（最大分配和深度递归）判断是否有足够的栈空间。在某些实现中，还可以传递负值作为 VLA 的大小，因此请确保你的大小表示为 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>` 或其他无符号类型。有关更多信息，请参阅 CERT
    C 规则 ARR32-C，"确保变量长度数组的大小参数在有效范围内"。与使用最坏情况的固定大小数组相比，VLAs 减少了栈的使用。
- en: 'The following file-scope declarations demonstrate another confusing aspect
    of VLAs:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件作用域的声明展示了 VLAs 另一个令人困惑的方面：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Is this code valid? If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    is a VLA, then the code is invalid, because the declaration is at file scope.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a constant-sized
    array, then the code is valid. GCC currently rejects this example because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a VLA. However, C23 allows
    implementations to extend the definition of an integer constant expression, which
    Clang does by making <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    a constant-sized array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效吗？如果 `<samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>` 是一个
    VLA，那么代码无效，因为声明是在文件作用域中。如果 `<samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>`
    是一个常量大小的数组，则代码有效。目前，GCC 会拒绝此示例，因为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>`
    是一个 VLA。然而，C23 允许实现扩展整数常量表达式的定义，而 Clang 通过将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>`
    变为常量大小的数组来实现这一点。
- en: 'We can rewrite these declarations to be portable using <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    on all C23-conforming implementations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>` 重写这些声明，使其在所有符合
    C23 标准的实现中可移植：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, another interesting and unexpected behavior occurs when calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> on a VLA. The compiler usually
    performs the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operation
    at compile time. However, if the expression changes the size of the array, it
    will be evaluated at runtime, including any side effects. The same is true of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>, as the program in
    [Listing 6-8](chapter6.xhtml#Lis6-8) shows.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当对 VLA 调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>` 时，会发生另一个有趣且出乎意料的行为。编译器通常在编译时执行
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>` 操作。然而，如果表达式改变了数组的大小，它将在运行时进行评估，包括任何副作用。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>` 也是如此，正如 [清单 6-8](chapter6.xhtml#Lis6-8)
    中的程序所示。
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: Unexpected side
    effects</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-8：意外的副作用</samp>
- en: In this simple test program, we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> and initialize
    it to <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The operand in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(size++)</samp> isn’t evaluated
    because the type of the operand is not a VLA. Consequently, the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> doesn’t change. We then call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int[size++]</samp> as the argument.
    Because this expression changes the size of the array, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    is incremented and is now equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> similarly increments
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">14</samp>. Finally, we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to be of <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof(int[size++])</samp>,
    which further increments <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>.
    Because these behaviors aren’t well understood, avoid using expressions with side
    effects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operators, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>s to improve understandability.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging Allocated Storage Problems</samp>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, improper memory management can lead to errors
    like leaking memory, reading from or writing to freed memory, and freeing memory
    more than once. One way to avoid some of these problems is to set pointers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> null pointer value after
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, as we’ve already
    discussed. Another strategy is to keep your dynamic memory management as simple
    as possible. For example, you should allocate and free memory in the same module,
    at the same level of abstraction, rather than freeing memory in subroutines, which
    leads to confusion about if, when, and where memory is freed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A third option is to use *dynamic analysis tools*, such as AddressSanitizer,
    Valgrind, or <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to detect
    and report memory errors. AddressSanitizer, as well as general approaches to debugging,
    testing, and analysis, are discussed in [Chapter 11](chapter11.xhtml), while <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> is covered in this section.
    AddressSanitizer or Valgrind are effective tools and better choices if they are
    available for your environment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">dmalloc</samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">dmalloc</samp>
- en: The *debug memory allocation* (<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>)
    library Gray Watson created replaces <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, and other memory management
    features with routines that provide debugging facilities that you can configure
    at runtime. The library has been tested on a variety of platforms.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试内存分配*（<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>）库是 Gray
    Watson 创建的，它替代了 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 以及其他内存管理功能，使用提供调试功能的例程，你可以在运行时配置这些功能。该库已在多种平台上测试。'
- en: Follow the installation directions provided at *[https://<wbr>dmalloc<wbr>.com](https://dmalloc.com)*
    to configure, build, and install the library. [Listing 6-9](chapter6.xhtml#Lis6-9)
    contains a short program that prints out usage information and exits (it would
    typically be part of a longer program). This program has several intentional errors
    and vulnerabilities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 *[https://<wbr>dmalloc<wbr>.com](https://dmalloc.com)* 提供的安装说明配置、构建并安装库。[清单
    6-9](chapter6.xhtml#Lis6-9) 包含一个简短的程序，打印出使用信息并退出（它通常是更长程序的一部分）。该程序包含几个故意的错误和漏洞。
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Catching a memory
    bug with</samp> <samp class="I">dmalloc</samp>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-9：使用</samp> <samp class="I">dmalloc</samp>
    捕获内存错误
- en: 'Recent versions of glibc will detect at least one of the vulnerabilities from
    this program:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: glibc 的最新版本将检测到此程序中的至少一个漏洞：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After repairing this error, include the lines shown in bold font to allow <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to report the file and
    line numbers of calls that cause problems.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 修复此错误后，加入加粗字体所示的行，以便 <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    报告导致问题的文件和行号。
- en: 'I’ll show the output later, but we need to discuss a few things first. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> distribution also
    comes with a command line utility. You can run the following command to get further
    information on how to use this utility:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会展示输出结果，但我们首先需要讨论一些事情。<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    分发包还包含一个命令行工具。你可以运行以下命令，获取有关如何使用该工具的更多信息：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before debugging your program with <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>,
    enter the following at the command line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> 调试程序之前，请在命令行中输入以下内容：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command sets the logfile name to *logfile* and instructs the library to
    perform a check after <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    invocations, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> argument
    specifies. If you specify a larger number as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> will check
    the heap less often, and your code will run faster; lower numbers are more likely
    to catch memory problems. The third argument enables a <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp>
    number of debug features. Other options include <samp class="SANS_TheSansMonoCd_W5Regular_11">runtime</samp>
    for minimal checking or <samp class="SANS_TheSansMonoCd_W5Regular_11">medium</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">high</samp> for more extensive
    heap verification.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将日志文件名设置为 *logfile*，并指示库在 <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    次调用后进行检查，正如 <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> 参数所指定的那样。如果你指定更大的数字作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> 参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    将减少堆检查的频率，你的代码将运行得更快；较低的数字更有可能捕获内存问题。第三个参数启用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">低</samp>
    数量的调试功能。其他选项包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">runtime</samp> 用于最小检查，或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">medium</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">high</samp>
    用于更广泛的堆验证。
- en: 'After executing this command, we can compile the program by using GCC as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们可以使用 GCC 按如下方式编译程序：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you run the program, you should see the following error:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该会看到以下错误：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And if you examine the logfile, you’ll find the following information:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查日志文件，你会找到以下信息：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These messages indicate that we’ve attempted to free the storage referenced
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">errmsg</samp> twice, first in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">usage</samp> function and then
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, which constitutes
    a double-free vulnerability. Of course, this is just a single example of the types
    of bugs that <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> can
    detect, and other defects exist in the simple program we are testing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息表明，我们试图两次释放由 <samp class="SANS_TheSansMonoCd_W5Regular_11">errmsg</samp>
    引用的存储，第一次在 <samp class="SANS_TheSansMonoCd_W5Regular_11">usage</samp> 函数中，第二次在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数中，这构成了双重释放漏洞。当然，这只是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> 可以检测到的错误类型之一，简单程序中还有其他缺陷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safety-Critical Systems</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全关键系统</samp>
- en: Systems with high safety requirements frequently ban the use of dynamic memory
    because memory managers can have unpredictable behavior that significantly impacts
    performance. Forcing all applications to live within a fixed, preallocated area
    of memory can eliminate these problems and make it easier to verify memory use.
    In the absence of recursion, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>,
    and VLAs (also prohibited in safety-critical systems), an upper bound on the use
    of stack memory can be derived statically, making it possible to prove that sufficient
    storage exists to execute the functionality of the application for all possible
    inputs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 安全要求高的系统通常禁止使用动态内存，因为内存管理器可能具有不可预测的行为，显著影响性能。强制所有应用程序都在固定的、预分配的内存区域内运行，可以消除这些问题，并使得内存使用的验证变得更容易。在没有递归、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> 和变长数组（VLA，安全关键系统中也禁止使用）情况下，栈内存的使用上限可以静态推导，从而证明在所有可能的输入下都能提供足够的存储来执行应用程序功能。
- en: Both GCC and Clang have a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla</samp>
    flag that warns if a VLA is used. GCC also has a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp> flag that warns
    for declarations of VLAs whose size is either unbounded or bounded by an argument
    that allows the array size to exceed <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp>
    bytes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 和 Clang 都有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla</samp>
    标志，当使用变长数组（VLA）时会发出警告。GCC 还有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla-larger-than=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">字节大小</samp> 标志，警告声明那些大小不受限制或通过允许数组大小超过
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">字节大小</samp> 字节的参数限定的 VLA。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned about working with memory that has allocated storage
    duration and how this differs from objects of either automatic or static storage
    duration. We described the heap and memory managers and each of the standard memory
    management functions. We identified some common causes of errors when using dynamic
    memory, such as leaks and double-free vulnerabilities, and introduced some mitigations
    to help avoid these problems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你了解了如何处理具有分配存储期的内存，以及这与自动存储期或静态存储期的对象有何不同。我们描述了堆和内存管理器以及每个标准内存管理函数。我们识别了使用动态内存时常见的一些错误原因，例如内存泄漏和双重释放漏洞，并介绍了一些缓解措施，帮助避免这些问题。
- en: We also covered some more specialized memory allocation topics such as flexible
    array members, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    function, and VLAs. We concluded the chapter with a discussion of debugging allocated
    storage problems by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了一些更专业的内存分配主题，例如灵活数组成员、<samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>
    函数和变长数组（VLA）。我们在本章末尾讨论了通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    库来调试分配存储问题。
- en: In the next chapter, you’ll learn about characters and strings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习字符和字符串。
