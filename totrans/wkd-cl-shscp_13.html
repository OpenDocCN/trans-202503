<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_273"/><span class="big"><strong>12</strong></span><br/><strong>SHELL SCRIPT FUN AND GAMES</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">Up to this point, we’ve focused on serious uses of shell scripts to improve your interaction with your system and make the system more flexible and powerful. But there’s another side to shell scripts that’s worth exploring: games.</p>&#13;
<p class="indent">Don’t worry—we’re not proposing that you write <em>Fallout 4</em> as a shell script. There just happen to be some simple games that are easily and informatively written as shell scripts. And wouldn’t you rather learn how to debug shell scripts with something fun than with some utility for suspending user accounts or analyzing Apache error logs?</p>&#13;
<p class="indent">For some of the scripts, you’ll need files from the book’s resources, found at <em><a href="http://www.nostarch.com/wcss2/">http://www.nostarch.com/wcss2/</a></em>, so download that file now if you haven’t already.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_274"/><strong>TWO QUICK TRICKS</strong></p>&#13;
<p class="noindent">Here are two quick examples up front to show you what we mean. First off, old-school Usenet users know about <em>rot13</em>, a simple mechanism whereby off-color jokes and obscene text are obscured to make them a bit less easily read. It’s a <em>substitution cipher</em>, and it’s remarkably simple to accomplish in Unix.</p>&#13;
<p class="indent">To rot13 something, feed it through <code>tr</code>.</p>&#13;
<pre class="programs">tr '[a-zA-Z]' '[n-za-mN-ZA-M]'</pre>&#13;
<p class="indent">Here’s an example:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo "So two people walk into a bar..." | tr '[a-zA-Z]' '[n-za-mN-ZA-M]'</span>&#13;
Fb gjb crbcyr jnyx vagb n one...</pre>&#13;
<p class="indent">To unwrap it, apply the same transform:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo 'Fb gjb crbcyr jnyx vagb n one...' | tr '[a-zA-Z]' '[n-za-mN-ZA-M]'</span>&#13;
So two people walk into a bar...</pre>&#13;
<p class="indent">A famous substitution cipher of this nature is associated with the movie <em>2001: A Space Odyssey</em>. Remember the computer’s name? Check it out:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo HAL | tr '[a-zA-Z]' '[b-zaB-ZA]'</span>&#13;
IBM</pre>&#13;
<p class="indent">Another short example is a palindrome checker. Enter something you believe is a palindrome, and the code will test it.</p>&#13;
<pre class="programs">testit="$(echo $@ | sed 's/[^[:alpha:]]//g' | tr '[:upper:]' '[:lower:]')"&#13;
backward="$(echo $testit | rev)"&#13;
&#13;
if [ "$testit" = "$backward" ] ; then&#13;
  echo "$@ is a palindrome"&#13;
else&#13;
  echo "$@ is not a palindrome"&#13;
fi</pre>&#13;
<p class="indent">A palindrome is a word that’s identical forward and backward, so the first step is to remove all non-alphabetic characters and ensure that all letters are lowercase. Then the Unix utility <code>rev</code> reverses the letters in a line of input. If the forward and backward versions are the same, we’ve got a palindrome; if they differ, we don’t.</p>&#13;
<p class="indent">The games in this chapter are only a bit more complex, but all will prove fun and worth adding to your system.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch12lev1sec01"><span epub:type="pagebreak" id="page_275"/><strong>#83 Unscramble: A Word Game</strong></h3>&#13;
<p class="noindenta">This is a basic anagram game. If you’ve seen the <em>Jumble</em> game in your newspaper or played word games at all, you’ll be familiar with the concept: a word is picked at random and then scrambled. Your task is to figure out what the original word is in the minimum number of turns. The full script for this game is in <a href="ch12.xhtml#ch12ex1">Listing 12-1</a>, but to get the word list, you’ll also need to download the <em>long-words.txt</em> file from the book’s resources <em><a href="http://www.nostarch.com/wcss2/">http://www.nostarch.com/wcss2/</a></em> and save it in the directory <em>/usr/lib/games</em>.</p>&#13;
<h4 class="h4" id="ch12lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # unscramble--Picks a word, scrambles it, and asks the user to guess&#13;
   #   what the original word (or phrase) was&#13;
&#13;
   wordlib="/usr/lib/games/long-words.txt"&#13;
&#13;
   scrambleword()&#13;
   {&#13;
     # Pick a word randomly from the wordlib and scramble it.&#13;
     #   Original word is $match, and scrambled word is $scrambled.&#13;
&#13;
     match="$(<span class="ent">➊</span>randomquote $wordlib)"&#13;
&#13;
     echo "Picked out a word!"&#13;
&#13;
     len=${#match}&#13;
     scrambled=""; lastval=1&#13;
&#13;
     for (( val=1; $val &lt; $len ; ))&#13;
     do&#13;
<span class="ent">➋</span>     if [ $(($RANDOM % 2)) -eq 1 ] ; then&#13;
         scrambled=$scrambled$(echo $match | cut -c$val)&#13;
       else&#13;
         scrambled=$(echo $match | cut -c$val)$scrambled&#13;
       fi&#13;
       val=$(( $val + 1 ))&#13;
     done&#13;
   }&#13;
&#13;
   if [ ! -r $wordlib ] ; then&#13;
     echo "$0: Missing word library $wordlib" &gt;&amp;2&#13;
     echo "(online: http://www.intuitive.com/wicked/examples/long-words.txt" &gt;&amp;2&#13;
     echo "save the file as $wordlib and you're ready to play!)" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   newgame=""; guesses=0; correct=0; total=0&#13;
&#13;
<span class="ent">➌</span> until [ "$guess" = "quit" ] ; do&#13;
&#13;
     scrambleword&#13;
<span epub:type="pagebreak" id="page_276"/>&#13;
     echo ""&#13;
     echo "You need to unscramble: $scrambled"&#13;
&#13;
     guess="??" ; guesses=0&#13;
     total=$(( $total + 1 ))&#13;
&#13;
<span class="ent">➍</span> while [ "$guess" != "$match" -a "$guess" != "quit" -a "$guess" != "next" ]&#13;
     do&#13;
       echo ""&#13;
       /bin/echo -n "Your guess (quit|next) : "&#13;
       read guess&#13;
&#13;
       if [ "$guess" = "$match" ] ; then&#13;
         guesses=$(( $guesses + 1 ))&#13;
         echo ""&#13;
         echo "*** You got it with tries = ${guesses}! Well done!! ***"&#13;
         echo ""&#13;
         correct=$(( $correct + 1 ))&#13;
       elif [ "$guess" = "next" -o "$guess" = "quit" ] ; then&#13;
         echo "The unscrambled word was \"$match\". Your tries: $guesses"&#13;
       else&#13;
         echo "Nope. That's not the unscrambled word. Try again."&#13;
         guesses=$(( $guesses + 1 ))&#13;
       fi&#13;
     done&#13;
   done&#13;
&#13;
   echo "Done. You correctly figured out $correct out of $total scrambled words."&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch12ex1"/><em>Listing 12-1: The</em> <code><em>unscramble</em></code> <em>shell script game</em></p>&#13;
<h4 class="h4" id="ch12lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">To randomly pick a single line from a file, this script uses <code>randomquote</code> (<a href="ch08.xhtml#ch08lev1sec07">Script #68</a> on <a href="ch08.xhtml#page_213">page 213</a>) <span class="ent">➊</span>, even though that script was originally written to work with web pages (like many good Unix utilities, it turns out to be useful in contexts other than the one for which it was intended).</p>&#13;
<p class="indent">The toughest part of this script was figuring out how to scramble a word. There’s no handy Unix utility for that, but it turns out that we can scramble the word differently and unpredictably each time if we go letter by letter through the correctly spelled word and randomly add each subsequent letter to either the beginning or the end of the scrambled sequence <span class="ent">➋</span>.</p>&#13;
<p class="indent">Notice where <code>$scrambled</code> is located in the two lines: in the first line the added letter is appended, while in the second it is prepended.</p>&#13;
<p class="indent">Otherwise the main game logic should be easily understood: the outer <code>until</code> loop <span class="ent">➌</span> runs until the user enters <code>quit</code> as a guess, while the inner <code>while</code> loop <span class="ent">➍</span> runs until the user either guesses the word or types <code>next</code> to skip to the next word.</p>&#13;
<h4 class="h4" id="ch12lev2sec03"><span epub:type="pagebreak" id="page_277"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has no arguments or parameters, so just enter the name and you’re ready to play!</p>&#13;
<h4 class="h4" id="ch12lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">After running, the shell script presents scrambled words of various lengths to the user, keeping track of how many words the user has successfully unscrambled, as <a href="ch12.xhtml#ch12ex2">Listing 12-2</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">unscramble</span>&#13;
Picked out a word!&#13;
&#13;
You need to unscramble: ninrenoccg&#13;
&#13;
Your guess (quit|next) : <span class="codestrong">concerning</span>&#13;
&#13;
*** You got it with tries = 1! Well done!! ***&#13;
&#13;
Picked out a word!&#13;
&#13;
You need to unscramble: esivrmipod&#13;
&#13;
Your guess (quit|next) : <span class="codestrong">quit</span>&#13;
The unscrambled word was "improvised". Your tries: 0&#13;
Done. You correctly figured out 1 out of 2 scrambled words.</pre>&#13;
<p class="listcap"><a id="ch12ex2"/><em>Listing 12-2: Running the</em> <code><em>unscramble</em></code> <em>shell script game</em></p>&#13;
<p class="indent">Clearly an inspired guess on that first one!</p>&#13;
<h4 class="h4" id="ch12lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Some method of offering a clue would make this game more interesting, as would a flag that requests the minimum word length that is acceptable. To accomplish the former, perhaps the first <em>n</em> letters of the unscrambled word could be shown for a certain penalty in the scoring; each clue requested would show one additional letter. For the latter, you’d need to have an expanded word dictionary as the one included with the script has a minimum word length of 10 letters—tricky!</p>&#13;
<h3 class="h3" id="ch12lev1sec02"><strong>#84 Hangman: Guess the Word Before It’s Too Late</strong></h3>&#13;
<p class="noindenta">A word game with a macabre metaphor, hangman is nonetheless an enjoyable classic. In the game, you guess letters that might be in the hidden word, and each time you guess incorrectly, the man hanging on the gallows has an additional body part drawn in. Make too many wrong guesses, and the man is fully illustrated, so not only do you lose but, well, you presumably die too. Rather draconian consequences!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_278"/>However, the game itself is fun, and writing it as a shell script proves surprisingly easy, as <a href="ch12.xhtml#ch12ex3">Listing 12-3</a> shows. For this script, you again need the word list we used in <a href="ch12.xhtml#ch12lev1sec01">Script #83</a> on <a href="ch12.xhtml#page_275">page 275</a>: save the <em>long-words.txt</em> file from the book’s resources in the directory <em>/usr/lib/games</em>.</p>&#13;
<h4 class="h4" id="ch12lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # hangman--A simple version of the hangman game. Instead of showing a&#13;
   #   gradually embodied hanging man, this simply has a bad-guess countdown.&#13;
   #   You can optionally indicate the initial distance from the gallows as&#13;
   #   the only argument.&#13;
&#13;
   wordlib="/usr/lib/games/long-words.txt"&#13;
   empty="\."      # We need something for the sed [set] when $guessed="".&#13;
   games=0&#13;
&#13;
   # Start by testing for our word library datafile.&#13;
&#13;
   if [ ! -r "$wordlib" ] ; then&#13;
     echo "$0: Missing word library $wordlib" &gt;&amp;2&#13;
     echo "(online: http://www.intuitive.com/wicked/examples/long-words.txt" &gt;&amp;2&#13;
     echo "save the file as $wordlib and you're ready to play!)" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # The big while loop. This is where everything happens.&#13;
&#13;
   while [ "$guess" != "quit" ] ; do&#13;
     match="$(randomquote $wordlib)"      # Pick a new word from the library.&#13;
&#13;
     if [ $games -gt 0 ] ; then&#13;
       echo ""&#13;
       echo "*** New Game! ***"&#13;
     fi&#13;
&#13;
     games="$(( $games + 1 ))"&#13;
     guessed="" ; guess="" ; bad=${1:-6}&#13;
     partial="$(echo $match | sed "s/[^$empty${guessed}]/-/g")"&#13;
&#13;
     # The guess &gt; analyze &gt; show results &gt; loop happens in this block.&#13;
&#13;
     while [ "$guess" != "$match" -a "$guess" != "quit" ] ; do&#13;
&#13;
       echo ""&#13;
       if [ ! -z "$guessed" ] ; then # Remember, ! –z means "is not empty".&#13;
         /bin/echo -n "guessed: $guessed, "&#13;
       fi&#13;
       echo "steps from gallows: $bad, word so far: $partial"&#13;
&#13;
       /bin/echo -n "Guess a letter: "&#13;
       read guess&#13;
       echo ""&#13;
       if [ "$guess" = "$match" ] ; then   # Got it!&#13;
         echo "You got it!"&#13;
       elif [ "$guess" = "quit" ] ; then   # You're out? Okay.&#13;
         exit 0&#13;
       # Now we need to validate the guess with various filters.&#13;
<span class="ent">➊</span>     elif [ $(echo $guess | wc -c | sed 's/[^[:digit:]]//g') -ne 2 ] ; then&#13;
         echo "Uh oh: You can only guess a single letter at a time"&#13;
<span class="ent">➋</span>     elif [ ! -z "$(echo $guess | sed 's/[[:lower:]]//g')" ] ; then&#13;
         echo "Uh oh: Please only use lowercase letters for your guesses"&#13;
<span class="ent">➌</span>     elif [ -z "$(echo $guess | sed "s/[$empty$guessed]//g")" ] ; then&#13;
         echo "Uh oh: You have already tried $guess"&#13;
       # Now we can actually see if the letter appears in the word.&#13;
<span class="ent">➍</span>     elif [ "$(echo $match | sed "s/$guess/-/g")" != "$match" ] ; then&#13;
         guessed="$guessed$guess"&#13;
<span class="ent">➎</span>     partial="$(echo $match | sed "s/[^$empty${guessed}]/-/g")"&#13;
         if [ "$partial" = "$match" ] ; then&#13;
           echo "** You've been pardoned!! Well done! The word was \"$match\"."&#13;
           guess="$match"&#13;
         else&#13;
           echo "* Great! The letter \"$guess\" appears in the word!"&#13;
         fi&#13;
       elif [ $bad -eq 1 ] ; then&#13;
         echo "** Uh oh: you've run out of steps. You're on the platform..."&#13;
         echo "** The word you were trying to guess was \"$match\""&#13;
         guess="$match"&#13;
       else&#13;
         echo "* Nope, \"$guess\" does not appear in the word."&#13;
         guessed="$guessed$guess"&#13;
         bad=$(( $bad - 1 ))&#13;
       fi&#13;
     done&#13;
   done&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_279"/><a id="ch12ex3"/><em>Listing 12-3: The</em> <code><em>hangman</em></code> <em>shell script game</em></p>&#13;
<h4 class="h4" id="ch12lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The tests in this script are all interesting and worth examination. Consider the test at <span class="ent">➊</span> that checks whether the player has entered more than a single letter as a guess.</p>&#13;
<p class="indent">Why test for the value 2 rather than 1? Because the entered value has a carriage return from when the user hit <small>ENTER</small> (which is a character, <code>\n</code>), it has two letters if it’s correct, not one. The <code>sed</code> in this statement strips out all non-digit values, of course, to avoid any confusion with the leading tab that <code>wc</code> likes to emit.</p>&#13;
<p class="indent">Testing for lowercase is straightforward <span class="ent">➋</span>. Remove all lowercase letters from <code>guess</code> and see whether the result is zero (empty) or not.</p>&#13;
<p class="indent">Finally, to see whether the user has guessed the letter already, transform the guess such that any letters in <code>guess</code> that also appear in the <code>guessed</code> variable are removed. Is the result zero (empty) or not <span class="ent">➌</span>?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_280"/>Apart from all these tests, the trick behind getting <code>hangman</code> to work is to replace each guessed letter in the original word with a dash wherever that letter appears in the word and then compare the result to the original word in which no letters have been replaced by dashes <span class="ent">➍</span>. If they’re different (that is, if one or more letters in the word are now dashes), the guessed letter is in the word. Guessing the letter <em>a</em>, for instance, when the word is <em>cat</em>, will result in the <code>guessed</code> variable holding your guess with a value of ‘-a-’.</p>&#13;
<p class="indent">One of the key ideas that makes it possible to write hangman is that the partially filled-in word shown to the player, the variable <code>partial</code>, is rebuilt each time a correct guess is made. Because the variable <code>guessed</code> accumulates each letter guessed by the player, a <code>sed</code> transformation that translates into a dash each letter in the original word that is <em>not</em> in the <code>guessed</code> string does the trick <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch12lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The hangman game has one optional argument: if you specify a numeric value as a parameter, the code will use that as the number of incorrect guesses allowed, rather than the default of 6. <a href="ch12.xhtml#ch12ex4">Listing 12-4</a> shows playing the <code>hangman</code> script with no arguments.</p>&#13;
<h4 class="h4" id="ch12lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">hangman</span>&#13;
&#13;
steps from gallows: 6, word so far: -------------&#13;
Guess a letter: <span class="codestrong">e</span>&#13;
&#13;
* Great! The letter "e" appears in the word!&#13;
&#13;
guessed: e, steps from gallows: 6, word so far: -e--e--------&#13;
Guess a letter: <span class="codestrong">i</span>&#13;
&#13;
* Great! The letter "i" appears in the word!&#13;
&#13;
guessed: ei, steps from gallows: 6, word so far: -e--e--i-----&#13;
Guess a letter: <span class="codestrong">o</span>&#13;
&#13;
* Great! The letter "o" appears in the word!&#13;
&#13;
guessed: eio, steps from gallows: 6, word so far: -e--e--io----&#13;
Guess a letter: <span class="codestrong">u</span>&#13;
&#13;
* Great! The letter "u" appears in the word!&#13;
&#13;
guessed: eiou, steps from gallows: 6, word so far: -e--e--iou---&#13;
Guess a letter: <span class="codestrong">m</span>&#13;
&#13;
* Nope, "m" does not appear in the word.&#13;
&#13;
guessed: eioum, steps from gallows: 5, word so far: -e--e--iou---&#13;
Guess a letter: <span class="codestrong">n</span>&#13;
&#13;
* Great! The letter "n" appears in the word!&#13;
&#13;
guessed: eioumn, steps from gallows: 5, word so far: -en-en-iou---&#13;
Guess a letter: <span class="codestrong">r</span>&#13;
&#13;
* Nope, "r" does not appear in the word.&#13;
&#13;
guessed: eioumnr, steps from gallows: 4, word so far: -en-en-iou---&#13;
Guess a letter: <span class="codestrong">s</span>&#13;
&#13;
* Great! The letter "s" appears in the word!&#13;
&#13;
guessed: eioumnrs, steps from gallows: 4, word so far: sen-en-ious--&#13;
Guess a letter: <span class="codestrong">t</span>&#13;
&#13;
* Great! The letter "t" appears in the word!&#13;
&#13;
guessed: eioumnrst, steps from gallows: 4, word so far: sententious--&#13;
Guess a letter: <span class="codestrong">l</span>&#13;
&#13;
* Great! The letter "l" appears in the word!&#13;
&#13;
guessed: eioumnrstl, steps from gallows: 4, word so far: sententiousl-&#13;
Guess a letter: <span class="codestrong">y</span>&#13;
&#13;
** You've been pardoned!! Well done! The word was "sententiously".&#13;
&#13;
*** New Game! ***&#13;
&#13;
steps from gallows: 6, word so far: ----------&#13;
Guess a letter: <span class="codestrong">quit</span></pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_281"/><a id="ch12ex4"/><em>Listing 12-4: Playing the</em> <code><em>hangman</em></code> <em>shell script game</em></p>&#13;
<h4 class="h4" id="ch12lev2sec10"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Obviously it’s difficult to have the guy-hanging-on-the-gallows graphic with a shell script, so we use the alternative of counting “steps to the gallows.” If you were motivated, however, you could probably have a series of predefined “text” graphics, one for each step, and output them as the game proceeds. Or you could choose a nonviolent alternative of some sort!</p>&#13;
<p class="indent">Note that it is possible to pick the same word twice, but with the default word list containing 2,882 different words, there’s not much chance of that. If this is a concern, however, the line where the word is chosen could also save all previous words in a variable and screen against them to ensure that there aren’t any repeats.</p>&#13;
<p class="indent">Finally, if you’re motivated, it’d be nice to have the guessed-letters list sorted alphabetically. There are a couple of approaches to this, but we’d use <code>sed|sort</code>.</p>&#13;
<h3 class="h3" id="ch12lev1sec03"><span epub:type="pagebreak" id="page_282"/><strong>#85 A State Capitals Quiz</strong></h3>&#13;
<p class="noindenta">Once you have a tool for choosing a line randomly from a file, there’s no limit to the types of quiz games you can write. We’ve pulled together a list of the capitals of all 50 states in the United States, available for download from <em><a href="http://www.nostarch.com/wcss2/">http://www.nostarch.com/wcss2/</a></em>. Save the file <em>state.capitals.txt</em> in your <em>/usr/lib/games</em> directory. The script in <a href="ch12.xhtml#ch12ex5">Listing 12-5</a> randomly chooses a line from the file, shows the state, and asks the user to enter the matching capital.</p>&#13;
<h4 class="h4" id="ch12lev2sec11"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # states--A state capital guessing game. Requires the state capitals&#13;
   #   data file state.capitals.txt.&#13;
&#13;
   db="/usr/lib/games/state.capitals.txt"     # Format is State[tab]City.&#13;
&#13;
   if [ ! -r "$db" ] ; then&#13;
     echo "$0: Can't open $db for reading." &gt;&amp;2&#13;
     echo "(get state.capitals.txt" &gt;&amp;2&#13;
     echo "save the file as $db and you're ready to play!)" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   guesses=0; correct=0; total=0&#13;
&#13;
   while [ "$guess" != "quit" ] ; do&#13;
&#13;
     thiskey="$(randomquote $db)"&#13;
&#13;
     # $thiskey is the selected line. Now let's grab state and city info, and&#13;
     #   then also have "match" as the all-lowercase version of the city name.&#13;
&#13;
<span class="ent">➊</span>   state="$(echo $thiskey | cut -d\   -f1 | sed 's/-/ /g')"&#13;
     city="$(echo $thiskey | cut -d\   -f2 | sed 's/-/ /g')"&#13;
     match="$(echo $city | tr '[:upper:]' '[:lower:]')"&#13;
&#13;
     guess="??" ; total=$(( $total + 1 )) ;&#13;
&#13;
     echo ""&#13;
     echo "What city is the capital of $state?"&#13;
&#13;
     # Main loop where all the action takes place. Script loops until&#13;
     #   city is correctly guessed or the user types "next" to&#13;
     #   skip this one or "quit" to quit the game.&#13;
&#13;
     while [ "$guess" != "$match" -a "$guess" != "next" -a "$guess" != "quit" ]&#13;
     do&#13;
       /bin/echo -n "Answer: "&#13;
       read guess&#13;
       if [ "$guess" = "$match" -o "$guess" = "$city" ] ; then&#13;
         echo ""&#13;
         echo "*** Absolutely correct! Well done! ***"&#13;
         correct=$(( $correct + 1 ))&#13;
         guess=$match&#13;
       elif [ "$guess" = "next" -o "$guess" = "quit" ] ; then&#13;
         echo ""&#13;
         echo "$city is the capital of $state." # What you SHOULD have known :)&#13;
       else&#13;
         echo "I'm afraid that's not correct."&#13;
       fi&#13;
     done&#13;
&#13;
   done&#13;
&#13;
   echo "You got $correct out of $total presented."&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_283"/><a id="ch12ex5"/><em>Listing 12-5: The</em> <code><em>states</em></code> <em>trivia game shell script</em></p>&#13;
<h4 class="h4" id="ch12lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">For such an entertaining game, <code>states</code> involves very simple scripting. The data file contains state/capital pairs, with all spaces in the state and capital names replaced with dashes and the two fields separated by a single space. As a result, extracting the city and state names from the data is easy <span class="ent">➊</span>.</p>&#13;
<p class="indent">Each guess is compared against both the all-lowercase version of the city name (<code>match</code>) and the correctly capitalized city name to see whether it’s correct. If not, the guess is compared against the two command words <code>next</code> and <code>quit</code>. If either matches, the script shows the answer and either prompts for another state or quits, as appropriate. If there are no matches, the guess is considered incorrect.</p>&#13;
<h4 class="h4" id="ch12lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has no arguments or command flags. Just start it up and play!</p>&#13;
<h4 class="h4" id="ch12lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Ready to quiz yourself on state capitals? <a href="ch12.xhtml#ch12ex6">Listing 12-6</a> shows our state capital trivia skills in action!</p>&#13;
<pre class="programs">$ <span class="codestrong">states</span>&#13;
&#13;
What city is the capital of Indiana?&#13;
Answer: <span class="codestrong">Bloomington</span>&#13;
I'm afraid that's not correct.&#13;
Answer: <span class="codestrong">Indianapolis</span>&#13;
&#13;
*** Absolutely correct! Well done! ***&#13;
&#13;
What city is the capital of Massachusetts?&#13;
Answer: <span class="codestrong">Boston</span>&#13;
&#13;
*** Absolutely correct! Well done! ***&#13;
&#13;
What city is the capital of West Virginia?&#13;
Answer: <span class="codestrong">Charleston</span>&#13;
&#13;
*** Absolutely correct! Well done! ***&#13;
&#13;
What city is the capital of Alaska?&#13;
Answer: <span class="codestrong">Fairbanks</span>&#13;
I'm afraid that's not correct.&#13;
Answer: <span class="codestrong">Anchorage</span>&#13;
I'm afraid that's not correct.&#13;
Answer: <span class="codestrong">Nome</span>&#13;
I'm afraid that's not correct.&#13;
Answer: <span class="codestrong">Juneau</span>&#13;
&#13;
*** Absolutely correct! Well done! ***&#13;
&#13;
What city is the capital of Oregon?&#13;
Answer: <span class="codestrong">quit</span>&#13;
&#13;
Salem is the capital of Oregon.&#13;
You got 4 out of 5 presented.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_284"/><a id="ch12ex6"/><em>Listing 12-6: Running the</em> <code><em>states</em></code> <em>trivia game shell script</em></p>&#13;
<p class="indent">Fortunately, the game tracks only ultimately correct guesses, not how many incorrect guesses you made or whether you popped over to Google to get the answer!</p>&#13;
<h4 class="h4" id="ch12lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Probably the greatest weakness in this game is that it’s picky about spelling. A useful modification would be to add code to allow fuzzy matching, so that the user entry of <code>Juneu</code> might match Juneau, for example. This could be done using a modified <em>Soundex algorithm</em>, in which vowels are removed and doubled letters are squished down to a single letter (for example, Annapolis would transform to <code>npls</code>). This might be too forgiving for your tastes, but the general concept is worth considering.</p>&#13;
<p class="indent">As with other games, a hint function would be useful, too. Perhaps it would show the first letter of the correct answer when requested and keep track of how many hints are used as the play proceeds.</p>&#13;
<p class="indent">Although this game is written for state capitals, it would be trivial to modify the script to work with any sort of paired data file. For example, with a different file, you could create an Italian vocabulary quiz, a country/currency match, or a politician/political party quiz. As we’ve seen repeatedly in Unix, writing something that is reasonably general purpose allows it to be reused in useful and occasionally unexpected ways.</p>&#13;
<h3 class="h3" id="ch12lev1sec04"><span epub:type="pagebreak" id="page_285"/><strong>#86 Is That Number a Prime?</strong></h3>&#13;
<p class="noindenta">Prime numbers are numbers that are divisible only by themselves, for example, 7. On the other hand, 6 and 8 are not prime numbers. Recognizing prime numbers is easy with single digits, but it gets more complicated when we jump up to bigger numbers.</p>&#13;
<p class="indent">There are different mathematical approaches to figuring out whether a number is prime, but let’s stick with the brute-force method of trying all possible divisors to see whether any have a remainder of zero, as <a href="ch12.xhtml#ch12ex7">Listing 12-7</a> shows.</p>&#13;
<h4 class="h4" id="ch12lev2sec16"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # isprime--Given a number, ascertain whether it's a prime. This uses what's&#13;
   #   known as trial division: simply check whether any number from 2 to (n/2)&#13;
   #   divides into the number without a remainder.&#13;
&#13;
     counter=2&#13;
   remainder=1&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: isprime NUMBER" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   number=$1&#13;
&#13;
   # 3 and 2 are primes, 1 is not.&#13;
&#13;
   if [ $number -lt 2 ] ; then&#13;
     echo "No, $number is not a prime"&#13;
     exit 0&#13;
   fi&#13;
&#13;
   # Now let's run some calculations.&#13;
&#13;
<span class="ent">➊</span> while [ $counter -le $(expr $number / 2) -a $remainder -ne 0 ]&#13;
   do&#13;
     remainder=$(expr $number % $counter)  # '/' is divide, '%' is remainder&#13;
     # echo "  for counter $counter, remainder = $remainder"&#13;
     counter=$(expr $counter + 1)&#13;
   done&#13;
&#13;
   if [ $remainder -eq 0 ] ; then&#13;
     echo "No, $number is not a prime"&#13;
   else&#13;
     echo "Yes, $number is a prime"&#13;
   fi&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch12ex7"/><em>Listing 12-7: The</em> <code><em>isprime</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch12lev2sec17"><span epub:type="pagebreak" id="page_286"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The heart of this script is in the <code>while</code> loop, so take a look at that more closely at <span class="ent">➊</span>. If we were trying a <code>number</code> of 77, the conditional statement would be testing this:</p>&#13;
<pre class="programs">while [ 2 -le 38 -a 1 -ne 0 ]</pre>&#13;
<p class="indent">Obviously this is false: 77 does not divide evenly by 2. Each time the code tests a potential divisor (<code>$counter</code>) and finds that it doesn’t divide evenly, it calculates the remainder (<code>$number % $counter)</code> and increments the <code>$counter</code> by 1. Ploddingly, it proceeds.</p>&#13;
<h4 class="h4" id="ch12lev2sec18"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Let’s pick a few numbers that seem like they could be prime and test them in <a href="ch12.xhtml#ch12ex8">Listing 12-8</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">isprime 77</span>&#13;
No, 77 is not a prime&#13;
$ <span class="codestrong">isprime 771</span>&#13;
No, 771 is not a prime&#13;
$ <span class="codestrong">isprime 701</span>&#13;
Yes, 701 is a prime</pre>&#13;
<p class="listcap"><a id="ch12ex8"/><em>Listing 12-8: Running the</em> <code><em>isprime</em></code> <em>shell script on some numbers</em></p>&#13;
<p class="indent">If you’re curious, uncomment out the <code>echo</code> statement in the <code>while</code> loop to see the calculations and get a sense of how quickly—or slowly—the script finds a divisor that divides evenly into the number without a remainder. In fact, let’s do just that and test 77, as shown in <a href="ch12.xhtml#ch12ex9">Listing 12-9</a>.</p>&#13;
<h4 class="h4" id="ch12lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">isprime 77</span>&#13;
  for counter 2, remainder = 1&#13;
  for counter 3, remainder = 2&#13;
  for counter 4, remainder = 1&#13;
  for counter 5, remainder = 2&#13;
  for counter 6, remainder = 5&#13;
  for counter 7, remainder = 0&#13;
No, 77 is not a prime</pre>&#13;
<p class="listcap"><a id="ch12ex9"/><em>Listing 12-9: Running the</em> <code><em>isprime</em></code> <em>script with debug lines uncommented</em></p>&#13;
<h4 class="h4" id="ch12lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There are some inefficiencies in the implementation of the mathematical formula in this script that slow it way down. For example, consider the <code>while</code> loop conditional. We keep calculating <code>$(expr $number / 2)</code> when we can just <span epub:type="pagebreak" id="page_287"/>calculate that value once and use the calculated value for each subsequent iteration, saving the need to spawn a subshell and invoking <code>expr</code> to find out that the value hasn’t changed one iota since the last iteration.</p>&#13;
<p class="indent">There are also some far smarter algorithms to test for prime numbers, and these are worth exploring, including the delightfully named sieve of Eratosthenes, along with more modern formulas such as the sieve of Sundaram and the rather more complicated sieve of Atkin. Check them out online and test whether your phone number (without dashes!) is a prime or not.</p>&#13;
<h3 class="h3" id="ch12lev1sec05"><strong>#87 Let’s Roll Some Dice</strong></h3>&#13;
<p class="noindenta">This is a handy script for anyone who enjoys tabletop games, especially role-playing games like <em>Dungeons &amp; Dragons</em>.</p>&#13;
<p class="indent">The common perception of these games is that they’re just a lot of dice rolling, and that’s actually accurate. It’s all about probabilities, so sometimes you’re rolling a 20-sided die and other times you’re rolling six 6-sided dice. Dice are such an easy random number generator that a huge number of games use them, whether it’s one die, two (think <em>Monopoly</em> or <em>Trouble</em>), or more.</p>&#13;
<p class="indent">They all turn out to be easy to model, and that’s what the script in <a href="ch12.xhtml#ch12ex10">Listing 12-10</a> does, letting the user specify how many of what kind of dice are needed, then “rolling” them all, and offering a sum.</p>&#13;
<h4 class="h4" id="ch12lev2sec21"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # rolldice--Parse requested dice to roll and simulate those rolls.&#13;
   #   Examples: d6 = one 6-sided die&#13;
   #             2d12 = two 12-sided dice&#13;
   #             d4 3d8 2d20 = one 4-side die, three 8-sided, and two 20-sided dice&#13;
&#13;
   rolldie()&#13;
   {&#13;
     dice=$1&#13;
     dicecount=1&#13;
     sum=0&#13;
&#13;
     # First step: break down arg into MdN.&#13;
&#13;
<span class="ent">➊</span>   if [ -z "$(echo $dice | grep 'd')" ] ; then&#13;
       quantity=1&#13;
       sides=$dice&#13;
     else&#13;
       quantity=$(echo $dice | <span class="ent">➋</span>cut -dd -f1)&#13;
       if [ -z "$quantity" ] ; then       # User specified dN, not just N.&#13;
         quantity=1&#13;
       fi&#13;
       sides=$(echo $dice | cut -dd -f2)&#13;
     fi&#13;
     echo "" ; echo "rolling $quantity $sides-sided die"&#13;
     # Now roll the dice...&#13;
&#13;
     while [ $dicecount -le $quantity ] ; do&#13;
<span class="ent">➌</span>     roll=$(( ( $RANDOM % $sides ) + 1 ))&#13;
       sum=$(( $sum + $roll ))&#13;
       echo " roll #$dicecount = $roll"&#13;
       dicecount=$(( $dicecount + 1 ))&#13;
     done&#13;
&#13;
     echo I rolled $dice and it added up to $sum&#13;
   }&#13;
&#13;
   while [ $# -gt 0 ] ; do&#13;
     rolldie $1&#13;
     sumtotal=$(( $sumtotal + $sum ))&#13;
     shift&#13;
   done&#13;
&#13;
   echo ""&#13;
   echo "In total, all of those dice add up to $sumtotal"&#13;
   echo ""&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_288"/><a id="ch12ex10"/><em>Listing 12-10: The</em> <code><em>rolldice</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch12lev2sec22"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script revolves around a simple line of code that invokes the bash random number generator through the expedient shortcut of referencing <code>$RANDOM</code> <span class="ent">➌</span>. That’s the key line; everything else is just window dressing.</p>&#13;
<p class="indent">The other interesting segment is where the dice description is broken down <span class="ent">➊</span>, because the script supports all three of these notations: <code>3d8</code>, <code>d6</code>, and <code>20</code>. This is a standard gaming notation, for convenience: number of dice + <em>d</em> + sides the die should have. For example, <code>2d6</code> means two 6-sided dice. See if you can figure out how each is processed.</p>&#13;
<p class="indent">There’s a fair bit of output for such a simple script. You’ll probably want to adjust this to your own preferences, but here you can see that the statement is just a handy way to verify that it parsed the die or dice request properly.</p>&#13;
<p class="indent">Oh, and the <code>cut</code> invocation <span class="ent">➋</span>? Remember that <code>-d</code> indicates the field delimiter, so <code>-dd</code> simply says to use the letter <em>d</em> as that delimiter, as needed for this particular dice notation.</p>&#13;
<h4 class="h4" id="ch12lev2sec23"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Let’s start easy: in <a href="ch12.xhtml#ch12ex11">Listing 12-11</a>, we’ll use two 6-sided dice, as if we were playing <em>Monopoly</em>.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_289"/>$ <span class="codestrong">rolldice 2d6</span>&#13;
rolling 2 6-sided die&#13;
  roll #1 = 6&#13;
  roll #2 = 2&#13;
I rolled 2d6 and it added up to 8&#13;
In total, all of those dice add up to 8&#13;
$ <span class="codestrong">rolldice 2d6</span>&#13;
rolling 2 6-sided die&#13;
  roll #1 = 4&#13;
  roll #2 = 2&#13;
I rolled 2d6 and it added up to 6&#13;
In total, all of those dice add up to 6</pre>&#13;
<p class="listcap"><a id="ch12ex11"/><em>Listing 12-11: Testing the</em> <code><em>rolldice</em></code> <em>script with a pair of six-sided dice</em></p>&#13;
<p class="indent">Notice that the first time it “rolled” the two dice, they came up 6 and 2, but the second time they came up 4 and 2.</p>&#13;
<p class="indent">How about a quick <em>Yahtzee</em> roll? Easy enough. We’ll roll five six-sided dice in <a href="ch12.xhtml#ch12ex12">Listing 12-12</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">rolldice 5d6</span>&#13;
rolling 5 6-sided die&#13;
  roll #1 = 2&#13;
  roll #2 = 1&#13;
  roll #3 = 3&#13;
  roll #4 = 5&#13;
  roll #5 = 2&#13;
I rolled 5d6 and it added up to 13&#13;
In total, all of those dice add up to 13</pre>&#13;
<p class="listcap"><a id="ch12ex12"/><em>Listing 12-12: Testing the</em> <code><em>rolldice</em></code> <em>script with five six-sided dice</em></p>&#13;
<p class="indent">Not a very good roll: 1, 2, 2, 3, 5. If we were playing <em>Yahtzee</em>, we’d keep the pair of 2s and reroll everything else.</p>&#13;
<p class="indent">This gets more interesting when you have a more complicated set of dice to roll. In <a href="ch12.xhtml#ch12ex13">Listing 12-13</a>, let’s try two 18-sided dice, one 37-sided die, and a 3-sided die (since we don’t have to worry about the limitations of 3D geometric shapes).</p>&#13;
<pre class="programs">$ <span class="codestrong">rolldice 2d18 1d37 1d3</span>&#13;
rolling 2 18-sided die&#13;
  roll #1 = 16&#13;
  roll #2 = 14&#13;
I rolled 2d18 and it added up to 30&#13;
rolling 1 37-sided die&#13;
  roll #1 = 29&#13;
I rolled 1d37 and it added up to 29&#13;
rolling 1 3-sided die&#13;
  roll #1 = 2&#13;
I rolled 1d3 and it added up to 2&#13;
In total, all of those dice add up to 61</pre>&#13;
<p class="listcap"><a id="ch12ex13"/><em>Listing 12-13: Running the</em> <code><em>rolldice</em></code> <em>script with an assortment of dice types</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>Cool, eh? A few additional rolls of this motley set of dice yielded 22, 49, and 47. Now you know, gamers!</p>&#13;
<h4 class="h4" id="ch12lev2sec24"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There’s not much to hack in this script since the task is so easy. The only thing we would recommend is fine-tuning the amount of output that the program produces. For example, a notation like <code>5d6: 2 3 1 3 7 = 16</code> would be more space efficient.</p>&#13;
<h3 class="h3" id="ch12lev1sec06"><strong>#88 Acey Deucey</strong></h3>&#13;
<p class="noindenta">For our last script in this chapter, we’ll create the card game Acey Deucey, which means we’ll need to figure out how to create and “shuffle” a deck of playing cards to get randomized results. This is tricky, but the functions you write for this game will give you a general purpose solution you can use to make a more complicated game like blackjack or even rummy or Go Fish.</p>&#13;
<p class="indent">The game is simple: deal two cards, and then bet whether the next card you’re going to flip up ranks between the two existing cards. Suit is irrelevant; it’s all about the card rank, and a tie loses. Thus, if you flip up a 6 of hearts and a 9 of clubs and the third card is a 6 of diamonds, it’s a loss. A 4 of spades is also a loss. But a 7 of clubs is a win.</p>&#13;
<p class="indent">So there are two tasks here: the entire card deck simulation and the logic of the game itself, including asking the user whether they want to make a bet. Oh, and one more thing: if you deal two cards that have the same rank, there’s no point betting because you can’t win.</p>&#13;
<p class="indent">That’ll make an interesting script. Ready? Then go to <a href="ch12.xhtml#ch12ex14">Listing 12-14</a>.</p>&#13;
<h4 class="h4" id="ch12lev2sec25"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # aceyduecey: Dealer flips over two cards, and you guess whether the&#13;
   #   next card from the deck will rank between the two. For example,&#13;
   #   with a 6 and an 8, a 7 is between the two, but a 9 is not.&#13;
&#13;
   function initializeDeck&#13;
   {&#13;
       # Start by creating the deck of cards.&#13;
&#13;
       card=1&#13;
       while [ $card –le 52 ]         # 52 cards in a deck. You knew that, right?&#13;
       do&#13;
<span class="ent">➊</span>       deck[$card]=$card&#13;
         card=$(( $card + 1 ))&#13;
       done&#13;
   }&#13;
&#13;
   function shuffleDeck&#13;
   {&#13;
<span epub:type="pagebreak" id="page_291"/>       # It's not really a shuffle. It's a random extraction of card values&#13;
       #   from the 'deck' array, creating newdeck[] as the "shuffled" deck.&#13;
&#13;
       count=1&#13;
&#13;
       while [ $count != 53 ]&#13;
       do&#13;
         pickCard&#13;
<span class="ent">➋</span>       newdeck[$count]=$picked&#13;
         count=$(( $count + 1 ))&#13;
       done&#13;
   }&#13;
&#13;
<span class="ent">➌</span> function pickCard&#13;
   {&#13;
       # This is the most interesting function: pick a random card from&#13;
       #   the deck. Uses the deck[] array to find an available card slot.&#13;
&#13;
       local errcount randomcard&#13;
&#13;
       threshold=10      # Max guesses for a card before we fall through&#13;
       errcount=0&#13;
&#13;
       # Randomly pick a card that hasn't already been pulled from the deck&#13;
       #   a max of $threshold times. Fall through on fail (to avoid a possible&#13;
       #   infinite loop where it keeps guessing the same already dealt card).&#13;
&#13;
<span class="ent">➍</span>   while [ $errcount -lt $threshold ]&#13;
       do&#13;
         randomcard=$(( ( $RANDOM % 52 ) + 1 ))&#13;
         errcount=$(( $errcount + 1 ))&#13;
&#13;
         if [ ${deck[$randomcard]} -ne 0 ] ; then&#13;
           picked=${deck[$randomcard]}&#13;
           deck[$picked]=0    # Picked--remove it.&#13;
           return $picked&#13;
         fi&#13;
       done&#13;
&#13;
       # If we get here, we've been unable to randomly pick a card, so we'll&#13;
       #   just step through the array until we find an available card.&#13;
&#13;
       randomcard=1&#13;
&#13;
<span class="ent">➎</span>   while [ ${newdeck[$randomcard]} -eq 0 ]&#13;
       do&#13;
         randomcard=$(( $randomcard + 1 ))&#13;
       done&#13;
&#13;
       picked=$randomcard&#13;
       deck[$picked]=0      # Picked--remove it.&#13;
&#13;
       return $picked&#13;
   }&#13;
&#13;
<span epub:type="pagebreak" id="page_292"/>   function showCard&#13;
   {&#13;
      # This uses a div and a mod to figure out suit and rank, though&#13;
      #   in this game, only rank matters. Still, presentation is&#13;
      #   important, so this helps make things pretty.&#13;
&#13;
      card=$1&#13;
&#13;
      if [ $card -lt 1 -o $card -gt 52 ] ; then&#13;
        echo "Bad card value: $card"&#13;
        exit 1&#13;
      fi&#13;
&#13;
      # div and mod -- see, all that math in school wasn't wasted!&#13;
&#13;
<span class="ent">➏</span>    suit="$(( ( ( $card - 1) / 13 ) + 1))"&#13;
      rank="$(( $card % 13))"&#13;
&#13;
      case $suit in&#13;
        1 ) suit="Hearts"   ;;&#13;
        2 ) suit="Clubs"    ;;&#13;
        3 ) suit="Spades"   ;;&#13;
        4 ) suit="Diamonds" ;;&#13;
        * ) echo "Bad suit value: $suit"&#13;
            exit 1&#13;
&#13;
      esac&#13;
&#13;
      case $rank in&#13;
        0 ) rank="King"    ;;&#13;
        1 ) rank="Ace"     ;;&#13;
        11) rank="Jack"    ;;&#13;
        12) rank="Queen"   ;;&#13;
      esac&#13;
&#13;
      cardname="$rank of $suit"&#13;
   }&#13;
&#13;
<span class="ent">➐</span> function dealCards&#13;
   {&#13;
       # Acey Deucey has two cards flipped up...&#13;
&#13;
       card1=${newdeck[1]}    # Since deck is shuffled, we take&#13;
       card2=${newdeck[2]}    #   the top two cards from the deck&#13;
       card3=${newdeck[3]}    #   and pick card #3 secretly.&#13;
&#13;
       rank1=$(( ${newdeck[1]} % 13 ))  # And let's get the rank values&#13;
       rank2=$(( ${newdeck[2]} % 13 ))  #   to make subsequent calculations easy.&#13;
       rank3=$(( ${newdeck[3]} % 13 ))&#13;
&#13;
       # Fix to make the king: default rank = 0, make rank = 13.&#13;
&#13;
       if [ $rank1 -eq 0 ] ; then&#13;
         rank1=13;&#13;
       fi&#13;
<span epub:type="pagebreak" id="page_293"/>       if [ $rank2 -eq 0 ] ; then&#13;
         rank2=13;&#13;
       fi&#13;
       if [ $rank3 -eq 0 ] ; then&#13;
         rank3=13;&#13;
       fi&#13;
&#13;
       # Now let's organize them so that card1 is always lower than card2.&#13;
&#13;
<span class="ent">➑</span>     if [ $rank1 -gt $rank2 ] ; then&#13;
         temp=$card1; card1=$card2; card2=$temp&#13;
         temp=$rank1; rank1=$rank2; rank2=$temp&#13;
       fi&#13;
&#13;
       showCard $card1 ; cardname1=$cardname&#13;
       showCard $card2 ; cardname2=$cardname&#13;
&#13;
       showCard $card3 ; cardname3=$cardname # Shhh, it's a secret for now.&#13;
&#13;
<span class="ent">➒</span>     echo "I've dealt:" ; echo "   $cardname1" ; echo "   $cardname2"&#13;
   }&#13;
&#13;
   function introblurb&#13;
   {&#13;
   cat &lt;&lt; EOF&#13;
&#13;
   Welcome to Acey Deucey. The goal of this game is for you to correctly guess&#13;
   whether the third card is going to be between the two cards I'll pull from&#13;
   the deck. For example, if I flip up a 5 of hearts and a jack of diamonds,&#13;
   you'd bet on whether the next card will have a higher rank than a 5 AND a&#13;
   lower rank than a jack (that is, a 6, 7, 8, 9, or 10 of any suit).&#13;
&#13;
   Ready? Let's go!&#13;
&#13;
   EOF&#13;
   }&#13;
&#13;
   games=0&#13;
   won=0&#13;
&#13;
   if [ $# -gt 0 ] ; then    # Helpful info if a parameter is specified&#13;
     introblurb&#13;
   fi&#13;
&#13;
   while [ /bin/true ] ; do&#13;
&#13;
     initializeDeck&#13;
     shuffleDeck&#13;
     dealCards&#13;
&#13;
     splitValue=$(( $rank2 - $rank1 ))&#13;
&#13;
     if [ $splitValue -eq 0 ] ; then&#13;
       echo "No point in betting when they're the same rank!"&#13;
       continue&#13;
     fi&#13;
&#13;
     /bin/echo -n "The spread is $splitValue. Do you think the next card will "&#13;
     /bin/echo -n "be between them? (y/n/q) "&#13;
     read answer&#13;
&#13;
     if [ "$answer" = "q" ] ; then&#13;
       echo ""&#13;
       echo "You played $games games and won $won times."&#13;
       exit 0&#13;
     fi&#13;
&#13;
     echo "I picked: $cardname3"&#13;
&#13;
     # Is it between the values? Let's test. Remember, equal rank = lose.&#13;
&#13;
<span class="ent">➓</span>   if [ $rank3 -gt $rank1 -a $rank3 -lt $rank2 ] ; then # Winner!&#13;
       winner=1&#13;
     else&#13;
       winner=0&#13;
     fi&#13;
&#13;
     if [ $winner -eq 1 -a "$answer" = "y" ] ; then&#13;
       echo "You bet that it would be between the two, and it is. WIN!"&#13;
       won=$(( $won + 1 ))&#13;
     elif [ $winner -eq 0 -a "$answer" = "n" ] ; then&#13;
       echo "You bet that it would not be between the two, and it isn't. WIN!"&#13;
       won=$(( $won + 1 ))&#13;
     else&#13;
       echo "Bad betting strategy. You lose."&#13;
     fi&#13;
&#13;
     games=$(( $games + 1 )) # How many times do you play?&#13;
&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_294"/><a id="ch12ex14"/><em>Listing 12-14: The</em> <code><em>aceydeucey</em></code> <em>script game</em></p>&#13;
<h4 class="h4" id="ch12lev2sec26"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Simulating a deck of shuffled playing cards is not easy. There’s the question of how to portray the cards themselves and of how to “shuffle” or randomly organize an otherwise neatly ordered deck.</p>&#13;
<p class="indent">To address this, we create two arrays of 52 elements: <code>deck[]</code> <span class="ent">➊</span> and <code>newdeck[]</code> <span class="ent">➋</span>. The former is an array of the ordered cards where each value is replaced by a <code>-1</code> as it’s “selected” and put into a random slot of <code>newdeck[]</code>. <span epub:type="pagebreak" id="page_295"/>The <code>newdeck[]</code> array, then, is the “shuffled” deck. While in this game we only ever use the first three cards, the general solution is far more interesting to consider than the specific one.</p>&#13;
<p class="indent">That means this script is overkill. But hey, it’s interesting. <img src="../images/common1.jpg" alt="image"/></p>&#13;
<p class="indent">Let’s step through the functions to see how things work. First off, initializing the deck is really simple, as you can see if you flip back and examine the <code>initializeDeck</code> function.</p>&#13;
<p class="indent">Similarly, <code>shuffleDeck</code> is surprisingly straightforward because all the work is really done in the <code>pickCard</code> function. But <code>shuffleDeck</code> simply steps through the 52 slots in <code>deck[]</code>, randomly picks a value that hasn’t yet been picked, and saves it in the <em>n</em>th array space of <code>newdeck[]</code>.</p>&#13;
<p class="indent">Let’s look at <code>pickCard</code> <span class="ent">➌</span> because that’s where the heavy lifting of the shuffle occurs. The function is broken into two blocks: the first attempts to randomly pick an available card, giving it <code>$threshold</code> tries to succeed. As the function is called again and again, the first calls always succeed at this, but later in the process, once 50 cards are already moved over into the <code>newdeck[]</code>, it’s quite possible that 10 random guesses all yield a fail. That’s the <code>while</code> block of code at <span class="ent">➍</span>.</p>&#13;
<p class="indent">Once <code>$errcount</code> is equal to <code>$threshold</code>, we basically give up on this strategy in the interest of performance and move to the second block of code: stepping through the deck card by card until we find an available card. That’s the block at <span class="ent">➎</span>.</p>&#13;
<p class="indent">If you think about the implications of this strategy, you’ll realize that the lower you set the threshold, the more likely that <code>newdeck</code> will be sequential, particularly later in the deck. At the extreme, <code>threshold = 1</code> would yield an ordered deck where <code>newdeck[]</code> = <code>deck[]</code>. Is 10 the right value? That’s a bit beyond the scope of this book, but we’d welcome email from someone who wanted to experimentally ascertain the best balance of randomness and performance!</p>&#13;
<p class="indent">The <code>showCard</code> function is long, but most of those lines are really just about making the results pretty. The core of the entire deck simulation is captured in the two lines at <span class="ent">➏</span>.</p>&#13;
<p class="indent">For this game, suit is irrelevant, but you can see that for a given card value, the rank is going to be 0–12 and the suit would be 0–3. The cards’ qualities just need to be mapped to user-friendly values. To make debugging easy, a 6 of clubs has a rank 6, and an ace has rank 1. A king has a default rank of 0, but we adjust it to rank 13 so the math works.</p>&#13;
<p class="indent">The <code>dealCards</code> function <span class="ent">➐</span> is where the actual Acey Deucey game comes into play: all the previous functions are dedicated to implementing the useful set of functions for any card game. The <code>dealCards</code> function deals out all three cards required for the game, even though the third card is hidden until after the player places their bet. This just makes life easier—it’s not so that the computer can cheat! Here you can also see that the separately stored rank values (<code>$rank1</code>, <code>$rank2</code>, and <code>$rank3</code>) are fixed for the king = 13 scenario. Also to make life easier, the top two cards are sorted so that the lower-rank card always comes first. That’s the <code>if</code> chunk at <span class="ent">➑</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_296"/>At <span class="ent">➒</span>, it’s time to show what’s dealt. The last step is to present the cards, check whether the ranks match (in which case we’ll skip the prompt that lets the user decide whether to bet), and then test whether the third card is between the first two. This test is done in the code block at <span class="ent">➓</span>.</p>&#13;
<p class="indent">Finally, the result of the bet is tricky. If you bet that the drawn card will be between the first two cards and it is, or you bet that it won’t be and it isn’t, you’re a winner. Otherwise you lose. This result is figured out in the final block.</p>&#13;
<h4 class="h4" id="ch12lev2sec27"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Specify any starting parameter and the game will give you a rudimentary explanation of how to play. Otherwise, you just jump in.</p>&#13;
<p class="indent">Let’s look at the intro in <a href="ch12.xhtml#ch12ex15">Listing 12-15</a>.</p>&#13;
<h4 class="h4" id="ch12lev2sec28"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">aceydeucey intro</span>&#13;
&#13;
Welcome to Acey Deucey. The goal of this game is for you to correctly guess&#13;
whether the third card is going to be between the two cards I'll pull from&#13;
the deck. For example, if I flip up a 5 of hearts and a jack of diamonds,&#13;
you'd bet on whether the next card will have a higher rank than a 5 AND a&#13;
lower rank than a jack (that is, a 6, 7, 8, 9, or 10 of any suit).&#13;
&#13;
Ready? Let's go!&#13;
&#13;
I've dealt:&#13;
   3 of Hearts&#13;
   King of Diamonds&#13;
The spread is 10. Do you think the next card will be between them? (y/n/q) <span class="codestrong">y</span>&#13;
I picked: 4 of Hearts&#13;
You bet that it would be between the two, and it is. WIN!&#13;
&#13;
I've dealt:&#13;
   8 of Clubs&#13;
   10 of Hearts&#13;
The spread is 2. Do you think the next card will be between them? (y/n/q) <span class="codestrong">n</span>&#13;
I picked: 6 of Diamonds&#13;
You bet that it would not be between the two, and it isn't. WIN!&#13;
&#13;
I've dealt:&#13;
   3 of Clubs&#13;
   10 of Spades&#13;
The spread is 7. Do you think the next card will be between them? (y/n/q) <span class="codestrong">y</span>&#13;
I picked: 5 of Clubs&#13;
You bet that it would be between the two, and it is. WIN!&#13;
&#13;
I've dealt:&#13;
   5 of Diamonds&#13;
   Queen of Spades&#13;
The spread is 7. Do you think the next card will be between them? (y/n/q) <span class="codestrong">q</span>&#13;
&#13;
You played 3 games and won 3 times.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_297"/><a id="ch12ex15"/><em>Listing 12-15: Playing the</em> <code><em>aceydeucey</em></code> <em>script game</em></p>&#13;
<h4 class="h4" id="ch12lev2sec29"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There’s the lingering question of whether the deck is shuffled adequately with a threshold of 10; that’s one area that can definitely be improved. It’s also not clear whether showing the spread (the difference between the ranks of the two cards) is beneficial. Certainly you wouldn’t do that in a real game; the player would need to figure it out.</p>&#13;
<p class="indent">Then again, you could go in the opposite direction and calculate the odds of having a card between two arbitrary card values. Let’s think about this: the odds of any given card being drawn is 1 out of 52. If there are 50 cards left in the deck because two have already been dealt, the odds of any given card coming up is 1 out of 50. Since suit is irrelevant, there are 4 out of 50 chances that any different rank comes up. Therefore, the odds of a given spread are (the number of cards in that possible spread × 4) out of 50. If a 5 and a 10 are dealt, the spread is 4, since the possible winning cards are a 6, 7, 8, or 9. So the odds of winning are 4 × 4 out of 50. See what we mean?</p>&#13;
<p class="indent">Finally, as with every command line–based game, the interface could do with some work. We’ll leave that up to you. We’ll also leave you the question of what other games to explore with this handy library of playing-card functions.<span epub:type="pagebreak" id="page_298"/></p>&#13;
</body></html>