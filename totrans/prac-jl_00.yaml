- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*I often feel that the American programmer would profit more from learning,
    say, Latin than from learning yet another programming language.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Edsger Dijkstra
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Julia is a fairly new programming language. It emerged into the public sphere
    in 2012 after two and a half years of research by four computer scientists at
    MIT. Julia’s creators explained why they needed to create a new language: they
    were “greedy.”'
  prefs: []
  type: TYPE_NORMAL
- en: There were already languages that were fast, such as C and Fortran. They were
    well suited to writing programs that ran on giant supercomputers to simulate the
    weather or design airplanes. But their syntax was not the friendliest; programs
    in these languages demanded a certain amount of ceremony. And they didn’t provide
    an interactive experience; one could not improvise and explore at the terminal,
    but had to submit to an edit-compile-run discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Other languages existed that dispensed with ceremony and that one could use
    as interactive calculators, such as Python and MATLAB. However, programs written
    in these languages were slow. Also, such languages often were not well suited
    to keeping large programs organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia’s creators were greedy because they wanted it all: a language that was
    as easy to use as Python but was also as fast as Fortran. The solutions that people
    bolted on to Python (for example) to make it faster often involved rewriting the
    time-consuming parts of their programs in a faster language, such as C. The resulting
    chimera meant maintaining code in two languages, with the resulting organizational,
    personnel, and mental overhead issues. This is called the “two language problem,”
    and one of the motivations behind Julia was to eliminate it.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia is now widely acclaimed as a real solution to the two-language problem.
    In fact, it’s one of only three languages that belong to the “petaflop club,”
    reaching the very top rank of performance on giant number-crunching problems (the
    other two are Fortran and C++). Uniquely, Julia combines this high level of performance
    with the ability to serve as an interactive calculator, whether with its highly
    polished read-eval-print loop (REPL), in development environments of various kinds,
    or in browser-based notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: For those who have worked with Python, Octave, MATLAB, JavaScript using Node,
    or other REPL-based language systems, the Julia experience will be familiar. You
    can simply type `julia` in a terminal, and you’ll see a brief startup message
    and a welcoming interactive prompt. Now you can type expressions and get immediate
    results printed back out on the terminal. You can define variables and functions,
    operate on arrays, import libraries of functions, read data from the disk or the
    network, and generally use the language as a sophisticated calculator. You never
    have to declare the types of variables nor spin any other boilerplate that comes
    between you and your work.
  prefs: []
  type: TYPE_NORMAL
- en: Those are the similarities to other interpreted languages. You’ll also encounter
    some differences. You might notice occasional delays of a few seconds that usually
    don’t occur with languages like Python. This happens because Julia isn’t really
    an interpreted language, but it is doing both pre-compilation of code and just-in-time
    (JIT) compilation behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll discover, this trade-off is worthwhile when your calculations get
    big. Your experience with other interactive languages may cause you to expect
    things to grind to a halt, but you will find, instead, that your code will execute
    with the speed of a compiled language like Fortran.
  prefs: []
  type: TYPE_NORMAL
- en: As you explore further, you’ll discover that Julia is not like other languages
    you may be familiar with. At first, it seems superficially the same. You can type
    `1 + 1` and get `2` back. But you’ll learn that Julia is neither object oriented
    like Python, nor traditionally functional like Haskell, nor is it like whatever
    JavaScript is. The language is organized around a different principle, and that’s
    the source of much of its power.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Is Julia Popular with Scientists?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Julia is organized around something called multiple dispatch, which is enabled
    by a powerful and flexible type system. Later, you’ll learn more about what these
    things mean and how to take advantage of them in your programs. For now, file
    this idea away for future reference: the multiple dispatch system is as important
    a reason as Julia’s famous interactivity and speed for its success in the scientific
    world. While Julia is not the first language to incorporate this feature, it’s
    the first one to combine it with the other virtues that make it genuinely useful
    for the research community.'
  prefs: []
  type: TYPE_NORMAL
- en: It is this design feature that enables an unprecedented level and ease of code
    reuse and recombination. This, as much as any benchmark, is what delights the
    researchers who have adopted Julia as their computational tool. Julia is taking
    off with scientists largely because it allows them to use each other’s code and
    recombine libraries to create new functionalities in ways not envisioned by the
    library’s authors. You’ll see many examples of this in later chapters, especially
    in [Part II](part2.xhtml). You’ll also see how the type system and Julia’s metaprogramming
    abilities allow you to bend the language to fit your problem perfectly, with no
    compromise in performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Will This Book Do for You?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After reading [Part I](part1.xhtml), and whatever interests you in [Part II](part2.xhtml),
    you’ll be able to take full advantage of Julia to solve any computational problem
    that confronts you. You will know how to explore and visualize data, solve equations,
    write simulations, and use and create libraries. The emphasis here is on applying
    Julia to research problems. The approach is direct and practical, with a minimum
    of theoretical computer science. I’ll teach you how to write efficient code that
    runs on a laptop or on large distributed systems. Whether your interest is in
    scientific research, mathematics, statistics, or just fun, you’ll learn how to
    make intelligent use of this tool and how to enjoy doing so.
  prefs: []
  type: TYPE_NORMAL
- en: This book starts at the beginning, assuming that you have never touched Julia.
    I don’t assume any particular knowledge of numerical methods or computational
    techniques, explaining everything of this sort as needed. I assume only that you’ve
    had some contact with basic programming concepts. In other words, when I describe
    how to write an `if` statement in Julia, I’ll expect that you’re familiar, in
    a general sense, with the concept of using conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Use This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The material in [Part I](part1.xhtml) builds sequentially, so, ideally, you’ll
    read those chapters in order. The chapters in [Part II](part2.xhtml), by contrast,
    depend only on the material in [Part I](part1.xhtml), not on each other. You can
    successfully read the biology chapter without looking at the physics chapter.
    Of course, I encourage everyone to read every chapter! Here’s why: some particular
    techniques are developed in application chapters in which they are most likely
    to be relevant. However, due to the nature of scientific research, any bit of
    computational knowledge can potentially find application in any discipline. For
    example, a biologist may find the material in the physics chapter about differential
    equation solvers to be useful in modeling population dynamics. Since the chapters
    in [Part II](part2.xhtml) are not in any particular order, however, it will probably
    be most natural to read the chapter of immediate interest to you first, and return
    to the others at your leisure.'
  prefs: []
  type: TYPE_NORMAL
- en: The book has an extensive index, which should make it easy to root out any subject,
    no matter where it is hiding.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the most out of a book such as this, read it with a Julia prompt
    open, so you can try things out as you encounter them in the text. The hands-on
    approach cements ideas far more effectively than simply reading. As you follow
    along, you’ll find that you want to try out variations of my sample code and learn
    how the language behaves through trial and error. You won’t break anything. If
    you get into a weird state that you don’t know how to fix, you can simply exit
    the REPL and start it up again. In addition, the Julia REPL has a well-implemented
    documentation mode, where you can access all the gruesome details about any particular
    function to supplement what’s in the text.
  prefs: []
  type: TYPE_NORMAL
- en: This book has a companion website at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)
    where you can find runnable versions of all the major code listings in the text,
    datafiles used by the programs, color versions of the illustrations, example animations,
    and videos of simulations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Book Overview**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Part I](part1.xhtml), after the preliminaries dealing with installation
    and the coding environment, we focus on learning Julia: the syntax, data types,
    concepts, and best practices. This part also contains chapters about the module
    and package system and visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1: Getting Started](ch01.xhtml)** Introduces the hardware and experience
    needed for running Julia and benefiting from this book, and provides a guide to
    installation on various operating systems. We also review the most common coding
    environments and end with some recommendations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2: Language Basics](ch02.xhtml)** Provides an introduction to the
    concepts, syntax, and data types of Julia that will equip you with a solid, basic
    understanding of the language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3: Modules and Packages](ch03.xhtml)** Describes how to organize
    your Julia programs, how to incorporate code from others into your work, and how
    you can be a part of the Julia community.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4: The Plotting System](ch04.xhtml)** Concentrates on Julia’s powerful
    `Plots` package. You’ll learn how to make and customize every common type of 2D
    and 3D plot and how to create interactive graphics and finished illustrations
    for publication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5: Collections](ch05.xhtml)** Introduces data types such as sets,
    strings, arrays, dictionaries, structs, and tuples. This chapter covers comprehensions
    and generators, operators over collections, array initialization and manipulation,
    and Julia’s various types of strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6: Functions, Metaprogramming, and Errors](ch06.xhtml)** Delves
    further into functions, treating different ways to define and supply arguments,
    and higher-order functions. It includes an introduction to metaprogramming, involving
    the use of symbols, expression objects, and macros to write code that manipulates
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7: Diagrams and Animations](ch07.xhtml)** Shows how to use a flexible
    and powerful package for mathematical and other diagrams, and a more specialized
    tool for drawing node-and-edge graphs. We’ll explore two packages providing different
    approaches for creating animations, and we’ll use several of these packages in
    later chapters to create illustrations and videos.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8: The Type System](ch08.xhtml)** Covers more details about Julia’s
    different kinds of numbers and other objects, the type hierarchy, type assertions
    and declarations, and how to create our own types. It explains how to use the
    type system in concert with multiple dispatch to organize our programs and the
    connection between types and performance. In addition, a section on plotting recipes
    reveals the unique power of Julia’s plotting system.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II](part2.xhtml) contains chapters devoted to particular fields of research,
    plus a final chapter on parallel processing. Each chapter uses one or more specialized
    packages widely used in an area of application, and tackles at least one interesting
    problem in its specialty.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9: Physics](ch09.xhtml)** Shows how to enrich numbers with units
    and uncertainties, a subject of potential interest to scientists in many fields.
    A detailed example of thermal convection demonstrates how to use a powerful fluid
    dynamics package. The chapter ends with an introduction to a state-of-the-art
    package for solving differential equations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10: Statistics](ch10.xhtml)** Discusses concepts in statistics and
    probability theory, such as distributions, and relates them to functions and types
    provided by relevant Julia packages. It applies these ideas to the simulation
    of the spread of an infection, and it introduces dataframes by slicing and dicing
    real data about COVID cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11: Biology](ch11.xhtml)** Explores agent-based modeling and shows
    how to use Julia’s `Agents` package to simulate the evolution of creatures who
    learn how to avoid being captured by predators. It builds on some ideas from the
    statistics chapter to analyze the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12: Mathematics](ch12.xhtml)** Focuses on symbolic mathematics (computer
    algebra) and linear algebra. It describes two main approaches to the first topic,
    including hybrid numerical-symbolic techniques. It covers the basic use of linear
    algebra packages to solve equations and efficiently perform matrix operations
    by taking advantage of the type system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13: Scientific Machine Learning](ch13.xhtml)** Explores concepts
    and techniques in a relatively new area that exploits ideas from machine learning
    to infer properties of models. It shows how to use automatic differentiation in
    several contexts, and introduces probabilistic programming through Julia’s `Turing`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14: Signal and Image Processing](ch14.xhtml)** Focuses on signals
    and images. The signal section covers Fourier analysis, filtering, and related
    topics, using a bird call as the working example. The image section uses feature
    recognition in the problem of counting blood cells and examines several techniques
    for image resizing, smoothing, and other manipulations. In this context it delves
    further into advanced array concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15: Parallel Processing](ch15.xhtml)** Explains how to run our programs
    on more than one CPU core or computer. The chapter discusses the different concurrency
    paradigms and how to take advantage of multithreading and multiprocessing. We’ll
    see how to run our programs on a network with machines all over the world, with
    no change to the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For details on the inspiration for the Julia language, see “Why We Created
    Julia”: [*https://julialang.org/blog/2012/02/why-we-created-julia/*](https://julialang.org/blog/2012/02/why-we-created-julia/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My article in *Ars Technica*, “The Unreasonable Effectiveness of the Julia
    Programming Language,” explains the underlying reasons for Julia’s wide adoption
    among scientists: [*https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/*](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re a Python programmer and want a very brief rundown of the differences
    in syntax, see “Julia for Python Programmers” by Dr. John D. Cook, at [*http://www.johndcook.com/blog/2015/09/15/julia-for-python-programmers/*](http://www.johndcook.com/blog/2015/09/15/julia-for-python-programmers/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, instead, you come from Lisp, take a look at “A Lisper’s First Impression
    of Julia” by Pascal Costanza at [*https://p-cos.blogspot.com/search?q=first+impression+of+Julia*](https://p-cos.blogspot.com/search?q=first+impression+of+Julia).
    It’s from 2014, but still of interest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the original theoretical justification explaining the need of a new language
    and how Julia’s design decisions meet that need, see “Julia: A Fresh Approach
    to Numerical Computing,” authored by Julia creators Jeff Bezanson, Alan Edelman,
    Stefan Karpinski, and Viral B. Shah ([*http://arxiv.org/abs/1411.1607*](http://arxiv.org/abs/1411.1607)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For another version of Julia’s creation story, see Klint Finley’s “Out in the
    Open: Man Creates One Programming Language to Rule Them All” ([*https://www.wired.com/2014/02/julia/*](https://www.wired.com/2014/02/julia/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Julia Joins Petaflop Club” from Julia Computing is an astronomical (in both
    senses) application of Julia ([*https://cacm.acm.org/news/221003-julia-joins-petaflop-club/fulltext*](https://cacm.acm.org/news/221003-julia-joins-petaflop-club/fulltext)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Julia Update: Adoption Keeps Climbing; Is It a Python Challenger?” by John
    Russell ([*https://www.hpcwire.com/2021/01/13/julia-update-adoption-keeps-climbing-is-it-a-python-challenger/*](https://www.hpcwire.com/2021/01/13/julia-update-adoption-keeps-climbing-is-it-a-python-challenger/))
    provides some interesting historical perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Why I Switched to Julia” by Bradley Setzler is a case study of Julia used
    in econometrics that shows a 100-fold speed increase over Python with NumPy: [*https://juliaeconomics.com/2014/06/15/why-i-started-a-blog-about-programming-julia-for-economics/*](https://juliaeconomics.com/2014/06/15/why-i-started-a-blog-about-programming-julia-for-economics/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
